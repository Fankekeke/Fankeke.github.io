<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue2.0八——知识点整理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue2.0八——知识点整理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/03o5wfvvin9o/",
				"appid": "1613049289050283", 
				"title": "Vue2.0八——知识点整理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-23T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/1ud2on94v6t/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/oa0wb68vy2r/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&text=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&text=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&title=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&is_video=false&description=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&title=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&title=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&title=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f03o5wfvvin9o%2f&title=Vue2.0%e5%85%ab%e2%80%94%e2%80%94%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue2.0八——知识点整理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-23" itemprop="datePublished">2018-12-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e1、active-class是哪个组件的属性？嵌套路由怎么定义？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：vue-router模块的router-link组件。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs perl\x22\x3e\x3ccode\x3e答：vue-router模块的router-\x3cspan class=\x22hljs-keyword\x22\x3elink\x3c\/span\x3e组件。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：在router目录下的index.js文件中，对path属性加上\/:id。  使用router对象的params.id\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3e答：在router目录下的index.js文件中，对path属性加上\/:\x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e。  使用router对象的params.\x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、vue-router有哪几种导航钩子？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，\n作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vbnet\x22\x3e\x3ccode\x3e答：三种，一种是全局导航钩子：router.beforeEach(\x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e)，\n作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4、scss是什么？安装使用的步骤是？有哪几大特性？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：预处理css，把css当前函数编写，定义变量,嵌套。\n 先装css-loader、node-loader、sass-loader等加载器模块，\n 在webpack-base.config.js配置文件中加多一个拓展:extenstion，\n 再加多一个模块：module里面test、loader\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e答：预处理css，把css当前函数编写，定义变量,嵌套。\n 先装css-loader、\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-loader\x3c\/span\x3e、sass-loader等加载器模块，\n 在webpack-base.config.js配置文件中加多一个拓展:extenstion，\n 再加多一个模块：module里面test、loader\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.1、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：css的预编译。\n使用步骤：\n第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）\n第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss\n第三步：还是在同一个文件，配置一个module属性\n第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”\n有哪几大特性:\n1、可以用变量，例如（$变量名称=值）；\n2、可以用混合器，例如（）\n3、可以嵌套\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e答：css的预编译。\n使用步骤：\n第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）\n第二步：在build目录找到webpack\x3cspan class=\x22hljs-selector-class\x22\x3e.base\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.config\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e，在那个extends属性中加一个拓展\x3cspan class=\x22hljs-selector-class\x22\x3e.scss\x3c\/span\x3e\n第三步：还是在同一个文件，配置一个module属性\n第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”\n有哪几大特性:\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、可以用变量，例如（$变量名称=值）；\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、可以用混合器，例如（）\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、可以嵌套\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5、mint-ui是什么？怎么使用？说出至少三个组件使用方法？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：基于vue的前端组件库。npm安装，然后import样式和js，\nvue.use（mintUi）全局引入。在单个组件局部引入：\nimport {Toast} from ‘mint-ui’。组件一：\nToast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e答：基于vue的前端组件库。\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e安装，然后\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e样式和js，\nvue.use（mintUi）全局引入。在单个组件局部引入：\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {Toast} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e ‘mint-ui’。组件一：\nToast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。\nvue的model层的data属性。绑定事件：\x3cinput @click=doLog() \/\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3e答：可以实现双向绑定，指令（v-\x3cspan class=\x22hljs-built_in\x22\x3eclass\x3c\/span\x3e、v-\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e、v-\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e、v-show、v-\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e）。\nvue的model层的data属性。绑定事件：\x26lt;input @click=doLog() \/\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e7、axios是什么？怎么使用？描述使用它实现登录功能的流程？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：请求后台资源的模块。npm install axios -S装好，\n然后发送的是跨域，需在配置文件中config\/index.js进行设置。\n后台如果是Tp5则定义一个资源路由。js中使用import进来，\n然后.get或.post。返回在.then函数中如果成功，\n失败则是在.catch函数中\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e答：请求后台资源的模块。npm install axios -S装好，\n然后发送的是跨域，需在配置文件中\x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e\/index.js进行设置。\n后台如果是Tp5则定义一个资源路由。js中使用\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e进来，\n然后.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e或.post。返回在.then函数中如果成功，\n失败则是在.\x3cspan class=\x22hljs-built_in\x22\x3ecatch\x3c\/span\x3e函数中\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e8、axios\x2btp5进阶中，调用axios.post(‘api\/user’)是进行的什么操作？axios.put(‘api\/user\/8′)呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：跨域，添加用户操作，更新操作。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e答：跨域，添加用户操作，更新操作。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e9、什么是RESTful API？怎么使用?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：是一个api的标准，无状态请求。请求的路由地址是固定的，\n如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e答：是一个api的标准，无状态请求。请求的路由地址是固定的，\n如果是tp5则先路由配置中把资源路由配置好。标准有：\x3cspan class=\x22hljs-selector-class\x22\x3e.post\x3c\/span\x3e \x3cspan class=\x22hljs-selector-class\x22\x3e.put\x3c\/span\x3e \x3cspan class=\x22hljs-selector-class\x22\x3e.delete\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e10、vuex是什么？怎么使用？哪种功能场景使用它？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：vue框架中状态管理。在main.js引入store，注入。\n新建了一个目录store，….. export 。\n场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e答：vue框架中状态管理。在main.js引入store，注入。\n新建了一个目录store，….. \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e 。\n场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：一个model\x2bview\x2bviewModel框架，数据模型model，viewModel连接两个\n区别：vue数据驱动，通过数据来显示视图层而不是节点操作。\n场景：数据操作比较多的场景，更加便捷\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stan\x22\x3e\x3ccode\x3e答：一个\x3cspan class=\x22hljs-title\x22\x3emodel\x3c\/span\x3e\x2bview\x2bviewModel框架，数据模型\x3cspan class=\x22hljs-title\x22\x3emodel\x3c\/span\x3e，viewModel连接两个\n区别：vue数据驱动，通过数据来显示视图层而不是节点操作。\n场景：数据操作比较多的场景，更加便捷\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives\n钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）\n钩子函数参数：el、binding\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e答：全局定义指令：在vue对象的\x3cspan class=\x22hljs-keyword\x22\x3edirective方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives\n\x3c\/span\x3e钩子函数：\x3cspan class=\x22hljs-keyword\x22\x3ebind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）\n\x3c\/span\x3e钩子函数参数：el、\x3cspan class=\x22hljs-keyword\x22\x3ebinding\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e13、说出至少4种vue当中的指令和它的用法？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e答：v-\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e：判断是否隐藏；v-\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e：数据循环出来；v-bind:\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e：绑定一个属性；\x3cspan class=\x22hljs-title\x22\x3ev\x3c\/span\x3e-\x3cspan class=\x22hljs-title\x22\x3emodel\x3c\/span\x3e：实现双向绑定\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e14、vue-router是什么？它有哪些组件？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：vue用来写路由一个插件。router-link、router-view\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cos\x22\x3e\x3ccode\x3e答：vue用来写路由一个插件。router-link、router-\x3cspan class=\x22hljs-keyword\x22\x3eview\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e15、导航钩子有哪些？它们有哪些参数？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：导航钩子有：a\/全局钩子和组件内独享的钩子。b\/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave\n参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3e答：导航钩子有：a\x3cspan class=\x22hljs-regexp\x22\x3e\/全局钩子和组件内独享的钩子。b\/\x3c\/span\x3ebeforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave\n参数：有to（去的那个路由）、\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e（离开的路由）、\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e16、Vue的双向数据绑定原理是什么？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n具体步骤：\n第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter\n这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:\n1、在自身实例化时往属性订阅器(dep)里面添加自己\n2、自身必须有一个update()方法\n3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\x3e 视图更新；视图交互变化(input) -\x3e 数据model变更的双向绑定效果。\nps：16题答案同样适合”vue data是怎么实现的？”此面试题。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gauss\x22\x3e\x3ccode\x3e答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n具体步骤：\n第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter\n这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n第二步：\x3cspan class=\x22hljs-keyword\x22\x3ecompile\x3c\/span\x3e解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n第三步：Watcher订阅者是Observer和\x3cspan class=\x22hljs-keyword\x22\x3eCompile\x3c\/span\x3e之间通信的桥梁，主要做的事情是:\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、在自身实例化时往属性订阅器(dep)里面添加自己\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、自身必须有一个update()方法\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发\x3cspan class=\x22hljs-keyword\x22\x3eCompile\x3c\/span\x3e中绑定的回调，则功成身退。\n第四步：MVVM作为数据绑定的入口，整合Observer、\x3cspan class=\x22hljs-keyword\x22\x3eCompile\x3c\/span\x3e和Watcher三者，通过Observer来监听自己的model数据变化，通过\x3cspan class=\x22hljs-keyword\x22\x3eCompile\x3c\/span\x3e来解析编译模板指令，最终利用Watcher搭起Observer和\x3cspan class=\x22hljs-keyword\x22\x3eCompile\x3c\/span\x3e之间的通信桥梁，达到数据变化 -\x26gt; 视图更新；视图交互变化(input) -\x26gt; 数据model变更的双向绑定效果。\nps：\x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e题答案同样适合”vue data是怎么实现的？”此面试题。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e17、请详细说下你对vue生命周期的理解？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：总共分为8个阶段创建前\/后，载入前\/后，更新前\/后，销毁前\/后。\n创建前\/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。\n载入前\/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。\n更新前\/后：当data变化时，会触发beforeUpdate和updated方法。\n销毁前\/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e答：总共分为\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e个阶段创建前\/后，载入前\/后，更新前\/后，销毁前\/后。\n创建前\/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e都为undefined，还未初始化。在created阶段，vue实例的数据对象\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e有了，$el还没有。\x3c\/span\x3e\n载入前\/后：在beforeMount阶段，vue实例的$el和\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e都初始化了，但还是挂载之前为虚拟的dom节点，\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.message还未替换。在mounted阶段，vue实例挂载完成，\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.message成功渲染。\x3c\/span\x3e\n更新前\/后：当\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e变化时，会触发beforeUpdate和updated方法。\x3c\/span\x3e\n销毁前\/后：在执行destroy方法后，对\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e18、请说下封装 vue 组件的过程？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n然后，使用\x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.extend\x3c\/span\x3e方法创建一个组件，然后使用\x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.component\x3c\/span\x3e方法注册组件。子组件需要数据，可以在\x3cspan class=\x22hljs-selector-tag\x22\x3eprops\x3c\/span\x3e中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用\x3cspan class=\x22hljs-selector-tag\x22\x3eemit\x3c\/span\x3e方法。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e19、你是怎么认识vuex的？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。\n通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。\n应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode\x3e答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有\x3cspan class=\x22hljs-keyword\x22\x3espring\x3c\/span\x3e等。\n通过状态（数据源）集中管理驱动组件的变化（好比\x3cspan class=\x22hljs-keyword\x22\x3espring\x3c\/span\x3e的IOC容器对bean进行集中管理）。\n应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e20、vue-loader是什么？使用它的用途有哪些？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：解析.vue文件的一个加载器，跟template\/js\/style转换成js模块。\n用途：js可以写es6、style样式可以scss或less、template可以加jade等\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs x86asm\x22\x3e\x3ccode\x3e答：解析.vue文件的一个加载器，跟template\/\x3cspan class=\x22hljs-keyword\x22\x3ejs\x3c\/span\x3e\/style转换成\x3cspan class=\x22hljs-keyword\x22\x3ejs\x3c\/span\x3e模块。\n用途：\x3cspan class=\x22hljs-keyword\x22\x3ejs\x3c\/span\x3e可以写es6、style样式可以scss或less、template可以加jade等\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e21、请说出vue.cli项目中src目录每个文件夹和文件的用法？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e答：\x3cspan class=\x22hljs-selector-tag\x22\x3eassets\x3c\/span\x3e文件夹是放静态资源；\x3cspan class=\x22hljs-selector-tag\x22\x3ecomponents\x3c\/span\x3e是放组件；\x3cspan class=\x22hljs-selector-tag\x22\x3erouter\x3c\/span\x3e是定义路由相关的配置;\x3cspan class=\x22hljs-selector-tag\x22\x3eview\x3c\/span\x3e视图；\x3cspan class=\x22hljs-selector-tag\x22\x3eapp\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.vue\x3c\/span\x3e是一个应用主组件；\x3cspan class=\x22hljs-selector-tag\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e是入口文件\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {\n第二步：在需要用的页面（组件）中导入：import smithButton from ‘..\/components\/smithButton.vue’\n第三步：注入到vue的子组件的components属性上面,components:{smithButton}\n第四步：在template视图view中使用，\x3csmith-button\x3e  \x3c\/smith-button\x3e\n问题有：smithButton命名，使用的时候则smith-button。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e答：第一步：在components目录新建你的组件文件（\x3cspan class=\x22hljs-keyword\x22\x3esmithButton.vue），script一定要export \x3c\/span\x3edefault {\n第二步：在需要用的页面（组件）中导入：\x3cspan class=\x22hljs-meta\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esmithButton \x3c\/span\x3efrom ‘..\/components\/\x3cspan class=\x22hljs-keyword\x22\x3esmithButton.vue’\n\x3c\/span\x3e第三步：注入到vue的子组件的components属性上面,components:{\x3cspan class=\x22hljs-keyword\x22\x3esmithButton}\n\x3c\/span\x3e第四步：在template视图view中使用，\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3esmith-button\x26gt; \x3c\/span\x3e \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3esmith-button\x26gt;\n\x3c\/span\x3e问题有：\x3cspan class=\x22hljs-keyword\x22\x3esmithButton命名，使用的时候则smith-button。\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e23、聊聊你对Vue.js的template编译的理解？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）\n详情步骤：\n首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。\n然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs verilog\x22\x3e\x3ccode\x3e答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）\n详情步骤：\n首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。\n然后，AST会经过\x3cspan class=\x22hljs-keyword\x22\x3egenerate\x3c\/span\x3e（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e24、vue的组件是怎么定义的？父组件怎么给子组件传值？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：首先注册vue.components，第一个参数是组件名称，第二个参数是选项。\n直接绑定一个属性，然后在子组件props里面接收\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e答：首先注册vue.\x3cspan class=\x22hljs-built_in\x22\x3ecomponents\x3c\/span\x3e，第一个参数是组件名称，第二个参数是选项。\n直接绑定一个属性，然后在子组件\x3cspan class=\x22hljs-built_in\x22\x3eprops\x3c\/span\x3e里面接收\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e25、使用过element.ui吗？说下它其中两个组件的使用方法？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它\n的间距，后面也是跟数字，也是从24份里面取的。\ninput按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default\n（默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs verilog\x22\x3e\x3ccode\x3e答：使用过用过一个布局的，它是由\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e份，它的写法是:span后面带的数字它占\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e份里面的宽度。:offset是它\n的间距，后面也是跟数字，也是从\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e份里面取的。\n\x3cspan class=\x22hljs-keyword\x22\x3einput\x3c\/span\x3e按钮，标签是el-\x3cspan class=\x22hljs-keyword\x22\x3einput\x3c\/span\x3e，后面\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e跟上一个属性就是显示不同按钮的类型，有默认的\x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e\n（默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e26、说下你对mvvm的理解？双向绑定的理解?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：mvvm就是vm框架视图、m模型就是用来定义驱动的数据、v经过数据改变后的html、vm就是用来实现双向绑定\n    双向绑定:一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3e答：mvvm就是\x3cspan class=\x22hljs-keyword\x22\x3evm\x3c\/span\x3e框架视图、\x3cspan class=\x22hljs-keyword\x22\x3em\x3c\/span\x3e模型就是用来定义驱动的数据、v经过数据改变后的html、\x3cspan class=\x22hljs-keyword\x22\x3evm\x3c\/span\x3e就是用来实现双向绑定\n    双向绑定:一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e27、说出你所使用过的vue指令\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：v-on（监听事件、@change、@click）、v-if（判断的）、v-show（显示\/隐藏）、v-bind（绑定属性、:disabled、:src）\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ruby\x22\x3e\x3ccode\x3e答：v-on（监听事件、@change、@click）、v-\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e（判断的）、v-show（显示\/隐藏）、v-bind（绑定属性、\x3cspan class=\x22hljs-symbol\x22\x3e:disabled\x3c\/span\x3e、\x3cspan class=\x22hljs-symbol\x22\x3e:src\x3c\/span\x3e）\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e28、你觉得怎样的自定义组件是完善的？至少说出4点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：第一点、可以通用\n第二点、代码尽量简洁\n第三点、容易修改\n第四点、功能要多一点 \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e答：第一点、可以通用\n第二点、代码尽量简洁\n第三点、容易修改\n第四点、功能要多一点 \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一、请说下具体使用vue的理解？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。\n2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n4、js的代码无形的规范，团队合作开发代码可阅读性更高。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e答：\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e、js的代码无形的规范，团队合作开发代码可阅读性更高。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e二、你觉得哪些项目适合vue框架？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。\n2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli\x2bwebpack后的前端目录，非常有利于项目的跨平台部署。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e答：\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、数据信息量比较多的，反之类似企业网站就无需此框架了。\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、手机web和app应用多端共用一套界面的项目，因为使用vue.cli\x2bwebpack后的前端目录，非常有利于项目的跨平台部署。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e三、怎么理解MVVM模式的这些框架？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：1、M就是Model模型层，存的一个数据对象。\n2、V就是View视图层，所有的html节点在这一层。\n3、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e答：\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、M就是Model模型层，存的一个数据对象。\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、V就是View视图层，所有的html节点在这一层。\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e四、PC端项目你会在哪些场景使用Vue框架？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。\n那么vue为什么解决这些问题呢？\n第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。\n第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作\x3cspan class=\x22hljs-keyword\x22\x3ejs和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。\n\x3c\/span\x3e那么vue为什么解决这些问题呢？\n第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在\x3cspan class=\x22hljs-keyword\x22\x3ejs和html两个地方。\n\x3c\/span\x3e第二：vue通过Virtual Dom就是在\x3cspan class=\x22hljs-keyword\x22\x3ejs中模拟DOM对象树来优化DOM操作。\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3evuex\x3cbr\x3e1、vuex有哪几种属性？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：有五种，分别是 State、 Getter、Mutation 、Action、 Module\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e答：有五种，分别是 State、 Getter、Mutation 、\x3cspan class=\x22hljs-keyword\x22\x3eAction\x3c\/span\x3e、 \x3cspan class=\x22hljs-keyword\x22\x3eModule\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、vuex的State特性是？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data\n二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\n三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e答：\n一、Vuex就是一个仓库，仓库里面放了很多对象。其中\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e就是数据源存放地，对应于与一般Vue对象里面的data\n二、\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\n三、它通过mapState把全局的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 和 getters 映射到当前组件的 computed 计算属性中\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、vuex的Getter特性是？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、getters 可以对State进行计算操作，它就是Store的计算属性\n二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\n三、 如果一个状态只在一个组件内使用，是可以不用getters\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e答：\n一、getters 可以对State进行计算操作，它就是Store的计算属性\n二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\n三、 如果一个状态只在一个组件内使用，是可以不用getters\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4、vuex的Mutation特性是？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、Action 类似于 mutation，不同在于：\n二、Action 提交的是 mutation，而不是直接变更状态。\n三、Action 可以包含任意异步操作\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3e答：\n一、\x3cspan class=\x22hljs-keyword\x22\x3eAction\x3c\/span\x3e 类似于 mutation，不同在于：\n二、\x3cspan class=\x22hljs-keyword\x22\x3eAction\x3c\/span\x3e 提交的是 mutation，而不是直接变更状态。\n三、\x3cspan class=\x22hljs-keyword\x22\x3eAction\x3c\/span\x3e 可以包含任意异步操作\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。\n二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e答：\n一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e里。\n二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e6、不用Vuex会带来什么问题？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、可维护性会下降，你要想修改数据，你得维护三个地方\n二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的\n三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vhdl\x22\x3e\x3ccode\x3e答：\n一、可维护性会下降，你要想修改数据，你得维护三个地方\n二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的\n三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用\x3cspan class=\x22hljs-keyword\x22\x3eComponent\x3c\/span\x3e就是为了减少耦合，现在这么用，和组件化的初衷相背。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生命周期\x3cbr\x3e1、什么是vue生命周期？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、vue生命周期的作用是什么？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、vue生命周期总共有几个阶段？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：它可以总共分为8个阶段：创建前\/后, 载入前\/后,更新前\/后,销毁前\/销毁后\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode\x3e答：它可以总共分为\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e个阶段：创建前\x3cspan class=\x22hljs-regexp\x22\x3e\/后, 载入前\/\x3c\/span\x3e后,更新前\x3cspan class=\x22hljs-regexp\x22\x3e\/后,销毁前\/\x3c\/span\x3e销毁后\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4、第一次页面加载会触发哪几个钩子？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e答：第一次页面加载时会触发 \x3cspan class=\x22hljs-keyword\x22\x3ebeforeCreate, \x3c\/span\x3ecreated, \x3cspan class=\x22hljs-keyword\x22\x3ebeforeMount, \x3c\/span\x3emounted 这几个钩子\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5、DOM 渲染在 哪个周期中就已经完成？\x3cbr\x3e答：DOM 渲染在 mounted 中就已经完成了。\x3c\/p\x3e\n\x3cp\x3e6、简单描述每个周期具体适合哪些场景？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个\x3cspan class=\x22hljs-type\x22\x3eloading\x3c\/span\x3e事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束\x3cspan class=\x22hljs-type\x22\x3eloading\x3c\/span\x3e事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到\x3cspan class=\x22hljs-type\x22\x3eDOM\x3c\/span\x3e节点 updated : 如果对数据统一处理，在这里写上相应函数 \x3cspan class=\x22hljs-type\x22\x3ebeforeDestroy\x3c\/span\x3e : 可以做一个确认停止事件的确认框 \x3cspan class=\x22hljs-type\x22\x3enextTick\x3c\/span\x3e : 更新数据后立即操作\x3cspan class=\x22hljs-type\x22\x3edom\x3c\/span\x3e \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eaxios\x3cbr\x3e1、axios的特点有哪些？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API\n二、它可以拦截请求和响应\n三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据\n四、安全性更高，客户端支持防御 XSRF\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mercury\x22\x3e\x3ccode\x3e答：\n一、Axios 是一个基于 \x3cspan class=\x22hljs-keyword\x22\x3epromise\x3c\/span\x3e 的 HTTP 库，支持\x3cspan class=\x22hljs-keyword\x22\x3epromise\x3c\/span\x3e所有的API\n二、它可以拦截请求和响应\n三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据\n四、安全性更高，客户端支持防御 XSRF\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、axios有哪些常用方法？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n一、axios.get(url[, config])   \/\/get请求用于列表和信息查询\n二、axios.delete(url[, config])  \/\/删除\n三、axios.post(url[, data[, config]])  \/\/post请求用于信息的添加\n四、axios.put(url[, data[, config]])  \/\/更新操作\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e答：\n一、axios.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(url[, \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e])   \x3cspan class=\x22hljs-comment\x22\x3e\/\/get请求用于列表和信息查询\x3c\/span\x3e\n二、axios.\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e(url[, \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e])  \x3cspan class=\x22hljs-comment\x22\x3e\/\/删除\x3c\/span\x3e\n三、axios.post(url[, data[, \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e]])  \x3cspan class=\x22hljs-comment\x22\x3e\/\/post请求用于信息的添加\x3c\/span\x3e\n四、axios.\x3cspan class=\x22hljs-built_in\x22\x3eput\x3c\/span\x3e(url[, data[, \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e]])  \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新操作\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、说下你了解的axios相关配置属性？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22答：\n`url`是用于请求的服务器URL\n\n`method`是创建请求时使用的方法,默认是get\n\n`baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL\n\n`transformRequest`允许在向服务器发送前，修改请求数据，只能用在\x27PUT\x27,\x27POST\x27和\x27PATCH\x27这几个请求方法\n\n`headers`是即将被发送的自定义请求头\nheaders:{\x27X-Requested-With\x27:\x27XMLHttpRequest\x27},\n\n`params`是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象\nparams:{\nID:12345\n},\n\n`auth`表示应该使用HTTP基础验证，并提供凭据\n这将设置一个`Authorization`头，覆写掉现有的任意使用`headers`设置的自定义`Authorization`头\nauth:{\nusername:\x27janedoe\x27,\npassword:\x27s00pers3cret\x27\n},\n\n\x27proxy\x27定义代理服务器的主机名称和端口\n`auth`表示HTTP基础验证应当用于连接代理，并提供凭据\n这将会设置一个`Proxy-Authorization`头，覆写掉已有的通过使用`header`设置的自定义`Proxy-Authorization`头。\nproxy:{\nhost:\x27127.0.0.1\x27,\nport:9000,\nauth::{\nusername:\x27mikeymike\x27,\npassword:\x27rapunz3l\x27\n}\n},\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e答：\n`url`是用于请求的服务器URL\n\n`method`是创建请求时使用的方法,默认是get\n\n`baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL\n\n`transformRequest`允许在向服务器发送前，修改请求数据，只能用在\x3cspan class=\x22hljs-string\x22\x3e\x27PUT\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27POST\x27\x3c\/span\x3e和\x3cspan class=\x22hljs-string\x22\x3e\x27PATCH\x27\x3c\/span\x3e这几个请求方法\n\n`headers`是即将被发送的自定义请求头\nheaders:{\x3cspan class=\x22hljs-string\x22\x3e\x27X-Requested-With\x27\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27XMLHttpRequest\x27\x3c\/span\x3e},\n\n`params`是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象\nparams:{\nID:\x3cspan class=\x22hljs-number\x22\x3e12345\x3c\/span\x3e\n},\n\n`auth`表示应该使用HTTP基础验证，并提供凭据\n这将设置一个`Authorization`头，覆写掉现有的任意使用`headers`设置的自定义`Authorization`头\nauth:{\nusername:\x3cspan class=\x22hljs-string\x22\x3e\x27janedoe\x27\x3c\/span\x3e,\npassword:\x3cspan class=\x22hljs-string\x22\x3e\x27s00pers3cret\x27\x3c\/span\x3e\n},\n\n\x3cspan class=\x22hljs-string\x22\x3e\x27proxy\x27\x3c\/span\x3e定义代理服务器的主机名称和端口\n`auth`表示HTTP基础验证应当用于连接代理，并提供凭据\n这将会设置一个`Proxy-Authorization`头，覆写掉已有的通过使用`header`设置的自定义`Proxy-Authorization`头。\nproxy:{\nhost:\x3cspan class=\x22hljs-string\x22\x3e\x27127.0.0.1\x27\x3c\/span\x3e,\nport:\x3cspan class=\x22hljs-number\x22\x3e9000\x3c\/span\x3e,\nauth::{\nusername:\x3cspan class=\x22hljs-string\x22\x3e\x27mikeymike\x27\x3c\/span\x3e,\npassword:\x3cspan class=\x22hljs-string\x22\x3e\x27rapunz3l\x27\x3c\/span\x3e\n}\n},\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ekeep-alive\x3c\/p\x3e\n\x3cp\x3evue性能\x3c\/p\x3e\n\x3cp\x3epolyfill imort引入并执行 应用场景：页面开始一片空白\x3cbr\x3e1、vue响应式原理？\x3cbr\x3e2、vue-router实现原理？\x3cbr\x3e3、为什么要选vue？与其它框架对比的优势和劣势？\x3cbr\x3e4、vue如何实现父子组件通信，以及非父子组件通信？\x3cbr\x3e5、vuejs与angularjs以及react的区别？\x3cbr\x3e6、vuex是用来做什么的？\x3cbr\x3e7、vue源码结构\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue2.0八——知识点整理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012315822">https://segmentfault.com/a/1190000012315822</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/03o5wfvvin9o/" target="_blank">https://alili.tech/archive/03o5wfvvin9o/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>