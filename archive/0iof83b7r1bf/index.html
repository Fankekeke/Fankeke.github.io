<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="聊一聊我对 React Context 的理解以及应用"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>聊一聊我对 React Context 的理解以及应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/0iof83b7r1bf/",
				"appid": "1613049289050283", 
				"title": "聊一聊我对 React Context 的理解以及应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/sk5oogl3f3s/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/pr17i4ohe9f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&text=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&text=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&title=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&is_video=false&description=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&title=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&title=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&title=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0iof83b7r1bf%2f&title=%e8%81%8a%e4%b8%80%e8%81%8a%e6%88%91%e5%af%b9%20React%20Context%20%e7%9a%84%e7%90%86%e8%a7%a3%e4%bb%a5%e5%8f%8a%e5%ba%94%e7%94%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">聊一聊我对 React Context 的理解以及应用</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eContext\x3c\/code\x3e被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。\x3c\/p\x3e\n\x3cp\x3e在React的官方文档中，\x3ca href=\x22https:\/\/reactjs.org\/docs\/context.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eContext\x3c\/code\x3e\x3c\/a\x3e被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。\x3c\/p\x3e\n\x3cblockquote\x3eThe vast majority of applications do not need to use content.\x3cp\x3eIf you want your application to be stable, don\x27t use context. It is an experimental API and it is likely to break in future releases of React.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e不过，这并非意味着我们不需要关注\x3ccode\x3eContext\x3c\/code\x3e。事实上，很多优秀的React组件都通过Context来完成自己的功能，比如react-redux的\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e，就是通过\x3ccode\x3eContext\x3c\/code\x3e提供一个全局态的\x3ccode\x3estore\x3c\/code\x3e，拖拽组件react-dnd，通过\x3ccode\x3eContext\x3c\/code\x3e在组件中分发DOM的Drag和Drop事件，路由组件react-router通过\x3ccode\x3eContext\x3c\/code\x3e管理路由状态等等。在React组件开发中，如果用好\x3ccode\x3eContext\x3c\/code\x3e，可以让你的组件变得强大，而且灵活。\x3c\/p\x3e\n\x3cp\x3e今天就想跟大家聊一聊，我在开发当中，所认识到的这个\x3ccode\x3eContext\x3c\/code\x3e，以及我是如何使用它来进行组件开发的。\x3c\/p\x3e\n\x3cblockquote\x3e注：本文中所有提到的App皆指Web端App。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初识React Context\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e官方对于Context的定义\x3c\/h3\x3e\n\x3cp\x3eReact文档官网并未对\x3ccode\x3eContext\x3c\/code\x3e给出“是什么”的定义，更多是描述使用的\x3ccode\x3eContext\x3c\/code\x3e的场景，以及如何使用\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e官网对于使用\x3ccode\x3eContext\x3c\/code\x3e的场景是这样描述的：\x3c\/p\x3e\n\x3cblockquote\x3eIn Some Cases, you want to pass data through the component tree without having to pass the props down manuallys at every level. you can do this directly in React with the powerful \x22context\x22 API.\x3c\/blockquote\x3e\n\x3cp\x3e简单说就是，当你不想在组件树中通过逐层传递\x3ccode\x3eprops\x3c\/code\x3e或者\x3ccode\x3estate\x3c\/code\x3e的方式来传递数据时，可以使用\x3ccode\x3eContext\x3c\/code\x3e来实现\x3cstrong\x3e跨层级\x3c\/strong\x3e的组件数据传递。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365879?w=1930\x26amp;h=1000\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365879?w=1930\x26amp;h=1000\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e使用props或者state传递数据，数据自顶下流。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365880?w=1626\x26amp;h=1000\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365880?w=1626\x26amp;h=1000\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e使用\x3ccode\x3eContext\x3c\/code\x3e，可以跨越组件进行数据传递。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e如何使用Context\x3c\/h3\x3e\n\x3cp\x3e如果要\x3ccode\x3eContext\x3c\/code\x3e发挥作用，需要用到两种组件，一个是\x3ccode\x3eContext\x3c\/code\x3e生产者(Provider)，通常是一个父节点，另外是一个\x3ccode\x3eContext\x3c\/code\x3e的消费者(Consumer)，通常是一个或者多个子节点。所以\x3ccode\x3eContext\x3c\/code\x3e的使用基于\x3cstrong\x3e生产者消费者模式\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e对于父组件，也就是\x3ccode\x3eContext\x3c\/code\x3e生产者，需要通过一个静态属性\x3ccode\x3echildContextTypes\x3c\/code\x3e声明提供给子组件的\x3ccode\x3eContext\x3c\/code\x3e对象的属性，并实现一个实例\x3ccode\x3egetChildContext\x3c\/code\x3e方法，返回一个代表\x3ccode\x3eContext\x3c\/code\x3e的纯对象 (plain object) 。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nclass MiddleComponent extends React.Component {\n  render () {\n    return \x3cChildComponent \/\x3e\n  }\n}\n\nclass ParentComponent extends React.Component {\n  \/\/ 声明Context对象属性\n  static childContextTypes = {\n    propA: PropTypes.string,\n    methodA: PropTypes.func\n  }\n  \n  \/\/ 返回Context对象，方法名是约定好的\n  getChildContext () {\n    return {\n      propA: \x27propA\x27,\n      methodA: () =\x3e \x27methodA\x27\n    }\n  }\n  \n  render () {\n    return \x3cMiddleComponent \/\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMiddleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChildComponent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  }\n}\n\nclass ParentComponent extends React.Component {\n  \/\/ 声明Context对象属性\n  static childContextTypes = {\n    propA: PropTypes.string,\n    methodA: PropTypes.func\n  }\n  \n  \/\/ 返回Context对象，方法名是约定好的\n  getChildContext () {\n    return {\n      propA: \x27propA\x27,\n      methodA: () =\x26gt; \x27methodA\x27\n    }\n  }\n  \n  render () {\n    return \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMiddleComponent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而对于\x3ccode\x3eContext\x3c\/code\x3e的消费者，通过如下方式访问父组件提供的\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nclass ChildComponent extends React.Component {\n  \/\/ 声明需要使用的Context属性\n  static contextTypes = {\n    propA: PropTypes.string\n  }\n  \n  render () {\n    const {\n      propA,\n      methodA\n    } = this.context\n    \n    console.log(`context.propA = ${propA}`)  \/\/ context.propA = propA\n    console.log(`context.methodA = ${methodA}`)  \/\/ context.methodA = undefined\n    \n    return ...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChildComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明需要使用的Context属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e contextTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3epropA\x3c\/span\x3e: PropTypes.string\n  }\n  \n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n      propA,\n      methodA\n    } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`context.propA = \x3cspan class=\x22hljs-subst\x22\x3e${propA}\x3c\/span\x3e`\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ context.propA = propA\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`context.methodA = \x3cspan class=\x22hljs-subst\x22\x3e${methodA}\x3c\/span\x3e`\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ context.methodA = undefined\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ...\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e子组件需要通过一个静态属性\x3ccode\x3econtextTypes\x3c\/code\x3e声明后，才能访问父组件\x3ccode\x3eContext\x3c\/code\x3e对象的属性，否则，即使属性名没写错，拿到的对象也是\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e对于无状态子组件(Stateless Component)，可以通过如下方式访问父组件的\x3ccode\x3eContext\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nconst ChildComponent = (props, context) =\x3e {\n  const {\n    propA\n  } = context\n    \n  console.log(`context.propA = ${propA}`)  \/\/ context.propA = propA\n    \n  return ...\n}\n  \nChildComponent.contextProps = {\n  propA: PropTypes.string    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ChildComponent = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops, context\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n    propA\n  } = context\n    \n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`context.propA = \x3cspan class=\x22hljs-subst\x22\x3e${propA}\x3c\/span\x3e`\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ context.propA = propA\x3c\/span\x3e\n    \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ...\n}\n  \nChildComponent.contextProps = {\n  \x3cspan class=\x22hljs-attr\x22\x3epropA\x3c\/span\x3e: PropTypes.string    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而在接下来的发行版本中，React对\x3ccode\x3eContext\x3c\/code\x3e的API做了调整，更加明确了生产者消费者模式的使用方式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\n\nconst ThemeContext = React.createContext({\n  background: \x27red\x27,\n  color: \x27white\x27\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ThemeContext = React.createContext({\n  \x3cspan class=\x22hljs-attr\x22\x3ebackground\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过静态方法\x3ccode\x3eReact.createContext()\x3c\/code\x3e创建一个\x3ccode\x3eContext\x3c\/code\x3e对象，这个\x3ccode\x3eContext\x3c\/code\x3e对象包含两个组件，\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;Consumer \/\x26gt;\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends React.Component {\n  render () {\n    return (\n      \x3cThemeContext.Provider value=\x22{{\x22background: \x27green\x27, color: \x27white\x27\x22}}\x22\x3e\n        \x3cHeader \/\x3e\n      \x3c\/ThemeContext.Provider\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eProvider\x3c\/span\x3e value=\x22{{\x22background: \x3cspan class=\x22hljs-symbol\x22\x3e\x27gree\x3c\/span\x3en\x27, color: \x3cspan class=\x22hljs-symbol\x22\x3e\x27whit\x3c\/span\x3ee\x27\x22}}\x22\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\n      \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eProvider\x3c\/span\x3e\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e的\x3ccode\x3evalue\x3c\/code\x3e相当于现在的\x3ccode\x3egetChildContext()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Header extends React.Component {\n  render () {\n    return (\n      \x3cTitle\x3eHello React Context API\x3c\/Title\x3e\n    );\n  }\n}\n \nclass Title extends React.Component {\n  render () {\n    return (\n      \x3cThemeContext.Consumer\x3e\n        {context =\x3e (\n          \x3ch1 style=\x22{{\x22background: context.background, color: context.color\x22}}\x22\x3e\n            {this.props.children}\n          \x3c\/h1\x3e\n        )}\n      \x3c\/ThemeContext.Consumer\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHeader\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eContext\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eAPI\x3c\/span\x3e\x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e\x26gt;\n    );\n  }\n}\n \n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTitle\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eConsumer\x3c\/span\x3e\x26gt;\n        {context =\x26gt; (\n          \x26lt;h1 style=\x22{{\x22background: context.background, color: context.color\x22}}\x22\x26gt;\n            {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children}\n          \x26lt;\/h1\x26gt;\n        )}\n      \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eConsumer\x3c\/span\x3e\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;Consumer \/\x26gt;\x3c\/code\x3e的\x3ccode\x3echildren\x3c\/code\x3e必须是一个函数，通过函数的参数获取\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e提供的\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e可见，\x3ccode\x3eContext\x3c\/code\x3e的新API更加贴近React的风格。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e几个可以直接获取Context的地方\x3c\/h3\x3e\n\x3cp\x3e实际上，除了实例的\x3ccode\x3econtext\x3c\/code\x3e属性(\x3ccode\x3ethis.context\x3c\/code\x3e)，React组件还有很多个地方可以直接访问父组件提供的\x3ccode\x3eContext\x3c\/code\x3e。比如构造方法：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3ccode\x3econstructor(props, context)\x3c\/code\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e比如生命周期：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillReceiveProps(nextProps, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eshouldComponentUpdate(nextProps, nextState, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ecomponetWillUpdate(nextProps, nextState, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于面向函数的无状态组件，可以通过函数的参数直接访问组件的\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const StatelessComponent = (props, context) =\x3e (\n  ......\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e StatelessComponent = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops, context\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e (\n  ......\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是\x3ccode\x3eContext\x3c\/code\x3e的基础，更具体的指南内容可参见\x3ca href=\x22https:\/\/reactjs.org\/docs\/context.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e我对Context的理解\x3c\/h2\x3e\n\x3cp\x3eOK，说完基础的东西，现在聊一聊我对React的\x3ccode\x3eContext\x3c\/code\x3e的理解。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e把Context当做组件作用域\x3c\/h3\x3e\n\x3cp\x3e使用React的开发者都知道，一个React App本质就是一棵React组件树，每个React组件相当于这棵树上的一个节点，除了App的根节点，其他每个节点都存在一条父组件链。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365881?w=1820\x26amp;h=952\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365881?w=1820\x26amp;h=952\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e例如上图，\x3ccode\x3e\x26lt;Child \/\x26gt;\x3c\/code\x3e的父组件链是\x3ccode\x3e\x26lt;SubNode \/\x26gt;\x3c\/code\x3e -- \x3ccode\x3e\x26lt;Node \/\x26gt;\x3c\/code\x3e -- \x3ccode\x3e\x26lt;App \/\x26gt;\x3c\/code\x3e，\x3ccode\x3e\x26lt;SubNode \/\x26gt;\x3c\/code\x3e的父组件链是\x3ccode\x3e\x26lt;Node \/\x26gt;\x3c\/code\x3e -- \x3ccode\x3e\x26lt;App \/\x26gt;\x3c\/code\x3e，\x3ccode\x3e\x26lt;Node \/\x26gt;\x3c\/code\x3e的父组件链只有一个组件节点，就是\x3ccode\x3e\x26lt;App \/\x26gt;\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这些以树状连接的组件节点，实际上也组成了一棵\x3ccode\x3eContext\x3c\/code\x3e树，每个节点的\x3ccode\x3eContext\x3c\/code\x3e，来自父组件链上所有组件节点通过\x3ccode\x3egetChildContext()\x3c\/code\x3e所提供的\x3ccode\x3eContext\x3c\/code\x3e对象组合而成的对象。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365882?w=2098\x26amp;h=952\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365882?w=2098\x26amp;h=952\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e有了解JS作用域链概念的开发者应该都知道，JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。\x3c\/p\x3e\n\x3cp\x3e假如以JS的作用域链作为类比，React组件提供的\x3ccode\x3eContext\x3c\/code\x3e对象其实就好比一个提供给子组件访问的作用域，而\x3ccode\x3eContext\x3c\/code\x3e对象的属性可以看成作用域上的活动对象。由于组件的\x3ccode\x3eContext\x3c\/code\x3e由其父节点链上所有组件通过\x3ccode\x3egetChildContext()\x3c\/code\x3e返回的\x3ccode\x3eContext\x3c\/code\x3e对象组合而成，所以，组件通过\x3ccode\x3eContext\x3c\/code\x3e是可以访问到其父组件链上所有节点组件提供的\x3ccode\x3eContext\x3c\/code\x3e的属性。\x3c\/p\x3e\n\x3cp\x3e所以，我借鉴了JS作用域链的思路，把\x3ccode\x3eContext\x3c\/code\x3e当成是\x3cstrong\x3e组件的作用域\x3c\/strong\x3e来使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e关注Context的可控性和影响范围\x3c\/h3\x3e\n\x3cp\x3e不过，作为组件作用域来看待的\x3ccode\x3eContext\x3c\/code\x3e与常见的作用域的概念 (就我个人目前接触到的编程语言而言) 是有所区别的。我们需要关注\x3ccode\x3eContext\x3c\/code\x3e的可控性和影响范围。\x3c\/p\x3e\n\x3cp\x3e在我们平时的开发中，用到作用域或者上下文的场景是很常见，很自然，甚至是无感知的，然而，在React中使用\x3ccode\x3eContext\x3c\/code\x3e并不是那么容易。父组件提供\x3ccode\x3eContext\x3c\/code\x3e需要通过\x3ccode\x3echildContextTypes\x3c\/code\x3e进行“声明”，子组件使用父组件的\x3ccode\x3eContext\x3c\/code\x3e属性需要通过\x3ccode\x3econtextTypes\x3c\/code\x3e进行“申请”，所以，我认为React的\x3ccode\x3eContext\x3c\/code\x3e是一种\x3cstrong\x3e“带权限”的组件作用域\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e这种“带权限”的方式有何好处？就我个人的理解，首先是保持框架API的一致性，和\x3ccode\x3epropTypes\x3c\/code\x3e一样，使用声明式编码风格。另外就是，\x3cstrong\x3e可以在一定程度上确保组件所提供的\x3ccode\x3eContext\x3c\/code\x3e的可控性和影响范围\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3eReact App的组件是树状结构，一层一层延伸，父子组件是一对多的线性依赖。随意的使用\x3ccode\x3eContext\x3c\/code\x3e其实会破坏这种依赖关系，导致组件之间一些不必要的额外依赖，降低组件的复用性，进而可能会影响到App的可维护性。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365883?w=1996\x26amp;h=952\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365883?w=1996\x26amp;h=952\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过上图可以看到，原本线性依赖的组件树，由于子组件使用了父组件的\x3ccode\x3eContext\x3c\/code\x3e，导致\x3ccode\x3e\x26lt;Child \/\x26gt;\x3c\/code\x3e组件对\x3ccode\x3e\x26lt;Node \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;App \/\x26gt;\x3c\/code\x3e都产生了依赖关系。一旦脱离了这两个组件，\x3ccode\x3e\x26lt;Child \/\x26gt;\x3c\/code\x3e的可用性就无法保障了，减低了\x3ccode\x3e\x26lt;Child \/\x26gt;\x3c\/code\x3e的复用性。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013365884?w=1762\x26amp;h=956\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013365884?w=1762\x26amp;h=956\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在我看来，\x3cstrong\x3e通过\x3ccode\x3eContext\x3c\/code\x3e暴露数据或者API不是一种优雅的实践方案\x3c\/strong\x3e，尽管react-redux是这么干的。因此需要一种机制，或者说约束，去降低不必要的影响。\x3c\/p\x3e\n\x3cp\x3e通过\x3ccode\x3echildContextTypes\x3c\/code\x3e和\x3ccode\x3econtextTypes\x3c\/code\x3e这两个静态属性的约束，可以在一定程度保障，只有组件自身，或者是与组件相关的其他子组件才可以随心所欲的访问\x3ccode\x3eContext\x3c\/code\x3e的属性，无论是数据还是函数。因为只有组件自身或者相关的子组件可以清楚它能访问\x3ccode\x3eContext\x3c\/code\x3e哪些属性，而相对于那些与组件无关的其他组件，无论是内部或者外部的 ，由于不清楚父组件链上各父组件的\x3ccode\x3echildContextTypes\x3c\/code\x3e“声明”了哪些\x3ccode\x3eContext\x3c\/code\x3e属性，所以没法通过\x3ccode\x3econtextTypes\x3c\/code\x3e“申请”相关的属性。所以我理解为，给组件的作用域\x3ccode\x3eContext\x3c\/code\x3e“带权限”，可以在一定程度上确保\x3ccode\x3eContext\x3c\/code\x3e的可控性和影响范围。\x3c\/p\x3e\n\x3cp\x3e在开发组件过程中，我们应该时刻关注这一点，不要随意的使用\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e不需要优先使用Context\x3c\/h3\x3e\n\x3cp\x3e作为React的高级API，React并\x3ca href=\x22https:\/\/reactjs.org\/docs\/context.html#why-not-to-use-context\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不推荐我们优先考虑使用\x3ccode\x3eContext\x3c\/code\x3e\x3c\/a\x3e。我的理解是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eContext\x3c\/code\x3e目前还处于实验阶段，可能会在后面的发行版本中有大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来较大影响和麻烦，不建议在App中使用\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e尽管不建议在App中使用\x3ccode\x3eContext\x3c\/code\x3e，但对于组件而言，由于影响范围小于App，如果可以做到高内聚，不破坏组件树的依赖关系，那么还是可以考虑使用\x3ccode\x3eContext\x3c\/code\x3e的。\x3c\/li\x3e\n\x3cli\x3e对于组件之间的数据通信或者状态管理，优先考虑用\x3ccode\x3eprops\x3c\/code\x3e或者\x3ccode\x3estate\x3c\/code\x3e解决，然后再考虑用其他第三方成熟库解决的，以上方法都不是最佳选择的时候，那么再考虑使用\x3ccode\x3eContext\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eContext\x3c\/code\x3e的更新需要通过\x3ccode\x3esetState()\x3c\/code\x3e触发，但是这并不是可靠的。\x3ccode\x3eContext\x3c\/code\x3e支持跨组件访问，但是，如果中间的子组件通过一些方法不响应更新，比如\x3ccode\x3eshouldComponentUpdate()\x3c\/code\x3e返回\x3ccode\x3efalse\x3c\/code\x3e，那么不能保证\x3ccode\x3eContext\x3c\/code\x3e的更新一定可达使用\x3ccode\x3eContext\x3c\/code\x3e的子组件。因此，\x3ccode\x3eContext\x3c\/code\x3e的可靠性需要关注。不过更新的问题，在新版的API中得以解决。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e简而言之，只要你能确保\x3ccode\x3eContext\x3c\/code\x3e是可控的，使用\x3ccode\x3eContext\x3c\/code\x3e并无大碍，甚至如果能够合理的应用，\x3ccode\x3eContext\x3c\/code\x3e其实可以给React组件开发带来很强大的体验。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e用Context作为共享数据的媒介\x3c\/h3\x3e\n\x3cp\x3e官方所提到\x3ccode\x3eContext\x3c\/code\x3e可以用来进行跨组件的数据通信。而我，把它理解为，好比一座桥，作为一种作为媒介进行\x3cstrong\x3e数据共享\x3c\/strong\x3e。数据共享可以分两类：\x3cstrong\x3eApp级\x3c\/strong\x3e与\x3cstrong\x3e组件级\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cstrong\x3eApp级的数据共享\x3c\/strong\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eApp根节点组件提供的\x3ccode\x3eContext\x3c\/code\x3e对象可以看成是App级的全局作用域，所以，我们利用App根节点组件提供的\x3ccode\x3eContext\x3c\/code\x3e对象创建一些App级的全局数据。现成的例子可以参考react-redux，以下是\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e组件源码的核心实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function createProvider(storeKey = \x27store\x27, subKey) {\n    const subscriptionKey = subKey || `${storeKey}Subscription`\n\n    class Provider extends Component {\n        getChildContext() {\n          return { [storeKey]: this[storeKey], [subscriptionKey]: null }\n        }\n\n        constructor(props, context) {\n          super(props, context)\n          this[storeKey] = props.store;\n        }\n\n        render() {\n          return Children.only(this.props.children)\n        }\n    }\n\n    \/\/ ......\n\n    Provider.propTypes = {\n        store: storeShape.isRequired,\n        children: PropTypes.element.isRequired,\n    }\n    Provider.childContextTypes = {\n        [storeKey]: storeShape.isRequired,\n        [subscriptionKey]: subscriptionShape,\n    }\n\n    return Provider\n}\n\nexport default createProvider()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateProvider\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estoreKey = \x3cspan class=\x22hljs-string\x22\x3e\x27store\x27\x3c\/span\x3e, subKey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e subscriptionKey = subKey || \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${storeKey}\x3c\/span\x3eSubscription`\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        getChildContext() {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { [storeKey]: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[storeKey], [subscriptionKey]: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e }\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n          \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context)\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[storeKey] = props.store;\n        }\n\n        render() {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Children.only(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children)\n        }\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n\n    Provider.propTypes = {\n        \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: storeShape.isRequired,\n        \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: PropTypes.element.isRequired,\n    }\n    Provider.childContextTypes = {\n        [storeKey]: storeShape.isRequired,\n        [subscriptionKey]: subscriptionShape,\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Provider\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e createProvider()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eApp的根组件用\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e组件包裹后，本质上就为App提供了一个全局的属性\x3ccode\x3estore\x3c\/code\x3e，相当于在整个App范围内，共享\x3ccode\x3estore\x3c\/code\x3e属性。当然，\x3ccode\x3e\x26lt;Provider \/\x26gt;\x3c\/code\x3e组件也可以包裹在其他组件中，在组件级的全局范围内共享\x3ccode\x3estore\x3c\/code\x3e。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cstrong\x3e组件级的数据共享\x3c\/strong\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e如果组件的功能不能单靠组件自身来完成，还需要依赖额外的子组件，那么可以利用\x3ccode\x3eContext\x3c\/code\x3e构建一个由多个子组件组合的组件。例如，react-router。\x3c\/p\x3e\n\x3cp\x3ereact-router的\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e自身并不能独立完成路由的操作和管理，因为导航链接和跳转的内容通常是分离的，因此还需要依赖\x3ccode\x3e\x26lt;Link \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;Route \/\x26gt;\x3c\/code\x3e等子组件来一同完成路由的相关工作。为了让相关的子组件一同发挥作用，react-router的实现方案是利用\x3ccode\x3eContext\x3c\/code\x3e在\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e、\x3ccode\x3e\x26lt;Link \/\x26gt;\x3c\/code\x3e以及\x3ccode\x3e\x26lt;Route \/\x26gt;\x3c\/code\x3e这些相关的组件之间共享一个\x3ccode\x3erouter\x3c\/code\x3e，进而完成路由的统一操作和管理。\x3c\/p\x3e\n\x3cp\x3e下面截取\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e、\x3ccode\x3e\x26lt;Link \/\x26gt;\x3c\/code\x3e以及\x3ccode\x3e\x26lt;Route \/\x26gt;\x3c\/code\x3e这些相关的组件部分源码，以便更好的理解上述所说的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Router.js\n\n\/**\n * The public API for putting history on context.\n *\/\nclass Router extends React.Component {\n  static propTypes = {\n    history: PropTypes.object.isRequired,\n    children: PropTypes.node\n  };\n\n  static contextTypes = {\n    router: PropTypes.object\n  };\n\n  static childContextTypes = {\n    router: PropTypes.object.isRequired\n  };\n\n  getChildContext() {\n    return {\n      router: {\n        ...this.context.router,\n        history: this.props.history,\n        route: {\n          location: this.props.history.location,\n          match: this.state.match\n        }\n      }\n    };\n  }\n  \n  \/\/ ......\n  \n  componentWillMount() {\n    const { children, history } = this.props;\n    \n    \/\/ ......\n    \n    this.unlisten = history.listen(() =\x3e {\n      this.setState({\n        match: this.computeMatch(history.location.pathname)\n      });\n    });\n  }\n\n  \/\/ ......\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Router.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * The public API for putting history on context.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRouter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static propTypes = {\n    history: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e.isRequired,\n    children: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.node\n  };\n\n  static contextTypes = {\n    router: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  };\n\n  static childContextTypes = {\n    router: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e.isRequired\n  };\n\n  getChildContext() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      router: {\n        ...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router,\n        history: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.history,\n        route: {\n          location: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.history.location,\n          \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.\x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e\n        }\n      }\n    };\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n  \n  componentWillMount() {\n    const { children, history } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.unlisten = history.listen(() =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.computeMatch(history.location.pathname)\n      });\n    });\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管源码还有其他的逻辑，但\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e的核心就是为子组件提供一个带有\x3ccode\x3erouter\x3c\/code\x3e属性的\x3ccode\x3eContext\x3c\/code\x3e，同时监听\x3ccode\x3ehistory\x3c\/code\x3e，一旦\x3ccode\x3ehistory\x3c\/code\x3e发生变化，便通过\x3ccode\x3esetState()\x3c\/code\x3e触发组件重新渲染。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Link.js\n\n\/**\n * The public API for rendering a history-aware \x3ca\x3e.\n *\/\nclass Link extends React.Component {\n  \n  \/\/ ......\n  \n  static contextTypes = {\n    router: PropTypes.shape({\n      history: PropTypes.shape({\n        push: PropTypes.func.isRequired,\n        replace: PropTypes.func.isRequired,\n        createHref: PropTypes.func.isRequired\n      }).isRequired\n    }).isRequired\n  };\n\n  handleClick = event =\x3e {\n    if (this.props.onClick) this.props.onClick(event);\n\n    if (\n      !event.defaultPrevented \x26amp;\x26amp;\n      event.button === 0 \x26amp;\x26amp;\n      !this.props.target \x26amp;\x26amp;\n      !isModifiedEvent(event)\n    ) {\n      event.preventDefault();\n      \/\/ 使用\x3cRouter \/\x3e组件提供的router实例\n      const { history } = this.context.router;\n      const { replace, to } = this.props;\n\n      if (replace) {\n        history.replace(to);\n      } else {\n        history.push(to);\n      }\n    }\n  };\n  \n  render() {\n    const { replace, to, innerRef, ...props } = this.props;\n\n    \/\/ ...\n\n    const { history } = this.context.router;\n    const location =\n      typeof to === \x26quot;string\x26quot;\n        ? createLocation(to, null, null, history.location)\n        : to;\n\n    const href = history.createHref(location);\n    return (\n      \x3ca {...props} onClick={this.handleClick} href={href} ref={innerRef} \/\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Link.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * The public API for rendering a history-aware \x26lt;a\x26gt;.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e contextTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3erouter\x3c\/span\x3e: PropTypes.shape({\n      \x3cspan class=\x22hljs-attr\x22\x3ehistory\x3c\/span\x3e: PropTypes.shape({\n        \x3cspan class=\x22hljs-attr\x22\x3epush\x3c\/span\x3e: PropTypes.func.isRequired,\n        \x3cspan class=\x22hljs-attr\x22\x3ereplace\x3c\/span\x3e: PropTypes.func.isRequired,\n        \x3cspan class=\x22hljs-attr\x22\x3ecreateHref\x3c\/span\x3e: PropTypes.func.isRequired\n      }).isRequired\n    }).isRequired\n  };\n\n  handleClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onClick) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onClick(event);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      !event.defaultPrevented \x26amp;\x26amp;\n      event.button === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp;\n      !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.target \x26amp;\x26amp;\n      !isModifiedEvent(event)\n    ) {\n      event.preventDefault();\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用\x26lt;Router \/\x26gt;组件提供的router实例\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { history } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router;\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { replace, to } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (replace) {\n        history.replace(to);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        history.push(to);\n      }\n    }\n  };\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { replace, to, innerRef, ...props } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { history } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e location =\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e to === \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e\n        ? createLocation(to, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, history.location)\n        : to;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e href = history.createHref(location);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...props\x3c\/span\x3e} \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleClick}\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{href}\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{innerRef}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    );\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;Link \/\x26gt;\x3c\/code\x3e的核心就是渲染\x3ccode\x3e\x26lt;a\x26gt;\x3c\/code\x3e标签，拦截\x3ccode\x3e\x26lt;a\x26gt;\x3c\/code\x3e标签的点击事件，然后通过\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e共享的\x3ccode\x3erouter\x3c\/code\x3e对\x3ccode\x3ehistory\x3c\/code\x3e进行路由操作，进而通知\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e重新渲染。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Route.js\n\n\/**\n * The public API for matching a single path and rendering.\n *\/\nclass Route extends React.Component {\n  \n  \/\/ ......\n  \n  state = {\n    match: this.computeMatch(this.props, this.context.router)\n  };\n\n  \/\/ 计算匹配的路径，匹配的话，会返回一个匹配对象，否则返回null\n  computeMatch(\n    { computedMatch, location, path, strict, exact, sensitive },\n    router\n  ) {\n    if (computedMatch) return computedMatch;\n    \n    \/\/ ......\n\n    const { route } = router;\n    const pathname = (location || route.location).pathname;\n    \n    return matchPath(pathname, { path, strict, exact, sensitive }, route.match);\n  }\n \n  \/\/ ......\n\n  render() {\n    const { match } = this.state;\n    const { children, component, render } = this.props;\n    const { history, route, staticContext } = this.context.router;\n    const location = this.props.location || route.location;\n    const props = { match, location, history, staticContext };\n\n    if (component) return match ? React.createElement(component, props) : null;\n\n    if (render) return match ? render(props) : null;\n\n    if (typeof children === \x26quot;function\x26quot;) return children(props);\n\n    if (children \x26amp;\x26amp; !isEmptyChildren(children))\n      return React.Children.only(children);\n\n    return null;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Route.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * The public API for matching a single path and rendering.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n  \n  state = {\n    \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.computeMatch(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router)\n  };\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算匹配的路径，匹配的话，会返回一个匹配对象，否则返回null\x3c\/span\x3e\n  computeMatch(\n    { computedMatch, location, path, strict, exact, sensitive },\n    router\n  ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (computedMatch) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e computedMatch;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n\n    const { route } = router;\n    const pathname = (location || route.location).pathname;\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e matchPath(pathname, { path, strict, exact, sensitive }, route.\x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e);\n  }\n \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n\n  render() {\n    const { \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state;\n    const { children, component, render } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    const { history, route, staticContext } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router;\n    const location = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location || route.location;\n    const props = { \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e, location, history, staticContext };\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e ? \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.createElement(component, props) : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (render) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e ? render(props) : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof children === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e children(props);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children \x26amp;\x26amp; !isEmptyChildren(children))\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eChildren\x3c\/span\x3e.only(children);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;Route \/\x26gt;\x3c\/code\x3e有一部分源码与\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e相似，可以实现路由的嵌套，但其核心是通过\x3ccode\x3eContext\x3c\/code\x3e共享的\x3ccode\x3erouter\x3c\/code\x3e，判断是否匹配当前路由的路径，然后渲染组件。\x3c\/p\x3e\n\x3cp\x3e通过上述的分析，可以看出，整个react-router其实就是围绕着\x3ccode\x3e\x26lt;Router \/\x26gt;\x3c\/code\x3e的\x3ccode\x3eContext\x3c\/code\x3e来构建的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e使用Context开发组件\x3c\/h2\x3e\n\x3cp\x3e之前，通过\x3ccode\x3eContext\x3c\/code\x3e开发过一个简单的组件，插槽分发组件。本章就借着这个插槽分发组件的开发经历，聊聊如何使用\x3ccode\x3eContext\x3c\/code\x3e进行组件的开发。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e插槽分发组件\x3c\/h3\x3e\n\x3cp\x3e首先说说什么是插槽分发组件，这个概念最初是在Vuejs中认识的。插槽分发是一种通过组件的组合，将父组件的内容插入到子组件模板的技术，在Vuejs中叫做\x3ccode\x3eSlot\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e为了让大家更加直观的理解这个概念，我从Vuejs搬运了一段关于插槽分发的Demo。\x3c\/p\x3e\n\x3cp\x3e对于提供的插槽的组件\x3ccode\x3e\x26lt;my-component \/\x26gt;\x3c\/code\x3e，模板如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3ch2\x3e我是子组件的标题\x3c\/h2\x3e\n  \x3cslot\x3e\n    只有在没有要分发的内容时显示\n  \x3c\/slot\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh2\x3c\/span\x3e\x26gt;\x3c\/span\x3e我是子组件的标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh2\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    只有在没有要分发的内容时显示\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于父组件，模板如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3ch1\x3e我是父组件的标题\x3c\/h1\x3e\n  \x3cmy-component\x3e\n    \x3cp\x3e这是一些初始内容\x3c\/p\x3e\n    \x3cp\x3e这是更多的初始内容\x3c\/p\x3e\n  \x3c\/my-component\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e我是父组件的标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这是一些初始内容\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这是更多的初始内容\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终渲染的结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3ch1\x3e我是父组件的标题\x3c\/h1\x3e\n  \x3cdiv\x3e\n    \x3ch2\x3e我是子组件的标题\x3c\/h2\x3e\n    \x3cp\x3e这是一些初始内容\x3c\/p\x3e\n    \x3cp\x3e这是更多的初始内容\x3c\/p\x3e\n  \x3c\/div\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e我是父组件的标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh2\x3c\/span\x3e\x26gt;\x3c\/span\x3e我是子组件的标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh2\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这是一些初始内容\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这是更多的初始内容\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到组件\x3ccode\x3e\x26lt;my-component \/\x26gt; \x3c\/code\x3e 的\x3ccode\x3e\x26lt;slot \/\x26gt;\x3c\/code\x3e节点最终被父组件中\x3ccode\x3e\x26lt;my-component \/\x26gt;\x3c\/code\x3e节点下的内容所替换。\x3c\/p\x3e\n\x3cp\x3eVuejs还支持\x3cstrong\x3e具名插槽\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e例如，一个布局组件\x3ccode\x3e\x26lt;app-layout \/\x26gt;\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv class=\x26quot;container\x26quot;\x3e\n  \x3cheader\x3e\n    \x3cslot name=\x26quot;header\x26quot;\x3e\x3c\/slot\x3e\n  \x3c\/header\x3e\n  \x3cmain\x3e\n    \x3cslot\x3e\x3c\/slot\x3e\n  \x3c\/main\x3e\n  \x3cfooter\x3e\n    \x3cslot name=\x26quot;footer\x26quot;\x3e\x3c\/slot\x3e\n  \x3c\/footer\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eslot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而在父组件模板中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3capp-layout\x3e\n  \x3ch1 slot=\x26quot;header\x26quot;\x3e这里可能是一个页面标题\x3c\/h1\x3e\n  \x3cp\x3e主要内容的一个段落。\x3c\/p\x3e\n  \x3cp\x3e另一个段落。\x3c\/p\x3e\n  \x3cp slot=\x26quot;footer\x26quot;\x3e这里有一些联系信息\x3c\/p\x3e\n\x3c\/app-layout\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eapp-layout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里可能是一个页面标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e主要内容的一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e另一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里有一些联系信息\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eapp-layout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终渲染的结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv class=\x26quot;container\x26quot;\x3e\n  \x3cheader\x3e\n    \x3ch1\x3e这里可能是一个页面标题\x3c\/h1\x3e\n  \x3c\/header\x3e\n  \x3cmain\x3e\n    \x3cp\x3e主要内容的一个段落。\x3c\/p\x3e\n    \x3cp\x3e另一个段落。\x3c\/p\x3e\n  \x3c\/main\x3e\n  \x3cfooter\x3e\n    \x3cp\x3e这里有一些联系信息\x3c\/p\x3e\n  \x3c\/footer\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里可能是一个页面标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e主要内容的一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e另一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里有一些联系信息\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e插槽分发的好处体现在，它可以让组件具有可抽象成模板的能力。组件自身只关心模板结构，具体的内容交给父组件去处理，同时，不打破HTML描述DOM结构的语法表达方式。我觉得这是一项很有意义的技术，可惜，React对于这项技术的支持不是那么友好。于是我便参考Vuejs的插槽分发组件，开发了一套基于React的插槽分发组件，可以让React组件也具模板化的能力。\x3c\/p\x3e\n\x3cp\x3e对于\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e组件，我希望可以写成下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class AppLayout extends React.Component {\n  static displayName = \x27AppLayout\x27\n  \n  render () {\n    return (\n      \x3cdiv class=\x26quot;container\x26quot;\x3e\n        \x3cheader\x3e\n          \x3cSlot name=\x26quot;header\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/header\x3e\n        \x3cmain\x3e\n          \x3cSlot\x3e\x3c\/Slot\x3e\n        \x3c\/main\x3e\n        \x3cfooter\x3e\n          \x3cSlot name=\x26quot;footer\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/footer\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppLayout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e displayName = \x3cspan class=\x22hljs-string\x22\x3e\x27AppLayout\x27\x3c\/span\x3e\n  \n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在外层使用时，可以写成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cAppLayout\x3e\n  \x3cAddOn slot=\x26quot;header\x26quot;\x3e\n    \x3ch1\x3e这里可能是一个页面标题\x3c\/h1\x3e\n  \x3c\/AddOn\x3e\n  \x3cAddOn\x3e\n    \x3cp\x3e主要内容的一个段落。\x3c\/p\x3e\n      \x3cp\x3e另一个段落。\x3c\/p\x3e\n  \x3c\/AddOn\x3e\n  \x3cAddOn slot=\x26quot;footer\x26quot;\x3e\n    \x3cp\x3e这里有一些联系信息\x3c\/p\x3e\n  \x3c\/AddOn\x3e\n\x3c\/AppLayout\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAppLayout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里可能是一个页面标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e主要内容的一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e另一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里有一些联系信息\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAppLayout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e组件的实现思路\x3c\/h3\x3e\n\x3cp\x3e根据前面所想的，先整理一下实现思路。\x3c\/p\x3e\n\x3cp\x3e不难看出，插槽分发组件需要依靠两个子组件——插槽组件\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和分发组件\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e。插槽组件，负责打桩，提供分发内容的坑位。分发组件，负责收集分发内容，并提供给插槽组件去渲染分发内容，相当于插槽的消费者。\x3c\/p\x3e\n\x3cp\x3e显然，这里遇到了一个问题，\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e组件与\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e组件是独立的，如何将\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的内容填充到\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e中呢？解决这个问题不难，两个独立的模块需要建立联系，就给他们建立一个桥梁。那么这个桥梁要如何搭建呢？回过头来看看之前的设想的代码。\x3c\/p\x3e\n\x3cp\x3e对于\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e组件，希望写成下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class AppLayout extends React.Component {\n  static displayName = \x27AppLayout\x27\n  \n  render () {\n    return (\n      \x3cdiv class=\x26quot;container\x26quot;\x3e\n        \x3cheader\x3e\n          \x3cSlot name=\x26quot;header\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/header\x3e\n        \x3cmain\x3e\n          \x3cSlot\x3e\x3c\/Slot\x3e\n        \x3c\/main\x3e\n        \x3cfooter\x3e\n          \x3cSlot name=\x26quot;footer\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/footer\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppLayout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e displayName = \x3cspan class=\x22hljs-string\x22\x3e\x27AppLayout\x27\x3c\/span\x3e\n  \n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在外层使用时，写成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cAppLayout\x3e\n  \x3cAddOn slot=\x26quot;header\x26quot;\x3e\n    \x3ch1\x3e这里可能是一个页面标题\x3c\/h1\x3e\n  \x3c\/AddOn\x3e\n  \x3cAddOn\x3e\n    \x3cp\x3e主要内容的一个段落。\x3c\/p\x3e\n      \x3cp\x3e另一个段落。\x3c\/p\x3e\n  \x3c\/AddOn\x3e\n  \x3cAddOn slot=\x26quot;footer\x26quot;\x3e\n    \x3cp\x3e这里有一些联系信息\x3c\/p\x3e\n  \x3c\/AddOn\x3e\n\x3c\/AppLayout\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAppLayout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里可能是一个页面标题\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e主要内容的一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e另一个段落。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这里有一些联系信息\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAddOn\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eAppLayout\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e无论是\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e还是\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e，其实都在\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e的作用域内。\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e是\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e组件\x3ccode\x3erender()\x3c\/code\x3e方法返回的组件节点，而\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e则是\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e的\x3ccode\x3echildren\x3c\/code\x3e节点，所以，可以将\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e视为\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e与\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的桥梁的角色。那么，\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e通过什么给\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e建立联系呢？这里就用到本文的主角——\x3ccode\x3eContext\x3c\/code\x3e。接下来的问题就是，如何使用\x3ccode\x3eContext\x3c\/code\x3e给\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e建立联系？\x3c\/p\x3e\n\x3cp\x3e前面提到了\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e这座桥梁。在外层组件，\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e负责通过\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e收集为插槽填充的内容。\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e自身借助\x3ccode\x3eContext\x3c\/code\x3e定义一个获取填充内容的接口。在渲染的时候，因为\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e是\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e渲染的节点，所以，\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e可以通过\x3ccode\x3eContext\x3c\/code\x3e获取到\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e定义的获取填充内容的接口，然后通过这个接口，获取到填充内容进行渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e按照思路实现插槽分发组件\x3c\/h3\x3e\n\x3cp\x3e由于\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e是\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e的\x3ccode\x3echildren\x3c\/code\x3e节点，并且\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e是特定的组件，我们可以通过\x3ccode\x3ename\x3c\/code\x3e或者\x3ccode\x3edisplayName\x3c\/code\x3e识别出来，所以，\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e在渲染之前，也就是\x3ccode\x3erender()\x3c\/code\x3e的\x3ccode\x3ereturn\x3c\/code\x3e之前，对\x3ccode\x3echildren\x3c\/code\x3e进行遍历，以\x3ccode\x3eslot\x3c\/code\x3e的值作为\x3ccode\x3ekey\x3c\/code\x3e，将每一个\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的\x3ccode\x3echildren\x3c\/code\x3e缓存下来。如果\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e没有设置\x3ccode\x3eslot\x3c\/code\x3e，那么将其视为给非具名的\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e填充内容，我们可以给这些非具名的插槽定一个\x3ccode\x3ekey\x3c\/code\x3e，比如叫\x3ccode\x3e$$default\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e对于\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e，代码大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class AppLayout extends React.Component {\n  \n  static childContextTypes = {\n    requestAddOnRenderer: PropTypes.func\n  }\n  \n  \/\/ 用于缓存每个\x3cAddOn \/\x3e的内容\n  addOnRenderers = {}\n  \n  \/\/ 通过Context为子节点提供接口\n  getChildContext () {\n    const requestAddOnRenderer = (name) =\x3e {\n      if (!this.addOnRenderers[name]) {\n        return undefined\n      }\n      return () =\x3e (\n        this.addOnRenderers[name]\n      )\n    }\n    return {\n      requestAddOnRenderer\n    }\n  }\n\n  render () {\n    const {\n      children,\n      ...restProps\n    } = this.props\n\n    if (children) {\n      \/\/ 以k-v的方式缓存\x3cAddOn \/\x3e的内容\n      const arr = React.Children.toArray(children)\n      const nameChecked = []\n      this.addOnRenderers = {}\n      arr.forEach(item =\x3e {\n        const itemType = item.type\n        if (item.type.displayName === \x27AddOn\x27) {\n          const slotName = item.props.slot || \x27$$default\x27\n          \/\/ 确保内容唯一性\n          if (nameChecked.findIndex(item =\x3e item === stubName) !== -1) {\n            throw new Error(`Slot(${slotName}) has been occupied`)\n          }\n          this.addOnRenderers[stubName] = item.props.children\n          nameChecked.push(stubName)\n        }\n      })\n    }\n\n    return (\n      \x3cdiv class=\x26quot;container\x26quot;\x3e\n        \x3cheader\x3e\n          \x3cSlot name=\x26quot;header\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/header\x3e\n        \x3cmain\x3e\n          \x3cSlot\x3e\x3c\/Slot\x3e\n        \x3c\/main\x3e\n        \x3cfooter\x3e\n          \x3cSlot name=\x26quot;footer\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/footer\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppLayout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e childContextTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3erequestAddOnRenderer\x3c\/span\x3e: PropTypes.func\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于缓存每个\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n  addOnRenderers = {}\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过Context为子节点提供接口\x3c\/span\x3e\n  getChildContext () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e requestAddOnRenderer = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]\n      )\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      requestAddOnRenderer\n    }\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n      children,\n      ...restProps\n    } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以k-v的方式缓存\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr = React.Children.toArray(children)\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nameChecked = []\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers = {}\n      arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e itemType = item.type\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (item.type.displayName === \x3cspan class=\x22hljs-string\x22\x3e\x27AddOn\x27\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slotName = item.props.slot || \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 确保内容唯一性\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nameChecked.findIndex(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e item === stubName) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`Slot(\x3cspan class=\x22hljs-subst\x22\x3e${slotName}\x3c\/span\x3e) has been occupied`\x3c\/span\x3e)\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[stubName] = item.props.children\n          nameChecked.push(stubName)\n        }\n      })\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e定义了一个\x3ccode\x3eContext\x3c\/code\x3e接口\x3ccode\x3erequestAddOnRenderer()\x3c\/code\x3e，\x3ccode\x3erequestAddOnRenderer()\x3c\/code\x3e接口根据\x3ccode\x3ename\x3c\/code\x3e返回一个函数，这个返回的函数会根据\x3ccode\x3ename\x3c\/code\x3e访问\x3ccode\x3eaddOnRenderers\x3c\/code\x3e的属性，\x3ccode\x3eaddOnRenderers\x3c\/code\x3e就是\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的内容缓存对象。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e的实现很简单，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/            props,              context\nconst Slot = ({ name, children }, { requestAddOnRenderer }) =\x3e {\n  const addOnRenderer = requestAddOnRenderer(name)\n  return (addOnRenderer \x26amp;\x26amp; addOnRenderer()) ||\n    children ||\n    null\n}\n\nSlot.displayName = \x27Slot\x27\nSlot.contextTypes = { requestAddOnRenderer: PropTypes.func }\nSlot.propTypes = { name: PropTypes.string }\nSlot.defaultProps = { name: \x27$$default\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/            props,              context\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Slot = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ name, children }, { requestAddOnRenderer }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e addOnRenderer = requestAddOnRenderer(name)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (addOnRenderer \x26amp;\x26amp; addOnRenderer()) ||\n    children ||\n    \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\nSlot.displayName = \x3cspan class=\x22hljs-string\x22\x3e\x27Slot\x27\x3c\/span\x3e\nSlot.contextTypes = { \x3cspan class=\x22hljs-attr\x22\x3erequestAddOnRenderer\x3c\/span\x3e: PropTypes.func }\nSlot.propTypes = { \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: PropTypes.string }\nSlot.defaultProps = { \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e通过\x3ccode\x3econtext\x3c\/code\x3e获取到\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e提供的接口\x3ccode\x3erequestAddOnRenderer()\x3c\/code\x3e，最终渲染的主要对象就是缓存在\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e中的\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的内容。如果没有获取到指定的\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的内容，则渲染\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e自身的\x3ccode\x3echildren\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e更简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const AddOn = () =\x3e null\n\nAddOn.propTypes = { slot: PropTypes.string }\nAddOn.defaultTypes = { slot: \x27$$default\x27 }\nAddOn.displayName = \x27AddOn\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode class=\x22jsx\x22\x3econst AddOn = () =\x26gt; null\n\nAddOn\x3cspan class=\x22hljs-selector-class\x22\x3e.propTypes\x3c\/span\x3e = { slot: PropTypes\x3cspan class=\x22hljs-selector-class\x22\x3e.string\x3c\/span\x3e }\nAddOn\x3cspan class=\x22hljs-selector-class\x22\x3e.defaultTypes\x3c\/span\x3e = { slot: \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e }\nAddOn\x3cspan class=\x22hljs-selector-class\x22\x3e.displayName\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27AddOn\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e不做任何事情，仅仅返回\x3ccode\x3enull\x3c\/code\x3e，它的作用就是让\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e缓存分发给插槽的内容。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e可以让\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e更具通用性\x3c\/h3\x3e\n\x3cp\x3e通过上文的代码，基本将\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e改造成了一个具备插槽分发能力的组件，但是很明显的，\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e并不具备通用性，我们可以将它提升成一个独立通用的组件。\x3c\/p\x3e\n\x3cp\x3e我给这个组件命名为SlotProvider\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function getDisplayName (component) {\n  return component.displayName || component.name || \x27component\x27\n}\n\nconst slotProviderHoC = (WrappedComponent) =\x3e {\n  return class extends React.Component {\n    static displayName = `SlotProvider(${getDisplayName(WrappedComponent)})`\n\n    static childContextTypes = {\n      requestAddOnRenderer: PropTypes.func\n    }\n  \n    \/\/ 用于缓存每个\x3cAddOn \/\x3e的内容\n    addOnRenderers = {}\n  \n    \/\/ 通过Context为子节点提供接口\n    getChildContext () {\n      const requestAddOnRenderer = (name) =\x3e {\n        if (!this.addOnRenderers[name]) {\n          return undefined\n        }\n        return () =\x3e (\n          this.addOnRenderers[name]\n        )\n      }\n      return {\n        requestAddOnRenderer\n      }\n    }\n\n    render () {\n      const {\n        children,\n        ...restProps\n      } = this.props\n\n      if (children) {\n        \/\/ 以k-v的方式缓存\x3cAddOn \/\x3e的内容\n        const arr = React.Children.toArray(children)\n        const nameChecked = []\n        this.addOnRenderers = {}\n        arr.forEach(item =\x3e {\n          const itemType = item.type\n          if (item.type.displayName === \x27AddOn\x27) {\n            const slotName = item.props.slot || \x27$$default\x27\n            \/\/ 确保内容唯一性\n            if (nameChecked.findIndex(item =\x3e item === stubName) !== -1) {\n              throw new Error(`Slot(${slotName}) has been occupied`)\n            }\n            this.addOnRenderers[stubName] = item.props.children\n            nameChecked.push(stubName)\n          }\n        })\n      }\n      \n      return (\x3cWrappedComponent {...restProps} \/\x3e)\n    }\n  }\n}\n\nexport const SlotProvider = slotProviderHoC\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetDisplayName\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecomponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e component.displayName || component.name || \x3cspan class=\x22hljs-string\x22\x3e\x27component\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slotProviderHoC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e displayName = \x3cspan class=\x22hljs-string\x22\x3e`SlotProvider(\x3cspan class=\x22hljs-subst\x22\x3e${getDisplayName(WrappedComponent)}\x3c\/span\x3e)`\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e childContextTypes = {\n      \x3cspan class=\x22hljs-attr\x22\x3erequestAddOnRenderer\x3c\/span\x3e: PropTypes.func\n    }\n  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于缓存每个\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n    addOnRenderers = {}\n  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过Context为子节点提供接口\x3c\/span\x3e\n    getChildContext () {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e requestAddOnRenderer = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]\n        )\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        requestAddOnRenderer\n      }\n    }\n\n    render () {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n        children,\n        ...restProps\n      } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以k-v的方式缓存\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr = React.Children.toArray(children)\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nameChecked = []\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers = {}\n        arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e itemType = item.type\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (item.type.displayName === \x3cspan class=\x22hljs-string\x22\x3e\x27AddOn\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slotName = item.props.slot || \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 确保内容唯一性\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nameChecked.findIndex(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e item === stubName) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n              \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`Slot(\x3cspan class=\x22hljs-subst\x22\x3e${slotName}\x3c\/span\x3e) has been occupied`\x3c\/span\x3e)\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[stubName] = item.props.children\n            nameChecked.push(stubName)\n          }\n        })\n      }\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...restProps\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e)\n    }\n  }\n}\n\nexport const SlotProvider = slotProviderHoC\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用React的高阶组件对原来的\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e进行改造，将其转变为一个独立通用的组件。对于原来的\x3ccode\x3e\x26lt;AppLayout \/\x26gt;\x3c\/code\x3e，可以使用这个\x3ccode\x3eSlotProvider\x3c\/code\x3e高阶组件，转换成一个具备插槽分发能力的组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { SlotProvider } from \x27.\/SlotProvider.js\x27\n\nclass AppLayout extends React.Component {\n  static displayName = \x27AppLayout\x27\n  \n  render () {\n    return (\n      \x3cdiv class=\x26quot;container\x26quot;\x3e\n        \x3cheader\x3e\n          \x3cSlot name=\x26quot;header\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/header\x3e\n        \x3cmain\x3e\n          \x3cSlot\x3e\x3c\/Slot\x3e\n        \x3c\/main\x3e\n        \x3cfooter\x3e\n          \x3cSlot name=\x26quot;footer\x26quot;\x3e\x3c\/Slot\x3e\n        \x3c\/footer\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nexport default SlotProvider(AppLayout)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { SlotProvider } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/SlotProvider.js\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppLayout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e displayName = \x3cspan class=\x22hljs-string\x22\x3e\x27AppLayout\x27\x3c\/span\x3e\n  \n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22header\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eheader\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emain\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22footer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSlot\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3efooter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e SlotProvider(AppLayout)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过以上的经历，可以看到，当设计开发一个组件时，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e组件可能需要由一个根组件和多个子组件一起合作来完成组件功能\x3c\/strong\x3e。比如插槽分发组件实际上需要\x3ccode\x3eSlotProvider\x3c\/code\x3e与\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e一起配合使用，\x3ccode\x3eSlotProvider\x3c\/code\x3e作为根组件，而\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e都算是子组件。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e子组件相对于根组件的位置或者子组件之间的位置是不确定\x3c\/strong\x3e。对于\x3ccode\x3eSlotProvider\x3c\/code\x3e而言，\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e的位置是不确定的，它会处在被\x3ccode\x3eSlotProvider\x3c\/code\x3e这个高阶组件所包裹的组件的模板的任何位置，而对于\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e，他们直接的位置也不确定，一个在\x3ccode\x3eSlotProvider\x3c\/code\x3e包装的组件的内部，另一个是\x3ccode\x3eSlotProvider\x3c\/code\x3e的\x3ccode\x3echildren\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e子组件之间需要依赖一些全局态的API或者数据\x3c\/strong\x3e，比如\x3ccode\x3e\x26lt;Slot \/\x26gt;\x3c\/code\x3e实际渲染的内容来自于\x3ccode\x3eSlotProvider\x3c\/code\x3e收集到的\x3ccode\x3e\x26lt;AddOn \/\x26gt;\x3c\/code\x3e的内容。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这时我们就需要借助一个中间者作为媒介来共享数据，相比额外引入redux这些第三方模块，直接使用\x3ccode\x3eContext\x3c\/code\x3e可以更优雅。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e尝试一下新版本的Context API\x3c\/h3\x3e\n\x3cp\x3e使用新版的Context API对之前的插槽分发组件进行改造。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ SlotProvider.js\n\nfunction getDisplayName (component) {\n  return component.displayName || component.name || \x27component\x27\n}\n\nexport const SlotContext = React.createContext({\n  requestAddOnRenderer: () =\x3e {}\n})\n\nconst slotProviderHoC = (WrappedComponent) =\x3e {\n  return class extends React.Component {\n    static displayName = `SlotProvider(${getDisplayName(WrappedComponent)})`\n\n    \/\/ 用于缓存每个\x3cAddOn \/\x3e的内容\n    addOnRenderers = {}\n  \n    requestAddOnRenderer = (name) =\x3e {\n      if (!this.addOnRenderers[name]) {\n        return undefined\n      }\n      return () =\x3e (\n        this.addOnRenderers[name]\n      )\n    }\n\n    render () {\n      const {\n        children,\n        ...restProps\n      } = this.props\n\n      if (children) {\n        \/\/ 以k-v的方式缓存\x3cAddOn \/\x3e的内容\n        const arr = React.Children.toArray(children)\n        const nameChecked = []\n        this.addOnRenderers = {}\n        arr.forEach(item =\x3e {\n          const itemType = item.type\n          if (item.type.displayName === \x27AddOn\x27) {\n            const slotName = item.props.slot || \x27$$default\x27\n            \/\/ 确保内容唯一性\n            if (nameChecked.findIndex(item =\x3e item === stubName) !== -1) {\n              throw new Error(`Slot(${slotName}) has been occupied`)\n            }\n            this.addOnRenderers[stubName] = item.props.children\n            nameChecked.push(stubName)\n          }\n        })\n      }\n      \n      return (\n        \x3cSlotContext.Provider value={\n            requestAddOnRenderer: this.requestAddOnRenderer\n          }\x3e\n          \x3cWrappedComponent {...restProps} \/\x3e\n        \x3c\/SlotContext.Provider\x3e\n      )\n    }\n  }\n}\n\nexport const SlotProvider = slotProviderHoC\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ SlotProvider.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetDisplayName\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecomponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e component.displayName || component.name || \x3cspan class=\x22hljs-string\x22\x3e\x27component\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e SlotContext = React.createContext({\n  \x3cspan class=\x22hljs-attr\x22\x3erequestAddOnRenderer\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slotProviderHoC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e displayName = \x3cspan class=\x22hljs-string\x22\x3e`SlotProvider(\x3cspan class=\x22hljs-subst\x22\x3e${getDisplayName(WrappedComponent)}\x3c\/span\x3e)`\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于缓存每个\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n    addOnRenderers = {}\n  \n    requestAddOnRenderer = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[name]\n      )\n    }\n\n    render () {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n        children,\n        ...restProps\n      } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以k-v的方式缓存\x26lt;AddOn \/\x26gt;的内容\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr = React.Children.toArray(children)\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nameChecked = []\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers = {}\n        arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e itemType = item.type\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (item.type.displayName === \x3cspan class=\x22hljs-string\x22\x3e\x27AddOn\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slotName = item.props.slot || \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 确保内容唯一性\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nameChecked.findIndex(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e item === stubName) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n              \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`Slot(\x3cspan class=\x22hljs-subst\x22\x3e${slotName}\x3c\/span\x3e) has been occupied`\x3c\/span\x3e)\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addOnRenderers[stubName] = item.props.children\n            nameChecked.push(stubName)\n          }\n        })\n      }\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x26lt;SlotContext.Provider value={\n            requestAddOnRenderer: this.requestAddOnRenderer\n          }\x26gt;\n          \x26lt;WrappedComponent {...restProps} \/\x26gt;\n        \x26lt;\/SlotContext.Provider\x26gt;\n      )\n    }\n  }\n}\n\nexport const SlotProvider = slotProviderHoC\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e移除了之前的\x3ccode\x3echildContextTypes\x3c\/code\x3e和\x3ccode\x3egetChildContext()\x3c\/code\x3e，除了局部的调整，整体核心的东西没有大变化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Slot.js\n\nimport { SlotContext } from \x27.\/SlotProvider.js\x27\n\nconst Slot = ({ name, children }) =\x3e {\n  return (\n    \x3cSlotContext.Consumer\x3e\n      {(context) =\x3e {\n        const addOnRenderer = requestAddOnRenderer(name)\n          return (addOnRenderer \x26amp;\x26amp; addOnRenderer()) ||\n            children ||\n            null\n      \x22}}\x22\n    \x3c\/SlotContext.Consumer\x3e\n  )\n}\n\nSlot.displayName = \x27Slot\x27\nSlot.propTypes = { name: PropTypes.string }\nSlot.defaultProps = { name: \x27$$default\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Slot.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { SlotContext } from \x3cspan class=\x22hljs-string\x22\x3e\x27.\/SlotProvider.js\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Slot = ({ name, children }) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x26lt;SlotContext.Consumer\x26gt;\n      {(context) =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e addOnRenderer = requestAddOnRenderer(name)\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (addOnRenderer \x26amp;\x26amp; addOnRenderer()) ||\n            children ||\n            \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n      \x22}}\x22\n    \x26lt;\/SlotContext.Consumer\x26gt;\n  )\n}\n\nSlot.displayName = \x3cspan class=\x22hljs-string\x22\x3e\x27Slot\x27\x3c\/span\x3e\nSlot.propTypes = { name: PropTypes.string }\nSlot.defaultProps = { name: \x3cspan class=\x22hljs-string\x22\x3e\x27$$default\x27\x3c\/span\x3e }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于之前就按照生产者消费者的模式来使用\x3ccode\x3eContext\x3c\/code\x3e，加上组件自身也比较简单，因此使用新的API进行改造后，差别不大。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e总结\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e相比\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e，React的\x3ccode\x3eContext\x3c\/code\x3e可以实现跨层级的组件通信。\x3c\/li\x3e\n\x3cli\x3eContext API的使用基于生产者消费者模式。生产者一方，通过组件静态属性\x3ccode\x3echildContextTypes\x3c\/code\x3e声明，然后通过实例方法\x3ccode\x3egetChildContext()\x3c\/code\x3e创建\x3ccode\x3eContext\x3c\/code\x3e对象。消费者一方，通过组件静态属性\x3ccode\x3econtextTypes\x3c\/code\x3e申请要用到的\x3ccode\x3eContext\x3c\/code\x3e属性，然后通过实例的\x3ccode\x3econtext\x3c\/code\x3e访问\x3ccode\x3eContext\x3c\/code\x3e的属性。\x3c\/li\x3e\n\x3cli\x3e使用\x3ccode\x3eContext\x3c\/code\x3e需要多一些思考，不建议在App中使用\x3ccode\x3eContext\x3c\/code\x3e，但如果开发组件过程中可以确保组件的内聚性，可控可维护，不破坏组件树的依赖关系，影响范围小，可以考虑使用\x3ccode\x3eContext\x3c\/code\x3e解决一些问题。\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3eContext\x3c\/code\x3e暴露API或许在一定程度上给解决一些问题带来便利，但个人认为不是一个很好的实践，需要慎重。\x3c\/li\x3e\n\x3cli\x3e旧版本的\x3ccode\x3eContext\x3c\/code\x3e的更新需要依赖\x3ccode\x3esetState()\x3c\/code\x3e，是不可靠的，不过这个问题在新版的API中得以解决。\x3c\/li\x3e\n\x3cli\x3e可以把\x3ccode\x3eContext\x3c\/code\x3e当做组件的作用域来看待，但是需要关注\x3ccode\x3eContext\x3c\/code\x3e的可控性和影响范围，使用之前，先分析是否真的有必要使用，避免过度使用所带来的一些副作用。\x3c\/li\x3e\n\x3cli\x3e可以把\x3ccode\x3eContext\x3c\/code\x3e当做媒介，进行App级或者组件级的数据共享。\x3c\/li\x3e\n\x3cli\x3e设计开发一个组件，如果这个组件需要多个组件关联组合的，使用\x3ccode\x3eContext\x3c\/code\x3e或许可以更加优雅。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上是我的分享内容，如有不足或者错误的地方，欢迎批评指正。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e引用\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3eContext - \x3ca href=\x22https:\/\/reactjs.org\/docs\/context.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/reactjs.org\/docs\/cont...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eReact 16.3来了：带着全新的Context API - \x3ca href=\x22http:\/\/cnodejs.org\/topic\/5a7bd5c4497a08f571384f03\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/cnodejs.org\/topic\/5a7b...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eContent Distribution with Slots - \x3ca href=\x22https:\/\/vuejs.org\/v2\/guide\/components.html#Content-Distribution-with-Slots\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/vuejs.org\/v2\/guide\/co...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>聊一聊我对 React Context 的理解以及应用</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013365874">https://segmentfault.com/a/1190000013365874</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/0iof83b7r1bf/" target="_blank">https://alili.tech/archive/0iof83b7r1bf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>