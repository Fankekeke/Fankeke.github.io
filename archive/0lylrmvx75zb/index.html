<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 在 V8 中的元素种类及性能优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 在 V8 中的元素种类及性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/0lylrmvx75zb/",
				"appid": "1613049289050283", 
				"title": "JavaScript 在 V8 中的元素种类及性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-30T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ls5fi9x4y48/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6x9uxm3m2l/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&text=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&text=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&title=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&is_video=false&description=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&title=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&title=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&title=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0lylrmvx75zb%2f&title=JavaScript%20%e5%9c%a8%20V8%20%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0%e7%a7%8d%e7%b1%bb%e5%8f%8a%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 在 V8 中的元素种类及性能优化</h1><div class="meta"><div class="postdate"><time datetime="2018-12-30" itemprop="datePublished">2018-12-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e原文：\x3ca href=\x22https:\/\/v8project.blogspot.com\/2017\/09\/elements-kinds-in-v8.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e“Elements kinds” in V8\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eJavaScript 对象可以具有与它们相关联的任意属性。对象属性的名称可以包含任何字符。JavaScript 引擎可以进行优化的一个有趣的例子是当属性名是纯数字时，一个特例就是\x3ca href=\x22https:\/\/tc39.github.io\/ecma262\/#sec-object-type\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数组索引\x3c\/a\x3e的属性。\x3c\/p\x3e\n\x3cp\x3e在 V8 中，如果属性名是数字（最常见的形式是 Array 构造函数生成的对象）会被特殊处理。尽管在许多情况下，这些数字索引属性的行为与其他属性一样，V8 选择将它们与非数字属性分开存储以进行优化。在引擎内部，V8 甚至给这些属性一个特殊的名称：元素。对象具有映射到值的\x3ca href=\x22https:\/\/v8project.blogspot.com\/2017\/08\/fast-properties.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e属性\x3c\/a\x3e，而数组具有映射到元素的索引。\x3c\/p\x3e\n\x3cp\x3e尽管这些内部结构从未直接暴露给 JavaScript 开发人员，但它们解释了为什么某些代码模式比其他代码模式更快。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e常见的元素种类\x3c\/h2\x3e\n\x3cp\x3e运行 JavaScript 代码时，V8 会跟踪每个数组所包含的元素。这些信息可以帮助 V8 优化数组元素的操作。例如，当您在数组上调用 \x3ccode\x3ereduce\x3c\/code\x3e，\x3ccode\x3emap\x3c\/code\x3e 或 \x3ccode\x3eforEach\x3c\/code\x3e 时，V8 可以根据数组包含哪些元素来优化这些操作。\x3c\/p\x3e\n\x3cp\x3e拿这个数组举例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [1, 2, 3];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它包含什么样的元素？如果你使用 \x3ccode\x3etypeof\x3c\/code\x3e 操作符，它会告诉你数组包含 \x3ccode\x3enumbers\x3c\/code\x3e。在语言层面，这就是你所得到的：JavaScript 不区分整数，浮点数和双精度 - 它们只是数字。然而，在引擎级别，我们可以做出更精确的区分。这个数组的元素是 \x3cstrong\x3ePACKED_SMI_ELEMENTS\x3c\/strong\x3e。在 V8\x3cbr\x3e 中，术语 Smi 是指用于存储小整数的特定格式。（后面我们会在 \x3ccode\x3ePACKED\x3c\/code\x3e 部分中说明。）\x3c\/p\x3e\n\x3cp\x3e稍后在这个数组中添加一个浮点数将其转换为更通用的元素类型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [1, 2, 3];\n\/\/ 元素类型: PACKED_SMI_ELEMENTS\narray.push(4.56);\n\/\/ 元素类型: PACKED_DOUBLE_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_SMI_ELEMENTS\x3c\/span\x3e\narray.push(\x3cspan class=\x22hljs-number\x22\x3e4.56\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_DOUBLE_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e向数组添加字符串再次改变其元素类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [1, 2, 3];\n\/\/ 元素类型: PACKED_SMI_ELEMENTS\narray.push(4.56);\n\/\/ 元素类型: PACKED_DOUBLE_ELEMENTS\narray.push(\x27x\x27);\n\/\/ 元素类型: PACKED_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_SMI_ELEMENTS\x3c\/span\x3e\narray.push(\x3cspan class=\x22hljs-number\x22\x3e4.56\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_DOUBLE_ELEMENTS\x3c\/span\x3e\narray.push(\x3cspan class=\x22hljs-string\x22\x3e\x27x\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e到目前为止，我们已经看到三种不同的元素，具有以下基本类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e小整数，又称 Smi。\x3c\/li\x3e\n\x3cli\x3e双精度浮点数，浮点数和不能表示为 Smi 的整数。\x3c\/li\x3e\n\x3cli\x3e常规元素，不能表示为 Smi 或双精度的值。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e请注意，双精度浮点数是 Smi 的更为一般的变体，而常规元素是双精度浮点数之上的另一个概括。可以表示为 Smi 的数字集合是可以表示为\x3cbr\x3e double 的数字的子集。\x3c\/p\x3e\n\x3cp\x3e这里重要的一点是，元素种类转换只能从一个方向进行：从特定的（例如 \x3ccode\x3ePACKED_SMI_ELEMENTS\x3c\/code\x3e）到更一般的（例如 \x3ccode\x3ePACKED_ELEMENTS\x3c\/code\x3e）。例如，一旦数组被标记为 \x3ccode\x3ePACKED_ELEMENTS\x3c\/code\x3e，它就不能回到 \x3ccode\x3ePACKED_DOUBLE_ELEMENTS\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e到目前为止，我们已经学到了以下内容：\x3c\/p\x3e\n\x3cp\x3eV8 为每个数组分配一个元素种类。数组的元素种类并没有被捆绑在一起 - 它可以在运行时改变。在前面的例子中，我们从 \x3ccode\x3ePACKED_SMI_ELEMENTS\x3c\/code\x3e 过渡到 \x3ccode\x3ePACKED_ELEMENTS\x3c\/code\x3e。元素种类转换只能从特定种类转变为更普遍的种类。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ePACKED vs HOLEY\x3c\/h2\x3e\n\x3cp\x3e密集数组 \x3ccode\x3ePACKED\x3c\/code\x3e 和稀疏数组 \x3ccode\x3eHOLEY\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e到目前为止，我们只处理密集或打包（\x3ccode\x3ePACKED\x3c\/code\x3e）数组。在数组中创建稀疏数组将元素降级到其 \x3ccode\x3eHOLEY\x3c\/code\x3e 变体：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [1, 2, 3, 4.56, \x27x\x27];\n\/\/ 元素类型: PACKED_ELEMENTS\narray.length; \/\/ 5\narray[9] = 1; \/\/ array[5] until array[8] are now holes\n\/\/ 元素类型: HOLEY_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4.56\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27x\x27\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: PACKED_ELEMENTS\x3c\/span\x3e\narray.length; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\narray[\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ array[5] until array[8] are now holes\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类型: HOLEY_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eV8 之所以做这个区别是因为 \x3ccode\x3ePACKED\x3c\/code\x3e 数组的操作比在 \x3ccode\x3eHOLEY\x3c\/code\x3e 数组上的操作更利于进行优化。对于 \x3ccode\x3ePACKED\x3c\/code\x3e 数组，大多数操作可以有效执行。相比之下， \x3ccode\x3eHOLEY\x3c\/code\x3e 数组的操作需要对原型链进行额外的检查和昂贵的查找。\x3c\/p\x3e\n\x3cp\x3e到目前为止，我们看到的每个基本元素（即 Smis，double 和常规元素）有两种：\x3ccode\x3ePACKED\x3c\/code\x3e 和 \x3ccode\x3eHOLEY\x3c\/code\x3e。我们不仅可以从 \x3ccode\x3ePACKED_SMI_ELEMENTS\x3c\/code\x3e 转变为 \x3ccode\x3ePACKED_DOUBLE_ELEMENTS\x3c\/code\x3e 我们也可以从任何 \x3ccode\x3ePACKED\x3c\/code\x3e 形式转变成 \x3ccode\x3eHOLEY\x3c\/code\x3e 形式。\x3c\/p\x3e\n\x3cp\x3e回顾一下：\x3c\/p\x3e\n\x3cp\x3e最常见的元素种类 \x3ccode\x3ePACKED\x3c\/code\x3e 和 \x3ccode\x3eHOLEY\x3c\/code\x3e。\x3ccode\x3ePACKED\x3c\/code\x3e 数组的操作比在 \x3ccode\x3eHOLEY\x3c\/code\x3e 数组上的操作更为有效。元素种类可从过渡 \x3ccode\x3ePACKED\x3c\/code\x3e 转变为 \x3ccode\x3eHOLEY\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eThe elements kind lattice\x3c\/h2\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e元素种类的格\x3c\/h2\x3e\n\x3cp\x3eV8 将这个变换系统实现为\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Lattice_%28order%29\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e格(数学概念)\x3c\/a\x3e。这是一个简化的可视化，仅显示最常见的元素种类：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVUVTt?w=1312\x26amp;h=560\x22 src=\x22https:\/\/static.alili.tech\/img\/bVUVTt?w=1312\x26amp;h=560\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e只能通过格子向下过渡。一旦将单精度浮点数添加到 Smi 数组中，即使稍后用 Smi 覆盖浮点数，它也会被标记为 \x3ccode\x3eDOUBLE\x3c\/code\x3e。类似地，一旦在数组中创建了一个洞，它将被永久标记为有洞 \x3ccode\x3eHOLEY\x3c\/code\x3e，即使稍后填充它也是如此。\x3c\/p\x3e\n\x3cp\x3eV8 目前有 \x3ca href=\x22https:\/\/cs.chromium.org\/chromium\/src\/v8\/src\/elements-kind.h?l=14\x26amp;rcl=a7e622ba330d046295b61bf6fa9f296a99aafa77\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e21 种不同的元素种类\x3c\/a\x3e，每种元素都有自己的一组可能的优化。\x3c\/p\x3e\n\x3cp\x3e一般来说，更具体的元素种类可以进行更细粒度的优化。元素类型的在格子中越是向下，该对象的操作越慢。为了获得最佳性能，请避免不必要的不具体类型 - 坚持使用符合您情况的最具体的类型。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e性能提示\x3c\/h2\x3e\n\x3cp\x3e在大多数情况下，元素种类的跟踪操作都隐藏在引擎下面，您不需要担心。但是，为了从系统中获得最大的收益，您可以采取以下几方面。再次重申:更具体的元素种类可以进行更细粒度的优化。元素类型的在格子中越是向下，该对象的操作越慢。为了获得最佳性能，请避免不必要的不具体类型 - 坚持使用符合您情况的最具体的类型。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e避免创建洞(hole)\x3c\/h3\x3e\n\x3cp\x3e假设我们正在尝试创建一个数组，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = new Array(3);\n\/\/ 此时，数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`\n\/\/ i.e. 给出当前信息的最具体的可能性。\narray[0] = \x27a\x27;\n\/\/ 接着，这是一个字符串，而不是一个小整数...所以过渡到`HOLEY_ELEMENTS`。\narray[1] = \x27b\x27;\narray[2] = \x27c\x27;\n\/\/ 这时，数组中的所有三个位置都被填充，所以数组被打包（即不再稀疏）。\n\/\/ 但是，我们无法转换为更具体的类型，例如 “PACKED_ELEMENTS”。\n\/\/ 元素类保留为“HOLEY_ELEMENTS”。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此时，数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ i.e. 给出当前信息的最具体的可能性。\x3c\/span\x3e\narray[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接着，这是一个字符串，而不是一个小整数...所以过渡到`HOLEY_ELEMENTS`。\x3c\/span\x3e\narray[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e;\narray[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时，数组中的所有三个位置都被填充，所以数组被打包（即不再稀疏）。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但是，我们无法转换为更具体的类型，例如 “PACKED_ELEMENTS”。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素类保留为“HOLEY_ELEMENTS”。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e一旦数组被标记为有洞，它永远是有洞的 - 即使它被打包了\x3c\/strong\x3e！从那时起，数组上的任何操作都可能变慢。如果您计划在数组上执行大量操作，并且希望对这些操作进行优化，请避免在数组中创建空洞。V8 可以更有效地处理密集数组。\x3c\/p\x3e\n\x3cp\x3e创建数组的一种更好的方法是使用字面量：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [\x27a\x27, \x27b\x27, \x27c\x27];\n\/\/ elements kind: PACKED_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ elements kind: PACKED_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果您提前不知道元素的所有值，那么可以创建一个空数组，然后再 \x3ccode\x3epush\x3c\/code\x3e 值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [];\n\/\/ …\narray.push(someValue);\n\/\/ …\narray.push(someOtherValue);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\narray.push(someValue);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\narray.push(someOtherValue);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方法确保数组不会被转换为 holey elements。因此，V8 可以更有效地优化数组上的任何操作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e避免读取超出数组的长度\x3c\/h3\x3e\n\x3cp\x3e当读数超过数组的长度时，例如读取 \x3ccode\x3earray[42]\x3c\/code\x3e 时，会发生类似的情况 \x3ccode\x3earray.length === 5\x3c\/code\x3e。在这种情况下，数组索引 \x3ccode\x3e42\x3c\/code\x3e 超出范围，该属性不存在于数组本身上，因此 JavaScript 引擎必须执行相同的昂贵的原型链查找。\x3c\/p\x3e\n\x3cp\x3e不要这样写你的循环：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Don’t do this!\nfor (let i = 0, item; (item = items[i]) != null; i\x2b\x2b) {\n  doSomething(item);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Don’t do this!\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, item; (item = items[i]) != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; i\x2b\x2b) {\n  doSomething(item);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该代码读取数组中的所有元素，然后再次读取。直到它找到一个元素为 \x3ccode\x3eundefined\x3c\/code\x3e 或 \x3ccode\x3enull\x3c\/code\x3e 时停止。（jQuery 在几个地方使用这种模式。）\x3c\/p\x3e\n\x3cp\x3e相反，将你的循环写成老式的方式，只需要一直迭代到最后一个元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let index = 0; index \x3c items.length; index\x2b\x2b) {\n  const item = items[index];\n  doSomething(item);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; items.length; index\x2b\x2b) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e item = items[index];\n  doSomething(item);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当你循环的集合是可迭代的（数组和 \x3ccode\x3eNodeLists\x3c\/code\x3e），还有更好的选择：只需要使用 for-of。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (const item of items) {\n  doSomething(item);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e item \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e items) {\n  doSomething(item);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于数组，您可以使用内置的 \x3ccode\x3eforEach\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22items.forEach((item) =\x3e {\n  doSomething(item);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eitems.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  doSomething(item);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如今，两者的性能 \x3ccode\x3efor-of\x3c\/code\x3e 和 \x3ccode\x3eforEach\x3c\/code\x3e 可以和旧式的 \x3ccode\x3efor\x3c\/code\x3e 循环相提并论。\x3c\/p\x3e\n\x3cp\x3e避免读数超出数组的长度！这样做和数组中的洞一样糟糕。在这种情况下，V8 的边界检查失败，检查属性是否存在失败，然后我们需要查找原型链。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e避免元素种类转换\x3c\/h3\x3e\n\x3cp\x3e一般来说，如果您需要在数组上执行大量操作，请尝试坚持尽可能具体的元素类型，以便 V8 可以尽可能优化这些操作。\x3c\/p\x3e\n\x3cp\x3e这比看起来更难。例如，只需给数组添加一个 \x3ccode\x3e-0\x3c\/code\x3e，一个小整数的数组即可将其转换为 \x3ccode\x3ePACKED_DOUBLE_ELEMENTS\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [3, 2, 1, \x2b0];\n\/\/ PACKED_SMI_ELEMENTS\narray.push(-0);\n\/\/ PACKED_DOUBLE_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ PACKED_SMI_ELEMENTS\x3c\/span\x3e\narray.push(\x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ PACKED_DOUBLE_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，此数组上的任何操作都将以与 Smi 完全不同的方式进行优化。\x3c\/p\x3e\n\x3cp\x3e避免 \x3ccode\x3e-0\x3c\/code\x3e，除非你需要在代码中明确区分 \x3ccode\x3e-0\x3c\/code\x3e 和 \x3ccode\x3e\x2b0\x3c\/code\x3e。（你可能并不需要）\x3c\/p\x3e\n\x3cp\x3e同样还有 \x3ccode\x3eNaN\x3c\/code\x3e 和 \x3ccode\x3eInfinity\x3c\/code\x3e。它们被表示为双精度，因此添加一个 \x3ccode\x3eNaN\x3c\/code\x3e 或 \x3ccode\x3eInfinity\x3c\/code\x3e 会将 \x3ccode\x3eSMI_ELEMENTS\x3c\/code\x3e 转换为\x3cbr\x3e\x3ccode\x3eDOUBLE_ELEMENTS\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const array = [3, 2, 1];\n\/\/ PACKED_SMI_ELEMENTS\narray.push(NaN, Infinity);\n\/\/ PACKED_DOUBLE_ELEMENTS\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ PACKED_SMI_ELEMENTS\x3c\/span\x3e\narray.push(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ PACKED_DOUBLE_ELEMENTS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果您计划对整数数组执行大量操作，在初始化的时候请考虑规范化 \x3ccode\x3e-0\x3c\/code\x3e，并且防止 \x3ccode\x3eNaN\x3c\/code\x3e 以及 \x3ccode\x3eInfinity\x3c\/code\x3e。这样数组就会保持 \x3ccode\x3ePACKED_SMI_ELEMENTS\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e事实上，如果你对数组进行数学运算，可以考虑使用 \x3ccode\x3eTypedArray\x3c\/code\x3e。每个数组都有专门的元素类型。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e类数组对象 vs 数组\x3c\/h3\x3e\n\x3cp\x3eJavaScript 中的某些对象 - 特别是在 DOM 中 - 虽然它们不是真正的数组，但是他们看起来像数组。可以自己创建类数组的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const arrayLike = {};\narrayLike[0] = \x27a\x27;\narrayLike[1] = \x27b\x27;\narrayLike[2] = \x27c\x27;\narrayLike.length = 3;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayLike = {};\narrayLike[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e;\narrayLike[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e;\narrayLike[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e;\narrayLike.length = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该对象具有 length 并支持索引元素访问（就像数组！），但它的原型上缺少数组方法，如 \x3ccode\x3eforEach\x3c\/code\x3e。尽管如此，仍然可以调用数组泛型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Array.prototype.forEach.call(arrayLike, (value, index) =\x3e {\n  console.log(`${ index }: ${ value }`);\n});\n\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.forEach.call(arrayLike, (value, index) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${ index }\x3c\/span\x3e: \x3cspan class=\x22hljs-subst\x22\x3e${ value }\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个代码工作原理如下，在类数组对象上调用数组内置的 \x3ccode\x3eArray.prototype.forEach\x3c\/code\x3e。但是，这比在真正的数组中调用 \x3ccode\x3eforEach\x3c\/code\x3e 慢，引擎数组的 \x3ccode\x3eforEach\x3c\/code\x3e 在 V8 中是高度优化的。如果你打算在这个对象上多次使用数组内置函数，可以考虑先把它变成一个真正的数组：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const actualArray = Array.prototype.slice.call(arrayLike, 0);\nactualArray.forEach((value, index) =\x3e {\n  console.log(`${ index }: ${ value }`);\n});\n\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e actualArray = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(arrayLike, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\nactualArray.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${ index }\x3c\/span\x3e: \x3cspan class=\x22hljs-subst\x22\x3e${ value }\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了后续的优化，进行一次性转换的成本是值得的，特别是如果您计划在数组上执行大量操作。\x3c\/p\x3e\n\x3cp\x3e例如，\x3ccode\x3earguments\x3c\/code\x3e 对象是类数组的对象。可以在其上调用数组内置函数，但是这样的操作将不会被完全优化，因为这些优化只针对真正的数组。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const logArgs = function() {\n  Array.prototype.forEach.call(arguments, (value, index) =\x3e {\n    console.log(`${ index }: ${ value }`);\n  });\n};\nlogArgs(\x27a\x27, \x27b\x27, \x27c\x27);\n\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e logArgs = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.forEach.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, (value, index) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${ index }\x3c\/span\x3e: \x3cspan class=\x22hljs-subst\x22\x3e${ value }\x3c\/span\x3e`\x3c\/span\x3e);\n  });\n};\nlogArgs(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES2015 的 rest 参数在这里很有帮助。它们产生真正的数组，可以优雅的代替类似数组的对象 \x3ccode\x3earguments\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const logArgs = (...args) =\x3e {\n  args.forEach((value, index) =\x3e {\n    console.log(`${ index }: ${ value }`);\n  });\n};\nlogArgs(\x27a\x27, \x27b\x27, \x27c\x27);\n\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e logArgs = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  args.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${ index }\x3c\/span\x3e: \x3cspan class=\x22hljs-subst\x22\x3e${ value }\x3c\/span\x3e`\x3c\/span\x3e);\n  });\n};\nlogArgs(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This logs \x270: a\x27, then \x271: b\x27, and finally \x272: c\x27.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如今，没有理由直接使用对象 \x3ccode\x3earguments\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e通常，尽可能避免使用数组类对象，应该使用真正的数组。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e避免多态\x3c\/h3\x3e\n\x3cp\x3e如果您的代码需要处理包含多种不同元素类型的数组，则可能会比单个元素类型数组要慢，因为你的代码要对不同类型的数组元素进行多态操作。\x3c\/p\x3e\n\x3cp\x3e考虑以下示例，其中使用了各种元素种类调用。（请注意，这不是本机 \x3ccode\x3eArray.prototype.forEach\x3c\/code\x3e，它具有自己的一些优化，这些优化不同于本文中讨论的元素种类优化。）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const each = (array, callback) =\x3e {\n  for (let index = 0; index \x3c array.length; \x2b\x2bindex) {\n    const item = array[index];\n    callback(item);\n  }\n};\nconst doSomething = (item) =\x3e console.log(item);\n\neach([], () =\x3e {});\n\neach([\x27a\x27, \x27b\x27, \x27c\x27], doSomething);\n\/\/ `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache\n\/\/ (or “IC”) to remember that `each` is called with this particular\n\/\/ elements kind. V8 is optimistic and assumes that the\n\/\/ `array.length` and `array[index]` accesses inside the `each`\n\/\/ function are monomorphic (i.e. only ever receive a single kind\n\/\/ of elements) until proven otherwise. For every future call to\n\/\/ `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If\n\/\/ so, V8 can re-use the previously-generated code. If not, more work\n\/\/ is needed.\n\neach([1.1, 2.2, 3.3], doSomething);\n\/\/ `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has\n\/\/ now seen different elements kinds passed to `each` in its IC, the\n\/\/ `array.length` and `array[index]` accesses inside the `each`\n\/\/ function get marked as polymorphic. V8 now needs an additional\n\/\/ check every time `each` gets called: one for `PACKED_ELEMENTS`\n\/\/ (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for\n\/\/ any other elements kinds (like before). This incurs a performance\n\/\/ hit.\n\neach([1, 2, 3], doSomething);\n\/\/ `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another\n\/\/ degree of polymorphism. There are now three different elements\n\/\/ kinds in the IC for `each`. For every `each` call from now on, yet\n\/\/ another elements kind check is needed to re-use the generated code\n\/\/ for `PACKED_SMI_ELEMENTS`. This comes at a performance cost.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e each = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3earray, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; array.length; \x2b\x2bindex) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e item = array[index];\n    callback(item);\n  }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doSomething = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(item);\n\neach([], () =\x26gt; {});\n\neach([\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e], doSomething);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ (or “IC”) to remember that `each` is called with this particular\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ elements kind. V8 is optimistic and assumes that the\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `array.length` and `array[index]` accesses inside the `each`\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ function are monomorphic (i.e. only ever receive a single kind\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ of elements) until proven otherwise. For every future call to\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ so, V8 can re-use the previously-generated code. If not, more work\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ is needed.\x3c\/span\x3e\n\neach([\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2.2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3.3\x3c\/span\x3e], doSomething);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ now seen different elements kinds passed to `each` in its IC, the\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `array.length` and `array[index]` accesses inside the `each`\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ function get marked as polymorphic. V8 now needs an additional\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ check every time `each` gets called: one for `PACKED_ELEMENTS`\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ any other elements kinds (like before). This incurs a performance\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ hit.\x3c\/span\x3e\n\neach([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e], doSomething);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ degree of polymorphism. There are now three different elements\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ kinds in the IC for `each`. For every `each` call from now on, yet\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ another elements kind check is needed to re-use the generated code\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ for `PACKED_SMI_ELEMENTS`. This comes at a performance cost.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e内置方法（如 \x3ccode\x3eArray.prototype.forEach\x3c\/code\x3e）可以更有效地处理这种多态性，因此在性能敏感的情况下考虑使用它们而不是用户库函数。\x3c\/p\x3e\n\x3cp\x3eV8 中单态与多态的另一个例子涉及对象形状（object shape），也称为对象的隐藏类。要了解更多，请查看 \x3ca href=\x22http:\/\/mrale.ph\/blog\/2015\/01\/11\/whats-up-with-monomorphism.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVyacheslav 的文章\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e调试元素种类\x3c\/h2\x3e\n\x3cp\x3e找出一个给定的对象的“元素种类”，可以使用一个调试版本 d8（参见“\x3ca href=\x22https:\/\/github.com\/v8\/v8\/wiki\/Building-from-Source\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从源代码构建\x3c\/a\x3e”），并运行：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ out.gn\/x64.debug\/d8 --allow-natives-syntax\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode class=\x22shell\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e$ \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e.gn\/x64.debug\/d8 \x3cspan class=\x22hljs-comment\x22\x3e--allow-natives-syntax\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这将打开 d8 REPL 中的特殊函数，如 \x3ccode\x3e%DebugPrint(object)\x3c\/code\x3e。输出中的“元素”字段显示您传递给它的任何对象的“元素种类”。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22d8\x3e const array = [1, 2, 3]; %DebugPrint(array);\nDebugPrint: 0x1fbbad30fd71: [JSArray]\n - map = 0x10a6f8a038b1 [FastProperties]\n - prototype = 0x1212bb687ec1\n - elements = 0x1fbbad30fd19 \x3cFixedArray[3]\x3e [PACKED_SMI_ELEMENTS (COW)]\n - length = 3\n - properties = 0x219eb0702241 \x3cFixedArray[0]\x3e {\n    #length: 0x219eb0764ac9 \x3cAccessorInfo\x3e (const accessor descriptor)\n }\n - elements= 0x1fbbad30fd19 \x3cFixedArray[3]\x3e {\n           0: 1\n           1: 2\n           2: 3\n }\n[…]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3ed8\x26gt; const array = [1, 2, 3]; %DebugPrint(array);\nDebugPrint: 0x1fbbad30fd71: [JSArray]\n -\x3cspan class=\x22ruby\x22\x3e map = \x3cspan class=\x22hljs-number\x22\x3e0x10a6f8a038b1\x3c\/span\x3e [FastProperties]\n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e prototype = \x3cspan class=\x22hljs-number\x22\x3e0x1212bb687ec1\x3c\/span\x3e\n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e elements = \x3cspan class=\x22hljs-number\x22\x3e0x1fbbad30fd19\x3c\/span\x3e \x26lt;FixedArray[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\x26gt; [PACKED_SMI_ELEMENTS (COW)]\n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e length = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e properties = \x3cspan class=\x22hljs-number\x22\x3e0x219eb0702241\x3c\/span\x3e \x26lt;FixedArray[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\x26gt; {\n\x3c\/span\x3e    #length: 0x219eb0764ac9 \x26lt;AccessorInfo\x26gt; (const accessor descriptor)\n }\n -\x3cspan class=\x22ruby\x22\x3e elements= \x3cspan class=\x22hljs-number\x22\x3e0x1fbbad30fd19\x3c\/span\x3e \x26lt;FixedArray[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\x26gt; {\n\x3c\/span\x3e           0: 1\n           1: 2\n           2: 3\n }\n[…]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，“COW” 表示写时复制，这是另一个内部优化。现在不要担心 - 这是另一个博文的主题！\x3c\/p\x3e\n\x3cp\x3e调试版本中可用的另一个有用的标志是 \x3ccode\x3e--trace-elements-transitions\x3c\/code\x3e。启用它让 V8 在任何元素发生类型转换时通知您。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ cat my-script.js\nconst array = [1, 2, 3];\narray[3] = 4.56;\n\n$ out.gn\/x64.debug\/d8 --trace-elements-transitions my-script.js\nelements transition [PACKED_SMI_ELEMENTS -\x3e PACKED_DOUBLE_ELEMENTS] in ~\x2b34 at x.js:2 for 0x1df87228c911 \x3cJSArray[3]\x3e from 0x1df87228c889 \x3cFixedArray[3]\x3e to 0x1df87228c941 \x3cFixedDoubleArray[22]\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e$ cat my-script.js\nconst array = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\narray[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e4.56\x3c\/span\x3e;\n\n$ \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e.gn\/x64.\x3cspan class=\x22hljs-keyword\x22\x3edebug\x3c\/span\x3e\/d8 --trace-elements-transitions my-script.js\nelements transition [PACKED_SMI_ELEMENTS -\x26gt; PACKED_DOUBLE_ELEMENTS] \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e ~\x2b\x3cspan class=\x22hljs-number\x22\x3e34\x3c\/span\x3e at x.js:\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex1df87228c911 \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;JSArray[3]\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex1df87228c889 \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;FixedArray[3]\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex1df87228c941 \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;FixedDoubleArray[22]\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 在 V8 中的元素种类及性能优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011303679">https://segmentfault.com/a/1190000011303679</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/0lylrmvx75zb/" target="_blank">https://alili.tech/archive/0lylrmvx75zb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>