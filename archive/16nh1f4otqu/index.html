<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript中的图片处理与合成(一)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript中的图片处理与合成(一) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/16nh1f4otqu/",
				"appid": "1613049289050283", 
				"title": "JavaScript中的图片处理与合成(一) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-12T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/kp2qv59svej/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ixi117azg2/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&text=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&text=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&title=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&is_video=false&description=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&title=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&title=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&title=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f16nh1f4otqu%2f&title=JavaScript%e4%b8%ad%e7%9a%84%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86%e4%b8%8e%e5%90%88%e6%88%90%28%e4%b8%80%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript中的图片处理与合成(一)</h1><div class="meta"><div class="postdate"><time datetime="2018-12-12" itemprop="datePublished">2018-12-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eJavaScript中的图片处理与合成(一)\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e引言：\x3c\/h2\x3e\n\x3cp\x3e图片处理现在已经成为了我们生活中的刚需，想必大家也经常有这方面的需求。实际前端业务中，也经常会有很多的项目需要用到图片加工和处理。由于过去一段时间公司的业务需求，让我在这方面积累了一些干货，趁着年后这段时间总结成一系列文章与大家分享，希望能对各位努力中的前端童鞋带来启发和帮助~~~?\x3c\/p\x3e\n\x3cp\x3e本系列分成以下4个部分:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e基础类型图片处理技术之缩放与裁剪；\x3c\/li\x3e\n\x3cli\x3e基础类型图片处理技术之图片合成；\x3c\/li\x3e\n\x3cli\x3e基础类型图片处理技术之文字合成；\x3c\/li\x3e\n\x3cli\x3e算法类型图片处理技术；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e文章中，我会提到很多在实际实践中所遇到的坑或者经验，应该算是干货满满~~如果能通读，应该能大大提升对前端图片处理领域的理解，有感兴趣的童鞋可以与我深入讨论，希望本文能达到抛砖引玉的效果，让前端在图像处理方面有更多的可能性，有不足之处望请谅解。\x3c\/p\x3e\n\x3cp\x3e通过这些积累，我封装了几个项目中常用的功能：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\n\x3cstrong\x3e图片合成:\x3c\/strong\x3e \x3ca href=\x22http:\/\/f2er.meitu.com\/gxd\/mcanvas\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExample\x3c\/a\x3e \x3ca href=\x22https:\/\/github.com\/xd-tayde\/mcanvas\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGit\x3c\/a\x3e\n\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\n\x3cstrong\x3e图片裁剪:\x3c\/strong\x3e \x3ca href=\x22http:\/\/f2er.meitu.com\/hmz\/ClipImageDemo\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExample\x3c\/a\x3e \x3ca href=\x22https:\/\/github.com\/ishareme\/clipimage\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGit\x3c\/a\x3e\n\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\n\x3cstrong\x3e人像抠除:\x3c\/strong\x3e \x3ca href=\x22http:\/\/f2er.meitu.com\/gxd\/matting\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExample\x3c\/a\x3e \x3ca href=\x22https:\/\/github.com\/xd-tayde\/matting\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGit\x3c\/a\x3e\n\x3c\/h3\x3e\n\x3cp\x3e唠叨完这些老套路后，我们开始起飞！~~✈️✈️✈️\x3c\/p\x3e\n\x3cp\x3e首先，我这里将前端图片处理暂且分成两种类型：\x3cstrong\x3e基础类型\x3c\/strong\x3e 与 \x3cstrong\x3e算法类型\x3c\/strong\x3e；\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cstrong\x3e基础类型的图片处理技术:\x3c\/strong\x3e 图片缩放，旋转，添加边框，图片合成，拼图等业务都属于基础类型的图片处理，其区分点在于\x3cstrong\x3e无需使用像素级别的算法\x3c\/strong\x3e，而是通过计算改变图片的\x3cstrong\x3e尺寸及位置\x3c\/strong\x3e等来改造图片。例如常用的贴纸功能:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4JHn?w=1500\x26amp;h=907\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4JHn?w=1500\x26amp;h=907\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cstrong\x3e算法类型的图片处理:\x3c\/strong\x3e 这类型的图片处理复杂度较高，特点是通过像素级别算法对图片的\x3cstrong\x3e像素点\x3c\/strong\x3e进行\x3ccode\x3eRGBA\x3c\/code\x3e通道值等进行改造，例如我们使用\x3ccode\x3ephotshop\x3c\/code\x3e或者美图秀秀等工具对图片进行的 美颜 \/ 滤镜 \/ 黑白 \/ 抠图 \/ 模糊等操作，这类型的重点主要在于\x3cstrong\x3e算法和性能\x3c\/strong\x3e层面。例如常用的妆容功能:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4JJe?w=1750\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4JJe?w=1750\x26amp;h=800\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e本系列首先从基础类型处理开启我们的旅程。基础类型的图片处理在实际项目中有着大量的使用场景，主要是运用\x3ccode\x3ecanvas\x3c\/code\x3e的能力来完成，不存在性能和兼容性问题，能够达到线上运行标准。我这里将基础类型的图片处理大致的分成以下几种类型，这些类型基本能覆盖日常所有业务场景：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e图片的缩放；\x3c\/li\x3e\n\x3cli\x3e图片的裁剪；\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e图片的合成；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e图片与图片的合成，例如贴纸，边框，水印等；\x3c\/li\x3e\n\x3cli\x3e为图片添加文字；\x3c\/li\x3e\n\x3cli\x3e为图片添加基础几何图形；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3eTips: 我已将该类型的图片处理场景封装成了一个\x3cstrong\x3e插件\x3c\/strong\x3e，基本上能应付所有这类型图片处理的需求，\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/xd-tayde\/mcanvas\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGIT地址\x3c\/a\x3e\x3c\/strong\x3e (欢迎探讨);\x3c\/blockquote\x3e\n\x3cp\x3e在介绍具体的功能前，由于图片的绘制完全的依赖于图片的加载，因此先来了解一些前置知识。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e1、图片的跨域\x3c\/h2\x3e\n\x3cp\x3e首先，图片加载并绘制涉及了图片的跨域问题，因此如果是一张在线的图片，需要在图片服务器上设置跨域头，并且在前端加载图片之前\x3cstrong\x3e将\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e标签的\x3ccode\x3ecrossOrigin\x3c\/code\x3e设置为\x3ccode\x3e*\x3c\/code\x3e\x3c\/strong\x3e，否则绘制到画布的时候会报跨域的错误。\x3c\/p\x3e\n\x3cp\x3eTips: 这里积累了一些小坑，可以跟大家分享下：\x3c\/p\x3e\n\x3cp\x3e1、\x3ccode\x3ecrossOrigin\x3c\/code\x3e需要严格设置，既\x3cstrong\x3e只有是线上图片时，才设置\x3c\/strong\x3e，而本地路径或者\x3ccode\x3ebase64\x3c\/code\x3e时，则一定不能设置，否则在某些系统下会报错，导致图片加载失败；\x3c\/p\x3e\n\x3cp\x3e2、当项目为本地包环境时，例如内置于 \x3ccode\x3eApp\x3c\/code\x3e中时，\x3ccode\x3ecrossOrigin\x3c\/code\x3e值无效，\x3cstrong\x3e\x3ccode\x3ewebview\x3c\/code\x3e的安全机制会导致无论该值设置与否，都会报跨域的错误。\x3c\/strong\x3e解决办法是：需要将所有图片\x3cstrong\x3e转换成\x3ccode\x3ebase64\x3c\/code\x3e\x3c\/strong\x3e才能正确绘制；\x3c\/p\x3e\n\x3cp\x3e3、\x3ccode\x3ecrossOrigin\x3c\/code\x3e值一定要在图片加载之前设置，即\x3cstrong\x3e为\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e赋值\x3ccode\x3esrc\x3c\/code\x3e之前进行设置\x3c\/strong\x3e，否则无效；\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e2、图片的加载\x3c\/h2\x3e\n\x3cp\x3e由于\x3ccode\x3ecanvas\x3c\/code\x3e的绘制需要的是已经加载完成的图片，我们需要确保绘制的素材图片是已经加载完成的，因此我们需要使用\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e的\x3ccode\x3eonload\x3c\/code\x3e事件，可以\x3cstrong\x3e使用\x3ccode\x3ehtml\x3c\/code\x3e中已存在的图片，或者用\x3ccode\x3ejs\x3c\/code\x3e创建一个图片对象:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function loadImage(image, loader, error){\n    \/\/ 创建 image 对象加载图片；\n    let img = new Image();\n    \n    \/\/ 当为线上图片时，需要设置 crossOrigin 属性；\n    if(image.indexOf(\x27http\x27) == 0)img.crossOrigin = \x27*\x27;\n    img.onload = () =\x3e {\n        loaded(img);\n        \n        \/\/ 使用完后清空该对象，释放内存；\n        setTimeout(()=\x3e{\n            img = null;\n        },1000);\n    };\n    img.onerror = () =\x3e {\n        error(\x27img load error\x27);\n    };\n    img.src = image;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eloadImage\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eimage, loader, error\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建 image 对象加载图片；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e img = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image();\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当为线上图片时，需要设置 crossOrigin 属性；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(image.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e) == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)img.crossOrigin = \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e;\n    img.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        loaded(img);\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用完后清空该对象，释放内存；\x3c\/span\x3e\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n            img = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        },\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    };\n    img.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        error(\x3cspan class=\x22hljs-string\x22\x3e\x27img load error\x27\x3c\/span\x3e);\n    };\n    img.src = image;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e介绍图片加载的前置知识后，我们先来看最简单的图片处理---缩放与裁剪！\x3c\/p\x3e\n\x3cblockquote\x3eTips: 相信大家阅读本文时，如果对\x3ccode\x3ecanvas\x3c\/code\x3e不太了解，可以查询下对应的\x3ccode\x3eAPI\x3c\/code\x3e文档即可，本文不再对\x3ccode\x3ecanvas\x3c\/code\x3e基础\x3ccode\x3eAPI\x3c\/code\x3e做详细讲解。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e一、图片的缩放\x3c\/h2\x3e\n\x3cp\x3e图片的缩放最常见的场景是做图片的\x3cstrong\x3e压缩\x3c\/strong\x3e。在保证图片清晰的前提下通过合理地缩小图片尺寸，能大大的降低图片的大小。在实际应用场景中，有着广泛的用途。例如图片上传时，用户自主上传的图片可能是一张非常大的尺寸，例如现在手机所拍摄的照片尺寸经常能达到\x3ccode\x3e1920*2560\x3c\/code\x3e的尺寸,大小可能超过5M。而在项目中，我们可能并不需要用到这么大的尺寸，此时对图片的压缩能大大的优化加载速度和节省带宽；\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e1、新建一个\x3ccode\x3ecanvas\x3c\/code\x3e画布，将宽高设置为需要压缩到的尺寸;\x3c\/h3\x3e\n\x3cp\x3e该画布既为图片缩放后的尺寸，此处有个点是需要保证图片的比例不变, 因此需要通过计算得出画布的宽与高：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let imgRatio = img.naturalWidth \/ img.naturalHeight;\n\n\/\/ 创建一个画布容器；\nlet cvs = document.createElement(\x27canvas\x27);\n\n\/\/ 获取容器中的画板；\nlet ctx = cvs.getContext(\x272d\x27);\ncvs.width = 1000;\ncvs.height = cvs.width \/ imgRatio;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e imgRatio = img.naturalWidth \/ img.naturalHeight;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个画布容器；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cvs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取容器中的画板；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ctx = cvs.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e);\ncvs.width = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\ncvs.height = cvs.width \/ imgRatio;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2、将图片画入后再导出成\x3ccode\x3ebase64\x3c\/code\x3e;\x3c\/h3\x3e\n\x3cp\x3e这里使用2个最常用的方法:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3ectx.drawImage(image, dx, dy, dw, dh)\x3c\/code\x3e: 这个方法其实最多可以接收9个参数, 实现压缩，只需要使用其中的5个参数即可, 其余参数在其它部分使用到时再做详解；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eimage : 需要绘制的图片源，需要接收已经 \x3cstrong\x3e加载完成\x3c\/strong\x3e 的\x3ccode\x3eHTMLImageElement\x3c\/code\x3e，\x3ccode\x3eHTMLCanvasElement\x3c\/code\x3e或者\x3ccode\x3eHTMLVideoElement\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3edx \/ dy : 相对于画布左上角的绘制起始点坐标；\x3c\/li\x3e\n\x3cli\x3edw \/ dh : 绘制的宽度和高度，宽高比例并不锁定，可使图片变形；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3ecvs.toDataURL(type, quality)\x3c\/code\x3e: 该方法用于将画布上的内容导出成 \x3ccode\x3ebase64\x3c\/code\x3e 格式的图片，可配置2个参数；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3etype: 图片格式, 一般可以使用 \x3ccode\x3eimage\/png\x3c\/code\x3e 或者 \x3ccode\x3eimage\/jpeg\x3c\/code\x3e, 当图片不包含透明时，建议使用\x3ccode\x3ejpeg\x3c\/code\x3e，可使导出的图片大小减小很多；\x3c\/li\x3e\n\x3cli\x3equality: 图片质量，可使用\x3ccode\x3e0~1\x3c\/code\x3e之间的任意值；经过测试，该值设置成\x3ccode\x3e0.9\x3c\/code\x3e时较为合适，可以有效减小图片文件大小且基本不影响图片清晰度，导出后的 \x3ccode\x3ebase64\x3c\/code\x3e 既为压缩后的图片；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3eTips: 此处有个坑, 想导出\x3ccode\x3ejpg\x3c\/code\x3e格式的图片必须用\x3ccode\x3eimage\/jpeg\x3c\/code\x3e，不能使用\x3ccode\x3eimage\/jpg\x3c\/code\x3e；\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将原图等比例绘制到缩放后的画布上；\nctx.drawImage(image, 0, 0, cvs.width, cvs.height);\n\n\/\/ 将绘制后的图导出成 base64 的格式；\nlet b64 = cvs.toDataURL(\x27image\/jpeg\x27, 0.9);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将原图等比例绘制到缩放后的画布上；\x3c\/span\x3e\nctx.drawImage(image, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, cvs.width, cvs.height);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将绘制后的图导出成 base64 的格式；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e b64 = cvs.toDataURL(\x3cspan class=\x22hljs-string\x22\x3e\x27image\/jpeg\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0.9\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e3.多种格式的图片转换成\x3ccode\x3ebase64\x3c\/code\x3e;\x3c\/h3\x3e\n\x3cp\x3e我们常用的图片上传功能，我们使用的是原生的\x3ccode\x3e\x26lt;input type=\x22file\x22\x26gt;\x3c\/code\x3e标签，此时获取到的是\x3ccode\x3eFile\x3c\/code\x3e格式的图片，图片的格式各异且尺寸很大，我们应该压缩处理后再使用。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e使用\x3ccode\x3eFileReader\x3c\/code\x3e:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let file = e.files[0];   \nif(window.FileReader) {       \n    let fr = new FileReader();      \n    fr.onloadend = e =\x3e {\n        let b64 = e.target.result;\n        \n        \/\/ b64即为base64格式的用户上传图;\n    };       \n    fr.readAsDataURL(file);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e file = e.files[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];   \n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.FileReader) {       \n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FileReader();      \n    fr.onloadend = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e b64 = e.target.result;\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ b64即为base64格式的用户上传图;\x3c\/span\x3e\n    };       \n    fr.readAsDataURL(file);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e对\x3ccode\x3ebase64\x3c\/code\x3e的图片使用刚才的\x3ccode\x3ecanvas\x3c\/code\x3e方式进行压缩的处理；\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eTips: 这里有个小坑是，图片的\x3ccode\x3eEXIF\x3c\/code\x3e信息中的方向值会影响图片的展示，在\x3ccode\x3eIOS\x3c\/code\x3e会出现图片的宽高与图片的方向不匹配的问题，因此需要进行特殊处理，矫正图片的方向。方案:\x3c\/p\x3e\n\x3cp\x3e1、可以使用 \x3ccode\x3eexif.js\x3c\/code\x3e 来获取图片信息中的\x3ccode\x3eOrientation\x3c\/code\x3e属性，利用\x3ccode\x3ecanvas\x3c\/code\x3e的旋转绘制来矫正；\x3c\/p\x3e\n\x3cp\x3e2、这里有个 \x3ccode\x3ecanvasResize.js\x3c\/code\x3e 插件，可以解决从 \x3ccode\x3eFile\x3c\/code\x3e 到 \x3ccode\x3ebase64\x3c\/code\x3e 的所有问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e二、图片的裁剪\x3c\/h2\x3e\n\x3cp\x3e在实际项目中，由于图片的宽高比例各式各样，而展示和使用一般需要一个较为固定的比例，此时便需要将图片裁剪成我们需要的宽高比例，使用到的方式其实和图片的缩放基本一致，主要是通过调整 \x3ccode\x3edrawImage\x3c\/code\x3e 的\x3ccode\x3edx, dy\x3c\/code\x3e参数来实现。原理其实是，将\x3ccode\x3edrawImage\x3c\/code\x3e的绘制起始点\x3ccode\x3e(dx, dy)\x3c\/code\x3e向上偏移，此时由于\x3ccode\x3ecanvas\x3c\/code\x3e已被我们设置成期望裁剪后的尺寸，而超出画布的部分不会绘制，从而达到裁剪的目的；通过灵活的设置值，基本可以完成各种图片裁剪需求，简单示例图(黑色框代表创建的画布的尺寸): \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4JHG?w=1180\x26amp;h=716\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4JHG?w=1180\x26amp;h=716\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e此处以需要将一张\x3ccode\x3e600*800\x3c\/code\x3e的长方形图竖直居中裁剪为\x3ccode\x3e600*600\x3c\/code\x3e的正方形图为例, 简单封装成一个功能函数:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 使用方式：\nlet b64 = cropImage(img, {\n    width : 600,\n    height : 600,\n});\n\n\/\/ 居中裁剪\nfunction cropImage(img, ops){\n    \/\/ 图片原始尺寸；\n    let imgOriginWidth = img.naturalWidth,\n        imgOriginHeight = img.naturalHeight;\n        \n    \/\/ 图片长宽比，保证图片不变形；\n    let imgRatio = imgOriginWidth \/ imgOriginHeight;\n    \n    \/\/ 图片裁剪后的宽高， 默认值为原图宽高；\n    let imgCropedWidth = ops.width || imgOriginWidth,\n        imgCropedHeight = ops.height || imgOriginHeight;\n        \n    \/\/ 计算得出起始坐标点的偏移量, 由于是居中裁剪，因此等于 前后差值 \/ 2；\n    let dx = (imgCropedWidth - imgOriginWidth) \/ 2,\n        dy = (imgCropedHeight - imgOriginHeight) \/ 2;\n\n    \/\/ 创建画布，并将画布设置为裁剪后的宽高；\n    let cvs = document.createElement(\x27canvas\x27);\n    let ctx = cvs.getContext(\x272d\x27);\n    cvs.width = imgCropedWidth;\n    cvs.height = imgCropedHeight;\n    \n    \/\/ 绘制并导出图片；\n    ctx.drawImage(img, dx, dy, imgCropedWidth, imgCropedWidth \/ imgRatio);\n    return cvs.toDataURL(\x27image\/jpeg\x27, 0.9);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用方式：\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e b64 = cropImage(img, {\n    \x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e600\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eheight\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e600\x3c\/span\x3e,\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 居中裁剪\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecropImage\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eimg, ops\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片原始尺寸；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e imgOriginWidth = img.naturalWidth,\n        imgOriginHeight = img.naturalHeight;\n        \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片长宽比，保证图片不变形；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e imgRatio = imgOriginWidth \/ imgOriginHeight;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片裁剪后的宽高， 默认值为原图宽高；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e imgCropedWidth = ops.width || imgOriginWidth,\n        imgCropedHeight = ops.height || imgOriginHeight;\n        \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算得出起始坐标点的偏移量, 由于是居中裁剪，因此等于 前后差值 \/ 2；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dx = (imgCropedWidth - imgOriginWidth) \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n        dy = (imgCropedHeight - imgOriginHeight) \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建画布，并将画布设置为裁剪后的宽高；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cvs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ctx = cvs.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e);\n    cvs.width = imgCropedWidth;\n    cvs.height = imgCropedHeight;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绘制并导出图片；\x3c\/span\x3e\n    ctx.drawImage(img, dx, dy, imgCropedWidth, imgCropedWidth \/ imgRatio);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cvs.toDataURL(\x3cspan class=\x22hljs-string\x22\x3e\x27image\/jpeg\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0.9\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e三、图片的旋转\x3c\/h2\x3e\n\x3cp\x3e图片的旋转的原理同样也是将图片绘制到画布上进行旋转后再导出。其实使用到的是\x3ccode\x3ecanvas\x3c\/code\x3e的\x3ccode\x3erotate\x3c\/code\x3e方法；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let cvs = document.createElement(\x27canvas\x27);\nlet ctx = cvs.getContext(\x272d\x27);\n\n\/\/ 将参照点移动到画板的中心点；\nctx.translate(ctx.width\/2, ctx.height\/2);\n\/\/ 旋转画板；\nctx.rotate = 90;\n\/\/ 绘制图片；\nctx.drawImage(img);\n\/\/ 导出得到旋转后的图片；\ncvs.toDataURL();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cvs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ctx = cvs.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将参照点移动到画板的中心点；\x3c\/span\x3e\nctx.translate(ctx.width\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, ctx.height\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 旋转画板；\x3c\/span\x3e\nctx.rotate = \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绘制图片；\x3c\/span\x3e\nctx.drawImage(img);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出得到旋转后的图片；\x3c\/span\x3e\ncvs.toDataURL();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有个比较特别的部分，就是这里旋转的是画布的画板部分，并不是整个画布容器，而画布容器外面不会被绘制，因此这里就会出现一个图像四个角被裁剪掉的问题:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4JHV?w=831\x26amp;h=424\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4JHV?w=831\x26amp;h=424\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e解决的方式就是:\x3c\/p\x3e\n\x3cp\x3e将画布容器放大，变成:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4JIn?w=989\x26amp;h=502\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4JIn?w=989\x26amp;h=502\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面这个例子中，由于图片是正方形，因此将容器的宽高放大1.5倍便可保证图片不会被裁剪，而现实中的图片由于宽高比例不定，因此这个放大系数是一个动态的值:\x3c\/p\x3e\n\x3cblockquote\x3eTips: 由于我们将画板基点移动到画布中心了，因此在绘制的时候，要相对于基点调整 \x3ccode\x3edx\x3c\/code\x3e 与 \x3ccode\x3edy\x3c\/code\x3e;\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建画布，获取画板；\n...\n\n\/\/ 放大系数为\nlet iw = img.width, ih = img.height;\nlet ir = iw \x3e ih ? iw \/ ih : ih \/ iw;\n\ncvs.width = iw * ir * 1.5;\ncvs.height = ih * ir * 1.5;\n\/\/ 将参照点移动到画板的中心点；\nctx.translate(cvs.width\/2, cvs.height\/2);\n\/\/ 旋转画板；\nctx.rotate = 90;\n\n\/\/ 绘制图片；\nctx.drawImage(img, -cvs.width\/2, -cvs.height\/2);\n\n\/\/ 导出图片；\n...\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建画布，获取画板；\x3c\/span\x3e\n...\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 放大系数为\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e iw = img.width, ih = img.height;\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ir = iw \x26gt; ih ? iw \/ ih : ih \/ iw;\n\ncvs.width = iw * ir * \x3cspan class=\x22hljs-number\x22\x3e1.5\x3c\/span\x3e;\ncvs.height = ih * ir * \x3cspan class=\x22hljs-number\x22\x3e1.5\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将参照点移动到画板的中心点；\x3c\/span\x3e\nctx.translate(cvs.width\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, cvs.height\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 旋转画板；\x3c\/span\x3e\nctx.rotate = \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绘制图片；\x3c\/span\x3e\nctx.drawImage(img, -cvs.width\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, -cvs.height\/\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出图片；\x3c\/span\x3e\n...\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e本文主要介绍了一些前端图片处理的前置知识:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e图片处理技术分类；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e基础类型图片处理技术；\x3c\/li\x3e\n\x3cli\x3e算法类型图片处理技术；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e图片的跨域；\x3c\/li\x3e\n\x3cli\x3e图片的加载；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e还有讲解了属于基础类型图片处理中最简单的两类:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e图片的缩放；\x3c\/li\x3e\n\x3cli\x3e图片的裁剪；\x3c\/li\x3e\n\x3cli\x3e图片的旋转；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e相信大家已经对图片的处理有了个大致的了解了。下篇文章，我们将继续深入研究基础类型中的图片合成，也是各种干货满满，美不胜收~~???。\x3c\/p\x3e\n\x3cp\x3e最后，非常感谢各位童鞋的阅读，有何建议或者疑惑，可以随时与我讨论哈~~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript中的图片处理与合成(一)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013483149">https://segmentfault.com/a/1190000013483149</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/16nh1f4otqu/" target="_blank">https://alili.tech/archive/16nh1f4otqu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>