<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="在 Linux 上如何得到一个段错误的核心转储"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>在 Linux 上如何得到一个段错误的核心转储 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/18b31796/",
				"appid": "1613049289050283", 
				"title": "在 Linux 上如何得到一个段错误的核心转储 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-20T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/391b577c/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6bdca400/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&text=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&text=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&title=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&is_video=false&description=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f18b31796%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&title=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&title=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&title=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f18b31796%2f&title=%e5%9c%a8%20Linux%20%e4%b8%8a%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e6%ae%b5%e9%94%99%e8%af%af%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%ac%e5%82%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">在 Linux 上如何得到一个段错误的核心转储</h1><div class="meta"><div class="postdate"><time datetime="2018-10-20" itemprop="datePublished">2018-10-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#在-linux-上如何得到一个段错误的核心转储\x22\x3e\x3c\/a\x3e在 Linux 上如何得到一个段错误的核心转储\x3c\/h1\x3e\n\x3cp\x3e本周工作中，我花了整整一周的时间来尝试调试一个段错误。我以前从来没有这样做过，我花了很长时间才弄清楚其中涉及的一些基本事情（获得核心转储、找到导致段错误的行号）。于是便有了这篇博客来解释如何做那些事情！\x3c\/p\x3e\n\x3cp\x3e在看完这篇博客后，你应该知道如何从“哦，我的程序出现段错误，但我不知道正在发生什么”到“我知道它出现段错误时的堆栈、行号了！ “。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#什么是段错误\x22\x3e\x3c\/a\x3e什么是段错误？\x3c\/h3\x3e\n\x3cp\x3e“段错误segmentation fault”是指你的程序尝试访问不允许访问的内存地址的情况。这可能是由于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e试图解引用空指针（你不被允许访问内存地址 \x3ccode\x3e0\x3c\/code\x3e）；\x3c\/li\x3e\n\x3cli\x3e试图解引用其他一些不在你内存（LCTT 译注：指不在合法的内存地址区间内）中的指针；\x3c\/li\x3e\n\x3cli\x3e一个已被破坏并且指向错误的地方的 C\x2b\x2b 虚表指针C\x2b\x2b vtable pointer，这导致程序尝试执行没有执行权限的内存中的指令；\x3c\/li\x3e\n\x3cli\x3e其他一些我不明白的事情，比如我认为访问未对齐的内存地址也可能会导致段错误（LCTT 译注：在要求自然边界对齐的体系结构，如 MIPS、ARM 中更容易因非对齐访问产生段错误）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这个“C\x2b\x2b 虚表指针”是我的程序发生段错误的情况。我可能会在未来的博客中解释这个，因为我最初并不知道任何关于 C\x2b\x2b 的知识，并且这种虚表查找导致程序段错误的情况也是我所不了解的。\x3c\/p\x3e\n\x3cp\x3e但是！这篇博客后不是关于 C\x2b\x2b 问题的。让我们谈论的基本的东西，比如，我们如何得到一个核心转储？\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#步骤1运行-valgrind\x22\x3e\x3c\/a\x3e步骤1：运行 valgrind\x3c\/h3\x3e\n\x3cp\x3e我发现找出为什么我的程序出现段错误的最简单的方式是使用 \x3ccode\x3evalgrind\x3c\/code\x3e：我运行\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs fortran\x22\x3evalgrind -v your-\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这给了我一个故障时的堆栈调用序列。 简洁！\x3c\/p\x3e\n\x3cp\x3e但我想也希望做一个更深入调查，并找出些 \x3ccode\x3evalgrind\x3c\/code\x3e 没告诉我的信息！ 所以我想获得一个核心转储并探索它。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#如何获得一个核心转储\x22\x3e\x3c\/a\x3e如何获得一个核心转储\x3c\/h3\x3e\n\x3cp\x3e核心转储core dump是您的程序内存的一个副本，并且当您试图调试您的有问题的程序哪里出错的时候它非常有用。\x3c\/p\x3e\n\x3cp\x3e当您的程序出现段错误，Linux 的内核有时会把一个核心转储写到磁盘。 当我最初试图获得一个核心转储时，我很长一段时间非常沮丧，因为 - Linux 没有生成核心转储！我的核心转储在哪里？\x3c\/p\x3e\n\x3cp\x3e这就是我最终做的事情：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在启动我的程序之前运行 \x3ccode\x3eulimit -c unlimited\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e运行 \x3ccode\x3esudo sysctl -w kernel.core_pattern=\/tmp\/core-%e.%p.%h.%t\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3\x3e\x3ca href=\x22#ulimit设置核心转储的最大尺寸\x22\x3e\x3c\/a\x3eulimit：设置核心转储的最大尺寸\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eulimit -c\x3c\/code\x3e 设置核心转储的最大尺寸。 它往往设置为 0，这意味着内核根本不会写核心转储。 它以千字节为单位。 \x3ccode\x3eulimit\x3c\/code\x3e 是按每个进程分别设置的 —— 你可以通过运行 \x3ccode\x3ecat \/proc\/PID\/limit\x3c\/code\x3e 看到一个进程的各种资源限制。\x3c\/p\x3e\n\x3cp\x3e例如这些是我的系统上一个随便一个 Firefox 进程的资源限制：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs tcl\x22\x3e$ cat \/\x3cspan class=\x22hljs-keyword\x22\x3eproc\x3c\/span\x3e\/6309\/limits\x3cspan class=\x22hljs-title\x22\x3e \nLimit\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e                    Soft\x3c\/span\x3e Limit\x3cspan class=\x22hljs-title\x22\x3e           Hard\x3c\/span\x3e Limit\x3cspan class=\x22hljs-title\x22\x3e           Units\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e cpu\x3cspan class=\x22hljs-title\x22\x3e time\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e             unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           seconds\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e  \nMax\x3c\/span\x3e file\x3cspan class=\x22hljs-title\x22\x3e size\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e            unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e data\x3cspan class=\x22hljs-title\x22\x3e size\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e            unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e stack\x3cspan class=\x22hljs-title\x22\x3e size\x3c\/span\x3e            8388608\x3cspan class=\x22hljs-title\x22\x3e              unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e core\x3cspan class=\x22hljs-title\x22\x3e file\x3c\/span\x3e size        0\x3cspan class=\x22hljs-title\x22\x3e                    unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e resident\x3cspan class=\x22hljs-title\x22\x3e set\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e         unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e processes             30571                30571\x3cspan class=\x22hljs-title\x22\x3e                processes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\nMax\x3c\/span\x3e open\x3cspan class=\x22hljs-title\x22\x3e files\x3c\/span\x3e            1024                 1048576\x3cspan class=\x22hljs-title\x22\x3e              files\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e locked\x3cspan class=\x22hljs-title\x22\x3e memory\x3c\/span\x3e         65536                65536\x3cspan class=\x22hljs-title\x22\x3e                bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e address\x3cspan class=\x22hljs-title\x22\x3e space\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e        unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e file\x3cspan class=\x22hljs-title\x22\x3e locks\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           locks\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e pending\x3cspan class=\x22hljs-title\x22\x3e signals\x3c\/span\x3e       30571                30571\x3cspan class=\x22hljs-title\x22\x3e                signals\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e  \nMax\x3c\/span\x3e msgqueue\x3cspan class=\x22hljs-title\x22\x3e size\x3c\/span\x3e         819200               819200\x3cspan class=\x22hljs-title\x22\x3e               bytes\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e    \nMax\x3c\/span\x3e nice\x3cspan class=\x22hljs-title\x22\x3e priority\x3c\/span\x3e         0                    0\x3cspan class=\x22hljs-title\x22\x3e                    \nMax\x3c\/span\x3e realtime\x3cspan class=\x22hljs-title\x22\x3e priority\x3c\/span\x3e     0                    0\x3cspan class=\x22hljs-title\x22\x3e                    \nMax\x3c\/span\x3e realtime\x3cspan class=\x22hljs-title\x22\x3e timeout\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e     unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           unlimited\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e           us\x3c\/span\x3e   \n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e内核在决定写入多大的核心转储文件时使用软限制soft limit（在这种情况下，\x3ccode\x3emax core file size = 0\x3c\/code\x3e）。 您可以使用 shell 内置命令 \x3ccode\x3eulimit\x3c\/code\x3e（\x3ccode\x3eulimit -c unlimited\x3c\/code\x3e） 将软限制增加到硬限制hard limit。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#kernelcore_pattern核心转储保存在哪里\x22\x3e\x3c\/a\x3ekernel.core_pattern：核心转储保存在哪里\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3ekernel.core_pattern\x3c\/code\x3e 是一个内核参数，或者叫 “sysctl 设置”，它控制 Linux 内核将核心转储文件写到磁盘的哪里。\x3c\/p\x3e\n\x3cp\x3e内核参数是一种设定您的系统全局设置的方法。您可以通过运行 \x3ccode\x3esysctl -a\x3c\/code\x3e 得到一个包含每个内核参数的列表，或使用 \x3ccode\x3esysctl kernel.core_pattern\x3c\/code\x3e 来专门查看 \x3ccode\x3ekernel.core_pattern\x3c\/code\x3e 设置。\x3c\/p\x3e\n\x3cp\x3e所以 \x3ccode\x3esysctl -w kernel.core_pattern=\/tmp\/core-%e.%p.%h.%t\x3c\/code\x3e 将核心转储保存到目录 \x3ccode\x3e\/tmp\x3c\/code\x3e 下，并以 \x3ccode\x3ecore\x3c\/code\x3e 加上一系列能够标识（出故障的）进程的参数构成的后缀为文件名。\x3c\/p\x3e\n\x3cp\x3e如果你想知道这些形如 \x3ccode\x3e%e\x3c\/code\x3e、\x3ccode\x3e%p\x3c\/code\x3e 的参数都表示什么，请参考 \x3ca href=\x22http:\/\/man7.org\/linux\/man-pages\/man5\/core.5.html\x22\x3eman core\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e有一点很重要，\x3ccode\x3ekernel.core_pattern\x3c\/code\x3e 是一个全局设置 —— 修改它的时候最好小心一点，因为有可能其它系统功能依赖于把它被设置为一个特定的方式（才能正常工作）。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#kernelcore_pattern-和-ubuntu\x22\x3e\x3c\/a\x3ekernel.core_pattern 和 Ubuntu\x3c\/h3\x3e\n\x3cp\x3e默认情况下在 ubuntu 系统中，\x3ccode\x3ekernel.core_pattern\x3c\/code\x3e 被设置为下面的值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cos\x22\x3e$ sysctl kernel.core_pattern\nkernel.core_pattern = |\/usr\/share\/apport\/apport \x3cspan class=\x22hljs-built_in\x22\x3e%p\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3e%s\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3e%c\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3e%d\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3e%P\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这引起了我的迷惑（这 apport 是干什么的，它对我的核心转储做了什么？）。以下关于这个我了解到的：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eUbuntu 使用一种叫做 apport 的系统来报告 apt 包有关的崩溃信息。\x3c\/li\x3e\n\x3cli\x3e设定 \x3ccode\x3ekernel.core_pattern=|\/usr\/share\/apport\/apport %p %s %c %d %P\x3c\/code\x3e 意味着核心转储将被通过管道送给 \x3ccode\x3eapport\x3c\/code\x3e 程序。\x3c\/li\x3e\n\x3cli\x3eapport 的日志保存在文件 \x3ccode\x3e\/var\/log\/apport.log\x3c\/code\x3e 中。\x3c\/li\x3e\n\x3cli\x3eapport 默认会忽略来自不属于 Ubuntu 软件包一部分的二进制文件的崩溃信息\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我最终只是跳过了 apport，并把 \x3ccode\x3ekernel.core_pattern\x3c\/code\x3e 重新设置为 \x3ccode\x3esysctl -w kernel.core_pattern=\/tmp\/core-%e.%p.%h.%t\x3c\/code\x3e，因为我在一台开发机上，我不在乎 apport 是否工作，我也不想尝试让 apport 把我的核心转储留在磁盘上。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#现在你有了核心转储接下来干什么\x22\x3e\x3c\/a\x3e现在你有了核心转储，接下来干什么？\x3c\/h3\x3e\n\x3cp\x3e好的，现在我们了解了 \x3ccode\x3eulimit\x3c\/code\x3e 和 \x3ccode\x3ekernel.core_pattern\x3c\/code\x3e ，并且实际上在磁盘的 \x3ccode\x3e\/tmp\x3c\/code\x3e 目录中有了一个核心转储文件。太好了！接下来干什么？我们仍然不知道该程序为什么会出现段错误！\x3c\/p\x3e\n\x3cp\x3e下一步将使用 \x3ccode\x3egdb\x3c\/code\x3e 打开核心转储文件并获取堆栈调用序列。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#从-gdb-中得到堆栈调用序列\x22\x3e\x3c\/a\x3e从 gdb 中得到堆栈调用序列\x3c\/h3\x3e\n\x3cp\x3e你可以像这样用 \x3ccode\x3egdb\x3c\/code\x3e 打开一个核心转储文件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e gdb -c my_core_file\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，我们想知道程序崩溃时的堆栈是什么样的。在 \x3ccode\x3egdb\x3c\/code\x3e 提示符下运行 \x3ccode\x3ebt\x3c\/code\x3e 会给你一个调用序列backtrace。在我的例子里，\x3ccode\x3egdb\x3c\/code\x3e 没有为二进制文件加载符号信息，所以这些函数名就像 “??????”。幸运的是，（我们通过）加载符号修复了它。\x3c\/p\x3e\n\x3cp\x3e下面是如何加载调试符号。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3esymbol-\x3cspan class=\x22hljs-built_in\x22\x3efile\x3c\/span\x3e \/path\/\x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3emy\x3c\/span\x3e\/binary\nsharedlibrary\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这从二进制文件及其引用的任何共享库中加载符号。一旦我这样做了，当我执行 \x3ccode\x3ebt\x3c\/code\x3e 时，gdb 给了我一个带有行号的漂亮的堆栈跟踪！\x3c\/p\x3e\n\x3cp\x3e如果你想它能工作，二进制文件应该以带有调试符号信息的方式被编译。在试图找出程序崩溃的原因时，堆栈跟踪中的行号非常有帮助。:)\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#查看每个线程的堆栈\x22\x3e\x3c\/a\x3e查看每个线程的堆栈\x3c\/h3\x3e\n\x3cp\x3e通过以下方式在 \x3ccode\x3egdb\x3c\/code\x3e 中获取每个线程的调用栈！\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lasso\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethread\x3c\/span\x3e apply \x3cspan class=\x22hljs-literal\x22\x3eall\x3c\/span\x3e bt \x3cspan class=\x22hljs-literal\x22\x3efull\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22#gdb--核心转储--惊喜\x22\x3e\x3c\/a\x3egdb \x2b 核心转储 = 惊喜\x3c\/h3\x3e\n\x3cp\x3e如果你有一个带调试符号的核心转储以及 \x3ccode\x3egdb\x3c\/code\x3e，那太棒了！您可以上下查看调用堆栈（LCTT 译注：指跳进调用序列不同的函数中以便于查看局部变量），打印变量，并查看内存来得知发生了什么。这是最好的。\x3c\/p\x3e\n\x3cp\x3e如果您仍然正在基于 gdb 向导来工作上，只打印出栈跟踪与bt也可以。 :)\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#asan\x22\x3e\x3c\/a\x3eASAN\x3c\/h3\x3e\n\x3cp\x3e另一种搞清楚您的段错误的方法是使用 AddressSanitizer 选项编译程序（“ASAN”，即 \x3ccode\x3e$CC -fsanitize=address\x3c\/code\x3e）然后运行它。 本文中我不准备讨论那个，因为本文已经相当长了，并且在我的例子中打开 ASAN 后段错误消失了，可能是因为 ASAN 使用了一个不同的内存分配器（系统内存分配器，而不是 tcmalloc）。\x3c\/p\x3e\n\x3cp\x3e在未来如果我能让 ASAN 工作，我可能会多写点有关它的东西。（LCTT 译注：这里指使用 ASAN 也能复现段错误）\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#从一个核心转储得到一个堆栈跟踪真的很亲切\x22\x3e\x3c\/a\x3e从一个核心转储得到一个堆栈跟踪真的很亲切！\x3c\/h3\x3e\n\x3cp\x3e这个博客听起来很多，当我做这些的时候很困惑，但说真的，从一个段错误的程序中获得一个堆栈调用序列不需要那么多步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e试试用 \x3ccode\x3evalgrind\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如果那没用，或者你想要拿到一个核心转储来调查：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e确保二进制文件编译时带有调试符号信息；\x3c\/li\x3e\n\x3cli\x3e正确的设置 \x3ccode\x3eulimit\x3c\/code\x3e 和 \x3ccode\x3ekernel.core_pattern\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e运行程序；\x3c\/li\x3e\n\x3cli\x3e一旦你用 \x3ccode\x3egdb\x3c\/code\x3e 调试核心转储了，加载符号并运行 \x3ccode\x3ebt\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e尝试找出发生了什么！\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我可以使用 \x3ccode\x3egdb\x3c\/code\x3e 弄清楚有个 C\x2b\x2b 的虚表条目指向一些被破坏的内存，这有点帮助，并且使我感觉好像更懂了 C\x2b\x2b 一点。也许有一天我们会更多地讨论如何使用 \x3ccode\x3egdb\x3c\/code\x3e 来查找问题！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/jvns.ca\/blog\/2018\/04\/28\/debugging-a-segfault-on-linux\/\x22\x3ehttps:\/\/jvns.ca\/blog\/2018\/04\/28\/debugging-a-segfault-on-linux\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/jvns.ca\/about\/\x22\x3eJulia Evans\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/stephenxs\x22\x3estephenxs\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/how-to-get-a-core-dump-for-a-segfault-on-linux">https://www.zcfy.cc/article/how-to-get-a-core-dump-for-a-segfault-on-linux</a> 原文标题: 在 Linux 上如何得到一个段错误的核心转储 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/18b31796/" target="_blank">https://alili.tech/archive/18b31796/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>