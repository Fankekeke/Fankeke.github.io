<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/1a007021/",
				"appid": "1613049289050283", 
				"title": "从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-23T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/58ca5aa3/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cb6887ef/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&text=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&text=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&title=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&is_video=false&description=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f1a007021%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&title=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&title=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&title=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1a007021%2f&title=%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%88%b0JS%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8cJS%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%9c%80%e5%85%a8%e9%9d%a2%e7%9a%84%e4%b8%80%e6%ac%a1%e6%a2%b3%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</h1><div class="meta"><div class="postdate"><time datetime="2018-10-23" itemprop="datePublished">2018-10-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e见解有限，如有描述不当之处，请帮忙及时指出，如有错误，会及时修正。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------超长文\x2b多图预警，需要花费不少时间。----------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e如果看完本文后，还对进程线程傻傻分不清，不清楚浏览器多进程、浏览器内核多线程、JS单线程、JS运行机制的区别。那么请回复我，一定是我写的还不够清晰，我来改。。。\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------正文开始----------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e最近发现有不少介绍JS单线程运行机制的文章，但是发现很多都仅仅是介绍某一部分的知识，而且各个地方的说法还不统一，容易造成困惑。\x3cbr\x3e因此准备梳理这块知识点，结合已有的认知，基于网上的大量参考资料，\x3cbr\x3e从浏览器多进程到JS单线程，将JS引擎的运行机制系统的梳理一遍。\x3c\/p\x3e\n\x3cp\x3e展现形式：由于是属于系统梳理型，就没有由浅入深了，而是从头到尾的梳理知识体系，\x3cbr\x3e重点是将关键节点的知识点串联起来，而不是仅仅剖析某一部分知识。\x3c\/p\x3e\n\x3cp\x3e内容是：从浏览器进程，再到浏览器内核运行，再到JS引擎单线程，再到JS事件循环机制，从头到尾系统的梳理一遍，摆脱碎片化，形成一个知识体系\x3c\/p\x3e\n\x3cp\x3e目标是：看完这篇文章后，对浏览器多进程，JS单线程，JS事件循环机制这些都能有一定理解，\x3cbr\x3e有一个知识体系骨架，而不是似懂非懂的感觉。\x3c\/p\x3e\n\x3cp\x3e另外，本文适合有一定经验的前端人员，\x3cstrong\x3e新手请规避\x3c\/strong\x3e，避免受到过多的概念冲击。可以先存起来，有了一定理解后再看，也可以分成多批次观看，避免过度疲劳。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e大纲\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e区分进程和线程\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e浏览器是多进程的\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e浏览器都包含哪些进程？\x3c\/li\x3e\n\x3cli\x3e浏览器多进程的优势\x3c\/li\x3e\n\x3cli\x3e重点是浏览器内核（渲染进程）\x3c\/li\x3e\n\x3cli\x3eBrowser进程和浏览器内核（Renderer进程）的通信过程\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e梳理浏览器内核中线程之间的关系\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eGUI渲染线程与JS引擎线程互斥\x3c\/li\x3e\n\x3cli\x3eJS阻塞页面加载\x3c\/li\x3e\n\x3cli\x3eWebWorker，JS的多线程？\x3c\/li\x3e\n\x3cli\x3eWebWorker与SharedWorker\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e简单梳理下浏览器渲染流程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eload事件与DOMContentLoaded事件的先后\x3c\/li\x3e\n\x3cli\x3ecss加载是否会阻塞dom树渲染？\x3c\/li\x3e\n\x3cli\x3e普通图层和复合图层\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e从Event Loop谈JS的运行机制\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e事件循环机制进一步补充\x3c\/li\x3e\n\x3cli\x3e单独说说定时器\x3c\/li\x3e\n\x3cli\x3esetTimeout而不是setInterval\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e事件循环进阶：macrotask与microtask\x3c\/li\x3e\n\x3cli\x3e写在最后的话\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e区分进程和线程\x3c\/h2\x3e\n\x3cp\x3e线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- 进程是一个工厂，工厂有它的独立资源\n\n- 工厂之间相互独立\n\n- 线程是工厂中的工人，多个工人协作完成任务\n\n- 工厂内有一个或多个工人\n\n- 工人之间共享空间\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e- 进程是一个工厂，工厂有它的独立资源\n\n- 工厂之间相互独立\n\n- 线程是工厂中的工人，多个工人协作完成任务\n\n- 工厂内有一个或多个工人\n\n- 工人之间共享空间\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再完善完善概念：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- 工厂的资源 -\x3e 系统分配的内存（独立的一块内存）\n\n- 工厂之间的相互独立 -\x3e 进程之间相互独立\n\n- 多个工人协作完成任务 -\x3e 多个线程在进程中协作完成任务\n\n- 工厂内有一个或多个工人 -\x3e 一个进程由一个或多个线程组成\n\n- 工人之间共享空间 -\x3e 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e- 工厂的资源 -\x26gt; 系统分配的内存（独立的一块内存）\n\n- 工厂之间的相互独立 -\x26gt; 进程之间相互独立\n\n- 多个工人协作完成任务 -\x26gt; 多个线程在进程中协作完成任务\n\n- 工厂内有一个或多个工人 -\x26gt; 一个进程由一个或多个线程组成\n\n- 工人之间共享空间 -\x26gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后再巩固下：\x3c\/p\x3e\n\x3cp\x3e如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925877?w=900\x26amp;h=655\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e所以，应该更容易理解了：\x3cstrong\x3e进程是cpu资源分配的最小单位（系统会给它分配内存）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e最后，再用较为官方的术语描述一遍：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\x3c\/li\x3e\n\x3cli\x3e线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3etips\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e不同进程之间也可以通信，不过代价较大\x3c\/li\x3e\n\x3cli\x3e现在，一般通用的叫法：\x3cstrong\x3e单线程与多线程\x3c\/strong\x3e，都是指\x3cstrong\x3e在一个进程内\x3c\/strong\x3e的单和多。（所以核心还是得属于一个进程才行）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e浏览器是多进程的\x3c\/h2\x3e\n\x3cp\x3e理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e浏览器是多进程的\x3c\/li\x3e\n\x3cli\x3e浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\x3c\/li\x3e\n\x3cli\x3e简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e关于以上几点的验证，\x3cstrong\x3e请再第一张图\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925878?w=900\x26amp;h=539\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925878?w=900\x26amp;h=539\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e图中打开了\x3ccode\x3eChrome\x3c\/code\x3e浏览器的多个标签页，然后可以在\x3ccode\x3eChrome的任务管理器\x3c\/code\x3e中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。\x3cbr\x3e感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会\x2b1以上\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了\x3cbr\x3e（所以每一个Tab标签对应一个进程并不一定是绝对的）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e浏览器都包含哪些进程？\x3c\/h3\x3e\n\x3cp\x3e知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3eBrowser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e负责浏览器界面显示，与用户交互。如前进，后退等\x3c\/li\x3e\n\x3cli\x3e负责各个页面的管理，创建和销毁其他进程\x3c\/li\x3e\n\x3cli\x3e将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\x3c\/li\x3e\n\x3cli\x3e网络资源的管理，下载等\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\x3c\/li\x3e\n\x3cli\x3eGPU进程：最多一个，用于3D绘制等\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e页面渲染，脚本执行，事件处理等\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e强化记忆：\x3cstrong\x3e在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925879?w=900\x26amp;h=438\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e另外，可以通过Chrome的\x3ccode\x3e更多工具 -\x26gt; 任务管理器\x3c\/code\x3e自行验证\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e浏览器多进程的优势\x3c\/h3\x3e\n\x3cp\x3e相比于单进程浏览器，多进程有如下优点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e避免单个page crash影响整个浏览器\x3c\/li\x3e\n\x3cli\x3e避免第三方插件crash影响整个浏览器\x3c\/li\x3e\n\x3cli\x3e多进程充分利用多核优势\x3c\/li\x3e\n\x3cli\x3e方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e简单点理解：\x3cstrong\x3e如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当然，内存等资源消耗也会更大，有点空间换时间的意思。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e重点是浏览器内核（渲染进程）\x3c\/h3\x3e\n\x3cp\x3e重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是\x3cstrong\x3e渲染进程\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e请牢记，浏览器的渲染进程是多线程的\x3c\/strong\x3e（这点如果不理解，\x3cstrong\x3e请回头看进程和线程的区分\x3c\/strong\x3e）\x3c\/p\x3e\n\x3cp\x3e终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3eGUI渲染线程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\x3c\/li\x3e\n\x3cli\x3e当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\x3c\/li\x3e\n\x3cli\x3e注意，\x3cstrong\x3eGUI渲染线程与JS引擎线程是互斥的\x3c\/strong\x3e，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中\x3cstrong\x3e等到JS引擎空闲时\x3c\/strong\x3e立即被执行。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eJS引擎线程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\x3c\/li\x3e\n\x3cli\x3eJS引擎线程负责解析Javascript脚本，运行代码。\x3c\/li\x3e\n\x3cli\x3eJS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\x3c\/li\x3e\n\x3cli\x3e同样注意，\x3cstrong\x3eGUI渲染线程与JS引擎线程是互斥的\x3c\/strong\x3e，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e事件触发线程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\x3c\/li\x3e\n\x3cli\x3e当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\x3c\/li\x3e\n\x3cli\x3e当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e定时触发器线程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e传说中的\x3ccode\x3esetInterval\x3c\/code\x3e与\x3ccode\x3esetTimeout\x3c\/code\x3e所在线程\x3c\/li\x3e\n\x3cli\x3e浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\x3c\/li\x3e\n\x3cli\x3e因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\x3c\/li\x3e\n\x3cli\x3e注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e异步http请求线程\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\x3c\/li\x3e\n\x3cli\x3e将检测到状态变更时，如果设置有回调函数，异步线程就\x3cstrong\x3e产生状态变更事件\x3c\/strong\x3e，将这个回调再放入事件队列中。再由JavaScript引擎执行。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于\x3ccode\x3e事件触发线程\x3c\/code\x3e的，所以如果仅仅是看某个碎片化知识，\x3cbr\x3e可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925880?w=287\x26amp;h=577\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925880?w=287\x26amp;h=577\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eBrowser进程和浏览器内核（Renderer进程）的通信过程\x3c\/h3\x3e\n\x3cp\x3e看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，\x3cbr\x3e这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。\x3c\/p\x3e\n\x3cp\x3e如果自己打开任务管理器，然后打开一个浏览器，就可以看到：\x3cstrong\x3e任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）\x3c\/strong\x3e，\x3cbr\x3e然后在这前提下，看下整个的过程：(简化了很多)\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eBrowser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eRenderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染\x3c\/li\x3e\n\x3cli\x3e当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）\x3c\/li\x3e\n\x3cli\x3e最后Render进程将结果传递给Browser进程\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3eBrowser进程接收到结果并将结果绘制出来\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里绘一张简单的图：（很简化）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925881?w=470\x26amp;h=325\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。\x3c\/p\x3e\n\x3cp\x3e这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。\x3c\/p\x3e\n\x3cp\x3e如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e梳理浏览器内核中线程之间的关系\x3c\/h2\x3e\n\x3cp\x3e到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eGUI渲染线程与JS引擎线程互斥\x3c\/h3\x3e\n\x3cp\x3e由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\x3c\/p\x3e\n\x3cp\x3e因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，\x3cbr\x3eGUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eJS阻塞页面加载\x3c\/h3\x3e\n\x3cp\x3e从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。\x3c\/p\x3e\n\x3cp\x3e譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。\x3cbr\x3e然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\x3c\/p\x3e\n\x3cp\x3e所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eWebWorker，JS的多线程？\x3c\/h3\x3e\n\x3cp\x3e前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？\x3c\/p\x3e\n\x3cp\x3e所以，后来HTML5中支持了\x3ccode\x3eWeb Worker\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eMDN的官方解释是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面\n\n一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 \n\n这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window\n\n因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eWeb Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面\n\n一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 \n\n这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e\n\n因此，使用 \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样理解下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）\x3c\/li\x3e\n\x3cli\x3eJS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，\x3cbr\x3e只待计算出结果后，将结果通信给主线程即可，perfect!\x3c\/p\x3e\n\x3cp\x3e而且注意下，\x3cstrong\x3eJS引擎是单线程的\x3c\/strong\x3e，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。\x3c\/p\x3e\n\x3cp\x3e其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eWebWorker与SharedWorker\x3c\/h3\x3e\n\x3cp\x3e既然都到了这里，就再提一下\x3ccode\x3eSharedWorker\x3c\/code\x3e（避免后续将这两个概念搞混）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eWebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eSharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e简单梳理下浏览器渲染流程\x3c\/h2\x3e\n\x3cp\x3e本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）\x3c\/p\x3e\n\x3cp\x3e为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- 浏览器输入url，浏览器主进程接管，开一个下载线程，\n然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n随后将内容通过RendererHost接口转交给Renderer进程\n\n- 浏览器渲染流程开始\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e- 浏览器输入url，浏览器主进程接管，开一个下载线程，\n然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n随后将内容通过RendererHost接口转交给Renderer进程\n\n- 浏览器渲染流程开始\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e解析html建立dom树\x3c\/li\x3e\n\x3cli\x3e解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\x3c\/li\x3e\n\x3cli\x3e布局render树（Layout\/reflow），负责各元素尺寸、位置的计算\x3c\/li\x3e\n\x3cli\x3e绘制render树（paint），绘制页面像素信息\x3c\/li\x3e\n\x3cli\x3e浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所有详细步骤都已经略去，渲染完毕后就是\x3ccode\x3eload\x3c\/code\x3e事件了，之后就是自己的JS逻辑处理了\x3c\/p\x3e\n\x3cp\x3e既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。\x3c\/p\x3e\n\x3cp\x3e这里重绘参考来源中的一张图：（参考来源第一篇）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012934765?w=900\x26amp;h=352\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012934765?w=900\x26amp;h=352\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eload事件与DOMContentLoaded事件的先后\x3c\/h3\x3e\n\x3cp\x3e上面提到，渲染完毕后会触发\x3ccode\x3eload\x3c\/code\x3e事件，那么你能分清楚\x3ccode\x3eload\x3c\/code\x3e事件与\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件的先后么？\x3c\/p\x3e\n\x3cp\x3e很简单，知道它们的定义就可以了：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e(譬如如果有async加载的脚本就不一定完成)\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e（渲染完毕了）\x3c\/p\x3e\n\x3cp\x3e所以，顺序是：\x3ccode\x3eDOMContentLoaded -\x26gt; load\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3ecss加载是否会阻塞dom树渲染？\x3c\/h3\x3e\n\x3cp\x3e这里说的是头部引入css的情况\x3c\/p\x3e\n\x3cp\x3e首先，我们都知道：\x3cstrong\x3ecss是由单独的下载线程异步下载的。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e然后再说下几个现象：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ecss加载不会阻塞DOM树解析（异步加载时DOM照常构建）\x3c\/li\x3e\n\x3cli\x3e但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这可能也是浏览器的一种优化机制。\x3c\/p\x3e\n\x3cp\x3e因为你加载css的时候，可能会修改下面DOM节点的样式，\x3cbr\x3e如果css加载不阻塞render树渲染的话，那么当css加载完之后，\x3cbr\x3erender树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。\x3cbr\x3e所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，\x3cbr\x3e在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e普通图层和复合图层\x3c\/h3\x3e\n\x3cp\x3e渲染步骤中就提到了\x3ccode\x3ecomposite\x3c\/code\x3e概念。\x3c\/p\x3e\n\x3cp\x3e可以简单的这样理解，浏览器渲染的图层一般包含两大类：\x3ccode\x3e普通图层\x3c\/code\x3e以及\x3ccode\x3e复合图层\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e首先，普通文档流内可以理解为一个复合图层（这里称为\x3ccode\x3e默认复合层\x3c\/code\x3e，里面不管添加多少元素，其实都是在同一个复合图层中）\x3c\/p\x3e\n\x3cp\x3e其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于\x3ccode\x3e默认复合层\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e然后，可以通过\x3ccode\x3e硬件加速\x3c\/code\x3e的方式，声明一个\x3ccode\x3e新的复合图层\x3c\/code\x3e，它会单独分配资源\x3cbr\x3e（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响\x3ccode\x3e默认复合层\x3c\/code\x3e里的回流重绘）\x3c\/p\x3e\n\x3cp\x3e可以简单理解下：\x3cstrong\x3eGPU中，各个复合图层是单独绘制的，所以互不影响\x3c\/strong\x3e，这也是为什么某些场景硬件加速效果一级棒\x3c\/p\x3e\n\x3cp\x3e可以\x3ccode\x3eChrome源码调试 -\x26gt; More Tools -\x26gt; Rendering -\x26gt; Layer borders\x3c\/code\x3e中看到，黄色的就是复合图层信息\x3c\/p\x3e\n\x3cp\x3e如下图。可以验证上述的说法\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925882?w=900\x26amp;h=564\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e如何变成复合图层（硬件加速）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e将该元素变成一个复合图层，就是传说中的硬件加速技术\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e最常用的方式：\x3ccode\x3etranslate3d\x3c\/code\x3e、\x3ccode\x3etranslateZ\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eopacity\x3c\/code\x3e属性\/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ewill-chang\x3c\/code\x3e属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e\x26lt;video\x26gt;\x26lt;iframe\x26gt;\x26lt;canvas\x26gt;\x26lt;webgl\x26gt;\x3c\/code\x3e等元素\x3c\/li\x3e\n\x3cli\x3e其它，譬如以前的flash插件\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eabsolute和硬件加速的区别\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。\x3cbr\x3e所以，就算absolute中信息改变时不会改变普通文档流中render树，\x3cbr\x3e但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。\x3cbr\x3e（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\x3c\/p\x3e\n\x3cp\x3e而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层\x3cbr\x3e（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e复合图层的作用？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能\x3c\/p\x3e\n\x3cp\x3e但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e硬件加速时请使用index\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染\x3c\/p\x3e\n\x3cp\x3e具体的原理时这样的：\x3cbr\x3e**webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，\x3cbr\x3e那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），\x3cbr\x3e会默认变为复合层渲染，如果处理不当会极大的影响性能**\x3c\/p\x3e\n\x3cp\x3e简单点理解，其实可以认为是一个隐式合成的概念：\x3cstrong\x3e如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层\x3c\/strong\x3e，这点需要特别注意\x3c\/p\x3e\n\x3cp\x3e另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/web.jobbole.com\/83575\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/web.jobbole.com\/83575\/\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e从Event Loop谈JS的运行机制\x3c\/h2\x3e\n\x3cp\x3e到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。\x3c\/p\x3e\n\x3cp\x3e注意，这里不谈\x3ccode\x3e可执行上下文\x3c\/code\x3e，\x3ccode\x3eVO\x3c\/code\x3e，\x3ccode\x3escop chain\x3c\/code\x3e等概念（这些完全可以整理成另一篇文章了），这里主要是结合\x3ccode\x3eEvent Loop\x3c\/code\x3e来谈JS代码是如何执行的。\x3c\/p\x3e\n\x3cp\x3e读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eJS引擎线程\x3c\/li\x3e\n\x3cli\x3e事件触发线程\x3c\/li\x3e\n\x3cli\x3e定时触发器线程\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e然后再理解一个概念：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eJS分为同步任务和异步任务\x3c\/li\x3e\n\x3cli\x3e同步任务都在主线程上执行，形成一个\x3ccode\x3e执行栈\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e主线程之外，\x3cstrong\x3e事件触发线程\x3c\/strong\x3e管理着一个\x3ccode\x3e任务队列\x3c\/code\x3e，只要异步任务有了运行结果，就在\x3ccode\x3e任务队列\x3c\/code\x3e之中放置一个事件。\x3c\/li\x3e\n\x3cli\x3e一旦\x3ccode\x3e执行栈\x3c\/code\x3e中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取\x3ccode\x3e任务队列\x3c\/code\x3e，将可运行的异步任务添加到可执行栈中，开始执行。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e看图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925883?w=610\x26amp;h=637\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，\x3cbr\x3e所以自然有误差。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e事件循环机制进一步补充\x3c\/h3\x3e\n\x3cp\x3e这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《\x3ca href=\x22http:\/\/vimeo.com\/96425312\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHelp, I\x27m stuck in an event-loop\x3c\/a\x3e》）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925884?w=636\x26amp;h=518\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图大致描述就是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e主线程运行时会产生执行栈，\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调\x3c\/li\x3e\n\x3cli\x3e如此循环\x3c\/li\x3e\n\x3cli\x3e注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e单独说说定时器\x3c\/h3\x3e\n\x3cp\x3e上述事件循环机制的核心是：JS引擎线程和事件触发线程\x3c\/p\x3e\n\x3cp\x3e但事件上，里面还有一些隐藏细节，譬如调用\x3ccode\x3esetTimeout\x3c\/code\x3e后，是如何等待特定时间后才添加到事件队列中的？\x3c\/p\x3e\n\x3cp\x3e是JS引擎检测的么？当然不是了。它是由\x3cstrong\x3e定时器线程\x3c\/strong\x3e控制（因为JS引擎自己都忙不过来，根本无暇分身）\x3c\/p\x3e\n\x3cp\x3e为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。\x3c\/p\x3e\n\x3cp\x3e什么时候会用到定时器线程？\x3cstrong\x3e当使用\x3ccode\x3esetTimeout\x3c\/code\x3e或\x3ccode\x3esetInterval\x3c\/code\x3e时\x3c\/strong\x3e，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\x3c\/p\x3e\n\x3cp\x3e譬如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(function(){\n    console.log(\x27hello!\x27);\n}, 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello!\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码的作用是当\x3ccode\x3e1000\x3c\/code\x3e毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(function(){\n    console.log(\x27hello!\x27);\n}, 0);\n\nconsole.log(\x27begin\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello!\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行\x3c\/p\x3e\n\x3cp\x3e注意：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e执行结果是：先\x3ccode\x3ebegin\x3c\/code\x3e后\x3ccode\x3ehello!\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e(不过也有一说是不同浏览器有不同的最小时间设定)\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行\x3ccode\x3ebegin\x3c\/code\x3e（因为只有可执行栈内空了后才会主动读取事件队列）\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3esetTimeout而不是setInterval\x3c\/h3\x3e\n\x3cp\x3e用setTimeout模拟定期计时和直接用setInterval是有区别的。\x3c\/p\x3e\n\x3cp\x3e因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差\x3cbr\x3e（误差多少与代码执行时间有关）\x3c\/p\x3e\n\x3cp\x3e而setInterval则是每次都精确的隔一段时间推入一个事件\x3cbr\x3e（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\x3c\/p\x3e\n\x3cp\x3e而且setInterval有一些比较致命的问题就是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e就会导致定时器代码连续运行好几次，而之间没有间隔。\x3cbr\x3e就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cdel\x3e譬如像iOS的webview,或者Safari等浏览器中都有一个特点，\x3cstrong\x3e在滚动的时候是不执行JS的\x3c\/strong\x3e，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误\x3c\/del\x3e（这一块后续有补充，setInterval自带的优化，不会重复添加回调）\x3c\/li\x3e\n\x3cli\x3e而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时\x3c\/p\x3e\n\x3cp\x3e所以，鉴于这么多但问题，目前一般认为的最佳方案是：\x3cstrong\x3e用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader21\x22\x3e事件循环进阶：macrotask与microtask\x3c\/h2\x3e\n\x3cp\x3e这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），\x3cbr\x3e强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x27script start\x27);\n\nsetTimeout(function() {\n    console.log(\x27setTimeout\x27);\n}, 0);\n\nPromise.resolve().then(function() {\n    console.log(\x27promise1\x27);\n}).then(function() {\n    console.log(\x27promise2\x27);\n});\n\nconsole.log(\x27script end\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27script start\x27\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27setTimeout\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise1\x27\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise2\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27script end\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e嗯哼，它的正确执行顺序是这样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22script start\nscript end\npromise1\npromise2\nsetTimeout\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3escript start\nscript end\npromise1\npromise2\nsetTimeout\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么呢？因为Promise里有了一个一个新的概念：\x3ccode\x3emicrotask\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e或者，进一步，JS中分为两种任务类型：\x3cstrong\x3e\x3ccode\x3emacrotask\x3c\/code\x3e和\x3ccode\x3emicrotask\x3c\/code\x3e\x3c\/strong\x3e，在ECMAScript中，microtask称为\x3ccode\x3ejobs\x3c\/code\x3e，macrotask可称为\x3ccode\x3etask\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e它们的定义？区别？简单点可以按如下理解：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3emacrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e每一个task会从头到尾将这个任务执行完毕，不会执行其它\x3c\/li\x3e\n\x3cli\x3e浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22（`task-\x3e渲染-\x3etask-\x3e...`）\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e（`task-\x26gt;渲染-\x26gt;task-\x26gt;...`）\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3emicrotask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e也就是说，在当前task任务后，下一个task之前，在渲染之前\x3c\/li\x3e\n\x3cli\x3e所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\x3c\/li\x3e\n\x3cli\x3e也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e分别很么样的场景会形成macrotask和microtask呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3emacrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）\x3c\/li\x3e\n\x3cli\x3emicrotask：Promise，process.nextTick等\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e__补充：在node环境下，process.nextTick的优先级高于Promise__，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。\x3c\/p\x3e\n\x3cp\x3e参考：\x3ca href=\x22https:\/\/segmentfault.com\/q\/1010000011914016\x22\x3ehttps:\/\/segmentfault.com\/q\/1010000011914016\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e再根据线程来理解下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3emacrotask中的事件都是放在一个事件队列中的，而这个队列由\x3cstrong\x3e事件触发线程\x3c\/strong\x3e维护\x3c\/li\x3e\n\x3cli\x3emicrotask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由\x3cstrong\x3eJS引擎线程维护\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e（这点由自己理解\x2b推测得出，因为它是在主线程下无缝执行的）\x3c\/p\x3e\n\x3cp\x3e所以，总结下运行机制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e执行一个宏任务（栈中没有就从事件队列中获取）\x3c\/li\x3e\n\x3cli\x3e执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\x3c\/li\x3e\n\x3cli\x3e宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\x3c\/li\x3e\n\x3cli\x3e当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\x3c\/li\x3e\n\x3cli\x3e渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012925885?w=392\x26amp;h=740\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e另外，请注意下\x3ccode\x3ePromise\x3c\/code\x3e的\x3ccode\x3epolyfill\x3c\/code\x3e与官方版本的区别：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e官方版本中，是标准的microtask形式\x3c\/li\x3e\n\x3cli\x3epolyfill，一般都是通过setTimeout模拟的，所以是macrotask形式\x3c\/li\x3e\n\x3cli\x3e请特别注意这两点区别\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），\x3cbr\x3e但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e20180126补充：使用MutationObserver实现microtask\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eMutationObserver可以用来实现microtask\x3cbr\x3e（它属于microtask，优先级小于Promise，\x3cbr\x3e一般是Promise不支持时才会这样做）\x3c\/p\x3e\n\x3cp\x3e它是HTML5中的新特性，作用是：监听一个DOM变动，\x3cbr\x3e当DOM对象树发生任何变动时，Mutation Observer会得到通知\x3c\/p\x3e\n\x3cp\x3e像以前的Vue源码中就是利用它来模拟nextTick的，\x3cbr\x3e具体原理是，创建一个TextNode并监听内容变化，\x3cbr\x3e然后要nextTick的时候去改一下这个节点的文本内容，\x3cbr\x3e如下：（Vue的源码，未修改）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var counter = 1\nvar observer = new MutationObserver(nextTickHandler)\nvar textNode = document.createTextNode(String(counter))\n\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () =\x3e {\n    counter = (counter \x2b 1) % 2\n    textNode.data = String(counter)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(nextTickHandler)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e textNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter))\n\nobserver.observe(textNode, {\n    \x3cspan class=\x22hljs-attr\x22\x3echaracterData\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n})\ntimerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    counter = (counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    textNode.data = \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/9cfd63a7d08c1eba029c8bd7463b3047c3347826\/src\/core\/util\/env.js#L86-L95\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对应Vue源码链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e不过，现在的Vue（2.5\x2b）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），\x3cbr\x3e取而代之的是使用MessageChannel\x3cbr\x3e（当然，默认情况仍然是Promise，不支持才兼容的）。\x3c\/p\x3e\n\x3cp\x3eMessageChannel属于宏任务，优先级是：\x3ccode\x3eMessageChannel-\x26gt;setTimeout\x3c\/code\x3e，\x3cbr\x3e所以Vue（2.5\x2b）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。\x3c\/p\x3e\n\x3cp\x3e这里不展开，可以看下\x3ca href=\x22https:\/\/juejin.im\/post\/5a1af88f5188254a701ec230\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/juejin.im\/post\/5a1af88f5188254a701ec230\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader22\x22\x3e写在最后的话\x3c\/h2\x3e\n\x3cp\x3e看到这里，不知道对JS的运行机制是不是更加理解了，从头到尾梳理，而不是就某一个碎片化知识应该是会更清晰的吧？\x3c\/p\x3e\n\x3cp\x3e同时，也应该注意到了JS根本就没有想象的那么简单，前端的知识也是无穷无尽，层出不穷的概念、N多易忘的知识点、各式各样的框架、\x3cbr\x3e底层原理方面也是可以无限的往下深挖，然后你就会发现，你知道的太少了。。。\x3c\/p\x3e\n\x3cp\x3e另外，本文也打算先告一段落，其它的，如JS词法解析，可执行上下文以及VO等概念就不继续在本文中写了，后续可以考虑另开新的文章。\x3c\/p\x3e\n\x3cp\x3e最后，喜欢的话，就请给个赞吧！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3e附录\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3e博客\x3c\/h3\x3e\n\x3cp\x3e初次发布\x3ccode\x3e2018.01.21\x3c\/code\x3e于我个人博客上面\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.dailichun.com\/2018\/01\/21\/js_singlethread_eventloop.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.dailichun.com\/2018\/01\/21\/js_singlethread_eventloop.html\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3e参考资料\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.cnblogs.com\/lhb25\/p\/how-browsers-work.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.cnblogs.com\/lhb25\/p\/how-browsers-work.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/p\/1210000012780980\x22\x3ehttps:\/\/segmentfault.com\/p\/1210000012780980\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/u013510838\/article\/details\/55211033\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.csdn.net\/u013510838\/article\/details\/55211033\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/Steward2011\/article\/details\/51319298\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.csdn.net\/Steward2011\/article\/details\/51319298\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.imweb.io\/topic\/58e3bfa845e5c13468f567d5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.imweb.io\/topic\/58e3bfa845e5c13468f567d5\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008015671\x22\x3ehttps:\/\/segmentfault.com\/a\/1190000008015671\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5a4ed917f265da3e317df515\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/juejin.im\/post\/5a4ed917f265da3e317df515\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/iovec\/p\/7904416.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cnblogs.com\/iovec\/p\/7904416.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.cnblogs.com\/wyaocn\/p\/5761163.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.cnblogs.com\/wyaocn\/p\/5761163.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2014\/10\/event-loop.html#comment-text\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ruanyifeng.com\/blog\/2014\/10\/event-loop.html#comment-text\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012925872">https://segmentfault.com/a/1190000012925872</a></p><h2 id="原文标题">原文标题</h2><p>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</p><h2>本文链接：</h2><a href="https://alili.tech/archive/1a007021/" target="_blank">https://alili.tech/archive/1a007021/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>