<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="玩转 React（六）- 处理事件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>玩转 React（六）- 处理事件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/1kx8ys5mfxf/",
				"appid": "1613049289050283", 
				"title": "玩转 React（六）- 处理事件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/gy01jgdooc5/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/42sao9od3ko/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&text=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&text=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&is_video=false&description=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1kx8ys5mfxf%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e5%85%ad%ef%bc%89-%20%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">玩转 React（六）- 处理事件</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e前面的文章介绍了 React 的 JSX 语法、组件的创建方式、组件的属性、组件的内部状态以及组件的生命周期。另外，还顺带说了各个知识点要重点注意的事情，以及我在项目实践中的一些经验。如果你觉得对自己有帮助，可以通过 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000011336838\x22\x3e玩转 React（一）- 前言\x3c\/a\x3e 中的文章目录进行阅读。\x3c\/p\x3e\n\x3cp\x3e另外，为了方便大家更好地交流 React、分享前端开发经验，我建了一个微信群，由于微信群二维码有时间限制，你可以先加我好友（\x3cstrong\x3e我的微信：leobaba88\x3c\/strong\x3e），验证信息 \x3ccode\x3e玩转 React\x3c\/code\x3e，我会拉你入群，欢迎大家，下面是我的微信二维码。\x3c\/p\x3e\n\x3cp\x3e好的，言归正传，今天我们说一下在 React 中是如何处理事件的。事件处理是前端开发过程中非常重要的一部分，通过事件处理机制，我们的前端应用可以响应用户的各种操作，从而实现一个富交互的前端应用。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e内容摘要\x3c\/h1\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如何为 React 的内置组件设置事件处理函数。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReact 事件对象与浏览器原生 DOM 事件对象的区别。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e默认情况下不能以异步的方式使用事件对象，如在 \x3ccode\x3esetTimeout\x3c\/code\x3e 中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要在组件中使用 \x3ccode\x3eaddEventListener\x3c\/code\x3e 注册事件处理函数，有坑。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e绑定事件处理函数 this 指向的四中方式以及他们的优缺点。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3eReact 内置组件的事件处理\x3c\/h1\x3e\n\x3cp\x3e我所说的 React 内置组件是指 React 中已经定义好的，可以直接使用的如 div、button、input 等与原生 HTML 标签对应的组件。\x3c\/p\x3e\n\x3cp\x3e我们先回顾一下浏览器原生 DOM 上注册事件的方式。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第一种方式\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca href=\x26quot;#\x26quot; onclick=\x26quot;console.info(\x27You clicked me.\x27); return false;\x26quot;\x3e\n    Click me.\n\x3c\/a\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22console.info(\x27You clicked me.\x27); return false;\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    Click me.\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是一种古老的方式，在 DOM level 1 规范中的事件注册方式，现在已经很少使用了。\x3c\/p\x3e\n\x3cp\x3e这种方式，用来注册事件的 HTML 属性的值是一个字符串，是一段需要执行的 JavaScript 代码。\x3c\/p\x3e\n\x3cp\x3e可以通过 \x3ccode\x3ereturn false;\x3c\/code\x3e 来阻止当前 HMTL 元素的默认行为，如 a 标签的页面跳转。\x3c\/p\x3e\n\x3cp\x3e关于 DOM 规范的级别可以参考：\x3ca href=\x22https:\/\/developer.mozilla.org\/fr\/docs\/DOM_Levels\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDOM Levels\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第二种方式：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca href=\x26quot;#\x26quot; id=\x26quot;my-link\x26quot;\x3e\n    Click me.\n\x3c\/a\x3e\n\n\x3cscript type=\x26quot;text\/javascript\x26quot;\x3e\n    document.querySelector(\x27#my-link\x27).addEventListener(\x27click\x27, (e) =\x3e {\n        e.preventDefault();\n        console.info(\x26quot;You clicked me.\x26quot;);\n    });\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22my-link\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    Click me.\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27#my-link\x27\x3c\/span\x3e).addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, (e) =\x26gt; {\n        e.preventDefault();\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.info(\x3cspan class=\x22hljs-string\x22\x3e\x22You clicked me.\x22\x3c\/span\x3e);\n    });\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是 DOM level 2 规范中引入的事件注册方式，目前各浏览器也支持的很好，用得是最多的，就是写起来有点啰嗦哈。\x3c\/p\x3e\n\x3cp\x3e在 React 中，事件注册与方式一非常类似，不过有如下几点不同：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e属性名称采用驼峰式（如：onClick，onKeyDown），而不是全小写字母。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e属性值接受一个函数，而不是字符串。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ereturn false;\x3c\/code\x3e 不会阻止组件的默认行为，需要调用 \x3ccode\x3ee.preventDefault();\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log(\x27The link was clicked.\x27);\n  }\n\n  return (\n    \x3ca href=\x26quot;#\x26quot; onClick={handleClick}\x3e\n      Click me\n    \x3c\/a\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eActionLink\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleClick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    e.preventDefault();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27The link was clicked.\x27\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      Click me\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是一个以函数方式定义的组件，组件渲染一个 a 元素，设置l链接的点击事件，通过事件处理函数接收到的事件对象（e），阻止了链接的默认行为，并打印 \x22The link was clicked.\x22 到控制台上。设置 React 内置组件的事件处理函数是不是非常简单。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3eReact 事件对象 VS 原生的 DOM 事件对象\x3c\/h1\x3e\n\x3cp\x3eReact 中的事件对象称之为 \x3ccode\x3eSyntheticEvent\x3c\/code\x3e（合成对象），它是依据 \x3ca href=\x22https:\/\/www.w3.org\/TR\/DOM-Level-3-Events\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDOM Level 3\x3c\/a\x3e 的事件规范实现的，这样做最大的好处是可以屏蔽浏览器的差异，各种厂商的浏览器对规范的实现程度是不一样的，如果直接使用原生 DOM 事件对象的话，有些情况下你需要考虑浏览器的兼容性。而 React 通过 \x3ccode\x3eSyntheticEvent\x3c\/code\x3e 已经把这些琐事帮你搞定了，在任何 React 支持的浏览器下，事件对象都有一致的接口。\x3c\/p\x3e\n\x3cp\x3eReact 中所有的事件处理函数都会接收到一个 \x3ccode\x3eSyntheticEvent\x3c\/code\x3e 的实例 e 作为参数，如果在某些特殊的场景中，你需要用到原生的 DOM 事件对象，可以通过 \x3ccode\x3ee.nativeEvent\x3c\/code\x3e 来获取。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e不要在异步过程中使用 React 事件对象\x3c\/h2\x3e\n\x3cp\x3e需要说明的是，出于性能的考虑，React 并不是为每一个事件处理函数生成一个全新的事件对象，事件对象会被复用，当事件处理函数被执行以后，事件对象的所有属性会被设置为 null，所以\x3cstrong\x3e在事件处理函数中，你不能以异步的方式使用 React 的事件对象\x3c\/strong\x3e，因为那时候事件对象的所有属性都是 null 了，或者已经不是你关心的那个事件了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e尽量不要使用 \x3ccode\x3eaddEventListener\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e这里稍微深入一下，不然我怕有的同学会踩坑。React 内部自己实现了一套高效的事件机制，为了提高框架的性能，React 通过 DOM 事件冒泡，只在 \x3ccode\x3edocument\x3c\/code\x3e 节点上注册原生的 DOM 事件，React 内部自己管理所有组件的事件处理函数，以及事件的冒泡、捕获。\x3c\/p\x3e\n\x3cp\x3e所以说，如果你通过 \x3ccode\x3eaddEventListener\x3c\/code\x3e 注册了某个 DOM 节点的某事件处理函数，并且通过 \x3ccode\x3ee.stopPropagation();\x3c\/code\x3e 阻断了事件的冒泡或者捕获，那么该节点下的所有节点上，同类型的 React 事件处理函数都会失效。\x3c\/p\x3e\n\x3cp\x3e如下示例，虽然设置的链接的点击事件，但是它却执行不了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CounterLink extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    }\n    this.handleClick = this.handleClick.bind(this);\n  }\n  componentDidMount() {\n    document.querySelector(\x27.my-link\x27).addEventListener(\x27click\x27, (e) =\x3e {\n      console.info(\x27raw click\x27);\n      e.stopPropagation();\n    })\n  }\n  handleClick(e) {\n    e.preventDefault();\n    console.info(\x27react click\x27);\n    this.setState({ count: this.state.count \x2b 1 });\n  }\n  render() {\n    return (\n      \x3cdiv className=\x26quot;my-link\x26quot;\x3e\n        \x3ca href=\x26quot;#\x26quot; onClick={this.handleClick}\x3eClicked me {this.state.count} times.\x3c\/a\x3e    \n      \x3c\/div\x3e\n    )\n  }\n}\nReactDOM.render(\x3cCounterLink\/\x3e, document.querySelector(\x26quot;#root\x26quot;));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounterLink\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n  componentDidMount() {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27.my-link\x27\x3c\/span\x3e).addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, (e) =\x26gt; {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.info(\x3cspan class=\x22hljs-string\x22\x3e\x27raw click\x27\x3c\/span\x3e);\n      e.stopPropagation();\n    })\n  }\n  handleClick(e) {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.info(\x3cspan class=\x22hljs-string\x22\x3e\x27react click\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e });\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22my-link\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eClicked me {this.state.count} times.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e    \n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounterLink\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x22#root\x22\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/codepen.io\/Sarike\/pen\/gXrVRv\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/Sarike\/pen...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22Sarike\/pen\/gXrVRv\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e如何绑定事件处理函数的 this\x3c\/h1\x3e\n\x3cp\x3e在以类继承的方式定义的组件中，为了能方便地调用当前组件的其他成员方法或属性（如：this.state），通常需要将事件处理函数运行时的 this 指向当前组件实例。\x3c\/p\x3e\n\x3cp\x3e如下面的示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Link extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    }\n  }\n  handleClick(e) {\n    e.preventDefault();\n    this.setState({ count: this.state.count \x2b 1 })\n  }\n  render() {\n    return \x3ca href=\x26quot;#\x26quot; onClick={this.handleClick}\x3eClicked me {this.state.count} times.\x3c\/a\x3e    \n  }\n\n}\n\nReactDOM.render(\x3cLink\/\x3e, document.querySelector(\x26quot;#root\x26quot;))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      count: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n  }\n  handleClick(e) {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ count: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;a href=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\x3cspan class=\x22hljs-type\x22\x3eClicked\x3c\/span\x3e me {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count} times.\x26lt;\/a\x26gt;    \n  }\n\n}\n\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eLink\x3c\/span\x3e\/\x26gt;, document.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x22#root\x22\x3c\/span\x3e))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当点击链接时，控制台会报错：\x3ccode\x3eUncaught TypeError: Cannot read property \x27setState\x27 of undefined\x3c\/code\x3e，就是因为没有将 \x3ccode\x3ehandleClick\x3c\/code\x3e 运行时的 this 绑定到当前组件。\x3c\/p\x3e\n\x3cp\x3e绑定事件处理函数的 this 到当前组件，有如下几种方式。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第一种方式\x3c\/strong\x3e，通过 bind 方法，原地绑定事件处理函数的 this 指向，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca href=\x26quot;#\x26quot; onClick={this.handleClick.bind(this)}\x3e\n    Clicked me {this.state.count} times.\n\x3c\/a\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e href=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e onClick={this\x3cspan class=\x22hljs-selector-class\x22\x3e.handleClick\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.bind\x3c\/span\x3e(this)}\x26gt;\n    Clicked me {this\x3cspan class=\x22hljs-selector-class\x22\x3e.state\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.count\x3c\/span\x3e} times.\n\x26lt;\/a\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式的优点是书写起来相对简单，但是每次渲染都会执行 bind 方法生成一个新的函数，会有额外的开销，由于事件处理函数是作为属性传递的，所以从而导致子组件进行重新渲染，显然这不是一种好的方式。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第二种方式\x3c\/strong\x3e，通过一个箭头函数将真实的事件处理函数包装一下，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca href=\x26quot;#\x26quot; onClick={e =\x3e this.handleClick(e)}\x3e\n    Clicked me {this.state.count} times.\n\x3c\/a\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-variable\x22\x3e\x26lt;a href=\x22#\x22 onClick={e =\x26gt;\x3c\/span\x3e this.handleClick(e)}\x26gt;\n    Clicked me {this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count} times.\n\x26lt;\/a\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式书写起来也不算麻烦，不过也没有解决第一种方式面临的性能开销和重新渲染的问题。但是这种方式的一个好处是能清晰描述事件处理函数接收的参数列表（这一点可能因人而异，个人观点觉得这是一个优点）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第三种方式\x3c\/strong\x3e，在 constructor 中预先将所有的事件处理函数通过 bind 方法进行绑定。如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Link extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    }\n    \n    \/\/ 重点在这里\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick(e) {\n    e.preventDefault();\n    this.setState({ count: this.state.count \x2b 1 })\n  }\n  render() {\n    return \x3ca href=\x26quot;#\x26quot; onClick={this.handleClick}\x3eClicked me {this.state.count} times.\x3c\/a\x3e    \n  }\n}\n\nReactDOM.render(\x3cLink\/\x3e, document.querySelector(\x26quot;#root\x26quot;))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      count: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重点在这里\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n  handleClick(e) {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ count: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;a href=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\x3cspan class=\x22hljs-type\x22\x3eClicked\x3c\/span\x3e me {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count} times.\x26lt;\/a\x26gt;    \n  }\n}\n\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eLink\x3c\/span\x3e\/\x26gt;, document.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x22#root\x22\x3c\/span\x3e))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式能解决前两种方式面临的额外开销和重新渲染的问题，但是写起来略微有点复杂，因为一个事件处理函数要分别在三个不同的地方进行定义、绑定 this 和使用。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e第四种方式\x3c\/strong\x3e，使用类的成员字段定义语法，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Link extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    }\n  }\n  handleClick = e =\x3e {\n    e.preventDefault();\n    this.setState({ count: this.state.count \x2b 1 })\n  }\n  render() {\n    return \x3ca href=\x26quot;#\x26quot; onClick={this.handleClick}\x3eClicked me {this.state.count} times.\x3c\/a\x3e    \n  }\n}\nReactDOM.render(\x3cLink\/\x3e, document.querySelector(\x26quot;#root\x26quot;))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n  }\n  handleClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eClicked me {this.state.count} times.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e    \n  }\n}\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x22#root\x22\x3c\/span\x3e))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式解决了上面三种方式面临的性能开销、重新渲染以及书写麻烦的问题。唯一的问题就是这种语法目前处于 Stage 3，还未纳入到正式的 ES 规范中。参考：\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-class-fields\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/tc39\/propo...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e不过这也没太大关系。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3e本文的内容并不多，可能说的有点啰嗦。简单总结一下，React 中通过设置组件的 \x3ca href=\x22https:\/\/reactjs.org\/docs\/events.html#supported-events\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e事件属性\x3c\/a\x3e 来注册事件，React 内部自己实现了一套包含冒泡、捕获逻辑在内的事件机制，所以尽量不要使用 \x3ccode\x3eaddEventListener\x3c\/code\x3e，除非你知道自己在干什么。有四种为事件处理函数绑定 this 的方法，推荐使用类属性定义的方式来定义处理函数，如果你不太在意哪一点性能开销的话，可以使用箭头函数包装真实事件回调的方式。另外，事件对象在 React 中是被复用的，事件回调被执行以后，事件对象的所有属性会被重置为 null，所以不要在异步的过程中使用事件对象。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e好了，有什么疑问可以加微信群交流，我的微信号：\x3ccode\x3eleobaba88\x3c\/code\x3e，验证信息：玩转 React。\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>玩转 React（六）- 处理事件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011877137">https://segmentfault.com/a/1190000011877137</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/1kx8ys5mfxf/" target="_blank">https://alili.tech/archive/1kx8ys5mfxf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>