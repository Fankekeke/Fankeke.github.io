<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React系列——React Fiber 架构介绍资料汇总（翻译&#43;中文资料）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React系列——React Fiber 架构介绍资料汇总（翻译&#43;中文资料） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/1mlwtk0325a/",
				"appid": "1613049289050283", 
				"title": "React系列——React Fiber 架构介绍资料汇总（翻译&#43;中文资料） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-17T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/sueja6r8dcf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/y6214jao41j/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&text=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&text=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&is_video=false&description=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1mlwtk0325a%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94React%20Fiber%20%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d%e8%b5%84%e6%96%99%e6%b1%87%e6%80%bb%ef%bc%88%e7%bf%bb%e8%af%91%2b%e4%b8%ad%e6%96%87%e8%b5%84%e6%96%99%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React系列——React Fiber 架构介绍资料汇总（翻译&#43;中文资料）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-17" itemprop="datePublished">2018-12-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e原文\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/acdlite\/react-fiber-architecture\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-fiber-architecture\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e介绍\x3c\/h3\x3e\n\x3cp\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cbr\x3eReact Fibre是React核心算法正在进行的重新实现。它是React团队两年多的研究成果。 \x3cp\x3eReact Fiber的目标是提高其对动画，布局和手势等领域的适用性。它的主体特征是增量渲染：能够将渲染工作分割成块，并将其分散到多个帧中。\x3c\/p\x3e\n\x3cp\x3e其他主要功能包括在进行更新时暂停，中止或重新使用工作的能力;为不同类型的更新分配优先权的能力;和新的并发原语。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e关于这个文档\x3c\/h3\x3e\n\x3cp\x3eFiber引入了几个新颖的概念，很难通过查看代码来完成。这个文档是我们在React项目中随着Fibre实现的一系列笔记开始的。随着它的发展，我意识到它也可能成为其他人的有用资源。\x3c\/p\x3e\n\x3cp\x3e我会尝试尽可能使用最普通的语言，并通过明确定义关键术语来避免行话。在可能的情况下，我也会大量连接外部资源。 \x3c\/p\x3e\n\x3cp\x3e请注意，我不在React团队，也不会从任何权威机构发言。这不是一个正式的文件。我已经要求React团队的成员对其进行检查以确保准确性。 \x3c\/p\x3e\n\x3cp\x3e这也是一个正在进行的工作。Fiber是一个正在进行的项目，在完成之前可能会经历重大的重构。我也试图在这里记录它的设计。改进和建议是非常受欢迎的。 \x3c\/p\x3e\n\x3cp\x3e我的目标是在阅读本文档之后，您将会理解\x3ca href=\x22https:\/\/github.com\/facebook\/react\/commits\/master\/src\/renderers\/shared\/fiber\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFiber的实施情况\x3c\/a\x3e，并最终甚至能够回馈给React。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e先决条件\x3c\/h3\x3e\n\x3cp\x3e我强烈建议您在继续之前熟悉以下资源： \x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hyy1115\/Front-end-course\/blob\/master\/React%E7%B3%BB%E5%88%97\/React%E7%BB%84%E4%BB%B6%E3%80%81%E5%85%83%E7%B4%A0%E5%92%8C%E5%AE%9E%E4%BE%8B.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Components, Elements, and Instances\x3c\/a\x3e - “ Component”通常是一个重载的术语。牢牢掌握这些术语至关重要。 \x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hyy1115\/Front-end-course\/blob\/master\/React%E7%B3%BB%E5%88%97\/React%20Reconciliation%EF%BC%88%E5%92%8C%E8%A7%A3%EF%BC%89.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReconciliation\x3c\/a\x3e - 对React reconciliation算法的高级描述。 \x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hyy1115\/Front-end-course\/blob\/master\/React%E7%B3%BB%E5%88%97\/React%20%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact基本理论概念\x3c\/a\x3e - 对React概念模型的描述。其中一些内容在第一次阅读时可能没有意义。没关系，随着时间的推移会更有意义。 \x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hyy1115\/Front-end-course\/blob\/master\/React%E7%B3%BB%E5%88%97\/React%20%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact设计原则\x3c\/a\x3e - 特别注意scheduling部分。它很好的解释了React Fiber的工作原理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eReview\x3c\/h3\x3e\n\x3cp\x3e如果你还没有看先决条件，请先看完它。\x3c\/p\x3e\n\x3cp\x3e在我们深入研究新的东西之前，让我们回顾一下几个概念。\x3c\/p\x3e\n\x3ch4\x3e什么是reconciliation\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3ereconciliation\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React算法，用来比较2颗树，以确定哪些部分需要改变。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3eReact算法，用来比较\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e颗树，以确定哪些部分需要改变。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e更新\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22用于呈现React应用的数据更改。通常是`setState`的结果。最终导致重新渲染。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e用于呈现React应用的数据更改。通常是`setState`的结果。最终导致重新渲染。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact的API的核心思想认为更新会导致整个应用程序重新渲染。这允许开发人员以声明的方式进行推理，而不用担心如何有效地将应用程序从任何特定状态转换到另一个状态（从A到B，从B到C，从C到A等等）。\x3c\/p\x3e\n\x3cp\x3e实际上，在每次更改时重新渲染整个应用程序只适用于最琐碎的应用程序;在实际的应用程序中，性能方面的代价非常高昂。 React具有优化功能，可在保持良好性能的同时创建整个应用程序需要重新呈现的外观。这些优化的大部分内容是reconciliation的一部分。\x3c\/p\x3e\n\x3cp\x3eReconciliation是被普遍理解为“虚拟DOM”的算法。高级描述如下所示：当您渲染React应用程序时，会生成一个描述应用程序的节点树并保存在内存中。然后将该树刷新到渲染环境 - 例如，在浏览器中，将其转换为一组DOM操作。当应用程序更新（通常通过setState），生成一个新的树。新树与前一棵树有区别，以计算需要更新呈现的应用程序的操作。\x3c\/p\x3e\n\x3cp\x3e尽管Fibre是对reconciler的彻头彻尾的重写，但React文档中描述的高级算法在很大程度上是相同的。关键是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e假定不同的组件类型产生实质上不同的树。React不会试图区分它们，而是完全替换旧的树。\x3c\/li\x3e\n\x3cli\x3e列表的区分使用keys来执行。关键应该是“稳定，可预测，独特”。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eReconciliation与渲染\x3c\/h4\x3e\n\x3cp\x3eDOM只是React可以渲染的渲染环境之一，还可以通过React Native进行本地iOS和Android视图。 （这就是为什么“虚拟DOM”有点用词不当）。\x3c\/p\x3e\n\x3cp\x3e它可以支持如此多目标是因为React的设计使reconciliation和渲染是分开的阶段。reconciler完成了计算树的哪些部分已经改变的工作;渲染器然后使用该信息实际更新呈现的应用程序。\x3c\/p\x3e\n\x3cp\x3e这种分离意味着React DOM和React Native可以使用他们自己的渲染器，同时共享由React核心提供的相同的reconciler。\x3c\/p\x3e\n\x3cp\x3eFiber重新实现了reconciler。虽然渲染者需要改变以支持（并利用）新的架构，但它并不主要关心渲染。\x3c\/p\x3e\n\x3ch4\x3eScheduling\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3escheduling\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22确定何时应该进行工作的过程。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e确定何时应该进行工作的过程。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e工作\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22任何必须执行的计算。工作通常是更新的结果（例如setState）。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs bash\x22\x3e\x3ccode\x3e任何必须执行的计算。工作通常是更新的结果（例如\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState）。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact的\x3ca href=\x22https:\/\/reactjs.org\/docs\/design-principles.html#scheduling\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e设计原则文档\x3c\/a\x3e在这个主题上非常好，我只是在这里引用它：\x3c\/p\x3e\n\x3cblockquote\x3e在当前实现中，React递归地遍历树，并在单个tick中调用整个更新树的render函数。但是，将来可能会延迟一些更新以避免丢帧。\x3cp\x3e这是React设计中的一个常见主题。当新数据可用时，一些流行的库实现了“push”方法，其中计算被执行。然而，React坚持“pull”的方法，计算可以延迟到必要的时候。\x3c\/p\x3e\n\x3cp\x3eReact不是一个通用的数据处理库。这是一个建立用户界面的库。我们认为它是唯一定位在一个应用程序来知道现在哪些计算是相关的，哪些不是。\x3c\/p\x3e\n\x3cp\x3e如果有什么东西在屏幕外，我们可以推迟任何与之相关的逻辑。如果数据比帧速率更快到达，我们可以合并批量更新。我们可以优先考虑来自用户交互的工作（比如点击按钮造成的动画）而不是重要的后台工作（比如刚刚从网络加载的新内容），以避免丢失帧。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e关键是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在用户界面中，没有必要立即应用每个更新。实际上，这样做可能会造成浪费，导致帧丢失并降低用户体验。\x3c\/li\x3e\n\x3cli\x3e不同类型的更新具有不同的优先级 - 动画更新需要比从数据存储更新更快地完成。\x3c\/li\x3e\n\x3cli\x3e基于push的方法要求应用程序（您，程序员）决定如何安排工作。基于pull的方法可以使框架（React）更加智能，并为您做出决定。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e目前，React并没有以重要的方式利用scheduling;整个子树的更新结果立即被重新渲染。检修React的核心算法以利用scheduling是Fiber背后的驱动理念。\x3c\/p\x3e\n\x3cp\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e现在我们已经准备好进入Fiber的实施。接下来的部分比我们迄今为止所讨论的更具技术性。在继续之前，请确保您对前面的内容感到满意。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e什么是fiber？\x3c\/h3\x3e\n\x3cp\x3e我们即将讨论React Fiber架构的核心。Fiber比应用程序开发人员通常所想的要底层抽象得多。如果你对自己的理解感到沮丧，不要感到气馁。继续尝试，最终会有意义的。 （当你最终得到它，请建议如何改善这一部分。） \x3c\/p\x3e\n\x3cp\x3e开始了！\x3c\/p\x3e\n\x3cp\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e我们已经确定，Fiber的主要目标是使React能够利用scheduling。具体来说，我们需要能够\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e暂停工作，稍后再回来。\x3c\/li\x3e\n\x3cli\x3e为不同类型的工作分配优先权。\x3c\/li\x3e\n\x3cli\x3e重复以前完成的工作。\x3c\/li\x3e\n\x3cli\x3e如果不再需要，请中止工作。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了做到这一点，我们首先需要一种把工作分解成单元的方法。从某种意义上说，这就是fiber。fiber代表一个工作单元。\x3c\/p\x3e\n\x3cp\x3e为了更进一步，让我们回到\x3ca href=\x22https:\/\/github.com\/reactjs\/react-basic#transformation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact组件作为数据函数的概念\x3c\/a\x3e，通常表达为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22v = f(d)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ev = f(d)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此渲染一个React应用程序类似于调用其主体包含对其他函数的调用的函数，等等。这个比喻在思考fiber时很有用。\x3c\/p\x3e\n\x3cp\x3e计算机通常跟踪程序执行的方式是使用调用\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Call_stack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e堆栈\x3c\/a\x3e。当一个函数被执行时，一个新的堆栈框架被添加到堆栈中。该堆栈框表示由该函数执行的工作。\x3c\/p\x3e\n\x3cp\x3e在处理UI时，问题是如果一次执行了太多的工作，它可能会导致动画丢帧，看起来不稳定。更重要的是，如果某些工作被更新的更新所取代，那么这些工作可能是不必要的。这是UI组件和函数之间的比较失败的地方，因为组件比一般的函数具有更多特定的问题。\x3c\/p\x3e\n\x3cp\x3e较新的浏览器（和React Native）实现了API来帮助解决这个确切的问题：requestIdleCallback schedules在空闲期间被调用的低优先级函数，requestAnimationFrame schedules在下一个动画帧上被调用的高优先级函数。问题是，为了使用这些API，您需要一种方法来将渲染工作分解为增量单元。如果只依赖调用堆栈，它将继续工作，直到堆栈为空。\x3c\/p\x3e\n\x3cp\x3e如果我们可以自定义调用堆栈的行为来优化呈现UI，这不是很好吗？如果我们可以随意中断调用堆栈并手动操作堆栈帧，这不是很好吗？\x3c\/p\x3e\n\x3cp\x3e这就是React Fiber的目的。Fiber重新实现堆栈，专门用于React组件。您可以将单个fiber视为虚拟堆栈帧。\x3c\/p\x3e\n\x3cp\x3e重新实现堆栈的好处是你可以将堆栈帧保存在内存中，然后执行它们（无论何时）。这对于完成我们安排的目标至关重要。\x3c\/p\x3e\n\x3cp\x3e除了调度scheduling，还有手动处理堆栈帧解锁了诸如并发和错误边界之类的功能的潜力。我们将在以后的章节中介绍这些话题。\x3c\/p\x3e\n\x3cp\x3e在下一节中，我们将更多地关注fiber的结构。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3efiber的结构\x3c\/h3\x3e\n\x3cp\x3e注意：随着我们对实现细节的更具体的了解，事情可能发生变化的可能性会增加。如果您发现任何错误或过时的信息，请提交PR。\x3c\/p\x3e\n\x3cp\x3e具体而言，fiber是一个JavaScript对象，包含有关组件，其输入和输出的信息。\x3c\/p\x3e\n\x3cp\x3efiber对应于堆栈帧，但也对应于组件的一个实例。\x3c\/p\x3e\n\x3cp\x3e这是一些属于fiber的重要领域。 （这个清单并不详尽。）\x3c\/p\x3e\n\x3ch4\x3etype and key\x3c\/h4\x3e\n\x3cp\x3efiber的type和key与React元素的作用相同。 （实际上，当从一个元素创建一个fiber时，这两个字段直接被复制过来。）\x3c\/p\x3e\n\x3cp\x3efiber的type描述了它对应的组件。对于复合组件，类型是函数或类组件本身。对于host组件（div，span等），类型是一个字符串。\x3c\/p\x3e\n\x3cp\x3e从概念上讲，type是函数（如在v = f（d）中），其执行被栈帧跟踪。 \x3c\/p\x3e\n\x3cp\x3e随着type的不同，在reconciliation期间使用key来确定fiber是否可以重新使用。\x3c\/p\x3e\n\x3ch4\x3echild and sibling\x3c\/h4\x3e\n\x3cp\x3e这些字段指向其他fiber，描述fiber的递归树状结构。 \x3c\/p\x3e\n\x3cp\x3e子fiber对应于组件渲染方法返回的值。所以在下面的例子中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent() {\n  return \x3cChild \/\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChild\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eParent的child fiber对应于Child。 \x3c\/p\x3e\n\x3cp\x3e兄弟领域说明了渲染返回多个children的情况（Fiber中的一个新特性）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent() {\n  return [\x3cChild1 \/\x3e, \x3cChild2 \/\x3e]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChild1\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChild2\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e]\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3echild的fiber形成一个单一的链表，head是第一个child。所以在这个例子中，Parent的child是Child1，而Child1的兄弟是Child2。 \x3c\/p\x3e\n\x3cp\x3e回到我们的功能比喻，你可以把一个子fiber想象成一个\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Tail_call\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e尾调用函数\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch4\x3ereturn\x3c\/h4\x3e\n\x3cp\x3ereturn fiber是程序在处理完当前fiber后返回的fiber。它在概念上与堆栈帧的返回地址相同。它也可以被认为是parent fiber。 \x3c\/p\x3e\n\x3cp\x3e如果fiber具有多个子fiber，则每个子fiber的return fiber是parent。所以在前面的例子中，Child1和Child2的return fiber是Parent。\x3c\/p\x3e\n\x3ch4\x3ependingProps 和 memoizedProps\x3c\/h4\x3e\n\x3cp\x3e从概念上讲，props是一个函数的arguments。一个fiber的pendingProps在执行开始时被设置，memoizedProps被设置在最后。 \x3c\/p\x3e\n\x3cp\x3e当传入的pendingProps等于memoizedProps时，它表明fiber的先前输出可以被重复使用，避免不必要的工作。\x3c\/p\x3e\n\x3ch4\x3ependingWorkPriority\x3c\/h4\x3e\n\x3cp\x3e一个数字，表示fiber所代表的工作的优先级。 ReactPriorityLevel模块列出了不同的优先级以及它们代表的内容。 \x3c\/p\x3e\n\x3cp\x3e除NoWork为0外，较大的数字表示较低的优先级。例如，您可以使用以下函数来检查fiber的优先级是否至少与给定级别一样高：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function matchesPriority(fiber, priority) {\n  return fiber.pendingWorkPriority !== 0 \x26amp;\x26amp;\n         fiber.pendingWorkPriority \x3c= priority\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ematchesPriority\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiber, priority\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fiber.pendingWorkPriority !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp;\n         fiber.pendingWorkPriority \x26lt;= priority\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此函数仅用于说明;它实际上并不是React Fiber代码库的一部分。\x3c\/p\x3e\n\x3cp\x3escheduler使用优先级字段来搜索要执行的下一个工作单元。这个算法将在以后的章节中讨论。\x3c\/p\x3e\n\x3ch4\x3e备用\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3eflush\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22flush fiber是将其输出呈现在屏幕上。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eflush\x3c\/span\x3e fiber是将其输出呈现在屏幕上。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3ework-in-progress\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22尚未完成的fiber;从概念上说，一个尚未返回的堆栈帧。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e尚未完成的fiber\x3cspan class=\x22hljs-comment\x22\x3e;从概念上说，一个尚未返回的堆栈帧。\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在任何时候，一个组件实例最多只有两条fiber对应：当前的，flushed fiber和work-in-progress fiber。 \x3c\/p\x3e\n\x3cp\x3e当前fiber的交替是work-in-progress，work-in-progress的交替是当前的fiber。\x3c\/p\x3e\n\x3cp\x3e使用名为cloneFiber的函数，可以创建一个fiber的替代品。 cloneFiber不会总是创建一个新的对象，而是尝试重用fiber的备用，如果它存在，最小化分配。 \x3c\/p\x3e\n\x3cp\x3e您应该将备用字段视为实现细节，但是它在代码库中经常出现，因此在此讨论它非常有用。\x3c\/p\x3e\n\x3ch4\x3e输出\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3ehost component\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React应用程序的叶子节点。它们特定于渲染环境（例如，在浏览器应用程序中，它们是“div”，“span”等）。在JSX中，它们使用小写的标记名称来表示。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3eReact应用程序的叶子节点。它们特定于渲染环境（例如，在浏览器应用程序中，它们是“\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e”，“span”等）。在JSX中，它们使用小写的标记名称来表示。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从概念上讲，fiber的输出是一个函数的返回值。\x3c\/p\x3e\n\x3cp\x3e每个fiber最终都有输出，但输出仅由host组件在叶子节点创建。然后将输出传送到树上。\x3c\/p\x3e\n\x3cp\x3e输出是最终呈现给渲染器，以便它可以刷新渲染环境的变化。渲染者有责任定义输出是如何创建和更新的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e未来部分\x3c\/h3\x3e\n\x3cp\x3e现在就是这样，但是这个文件还远远没有完成。以后的部分将介绍在整个生命周期中使用的算法。要涵盖的主题包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3escheduler如何找到要执行的下一个工作单元。\x3c\/li\x3e\n\x3cli\x3e如何通过fiber树跟踪和传播优先级。\x3c\/li\x3e\n\x3cli\x3escheduler如何知道何时暂停和恢复工作。\x3c\/li\x3e\n\x3cli\x3e工作如何被刷新并标记为完整。\x3c\/li\x3e\n\x3cli\x3e副作用（如生命周期方法）如何工作。\x3c\/li\x3e\n\x3cli\x3e协程是什么以及如何用它来实现上下文和布局等功能。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e相关视频\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/youtu.be\/aV1271hd9ew\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWhat\x27s Next for React (ReactNext 2016)\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e相关资料\x3c\/h3\x3e\n\x3cp\x3e1、\x3ca href=\x22http:\/\/www.ayqy.net\/blog\/dive-into-react-fiber\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完全理解React Fiber\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e2、\x3ca href=\x22http:\/\/zxc0328.github.io\/2017\/09\/28\/react-16-source\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 16 Fiber源码速览\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e3、\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/26027085\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Fiber是什么\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e4、\x3ca href=\x22https:\/\/www.zhihu.com\/question\/49496872\/answer\/116346458\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e如何理解 React Fiber 架构？\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e5、\x3ca href=\x22https:\/\/bogdan-lyashenko.github.io\/Under-the-hood-ReactJS\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnder-the-hood-ReactJS\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3etree相关论文\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/grfia.dlsi.ua.es\/ml\/algorithms\/references\/editsurvey_bille.pdf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eA Survey on Tree Edit Distance and Related Problems\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React系列——React Fiber 架构介绍资料汇总（翻译+中文资料）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012834204">https://segmentfault.com/a/1190000012834204</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/1mlwtk0325a/" target="_blank">https://alili.tech/archive/1mlwtk0325a/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>