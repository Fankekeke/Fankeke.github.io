<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue.js 服务端渲染业务入门实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue.js 服务端渲染业务入门实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/259hmwxpz1o/",
				"appid": "1613049289050283", 
				"title": "Vue.js 服务端渲染业务入门实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/cl0fczjmjrv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/5auw9v3zf7t/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&text=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&text=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&title=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&is_video=false&description=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&title=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&title=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&title=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f259hmwxpz1o%2f&title=Vue.js%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%e4%b8%9a%e5%8a%a1%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue.js 服务端渲染业务入门实践</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e作者：威威（沪江前端开发工程师）\x3cbr\x3e本文原创，转载请注明作者及出处。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e背景\x3c\/h1\x3e\n\x3cp\x3e最近， 产品同学一如往常笑嘻嘻的递来需求文档， 纵使内心万般拒绝， 身体倒是很诚实。 接过需求，好在需求不复杂， 简单构思 后决定用Vue， 得心应手。 切好图， 挽起袖子准备撸代码的时候， SEO同学不知何时已经站到了背后。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;听说你要用Vue?\x26quot;\n\x26quot;恩...\x26quot;\n\x26quot;SEO考虑了吗?整个SPA出来，网页的SEO咋办?\x26quot;\n\x26quot;奥...\x26quot;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22听说你要用Vue?\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x22恩...\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x22SEO考虑了吗?整个SPA出来，网页的SEO咋办?\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x22奥...\x22\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e换以前， 估计只能无奈的换个实现方式， 但是Vue 2.0时代的到来， 给你多了一种可能。 你可以对SEO工程师说:用Vue没问题!\x3c\/p\x3e\n\x3cp\x3e想必，很多前端同学都有类似这样的经历， 为了SEO，只能放弃得心应手的框架。 SEO(Search Engine Optimization)顾名思义就是一系列为了提高 网站收录排名，吸引精准用户的方案。 这么看来，SEO确实是有举足轻重的作用。 不过，好消息是，Vue2.0的发布为SEO提供了可能， 这就是SSR(serve side render)。\x3c\/p\x3e\n\x3cp\x3e说起SSR，其实早在SPA (Single Page Application) 出现之前，网页就是在服务端渲染的。服务器接收到客户端请求后，将数据和模板拼接成完整的页面响应到客户端。 客户端直接渲染， 此时用户希望浏览新的页面，就必须重复这个过程， 刷新页面. 这种体验在Web技术发展的当下是几乎不能被接受的，于是越来越多的技术方案涌现，力求 实现无页面刷新或者局部刷新来达到优秀的交互体验。 比如Vue:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- 在客户端管理路由，用户切换路由，无需向服务器重新请求页面和静态资源，只需要使用 ajax 获取数据在客户端完成渲染，这样可以减少了很多不必要的网络传输，缩短了响应时间。\n- 声明式渲染(告诉 vue 你要做什么，让它帮你做)，把我们从烦人的DOM操作中解放出来，集中处理业务逻辑。\n- 组件化视图，无论是功能组件还是UI组件都可以进行抽象，写一次到处用。\n- 前后端并行开发，只需要与后端定好数据格式，前期用模拟数据，就可以与后端并行开发了。\n- 对复杂项目的各个组件之间的数据传递 vue  - Vuex 状态管理模式\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e 在客户端管理路由，用户切换路由，无需向服务器重新请求页面和静态资源，只需要使用 ajax 获取数据在客户端完成渲染，这样可以减少了很多不必要的网络传输，缩短了响应时间。\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e 声明式渲染(告诉 vue 你要做什么，让它帮你做)，把我们从烦人的DOM操作中解放出来，集中处理业务逻辑。\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e 组件化视图，无论是功能组件还是UI组件都可以进行抽象，写一次到处用。\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e 前后端并行开发，只需要与后端定好数据格式，前期用模拟数据，就可以与后端并行开发了。\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e 对复杂项目的各个组件之间的数据传递 vue  - Vuex 状态管理模式\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e缺点大家自然猜到了， 对，主要的一点就是不利于SEO，或者说对SEO不友好。 来看下面两张图；\x3c\/p\x3e\n\x3cp\x3eSPA页面的源代码\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVUt6n?w=640\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/bVUt6n?w=640\x26amp;h=328\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e下图SSR页面的源代码\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVUt6o?w=640\x26amp;h=348\x22 src=\x22https:\/\/static.alili.tech\/img\/bVUt6o?w=640\x26amp;h=348\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面两张图就是使用了传统单页应用和SSR的页面源代码， 第一张图中，很明显页面的数据都是通过Ajax异步获取，然而搜索引擎度娘家的爬虫看到这样空旷的源码并不会丝毫留恋. 相反，通过服务端渲染的页面，就有很多对于爬虫来讲有效的连接. 毕竟度娘一家独大，看来服务端渲染确实有探究的必要了。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3eVue.js 的服务端渲染是怎么回事?\x3c\/h1\x3e\n\x3cp\x3e先看一张Vue官网的服务端渲染示意图\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVUt6z?w=640\x26amp;h=293\x22 src=\x22https:\/\/static.alili.tech\/img\/bVUt6z?w=640\x26amp;h=293\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从图上可以看出，ssr 有两个入口文件，client.js 和 server.js， 都包含了应用代码，webpack 通过两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 当服务器接收到了来自客户端的请求之后，会创建一个渲染器 bundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件，并且执行它的代码， 然后发送一个生成好的 html 到浏览器，等到客户端加载了 client bundle 之后，会和服务端生成的DOM 进行 Hydration(判断这个DOM 和自己即将生成的DOM 是否相同，如果相同就将客户端的vue实例挂载到这个DOM上， 否则会提示警告)。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e怎么实现?\x3c\/h1\x3e\n\x3cp\x3e知道了Vue服务端渲染的大致流程，那怎么用代码来实现呢?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 创建一个 vue 实例\n2. 配置路由，以及相应的视图组件\n3. 使用 vuex 管理数据\n4. 创建服务端入口文件\n5. 创建客户端入口文件\n6. 配置 webpack，分服务端打包配置和客户端打包配置\n7. 创建服务器端的渲染器，将vue实例渲染成html\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e创建一个 vue 实例\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e配置路由，以及相应的视图组件\n\x3cspan class=\x22hljs-bullet\x22\x3e3. \x3c\/span\x3e使用 vuex 管理数据\n\x3cspan class=\x22hljs-bullet\x22\x3e4. \x3c\/span\x3e创建服务端入口文件\n\x3cspan class=\x22hljs-bullet\x22\x3e5. \x3c\/span\x3e创建客户端入口文件\n\x3cspan class=\x22hljs-bullet\x22\x3e6. \x3c\/span\x3e配置 webpack，分服务端打包配置和客户端打包配置\n\x3cspan class=\x22hljs-bullet\x22\x3e7. \x3c\/span\x3e创建服务器端的渲染器，将vue实例渲染成html\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e首先我们来创建一个 vue 实例\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ app.js\n\n    import Vue from \x27vue\x27;\n    import router from \x27.\/router\x27;\n    import store from \x27.\/store\x27;\n    import App from \x27.\/components\/app\x27;   \n\n    let app = new Vue({\n        template: \x27\x3capp\x3e\x3c\/app\x3e\x27，\n        base: \x27\/c\/\x27，\n        components: {\n            App\n        }，\n        router，\n        store\n    });\n\n    export {\n        app，\n        router，\n        store\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ app.js\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e router \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/router\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e store \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/components\/app\x27\x3c\/span\x3e;   \n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n        \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;app\x26gt;\x26lt;\/app\x26gt;\x27\x3c\/span\x3e，\n        base: \x3cspan class=\x22hljs-string\x22\x3e\x27\/c\/\x27\x3c\/span\x3e，\n        components: {\n            App\n        }，\n        router，\n        store\n    });\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e {\n        app，\n        router，\n        store\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和我们以前写的vue实例差别不大，但是我们不会在这里将app mount到DOM上，因为这个实例也会在服务端去运行，这里直接将 app 暴露出去。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e配置 vue 路由\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n  import Vue from \x27vue\x27;\n  import VueRouter from \x27vue-router\x27;\n\n  import IndexView from \x27..\/views\/indexView\x27;\n  import ArticleItems from \x27..\/views\/articleItems\x27;\n\n  Vue.use(VueRouter);\n\n  const router = new VueRouter({\n      mode: \x27history\x27，\n      base: \x27\/c\/\x27，\n      routes: [\n          {\n              path: \x27\/:alias\x27，\n              component: IndexView\n          }， {\n              path: \x27\/:alias\/list\x27，\n              component: ArticleItems\n          }\n      ]\n  });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e VueRouter \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue-router\x27\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e IndexView \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/views\/indexView\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ArticleItems \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/views\/articleItems\x27\x3c\/span\x3e;\n\n  Vue.use(VueRouter);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e router = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e VueRouter({\n      \x3cspan class=\x22hljs-attr\x22\x3emode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e，\n      base: \x3cspan class=\x22hljs-string\x22\x3e\x27\/c\/\x27\x3c\/span\x3e，\n      routes: [\n          {\n              \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/:alias\x27\x3c\/span\x3e，\n              component: IndexView\n          }， {\n              \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/:alias\/list\x27\x3c\/span\x3e，\n              component: ArticleItems\n          }\n      ]\n  });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意这里的 base，在服务端传递 path 给 vue-router 的时候要注意去掉前面的 \x27\/c\/\x27，否则会匹配不到。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e创建视图组件，这里我们使用单文件组件，下面是 indexView.vue 文件的实例代码\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ctemplate\x3e\n      \x3cdiv class=\x26quot;content\x26quot;\x3e\n          \x3ccourse-cover :class-data=\x26quot;classData[0]\x26quot;\x3e\x3c\/course-cover\x3e\n          \x3carticle-items :article-items=\x26quot;articleItems\x26quot;\x3e\x3c\/article-items\x3e\n      \x3c\/div\x3e\n  \x3c\/template\x3e\n\n  \x3cscript\x3e\n      import courseCover from \x27..\/components\/courseCover.vue\x27;\n      import articleItems from \x27..\/components\/articleItems\x27;\n\n      export default {\n          computed: {\n              classData() {\n                  return this.$store.state.courseListItems;\n              }，\n              articleItems() {\n                  return this.$store.state.articleItems;\n              }\n          }，\n          components: {\n              courseCover，\n              articleItems\n          }，\n          \/\/ 服务端获取数据\n          fetchServerData ({ state， dispatch， commit }) {\n              let alias = state.route.params.alias;\n\n              return Promise.all([\n                  dispatch(\x27FETCH_ZT\x27， { alias })，\n                  dispatch(\x27FETCH_COURSE_ITEMS\x27)，\n                  dispatch(\x27FETCH_ARTICLE_ITEMS\x27)\n              ])\n          }，\n          \/\/ 客户端获取数据\n          beforeMount() {\n              return this.$store.dispatch(\x27FETCH_COURSE_ITEMS\x27);\n          }\n      }\n  \x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;template\x26gt;\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22content\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecourse-cover\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3e:class-data\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22classData[0]\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecourse-cover\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3earticle-items\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3e:article-items\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22articleItems\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3earticle-items\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e courseCover \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/components\/courseCover.vue\x27\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e articleItems \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/components\/articleItems\x27\x3c\/span\x3e;\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-attr\x22\x3ecomputed\x3c\/span\x3e: {\n              classData() {\n                  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.state.courseListItems;\n              }，\n              articleItems() {\n                  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.state.articleItems;\n              }\n          }，\n          components: {\n              courseCover，\n              articleItems\n          }，\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 服务端获取数据\x3c\/span\x3e\n          fetchServerData ({ state， dispatch， commit }) {\n              \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e alias = state.route.params.alias;\n\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([\n                  dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27FETCH_ZT\x27\x3c\/span\x3e， { alias })，\n                  dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27FETCH_COURSE_ITEMS\x27\x3c\/span\x3e)，\n                  dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27FETCH_ARTICLE_ITEMS\x27\x3c\/span\x3e)\n              ])\n          }，\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 客户端获取数据\x3c\/span\x3e\n          beforeMount() {\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27FETCH_COURSE_ITEMS\x27\x3c\/span\x3e);\n          }\n      }\n  \x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们暴露一个 fetchServerData 方法用来在服务端渲染时做数据的预加载，具体在哪调用，下面会讲到。 beforeMount 是vue的生命周期钩子函数，当应用在客户端切换到这个视图的时候会在特定的时候去执行，用于在客户端获取数据。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e使用 vuex 管理数据，vue2.0 的服务端官方推荐使用 STORE 来管理数据，和1.0相比 api 有一些调整\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  import Vue from \x27vue\x27;\n  import Vuex from \x27vuex\x27;\n  import axios from \x27axios\x27;\n\n  Vue.use(Vuex);\n\n  let apiHost = \x27http:\/\/localhost:3000\x27;\n\n  const store = new Vuex.Store({\n      state: {\n          alias: \x27\x27，\n          ztData: {}，\n          courseListItems: []，\n          articleItems: []\n      }，\n      actions: {\n          FETCH_ZT: ({ commit， dispatch， state }， { alias }) = {\n              commit(\x27SET_ALIAS\x27， { alias });\n              return axios.get(`${apiHost}\/api\/zt`)\n                          .then(response =\x3e {\n                              let data = response.data || {};\n                              commit(\x27SET_ZT_DATA\x27， data);\n                          })\n          }，\n          FETCH_COURSE_ITEMS: ({ commit， dispatch， state }) =\x3e {\n              return axios.get(`${apiHost}\/api\/course_items`).then(response =\x3e {\n                  let data = response.data;\n                  commit(\x27SET_COURSE_ITEMS\x27， data);\n              });\n          }，\n          FETCH_ARTICLE_ITEMS: ({ commit， dispatch， state }) =\x3e {\n              return axios.get(`${apiHost}\/api\/article_items`)\n                          .then(response =\x3e {\n                              let data = response.data;\n                              commit(\x27SET_ARTICLE_ITEMS\x27， data);\n                          })\n          }\n      }，\n      mutations: {\n          SET_COURSE_ITEMS: (state， data) =\x3e {\n              state.courseListItems = data;\n          }，\n          SET_ALIAS: (state， { alias }) =\x3e {\n              state.alias = alias;\n          }，\n          SET_ZT_DATA: (state， { ztData }) =\x3e {\n              state.ztData = ztData;\n          }，\n          SET_ARTICLE_ITEMS: (state， items) =\x3e {\n              state.articleItems = items;\n          }\n      }\n  })\n\n  export default store;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vuex \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e axios \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27axios\x27\x3c\/span\x3e;\n\n  Vue.use(Vuex);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e apiHost = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:3000\x27\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vuex.Store({\n      \x3cspan class=\x22hljs-attr\x22\x3estate\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-attr\x22\x3ealias\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e，\n          ztData: {}，\n          courseListItems: []，\n          articleItems: []\n      }，\n      actions: {\n          \x3cspan class=\x22hljs-attr\x22\x3eFETCH_ZT\x3c\/span\x3e: ({ commit， dispatch， state }， { alias }) = {\n              commit(\x3cspan class=\x22hljs-string\x22\x3e\x27SET_ALIAS\x27\x3c\/span\x3e， { alias });\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e axios.get(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${apiHost}\x3c\/span\x3e\/api\/zt`\x3c\/span\x3e)\n                          .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                              \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = response.data || {};\n                              commit(\x3cspan class=\x22hljs-string\x22\x3e\x27SET_ZT_DATA\x27\x3c\/span\x3e， data);\n                          })\n          }，\n          FETCH_COURSE_ITEMS: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ commit， dispatch， state }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e axios.get(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${apiHost}\x3c\/span\x3e\/api\/course_items`\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = response.data;\n                  commit(\x3cspan class=\x22hljs-string\x22\x3e\x27SET_COURSE_ITEMS\x27\x3c\/span\x3e， data);\n              });\n          }，\n          FETCH_ARTICLE_ITEMS: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ commit， dispatch， state }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e axios.get(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${apiHost}\x3c\/span\x3e\/api\/article_items`\x3c\/span\x3e)\n                          .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                              \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = response.data;\n                              commit(\x3cspan class=\x22hljs-string\x22\x3e\x27SET_ARTICLE_ITEMS\x27\x3c\/span\x3e， data);\n                          })\n          }\n      }，\n      mutations: {\n          \x3cspan class=\x22hljs-attr\x22\x3eSET_COURSE_ITEMS\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate， data\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              state.courseListItems = data;\n          }，\n          SET_ALIAS: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate， { alias }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              state.alias = alias;\n          }，\n          SET_ZT_DATA: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate， { ztData }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              state.ztData = ztData;\n          }，\n          SET_ARTICLE_ITEMS: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate， items\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n              state.articleItems = items;\n          }\n      }\n  })\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e store;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3estate 使我们应用层的数据，相当于一个仓库，整个应用层的数据都存在这里，与不使用vuex的vue应用有两点不同：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22-  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n-  Vuex 不允许我们直接对 store 中的数据进行操作。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\naction 响应在view上的用户输入导致的状态变化，并不直接操作数据，异步的逻辑都封装在这里执行，它最终的目的是提交 mutation 来操作数据。 mutation vuex 中修改store 数据的唯一方法，使用 commit 来提交。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs llvm\x22\x3e\x3ccode\x3e-  Vuex 的状态存储是响应式的。当 Vue 组件从 \x3cspan class=\x22hljs-keyword\x22\x3estore\x3c\/span\x3e 中读取状态的时候，若 \x3cspan class=\x22hljs-keyword\x22\x3estore\x3c\/span\x3e 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n-  Vuex 不允许我们直接对 \x3cspan class=\x22hljs-keyword\x22\x3estore\x3c\/span\x3e 中的数据进行操作。改变 \x3cspan class=\x22hljs-keyword\x22\x3estore\x3c\/span\x3e 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\naction 响应在view上的用户输入导致的状态变化，并不直接操作数据，异步的逻辑都封装在这里执行，它最终的目的是提交 mutation 来操作数据。 mutation vuex 中修改\x3cspan class=\x22hljs-keyword\x22\x3estore\x3c\/span\x3e 数据的唯一方法，使用 commit 来提交。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e创建服务端的入口文件 server-entry.js\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ server-entry.js\n    import {app， router， store} from \x27.\/app\x27;\n\n    export default context =\x3e {\n\n        const s = Date.now();\n        router.push(context.url);\n        const matchedComponents = router.getMatchedComponents();\n        if(!matchedComponents) {\n            return Promise.reject({ code: \x27404\x27 });\n        }\n\n        return Promise.all(\n            matchedComponents.map(component =\x3e {\n                if(component.fetchServerData) {\n                    return component.fetchServerData(store);\n                }\n            })\n        ).then(() =\x3e {\n            context.initialState = store.state;\n            return app;\n        })\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ server-entry.js\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {app， router， store} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e context =\x26gt; {\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n        router.push(context.url);\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e matchedComponents = router.getMatchedComponents();\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!matchedComponents) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject({ \x3cspan class=\x22hljs-attr\x22\x3ecode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27404\x27\x3c\/span\x3e });\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(\n            matchedComponents.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecomponent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(component.fetchServerData) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e component.fetchServerData(store);\n                }\n            })\n        ).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            context.initialState = store.state;\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e app;\n        })\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eserver.js 返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 promise 返回。 context 一般包含 当前页面的url，首先我们调用 vue-router 的 router.push(url) 切换到到对应的路由， 然后调用 getMatchedComponents 方法返回对应要渲染的组件， 这里会检查组件是否有 fetchServerData 方法，如果有就会执行它。\x3c\/p\x3e\n\x3cp\x3e下面这行代码将服务端获取到的数据挂载到 context 对象上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22context.initialState = store.state\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3econtext.initialState = store.state\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建客户端入口文件 client-entry.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ client-entry.js\n    import { app， store } from \x27.\/app\x27;\n    import \x27.\/main.scss\x27;\n    store.replaceState(window.__INITIAL_STATE__);\n    app.$mount(\x27#app\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ client-entry.js\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { app， store } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/main.scss\x27\x3c\/span\x3e;\n    store.replaceState(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__INITIAL_STATE__);\n    app.$mount(\x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e客户端入口文件很简单，同步服务端发送过来的数据，然后把 vue 实例挂载到服务端渲染的 DOM 上。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e配置 webpack\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ webpack.server.config.js\n    const base = require(\x27.\/webpack.base.config\x27); \/\/ webpack 的通用配置\n    module.exports = Object.assign({}， base， {\n        target: \x27node\x27，\n        entry: \x27.\/src\/server-entry.js\x27，\n        output: {\n            filename: \x27server-bundle.js\x27，\n            libraryTarget: \x27commonjs2\x27\n        }，\n        externals: Object.keys(require(\x27..\/package.json\x27).dependencies)，\n        plugins: [\n            new webpack.DefinePlugin({\n            \x27process.env.NODE_ENV\x27: JSON.stringify(process.env.NODE_ENV || \x27development\x27)，\n            \x27process.env.VUE_ENV\x27: \x27\x26quot;server\x26quot;\x27\n            })\n        ]\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack.server.config.js\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e base = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.base.config\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack 的通用配置\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}， base， {\n        \x3cspan class=\x22hljs-attr\x22\x3etarget\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27node\x27\x3c\/span\x3e，\n        entry: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/server-entry.js\x27\x3c\/span\x3e，\n        output: {\n            \x3cspan class=\x22hljs-attr\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27server-bundle.js\x27\x3c\/span\x3e，\n            libraryTarget: \x3cspan class=\x22hljs-string\x22\x3e\x27commonjs2\x27\x3c\/span\x3e\n        }，\n        externals: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/package.json\x27\x3c\/span\x3e).dependencies)，\n        plugins: [\n            \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.DefinePlugin({\n            \x3cspan class=\x22hljs-string\x22\x3e\x27process.env.NODE_ENV\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(process.env.NODE_ENV || \x3cspan class=\x22hljs-string\x22\x3e\x27development\x27\x3c\/span\x3e)，\n            \x3cspan class=\x22hljs-string\x22\x3e\x27process.env.VUE_ENV\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x22server\x22\x27\x3c\/span\x3e\n            })\n        ]\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意这里添加了 target: \x27node\x27 和 libraryTarget: \x27commonjs2\x27，然后入口文件改成我们的 server-entry.js， 客户端的 webpack 和以前一样，这里就不贴了。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e分别打包服务端代码和客户端代码\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e因为有两个 webpack 配置文件，执行 webpack 时候就需要指定 --config 参数来编译不同的 bundle。 我们可以配置两个 npm script\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \x26quot;packclient\x26quot;: \x26quot;webpack --config webpack.client.config.js\x26quot;,\n    \x26quot;packserver\x26quot;: \x26quot;webpack --config webpack.server.config.js\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e    \x22\x3cspan class=\x22hljs-selector-tag\x22\x3epackclient\x3c\/span\x3e\x22: \x22\x3cspan class=\x22hljs-selector-tag\x22\x3ewebpack\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3e--config\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ewebpack\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.client\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.config\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\x22,\n    \x22\x3cspan class=\x22hljs-selector-tag\x22\x3epackserver\x3c\/span\x3e\x22: \x22\x3cspan class=\x22hljs-selector-tag\x22\x3ewebpack\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3e--config\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ewebpack\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.server\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.config\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\x22\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在命令行运行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    npm run packclient\n    npm run packserver\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dockerfile\x22\x3e\x3ccode\x3e    npm \x3cspan class=\x22hljs-keyword\x22\x3erun\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e packclient\n\x3c\/span\x3e    npm \x3cspan class=\x22hljs-keyword\x22\x3erun\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e packserver\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就会生成两个文件 client-bundle.js 和 server-bundle.js\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e创建服务端渲染器\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ controller.js\n\n  const serialize = require(\x27serialize-javascript\x27);\n  \/\/ 因为我们在vue-router 的配置里面使用了 `base: \x27\/c\x27`，这里需要去掉请求path中的 \x27\/c\x27\n  let url = this.url.replace(\/\\\/c\/, \x27\x27);\n  let context = { url: this.url };\n  \/\/ 创建渲染器\n  let bundleRenderer = createRenderer(fs.readFileSync(resolve(\x27.\/dist\/server-bundle.js\x27)， \x27utf-8\x27))\n  let html = yield new Promise((resolve， reject) =\x3e {\n      \/\/ 将vue实例编译成一个字符串\n      bundleRenderer.renderToString(\n          context，   \/\/ 传递context 给 server-bundle.js 使用\n          (err， html) =\x3e {\n              if(err) {\n                  console.error(\x27server render error\x27， err);\n                  resolve(\x27\x27);\n              }\n              \/**\n               * 还记得在 server-entry.js 里面 `context.initialState = store.state` 这行代码么？\n               * 这里就直接把数据发送到浏览器端啦\n              **\/\n              html \x2b= `\x3cscript\x3e\n                          \/\/ 将服务器获取到的数据作为首屏数据发送到浏览器\n                          window.__INITIAL_STATE__ = ${serialize(context.initialState， { isJSON: true })}\n                      \x3c\/script\x3e`;\n              resolve(html);\n          }\n      )\n  })\n\n  yield this.render(\x27ssr\x27， html);\n\n  \/\/ 创建渲染器函数\n  function createRenderer(code) {\n      return require(\x27vue-server-renderer\x27).createBundleRenderer(code);\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ controller.js\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e serialize = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27serialize-javascript\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为我们在vue-router 的配置里面使用了 `base: \x27\/c\x27`，这里需要去掉请求path中的 \x27\/c\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e url = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.url.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/\\\/c\/\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e context = { \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.url };\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建渲染器\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e bundleRenderer = createRenderer(fs.readFileSync(resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/dist\/server-bundle.js\x27\x3c\/span\x3e)， \x3cspan class=\x22hljs-string\x22\x3e\x27utf-8\x27\x3c\/span\x3e))\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e html = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve， reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将vue实例编译成一个字符串\x3c\/span\x3e\n      bundleRenderer.renderToString(\n          context，   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传递context 给 server-bundle.js 使用\x3c\/span\x3e\n          (err， html) =\x26gt; {\n              \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err) {\n                  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27server render error\x27\x3c\/span\x3e， err);\n                  resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n              }\n              \x3cspan class=\x22hljs-comment\x22\x3e\/**\n               * 还记得在 server-entry.js 里面 `context.initialState = store.state` 这行代码么？\n               * 这里就直接把数据发送到浏览器端啦\n              **\/\x3c\/span\x3e\n              html \x2b= \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;script\x26gt;\n                          \/\/ 将服务器获取到的数据作为首屏数据发送到浏览器\n                          window.__INITIAL_STATE__ = \x3cspan class=\x22hljs-subst\x22\x3e${serialize(context.initialState， { isJSON: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }\x3c\/span\x3e)}\n                      \x26lt;\/script\x26gt;`\x3c\/span\x3e;\n              resolve(html);\n          }\n      )\n  })\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.render(\x3cspan class=\x22hljs-string\x22\x3e\x27ssr\x27\x3c\/span\x3e， html);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建渲染器函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateRenderer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecode\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27vue-server-renderer\x27\x3c\/span\x3e).createBundleRenderer(code);\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 node 的 views 模板文件中只需要将上面的 html 输出就可以了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ssr.html\n    {% extends \x27layout.html\x27 %}\n    {% block body %}\n        \x22{{\x22 html | safe \x22}}\x22\n    {% endblock %}\n\n    \x3cscript src=\x26quot;\/public\/client.js\x26quot;\x3e\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ssr.html\x3c\/span\x3e\n    {% extends \x3cspan class=\x22hljs-string\x22\x3e\x27layout.html\x27\x3c\/span\x3e %}\n    {% block body %}\n        \x22{{\x22 html | safe \x22}}\x22\n    {% endblock %}\n\n    \x26lt;script src=\x3cspan class=\x22hljs-string\x22\x3e\x22\/public\/client.js\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，一个简单的服务端渲染就结束了。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e限于篇幅，详细的代码请参考 Github代码库：\x3ca href=\x22https:\/\/github.com\/ikcamp\/vue-ssr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/ikcamp\/vue...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e小结\x3c\/h1\x3e\n\x3cp\x3e整个demo包含了：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3evue \x2b vue-router \x2b vuex 的使用\x3c\/li\x3e\n\x3cli\x3e服务端数据获取\x3c\/li\x3e\n\x3cli\x3e客户端数据同步以及DOM hydration。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e没有涉及：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e流式渲染\x3c\/li\x3e\n\x3cli\x3e组件缓存\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对Vue的服务端渲染有更深一步的认识，实际在生产环境中的应用可能还需要考虑很多因素。\x3c\/p\x3e\n\x3cp\x3e选择Vue的服务端渲染方案，是情理之中的选择，不是对新技术的盲目追捧，而是一切为了需要。 Vue 2.0的SSR方案只是提供了一种可能，多了一种选择，框架本身在于服务开发者，根据不同的场景选择不同的方案，才会事半功倍。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e文章仅代表个人观点，有不妥当地方烦请大家指出，共同进步！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010887896\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010887896\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010953661\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010953661\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eiKcamp原创新书《移动Web前端高效开发实战》已在亚马逊、京东、当当开售。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/m.bosszhipin.com\/weijd\/v2\/job\/7bbfc95b9f1e9c4a1nRy2926FVA~?date8=20170905\x26amp;sid=self_jd\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x26gt;\x26gt; 沪江Web前端上海团队招聘【Web前端架构师】，有意者简历至：zhouyao@hujiang.com \x26lt;\x26lt;\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue.js 服务端渲染业务入门实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011039920">https://segmentfault.com/a/1190000011039920</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/259hmwxpz1o/" target="_blank">https://alili.tech/archive/259hmwxpz1o/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>