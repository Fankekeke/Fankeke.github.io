<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript：处理&#39;undefined&#39;的7个技巧"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript：处理&#39;undefined&#39;的7个技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/25e884f1/",
				"appid": "1613049289050283", 
				"title": "JavaScript：处理&#39;undefined&#39;的7个技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/916cf636/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ee781fe9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&text=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&text=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&title=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&is_video=false&description=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&title=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&title=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&title=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f25e884f1%2f&title=JavaScript%ef%bc%9a%e5%a4%84%e7%90%86%27undefined%27%e7%9a%847%e4%b8%aa%e6%8a%80%e5%b7%a7"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript：处理&#39;undefined&#39;的7个技巧</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e我刚刚开始学习JavaScript时，大约是八年前，当时我对于undefined 和 null 比较困惑 ，因为他们都表示空值。他们有什么明确的区别吗？他们似乎都可以定义一个空值，而且 当你进行 在做null ===undefined 的比较时，结果是true。\x3c\/p\x3e\n\x3cp\x3e现在的大多数语言，像Ruby, Python or Java，他们有一个单独的空值（nil 或 null），这似乎才合理。\x3c\/p\x3e\n\x3cp\x3e而在JavaScript里，当你要获取一个变量或对象（未初始化）的值时，js引擎会返回 undefined。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1B\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ceylon\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e company;  \ncompany;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e person = { name: \x3cspan class=\x22hljs-string\x22\x3e\x27John Smith\x27\x3c\/span\x3e };  \nperson.age; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另一方面，对象引用错误会返回null。Javascript本身并不会给将变量或者对象属性的值设为 null。一些js原生的方法会返回null，比如string.prototypt.match() 参数不是对象时，会返回null，来表示对象缺失\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1F\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3earray\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e;\x3c\/span\x3e  \n\x3cspan class=\x22hljs-string\x22\x3earray;\x3c\/span\x3e                \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e  \n\x3cspan class=\x22hljs-string\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3emovie\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Starship Troopers\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e  \x3cspan class=\x22hljs-attr\x22\x3emusicBy:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e  \n\x3cspan class=\x22hljs-string\x22\x3emovie.musicBy;\x3c\/span\x3e        \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e  \n\x3cspan class=\x22hljs-string\x22\x3e\x27abc\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e.match(\/[0-9]\/);\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于JavaScript的宽容特性，开发人员有访问未初始化值的诱惑。 我也犯了这种不好的做法。\x3c\/p\x3e\n\x3cp\x3e通常这种冒险行为会产生“未定义”的相关错误，从而快速结束脚本。 相关的常见错误消息是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eTypeError：\x27undefined\x27不是函数\x3c\/li\x3e\n\x3cli\x3eTypeError：无法读取未定义的属性\x27\x26lt;prop-name\x26gt;\x27\x27\x3c\/li\x3e\n\x3cli\x3e和类似\x3cem\x3etype errors\x3c\/em\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eJavaScript开发能够理解这个笑话:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eundefined\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ problem solved\x3c\/span\x3e\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了减少这种错误的风险，您必须了解产生“undefined”时的情况。 更重要的是抑制其外观并在应用程序中传播，从而提高代码的耐用性。\x3c\/p\x3e\n\x3cp\x3e我们来详细探讨\x3ccode\x3eundefined\x3c\/code\x3e及其对代码安全的影响。\x3c\/p\x3e\n\x3ch2\x3e1. 什么是\x3ccode\x3eundefined\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3eJavaScript 的 6 基本类型:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cem\x3eBoolean\x3c\/em\x3e: \x3ccode\x3etrue\x3c\/code\x3e or \x3ccode\x3efalse\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eNumber\x3c\/em\x3e: \x3ccode\x3e1\x3c\/code\x3e, \x3ccode\x3e6.7\x3c\/code\x3e, \x3ccode\x3e0xFF\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eString\x3c\/em\x3e: \x3ccode\x3e\x22Gorilla and banana\x22\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eSymbol\x3c\/em\x3e: \x3ccode\x3eSymbol(\x22name\x22)\x3c\/code\x3e (starting ES2015)\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eNull\x3c\/em\x3e: \x3ccode\x3enull\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eUndefined\x3c\/em\x3e: \x3ccode\x3eundefined\x3c\/code\x3e.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eAnd a separated \x3cem\x3eobject type\x3c\/em\x3e: \x3ccode\x3e{name: \x22Dmitri\x22}\x3c\/code\x3e, \x3ccode\x3e[\x22apple\x22, \x22orange\x22]\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e从6个基本类型\x3ccode\x3eundefined\x3c\/code\x3e是一个特殊的值，它的类型为Undefined。 根据[ECMAScript规范]（\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/7.0\/#sec-undefined-value）：\x22\x3ehttps:\/\/www.ecma-international.org\/ecma-262\/7.0\/#sec-undefined-value）：\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3e未定义的值\x3c\/strong\x3e原始值在变量未被赋值时使用。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e该标准明确规定，在访问未初始化的变量，不存在的对象属性，不存在的数组元素等时，您将收到未定义的值。 例如：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1J\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e movie = { name: \x3cspan class=\x22hljs-string\x22\x3e\x27Interstellar\x27\x3c\/span\x3e };  \nmovie.year; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e movies = [\x3cspan class=\x22hljs-string\x22\x3e\x27Interstellar\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Alexander\x27\x3c\/span\x3e];  \nmovies[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eECMAScript规范定义了“未定义”值的类型：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3e未定义类型\x3c\/strong\x3e是唯一值为“未定义”值的类型。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1L\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; true  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1M\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs vbnet\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enothing\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-built_in\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enothing\x3c\/span\x3e === \x3cspan class=\x22hljs-comment\x22\x3e\x27undefined\x27;   \/\/ =\x26gt; true  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e2. 创建未定义的常见场景`\x3c\/h2\x3e\n\x3ch3\x3e2.1 未初始化的变量\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e一个尚未赋值的声明变量（\x3cstrong\x3e uninitialized \x3c\/strong\x3e）默认为undefined。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3ePlain and simple:\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1N\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs abnf\x22\x3elet myVariable\x3cspan class=\x22hljs-comment\x22\x3e;  \x3c\/span\x3e\nmyVariable\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解决未初始化变量问题的一种有效方法是尽可能分配一个初始值_。 变量在未初始化状态下存在的越少越好。 理想情况下，您可以在声明`const myVariable =\x27初始值\x27后立即分配一个值，但这并非总是可行。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eTip 1: 赞成\x3ccode\x3econst\x3c\/code\x3e，否则使用\x3ccode\x3elet\x3c\/code\x3e，但是告别\x3ccode\x3evar\x3c\/code\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在我看来，ECMAScript 2015的最佳功能之一是使用\x3ccode\x3econst\x3c\/code\x3e和\x3ccode\x3elet\x3c\/code\x3e声明变量的新方法。 这是一个很大的进步，这些声明是块范围的（与旧函数作用域\x3ccode\x3evar\x3c\/code\x3e相反）并存在于[暂时死区]（\x3ca href=\x22https:\/\/rainsoft.io\/variables-lifecycle-and-why-let-\x22\x3ehttps:\/\/rainsoft.io\/variables-lifecycle-and-why-let-\x3c\/a\x3e 没有被吊起\/＃5letvariableslifecycle）直到宣告行。\x3c\/p\x3e\n\x3cp\x3e当变量只接收一个值时，我建议使用\x3ccode\x3econst\x3c\/code\x3e声明。 它创建一个[不可变绑定]（\x3ca href=\x22https:\/\/mathiasbynens.be\/notes\/es6-const）。\x22\x3ehttps:\/\/mathiasbynens.be\/notes\/es6-const）。\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3econst\x3c\/code\x3e的一个很好的特性是 - 你必须给初始值赋予变量\x3ccode\x3econst myVariable =\x27initial\x27\x3c\/code\x3e。 变量不会暴露于未初始化的状态，并且访问\x3ccode\x3eundefined\x3c\/code\x3e根本不可能。\x3c\/p\x3e\n\x3cp\x3e让我们检查一下验证单词是否是回文的函数：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1O\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3efunction isPalindrome(word) {  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e = word.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e half = Math.\x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e `\x26lt; half; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (word[\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e] !== word[\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e - \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\nisPalindrome(\x27madam\x27); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt;` true  \x3c\/span\x3e\nisPalindrome(\x27hello\x27); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014cae895cf3ba6bb1.png\x22 alt=\x22不要写var，写const，let\x22\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3evar\x3c\/code\x3e声明的问题是整个函数范围内的[变量提升]（\x3ca href=\x22https:\/\/rainsoft.io\/javascript-hoisting-in-details\/#hoistingandvar）。\x22\x3ehttps:\/\/rainsoft.io\/javascript-hoisting-in-details\/#hoistingandvar）。\x3c\/a\x3e 你可以在函数范围的末尾声明一个\x3ccode\x3evar\x3c\/code\x3e变量，但是它仍然可以在声明之前被访问：并且你会得到一个\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1P\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebigFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  myVariable; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e myVariable = \x3cspan class=\x22hljs-string\x22\x3e\x27Initial value\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  myVariable; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27Initial value\x27\x3c\/span\x3e\n}\nbigFunction();  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相反，在声明行之前不能访问\x3ccode\x3elet\x3c\/code\x3e（包括\x3ccode\x3econst\x3c\/code\x3e）变量。 发生这种情况是因为该变量在声明之前处于[暂时死区]（\x3ca href=\x22https:\/\/rainsoft.io\/variables-lifecycle-and-why-let-is-not-hoisted\/#5letvariableslifecycle）中。\x22\x3ehttps:\/\/rainsoft.io\/variables-lifecycle-and-why-let-is-not-hoisted\/#5letvariableslifecycle）中。\x3c\/a\x3e 这很好，因为你访问\x3ccode\x3eundefined\x3c\/code\x3e的机会较少。\x3c\/p\x3e\n\x3cp\x3e上面的例子用let改写后，会出错。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1T\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebigFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  myVariable; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; Throws \x27ReferenceError: myVariable is not defined\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e myVariable = \x3cspan class=\x22hljs-string\x22\x3e\x27Initial value\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ code...\x3c\/span\x3e\n  myVariable; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27Initial value\x27\x3c\/span\x3e\n}\nbigFunction();  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eTip 2: 增强内聚性\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e[Cohesion]（\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Cohesion_（computer_science））描述了模块（命名空间，类，方法，代码块）的元素所属的程度。\x22\x3ehttps:\/\/en.wikipedia.org\/wiki\/Cohesion_（computer_science））描述了模块（命名空间，类，方法，代码块）的元素所属的程度。\x3c\/a\x3e 内聚的测量通常被描述为\x3cem\x3e高内聚\x3c\/em\x3e或低内聚_。\x3c\/p\x3e\n\x3cp\x3e高内聚是最好的，因为它建议设计模块的元素只专注于单个任务。 它使模块：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cem\x3eFocused\x3c\/em\x3e and \x3cem\x3eunderstandable\x3c\/em\x3e: easier to understand what the module does\x3c\/li\x3e\n\x3cli\x3e功能单一且容易理解\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eMaintainable\x3c\/em\x3e and \x3cem\x3eeasier to refactor\x3c\/em\x3e: the change in the module affects fewer modules\x3c\/li\x3e\n\x3cli\x3e易于维护和复用\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eReusable\x3c\/em\x3e: being focusing on a single task, it makes the module easier to reuse\x3c\/li\x3e\n\x3cli\x3e重复利用\x3c\/li\x3e\n\x3cli\x3e\x3cem\x3eTestable\x3c\/em\x3e: you would easier test a module that\x27s focused on a single task\x3c\/li\x3e\n\x3cli\x3e易于测试\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cimg src=\x22http:\/\/s4.qhres.com\/static\/366a28d7a5d76f82.svg\x22 alt=\x22组件耦合和内聚\x22\x3e\x3c\/p\x3e\n\x3cp\x3e高内聚力伴随[松耦合]（\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Loose_coupling）是设计良好的系统的特点。\x22\x3ehttps:\/\/en.wikipedia.org\/wiki\/Loose_coupling）是设计良好的系统的特点。\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e一个代码块本身可能被认为是一个小模块。 为了从高内聚的好处中受益，您需要尽可能使变量尽可能靠近使用它们的代码块。\x3c\/p\x3e\n\x3cp\x3e例如，如果一个变量完全存在以形成块范围的逻辑，则声明并允许该变量仅存在于该块内（使用\x3ccode\x3econst\x3c\/code\x3e或\x3ccode\x3elet\x3c\/code\x3e声明）。 不要将这个变量暴露给外部块作用域，因为外部块不应该关心这个变量。\x3c\/p\x3e\n\x3cp\x3e不必要的扩展变量生命周期的一个典型例子是在函数内使用\x3ccode\x3efor\x3c\/code\x3e循环：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs n1ql\x22\x3efunction someFunc(array) {  \n  var \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e, item, \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n  \/\/ some code...\n  \/\/ some code...\n  for (\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    item = \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e];\n    \/\/ some code...\n  }\n  return \x27some result\x27;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eindex\x3c\/code\x3e，\x3ccode\x3eitem\x3c\/code\x3e和\x3ccode\x3elength\x3c\/code\x3e变量在函数体的开头声明。 然而，它们只用于接近尾声。 那么这种方法有什么问题？\x3c\/p\x3e\n\x3cp\x3e在顶部的声明和\x3ccode\x3efor\x3c\/code\x3e语句中的用法之间，变量\x3ccode\x3eindex\x3c\/code\x3e，\x3ccode\x3eitem\x3c\/code\x3e都是未初始化的并且暴露给\x3ccode\x3eundefined\x3c\/code\x3e。 它们在整个功能范围内的生命周期不合理。\x3c\/p\x3e\n\x3cp\x3e更好的方法是将这些变量尽可能靠近他们的使用地点：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3efunction someFunc(array) {  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ some code...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ some code...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e = array.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e `\x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e item = array[\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ some \x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x27some result\x27;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么修改后的版本比最初版本更好？ 让我们来看看：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e变量不会暴露于未初始化的状态，因此您没有访问未定义的风险\x3c\/li\x3e\n\x3cli\x3e尽可能将变量移动到它们的使用地点增加了代码的可读性\x3c\/li\x3e\n\x3cli\x3e高度连贯的代码块在需要时更容易重构并提取为分离的函数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3\x3e2.2 访问不存在的属性\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3eWhen accessing a **non-existing object property**, JavaScript returns\x3c\/code\x3eundefined`.\n当访问不再的属性时，会返回undefined\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e看例子：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1W\/1\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ceylon\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e favoriteMovie = {  \n  title: \x3cspan class=\x22hljs-string\x22\x3e\x27Blade Runner\x27\x3c\/span\x3e\n};\nfavoriteMovie.actors; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e本身访问不存在的属性不会引发错误。 尝试从不存在的属性值获取数据时出现真正的问题。 这是最常见的\x3ccode\x3eundefined\x3c\/code\x3e相关陷阱，反映在众所周知的错误消息\x27TypeError：Can not read property\x3ccode\x3e\x26lt;prop\x26gt;\x3c\/code\x3eof undefined`中。\x3c\/p\x3e\n\x3cp\x3e让我们稍微修改前面的代码片段来说明一个“TypeError”抛出：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1Z\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e favoriteMovie = {  \n  title: \x3cspan class=\x22hljs-string\x22\x3e\x27Blade Runner\x27\x3c\/span\x3e\n};\nfavoriteMovie.actors[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];  \n\/\/ TypeError: Cannot read property \x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e undefined\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e允许访问不存在的属性的JavaScript的宽容性质是混淆的来源：该属性可能被设置，或者可能不是。 绕过这个问题的理想方法是限制对象始终定义它所拥有的属性。\x3c\/p\x3e\n\x3cp\x3e不幸的是，您经常无法控制您使用的对象。 这些对象在不同情况下可能具有不同的属性集。 所以你必须手动处理所有这些场景。\x3c\/p\x3e\n\x3cp\x3e让我们实现一个函数append（array，toAppend），它在数组的开始和\/或结尾添加新的元素。 \x3ccode\x3etoAppend\x3c\/code\x3e参数接受一个具有属性的对象：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3efirst\x3c\/code\x3e: element inserted at the beginning of \x3ccode\x3earray\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3elast\x3c\/code\x3e: element inserted at the end of \x3ccode\x3earray\x3c\/code\x3e.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK11\/2\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs maxima\x22\x3efunction \x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, toAppend) {  \n  const arrayCopy = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.slice();\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (toAppend.\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e) {\n    arrayCopy.unshift(toAppend.\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (toAppend.\x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e) {\n    arrayCopy.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(toAppend.\x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e arrayCopy;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e], { \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e }); \/\/ =\x26gt; [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e]  \n\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e([\x27Hello\x27], { \x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e: \x27World\x27 });     \/\/ =\x26gt; [\x27Hello\x27, \x27World\x27]  \n\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e], { \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e });            \/\/ =\x26gt; [\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e]  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK11\/3\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3eappend([\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e], { \x3cspan class=\x22hljs-string\x22\x3efirst:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3elast:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; [10]  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面的提示解释了如何正确检查属性是否存在。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eTip 3: 检查属性是否存在\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e幸运的是，JavaScript提供了很多方法来确定对象是否具有特定属性：\x3c\/p\x3e\n\x3cp\x3e*\x3ccode\x3eobj.prop！== undefined\x3c\/code\x3e：直接与\x3ccode\x3eundefined\x3c\/code\x3e进行比较\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3etypeof obj.prop！==\x27undefined\x27：验证属性值的类型\n*\x3ccode\x3eobj.hasOwnProperty（\x27prop\x27）\x3c\/code\x3e：验证对象是否拥有自己的属性\x3c\/li\x3e\n\x3cli\x3eobj`中的\x27prop\x27：验证对象是否有自己的或继承的属性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我的建议是使用\x3ccode\x3ein\x3c\/code\x3e运算符。它有一个简短而甜美的语法。 \x3ccode\x3ein\x3c\/code\x3e操作符存在意味着明确的目的是检查对象是否具有特定的属性，而不访问实际的属性值。\x3c\/p\x3e\n\x3cp\x3e！[不要写var，写const并在JavaScript中放置]（\x3ca href=\x22https:\/\/p0.ssl.qhimg.com\/t010effea86a232d8a4.png）\x22\x3ehttps:\/\/p0.ssl.qhimg.com\/t010effea86a232d8a4.png）\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eobj.hasOwnProperty（\x27prop\x27）\x3c\/code\x3e也是一个不错的解决方案。它比\x3ccode\x3ein\x3c\/code\x3e运算符略长，并且只在对象自己的属性中进行验证。\x3c\/p\x3e\n\x3cp\x3e涉及与\x27undefined\x27比较的两种方式可能会起作用......但在我看来\x3ccode\x3eobj.prop！== undefined\x3c\/code\x3e和\x3ccode\x3etypeof obj.prop！==\x27undefined`\x3c\/code\x3e看起来冗长而怪异，并且暴露直接处理\x3ccode\x3eundefined\x3c\/code\x3e的怀疑路径。\x3c\/p\x3e\n\x3cp\x3e让我们使用\x3ccode\x3ein\x3c\/code\x3e运算符来改进\x3ccode\x3eappend（array，toAppend）\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK13\/1\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs maxima\x22\x3efunction \x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, toAppend) {  \n  const arrayCopy = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.slice();\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x27\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e\x27 \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e toAppend) {\n    arrayCopy.unshift(toAppend.\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x27\x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e\x27 \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e toAppend) {\n    arrayCopy.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(toAppend.\x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e arrayCopy;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e], { \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e }); \/\/ =\x26gt; [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e]  \n\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e], { \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e });  \/\/ =\x26gt; [\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e]  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eTip 4: 用对象结构的方式访问对象的属性\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e访问对象属性时，如果该属性不存在，有时需要指示默认值。\x3c\/p\x3e\n\x3cp\x3e你可以使用\x3ccode\x3ein\x3c\/code\x3e伴随着三元运算符来实现：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK14\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e = { };  \n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prop = \x3cspan class=\x22hljs-string\x22\x3e\x27prop\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e ? \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e.prop : \x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e;  \nprop; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27default\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当要检查的属性数量增加时，三元运算符语法的使用会变得艰巨。 对于每个属性，你必须创建一个新的代码行来处理默认值，增加类似外观的三元运算符的丑陋墙。\x3c\/p\x3e\n\x3cp\x3e为了使用更优雅的方法，让我们熟悉称为\x3cem\x3eobject destructuring\x3c\/em\x3e的一个伟大的ES2015功能。\n[对象解构]（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/Destructuring_assignment#Object_destructuring）允许直接将对象属性值直接提取到变量中，并设置默认值if\x22\x3ehttps:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/Destructuring_assignment#Object_destructuring）允许直接将对象属性值直接提取到变量中，并设置默认值if\x3c\/a\x3e 该属性不存在。 避免直接处理undefined的简便语法。\x3c\/p\x3e\n\x3cp\x3e事实上，现在的属性解析看起来简短且明了：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK16\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e = {  };  \n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { prop = \x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e } = \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e;  \nprop; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27default\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了看到实际情况，让我们定义一个有用的函数，将字符串包装在引号中。 \x3ccode\x3equote（subject，config）\x3c\/code\x3e接受第一个参数作为要包装的字符串。 第二个参数\x3ccode\x3econfig\x3c\/code\x3e是一个具有以下属性的对象：\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e\x3ccode\x3echar\x3c\/code\x3e：引号字符，例如 \x3ccode\x3e（单引号）或\x3c\/code\x3e（双引号），默认为\x3ccode\x3e`\x3c\/code\x3e。\n\x3c\/em\x3e\x3ccode\x3eskipIfQuoted\x3c\/code\x3e：如果字符串已被引用，则跳过引用的布尔值。 默认为\x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e应用对象解构的好处，让我们实现反引号的使用\x3ccode\x3e\x3c\/code\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK17\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs rust\x22\x3efunction quote(\x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e, config) {  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27\x22\x27\x3c\/span\x3e, skipIfQuoted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e } = config;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e length = \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e.length;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (skipIfQuoted\n      \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] === \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e\n      \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e[length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] === \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e;\n}\nquote(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Hello\x3c\/span\x3e World\x27, { \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e });        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27*Hello World*\x27  \x3c\/span\x3e\nquote(\x27\x3cspan class=\x22hljs-string\x22\x3e\x22Welcome\x22\x3c\/span\x3e\x27, { skipIfQuoted: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27\x22Welcome\x22\x27  \x3c\/span\x3e\n\n``\n`\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e =\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x27\x3c\/span\x3e，skipIfQuoted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e} = config`解构赋值在一行中从`config`对象中提取属性`\x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e`和`skipIfQuoted`如果某些属性在`config`对象中不可用， 解构赋值将默认值设置为：\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x27\x3c\/span\x3e为\x3cspan class=\x22hljs-symbol\x22\x3e\x27char\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27，\x27\x3c\/span\x3e\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27为\x27\x3c\/span\x3eskipIfQuoted`。\n\n幸运的是，该功能还有改进的空间。\n让我们将解构赋值移到参数部分。 并为`config`参数设置一个默认值（一个空对象`{}`），以在默认设置足够时跳过第二个参数。\n\n[Try \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e repl.it](https:\x3cspan class=\x22hljs-comment\x22\x3e\/\/repl.it\/HK1b\/0)\x3c\/span\x3e\n\n```javascript\nfunction quote(\x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e, { \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27\x22\x27\x3c\/span\x3e, skipIfQuoted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e } = {}) {  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e length = \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e.length;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (skipIfQuoted\n      \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] === \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e\n      \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e[length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] === \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3estr\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e;\n}\nquote(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Hello\x3c\/span\x3e World\x27, { \x3cspan class=\x22hljs-built_in\x22\x3echar\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27*Hello World*\x27  \x3c\/span\x3e\nquote(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Sunny\x3c\/span\x3e day\x27);                  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27\x22Sunny day\x22\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，解构赋值将替换函数签名中的“config”参数。 我喜欢这样：\x3ccode\x3equote（）\x3c\/code\x3e变成一行更短。 在解构赋值右侧的\x3ccode\x3e= {}\x3c\/code\x3e确保在第二个参数没有在quote（\x27Sunny day\x27）`中被指定时使用空对象。\x3c\/p\x3e\n\x3cp\x3e对象解构是一个强大的功能，可以有效地处理从对象中提取属性。 我喜欢在访问的属性不存在时指定要返回的默认值的可能性。 因此，避免了“未定义”以及与处理它有关的问题。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eTip 5:  用默认属性填充对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e如果不需要像解构分配那样为每个属性创建变量，则缺少某些属性的对象可以用缺省值填充。\x3c\/p\x3e\n\x3cp\x3eES2015\x3ccode\x3eObject.assign（target，source1，source2，...）\x3c\/code\x3e将所有可枚举属性的值从一个或多个源对象复制到目标对象中。 该函数返回目标对象。\x3c\/p\x3e\n\x3cp\x3e例如，您需要访问\x3ccode\x3eunsafeOptions\x3c\/code\x3e对象的属性，该属性并不总是包含其全部属性。\x3c\/p\x3e\n\x3cp\x3e为了在\x3ccode\x3eunsafeOptions\x3c\/code\x3e中访问一个不存在的属性时避免\x3ccode\x3eundefined\x3c\/code\x3e，让我们做一些调整：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e定义一个保存默认属性值的对象\x3ccode\x3edefaults\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3eObject.assign（{}，defaults，unsafeOptions）\x3c\/code\x3e来构建一个新的对象\x3ccode\x3eoptions\x3c\/code\x3e。 新对象接收来自\x3ccode\x3eunsafeOptions\x3c\/code\x3e的所有属性，但缺少的属性来自\x3ccode\x3edefaults\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1c\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e unsafeOptions = {  \n  fontSize: \x3cspan class=\x22hljs-number\x22\x3e18\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {  \n  fontSize: \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = \x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.assign({}, defaults, unsafeOptions);  \noptions.fontSize; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 18  \x3c\/span\x3e\noptions.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27black\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eObject.assign（）\x3c\/code\x3e将第一个参数作为目标对象\x3ccode\x3e{}\x3c\/code\x3e。 目标对象从\x3ccode\x3eunsafeOptions\x3c\/code\x3e源对象接收\x3ccode\x3efontSize\x3c\/code\x3e属性的值。 并且来自\x3ccode\x3edefaults\x3c\/code\x3e源对象的\x3ccode\x3ecolor\x3c\/code\x3e属性的值，因为\x3ccode\x3eunsafeOptions\x3c\/code\x3e不包含\x3ccode\x3ecolor\x3c\/code\x3e。 枚举源对象的顺序很重要：稍后的源对象属性将覆盖先前的对象属性。\x3c\/p\x3e\n\x3cp\x3e您现在可以安全地访问\x3ccode\x3eoptions\x3c\/code\x3e对象的任何属性，包括最初在\x3ccode\x3eunsafeOptions\x3c\/code\x3e中不可用的\x3ccode\x3eoptions.color\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e幸运的是，使用默认属性填充对象的方式更简单轻松。 我建议使用一个新的JavaScript特性（现在在[stage 3]（\x3ca href=\x22https:\/\/tc39.github.io\/process-document\/）），它允许[在对象初始化器中传播属性]（https:\/\/github.com\/\x22\x3ehttps:\/\/tc39.github.io\/process-document\/）），它允许[在对象初始化器中传播属性]（https:\/\/github.com\/\x3c\/a\x3e TC39\/提议对象，其余的扩展）。\x3c\/p\x3e\n\x3cp\x3e代替Object.assign（）调用，使用对象扩展语法将来自源对象的所有属性和可枚举属性复制到目标对象中：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1e\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e unsafeOptions = {  \n  fontSize: \x3cspan class=\x22hljs-number\x22\x3e18\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {  \n  fontSize: \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = {  \n  ...defaults,\n  ...unsafeOptions\n};\noptions.fontSize; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 18  \x3c\/span\x3e\noptions.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27black\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对象初始值设定项从\x3ccode\x3edefaults\x3c\/code\x3e和\x3ccode\x3eunsafeOptions\x3c\/code\x3e源对象传播属性。 指定源对象的顺序很重要：稍后的源对象属性会覆盖先前的对象属性。\x3c\/p\x3e\n\x3cp\x3e使用默认属性值填充不完整的对象是使代码安全和稳定的有效策略。 不管情况如何，对象总是包含全部属性：\x27undefined\x27不能生成。\x3c\/p\x3e\n\x3ch3\x3e2.3 函数的参数\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e函数参数默认默认为\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e通常，应使用相同数量的参数调用使用特定数量的参数定义的函数。 在这种情况下，这些参数将获得您期望的值：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1f\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3c\/span\x3e{  \n  a; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 5\x3c\/span\x3e\n  b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 3\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a * b;\n}\nmultiply(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 15  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当您在调用中省略参数时会发生什么？ 函数内部的参数变成\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e让我们稍微修改前面的例子，只用一个参数调用函数：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1j\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3c\/span\x3e{  \n  a; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 5\x3c\/span\x3e\n  b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a * b;\n}\nmultiply(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; NaN  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eTip 6: 给参数默认值\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e有时函数不需要调用的全套参数。 可以简单地为没有值的参数设置默认值。\x3c\/p\x3e\n\x3cp\x3e看例子：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1l\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (b === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n    b = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n  }\n  a; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 5\x3c\/span\x3e\n  b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 2\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a * b;\n}\nmultiply(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 10  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eThe function is invoked with a single argument \x3ccode\x3emultiply(5)\x3c\/code\x3e. Initially \x3ccode\x3ea\x3c\/code\x3e parameter is \x3ccode\x3e2\x3c\/code\x3e and \x3ccode\x3eb\x3c\/code\x3e is \x3ccode\x3eundefined\x3c\/code\x3e. The conditional statement verifies whether \x3ccode\x3eb\x3c\/code\x3e is \x3ccode\x3eundefined\x3c\/code\x3e. If it happens, \x3ccode\x3eb = 2\x3c\/code\x3e assignment sets a default value.\x3c\/p\x3e\n\x3cp\x3e尽管提供了分配默认值的方式，但我不建议直接比较\x27undefined\x27。 它很冗长，看起来像一个黑客。\x3c\/p\x3e\n\x3cp\x3e更好的方法是使用ES2015 [默认参数]（\x3ca href=\x22https:\/\/www.sitepoint.com\/es6-default-parameters\/）功能。\x22\x3ehttps:\/\/www.sitepoint.com\/es6-default-parameters\/）功能。\x3c\/a\x3e 它很短，很有表现力，并且与\x27undefined`没有直接的对比。\x3c\/p\x3e\n\x3cp\x3e例子修改，添加默认值:\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1m\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b = 2)\x3c\/span\x3e \x3c\/span\x3e{  \n  a; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 5\x3c\/span\x3e\n  b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 2\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a * b;\n}\nmultiply(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 10  \x3c\/span\x3e\nmultiply(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 10  \x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES2015的默认参数功能非常直观和高效。 始终使用它来为可选参数设置默认值。\x3c\/p\x3e\n\x3ch3\x3e2.4 函数返回值\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e隐式地，没有\x3ccode\x3ereturn\x3c\/code\x3e语句，JavaScript函数返回\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e在JavaScript中，没有任何\x3ccode\x3ereturn\x3c\/code\x3e语句的函数隐式地返回\x3ccode\x3eundefined\x3c\/code\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1n\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(x)\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = x * x;\n}\nsquare(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3esquare（）\x3c\/code\x3e函数不返回任何计算结果。 函数调用结果是\x27未定义的\x27。\x3c\/p\x3e\n\x3cp\x3e当\x3ccode\x3ereturn\x3c\/code\x3e语句存在时会发生同样的情况，但是附近没有表达式：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1o\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(x)\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = x * x;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n}\nsquare(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ereturn;\x3c\/code\x3e语句被执行，但它不返回任何表达式。 调用结果也是\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当然，在\x27return\x27附近表示要返回的表达式按预期工作：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1q\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(x)\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = x * x;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n}\nsquare(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 4  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eTip 7: 不要相信自动分号插入\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e以下JavaScript语句列表必须以分号（\x3ccode\x3e;\x3c\/code\x3e）结尾：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e空的陈述\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3elet\x3c\/code\x3e，\x3ccode\x3econst\x3c\/code\x3e，\x3ccode\x3evar\x3c\/code\x3e，\x3ccode\x3eimport\x3c\/code\x3e，\x3ccode\x3eexport\x3c\/code\x3e声明\x3c\/li\x3e\n\x3cli\x3e表达式语句\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3e调试器\x3c\/code\x3e语句\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3e继续\x3c\/code\x3e语句，\x3ccode\x3ebreak\x3c\/code\x3e语句\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3e抛出\x3c\/code\x3e声明\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ereturn\x3c\/code\x3e语句\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你使用上述语句之一，请务必在末尾指明分号：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1r\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetNum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Notice the semicolons at the end\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e num = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e num;\n}\ngetNum(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 1  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3elet\x3c\/code\x3e声明和\x3ccode\x3ereturn\x3c\/code\x3e声明结尾处写了一个强制性分号。\x3c\/p\x3e\n\x3cp\x3e当你不想添加这些分号时会发生什么？ 例如减少源文件的大小。\x3c\/p\x3e\n\x3cp\x3e在这种情况下，ECMAScript提供了[Automatic Semicolon Insertion]（\x3ca href=\x22http:\/\/www.ecma-international.org\/ecma-262\/6.0\/index.html#sec-automatic-semicolon-insertion）（ASI）机制，该机制可以插入\x22\x3ehttp:\/\/www.ecma-international.org\/ecma-262\/6.0\/index.html#sec-automatic-semicolon-insertion）（ASI）机制，该机制可以插入\x3c\/a\x3e 你丢失的分号。\x3c\/p\x3e\n\x3cp\x3e在ASI的帮助下，你可以从前面的示例中删除分号：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1t\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetNum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Notice that semicolons are missing\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e num = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e num\n}\ngetNum() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 1  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上文字是有效的JavaScript代码。 缺少的分号会自动插入。\x3c\/p\x3e\n\x3cp\x3e乍一看，它看起来很有希望。 ASI机制让你跳过不必要的分号。 您可以使JavaScript代码更小，更易于阅读。\x3c\/p\x3e\n\x3cp\x3eASI有一个小而烦人的陷阱。 当一个换行符位于\x3ccode\x3ereturn\x3c\/code\x3e和返回的表达式\x27return \\ n expression\x3ccode\x3e之间时，ASI自动在换行符之前插入一个分号\x3c\/code\x3e; \\ n表达式。\x3c\/p\x3e\n\x3cp\x3e在函数内部意味着什么\x3ccode\x3ereturn;\x3c\/code\x3e语句？ 该函数返回\x3ccode\x3eundefined\x3c\/code\x3e。 如果您不详细了解ASI的机制，那么意外返回的“未定义”是误导性的。\x3c\/p\x3e\n\x3cp\x3e例如，让我们研究\x3ccode\x3egetPrimeNumbers（）\x3c\/code\x3e调用的返回值：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK1x\/1\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3efunction getPrimeNumbers() {  \n  return \n    [ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e ]\n}\ngetPrimeNumbers() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3ereturn\x3c\/code\x3e语句和数组文字表达式之间存在一个新行。 JavaScript在\x3ccode\x3ereturn\x3c\/code\x3e后自动插入一个分号，解释代码如下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2C\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3efunction getPrimeNumbers() {  \n  return; \n  [ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e ];\n}\ngetPrimeNumbers(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e语句\x3ccode\x3ereturn;\x3c\/code\x3e使getPrimeNumbers（）函数返回undefined而不是期望的数组。\x3c\/p\x3e\n\x3cp\x3e通过删除\x3ccode\x3ereturn\x3c\/code\x3e和数组literal之间的换行符可以解决问题：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2D\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3efunction getPrimeNumbers() {  \n  return [ \n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e \n  ];\n}\ngetPrimeNumbers(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; [2, 3, 5, 7, 11, 13, 17]  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我的建议是研究[确切地说]（\x3ca href=\x22http:\/\/www.bradoncode.com\/blog\/2015\/08\/26\/javascript-semi-colon-insertion\/）\x22\x3ehttp:\/\/www.bradoncode.com\/blog\/2015\/08\/26\/javascript-semi-colon-insertion\/）\x3c\/a\x3e\n自动分号插入的作用，以避免这种情况。\x3c\/p\x3e\n\x3cp\x3eOf course, never put a newline between \x3ccode\x3ereturn\x3c\/code\x3e and the returned expression.\x3c\/p\x3e\n\x3ch3\x3e2.5 \x3ccode\x3evoid\x3c\/code\x3e 运算\x3c\/h3\x3e\n\x3cp\x3evoid运算，计算一个表达式，不返回计算结果，所以返回值为undefined\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2E\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e {\x3cspan class=\x22hljs-string\x22\x3ename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27John Smith\x27\x3c\/span\x3e}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e Math.min(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e[void use]运算符的[一个用例]（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/void#JavaScript_URIs）是将表达式评估抑制为undefined，依赖\x22\x3ehttps:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/void#JavaScript_URIs）是将表达式评估抑制为undefined，依赖\x3c\/a\x3e 关于评估的一些副作用。\x3c\/p\x3e\n\x3ch2\x3e3.  数组中的\x3ccode\x3eundefined\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3eYou get when accessing an array element with an out of bounds index.\n当你试图想要获取一个超出数组界限范围的下标时，会返回 \x3ccode\x3eundefined\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2H\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e colors = [\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e];  \ncolors[\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e];  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\ncolors[\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e数组\x3ccode\x3ecolors\x3c\/code\x3e 有3个元素array has 3 elements, 对应的下标分别是  \x3ccode\x3e0\x3c\/code\x3e, \x3ccode\x3e1\x3c\/code\x3e and \x3ccode\x3e2\x3c\/code\x3e。 因为在该数组中不存在下标5和-1，所以当你t访问\x3ccode\x3ecolors[5]\x3c\/code\x3e 和 \x3ccode\x3ecolors[-1]\x3c\/code\x3e会返回  \x3ccode\x3eundefined\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e在JavaScript中你可能遇到所谓的稀疏数组。 这些是有间隙的数组，即在某些索引中没有定义元素。\x3c\/p\x3e\n\x3cp\x3e当在一个稀疏数组中访问一个间隙（又名空槽）时，你也会得到一个\x27undefined`。\x3c\/p\x3e\n\x3cp\x3e以下示例将生成稀疏数组并尝试访问其空插槽：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2I\/1\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs prolog\x22\x3econst sparse1 = new \x3cspan class=\x22hljs-symbol\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);  \nsparse1;       \/\/ =\x26gt; [\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;empty slot\x26gt;`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;empty slot\x26gt;`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;empty slot\x26gt;`\x3c\/span\x3e]  \nsparse1[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];    \/\/ =\x26gt; undefined  \nsparse1[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];    \/\/ =\x26gt; undefined  \nconst sparse2 = [\x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e,  ,\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e]  \nsparse2;       \/\/ =\x26gt; [\x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;empty slot\x26gt;`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e]  \nsparse2[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];    \/\/ =\x26gt; undefined  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3esparse1\x3c\/code\x3e 是通过调用构造函数“Array”构造函数来创建的。 它有3个空插槽。 \x3ccode\x3esparse2\x3c\/code\x3e是用字面量的形式来创建了一个第二个元素为空的数组。 在任何这些稀疏数组中，访问一个空插槽的结果都是“undefined”。\x3c\/p\x3e\n\x3cp\x3e在处理数组时，为了避免捕获\x3ccode\x3eundefined\x3c\/code\x3e，一定要使用有效的数组索引，并避免创建稀疏数组。\x3c\/p\x3e\n\x3ch2\x3e4. \x3ccode\x3eundefined\x3c\/code\x3e and \x3ccode\x3enull\x3c\/code\x3e  之间的不同\x3c\/h2\x3e\n\x3cp\x3e这里有个合理的问题： \x3ccode\x3eundefined\x3c\/code\x3e and \x3ccode\x3enull\x3c\/code\x3e他们之间的主要区别是什么？都是一个指定值用来表示一个空状态。\x3c\/p\x3e\n\x3cp\x3e主要的区别是：\x3ccode\x3eundefined\x3c\/code\x3e是用来表示一个变量的值没有被定义。 \x3ccode\x3enull\x3c\/code\x3e 这是代表一个对象不存在。\x3c\/p\x3e\n\x3cp\x3e我们来看一下这些区别：\x3c\/p\x3e\n\x3cp\x3e当变量\x3ccode\x3enumber\x3c\/code\x3e 被定义，但是没有给它赋值进行初始化：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2J\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此变量\x3ccode\x3enumber\x3c\/code\x3e的值为 \x3ccode\x3eundefined\x3c\/code\x3e, .这明确表明了则是一个没有初始化的变量\x3c\/p\x3e\n\x3cp\x3e同样的，当你获取一个对象存在的属性时，也会发生这样的情况：该属性未初始化。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2L\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = { firstName: \x3cspan class=\x22hljs-string\x22\x3e\x27Dmitri\x27\x3c\/span\x3e };  \nobj.lastName; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; undefined  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面例子，因为 obj没有\x3ccode\x3elastName\x3c\/code\x3e属性，所以JavaScript会把 \x3ccode\x3eobj.lastName\x3c\/code\x3e 解析为 \x3ccode\x3eundefined\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e还有另一种情况，当一个变量期待是一个对象或者是一个方法返回一个对象时，但是由于某些原因，你不能实例化一个对象。。那么这样的情况下，null就会是一个有意义的指示器，来表示对象缺失。\x3c\/p\x3e\n\x3cp\x3e例如：clone()` 是一个用来复制JavaScript对象的 函数，这个函数期望能够返回的是一个对象。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2M\/2\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs php\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eclone\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof obj === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e \x26amp;\x26amp; obj !== \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Object.assign({}, obj);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e({name: \x3cspan class=\x22hljs-string\x22\x3e\x27John\x27\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; {name: \x27John\x27}  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e);             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; null  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e);           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; null  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后，可能会传入一个不是对象的参数：15，null。这种情况下，该函数就不能进行对象复制，所以会返回 \x3ccode\x3enull\x3c\/code\x3e  -- 来表示对象缺失\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3etypeof\x3c\/code\x3e 运算 能够看出两个值之间的区别\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HK2M\/1\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27undefined\x27  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27object\x27  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eThe \x3ca href=\x22https:\/\/rainsoft.io\/the-legend-of-javascript-equality-operator\/#theidentityoperator\x22\x3e全等运算符\x3c\/a\x3e \x3ccode\x3e===\x3c\/code\x3e 对于\x3ccode\x3eundefined\x3c\/code\x3e 和\x3ccode\x3enull\x3c\/code\x3e，也显示不相等。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/HLI0\/0\x22\x3eTry in repl.it\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nix\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3enothing\x3c\/span\x3e = undefined;  \n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emissingObject\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-attr\x22\x3enothing\x3c\/span\x3e === missingObject; \/\/ =\x26gt; \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e5.总结\x3c\/h2\x3e\n\x3cp\x3eundefined的存在是JavaScript随意性所造成的，他允许一下任意情况的使用：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3euninitialized variables \x3c\/li\x3e\n\x3cli\x3e未初始化的对象\x3c\/li\x3e\n\x3cli\x3enon-existing object properties or methods \x3c\/li\x3e\n\x3cli\x3e对象没有的方法或属性\x3c\/li\x3e\n\x3cli\x3eout of bounds indexes to access array elements  \x3c\/li\x3e\n\x3cli\x3e数组的超出长度下标的元素\x3c\/li\x3e\n\x3cli\x3ethe invocation result of a function that returns nothing\x3c\/li\x3e\n\x3cli\x3e当方法调用返回空时\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e大多数情况下，直接与\x27undefined\x27进行比较是一种不好的做法，因为你可能依赖于上面提到的允许但不鼓励的做法。\x3c\/p\x3e\n\x3cp\x3e一个有效的策略是减少代码中未定义关键字的出现。 在此期间，请总是以令人惊讶的方式记住它的潜在外观，并通过应用下列有益习惯来防止这种情况发生：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e减少未初始化变量的使用\x3c\/li\x3e\n\x3cli\x3e使变量生命周期变短并接近其使用的来源\x3c\/li\x3e\n\x3cli\x3e尽可能为变量分配一个初始值\x3c\/li\x3e\n\x3cli\x3e支持\x3ccode\x3econst\x3c\/code\x3e，否则使用\x3ccode\x3elet\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e使用默认值作为无意义的函数参数\x3c\/li\x3e\n\x3cli\x3e验证属性的存在或用缺省属性填充不安全的对象\x3c\/li\x3e\n\x3cli\x3e避免使用稀疏数组\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cem\x3eWhat\x27s your opinion about \x3ccode\x3eundefined\x3c\/code\x3e in JavaScript? Feel free to write a comment bellow!\x3c\/em\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/7-tips-to-handle-undefined-in-javascript-dmitri-pavlutin">https://www.zcfy.cc/article/7-tips-to-handle-undefined-in-javascript-dmitri-pavlutin</a> 原文标题: JavaScript：处理&rsquo;undefined&rsquo;的7个技巧 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/25e884f1/" target="_blank">https://alili.tech/archive/25e884f1/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>