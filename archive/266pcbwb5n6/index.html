<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端面试回顾（1）---javascript的面向对象"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端面试回顾（1）---javascript的面向对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/266pcbwb5n6/",
				"appid": "1613049289050283", 
				"title": "前端面试回顾（1）---javascript的面向对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/exvi3z7uwm8/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/h1rzzv6eh9e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f266pcbwb5n6%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e5%9b%9e%e9%a1%be%ef%bc%881%ef%bc%89---javascript%e7%9a%84%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端面试回顾（1）---javascript的面向对象</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e前一阵面试，过程中发现问到一些很基础的问题时候，自己并不能很流畅的回答出来。或者遇到一些基础知识的应用，由于对这些点理解的不是很深入，拿着笔居然什么都写不出来，于是有了回顾一下这些基础知识的想法。\x3c\/p\x3e\n\x3cp\x3e首先就是面试中经常会问到的，JS是怎么实现继承的，其实问到继承，面试官想问的可能还是你对JS面向对象的理解吧。\x3c\/p\x3e\n\x3cp\x3e这一部分的主要参考资料：《JavaScript高级程序设计》、《JavaScript设计模式》\x3cbr\x3e如果有什么错误的地方，也希望看到这篇文章的小伙伴给我指出来，谢谢 ^_^\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e一、对象\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e1.1创建对象\x3c\/h2\x3e\n\x3cp\x3eJavascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。\x3cbr\x3e一个简单的对象创建：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var People = {\n    name : \x26quot;eavan\x26quot;,\n    age : 24,\n    getName : function(){\n        alert(this.name);        \/\/eavan\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e People = {\n    name : \x3cspan class=\x22hljs-string\x22\x3e\x22eavan\x22\x3c\/span\x3e,\n    age : \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e,\n    getName : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/eavan\x3c\/span\x3e\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用的时候就可以用People.name，获取People这个对象的name属性,或者是People.getName()来得到People的name值。\x3cbr\x3e另一种对象创建方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\nvar People = new Object();\nPeople.name = \x26quot;eavan\x26quot;;\nPeople.age = 24;\nPeople.getName = function(){\n    alert(this.name);\n}\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs http\x22\x3e\x3ccode\x3e\n\n\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e People = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\nPeople.name = \x3cspan class=\x22hljs-string\x22\x3e\x22eavan\x22\x3c\/span\x3e;\nPeople.age = \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e;\nPeople.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n    \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里用到了new，就顺便提一下在使用new的时候发生了什么，其实在使用new的时候，大致可以认为做了这三件事，看下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var People  = {};                      \/\/我们创建了一个空对象People\nPeople.__proto__ = Object.prototype;   \/\/我们将这个空对象的__proto__成员指向了Object函数对象prototype成员对象\nObject.call(People);         \/\/我们将Object函数对象的this指针替换成People，然后再调用Object函数\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e People  = {};                      \x3cspan class=\x22hljs-comment\x22\x3e\/\/我们创建了一个空对象People\x3c\/span\x3e\nPeople.__proto__ = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/我们将这个空对象的__proto__成员指向了Object函数对象prototype成员对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.call(People);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/我们将Object函数对象的this指针替换成People，然后再调用Object函数\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e1.2封装\x3c\/h2\x3e\n\x3cp\x3e简单来说就是对一些属性的隐藏域暴露，比如私有属性、私有方法、共有属性、共有方法、保护方法等等。而js也能实现私有属性、私有方法、共有属性、共有方法等等这些特性。\x3c\/p\x3e\n\x3cp\x3e像java这样的面向对象的编程语言一般会有一个类的概念，从而实现封装。而javascript中没有类的概念，JS中实现封装主要还是靠函数。\x3c\/p\x3e\n\x3cp\x3e首先声明一个函数保存在一个变量里面。然后在这个函数（类）的内部通过对this变量添加属性或者方法来实现对类添加属相或者方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Person = function(){\n    var name = \x26quot;eavan\x26quot;;             \/\/私有属性\n    function checkName(){};         \/\/私有方法\n\n    this.myName = \x26quot;gaof\x26quot;;            \/\/对象共有属性\n    this.myFriends = [\x26quot;aa\x26quot;,\x26quot;bb\x26quot;,\x26quot;cc\x26quot;];\n    this.copy = function(){}         \/\/对象共有方法\n\n    this.getName = function(){       \/\/构造器方法\n        return name;\n    };            \n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Person = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22eavan\x22\x3c\/span\x3e;             \x3cspan class=\x22hljs-comment\x22\x3e\/\/私有属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckName\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};         \x3cspan class=\x22hljs-comment\x22\x3e\/\/私有方法\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.myName = \x3cspan class=\x22hljs-string\x22\x3e\x22gaof\x22\x3c\/span\x3e;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/对象共有属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.myFriends = [\x3cspan class=\x22hljs-string\x22\x3e\x22aa\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22bb\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22cc\x22\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.copy = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}         \x3cspan class=\x22hljs-comment\x22\x3e\/\/对象共有方法\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{       \x3cspan class=\x22hljs-comment\x22\x3e\/\/构造器方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e name;\n    };            \n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e纯构造函数封装数据的问题是：对像this.copy = function(){}这种方法的创建，其实在执行的时候大可不必绑定到特定的对象上去，将其定义到全局变量上也是一样的，而且其过程相当于实例化了一个Function，也大可不必实例化这么多其实干同一件事的方法。而这个小问题的解决可以用原型模式来解决。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e1.3理解原型\x3c\/h2\x3e\n\x3cp\x3e在每创建一个函数的时候，都会生成一个prototype属性，这个属性指向函数的原型对象。而其是用来包含特定类型的所有实例共享的属性和方法。所以，直接添加在原型中的实例和方法，就会被所有实例所共享。\x3c\/p\x3e\n\x3cp\x3e同样还是上面的Person的例子，我们可以为其原型添加新的属性和方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Person.isChinese = true;                          \/\/类的静态共有属性（对象不能访问）\nPerson.prototype.sex = \x26quot;man\x26quot; ;            \/\/类的共有属性\nPerson.prototype.frends = [\x26quot;gao\x26quot;,\x26quot;li\x26quot;,\x26quot;du\x26quot;];\nPerson.prototype.isBoy = function(){};    \/\/类的共有方法\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs protobuf\x22\x3e\x3ccode\x3ePerson.isChinese = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;                          \x3cspan class=\x22hljs-comment\x22\x3e\/\/类的静态共有属性（对象不能访问）\x3c\/span\x3e\nPerson.prototype.sex = \x3cspan class=\x22hljs-string\x22\x3e\x22man\x22\x3c\/span\x3e ;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/类的共有属性\x3c\/span\x3e\nPerson.prototype.frends = [\x3cspan class=\x22hljs-string\x22\x3e\x22gao\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22li\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22du\x22\x3c\/span\x3e];\nPerson.prototype.isBoy = function(){};    \x3cspan class=\x22hljs-comment\x22\x3e\/\/类的共有方法\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型封装数据的问题：对绑定在prototype上的引用类型的变量，由于被所有对象所共有，其中某一个对象对该数据进行修改，当别的对象访问该数据的时候，所访问到的值就是被修改后的。\x3cbr\x3e比如如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var person1 = new Person();\nperson1.frends.push(\x26quot;dd\x26quot;);\nconsole.log(person1.frends);    \/\/[\x26quot;gao\x26quot;, \x26quot;li\x26quot;, \x26quot;du\x26quot;, \x26quot;dd\x26quot;]\nvar person2 = new Person();\nperson2.frends.push(\x26quot;ee\x26quot;);\nconsole.log(person2.frends);     \/\/[\x26quot;gao\x26quot;, \x26quot;li\x26quot;, \x26quot;du\x26quot;, \x26quot;dd\x26quot;, \x26quot;ee\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Person();\nperson1.frends.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22dd\x22\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person1.frends);    \/\/[\x3cspan class=\x22hljs-string\x22\x3e\x22gao\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22li\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22du\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22dd\x22\x3c\/span\x3e]\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Person();\nperson2.frends.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22ee\x22\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person2.frends);     \/\/[\x3cspan class=\x22hljs-string\x22\x3e\x22gao\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22li\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22du\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22dd\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22ee\x22\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原本希望对person1和person2的friends属性分别添加新的内容，结果二者的friends属性居然是“公用”的！\x3c\/p\x3e\n\x3cp\x3e综上，最常见的方式应该是组合使用构造函数和原型模式，构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。\x3c\/p\x3e\n\x3cp\x3e每个类有三部分构成：第一部分是构造函数内，供实例对象化复制用。第二部分是构造函数外，直接通过点语法添加，供类使用，实例化对象访问不到。第三部分是类的原型中，实例化对象可以通过其原型链间接访问到，也是为所有实例化对象所共用。\x3c\/p\x3e\n\x3cp\x3e在说到对象实例的属性的时候，我们有一个问题，就是在访问一个属性的时候，这个属性是属于实例，还是属于这个实例的原型的呢？\x3c\/p\x3e\n\x3cp\x3e比如还是上面的例子，我们为person2实例增加一个sex属性，这时候访问person2的sex属性时，得到的是我们增加的值。说明为对象实例添加一个属性的时候，这个属性就会屏蔽原型对象中保存的同名属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   person2.sex = \x26quot;woman\x26quot;;\n    console.log(person1.sex);                \/\/man\n    console.log(person2.sex);                \/\/woman\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e   person2.sex = \x3cspan class=\x22hljs-string\x22\x3e\x22woman\x22\x3c\/span\x3e;\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person1.sex);                \x3cspan class=\x22hljs-comment\x22\x3e\/\/man\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person2.sex);                \x3cspan class=\x22hljs-comment\x22\x3e\/\/woman\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个时候我们可以使用hasOwnProperty()方法来检测一个属性是存在于实例中，还是存在于原型中。如果实例中有这个属性，hasOwnProperty()会返回true，而hasOwnProperty()并不会感知到原型中的属性。所以可以用这个方法检测属性到底是存在于实例中还是原型中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(person1.hasOwnProperty(\x26quot;sex\x26quot;));        \/\/原型中的属性，返回false\nconsole.log(person2.hasOwnProperty(\x26quot;sex\x26quot;));        \/\/实例中的属性，返回true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person1.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22sex\x22\x3c\/span\x3e));        \x3cspan class=\x22hljs-comment\x22\x3e\/\/原型中的属性，返回false\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(person2.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22sex\x22\x3c\/span\x3e));        \x3cspan class=\x22hljs-comment\x22\x3e\/\/实例中的属性，返回true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e二、继承\x3c\/h1\x3e\n\x3cp\x3eECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e2.1 原型链继承\x3c\/h2\x3e\n\x3cp\x3e如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super(){\n    this.val = true;\n    this.arr = [\x26quot;a\x26quot;];\n}\nfunction Sub(){\n        \/\/...\n}\nSub.prototype = new Super();\n\nvar sub = new Sub();\nconsole.log(sub.val)        \/\/true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n}\nSub.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Super();\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Sub();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sub.val)        \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码定义了Super和Sub两个类型，继承的核心就一句话：Sub.prototype = new Super() 将父类的一个实例赋给子类的原型。这样子类就能够使用父类实例所拥有的方法和父类原型中的方法。\x3c\/p\x3e\n\x3cp\x3e这种情况要想给子类添加自己的方法或者是覆盖父类中某个方法的时候，一定要在放在替换原型语句后面。否则写在原型上的方法都会丢失。\x3c\/p\x3e\n\x3cp\x3e而且在给子类添加新方法的时候，不能使用字面量的方式添加新方法，这样会导致继承无效。\x3cbr\x3e如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Sub.prototype = new Super();\nSub.prototype = {                        \/\/错误的方式\n    getVal : function(){\n        \/\/...\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3eSub.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Super();\nSub.prototype = {                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/错误的方式\x3c\/span\x3e\n    getVal : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码刚刚把Super的实例赋给原型，紧接着又将原信替换成一个对象字面量，导致现在原型包含的是一个Object的实例，并非Super的实例，因此原型链被切断了，Sub和Super已经没有关系了。\x3c\/p\x3e\n\x3cp\x3e原型链的问题：\x3cbr\x3e最主要的问题有两个：一是由于引用类型的原型属性会被所有实例所共享，所以通过原型链继承时，原型变成了另一个类型的实例，原先的实例属性也就变成了现在的原型属性，如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super(){\n    this.friends = [\x26quot;peng\x26quot;,\x26quot;gao\x26quot;];\n}\nfunction Sub(){\n        \/\/...\n}\nSub.prototype = new Super();\nvar sub1 = new Sub();\nvar sub2 = new Sub();\nsub1.friends.push(\x26quot;du\x26quot;);\nconsole.log(sub2.friends);            \/\/[\x26quot;peng\x26quot;, \x26quot;gao\x26quot;, \x26quot;du\x26quot;]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.friends = [\x3cspan class=\x22hljs-string\x22\x3e\x22peng\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22gao\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e\x3c\/span\x3e(){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n}\nSub.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eSuper\x3c\/span\x3e();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eSub\x3c\/span\x3e();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eSub\x3c\/span\x3e();\nsub1.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x22du\x22\x3c\/span\x3e);\nconsole.log(sub2.friends);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22peng\x22, \x22gao\x22, \x22du\x22]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子说明的就是上面的问题，子类的所有实例共享了父类中的引用类型属性。\x3c\/p\x3e\n\x3cp\x3e原型链继承的另一个问题是在创建子类行的实例的时候，没法向父类的构造函数传递参数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e2.2 构造函数继承\x3c\/h2\x3e\n\x3cp\x3e具体实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super(){\n    this.val = true;\n    this.arr = [\x26quot;a\x26quot;];\n}\nfunction Sub(){\n       Super.call(this);\n}\nvar sub = new Sub();\nconsole.log(sub.val)        \/\/true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n       Super.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Sub();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sub.val)        \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种模式这是解决了原型链继承中出现的两个问题，它可以传递参数，也没有了子类共享父类引用属性的问题。\x3cbr\x3e但这种模式也有他的问题，那就是在父类原型中定义的方法，其实是对子类不可见的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e2.3组合继承\x3c\/h2\x3e\n\x3cp\x3e既然上述的两种方式各有各自的局限性，将它俩整合到一起是不是会好一点呢，于是就有了组合继承。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super(){\n    this.val = true;\n    this.arr = [\x26quot;a\x26quot;];\n}\nfunction Sub(){\n       Super.call(this);                    \/\/{2}\n}\nSub.prototype = new Super();                \/\/{1}\nSub.prototype.constructor = Sub;            \/\/{3}\nvar sub = new Sub();\nconsole.log(sub.val)        \/\/true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n       Super.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/{2}\x3c\/span\x3e\n}\nSub.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Super();                \x3cspan class=\x22hljs-comment\x22\x3e\/\/{1}\x3c\/span\x3e\nSub.prototype.constructor = Sub;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/{3}\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Sub();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sub.val)        \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组合继承还有一个要注意的地方：\x3cbr\x3e在代码{3}处，将子类原型的constructor属性指向子类的构造函数。因为如果不这么做，子类的原型是父类的一个实例，所以子类原型的constructor属性就丢失了，他会顺着原型链继续往上找，于是就找到了父类的constructor所以它指向的其实是父类。\x3c\/p\x3e\n\x3cp\x3e这种继承方式是使用最多的一种方式。\x3cbr\x3e这种继承方式解决了上两种方式的缺点，不会出现共享引用类型的问题，同时父类原型中的方法也被继承了下来。\x3c\/p\x3e\n\x3cp\x3e如果要说起有什么缺点我们发现，在执行代码{1}时，Sub.prototype会得到父类型的val和arr两个属性。他们是Super的实例属性，只不过现在在Sub的原型上。而代码{2}处，在创建Sub实例的时候，调用Super的构造函数，又会在新的对象上创建属性val和arr，于是，这两个属性就屏蔽了原型中两个同名属性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e2.4寄生组合式继承\x3c\/h2\x3e\n\x3cp\x3e对于上面的问题，我们也有解决办法，不是在子类原型中多了一份父类的属性和方法么，那我原型中就只要父类原型中的属性和方法，这里我们引入了一个方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function inheritObject(obj){\n    var F = function(){};\n    F.prototype = obj;\n    return new F();\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einheritObject\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};\n    F.prototype = obj;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个方法创建了一个对象临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。\x3c\/p\x3e\n\x3cp\x3e我们可以设想，如果用这个方法拷贝一份父类的原型属性给子类，是不是就避免了上面提到的子类原型中多了一份父类构造函数内的属性。看如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\n\nfunction Sub(){\n    Super.call(this);\n}\nvar p = inheritObject(Super.prototype);         \/\/{1}\np.constructor = Sub;                            \/\/{2}\nSub.prototype = p;                              \/\/{3}\n \nvar sub = new Sub();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n}\nSuper.prototype.fun1 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};\nSuper.prototype.fun2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    Super.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = inheritObject(Super.prototype);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/{1}\x3c\/span\x3e\np.constructor = Sub;                            \x3cspan class=\x22hljs-comment\x22\x3e\/\/{2}\x3c\/span\x3e\nSub.prototype = p;                              \x3cspan class=\x22hljs-comment\x22\x3e\/\/{3}\x3c\/span\x3e\n \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sub = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Sub();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e基本思路就是：不必为了指定子类型的原型而调用父类的够着函数，我们需要的无非就是父类原型的一个副本而已。本质上就是复制出父类的一个副本，然后再将结果指定给子类型的原型。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e三、多态\x3c\/h1\x3e\n\x3cp\x3e所谓多态，就是同一个方法的多种调用方式，在javascript中，通过arguments对象对传入的参数做判断就可以实现多种调用方式。\x3c\/p\x3e\n\x3cp\x3e例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Add(){\n    function zero(){\n        return 10;\n    }\n    function one(num){\n        return 10 \x2b num;\n    }\nfunction    two(num1, num2){\n    return num1 \x2b num2;\n}\nthis.add = function(){\n    var arg = arguments,\n            len = arg.length;\n    switch (len){\n        case 0:\n            return zero();\n        case 1:\n            return one(arg[0]);\n        case 2:\n            return two(arg[0], arg[1]);\n        }\n    }\n}\nvar A = new Add();\nconsole.log(A.add());                \/\/10\nconsole.log(A.add(5));              \/\/15\nconsole.log(A.add(6, 7));          \/\/13\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAdd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ezero\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eone\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e \x2b num;\n    }\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e    \x3cspan class=\x22hljs-title\x22\x3etwo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enum1, num2\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e num1 \x2b num2;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arg = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,\n            len = arg.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (len){\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e:\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e zero();\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e one(arg[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]);\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e:\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e two(arg[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], arg[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n        }\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e A = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Add();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(A.add());                \x3cspan class=\x22hljs-comment\x22\x3e\/\/10\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(A.add(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e));              \x3cspan class=\x22hljs-comment\x22\x3e\/\/15\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(A.add(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e));          \x3cspan class=\x22hljs-comment\x22\x3e\/\/13\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端面试回顾（1）&mdash;javascript的面向对象</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011061136">https://segmentfault.com/a/1190000011061136</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/266pcbwb5n6/" target="_blank">https://alili.tech/archive/266pcbwb5n6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>