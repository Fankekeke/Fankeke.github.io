<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tutorial: GraphQL输入类型和自定义解析器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Tutorial: GraphQL输入类型和自定义解析器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/28e8dc11/",
				"appid": "1613049289050283", 
				"title": "Tutorial: GraphQL输入类型和自定义解析器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-21T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/32ffef6d/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ed7f0275/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&text=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&text=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&title=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&is_video=false&description=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&title=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&title=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&title=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f28e8dc11%2f&title=Tutorial%3a%20GraphQL%e8%be%93%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Tutorial: GraphQL输入类型和自定义解析器</h1><div class="meta"><div class="postdate"><time datetime="2018-10-21" itemprop="datePublished">2018-10-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3chr\x3e\n\x3cp\x3e这是我们全栈GraphQL \x2b React教程的第5部分，它指导您创建消息传递应用程序。 每个部分都是独立的，并且引入了新的关键概念，这意味着在执行此操作之前，您不必完成所有其他部分。 但万一你好奇，以下是我们到目前为止的内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b\x22\x3ePart 1: 创建一个简单的客户端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-part-2-server-99d0528c7928\x22\x3ePart 2: 创建一个简单的服务端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-mutations-764d7ec23c15\x22\x3ePart 3: 编写mutation并保持客户端同步\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3ePart 4: 良好的用户界面和客户端存储更新\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3ePart 5: 输入类型和自定义解析器(你在此!)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-server-side-e51c32dc2951\x22\x3ePart 6: 服务器端订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76\x22\x3ePart 7: 在客户端使用GraphQL订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823\x22\x3ePart 8: 分页\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e在第4部分中，我们介绍了如何使用store更新和良好的用户界面来处理示例应用的channel列表视图中的网络延迟。\x3c\/p\x3e\n\x3cp\x3e在这一部分中，我们将构建一个频道详情视图，显示channel中的所有消息并允许您发布新消息。 到最后，你会知道如何：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在查询中使用字段参数\x3c\/li\x3e\n\x3cli\x3e充分利用Apollo的标准缓存\x3c\/li\x3e\n\x3cli\x3e使用GraphQL输入类型\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e在开始之前，我们先克隆git仓库并安装依赖关系：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3egit \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehttps\x3c\/span\x3e:\/\/github.com\/apollographql\/graphql-tutorial.gitcd graphql-tutorialgit checkout t5-startcd server \x26amp;\x26amp; npm installcd ..\/client \x26amp;\x26amp; npm install\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e为了确保它的工作，让我们启动服务器和客户端，每个都在一个单独的终端中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servernpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在另一个终端：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e clientnpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e您现在可以导航到localhost:3000并浏览channel详情视图的当前状态。 我们已经为你做了一些工作，所以它应该看起来像这样：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01daf8fb03bfb48374.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e由于本教程主要关注GraphQL，因此我们已经为您制作了channel详细信息视图的路由和模板。 您不需要知道它如何在本教程中使用，但是如果您好奇，我们会使用react-router(查看\x3ca href=\x22https:\/\/medium.com\/@pshrmn\/a-simple-react-router-v4-tutorial-7f23ff27adf\x22\x3ereact-router tutorial\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/reacttraining.com\/react-router\/web\/guides\/quick-start\x22\x3edocumentation\x3c\/a\x3e).\x3c\/p\x3e\n\x3cp\x3e看起来我们已经完成了所有的工作，但新视图目前只是一个存根。 为了使其真正起作用，您需要编写一个GraphQL查询来获取来自服务器的channel名称和消息，并且您需要创建一个mutation来添加新消息。\x3c\/p\x3e\n\x3ch4\x3e添加channel详细信息视图\x3c\/h4\x3e\n\x3cp\x3echannel详情视图应显示channel名称，其信息和新的信息输入。 首先，我们修改架构并编写查询以显示当前channel中的消息。\x3c\/p\x3e\n\x3cp\x3e在schema中（在服务器上），我们需要创建一个消息类型，将消息字段添加到channel类型，并提供一种通过向根查询类型添加channel字段来获取单个channel的方法。 在进行这些更改之后，在schema.js中输入Define应如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eserver\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eschema.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst typeDefs =\x3cspan class=\x22hljs-built_in\x22\x3e type \x3c\/span\x3eChannel {  id: ID!  name: String  messages: [Message]!}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e {  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!  text: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e# \x3cspan class=\x22hljs-selector-tag\x22\x3eThis\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3especifies\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eentry\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3epoints\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3einto\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eour\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eAPItype\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eQuery\x3c\/span\x3e {  \x3cspan class=\x22hljs-attribute\x22\x3echannels\x3c\/span\x3e: [Channel]  \x3cspan class=\x22hljs-built_in\x22\x3echannel\x3c\/span\x3e(id: ID!): Channel}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e# \x3cspan class=\x22hljs-type\x22\x3eThe\x3c\/span\x3e mutation root \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, used to define all mutationstype \x3cspan class=\x22hljs-type\x22\x3eMutation\x3c\/span\x3e {  addChannel(name: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eChannel\x3c\/span\x3e};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3eschema\x3c\/span\x3e = makeExecutableSchema({ typeDefs, resolvers });export { schema };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e请注意，我们获取单个channel的方式是将id添加为字段参数。 这是GraphQL中非常常见的模式，您可能会在您的应用程序中使用它。 参数可以是任何标量或输入类型，我们将在本教程后面详细介绍。\x3c\/p\x3e\n\x3cp\x3e接下来，新查询需要由解析器支持，该解析器返回适当的channel。 为此，将加粗的查询添加到resolvers.js中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eserver\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eresolvers.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst channels\x3c\/span\x3e = [{  id: \x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e,  name: \x3cspan class=\x22hljs-string\x22\x3e\x27baseball\x27\x3c\/span\x3e,  messages: [{    id: \x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e,    text: \x3cspan class=\x22hljs-string\x22\x3e\x27baseball is life\x27\x3c\/span\x3e,  }]}];\x3cspan class=\x22hljs-attribute\x22\x3el\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3ee\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3et\x3c\/span\x3e \x3cspan class=\x22hljs-attribute\x22\x3en\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3ee\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3ex\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3et\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3eI\x3c\/span\x3e\x3cspan class=\x22hljs-attribute\x22\x3ed\x3c\/span\x3e = 3;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resolvers = {  \x3cspan class=\x22hljs-attr\x22\x3eQuery\x3c\/span\x3e: {    \x3cspan class=\x22hljs-attr\x22\x3echannels\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { ... },    \x3cspan class=\x22hljs-attr\x22\x3echannel\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eroot, { id }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e channels.find(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3echannel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e channel.id === id);\n},  },};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3e注意：我们为channel创建了一个预填充消息的数组。 如果你没有检查t5-start分支，你必须自己创建这个数组.\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e现在服务器支持查询特定channel，客户端 - 特别是ChannelDetails组件 - 需要执行查询。 GraphQL中的最佳做法是使用查询变量作为参数（在这种情况下，为$id）。 GraphQL规范要求我们在查询关键字后面定义我们使用的变量。 如果我们不这样做，服务器会抱怨我们使用了一个变量而没有定义它。 该定义必须与参数期望的类型相匹配。 在这种情况下，它是ID。\x3c\/p\x3e\n\x3cp\x3e在channelDetails.js中写入以下查询：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/channel\x3c\/span\x3eDetails.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3eexport const channelDetailsQuery = gql  query ChannelDetailsQuery($channelId : ID!) {    channel(\x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e: $channelId) {      \x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e      \x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e      messages {        \x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e        \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e      }    }  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在ChannelDetails React组件中，将存根替换为呈现实际数据的代码。 首先检查查询是否正在加载（data.loading），然后检查以确保没有错误（data.error），并最终呈现channel名称和MessagesList。\x3c\/p\x3e\n\x3cp\x3e如果你这样做了，你应该得到一个看起来像这样的组件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/\x3c\/span\x3eChannelDetails.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs moonscript\x22\x3econst ChannelDetails = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e({ data: {loading, \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e, channel }, match })\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (loading) {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Loading...;\n}  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e) {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e.message};\n}  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(channel === null){    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e   }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3e  return\x3c\/span\x3e (              {channel.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e}                );}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/export\x3c\/span\x3e const channelDetailsQuery = gql.\x3cspan class=\x22hljs-string\x22\x3e..\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e...\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，您只需使用之前编写的查询来打包组件，然后将其导出即可。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs 1c\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/client\/src\/components\/ChannelDetails.js (at the bottom)\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3e(graphql(channelDetailsQuery, {  options: (props) =\x26gt; ({    variables: { channelId: props.match.params.channelId },  }),})(ChannelDetails));\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们正在通往正常运行的可交流的应用程序，亲自尝试一下！ 它应该是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01f1af6ac30657ef7a.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e现在我们有一个channel名称和消息流，让我们添加消息mutation来发布新消息。\x3c\/p\x3e\n\x3ch4\x3e发布新消息\x3c\/h4\x3e\n\x3cp\x3e创建函数AddMessage与\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-mutations-764d7ec23c15\x22\x3e第三部分\x3c\/a\x3e添加频道非常相似, 所以首先建议使用带字段的mutation来显示消息文本和channel ID。 但是在将来，我们可能想要关联用户名，时间戳，文本编码，图片，提到的用户或其他元信息。 将这些添加到Mutation的签名中很快变得笨拙和不灵活。 为了保持整洁，我们将使用GraphQL\x3ca href=\x22http:\/\/graphql.org\/graphql-js\/mutations-and-input-types\/\x22\x3e输入类型\x3c\/a\x3e, 这是一个只能包含基本标量类型，列表类型和其他输入类型的对象。 输入类型允许客户端mutation签名保持不变并在模式中提供更好的可读性。\x3c\/p\x3e\n\x3cp\x3e从服务器开始，我们定义MessageInput输入类型，并在schema.js中包含mutation，如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eserver\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eschema.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eMessageInput\x3c\/span\x3e{  \x3cspan class=\x22hljs-attribute\x22\x3echannelId\x3c\/span\x3e: ID!  text: String}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMutation\x3c\/span\x3e {  # \x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e mutation to add a new channel to the list of channels  addChannel(name: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eChannel\x3c\/span\x3e  addMessage(message: \x3cspan class=\x22hljs-type\x22\x3eMessageInput\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eresolver.js中的addMessage解析器应该检查输入\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eserver\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eresolvers.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs nimrod\x22\x3e\x3cspan class=\x22hljs-type\x22\x3eMutation\x3c\/span\x3e: {  addChannel: \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,  addMessage: (root, { message }) =\x26gt; {    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e channel = channels.find(channel =\x26gt; channel.id === message.channelId);\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!channel)      throw new \x3cspan class=\x22hljs-type\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Channel does not exist\x22\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3e    const \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e = { id: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e(nextMessageId\x2b\x2b), text: \x3cspan class=\x22hljs-type\x22\x3emessage\x3c\/span\x3e.text };\nchannel.messages.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e;\n},},\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来在客户端，我们需要完成AddMessage.js，从查询开始：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/\x3c\/span\x3eAddMessage.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs protobuf\x22\x3econst addMessageMutation = gql  mutation addMessage($\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3eMessageInput\x3c\/span\x3e!) \x3c\/span\x3e{    addMessage(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e: $\x3cspan class=\x22hljs-title\x22\x3emessage\x3c\/span\x3e) \x3c\/span\x3e{      id      text    }  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eAddMessage组件主体将变量添加到AddChannel的基本代码中，其中包括我们在其中使用的相同的UI功能 \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3elast tutorial\x3c\/a\x3e. 唯一不同的部分是变量。 我在下面以粗体突出显示了这些变化：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/\x3c\/span\x3eAddMessage.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst AddMessage = ({ mutate, match }) =\x26gt; {  const handleKeyUp = (evt) =\x26gt; {    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (evt.keyCode === \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e) {      mutate({        \x3cspan class=\x22hljs-string\x22\x3evariables:\x3c\/span\x3e {          \x3cspan class=\x22hljs-string\x22\x3emessage:\x3c\/span\x3e {            \x3cspan class=\x22hljs-string\x22\x3echannelId:\x3c\/span\x3e match.params.channelId,            \x3cspan class=\x22hljs-string\x22\x3etext:\x3c\/span\x3e evt.target.value          }        },        \x3cspan class=\x22hljs-string\x22\x3eoptimisticResponse:\x3c\/span\x3e {          \x3cspan class=\x22hljs-string\x22\x3eaddMessage:\x3c\/span\x3e {            \x3cspan class=\x22hljs-string\x22\x3etext:\x3c\/span\x3e evt.target.value,            \x3cspan class=\x22hljs-string\x22\x3eid:\x3c\/span\x3e Math.round(Math.random() * \x3cspan class=\x22hljs-number\x22\x3e-1000000\x3c\/span\x3e),            \x3cspan class=\x22hljs-string\x22\x3e__typename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Message\x27\x3c\/span\x3e,          },        },        \x3cspan class=\x22hljs-string\x22\x3eupdate:\x3c\/span\x3e (store, { \x3cspan class=\x22hljs-string\x22\x3edata:\x3c\/span\x3e { addMessage } }) =\x26gt; {          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Read the data from the cache for this query.          const data = store.readQuery({            query: channelDetailsQuery,            variables: {              channelId: match.params.channelId,            }          });\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Add our Message from the mutation to the end.          data.channel.messages.push(addMessage);\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Write the data back to the cache.          store.writeQuery({            query: channelDetailsQuery,            variables: {              channelId: match.params.channelId,            },            data          });\x3c\/span\x3e\n},      });\nevt.target.value = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n}  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (     ...  );};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/const\x3c\/span\x3e addMessageMutation = gql.\x3cspan class=\x22hljs-string\x22\x3e..\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs lisp\x22\x3econst AddMessageWithMutation = graphql(  \x3cspan class=\x22hljs-name\x22\x3eaddMessageMutation\x3c\/span\x3e,)(\x3cspan class=\x22hljs-name\x22\x3ewithRouter\x3c\/span\x3e(\x3cspan class=\x22hljs-name\x22\x3eAddMessage\x3c\/span\x3e))\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3eAddMessageWithMutation;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eNote:\x3c\/em\x3e \x3ca href=\x22https:\/\/reacttraining.com\/react-router\/web\/api\/match\x22\x3e\x3cem\x3ematch\x3c\/em\x3e\x3c\/a\x3e \x3cem\x3e是react-router提供的url属性的接口\x3c\/em\x3e \x3ca href=\x22https:\/\/reacttraining.com\/react-router\/web\/api\/withRouter\x22\x3e\x3cem\x3ewithRouter\x3c\/em\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e现在我们有一个功能齐全的消息channel！ 但是，有一个小问题：如果网络速度较慢，用户必须等待channel名称和消息从服务器加载。 在加载所有数据之前，用户甚至不知道他们在哪个channel，这是坏的UX。 理想情况下，我们希望用户在加载邮件时看到良好的channel预览。 这就是我们在本教程的最后部分要做的。\x3c\/p\x3e\n\x3ch4\x3e从缓存中读取频channel名称\x3c\/h4\x3e\n\x3cp\x3e正如您可能已经注意到的，客户端已经知道channel名称，因为它在主页上加载了ChannelNameListQuery。 如果有方法让我们保留channel名称，我们可以在不向服务器提出其他请求的情况下显示它！\x3c\/p\x3e\n\x3cp\x3e幸运的是，Apollo Client会自动将每个查询结果存储在\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/the-concepts-of-graphql-bc68bd819be3\x22\x3enormalized cache\x3c\/a\x3e中，这意味着我们可以查询数据 我们希望让Apollo Client找出它是否可以从缓存中加载。 但是，有一个小问题：\x3c\/p\x3e\n\x3cp\x3e默认情况下，Apollo客户端使用查询路径（例如\/channel(id:5)\/name）来确定对象是否被缓存。\x3c\/p\x3e\n\x3cp\x3e由于channels和channel查询导致到同一对象的路径不同，Apollo Client不知道它们是相同的，除非您明确告诉它channel查询可能解析为channel查询检索到的对象。 我们可以通过向App.js中的ApolloClient构造函数添加一个自定义解析器来告诉Apollo客户端这种关系。 每当我们进行channel查询时，这个自定义解析器就会告诉Apollo客户端检查它的缓存中是否有ID $ channelId的Channel对象。 如果它在缓存中找到具有该ID的channel，则不会向服务器发出请求。\x3c\/p\x3e\n\x3cp\x3e以下自定义解析器在App.js中创建此映射：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eclient\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eApp.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs nimrod\x22\x3e\/\/function dataIdFromObject (\x3cspan class=\x22hljs-literal\x22\x3eresult\x3c\/span\x3e) \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst client = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ApolloClient({  networkInterface,  \x3cspan class=\x22hljs-string\x22\x3ecustomResolvers:\x3c\/span\x3e {    \x3cspan class=\x22hljs-string\x22\x3eQuery:\x3c\/span\x3e {      \x3cspan class=\x22hljs-string\x22\x3echannel:\x3c\/span\x3e (_, args) =\x26gt; {        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e toIdValue(dataIdFromObject({ \x3cspan class=\x22hljs-string\x22\x3e__typename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Channel\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eid:\x3c\/span\x3e args[\x3cspan class=\x22hljs-string\x22\x3e\x27id\x27\x3c\/span\x3e] }))      },    },  },  dataIdFromObject,});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eApolloClient\x3c\/em\x3e \x3cem\x3euses\x3c\/em\x3e \x3cem\x3edataIdFromObject\x3c\/em\x3e \x3cem\x3eto tag GraphQL objects in the cache and\x3c\/em\x3e \x3cem\x3etoIdValue\x3c\/em\x3e \x3cem\x3eensures an ID type is returned.\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e现在您只需要像通常那样创建ChannelPreview组件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/\x3c\/span\x3eChannelPreview.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs moonscript\x22\x3econst ChannelPreview = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e({ data: {loading, \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e, channel } })\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (    \n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs abnf\x22\x3e      Loading Messages      )\x3cspan class=\x22hljs-comment\x22\x3e;};\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs objectivec\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e channelQuery = gql  query ChannelQuery($channelId : ID!) {    channel(\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e: $channelId) {      \x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e      name    }  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3e(graphql(channelQuery, {  options: (props) =\x26gt; ({    variables: { channelId: props.channelId },  }),})(ChannelPreview));\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e最后，我们需要用ChannelPreview组件替换ChannelDetails组件的加载消息：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3e\/\x3cspan class=\x22hljs-regexp\x22\x3e\/client\/src\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/components\/\x3c\/span\x3eChannelDetails.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst ChannelDetails = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(...)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (loading) {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过从缓存中提取数据，我们创建了一个channel详细视图，可以在后台加载消息的同时立即显示channel名称。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01502df6fc862839ba.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e总结\x3c\/h4\x3e\n\x3cp\x3e恭喜，您现在有一个可以提供channel标记的消息流的应用程序！ 该服务几乎已经准备好用于生产，经过几次改进之后：首先，我们需要一种使用GraphQL订阅实时显示消息的方法，从\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-server-side-e51c32dc2951\x22\x3e下一部分\x3c\/a\x3e的服务器端开始. 其次，我们希望分页消息，因为一次加载所有消息可能会很慢。 最后，我们还需要添加登录和身份验证，以确保我们知道消息来自哪里。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e如果您喜欢本教程并希望继续学习Apollo和GraphQL，请务必点击下面的“关注”按钮，然后在Twitter上关注我们 \x3ca href=\x22https:\/\/twitter.com\/apollographql\x22\x3e@apollographql\x3c\/a\x3e 以及作者 \x3ca href=\x22https:\/\/twitter.com\/evanshauser\x22\x3e@evanshauser\x3c\/a\x3e.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e非常感谢\x3ca href=\x22https:\/\/medium.com\/@helfer\x22\x3eJonas Helfer\x3c\/a\x3e 的指导!\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/tutorial-graphql-input-types-and-custom-resolvers">www.zcfy.cc</a> 原文标题: Tutorial: GraphQL输入类型和自定义解析器 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/28e8dc11/" target="_blank">https://alili.tech/archive/28e8dc11/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>