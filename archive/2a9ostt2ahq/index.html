<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="源码分析：Vue的双向数据绑定"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>源码分析：Vue的双向数据绑定 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/2a9ostt2ahq/",
				"appid": "1613049289050283", 
				"title": "源码分析：Vue的双向数据绑定 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-30T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hjd3h71hbrm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/e2bvcc790gb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&text=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&text=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&title=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&is_video=false&description=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&title=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&title=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&title=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2a9ostt2ahq%2f&title=%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%9aVue%e7%9a%84%e5%8f%8c%e5%90%91%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">源码分析：Vue的双向数据绑定</h1><div class="meta"><div class="postdate"><time datetime="2018-12-30" itemprop="datePublished">2018-12-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e虽然工作中一直使用Vue作为基础库，但是对于其实现机理仅限于道听途说，这样对长期的技术发展很不利。所以最近攻读了其源码的一部分，先把双向数据绑定这一块的内容给整理一下，也算是一种学习的反刍。\x3c\/p\x3e\n\x3cp\x3e本篇文章的Vue源码版本为\x3ccode\x3ev2.2.0开发版\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eVue源码的整体架构无非是初始化Vue对象，挂载数据\x3ccode\x3edata\/props\x3c\/code\x3e等，在不同的时期触发不同的事件钩子，如\x3ccode\x3ecreated() \/ mounted() \/ update()\x3c\/code\x3e等，后面专门整理各个模块的文章。这里先讲双向数据绑定的部分，也是最主要的部分。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e设计思想：观察者模式\x3c\/h2\x3e\n\x3cp\x3eVue的双向数据绑定的设计思想为\x3ccode\x3e观察者模式\x3c\/code\x3e，为了方便，下文中将被观察的对象称为观察者，将观察者对象触发更新的称为订阅者。主要涉及到的概念有：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3eDep对象：Dependency依赖的简写，包含有三个主要属性\x3ccode\x3eid, subs, target\x3c\/code\x3e和四个主要函数\x3ccode\x3eaddSub, removeSub, depend, notify\x3c\/code\x3e，是观察者的依赖集合，负责在数据发生改变时，使用\x3ccode\x3enotify()\x3c\/code\x3e触发保存在\x3ccode\x3esubs\x3c\/code\x3e下的订阅列表，依次更新数据和DOM。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22id: 每个观察者(依赖对象)的唯一标识。\nsubs: 观察者对象的订阅者列表。\ntarget: 全局唯一的订阅者对象，因为只能同时计算和更新一个订阅者的值。\naddSub(): 使用`push()`方法添加一个订阅者。\nremoveSub(): 使用`splice()`方法移除一个订阅者。\ndepend(): 将自己添加到当前订阅者对象的依赖列表。\nnotify(): 在数据被更新时，会遍历subs对象，触发每一个订阅者的更新。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eid: 每个观察者(依赖对象)的唯一标识。\nsubs: 观察者对象的订阅者列表。\ntarget: 全局唯一的订阅者对象，因为只能同时计算和更新一个订阅者的值。\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eaddSub\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e: 使用`push()`方法添加一个订阅者。\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eremoveSub\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e: 使用`splice()`方法移除一个订阅者。\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3edepend\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e: 将自己添加到当前订阅者对象的依赖列表。\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3enotify\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e: 在数据被更新时，会遍历subs对象，触发每一个订阅者的更新。\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eObserver对象：即观察者，包含两个主要属性\x3ccode\x3evalue, dep\x3c\/code\x3e。做法是使用getter\/setter方法覆盖默认的取值和赋值操作，将对象封装为响应式对象，每一次调用时更新依赖列表，更新值时触发订阅者。绑定在对象的\x3ccode\x3e__ob__\x3c\/code\x3e原型链属性上。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22value: 原始值。\ndep: 依赖列表。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs avrasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3evalue:\x3c\/span\x3e 原始值。\n\x3cspan class=\x22hljs-symbol\x22\x3edep:\x3c\/span\x3e 依赖列表。\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e源码实战解析\x3c\/h2\x3e\n\x3cp\x3e有过Vue开发基础的应该都了解其怎么初始化一个Vue对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n    el: \x27#container\x27,\n    data: {\n        count: 100\n    },\n    ...\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e({\n    \x3cspan class=\x22hljs-attribute\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#container\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3edata\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attribute\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n    },\n    ...\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么我们就从这个count说起，看它是怎么完成双向数据绑定的。\x3c\/p\x3e\n\x3cp\x3e下面的代码片段中英文注释为尤雨溪所写，中文注释为我所写，英文注释更能代表开发者的清晰思路。\x3c\/p\x3e\n\x3cp\x3e首先从全局的初始化函数调用：\x3ccode\x3einitMixin(Vue$3);\x3c\/code\x3e，这里的\x3ccode\x3eVue$3\x3c\/code\x3e对象就是全局的Vue对象，在此之前已经挂载了Vue的各种基本数据和函数。这个函数体就是初始化我们上面声明Vue语句的过程化逻辑，取主体代码来看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里的options就是上面声明Vue对象的json对象\nVue.prototype._init = function (options) {\n    ...\n    var vm = this;\n    ...\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, \x27beforeCreate\x27);\n    \/\/ 这里就是我们接下来要跟进的初始化Vue参数\n    initState(vm);\n    initInjections(vm);\n    callHook(vm, \x27created\x27);\n    ...\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的options就是上面声明Vue对象的json对象\x3c\/span\x3e\nVue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    ...\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeCreate\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里就是我们接下来要跟进的初始化Vue参数\x3c\/span\x3e\n    initState(vm);\n    initInjections(vm);\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27created\x27\x3c\/span\x3e);\n    ...\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里主要完成了初始化事件、渲染、参数、注入等过程，并不断调用事件钩子的回调函数。下面来到如何初始化参数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  \/\/ 我们的count在这里初始化\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true \/* asRootData *\/);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitState\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(vm)\x3c\/span\x3e \x3c\/span\x3e{\n  vm._watchers = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e opts = vm.$options;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.props) { initProps(vm, opts.props); }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.methods) { initMethods(vm, opts.methods); }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们的count在这里初始化\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.data) {\n    initData(vm);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    observe(vm._data = {}, \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.computed) { initComputed(vm, opts.computed); }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.watch) { initWatch(vm, opts.watch); }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里依次检测参数中包含的\x3ccode\x3eprops\/methods\/data\/computed\/watch\x3c\/code\x3e并进入不同的函数进行初始化，这里我们只关心initData：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === \x27function\x27\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n  }\n  ...\n  \/\/ observe data\n  observe(data, true \/* asRootData *\/);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e initData (vm) {\n  var \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = vm.$options.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = vm._data = typeof \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e === \x27function\x27\x3c\/span\x3e\n    ? \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.call(\x3cspan class=\x22hljs-title\x22\x3evm\x3c\/span\x3e)\x3c\/span\x3e\n    : \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e || {};\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e = {};\x3c\/span\x3e\n  }\n  ...\n  \/\/ observe \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e\x3c\/span\x3e\n  observe(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, true \/* asRootData *\/);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到Vue的\x3ccode\x3edata\x3c\/code\x3e参数支持对象和回调函数，但最终返回的一定是对象，否则使用空对象。接下来就是重头戏了，我们如何将data参数设置为响应式的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\/\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, \x27__ob__\x27) \x26amp;\x26amp; value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    \/* 为了防止value不是单纯的对象而是Regexp或者函数之类的，或者是vm实例再或者是不可扩展的 *\/\n    observerState.shouldConvert \x26amp;\x26amp;\n    !isServerRendering() \x26amp;\x26amp;\n    (Array.isArray(value) || isPlainObject(value)) \x26amp;\x26amp;\n    Object.isExtensible(value) \x26amp;\x26amp;\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData \x26amp;\x26amp; ob) {\n    ob.vmCount\x2b\x2b;\n  }\n  return ob\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3eobserve\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, asRootData\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isObject(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasOwn(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e) \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e.__ob__ instanceof Observer) {\n    ob = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e.__ob__;\n  } \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 为了防止value不是单纯的对象而是Regexp或者函数之类的，或者是vm实例再或者是不可扩展的 *\/\x3c\/span\x3e\n    observerState.shouldConvert \x26amp;\x26amp;\n    !isServerRendering(\x3c\/span\x3e) \x26amp;\x26amp;\n    (\x3cspan class=\x22hljs-params\x22\x3eArray.isArray(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e) || \x3cspan class=\x22hljs-title\x22\x3eisPlainObject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e)) \x26amp;\x26amp;\n    Object.\x3cspan class=\x22hljs-title\x22\x3eisExtensible\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e) \x26amp;\x26amp;\n    !\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e._isVue\n  ) \x3c\/span\x3e{\n    ob = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (asRootData \x26amp;\x26amp; ob) {\n    ob.vmCount\x2b\x2b;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ob\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的英文注释非常清晰，就是为了给该对象新建一个观察者类，如果存在则返回已存在的（比如互相引用或依赖重复），可以看到这个观察者列表放置在对象的\x3ccode\x3e__ob__\x3c\/code\x3e属性下。下面我们看下这个Observer观察者类：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object\x27s property keys into getter\/setters that\n * collect dependencies and dispatches updates.\n *\/\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  \/\/ def函数是defineProperty的简单封装\n  def(value, \x27__ob__\x27, this);\n  if (Array.isArray(value)) {\n    \/\/ 在es5及更低版本的js里，无法完美继承数组，这里检测并选取合适的函数\n    \/\/ protoAugment函数使用原型链继承，copyAugment函数使用原型链定义（即对每个数组defineProperty）\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object\x27s property keys into getter\/setters that\n * collect dependencies and dispatches updates.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Observer = \x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep();\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ def函数是defineProperty的简单封装\x3c\/span\x3e\n  def(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在es5及更低版本的js里，无法完美继承数组，这里检测并选取合适的函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ protoAugment函数使用原型链继承，copyAugment函数使用原型链定义（即对每个数组defineProperty）\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, arrayMethods, arrayKeys);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observeArray(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在Observer类的注释里也清楚的说明，它会被关联到每一个被检测的对象，使用\x3ccode\x3egetter\/setter\x3c\/code\x3e修改其默认读写，用于收集依赖和发布更新。其中出现了三个我们需要关心的东西\x3ccode\x3eDep类\/observeArray\/walk\x3c\/code\x3e，我们先看observeArray的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Observe a list of Array items.\n *\/\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i \x3c l; i\x2b\x2b) {\n    observe(items[i]);\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Observe a list of Array items.\n *\/\x3c\/span\x3e\nObserver.prototype.observeArray = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobserveArray\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(items)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = items.length; i \x26lt; l; i\x2b\x2b) {\n    observe(items[i]);\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它不过是在Observer类和observe方法中间的一层递归，因为我们观察的只能是对象，而不能是数字、字符串或者数组（数组的观察比较特殊，事实上是重构了方法来触发更新，后面会讲到）。那我们接下来看下Dep类是做什么用的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\nvar Dep = function Dep () {\n  this.id = uid$1\x2b\x2b;\n  this.subs = [];\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Dep = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x2b\x2b;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = [];\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注释里告诉我们Dep类是一个会被多个指令订阅的可被观察的对象，这里的指令就是我们在html代码里书写的东西，如\x3ccode\x3e:class={active: hasActive}\x3c\/code\x3e或\x3ccode\x3e\x22{{\x22 count \x22}}\x22 \x22{{\x22 count * price \x22}}\x22\x3c\/code\x3e，而他们就会订阅\x3ccode\x3ehasActive\/count\/price\x3c\/code\x3e这些对象，而这些订阅他们的对象就会被放置在\x3ccode\x3eDep.subs\x3c\/code\x3e列表中。每一次新建Dep对象，就会全局uid递增，然后传给该Dep对象，保证唯一性id。\x3cbr\x3e我们接着看刚才的walk函数做了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Walk through each property and convert them into\n * getter\/setters. This method should only be called when\n * value type is Object.\n *\/\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i \x3c keys.length; i\x2b\x2b) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs q\x22\x3e\x3ccode\x3e\/**\n * Walk through \x3cspan class=\x22hljs-built_in\x22\x3eeach\x3c\/span\x3e property \x3cspan class=\x22hljs-built_in\x22\x3eand\x3c\/span\x3e convert them into\n * getter\/setters. This method should only be called when\n * \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e is Object.\n *\/\nObserver.prototype.walk = function walk (obj) {\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e = Object.\x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e(obj);\n  for (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e.length; i\x2b\x2b) {\n    defineReactive$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e(obj, \x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e[i], obj[\x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e[i]]);\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看来和名字一样，它只是走了一遍，那我们来看下\x3ccode\x3edefineReactive$$1\x3c\/code\x3e做了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Define a reactive property on an Object.\n *\/\nfunction defineReactive$$1 (obj, key, val, customSetter) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property \x26amp;\x26amp; property.configurable === false) {\n    return\n  }\n\n  \/\/ cater for pre-defined getter\/setters\n  var getter = property \x26amp;\x26amp; property.get;\n  var setter = property \x26amp;\x26amp; property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      \/\/ 脏检查，排除了NaN !== NaN的影响\n      if (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        return\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Define a reactive property on an Object.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive$$1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, key, val, customSetter\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep();\n\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x3c\/span\x3e= \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(obj, key);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x26amp;\x26amp; property.configurable \x3c\/span\x3e=== \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cater for pre-defined getter\/setters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e getter = \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x26amp;\x26amp; property.get\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e setter = \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x26amp;\x26amp; property.set\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e childOb = observe(val);\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    \x3cspan class=\x22hljs-attribute\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e value = getter ? getter.call(obj) : val;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n        dep.depend();\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n          childOb.dep.depend();\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n    },\n    \x3cspan class=\x22hljs-attribute\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e value = getter ? getter.call(obj) : val;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 脏检查，排除了NaN !== NaN的影响\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n        setter.call(obj, newVal);\n      } \x3cspan class=\x22hljs-title\x22\x3eelse\x3c\/span\x3e {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e终于找到重头戏了，这里真正使用了\x3ccode\x3egetter\/setter\x3c\/code\x3e代理了对象的默认读写。我们首先新建一个Dep对象，利用闭包准备收集依赖，然后我们使用observe观察该对象，注意此时与上面相比少了一个\x3ccode\x3easRootData = true\x3c\/code\x3e的参数。\x3cbr\x3e我们先来看取值的代理get，这里用到了\x3ccode\x3eDep.target属性和depend()方法\x3c\/code\x3e，我们来看看它是做什么的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ the current target watcher being evaluated.\n\/\/ this is globally unique because there could be only one\n\/\/ watcher being evaluated at any time.\nDep.target = null;\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  \/\/ stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i \x3c l; i\x2b\x2b) {\n    subs[i].update();\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the current target watcher being evaluated.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is globally unique because there could be only one\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ watcher being evaluated at any time.\x3c\/span\x3e\nDep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\nDep.prototype.depend = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edepend\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n    Dep.target.addDep(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n};\n\nDep.prototype.notify = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enotify\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stablize the subscriber list first\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e subs = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.slice();\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = subs.length; i \x26lt; l; i\x2b\x2b) {\n    subs[i].update();\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注释看的出来\x3ccode\x3eDep.target\x3c\/code\x3e是全局唯一的\x3ccode\x3ewatcher\x3c\/code\x3e对象，也就是当前正在指令计算的订阅者，它会在计算时赋值成一个watcher对象，计算完成后赋值为null。而\x3ccode\x3edepend\x3c\/code\x3e是用于对该订阅者添加依赖，告诉它你的值依赖于我，每次更新时应该来找我。另外还有\x3ccode\x3enotify()\x3c\/code\x3e的函数，用于遍历所有的依赖，通知他们更新数据。这里多看一下\x3ccode\x3eaddDep()\x3c\/code\x3e的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Add a dependency to this directive.\n *\/\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      \/\/ 使用push()方法添加一个订阅者\n      dep.addSub(this);\n    }\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Add a dependency to this directive.\n *\/\x3c\/span\x3e\nWatcher.prototype.addDep = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddDep\x3c\/span\x3e \x3c\/span\x3e(dep) {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e id = dep.id;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eDepIds\x3c\/span\x3e.has(id)) {\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eDepIds\x3c\/span\x3e.add(id);\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eDeps\x3c\/span\x3e.push(dep);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.depIds.has(id)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用push()方法添加一个订阅者\x3c\/span\x3e\n      dep.addSub(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e);\n    }\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到它有去重的机制，当重复依赖时保证相同ID的依赖只有一个。订阅者包含3个属性\x3ccode\x3enewDepIds\/newDeps\/depIds\x3c\/code\x3e分别存储依赖信息，如果之前就有了这个依赖，那么反过来将该订阅者加入到这个依赖关系中去。\x3cbr\x3e接着看get方法中的\x3ccode\x3edependArray()\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n *\/\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i \x3c l; i\x2b\x2b) {\n    e = value[i];\n    e \x26amp;\x26amp; e.__ob__ \x26amp;\x26amp; e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3e\/**\n * Collect dependencies on\x3cspan class=\x22hljs-built_in\x22\x3e array \x3c\/span\x3eelements when the\x3cspan class=\x22hljs-built_in\x22\x3e array \x3c\/span\x3eis touched, since\n * we cannot intercept\x3cspan class=\x22hljs-built_in\x22\x3e array \x3c\/span\x3eelement access like property getters.\n *\/\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i \x26lt; l; i\x2b\x2b) {\n    e = value[i];\n    e \x26amp;\x26amp; e.__ob__ \x26amp;\x26amp; e.__ob__.dep.depend();\n   \x3cspan class=\x22hljs-built_in\x22\x3e if \x3c\/span\x3e(Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到我们不能像对象一样监听数组的变化，所以如果获取一个数组的值，那么就需要将数组中所有的对象的观察者列表都加入到依赖中去。\x3cbr\x3e这样get方法读取值就代理完成了，接下来我们看set方法代理赋值的实现，我们先获取原始值，然后与新赋的值进行比较，也叫脏检查，如果数据发生了改变，则对该数据进行重新建立观察者，并通知所有的订阅者更新。\x3cbr\x3e接下来我们看下数组的更新检测是如何实现的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n[\x27push\x27, \x27pop\x27, \x27shift\x27, \x27unshift\x27, \x27splice\x27, \x27sort\x27, \x27reverse\x27].forEach(function (method) {\n  \/\/ cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n    \/\/ avoid leaking arguments:\n    \/\/ http:\/\/jsperf.com\/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case \x27push\x27:\n        inserted = args;\n        break\n      case \x27unshift\x27:\n        inserted = args;\n        break\n      case \x27splice\x27:\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    \/\/ notify change\n    ob.dep.notify();\n    return result\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arrayProto = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arrayMethods = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(arrayProto);\n[\x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27pop\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27shift\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27sort\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27reverse\x27\x3c\/span\x3e].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e original = arrayProto[method];\n  def(arrayMethods, method, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emutator\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoid leaking arguments:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/jsperf.com\/closure-with-arguments\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(i);\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      args[i] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e[i];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = original.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__ob__;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inserted;\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (method) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e:\n        inserted = args;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e:\n        inserted = args;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e:\n        inserted = args.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inserted) { ob.observeArray(inserted); }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ notify change\x3c\/span\x3e\n    ob.dep.notify();\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看的出来我们模拟了一个数组对象，代理了\x3ccode\x3epush\/pop\/shift\/unshift\/splice\/sort\/reverse\x3c\/code\x3e方法，用于检测数组的变化，并通知所有订阅者更新。如果有新建元素，会补充监听新对象。\x3cbr\x3e这就是从代码上解释为什么Vue不支持数组下标修改和长度修改的原因，至于为什么这么设计，我后面会再次更新或再开篇文章，讲一些通用的设计问题以及Js机制和缺陷。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e从上面的代码中我们可以一步步由深到浅的看到Vue是如何设计出双向数据绑定的，最主要的两点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用\x3ccode\x3egetter\/setter\x3c\/code\x3e代理值的读取和赋值，使得我们可以控制数据的流向。\x3c\/li\x3e\n\x3cli\x3e使用\x3ccode\x3e观察者模式\x3c\/code\x3e设计，实现了指令和数据的依赖关系以及触发更新。\x3c\/li\x3e\n\x3cli\x3e对于数组，\x3ccode\x3e代理\x3c\/code\x3e会修改原数组对象的方法，并触发更新。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e明白了这些原理，其实你也可以实现一个简单的数据绑定，造一个小轮子，当然，Vue的强大之处不止于此，我们后面再来聊一聊它的组件和渲染，看它是怎么一步一步将我们从DOM对象的魔爪里拯救出来的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e参考资料\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e数据的响应化：\x3ca href=\x22https:\/\/github.com\/Ma63d\/vue-analysis\/issues\/1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/Ma63d\/vue-...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eVue v2.2.0 源代码文件\x3c\/li\x3e\n\x3cli\x3ees6 Proxy: \x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/proxy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/es6.ruanyifeng.com\/#do...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>源码分析：Vue的双向数据绑定</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011328301">https://segmentfault.com/a/1190000011328301</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/2a9ostt2ahq/" target="_blank">https://alili.tech/archive/2a9ostt2ahq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>