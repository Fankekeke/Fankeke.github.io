<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Minimax 和 Alpha-beta 剪枝算法简介，以及以此实现的井字棋游戏（Tic-tac-toe）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Minimax 和 Alpha-beta 剪枝算法简介，以及以此实现的井字棋游戏（Tic-tac-toe） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/2c112r9xhpx/",
				"appid": "1613049289050283", 
				"title": "Minimax 和 Alpha-beta 剪枝算法简介，以及以此实现的井字棋游戏（Tic-tac-toe） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-12T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/reh3526t4nk/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/kp2qv59svej/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&text=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&text=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&title=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&is_video=false&description=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&title=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&title=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&title=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2c112r9xhpx%2f&title=Minimax%20%e5%92%8c%20Alpha-beta%20%e5%89%aa%e6%9e%9d%e7%ae%97%e6%b3%95%e7%ae%80%e4%bb%8b%ef%bc%8c%e4%bb%a5%e5%8f%8a%e4%bb%a5%e6%ad%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%ba%95%e5%ad%97%e6%a3%8b%e6%b8%b8%e6%88%8f%ef%bc%88Tic-tac-toe%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Minimax 和 Alpha-beta 剪枝算法简介，以及以此实现的井字棋游戏（Tic-tac-toe）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-12" itemprop="datePublished">2018-12-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e前段时间用 React 写了个\x3ca href=\x22https:\/\/github.com\/noiron\/react-2048\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2048 游戏\x3c\/a\x3e来练练手，准备用来回顾下 React 相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个 AI 算法来自动进行游戏，于是我找到了这篇文章：\x3ca href=\x22http:\/\/blog.codinglabs.org\/articles\/2048-ai-analysis.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2048-AI程序算法分析\x3c\/a\x3e，文中介绍了 minimax 算法和 alpha-beta 剪枝算法。于是我决定先学习下这两种算法，并以此写了这个 tic-tac-toe 游戏：\x3ca href=\x22https:\/\/tic-tac-toe-js-app.herokuapp.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etic-tac-toe-js\x3c\/a\x3e（\x3ca href=\x22https:\/\/github.com\/noiron\/tic-tac-toe-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e代码见此处\x3c\/a\x3e）。本文将说明如何用 JavaScript 来简单地实现算法，并将其运用到 tic-tac-toe 游戏中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eMinimax 算法简介\x3c\/h2\x3e\n\x3cp\x3e我觉得要解释 minimax 算法的原理，需要用示意图来解释更清晰，以下的几篇文章都对原理说的足够清楚。\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.codinglabs.org\/articles\/2048-ai-analysis.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2048-AI程序算法分析\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.neverstopbuilding.com\/blog\/2013\/12\/13\/tic-tac-toe-understanding-the-minimax-algorithm13\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTic Tac Toe: Understanding the Minimax Algorithm\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.flyingmachinestudios.com\/programming\/minimax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAn Exhaustive Explanation of Minimax, a Staple AI Algorithm\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cp\x3e其中后面的两篇文章都是以 tic-tac-toe 游戏为例，并用 Ruby 实现。\x3c\/p\x3e\n\x3cp\x3e以棋类游戏为例来说明 minimax 算法，每一个棋盘的状态都会对应一个分数。双方将会轮流下棋。轮到我方下子时，我会选择分数最高的状态；而对方会选择对我最不利的状态。可以这么认为，每次我都需要从对手给我选择的最差（min）局面中选出最好（max）的一个，这就是这个算法名称 \x3cstrong\x3eminimax\x3c\/strong\x3e 的意义。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4Vis?w=813\x26amp;h=495\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4Vis?w=813\x26amp;h=495\x22 alt=\x22minimax tree\x22 title=\x22minimax tree\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e（图片来自于 \x3ca href=\x22http:\/\/web.cs.ucla.edu\/~rosen\/161\/notes\/alphabeta.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/web.cs.ucla.edu\/~rosen...\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e我们接下来会解决这样一个问题，如上图所示，正方形的节点对应于我的决策，圆形的节点是对手的决策。双方轮流选择一个分支，我的目标是让最后选出的数字尽可能大，对方的目标是让这个数字尽可能小。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eMinimax 算法的实现\x3c\/h2\x3e\n\x3cp\x3e为了简单起见，对于这个特定的问题，我用了一个嵌套的数组来表示状态树。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const dataTree = [\n    [\n        [\n            [3, 17], [2, 12]\n        ],\n        [\n            [15], [25, 0]\n        ]\n    ],\n    [\n        [\n            [2, 5], [3]\n        ],\n        [\n            [2, 14]\n        ]\n    ]\n];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dataTree = [\n    [\n        [\n            [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e], [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e]\n        ],\n        [\n            [\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e], [\x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n        ]\n    ],\n    [\n        [\n            [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e], [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n        ],\n        [\n            [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e14\x3c\/span\x3e]\n        ]\n    ]\n];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e图中的节点分为两种类型：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cstrong\x3eMax 节点\x3c\/strong\x3e：图中的正方形节点，对应于我的回合，它会选取所有子节点中的最大值作为自身的值\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eMin 节点\x3c\/strong\x3e：图中的圆形节点，对应于对手的回合，它会选取所有子节点中的最小值作为自身的值\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e先定义一个 \x3ccode\x3eNode\x3c\/code\x3e 类，\x3ccode\x3econstructor\x3c\/code\x3e 如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(data, type, depth) {\n    this.data = data;\n    this.type = type; \/\/ 区分此节点的种类是 max 或 min\n    this.depth = depth;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(data, type, depth) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 区分此节点的种类是 max 或 min\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth = depth;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根节点的 \x3ccode\x3edepth\x3c\/code\x3e 为0，以下的每一层 \x3ccode\x3edepth\x3c\/code\x3e 依次加一。最底层的节点 \x3ccode\x3edepth\x3c\/code\x3e 为4，其 \x3ccode\x3edata\x3c\/code\x3e 是写在图中的数字，其它层节点的 \x3ccode\x3edata\x3c\/code\x3e 均是一个数组。\x3c\/p\x3e\n\x3cp\x3e接下来考虑如何给每个节点打分，可能会出现这样的几种情况：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e最底层的节点，直接返回本身的数字\x3c\/li\x3e\n\x3cli\x3e中间层的 max 节点，返回子节点中的最大分数\x3c\/li\x3e\n\x3cli\x3e中间层的 min 节点，返回子节点中的最小分数\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e为方便描述，我们按照由上到下、由左到右的顺序给图中节点进行标号。节点1是 max 节点，从节点2和节点3中选择较大值；而对于节点2来说，需要从节点4，5中选取较小值。很显然，我们这里要用递归的方法来实现，当搜索到最底层的节点时，递归过程开始返回。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4ViB?w=813\x26amp;h=495\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4ViB?w=813\x26amp;h=495\x22 alt=\x22minimax tree mark\x22 title=\x22minimax tree mark\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e以下是打分函数 \x3ccode\x3escore\x3c\/code\x3e 的具体代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22score() {\n    \/\/ 到达了最大深度后，此时的 data 是数组最内层的数字\n    if (this.depth \x3e= 4) {\n        return this.data;\n    }\n\n    \/\/ 对于 max 节点，返回的是子节点中的最大值\n    if (this.type === \x27max\x27) {\n        let maxScore = -1000;\n\n        for (let i = 0; i \x3c this.data.length; i\x2b\x2b) {\n            const d = this.data[i];\n            \/\/ 生成新的节点，子节点的 type 会和父节点不同\n            const childNode = new Node(d, changeType(this.type), this.depth \x2b 1);\n            \/\/ 递归获取其分数\n            const childScore = childNode.score();\n\n            if (childScore \x3e maxScore) {\n                maxScore = childScore;\n            }\n        }\n\n        return maxScore;\n    }\n\n    \/\/ 对于 min 节点，返回的是子节点中的最小值\n    else if (this.type === \x27min\x27) {\n        \/\/ 与上方代码相似，省略部分代码\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3escore() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 到达了最大深度后，此时的 data 是数组最内层的数字\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于 max 节点，返回的是子节点中的最大值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type === \x3cspan class=\x22hljs-string\x22\x3e\x27max\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e maxScore = \x3cspan class=\x22hljs-number\x22\x3e-1000\x3c\/span\x3e;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.length; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e d = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data[i];\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成新的节点，子节点的 type 会和父节点不同\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childNode = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(d, changeType(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 递归获取其分数\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childScore = childNode.score();\n\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childScore \x26gt; maxScore) {\n                maxScore = childScore;\n            }\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e maxScore;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于 min 节点，返回的是子节点中的最小值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type === \x3cspan class=\x22hljs-string\x22\x3e\x27min\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 与上方代码相似，省略部分代码\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3ca href=\x22https:\/\/github.com\/noiron\/tic-tac-toe-js\/blob\/master\/algorithms\/minimax.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整的 minimax 算法代码\x3c\/a\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eAlpha-beta 剪枝算法简介\x3c\/h2\x3e\n\x3cp\x3eAlpha-beta 剪枝算法可以认为是 minimax 算法的一种改进，在实际的问题中，需要搜索的状态数量将会非常庞大，利用 alpha-beta 剪枝算法可以去除一些不必要的搜索。\x3c\/p\x3e\n\x3cp\x3e关于 alpha-beta 算法的具体解释可以看这篇文章 \x3ca href=\x22http:\/\/web.cs.ucla.edu\/~rosen\/161\/notes\/alphabeta.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMinimax with Alpha Beta Pruning\x3c\/a\x3e。我们在前文中考虑的那张图就来自这篇文章，之后我们会用 alpha-beta 剪枝算法来改进之前的解决方案。\x3c\/p\x3e\n\x3cp\x3e剪枝算法中主要有这么些概念：\x3c\/p\x3e\n\x3cp\x3e每一个节点都会由 alpha 和 beta 两个值来确定一个范围 [alpha, beta]，alpha 值代表的是下界，beta 代表的是上界。每搜索一个子节点，都会按规则对范围进行修正。\x3c\/p\x3e\n\x3cp\x3eMax 节点可以修改 alpha 值，min 节点修改 beta 值。\x3c\/p\x3e\n\x3cp\x3e如果出现了 beta \x26lt;= alpha 的情况，则不用搜索更多的子树了，未搜索的这部分子树将被忽略，这个操作就被称作\x3cstrong\x3e剪枝（pruning）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e接下来我会尽量说明为什么剪枝这个操作是合理的，省略了一部分节点为什么不会对结果产生影响。用原图中以4号节点（第三层的第一个节点）为根节点的子树来举例，方便描述这里将他们用 A - G 的字母来重新标记。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4Vjd?w=544\x26amp;h=419\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4Vjd?w=544\x26amp;h=419\x22 alt=\x22子树\x22 title=\x22子树\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从 B 节点看起，B 是 min 节点，需要在 D 和 E 中寻找较小值，因此 B 取值为3，同时 B 的 beta 值也设置为 3。假设 B 还有更多值大于3的子节点，但因为已经出现了 D 这个最小值，所以不会对 B 产生影响，即这里的 beta = 3 确定了一个上界。\x3c\/p\x3e\n\x3cp\x3e.A 是 max 节点，需要在 B 和 C 中找到较大值，因为子树 B 已经搜索完毕，B 的值确定为 3，所以 A 的值至少为 3，这样确定了 A 的下界 alpha = 3。在搜索 C 子树之前，我们\x3cstrong\x3e希望 C 的值大于3\x3c\/strong\x3e，这样才会对 A 的下界 alpha 产生影响。于是 C 从 A 这里获得了下界 alpha = 3 这个限制条件。\x3c\/p\x3e\n\x3cp\x3e.C 是 min 节点，要从 F 和 G 里找出较小值。F 的值为2，所以 C 的值一定小于等于 2，更新 C 的上界 beta = 2。此时 C 的 alpha = 3, beta = 2，这是一个空区间，也就是说即使继续考虑 C 的其它子节点， 也\x3cstrong\x3e不可能让 C 的值大于 3\x3c\/strong\x3e，所以我们不必再考虑 G 节点。G 节点就是被剪枝的节点。\x3c\/p\x3e\n\x3cp\x3e重复这样的过程，会有更多的节点因为剪枝操作被忽略，从而对 minimax 算法进行了优化。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eAlpha-beta 剪枝算法的实现\x3c\/h2\x3e\n\x3cp\x3e接下来讨论如何修改前面实现的 minimax 算法，使其变为 alpha-beta 剪枝算法。\x3c\/p\x3e\n\x3cp\x3e第一步在 constructor 中加入两个新属性，alpha、beta。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(data, type, depth, alpha, beta) {\n    this.data = data;\n    this.type = type; \/\/ 区分此节点的种类是 max 或 min\n    this.depth = depth;\n\n    this.alpha = alpha || -Infinity;\n    this.beta = beta || Infinity;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(data, type, depth, alpha, beta) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 区分此节点的种类是 max 或 min\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth = depth;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha = alpha || -\x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beta = beta || \x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后每次都搜索会视情况更新 alpha, beta 的值，以下的代码片段来自于搜索 max 节点的过程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ alphabeta.js 中的 score() 函数\n\nfor (let i = 0; i \x3c this.data.length; i\x2b\x2b) {\n    \/\/ ...\n\n    if (childScore \x3e maxScore) {\n        maxScore = childScore;\n        \/\/ 相对于 minimax 算法，alpha-beta 剪枝算法在这里增加了一个更新 alpha 值的操作\n        this.alpha = maxScore;\n    }\n\n    \/\/ 如果满足了退出的条件，我们不需要继续搜索更多的节点了，退出循环\n    if (this.alpha \x3e= this.beta) {\n        break;\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ alphabeta.js 中的 score() 函数\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childScore \x26gt; maxScore) {\n        maxScore = childScore;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相对于 minimax 算法，alpha-beta 剪枝算法在这里增加了一个更新 alpha 值的操作\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha = maxScore;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果满足了退出的条件，我们不需要继续搜索更多的节点了，退出循环\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha \x26gt;= \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beta) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相对应的是在 min 节点中，我们更新的将是 beta 值。好了，只需要做这么些简单的改变，就将 minimax 算法改变成了 alpha-beta 剪枝算法了。\x3c\/p\x3e\n\x3cp\x3e最后看看如何将算法应用到 tic-tac-toe 游戏中。\x3c\/p\x3e\n\x3cblockquote\x3e\x3ca href=\x22https:\/\/github.com\/noiron\/tic-tac-toe-js\/blob\/master\/algorithms\/alphabeta.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整的 alpha-beta 剪枝算法代码\x3c\/a\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eTic-tac-toe 游戏中的应用\x3c\/h2\x3e\n\x3cp\x3eTic-tac-toe，即井字棋游戏，规则是在双方轮流在 3x3 的棋盘上的任意位置下子，率先将三子连成一线的一方获胜。\x3c\/p\x3e\n\x3cp\x3e这就是一个非常适合用 minimax 来解决的问题，即使在不考虑对称的情况，所有的游戏状态也只有 9! = 362880 种，相比于其它棋类游戏天文数字般的状态数量已经很少了，因而很适合作为算法的示例。\x3c\/p\x3e\n\x3cp\x3e我在代码中将棋盘的状态用一个长度为9的数组来表示，然后利用 canvas 绘制出一个简易的棋盘，下子的过程就是修改数组的对应位置然后重绘画面。\x3c\/p\x3e\n\x3cp\x3e现在我们已经有了现成的 minimax 和 alpha-beta 剪枝算法，只要加上一点儿细节就能完成这个游戏了?。\x3c\/p\x3e\n\x3cp\x3e先来定义一个 \x3ccode\x3eGameState\x3c\/code\x3e 类，其中保存了游戏的状态，对应于之前分析过程中的节点，其 \x3ccode\x3econstructor\x3c\/code\x3e 如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(board, player, depth, alpha, beta) {\n    this.board = board;\n    \/\/ player 是用字符 X 和 O 来标记当前由谁下子，以此来判断当前是 max 还是 min 节点\n    this.playerTurn = player;\n    this.depth = depth;\n\n    \/\/ 保存分数最高或最低的状态，用于确定下一步的棋盘状态\n    this.choosenState = null;\n    this.alpha = alpha || -Infinity;\n    this.beta = beta || Infinity;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(board, player, depth, alpha, beta) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.board = board;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ player 是用字符 X 和 O 来标记当前由谁下子，以此来判断当前是 max 还是 min 节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.playerTurn = player;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth = depth;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存分数最高或最低的状态，用于确定下一步的棋盘状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.choosenState = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha = alpha || -\x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beta = beta || \x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为进行游戏，首先需要一个 \x3ccode\x3echeckFinish\x3c\/code\x3e 函数，检查游戏是否结束，结束时返回胜利者信息。搜索的过程是在 \x3ccode\x3egetScore\x3c\/code\x3e 函数中完成的，每次搜索先检查游戏是否结束，平局返回零分，我们的算法是站在 AI 的角度来考虑的，因此 AI 胜利时返回10分，AI 失利时返回-10分。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ alphabeta.js 中的 getScore() 方法\n\nconst winner = this.checkFinish();\nif (winner) {\n    if (winner === \x27draw\x27) return 0;\n    if (winner === aiToken) return 10;\n    return -10;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ alphabeta.js 中的 getScore() 方法\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e winner = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.checkFinish();\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (winner) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (winner === \x3cspan class=\x22hljs-string\x22\x3e\x27draw\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (winner === aiToken) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-10\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着是对 max 和 min 节点的分类处理：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ alphabeta.js 中的 getScore() 方法\n\n\/\/ 获得所有可能的位置，利用 shuffle 加入随机性\nconst availablePos = _.shuffle(this.getAvailablePos());\n\n\/\/ 对于 max 节点，返回的是子节点中的最大值\nif (this.playerTurn === aiToken) {\n    let maxScore = -1000;\n    let maxIndex = 0;\n\n    for (let i = 0; i \x3c availablePos.length; i\x2b\x2b) {\n        const pos = availablePos[i];\n        \/\/ 在给定的位置下子，生成一个新的棋盘\n        const newBoard = this.generateNewBoard(pos, this.playerTurn);\n\n        \/\/ 生成一个新的节点\n        const childState = new GameState(newBoard, changeTurn(this.playerTurn), this.depth \x2b 1, this.alpha, this.beta);\n        \/\/ 这里开始递归调用 getScore() 函数\n        const childScore = childState.getScore();\n\n        if (childScore \x3e maxScore) {\n            maxScore = childScore;\n            maxIndex = i;\n            \/\/ 这里保存产生了最大的分数的节点，之后会被用于进行下一步\n            this.choosenState = childState;\n            this.alpha = maxScore;\n        }\n\n        if (this.alpha \x3e= this.beta) {\n            break;\n        }\n    }\n\n    return maxScore;\n}\n\n\/\/ min 节点的处理与上面类似\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ alphabeta.js 中的 getScore() 方法\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获得所有可能的位置，利用 shuffle 加入随机性\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e availablePos = _.shuffle(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getAvailablePos());\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于 max 节点，返回的是子节点中的最大值\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.playerTurn === aiToken) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e maxScore = \x3cspan class=\x22hljs-number\x22\x3e-1000\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e maxIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; availablePos.length; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pos = availablePos[i];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在给定的位置下子，生成一个新的棋盘\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newBoard = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.generateNewBoard(pos, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.playerTurn);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成一个新的节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childState = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e GameState(newBoard, changeTurn(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.playerTurn), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depth \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beta);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里开始递归调用 getScore() 函数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childScore = childState.getScore();\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childScore \x26gt; maxScore) {\n            maxScore = childScore;\n            maxIndex = i;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里保存产生了最大的分数的节点，之后会被用于进行下一步\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.choosenState = childState;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha = maxScore;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alpha \x26gt;= \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beta) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e maxScore;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ min 节点的处理与上面类似\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e完整代码见\x3ca href=\x22https:\/\/github.com\/noiron\/tic-tac-toe-js\/blob\/master\/src\/alphabeta.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ealphabeta.js\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e这样就简单地介绍了 minimax 算法和 alpha-beta 算法，并分别给出了一个简单的实现，然后在 tic-tac-toe 游戏中应用了算法。\x3c\/p\x3e\n\x3cp\x3e文章中所提到的所有代码可见此项目：\x3ca href=\x22https:\/\/github.com\/noiron\/tic-tac-toe-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTic-tac-toe-js\x3c\/a\x3e。其中的 \x3ccode\x3ealgorithms\x3c\/code\x3e 文件夹中是两种算法的简单实现，\x3ccode\x3esrc\x3c\/code\x3e 文件中是游戏的代码。\x3c\/p\x3e\n\x3cp\x3e文章开头说到了这篇文章起源于写2048游戏项目的过程中，之后我将 minimax 算法应用到了2048游戏的 AI 中，不过对于局面的评估函数尚不完善，现在 AI 只能勉强合成1024?， 还有很大的改进空间。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.wukai.me\/2018\/03\/04\/minimax-alpha-beta-pruning-and-tic-tac-toe\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e本文原链接\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Minimax 和 Alpha-beta 剪枝算法简介，以及以此实现的井字棋游戏（Tic-tac-toe）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013527949">https://segmentfault.com/a/1190000013527949</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/2c112r9xhpx/" target="_blank">https://alili.tech/archive/2c112r9xhpx/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>