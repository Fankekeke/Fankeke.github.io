<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="缓存 React 事件监听器来提高性能"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>缓存 React 事件监听器来提高性能 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/2e3f8879/",
				"appid": "1613049289050283", 
				"title": "缓存 React 事件监听器来提高性能 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-19T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/71780e3d/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c7e93bce/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&text=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&text=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&title=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&is_video=false&description=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&title=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&title=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&title=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2e3f8879%2f&title=%e7%bc%93%e5%ad%98%20React%20%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">缓存 React 事件监听器来提高性能</h1><div class="meta"><div class="postdate"><time datetime="2018-10-19" itemprop="datePublished">2018-10-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e\x3cimg src=\x22https:\/\/p5.ssl.qhimg.com\/t01786d1b810e4a8256.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e在 js 里面有个不被重视的概念：对象和函数的引用，而这个却直接地影响了 React 的性能。如果你打算创建两个相同的函数，但是却又不相等。你可以试着：（译者注：无法在markdown中插入代码，请查看原文代码！） \x3ccode\x3econst functionOne = function() { alert(\x27Hello world!\x27); }; const functionTwo = function() { alert(\x27Hello world!\x27); }; functionOne === functionTwo; \/\/ false\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果将一个变量指向一个已经存在的函数，看看它们的不同: \x3ccode\x3econst functionThree = function() { alert(\x27Hello world!\x27); }; const functionFour = functionThree; functionThree === functionFour; \/\/ true`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e对象也是这样的。 \x3ccode\x3econst object1 = {}; const object2 = {}; const object3 = object1; object1 === object2; \/\/ false object1 === object3; \/\/ true\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果你学过其他语言，可能会熟悉指针。每次你创建对象的时候，你都会为其分配设备内存。当声明 \x3ccode\x3eoject1 = {}\x3c\/code\x3e 的时候，将会在用户的 RAM 中创建一串字节给到 \x3ccode\x3eobject1\x3c\/code\x3e。可想而知，\x3ccode\x3eobject1\x3c\/code\x3e 就是一个保存了键值对存放在 RAM 的地址。而声明 \x3ccode\x3eobject2 = {}\x3c\/code\x3e，将会在 RAM 中创建另外一串不同的字节给到\x3ccode\x3eobject2\x3c\/code\x3e。\x3ccode\x3eobject\x3c\/code\x3e上地址和\x3ccode\x3eobject2\x3c\/code\x3e 的一样吗？不是的。这也为什么这两个变量的是不相等。他们的键值对可能会完全相同，但是他们在内存中的地址是不一样的，这才是会被比较的地方。\x3c\/p\x3e\n\x3cp\x3e若使得\x3ccode\x3eobject3 = object1\x3c\/code\x3e，会让\x3ccode\x3eobject3\x3c\/code\x3e的值为\x3ccode\x3eobject1\x3c\/code\x3e的地址。这不是一个新的对象。内存中的位置是一样的。可以如下验证： \x3ccode\x3econst object1 = { x: true }; const object3 = object1; object3.x = false; object1.x; \/\/ false\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这个例子里，在内存中创建对象并指向\x3ccode\x3eobject1\x3c\/code\x3e。让后让\x3ccode\x3eobject3\x3c\/code\x3e等于同样的内存地址。通过修改\x3ccode\x3eobject3\x3c\/code\x3e，可以改变对应内存中的值，这也意味着所有指向该内存的变量都会被修改。\x3ccode\x3eobect1\x3c\/code\x3e，仍指向该内存，所以值也被改变了。\x3c\/p\x3e\n\x3cp\x3e初级工程师会犯这种非常常见的错误，并且需要深入学习相关教程；只是本文是讨论 React 性能的，甚至是对变量引用有较深资历的开发者也可能需要学习。\x3c\/p\x3e\n\x3cp\x3e这个和 React 有什么关系呢？React 有个节省执行时间的聪明方式，可以优化性能：如果组件的 props 和 state 都没有变化，render 的输出必然也是没有变化的。很清晰的，如果所有的都一样，那就意味着没有变化。如果没有变化，\x3ccode\x3erender\x3c\/code\x3e 必须返回相同的输出，就不用执行了。这使得 React 更加快速，按需渲染。\x3c\/p\x3e\n\x3cp\x3eReact 采用和 JavaScript 一样的方式，通过简单的 \x3ccode\x3e==\x3c\/code\x3e 操作符来判断 props 和 state 是否有变化。React 不会深入比较对象是否相等。深对比是对比对象的每一个键值对，而不是对比内存地址。React 处理方式就是浅对比，仅仅是对比一下引用是否相同而已。\x3c\/p\x3e\n\x3cp\x3e如若将组件的 prop 从 \x3ccode\x3e{ x: 1 }\x3c\/code\x3e 改为另外一个 \x3ccode\x3e{ x: 1 }\x3c\/code\x3e，React 将会重新渲染，因为这两个对象在内存上有不用的引用。如果只是将组件的 prop 从上文中的 \x3ccode\x3eobject1\x3c\/code\x3e 改为 \x3ccode\x3eobject3\x3c\/code\x3e ，React 是不会重新渲染的，应为这两个对象是同一个引用。\x3c\/p\x3e\n\x3cp\x3e在 Javascript，函数也是同样的处理方式。如果 React 接收到不同内存地址而功能相同的函数，React 也会重新渲染。如果 React 接收到相同函数的引用，就会不重新渲染。\x3c\/p\x3e\n\x3cp\x3e在代码审核的时候，我就遇到下面这种常见误用的场景 \x3ccode\x3eclass SomeComponent extends React.PureComponent { get instructions() { if (this.props.do) { return \x27Click the button: \x27; } return \x27Do NOT click the button: \x27; } render() { return ( \x26lt;div\x26gt; {this.instructions} \x26lt;Button onClick={() =\x26amp;gt; alert(\x27!\x27)} \/\x26gt;\x26lt;\/div\x26gt; ); } }\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这是非常直接的一个组件。当按钮被点击的时候，就 alert。instructions 用来表示是否点击了按钮。而 SomeComponent 的 prop 的 \x3ccode\x3edo={true}\x3c\/code\x3e 或 \x3ccode\x3edo={false}\x3c\/code\x3e 决定了 instructions。\x3c\/p\x3e\n\x3cp\x3e这里有问题的是，当 \x3ccode\x3eSomeComponent\x3c\/code\x3e 重新渲染的时候（例如 do 属性从 true 切换到 false），\x3ccode\x3eButton\x3c\/code\x3e 也会重新渲染！尽管每次这个\x3ccode\x3eonClick\x3c\/code\x3e方法都是相同的，但是每次渲染都会被重新创建。每次渲染都会在内存中创建新的函数（因为会在 render 函数里重新创建），一个指向新内存地址的引用被传递到 \x3ccode\x3e\x26amp;lt;Button \/\x26amp;gt;\x3c\/code\x3e，虽然输入完全没有变化，该 \x3ccode\x3eButton\x3c\/code\x3e 组件还是会重新渲染。\x3c\/p\x3e\n\x3ch3\x3e修改\x3c\/h3\x3e\n\x3cp\x3e如果函数不依赖于组件（不是 \x3ccode\x3ethis\x3c\/code\x3e 上下文），你可以在组件的外部定义它。所有的组件实例都会用到相同的引用，因为都是同一个函数。 \x3ccode\x3econst createAlertBox = () =\x26gt; alert(\x27!\x27); class SomeComponent extends React.PureComponent { get instructions() { if (this.props.do) { return \x27Click the button: \x27; } return \x27Do NOT click the button: \x27; } render() { return ( \x26lt;div\x26gt; {this.instructions} \x26lt;Button onClick={createAlertBox} \/\x26gt; \x26lt;\/div\x26gt; ); } }\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e和前面的例子相反，\x3ccode\x3ecreateAlertBox\x3c\/code\x3e 在每次渲染中仍然有着有相同的引用。因此按钮就不会重新渲染了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eButton\x3c\/code\x3e 就像一个又小又快速渲染的组件，你可能在大型、复杂、渲染速度慢的组件里面看到这些行内的定义，在 React 应用里面真的会有很多很多。最好不要在渲染方法里面定义这些函数。\x3c\/p\x3e\n\x3cp\x3e如果函数确实依赖于组件，使得你不能在组件外部定义，你可以将组件的方法作为事件处理传递过去。 \x3ccode\x3eclass SomeComponent extends React.PureComponent { createAlertBox = () =\x26gt; { alert(this.props.message); }; get instructions() { if (this.props.do) { return \x27Click the button: \x27; } return \x27Do NOT click the button: \x27; } render() { return ( \x26lt;div\x26gt; {this.instructions} \x26lt;Button onClick={this.createAlertBox} \/\x26gt;; \x26lt;\/div\x26gt; ); } }\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e在本例中，每个\x3ccode\x3eSomeComponent\x3c\/code\x3e的实例有不同的告警方式。按钮的点击事件处理需要独立于\x3ccode\x3eSomeComponent\x3c\/code\x3e。通过传递\x3ccode\x3ecreateAlertBox\x3c\/code\x3e方法，他就和\x3ccode\x3eSomeComponent\x3c\/code\x3e是否渲染无关了。甚至和\x3ccode\x3emessage\x3c\/code\x3e这个属性是否修改也没有关系。\x3ccode\x3ecreateAlertBox\x3c\/code\x3e 的内存地址没有改变，意味着\x3ccode\x3eButton\x3c\/code\x3e没有重新渲染。这可以节省运行时间并提升应用的渲染速度。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e但是如果函数是动态的怎么办呢？\x3c\/em\x3e\x3c\/p\x3e\n\x3ch3\x3e修改(高级)\x3c\/h3\x3e\n\x3cp\x3e这里有个非常常见的使用情况，在简单的组件里面，有很多独立的动态事件监听器，例如在遍历数组的时候： \x3ccode\x3eclass SomeComponent extends React.PureComponent { render() { return ( \x26lt;ul\x26gt; {this.props.list.map(listItem =\x26gt; \x26lt;li\x26gt; \x26lt;Button onClick={() =\x26gt;alert(listItem.text)} \/\x26gt; \x26lt;\/li\x26gt; )} \x26lt;\/ul\x26gt; ); } }\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e在这个例子里面，有不确定数量的按钮和监听器，每个按钮都有独立的函数，并且无法在组件\x3ccode\x3eSomComponent\x3c\/code\x3e创建之前知道。要如何解决这个难题呢？\x3c\/p\x3e\n\x3cp\x3e输入记忆，或者更简单的称之为缓存。对于每个唯一的值，创建和缓存对应的函数。对以后这个唯一值的所有引用，都返回之前的缓存函数。\x3c\/p\x3e\n\x3cp\x3e这就是我如何实现上面的例子： \x3ccode\x3eclass SomeComponent extends React.PureComponent { \/\/ Each instance of SomeComponent has a cache of click handlers \/\/ that are unique to it. clickHandlers = {}; \/\/ Generate and\/or return a click handler, \/\/ given a unique identifier. getClickHandler(key) { \/\/ If no click handler exists for this unique identifier, create one. if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) { this.clickHandlers[key] = () =\x26gt; alert(key); } return this.clickHandlers[key]; } render() { return ( \x26lt;ul\x26gt; {this.props.list.map(listItem =\x26gt; \x26lt;li\x26gt; \x26lt;Button onClick={this.getClickHandler(listItem.text)} \/\x26gt;\x26lt;\/li\x26gt; )} \x26lt;\/ul\x26gt; ); } }\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e数组中的每一项都会被传入 \x3ccode\x3egetClickHandler\x3c\/code\x3e 方法中。这个方法里面，第一次传值调用的时候，会对应这个唯一的值创建函数，并返回。以后通过这个值调用这个方法的时候，将会不会返回新的函数，相反会返回之前在内存里创建的函数的引用。\x3c\/p\x3e\n\x3cp\x3e最终，重新渲染\x3ccode\x3eSomeComponent\x3c\/code\x3e组件时，不会引起\x3ccode\x3eButton\x3c\/code\x3e组件的重新渲染。相似的，在\x3ccode\x3elist\x3c\/code\x3e里面添加项也会为按钮动态地创建事件监听器。\x3c\/p\x3e\n\x3cp\x3e可能需要费点脑子为事件处理函数创建唯一的标识，来区分不同的函数，但是在遍历里面，没有比每个 JSX 对象生成的 \x3ccode\x3ekey\x3c\/code\x3e 更简单得了。\x3c\/p\x3e\n\x3cp\x3e这里对使用 \x3ccode\x3eindex\x3c\/code\x3e 当作唯一标识有个提醒：如果数组顺序改了或者有删除项，可能会获得错误的返回。当将数组从 \x3ccode\x3e[ \x27soda\x27, \x27pizza\x27 ]\x3c\/code\x3e 改为 \x3ccode\x3e[ \x27pizza\x27 ]\x3c\/code\x3e，同时已经缓存了事件监听器为\x3ccode\x3elisteners[0] = () =\x26amp;gt; alert(\x27soda\x27)\x3c\/code\x3e，但点击 \x3ccode\x3eindex\x3c\/code\x3e 为 0 的按钮 pizza 的时候，它将会弹出 \x3ccode\x3esoda\x3c\/code\x3e。这也是React建议不要使用数组的索引作为 key 的原因。\x3c\/p\x3e\n\x3ch3\x3e结论\x3c\/h3\x3e\n\x3cp\x3e如果你喜欢本文，随意给它掌声吧。它很快，很容易，而且免费。如果你有其他的问题或则相关的建议，请在下面留言。\x3c\/p\x3e\n\x3cp\x3e阅读更多我的专栏，可以在 \x3ca href=\x22https:\/\/www.linkedin.com\/in\/charles-stover\x22\x3eLinkedIn\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/twitter.com\/CharlesStover\x22\x3eTwitter\x3c\/a\x3e, 或 \x3ca href=\x22https:\/\/charlesstover.com\/\x22\x3echeck out my portfolio on CharlesStover.com\x3c\/a\x3e上关注我.\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/cache-your-react-event-listeners-to-improve-performance">https://www.zcfy.cc/article/cache-your-react-event-listeners-to-improve-performance</a> 原文标题: 缓存 React 事件监听器来提高性能 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/2e3f8879/" target="_blank">https://alili.tech/archive/2e3f8879/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>