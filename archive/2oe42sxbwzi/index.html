<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从源码解析vue响应式原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从源码解析vue响应式原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/2oe42sxbwzi/",
				"appid": "1613049289050283", 
				"title": "从源码解析vue响应式原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-20T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4setxh7kllm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/y8ysjrqkch/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&text=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&text=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&is_video=false&description=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oe42sxbwzi%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90vue%e5%93%8d%e5%ba%94%e5%bc%8f%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从源码解析vue响应式原理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-20" itemprop="datePublished">2018-12-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h2\x3e\n\x3cp\x3e\x3cem\x3e（距离上一次写文章已经过去了四个月，羞愧...）这几个月对vue的使用不少，但是自觉地始终停留在比较粗浅的层面，一直无法提升，所以尝试着开始阅读源码。\x3c\/em\x3e \x3cstrong\x3e文中内容仅代表个人理解，如果错误，欢迎指正\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3eVue中一个显著特性是数据响应式系统：当数据被修改时，视图会相应更新。从而方便的完成状态管理。\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/reactivity.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e中对此进行了简要的描述，本文将结合vuejs的源码，做出进一步的解析。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e基本概念\x3c\/h2\x3e\n\x3cp\x3e首先简单介绍一些在响应式系统中重要的概念。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3edata\x3c\/h3\x3e\n\x3cp\x3evue实例中的数据项\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eobserver\x3c\/h3\x3e\n\x3cp\x3e数据属性的观察者，监控对象的读写操作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3edep\x3c\/h3\x3e\n\x3cp\x3e(dependence的缩写)，字面意思是“依赖”，扮演角色是消息订阅器，拥有收集订阅者、发布更新的功能。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ewatcher\x3c\/h3\x3e\n\x3cp\x3e消息订阅者，可以订阅dep，之后接受dep发布的更新并执行对应视图或者表达式的更新。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3edep和watcher\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edep\x3c\/code\x3e和\x3ccode\x3ewatcher\x3c\/code\x3e的关系，可以理解为：\x3ccode\x3edep\x3c\/code\x3e是报纸，\x3ccode\x3ewatcher\x3c\/code\x3e是订阅了报纸的人，如果他们建立了订阅 的关系，那么每当报纸有更新的时候，就会通知对应的订阅者们。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eview\x3c\/h3\x3e\n\x3cp\x3e暂且认为就是在浏览器中显示的dom（关于virtual dom的内容暂时不在本文讨论）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e收集依赖\x3c\/h3\x3e\n\x3cp\x3ewatcher在自身属性中添加dep的行为，后面会详细介绍\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e收集订阅者\x3c\/h3\x3e\n\x3cp\x3edep在自身属性中添加watcher的行为，后面会详细介绍\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e流程简介\x3c\/h2\x3e\n\x3cp\x3e首先给出官方文档的流程图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010352759\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010352759\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在此基础上，我们根据源码更细一步划分出watcher和data之间的部分，即\x3ccode\x3eDep\x3c\/code\x3e和\x3ccode\x3eobserver\x3c\/code\x3e。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV04Cl?w=1315\x26amp;h=668\x22 src=\x22https:\/\/static.alili.tech\/img\/bV04Cl?w=1315\x26amp;h=668\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e总的来说，vue的数据响应式实现主要分成2个部分：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e把数据转化为getter和setter\x3c\/li\x3e\n\x3cli\x3e建立watcher并收集依赖\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第一部分是上图中\x3ccode\x3edata\x3c\/code\x3e、\x3ccode\x3eobserver\x3c\/code\x3e、\x3ccode\x3edep\x3c\/code\x3e之间联系的建立过程，第二部分是\x3ccode\x3ewatcher\x3c\/code\x3e、\x3ccode\x3edep\x3c\/code\x3e的关系建立\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e源码解析\x3c\/h2\x3e\n\x3cp\x3e本文中采用的源码是vuejs 2.5.0，\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGit地址\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3ePS：简单的代码直接添加中文注释，所以在关键代码部分做\x3ccode\x3e\x26lt;数字\x26gt;\x3c\/code\x3e标记，在后文详细介绍\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e首先我们在源码中找到vue进行数据处理的方法\x3ccode\x3einitData\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/* 源码目录 src\/core\/instance\/state.js *\/\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === \x27function\x27\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n      \x27data functions should return an object:\\n\x27 \x2b\n      \x27https:\/\/vuejs.org\/v2\/guide\/components. html#data-Must-Be-a-Function\x27,\n      vm\n    )\n  }\n  \/\/ proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      if (methods \x26amp;\x26amp; hasOwn(methods, key)) {\n        warn(\n          `Method \x26quot;${key}\x26quot; has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props \x26amp;\x26amp; hasOwn(props, key)) {\n      process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n        `The data property \x26quot;${key}\x26quot; is already declared as a prop. ` \x2b\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      \/\/\x3c1\x3edata属性代理\n      proxy(vm, `_data`, key)\n    }\n  }\n  \/\/ observe data\n   \/\/对data调用observe\n  observe(data, true \/* asRootData *\/)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* 源码目录 src\/core\/instance\/state.js *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = vm.$options.data\n  data = vm._data = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e data === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n    ? getData(data, vm)\n    : data || {}\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27data functions should return an object:\\n\x27\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/vuejs.org\/v2\/guide\/components. html#data-Must-Be-a-Function\x27\x3c\/span\x3e,\n      vm\n    )\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ proxy data on instance\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(data)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e props = vm.$options.props\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e methods = vm.$options.methods\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = keys.length\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key = keys[i]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (methods \x26amp;\x26amp; hasOwn(methods, key)) {\n        warn(\n          \x3cspan class=\x22hljs-string\x22\x3e`Method \x22\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x22 has already been defined as a data property.`\x3c\/span\x3e,\n          vm\n        )\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (props \x26amp;\x26amp; hasOwn(props, key)) {\n      process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n        \x3cspan class=\x22hljs-string\x22\x3e`The data property \x22\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x22 is already declared as a prop. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`Use prop default value instead.`\x3c\/span\x3e,\n        vm\n      )\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isReserved(key)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;1\x26gt;data属性代理\x3c\/span\x3e\n      proxy(vm, \x3cspan class=\x22hljs-string\x22\x3e`_data`\x3c\/span\x3e, key)\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ observe data\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/对data调用observe\x3c\/span\x3e\n  observe(data, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一段代码主要做2件事：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e代码\x26lt;1\x26gt;\x3c\/code\x3e在\x3ccode\x3ewhile\x3c\/code\x3e循环内调用\x3ccode\x3eproxy\x3c\/code\x3e函数把data的属性代理到vue实例上。完成之后可以通过\x3ccode\x3evm.key\x3c\/code\x3e直接访问\x3ccode\x3edata.key\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e之后对\x3ccode\x3edata\x3c\/code\x3e调用了\x3ccode\x3eobserve\x3c\/code\x3e方法，在这里说明一下，如果是在实例化之前添加的数据，因为被\x3ccode\x3eobserve\x3c\/code\x3e过，所以会变成响应式数据，而在实例化之后使用\x3ccode\x3evm.newKey = newVal\x3c\/code\x3e这样设置新属性，是不会自动响应的。解决方法是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- 如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值\n- 使用`vm.$data`等一些api进行数据操作\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e 如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e 使用\x3cspan class=\x22hljs-string\x22\x3e`vm.$data`\x3c\/span\x3e等一些api进行数据操作\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e接下来来看对应代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 源码目录 src\/core\/observer\/index.js *\/\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n if (!isObject(value) || value instanceof VNode) {\n   return\n }\n let ob: Observer | void\n \/\/检测当前数据是否被observe过,如果是则不必重复绑定\n if (hasOwn(value, \x27__ob__\x27) \x26amp;\x26amp; value.__ob__ instanceof Observer) {\n   ob = value.__ob__\n } else if (\n   \/\/\x3c1\x3e检测当前的数据是否是对象或者数组，如果是，则生成对应的Observer\n   observerState.shouldConvert \x26amp;\x26amp;\n   !isServerRendering() \x26amp;\x26amp;\n   (Array.isArray(value) || isPlainObject(value)) \x26amp;\x26amp;\n   Object.isExtensible(value) \x26amp;\x26amp;\n   !value._isVue\n ) {\n   ob = new Observer(value)\n }\n if (asRootData \x26amp;\x26amp; ob) {\n   ob.vmCount\x2b\x2b\n }\n return ob\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 源码目录 src\/core\/observer\/index.js *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobserve\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evalue: any, asRootData: ?boolean\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e | \x3cspan class=\x22hljs-title\x22\x3evoid\x3c\/span\x3e \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isObject(value) || value \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e VNode) {\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n }\n \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ob: Observer | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/检测当前数据是否被observe过,如果是则不必重复绑定\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasOwn(value, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e) \x26amp;\x26amp; value.__ob__ \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Observer) {\n   ob = value.__ob__\n } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;1\x26gt;检测当前的数据是否是对象或者数组，如果是，则生成对应的Observer\x3c\/span\x3e\n   observerState.shouldConvert \x26amp;\x26amp;\n   !isServerRendering() \x26amp;\x26amp;\n   (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value) || isPlainObject(value)) \x26amp;\x26amp;\n   \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isExtensible(value) \x26amp;\x26amp;\n   !value._isVue\n ) {\n   ob = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer(value)\n }\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (asRootData \x26amp;\x26amp; ob) {\n   ob.vmCount\x2b\x2b\n }\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ob\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e在本段代码中，\x3ccode\x3e代码\x26lt;1\x26gt;\x3c\/code\x3e处，对传入的数据对象进行了判断，\x3cstrong\x3e只对对象和数组类型生成\x3ccode\x3eObserver\x3c\/code\x3e实例\x3c\/strong\x3e,然后看\x3ccode\x3eObserver\x3c\/code\x3e这个类的代码，\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eObserver\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; \/\/ number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    \/\/ 生成了一个消息订阅器dep实例 关于dep的结构稍后详细介绍 \n    this.dep = new Dep()\n    this.vmCount = 0\n    \/\/def函数给当前数据添加不可枚举的__ob__属性，表示该数据已经被observe过\n    def(value, \x27__ob__\x27, this)\n    \/\/\x3c1\x3e对数组类型的数据 调用observeArray方法；对对象类型的数据，调用walk方法\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  \/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\n   \/* 循环遍历数据对象的每个属性，调用defineReactive方法 只对Object类型数据有效 *\/\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i \x3c keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \/**\n   * Observe a list of Array items. \n   *\/\n   \/* observe数组类型数据的每个值， *\/\n  observeArray (items: Array\x3cany\x3e) {\n    for (let i = 0, l = items.length; i \x3c l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\n\n\/* defineReactive的核心思想改写数据的getter和setter *\/\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  \/\/\x3c2\x3e生成一个dep实例，注意此处的dep和前文Observer类里直接添加的dep的区别\n  const dep = new Dep()\n    \n  \/\/检验该属性是否允许重新定义setter和getter\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property \x26amp;\x26amp; property.configurable === false) {\n    return\n  }\n\n  \/\/ cater for pre-defined getter\/setters\n  \/\/ 获取原有的 getter\/setters\n  const getter = property \x26amp;\x26amp; property.get\n  const setter = property \x26amp;\x26amp; property.set\n  \n  \/\/\x3c3\x3e此处对val进行了observe\n  let childOb = !shallow \x26amp;\x26amp; observe(val)\n  \n  \/\/\x3c4\x3e下面的代码利用Object.defineProperty函数把数据转化成getter和setter，并且在getter和setter时，进行了一些操作\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        \/\/ dep.depend()其实就是dep和watcher进行了互相绑定，而Dep.target表示需要绑定的那个watcher，任何时刻都最多只有一个，后面还会解释\n        dep.depend()\n        if (childOb) {\n          \/\/\x3c5\x3e当前对象的子对象的依赖也要被收集\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      \/* eslint-disable no-self-compare *\/\n      if (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        return\n      }\n      \/* eslint-enable no-self-compare *\/\n      if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; customSetter) {\n        customSetter()\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      \/\/\x3c6\x3e观察新的val并通知订阅者们属性有更新\n      childOb = !shallow \x26amp;\x26amp; observe(newVal)\n      dep.notify()\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  value: any;\n  dep: Dep;\n  vmCount: number; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ number of vms that has this object as root $data\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (value: any) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成了一个消息订阅器dep实例 关于dep的结构稍后详细介绍 \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/def函数给当前数据添加不可枚举的__ob__属性，表示该数据已经被observe过\x3c\/span\x3e\n    def(value, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;1\x26gt;对数组类型的数据 调用observeArray方法；对对象类型的数据，调用walk方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(value)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* 循环遍历数据对象的每个属性，调用defineReactive方法 只对Object类型数据有效 *\/\x3c\/span\x3e\n  walk (obj: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(obj)\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Observe a list of Array items. \n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* observe数组类型数据的每个值， *\/\x3c\/span\x3e\n  observeArray (items: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;any\x26gt;) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = items.length; i \x26lt; l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/* defineReactive的核心思想改写数据的getter和setter *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;2\x26gt;生成一个dep实例，注意此处的dep和前文Observer类里直接添加的dep的区别\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n    \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/检验该属性是否允许重新定义setter和getter\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e property = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(obj, key)\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (property \x26amp;\x26amp; property.configurable === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cater for pre-defined getter\/setters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取原有的 getter\/setters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getter = property \x26amp;\x26amp; property.get\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setter = property \x26amp;\x26amp; property.set\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;3\x26gt;此处对val进行了observe\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childOb = !shallow \x26amp;\x26amp; observe(val)\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;4\x26gt;下面的代码利用Object.defineProperty函数把数据转化成getter和setter，并且在getter和setter时，进行了一些操作\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dep.depend()其实就是dep和watcher进行了互相绑定，而Dep.target表示需要绑定的那个watcher，任何时刻都最多只有一个，后面还会解释\x3c\/span\x3e\n        dep.depend()\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;5\x26gt;当前对象的子对象的依赖也要被收集\x3c\/span\x3e\n          childOb.dep.depend()\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable no-self-compare *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-enable no-self-compare *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; customSetter) {\n        customSetter()\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n        setter.call(obj, newVal)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        val = newVal\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;6\x26gt;观察新的val并通知订阅者们属性有更新\x3c\/span\x3e\n      childOb = !shallow \x26amp;\x26amp; observe(newVal)\n      dep.notify()\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e在Observer类代码中，首先给当前数据\x3cstrong\x3e添加了一个dep实例，存放于对象或者数组类型数据的\x3ccode\x3e_![图片描述][2]ob_\x3c\/code\x3e属性上\x3c\/strong\x3e，然后把\x3ccode\x3e_ob_\x3c\/code\x3e挂在该数据上，它是该数据项被\x3ccode\x3eobserve\x3c\/code\x3e的标志，我们可以在控制台看到这个属性，,例如：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/例子 1\n\x3c!DOCTYPE html\x3e\n\x3chtml\x3e\n\n\x3chead\x3e\n  \x3cmeta charset=\x26quot;utf-8\x26quot;\x3e\n  \x3cmeta name=\x26quot;viewport\x26quot; content=\x26quot;width=device-width\x26quot;\x3e\n  \x3ctitle\x3evue demo\x3c\/title\x3e\n\x3c\/head\x3e\n\n\x3cbody\x3e\n  \x3cscript src=\x26quot;https:\/\/cdn.jsdelivr.net\/npm\/vue\x26quot;\x3e\x3c\/script\x3e\n  \x3cdiv id=\x26quot;app\x26quot;\x3e\n    \x3cdiv\x3eobj:\x22{{\x22 obj\x22}}\x22\x3c\/div\x3e\n  \x3c\/div\x3e\n\x3c\/body\x3e\n\x3cscript\x3e\n  app = new Vue({\n    el: \x27#app\x27,\n    data: {\n      str: \x26quot;a\x26quot;,\n      obj: {\n        key: \x26quot;val\x26quot;\n      }\n    }\n  });\n  console.log(app._data)\n\x3c\/script\x3e\n\n\x3c\/html\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\/\/例子 1\n\x3cspan class=\x22hljs-meta\x22\x3e\x26lt;!DOCTYPE html\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22utf-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22viewport\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3econtent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22width=device-width\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3evue demo\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/cdn.jsdelivr.net\/npm\/vue\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eobj:\x22{{\x22 obj\x22}}\x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n  app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3estr\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eobj\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22val\x22\x3c\/span\x3e\n      }\n    }\n  });\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(app._data)\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在控制台我们可以看到这样的数据\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV04Ip?w=1058\x26amp;h=335\x22 src=\x22https:\/\/static.alili.tech\/img\/bV04Ip?w=1058\x26amp;h=335\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，首先，data对象上已经有\x3ccode\x3e_ob_\x3c\/code\x3e属性，这是被\x3ccode\x3eobserve\x3c\/code\x3e的标志；其次，\x3ccode\x3eobj\x3c\/code\x3e和\x3ccode\x3earr\x3c\/code\x3e属性上有\x3ccode\x3e_ob_\x3c\/code\x3e属性，而\x3ccode\x3estr\x3c\/code\x3e没有，这个进一步证明了前文提到的：\x3ccode\x3eobserve\x3c\/code\x3e\x3cstrong\x3e只对对象和数组有效\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e随后，对于数组和对象类型的数据做不同处理：对于数组类型\x3ccode\x3eobserve\x3c\/code\x3e里面的每个值，对于对象，我们执行\x3ccode\x3ewalk()\x3c\/code\x3e方法，而\x3ccode\x3ewalk()\x3c\/code\x3e就是对于当前数据对象的每个key，执行\x3ccode\x3edefineReactive()\x3c\/code\x3e方法，所以接下来重点来看\x3ccode\x3edefineReactive()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3edefineReactive()\x3c\/code\x3e中，在\x3ccode\x3e代码\x26lt;2\x26gt;\x3c\/code\x3e处生成了一个\x3ccode\x3edep\x3c\/code\x3e实例，并在接下来的代码里，把这个\x3ccode\x3edep\x3c\/code\x3e对象放在当前数据对象的\x3ccode\x3ekey\x3c\/code\x3e(比如上面例子1中的\x3ccode\x3estr\x3c\/code\x3e)的\x3ccode\x3egetter\x3c\/code\x3e里，这个之前\x3ccode\x3eObserver\x3c\/code\x3e中的\x3ccode\x3edep\x3c\/code\x3e是有区别的:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eObserver\x3c\/code\x3e中的\x3ccode\x3edep\x3c\/code\x3e挂在\x3ccode\x3eObject\x3c\/code\x3e或者\x3ccode\x3eArray\x3c\/code\x3e类型的数据的\x3ccode\x3edep\x3c\/code\x3e属性上，可以在控制台直接查看；\x3c\/li\x3e\n\x3cli\x3e此处添加的\x3ccode\x3edep\x3c\/code\x3e挂在属性的\x3ccode\x3egetter\/setter上\x3c\/code\x3e，存在于函数闭包中，不可直接查看\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22为什么会有2种`Dep`呢？因为对于`Object`或者`Array`类型的数据，可能会有**添加\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e为什么会有\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e种`Dep`呢？因为对于`Object`或者`Array`类型的数据，可能会有**添加\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者删除成员的操作而其他类型的值只有赋值操作，赋值操作可以在\x3ccode\x3egetter\/setter上\x3c\/code\x3e中检测到。**，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e接下来\x3ccode\x3e代码\x26lt;3\x26gt;\x3c\/code\x3e处的是为了处理嵌套的数据对象，比如例子1中，\x3ccode\x3edata\x3c\/code\x3e是最顶层的\x3ccode\x3eObject\x3c\/code\x3e,\x3ccode\x3eobj\x3c\/code\x3e就是\x3ccode\x3edata\x3c\/code\x3e下的\x3ccode\x3eObject\x3c\/code\x3e，而\x3ccode\x3eobj\x3c\/code\x3e里面也可以再继续嵌套数据，有了此处的代码之后，就可以对嵌套的每一层都做\x3ccode\x3eobserve\x3c\/code\x3e处理。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e代码\x26lt;4\x26gt;\x3c\/code\x3e处是\x3ccode\x3edefineReactive()\x3c\/code\x3e的核心：利用\x3ccode\x3eObject.defineProperty()\x3c\/code\x3e(这个函数建议了解一下\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/defineProperty\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emdn地址\x3c\/a\x3e)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在当前属性的getter和setter中插入操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在当前数据被get时，当前的\x3ccode\x3ewatcher\x3c\/code\x3e(也就是\x3ccode\x3eDap.target\x3c\/code\x3e)和\x3ccode\x3edep\x3c\/code\x3e之间的绑定，这里有个注意点是在\x3ccode\x3e代码\x26lt;5\x26gt;\x3c\/code\x3e处，如果当前数据对象存在子对象，那么子对象的\x3ccode\x3edep\x3c\/code\x3e也要和当前\x3ccode\x3ewatcher\x3c\/code\x3e进行绑定，以此类推。\x3c\/li\x3e\n\x3cli\x3e在setter时，我们重新观测当前\x3ccode\x3eval\x3c\/code\x3e,然后通过\x3ccode\x3edep.notify()\x3c\/code\x3e来通知当前dep所绑定的订阅者们数据有更新。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eDep\x3c\/h3\x3e\n\x3cp\x3e接下来介绍一下\x3ccode\x3edep\x3c\/code\x3e。源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 源码目录 src\/core\/observer\/dep.js *\/\nlet uid = 0\n\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array\x3cWatcher\x3e;\n\n  constructor () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\n  \/\/添加一个watcher\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n  \/\/移除一个watcher\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n  \/\/让当前watcher收集依赖 同时Dep.target.addDep也会触发当前dep收集watcher\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n \/\/通知watcher们对应的数据有更新\n  notify () {\n    \/\/ stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i \x3c l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 源码目录 src\/core\/observer\/dep.js *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e uid = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e target: ?Watcher;\n  id: number;\n  subs: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Watcher\x26gt;;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid\x2b\x2b\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = []\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加一个watcher\x3c\/span\x3e\n  addSub (sub: Watcher) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.push(sub)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/移除一个watcher\x3c\/span\x3e\n  removeSub (sub: Watcher) {\n    remove(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs, sub)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/让当前watcher收集依赖 同时Dep.target.addDep也会触发当前dep收集watcher\x3c\/span\x3e\n  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n      Dep.target.addDep(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/通知watcher们对应的数据有更新\x3c\/span\x3e\n  notify () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stabilize the subscriber list first\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e subs = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.slice()\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = subs.length; i \x26lt; l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个类相对简单很多，只有2个属性:第一个是\x3ccode\x3eid\x3c\/code\x3e，在每个vue实例中都从0开始计数；另一个是\x3ccode\x3esubs\x3c\/code\x3e数组，用于存放\x3ccode\x3ewacther\x3c\/code\x3e，根绝前文我们知道，一个数据对应一个\x3ccode\x3eDep\x3c\/code\x3e，所以\x3ccode\x3esubs\x3c\/code\x3e里存放的也就是依赖该数据需要绑定的\x3ccode\x3ewacther\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这里有个\x3ccode\x3eDep.target\x3c\/code\x3e属性是全局共享的，表示\x3cstrong\x3e当前在收集依赖的那个Watcher，在每个时刻最多只会有一个\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3ewatcher\x3c\/h3\x3e\n\x3cp\x3e接下里看watcher的源码，比较长，但是我们只关注其中的几个属性和方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 源码目录 src\/core\/observer\/watcher.js *\/\n\/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\/\n \/* watcher用来解析表达式，收集依赖，并且当表达式的值改变时触发回调函数 \n 用在$watch() api 和指令中\n *\/\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array\x3cDep\x3e;\n  newDeps: Array\x3cDep\x3e;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    vm._watchers.push(this)\n    \/\/ options\n    \/\/这里暂时不用关注 \n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = \x2b\x2buid \/\/ uid for batching\n    this.active = true\n    this.dirty = this.lazy \/\/ for lazy watchers\n    \/\/deps和newDeps表示现有的依赖和新一轮收集的依赖\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== \x27production\x27\n      ? expOrFn.toString()\n      : \x27\x27\n    \/\/ parse expression for getter\n    \/\/\x3c1\x3e解析getter的表达式 \n    if (typeof expOrFn === \x27function\x27) {\n      this.getter = expOrFn\n    } else {\n      \/\/\x3c2\x3e获取实际对象的值\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n          `Failed watching path: \x26quot;${expOrFn}\x26quot; ` \x2b\n          \x27Watcher only accepts simple dot-delimited paths. \x27 \x2b\n          \x27For full control, use a function instead.\x27,\n          vm\n        )\n      }\n    }\n    \/\/this.lazy为true是计算属性的watcher，另外处理，其他情况调用get\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  \/**\n   * Evaluate the getter, and re-collect dependencies.\n   *\/\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \x26quot;${this.expression}\x26quot;`)\n      } else {\n        throw e\n      }\n    } finally {\n      \/\/ \x26quot;touch\x26quot; every property so they are all tracked as\n      \/\/ dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      \/\/\x3c3\x3e清除先前的依赖\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  \/**\n   * Add a dependency to this directive.\n   *\/\n   \/* 给当前指令添加依赖 *\/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  \/**\n   * Clean up for dependency collection.\n   *\/\n   \/* 清除旧依赖 *\/\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  \/**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\/\n   \/* 订阅者的接口 当依赖改变时会触发 *\/\n  update () {\n    \/* istanbul ignore else *\/\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n\n  \/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   *\/\n   \/* 调度接口 调度时会触发 *\/\n  run () {\n    if (this.active) {\n      \/\/\x3c14\x3e重新收集依赖\n      const value = this.get()\n      if (\n        value !== this.value ||\n        \/\/ Deep watchers and watchers on Object\/Arrays should fire even\n        \/\/ when the value is the same, because the value may\n        \/\/ have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        \/\/ set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \x26quot;${this.expression}\x26quot;`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  \/**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   *\/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  \/**\n   * Depend on all deps collected by this watcher.\n   *\/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  \/**\n   * Remove self from all dependencies\x27 subscriber list.\n   *\/\n  teardown () {\n    if (this.active) {\n      \/\/ remove self from vm\x27s watcher list\n      \/\/ this is a somewhat expensive operation so we skip it\n      \/\/ if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 源码目录 src\/core\/observer\/watcher.js *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\/\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/* watcher用来解析表达式，收集依赖，并且当表达式的值改变时触发回调函数 \n 用在$watch() api 和指令中\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e \x3c\/span\x3e{\n  vm: Component;\n  expression: string;\n  cb: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Dep\x26gt;;\n  newDeps: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Dep\x26gt;;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  value: any;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm\n    vm._watchers.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里暂时不用关注 \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = !!options.deep\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = !!options.user\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = !!options.lazy\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = !!options.sync\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = \x2b\x2buid \x3cspan class=\x22hljs-comment\x22\x3e\/\/ uid for batching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for lazy watchers\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/deps和newDeps表示现有的依赖和新一轮收集的依赖\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps = []\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps = []\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression = process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n      ? expOrFn.toString()\n      : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parse expression for getter\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;1\x26gt;解析getter的表达式 \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e expOrFn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = expOrFn\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;2\x26gt;获取实际对象的值\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = parsePath(expOrFn)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n        process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n          \x3cspan class=\x22hljs-string\x22\x3e`Failed watching path: \x22\x3cspan class=\x22hljs-subst\x22\x3e${expOrFn}\x3c\/span\x3e\x22 `\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27Watcher only accepts simple dot-delimited paths. \x27\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27For full control, use a function instead.\x27\x3c\/span\x3e,\n          vm\n        )\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/this.lazy为true是计算属性的watcher，另外处理，其他情况调用get\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy\n      ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Evaluate the getter, and re-collect dependencies.\n   *\/\x3c\/span\x3e\n  get () {\n    pushTarget(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e value\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(vm, vm)\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user) {\n        handleError(e, vm, \x3cspan class=\x22hljs-string\x22\x3e`getter for watcher \x22\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e e\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22touch\x22 every property so they are all tracked as\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dependencies for deep watching\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep) {\n        traverse(value)\n      }\n      popTarget()\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;3\x26gt;清除先前的依赖\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cleanupDeps()\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Add a dependency to this directive.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* 给当前指令添加依赖 *\/\x3c\/span\x3e\n  addDep (dep: Dep) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e id = dep.id\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.has(id)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.add(id)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps.push(dep)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds.has(id)) {\n        dep.addSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Clean up for dependency collection.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* 清除旧依赖 *\/\x3c\/span\x3e\n  cleanupDeps () {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i]\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.has(dep.id)) {\n        dep.removeSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds = tmp\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.clear()\n    tmp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps = tmp\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* 订阅者的接口 当依赖改变时会触发 *\/\x3c\/span\x3e\n  update () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run()\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      queueWatcher(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/* 调度接口 调度时会触发 *\/\x3c\/span\x3e\n  run () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;14\x26gt;重新收集依赖\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n        value !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value ||\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Deep watchers and watchers on Object\/Arrays should fire even\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ when the value is the same, because the value may\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ have mutated.\x3c\/span\x3e\n        isObject(value) ||\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep\n      ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set new value\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldValue = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user) {\n          \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, value, oldValue)\n          } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n            handleError(e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, \x3cspan class=\x22hljs-string\x22\x3e`callback for watcher \x22\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n          }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   *\/\x3c\/span\x3e\n  evaluate () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Depend on all deps collected by this watcher.\n   *\/\x3c\/span\x3e\n  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i].depend()\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Remove self from all dependencies\x27 subscriber list.\n   *\/\x3c\/span\x3e\n  teardown () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ remove self from vm\x27s watcher list\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is a somewhat expensive operation so we skip it\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if the vm is being destroyed.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._isBeingDestroyed) {\n        remove(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._watchers, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i].removeSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先看官方文档的英文注释可知，watcher用于watcher用来解析表达式，收集依赖，并且当表达式的值改变时触发回调函数，用在\x3ccode\x3e$watch()\x3c\/code\x3eapi 和指令之中。\x3c\/p\x3e\n\x3cp\x3ewatcher函数主要内容是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e初始化属性的值，其中和本文相关的主要是\x3ccode\x3edeps\x3c\/code\x3e、\x3ccode\x3enewDeps\x3c\/code\x3e、\x3ccode\x3edepIds\x3c\/code\x3e、\x3ccode\x3enewDepIds\x3c\/code\x3e,分别表示现有依赖和新一轮收集的依赖，这里的\x3cstrong\x3e依赖\x3c\/strong\x3e就是前文介绍的数据对应的\x3ccode\x3edep\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e设置getter属性。\x3ccode\x3e\x26lt;1\x26gt;\x3c\/code\x3e判断传入的表达式类型：可能是函数，也可能是表达式。如果是函数，那么直接设置成getter，如果是表达式，由于\x3ccode\x3e代码\x26lt;2\x26gt;\x3c\/code\x3e处的\x3ccode\x3eexpOrFn\x3c\/code\x3e只是字符串，\x3cstrong\x3e比如例子1中的\x3ccode\x3eobj.key\x3c\/code\x3e，在这里仅仅是一个字符串\x3c\/strong\x3e，所以要用\x3ccode\x3eparsePath\x3c\/code\x3e获取到实际的值\x3c\/li\x3e\n\x3cli\x3e执行get()方法，在这里主要做收集依赖，并且获取数据的值，之后要调用\x3ccode\x3e代码\x26lt;3\x26gt;\x3c\/code\x3e`cleanupDeps`清除旧的依赖。这是必须要做的，因为数据更新之后可能有新的数据属性添加进来，前一轮的依赖中没有包含这个新数据，所以要重新收集。\x3c\/li\x3e\n\x3cli\x3eupdate方法主要内容是里面的触发更新之后会触发run方法（虽然这里分了三种情况，但是最终都是触发run方法），而run方法调用\x3ccode\x3eget()\x3c\/code\x3e首先重新收集依赖，然后使用\x3ccode\x3ethis.cb.call\x3c\/code\x3e更新模板或者表达式的值。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e在最后，我们再总结一下这个流程：首先数据从初始化data开始，使用\x3ccode\x3eobserve\x3c\/code\x3e监控数据：给每个数据属性添加\x3ccode\x3edep\x3c\/code\x3e，并且在它的getter过程添加收集依赖操作，在setter过程添加通知更新的操作；在解析指令或者给vue实例设置\x3ccode\x3ewatch\x3c\/code\x3e选项或者调用\x3ccode\x3e$watch\x3c\/code\x3e时，生成对应的\x3ccode\x3ewatcher\x3c\/code\x3e并收集依赖。之后，如果数据触发更新，会通知\x3ccode\x3ewatcher\x3c\/code\x3e，\x3ccode\x3ewacther\x3c\/code\x3e在重新收集依赖之后，触发模板视图更新。这就完成了数据响应式的流程。\x3c\/p\x3e\n\x3cp\x3e本文的流程图根据源码的过程画出，而在官方文档的流程图中，没有单独列出\x3ccode\x3edep\x3c\/code\x3e和\x3ccode\x3eobvserver\x3c\/code\x3e，因为这个流程最核心的思路就是\x3cstrong\x3e将data的属性转化成\x3ccode\x3egetter\x3c\/code\x3e和\x3ccode\x3esetter\x3c\/code\x3e然后和\x3ccode\x3ewatcher\x3c\/code\x3e绑定\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e然后依然是惯例：如果这篇文章对你有帮助，希望可以收藏和推荐，以上内容属于个人见解，如果有不同意见，欢迎指出和探讨。\x3cstrong\x3e请尊重作者的版权，转载请注明出处，如作商用，请与作者联系，感谢！\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从源码解析vue响应式原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012612657">https://segmentfault.com/a/1190000012612657</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/2oe42sxbwzi/" target="_blank">https://alili.tech/archive/2oe42sxbwzi/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>