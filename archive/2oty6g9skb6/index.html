<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="后端知识点总结——NODE.JS（高级）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>后端知识点总结——NODE.JS（高级） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/2oty6g9skb6/",
				"appid": "1613049289050283", 
				"title": "后端知识点总结——NODE.JS（高级） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8qowe1d2h8h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/j95hq2a5mla/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&text=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&text=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&title=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&is_video=false&description=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&title=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&title=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&title=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f2oty6g9skb6%2f&title=%e5%90%8e%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94NODE.JS%ef%bc%88%e9%ab%98%e7%ba%a7%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">后端知识点总结——NODE.JS（高级）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1\x3e\x3cstrong\x3e后端知识点总结——NODE.JS（高级）\x3c\/strong\x3e\x3c\/h1\x3e\n\x3ch2\x3e1.Node入门:\x3c\/h2\x3e\n\x3cp\x3e什么是: 针对网络应用开发的平台\x3cbr\x3e主要特征:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e基于Google的JavaScript运行时引擎V8\x3c\/li\x3e\n\x3cli\x3e扩展了Node标准类库: TCP，同步或异步文件管理，HTTP\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e为什么使用Node:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e可以在服务器端运行js: 现有前端团队可直接参与后端js开发\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ejs天生支持非阻塞IO:\x3cbr\x3e IO: 代表一切数据进出程序的操作:\x3cbr\x3e   包括: 文件读写, 数据库操作, 网络操作\x3cbr\x3e 问题: 有延迟\x3cbr\x3e 传统阻塞IO: IO操作会阻塞当前主线程，直到本次IO操作完成，才能执行后续代码。\x3cbr\x3e 非阻塞IO: 即使处理较慢的IO操作时，主进城仍然能处理其他请求\x3cbr\x3e Js天生支持非阻塞: 回调函数=事件循环\x2b回调队列\x3cbr\x3e   所有非阻塞的操作，返回的结果暂时在回调队列中等待\x3cbr\x3e   由事件循环，自动依次取回到主程序中恢复执行\x3cbr\x3e   回调队列在主程序之外存储回调函数，所以，不会干扰主程序执行\x3cbr\x3e 非阻塞在Web服务器中: \x3cbr\x3e  普通服务器端应用: 虽然可实现每个请求独立线程\/进程, 但如果一个请求中，包含多个阻塞IO操作(访问数据库，网络，读写硬盘文件)，该请求返回的时间就等于所有IO操作的时间总和——慢\x3cbr\x3e  Node服务器端应用: 不但每个请求是一个独立的线程，且，每个请求内的每个IO操作，都是非阻塞的。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e一个包含多个IO操作的请求，返回的总响应时间，仅仅等于其中一个时间最长的IO操作的时间。\nNode.js vs javascript: \nJavascript: 编程语言, 依照ECMAScript\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2种运行环境:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e客户端浏览器: 由各种客户端浏览器中的js解释器执行\x3cbr\x3e 扩展: DOM API 和 BOM API 主要目的是为了操作网页内容和浏览器窗口\x3c\/li\x3e\n\x3cli\x3e独立的js解释器:Node.js 应用程序开发和运行的平台\x3cbr\x3e 仅支持ECMAScript\x3cbr\x3e 扩展: 各种专门的服务器模块: TCP, HTTP, 文件读写, MYSQL\x3cp\x3e构建一个简单的node应用: \x3cbr\x3e 创建一个新的node项目: 基本命令:\x3cbr\x3e mkdir 项目文件夹\x3cbr\x3e cd 项目文件夹\x3cbr\x3e npm init  \/\/负责在当前所在的项目目录下自动生成package.json配置文件\x3cbr\x3e 运行:node 入口文件.js\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e2.module\x3c\/h2\x3e\n\x3cp\x3eNode应用都是由模块组成\x3cbr\x3e模块就是组织程序功能的一种文件或文件夹\x3cbr\x3eNode应用采用CommonJS模块规范\x3cbr\x3eCommonJS规定:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e每个文件就是一个模块，有自己的作用域——避免全局污染\x3cbr\x3e  一个文件内定义的变量，函数，类都是该文件私有，对其它文件默认不可见\x3c\/li\x3e\n\x3cli\x3e对象，方法和变量也可以从一个文件\/模块中导出(exports)，用在其它文件\/模块中。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e实际项目中，都是将各种功能\/数据，划分为不同项目模块来管理\x3cbr\x3e 如何定义一个模块：2步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在模块\/文件中定义业务代码(对象,class,函数)\x3c\/li\x3e\n\x3cli\x3e将内部的功能抛出，用于将来其它js文件调用\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e2种情况:\x3c\/p\x3e\n\x3ch2\x3e2.1面向对象的方式:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e定义一种class或一个对象，包裹属性和功能\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e将class或对象直接赋值给module.exports\x3cbr\x3e  其中: module，指当前模块对象\/当前文件\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   exports是当前module对象的一个属性\n     本质上也是一个对象，保存将来要抛出的所有东西\n     exports是当前模块对外的唯一接口\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e今后，只要希望将模块内部的东西，抛出到外部，供其它文件使用时，都要添加到module.exports上\x3cbr\x3e  其它文件要想使用当前模块的功能，就必须用require引入当前模块，而require的本质是找模块的exports.\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e2.2面向函数的方式:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e在文件中，定义多个零散的方法\x3c\/li\x3e\n\x3cli\x3e将多个零散的方法添加到module的exports上\x3cbr\x3e  其实，可先将零散的方法，先集中定义在一个对象中，再将整个对象赋值给module.exports属性\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e引入模块: require() 专门负责加载模块文件\x3cbr\x3e   何时: 只要在另一个js文件中，引入自定义模块并获取内容时，都用require\x3cbr\x3e   本质: 找到js文件，并执行，返回module.exports对象\x3cbr\x3e   优化: 单例模式singleton: 始终保持项目中只有一个对象的实例\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e模块的引入和加载也是单例模式: 模块只在第一次被require时，创建。之后，缓存在内存中。反复require不会导致反复创建模块对象。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e强调: 模块是同步加载：前一个加载完，后一个才能开始\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e 强烈建议: 所有require必须集中在顶部\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e路径: 以.\/开头，表示使用相对路径，相对于当前正在执行脚本所在路径——不能省略!\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e    以\/开头，表示Linux系统根目录——绝对路径\n    以自定义变量开头,表示在变量保存的地址下继续查找\n    什么前缀也不加！只写模块名: 表示加载一个核心模块或项目引入的第三方模块\n      路径查找顺序:\n        \/usr\/local\/lib\/node\/模块名.js\n        \/home\/user\/projects\/node_modules\/模块名.js\n        \/home\/user\/node_modules\/模块名.js\n        \/home\/node_modules\/模块名.js\n        \/node_modules\/模块名.js\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e坑: 简写: module.exports.fun=function(){…}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e       可简写为: exports.fun=function(){…}\n   exports其实是module.exports的别名\n   var exports=module.exports;\n问题: 给exports赋值，无法赋值给module.exports\n   因为exports只是一个变量，临时保存module.exports的地址值。再次给exports赋任何新值，都导致exports与module.exports分道扬镳！\n避免: 不要用简写exports\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e3.目录模块:\x3c\/h2\x3e\n\x3cp\x3e何时: 当一个模块代码，复杂到需要进一步细分时，一个模块，就可能由多个文件组成，保存在一个文件夹里。\x3cbr\x3e如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建文件夹,集中保存相关的多个js文件模块\x3c\/li\x3e\n\x3cli\x3e在文件夹中添加一个主模块(index.js)，主模块中，引入并组织好多个小模块一起导出\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e在文件夹中添加package.json文件，其中:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e  {\n    \x22name\x22:\x22模块名\x22,\n    \x22main\x22:\x22.\/主模块相对路径\x22\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实, 如果没有main甚至没有package.json，也行。\x3cbr\x3e  会自动优先找文件夹下的index.js\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e引入目录模块: require(\x22.\/目录名\x22)\x3cbr\x3e  如果希望直接用目录名引用模块，不加相对路径:\x3cbr\x3e   将目录放入node_modules文件夹中\x3c\/p\x3e\n\x3cp\x3enpm: 第三方模块的包管理工具: 查询，下载\x3cbr\x3e 除了核心模块和自定义本地模块，node生态系统还提供了大量优质第三方模块\x3cbr\x3e 如何: \x3cbr\x3e  查询模块:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e模糊查找: npm search 模块名\n精确查找: npm search \/^模块名$\/\n  如果现实完整描述: npm search \/^模块名$\/ --parseable\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装模块: 2个位置:\x3c\/p\x3e\n\x3cli\x3e\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e全局安装: npm install -g 模块名\x3cbr\x3e  路径: Linux: \/usr\/local\/lib\/node_modules\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   Windows:\n    C:\\Users\\用户名\\AppData\\Roaming\\npm\\node_modules\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e项目本地安装: npm install 模块名 -save\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/li\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e全局对象: \x3cbr\x3e全局作用域对象不是window，而是global\x3cbr\x3eECMAScript标准中原本规定的就是global\x3cbr\x3e在浏览器中被window代替\x3cbr\x3e强调: 交互模式: 直接在命令行中测试node应用，所有全局变量\/全局函数自动成为global的成员\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e 脚本模式: 通过加载js文件执行node应用，文件内的\x22全局变量\/全局函数\x22,仅当前文件所有，不会成为global的成员——避免了全局污染\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3econsole对象:\x3cbr\x3e测试重要手段: 打桩: 在关键位置输出关键变量的值\x3cbr\x3e输出文本信息: 浏览器中4种输出，node中合并为2中: \x3cbr\x3e  console.log\/info() 输出普通的文本信息\x3cbr\x3e  console.error\/warn() 输出错误信息\x3cbr\x3e  其实: console.xxx()都自带格式化功能\x3cbr\x3e  Console.log vs console.error: .error可直接导出到文件日志中\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e如何: node xxx.js 2\x26gt; error-file.log\n其中:2\x26gt;表示输出流，专门向硬盘文件写入内容\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出耗时: \x3cbr\x3e  Console.time(\x22标签\x22); \/\/预备，开始!\x3cbr\x3e  正常程序逻辑\x3cbr\x3e  Console.timeEnd(\x22标签\x22); \/\/完成! 自动输出与time之间的时间间隔\x3cbr\x3e单元测试:\x3cbr\x3e  什么是: 对程序中最小的执行单元进行测试\x3cbr\x3e  开发人员主动对自己的函数执行单元测试\x3cbr\x3e  如何:  console.assert(判断条件, \x22错误提示\x22)\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e               只有条件不满足时，才输出msg\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出堆栈:\x3cbr\x3e  console.trace()\x3c\/p\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3col\x3e\x3cli\x3e全局对象: process:\x3c\/li\x3e\x3c\/ol\x3e\n\x3chr\x3e\n\x3cpre\x3e\x3ccode\x3eprocess.platform\nprocess.pid\nprocess.kill(pid);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台输入输出: \x3cbr\x3e 2步:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e让控制台进入输入状态:\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eprocess.stdin.resume()\x3cbr\x3e  process.stdin.setEncoding(\x22utf-8\x22)\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e监听stdin的data事件:\x3cbr\x3e  在控制台输入后，按回车，会触发stdin的data事件\x3c\/li\x3e\x3c\/ol\x3e\n\x3cpre\x3e\x3ccode\x3e  process.stdin.on(\x22data\x22,text=\x26gt;{\n      process.stdout.write( … text … )\n    })\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台参数: \x3cbr\x3e 2步: 1. 定义关联数组,保存参数名和参数对应的处理函数\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e2. 启动时， process.argv数组可自动获得传入的所有参数，  根据参数调用不同的处理函数\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eprocess.argv: [\x22node.exe\x22,\x22xxx.js\x22,\x22参数值1\x22,\x22参数值2\x22,…]\x3c\/p\x3e\n\x3cp\x3e高精度计时: \x3cbr\x3e  精确到纳秒, 优点: 不受系统时间影响\x3cbr\x3e  如何: 2步: 1. 获得开始的时间戳: var start=process.hrtime();\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e      2. 获得结束时间戳: var diff=process.hrtime(start);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ediff: [秒数, 纳秒]\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e获得秒差: diff[0]\x2bdiff[1]\/1e9\n获得毫秒差: diff[0]*1000\x2bdiff[1]\/1e6\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVs console.time\/timeEnd: \x3cbr\x3e   time\/timeEnd: 缺: 精度低, 优: 效率高\x3cbr\x3e   hrtime: 优: 精度高,且不受系统时间影响\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e      缺点: 效率低\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e非I\/O的异步操作(定时器): \x3cbr\x3e 何时: 要执行异步回调时\x3cbr\x3e 如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3esetTimeout\/setInterval() 将回调函数添加到事件循环的timer阶段的队列中等待执行。\x3cbr\x3e   Timer阶段是事件循环的第一阶段\x3cbr\x3e   习惯上: setTimeout往往都会设置ms数\x3c\/li\x3e\n\x3cli\x3esetImmediate() 将回调函数添加到事件循环的check阶段的队列中等待执行。\x3cbr\x3e   Check阶段比Timer要晚执行\x3cbr\x3e   习惯上: 并不设置毫秒数，而是普通的追加到等待队列末尾即可。\x3c\/li\x3e\n\x3cli\x3eprocess.nextTick() 将回调函数加入nextTickQueue队列等待执行\x3cbr\x3e  nextTickQueue不参与事件循环，而是在开始timer之前，就立刻执行nextTickQueue中的回调函数\x3cbr\x3e  优点: 不会有延迟\x3c\/li\x3e\n\x3cli\x3e自定义的EventEmiter\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e5.EventEmitter类型:\x3c\/h2\x3e\n\x3cp\x3eNode.js所有异步I\/O操作完成时，都会发送一个事件到事件队列\x3cbr\x3eNode.js中许多对象都会触发事件: \x3cbr\x3e 比如: http模块: 创建Server对象，监听http请求\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   一旦收到一个http请求，则立刻触发事件，将处理函数放入事件队列\n  fs模块: 在每次读写完文件时，也会触发事件，将处理函数放入事件队列\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e什么是EventEmitter: 专门封装事件监听和事件触发的API的一种类型\x3cbr\x3e所有可以触发事件的对象，都是EventEmitter类型的子对象\x3cbr\x3e如何让一个对象可以监听并触发事件:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e引入events模块: const events=require(\x22events\x22)\x3c\/li\x3e\n\x3cli\x3e创建events.EventEmitter类型的子对象:\x3cbr\x3e  var emitter=new events.EventEmitter();\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e用on，为对象添加事件监听:\x3cbr\x3e  emitter.on(\x22自定义事件名\x22,function 处理函数(参数列表){\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e… 获得参数, 执行操作 …\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e在任何情况下，使用对象的emit方法，触发指定的事件:\x3cbr\x3e  emitter.emit(\x22自定义事件名\x22,参数值,…)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e触发一次后，自动解绑: \x3cbr\x3eemitter.once(\x22自定义事件名\x22,处理函数)\x3c\/p\x3e\n\x3cp\x3e错误处理: \x3cbr\x3e 问题: try catch无法捕获异步调用中的错误\x3cbr\x3e 解决: Domain\x3cbr\x3e 何时: 只要既希望捕获主程序错误，又希望捕获异步操作的错误时\x3cbr\x3e 如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e引入domain模块: const domain=require(\x22domain\x22)\x3c\/li\x3e\n\x3cli\x3e创建domain对象: const mpDomain=domain.create();\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e为domain对象添加error事件监听\x3cbr\x3e  mpDomain.on(\x22error\x22,err=\x26gt;{\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3econsole.log(\x22出错啦!\x22\x2berr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e将可能出错的程序放入mpDomain中运行：\x3cbr\x3e  mpDomain.run(()=\x26gt;{\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3emusicPlayer.emit(\x22play\x22);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e6.协议:\x3c\/h2\x3e\n\x3cp\x3e什么是: 计算机之间通过网络实现通信时，事先达成的一种\x22约定\x22\x3cbr\x3e 为什么: 约定使不同厂商的设备，不同操作系统之间，都可按照统一约定，任意通信\x3c\/p\x3e\n\x3ch2\x3e7.分组交换方式:\x3c\/h2\x3e\n\x3cp\x3e什么是: 将大数据分割为一个个叫做包(packet)的较小单元进行传输\x3c\/p\x3e\n\x3ch2\x3e8.ISO\/OSI模型:\x3c\/h2\x3e\n\x3cp\x3eISO(国际标准化组织)\x3cbr\x3e OSI(开放式通信系统互联参考模型)\x3cbr\x3e  7层:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e应用层: 规定应用程序中的通信细节\x3cbr\x3e 包括: HTTP  FTP   TELNET    SMTP    DNS\x3c\/li\x3e\n\x3cli\x3e表示层: 负责数据格式的转换\x3c\/li\x3e\n\x3cli\x3e会话层: 建立连接\x3c\/li\x3e\n\x3cli\x3e传输层: 控制总体数据传输\x3cbr\x3e 包括: \x3cbr\x3e  TCP(传输控制协议): 可靠传输  \x3cbr\x3e   优: 可靠，客户端和服务端可双向通信\x3cbr\x3e   缺: 传输效率低\x3cbr\x3e   何时: 要求可靠性时\x3cbr\x3e  UDP(用户数据报协议): \x3cbr\x3e   何时: 对可靠性要求不高，对传输效率要求高，且发送小数据(qq, 微信, 在线视频播放)\x3c\/li\x3e\n\x3cli\x3e网络层: 将数据分组传输到目的地\x3c\/li\x3e\n\x3cli\x3e数据链路层: 负责规划网络中节点间的路线\x3c\/li\x3e\n\x3cli\x3e物理层: 负责通过以太网，蓝牙，光纤发送0\/1的比特流\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e9.TCP\/IP: 互联网协议套件\x3c\/h2\x3e\n\x3cp\x3e包含: TCP 传输控制协议\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   IP 互联网协议\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eTCP\/IP不是ISO标准\x3cbr\x3e  TCP\/IP 只有四层: \x3c\/p\x3e\n\x3cp\x3e鄙视:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eTCP\/IP四层协议，分别对应ISO\/OSI中的哪一层: 图6\x3c\/li\x3e\n\x3cli\x3e网络建立连接需要3次握手，断开连接需要4次握手，分别是:\x3cbr\x3e 图7\x3c\/li\x3e\n\x3cli\x3eHTTP\/1.0  1.1   2.0每次升级有哪些不同\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e10.net模块:\x3c\/h2\x3e\n\x3cp\x3e使用net模块:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e可创建基于TCP的客户端与服务器端通信\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e创建TCP服务器: \x3cbr\x3e  引入net模块\x3cbr\x3e  使用net.createServer方法创建服务端对象server\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e接受一个回调函数作为参数:\n 只要有客户端连接到当前服务端，就自动执行该回调函数\n 回调函数接受一个socket参数对象，用于与客户端通信\n Socket对象: 是客户端在服务器端的一个代理对象\n            可通过socket和真正的客户端发送和接受消息\n Socket对象的data事件，可监听客户端发来的消息\n   回调函数中, data参数为消息的内容\n Socket对象的end事件，可监听客户端的断开\n Socket的write方法向客户端输出消息\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e调用server的listen方法，绑定到一个端口，监听客户端发来的链接请求\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e也接受一个回调函数参数，但仅在启动监听后执行一次\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建TCP客户端: \x3cbr\x3e  引入net模块\x3cbr\x3e  使用net.connect()方法向服务器建立连接\x3cbr\x3e   var client=net.connect(服务端端口,ip,function(){})\x3cbr\x3e   回调函数在连接建立后，自动触发一次\x3cbr\x3e  为client的data事件绑定处理函数，处理函数的data参数自动接收服务端发来的消息\x3cbr\x3e  为client的end事件添加处理函数，当客户端断开连接时执行操作\x3cbr\x3e  在任何位置可用client.write(\x22消息内容\x22)向服务端发送\x3cbr\x3e  在任何位置可用client.end() 断开与服务端连接\x3c\/p\x3e\n\x3ch2\x3e11.HTTP模块:\x3c\/h2\x3e\n\x3cp\x3e使用HTTP模块:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e实现WEB服务器，接受请求并返回响应（代替了apache,tomcat）\x3c\/li\x3e\n\x3cli\x3e模拟客户端向一个指定的WEB服务器发送请求\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e创建HTTP服务端: \x3cbr\x3e  引入HTTP模块\x3cbr\x3e  创建HTTP服务端server:\x3cbr\x3e   var server=http.createServer(function(req,res){\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e \/\/只要有请求发送到该服务器，就自动触发该回调函数\n \/\/其中: \n   \/\/req对象，封装了发来的请求信息\n   \/\/res对象，专门用于向服务器端返回响应\n    \/\/res.writeHead(状态码,{ 属性:值, …:… ,…})\n    \/\/res.write(\x22放入响应主体中\x22)\n    \/\/res.end()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3cbr\x3e  启动监听: server.listen(端口,function(){ … })\x3c\/p\x3e\n\x3cp\x3e创建HTTP请求: \x3cbr\x3e  使用http.request()方法创建一个请求(连接)，获得请求对象req\x3cbr\x3e   接收2个参数:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eoptions对象参数:\n host\n port\n method\n path  \/index.html?page=12\n回调函数: 在服务器端返回响应时执行\n 参数res: 专门用于获得响应内容(响应头和响应主体)\n  HTTP协议规定: 先发响应头部 用res.headers获得响应头部对象，用res.statusCode 获得状态码\n  强调: 响应主题是稍后才发送过来\n   必须用res.on(\x22data\x22,function(buffer){ … String(buffer) …})\n  强调: 凡是从响应中获得的data，默认都是字符串\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ereq.end()结束并发送请求。\x3cbr\x3e   强调:必须加req.end()，请求才能发送出去\x3c\/p\x3e\n\x3cp\x3ehttp.get()\x3cbr\x3e  专门向服务器端发送get请求\x3cbr\x3e  是http.request()的简化:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e自动设置method为get;\x3c\/li\x3e\n\x3cli\x3e自动调req.end\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e但依然需要使用res.on(\x22data\x22,function(buffer){ … })来接受响应主体\x3c\/p\x3e\n\x3cp\x3e分块: \x3cbr\x3e  问题: 如果响应主体过大，一次性传不过来\x3cbr\x3e  解决:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   分块发送和接受，再拼接，再整体转换\n   如果分块接受，res.on(\x22data\x22,function(buf){ … })每收到一块，就会反复触发。\n   其中buf，仅是其中一块而已\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请求文件，保存在本地: \x3cbr\x3e  引入fs模块: \x3cbr\x3e  创建写入流，指向目标文件: var writable=fs.createWriteStream(\x22相对路径\x22)\x3cbr\x3e  使用管道，将写入流writable连接到res对象上: res.pipe(writable)\x3c\/p\x3e\n\x3cp\x3e响应头部: res.writeHead(状态码,{ })\x3cbr\x3e   允许跨域: \x22Access-Control-Allow-Origin\x22:\x22请求来源的网站\x22\x3cbr\x3e   指定内容类型:\x22Content-Type\x22:\x22application\/json\x22  \x22text\/css\x22\x3c\/p\x3e\n\x3cp\x3ereq对象: \x3cbr\x3e  请求头部: req.headers\x3cbr\x3e  请求方法: req.method\x3cbr\x3e  请求地址: req.url\x3cbr\x3e   url的处理:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e引入url模块\n用url.parse(req.url,true)将req.url字符串转为对象\n 其中true,表示将search中的参数也转为对象属性\n 如何: var obj=url.parse(req.url, true)\n  其中: obj.query中保存了所有参数及其值\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e获得请求参数: \x3cbr\x3e  Get: get方式的参数都通过url中的search传递\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e  obj=url.parse(req.url,true)\n  obj.query\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePost: post方式的参数都是放在请求主体中，没有在url中\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e  问题:obj.query无法获得\n  解决: req.on(\x22data\x22,function(buf){ … })\n  问题: String(buf)获得的是参数的字符串\n  解决: querystring模块\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e12.https模块:\x3c\/h2\x3e\n\x3cp\x3e问题: http协议是明文的\x3cbr\x3e  危害: 1. 通信使用明文，内容可能被窃听\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e   2. 不验证身份，有可能遭遇伪装\n   3. 无法证明消息的完整性，消息有可能被篡改\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e网络嗅探器:\x3c\/p\x3e\n\x3ch2\x3e13.解决: https协议\x3c\/h2\x3e\n\x3cp\x3ehttps是更安全的http协议:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e客户端和服务器端的双向认证\x3c\/li\x3e\n\x3cli\x3e完整性检查\x3c\/li\x3e\n\x3cli\x3e内容加密\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3ehttps=http\x2bssl\x3c\/p\x3e\n\x3cp\x3essl\/tls: ssl 安全套接层，对传统socket进一步提供安全的保护\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e tls 传输层安全, 其实是ssl的继任者\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e14.提供三大服务:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e客户端和服务器端的双向认证 ——可靠\x3c\/li\x3e\n\x3cli\x3e完整性检查 ——完整\x3c\/li\x3e\n\x3cli\x3e数据加密   ——机密性\x3cbr\x3etls\/ssl的执行过程:\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e15.Step0: 获得服务器端证书, 3步:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e在服务器端生成私钥\x3c\/li\x3e\n\x3cli\x3e用私钥生成一个证书申请文件\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e将私钥和申请文件交给第三方CA，第三方CA经过审查，会生成并颁发证书给申请的服务器\x3cbr\x3e  证书包含2样东西: 公钥\x2b公司的信息\x3cbr\x3eStep1: 客户端请求https协议的web服务器\x3cbr\x3eStep2: 服务器返回证书给客户端\x3cbr\x3eStep3: 客户端拿到证书后，将证书交给CA。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e  客户端利用CA中的公钥随机生成自己的私钥\n  将私钥发给服务器端\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStep4: 服务器端获得客户端发来的客户端私钥\x3cbr\x3e到此，客户端和服务器端，拥有了相同的两个钥匙\x3cbr\x3e之后，服务器和客户端发送的所有消息，都用两个相同的私钥加密和解密\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e16.如何实现https的web服务器应用:\x3c\/h2\x3e\n\x3col\x3e\x3cli\x3e申请https网站的认证证书：\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eStep1: 用openssl生成服务器端私钥:\x3cbr\x3e openssl  genrsa  -out  d:\/privatekey.pem  1024\x3cbr\x3e   Step2: 用私钥生成证书申请文件:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eopenssl  req  -new  -key  d:\/privatekey.pem  -out  d:\/certificaterequest.csr\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStep3: 用私钥和证书申请文件共同生成证书文件\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eopenssl  x509  -req  -in  d:\/certificaterequest.csr  -signkey  \nd:\/privatekey.pem   -out  d:\/certificate.pem\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2.使用node的https模块创建服务器\x3cbr\x3eStep1: 引入必须的模块: \x3cbr\x3econst https=require(“https”);\x3cbr\x3econst fs=require(“fs”);\x3cbr\x3e   Step2:读取服务器私钥和证书文件，保存到服务器程序的变量中\x3cbr\x3elet privatekey=fs.readFileSync(“d:\/privatekey.pem”);\x3cbr\x3elet certificate=fs.readFileSync(“d:\/certificate.pem”);\x3cbr\x3e   Step3: 用https创建服务器端应用程序，提供私钥和证书，并定义处理请求的回调函数\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ehttps.createServer(\n  {\n    key: privatekey,\n    cert: certificate\n},\n(req,res)=\x26gt;{\n  res.write(“…”)\n  res.end();\n}\n).listen(443)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.用https模块向https的服务器发送请求\x3cbr\x3e错误: http模块不支持向https服务器发送请求\x3cbr\x3e正确: \x3c\/p\x3e\n\x3cp\x3evar https=require(“https”);\x3cbr\x3e https.get(“\x3ca href=\x22https:\/\/...\x22 rel=\x22nofollow noreferrer\x22\x3ehttps:\/\/...\x3c\/a\x3e”, res=\x26gt;{\x3cbr\x3e   res.on(“data”,buf=\x26gt;{\x3cbr\x3e buf…\x3cbr\x3e})\x3cbr\x3e})\x3c\/p\x3e\n\x3ch2\x3e17.express\x3c\/h2\x3e\n\x3cp\x3e什么是: 基于node的http模块和第三方的Connect框架的web框架\x3cbr\x3eConnect框架: 专门将各种各样的中间件函数粘合在一起，共同处理http请求中的req对象\x3cbr\x3e 何时: 只要对req对象反复执行多种操作时，都要用connect组织多个中间件。\x3cbr\x3e 如何: \x3c\/p\x3e\n\x3cp\x3eStep1: 安装connect模块:  npm install connect –save\x3c\/p\x3e\n\x3cp\x3eStep2: 引入connect模块: var connect=require(“connect”)\x3c\/p\x3e\n\x3cp\x3eStep3: 用connect模块创建处理req对象的应用程序实例var app=connect();\x3c\/p\x3e\n\x3cp\x3eStep4: 向connect模块的应用程序实例中添加中间件函数\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e  app.use(function md1(req,res,next){\n  \/\/加工req对象\n  … …\n  next();\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStep5: connect的应用程序实例，必须要放入createServer中用于处理服务器接收到的req对象\x3cbr\x3e   http.createServer(app)\x3cbr\x3e总结: express是在connect基础上的进一步封装和简化，所以express也是采用中间件组合的方式，处理req对象\x3cbr\x3e安装express框架: 2种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用本地express模块，进能够提供服务支持，需要自定义添加复杂的程序结构\x3cp\x3eStep1: npm install –save express\x3cbr\x3eStep2: 引入http和express\x3cbr\x3e  const http=require(“http”);\x3cbr\x3e  const express=require(“express”);\x3cbr\x3eStep3: 创建express应用实例对象:\x3cbr\x3e  let app=express();\x3cbr\x3eStep4: 为app添加各种处理中间件函数\x3cbr\x3e  app.use(function md(req,res,next){ … …})\x3cbr\x3e   Step5: 将app和createServer相连\x3cbr\x3e   http.createServer(app).listen(端口号);\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e使用脚手架, 简化生成项目的结构:\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eStep1: 全局安装express生成器:\x3cbr\x3e npm install –g express-generator\x3c\/p\x3e\n\x3cp\x3eStep2: 用生成器，生成项目脚手架代码:\x3cbr\x3eexpress 项目文件夹名 –e  \/\/-e 表示用EJS作为前端页面模板\x3cbr\x3e强调: 只负责生成项目代码，并不负责下载依赖包\x3c\/p\x3e\n\x3cp\x3eStep3: 为脚手架代码下载所有依赖包\x3cbr\x3ecd 项目文件夹下\x3cbr\x3enpm  install  \/\/根据package.json中的依赖项\x3c\/p\x3e\n\x3cp\x3eStep4: 用脚手架代码启动nodejs服务器端应用程序: npm start\x3c\/p\x3e\n\x3cp\x3eexpress项目结构:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e.\/bin\/www.js   express项目的启动文件\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3epackage.json中: npm start 时 自动执行  node .\/bin\/www\x3c\/p\x3e\n\x3cp\x3e2.\/app.js  对express框架的实例对象的配置\x3cbr\x3e要求: 对express实例对象app的所有配置必须放在一个独立的文件模块app.js中\x3cbr\x3e然后，在主程序www.js中引入app.js模块\x3c\/p\x3e\n\x3cp\x3e3..\/routes\/xxx.js 路由模块\x3cbr\x3e每个子功能，都应该集中定义在一个路由模块文件中\x3cbr\x3e在app.js中引入路由文件模块，并将路由文件模块添加到app的中间件列表中，并设置上级路径\x3cbr\x3e在每个子路由模块文件中，创建路由对象，为路由对象添加不同请求方法和不同子路径下的处理函数\x3cbr\x3e强调: 子路由中的相对路径，都是在上级路径之下的相对路径\x3c\/p\x3e\n\x3cp\x3e改造脚手架项目结构:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e补充缺失的模块:\x3cbr\x3eexpress-session   让express可以处理session\x3cbr\x3econnect-flash    强化自动维护session的功能\x3cbr\x3epassport        综合的用户验证解决方案\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e         ( 使用passport模块，实现qq，微信登录)\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e在app.js中添加对新模块的引用:\x3c\/li\x3e\n\x3cli\x3e为项目添加mongodb支持\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eStep1: 安装mongoose模块和promise模块\x3cbr\x3e mongoose: node js专用的简化操作mongodb数据库的模块\x3c\/p\x3e\n\x3cp\x3eStep2: 创建文件夹.\/config，在文件夹下添加config.js\x3cbr\x3e 在config.js中定义对象模块，保存连接字符串\x3cbr\x3e module.exports={\x3cbr\x3e   db:”mongodb:\/\/主机名或ip\/数据库名”}\x3c\/p\x3e\n\x3cp\x3eStep3:  在.\/config文件夹下创建mongoose.js，保存创建连接对象的代码:\x3cbr\x3e var config=require(\x27.\/config\x27),\x3cbr\x3e mongoose=require(\x27mongoose\x27);\x3cbr\x3e  设置mongoose的promise属性，使用当前项目的promise模块\x3cbr\x3e mongoose.Promise=require(‘promise’);\x3cbr\x3e var db=mongoose.connect(config.db) module.exports=db;\x3c\/p\x3e\n\x3cp\x3eStep4:  根据业务需要，定义mongoose模型对象: \x3cbr\x3e创建.\/models文件夹, 在models内为每种业务对象创建专门的模型文件\x3c\/p\x3e\n\x3cp\x3e3步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e引入mongoose，获得Schema类型\x3c\/li\x3e\n\x3cli\x3e用Schema创建UserSchema结构\x3c\/li\x3e\n\x3cli\x3e将UserSchema编译为User模型，并抛出为User模块\x3cbr\x3eStep5: 回到mongoose.js中，在connect之后，引入User模块require(\x27..\/models\/user.model\x27);\x3cbr\x3eStep6: 回到app.js中，在路由中间件之前，先请求并初始化mongoose.jsrequire(\x22.\/config\/mongoose\x22);\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>后端知识点总结——NODE.JS（高级）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014534808">https://segmentfault.com/a/1190000014534808</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/2oty6g9skb6/" target="_blank">https://alili.tech/archive/2oty6g9skb6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>