<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tutorial: 在React中使用GraphQL mutation"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Tutorial: 在React中使用GraphQL mutation | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/32ffef6d/",
				"appid": "1613049289050283", 
				"title": "Tutorial: 在React中使用GraphQL mutation | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-21T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/c0dd4948/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/28e8dc11/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&text=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&text=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&title=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&is_video=false&description=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&title=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&title=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&title=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f32ffef6d%2f&title=Tutorial%3a%20%e5%9c%a8React%e4%b8%ad%e4%bd%bf%e7%94%a8GraphQL%20mutation"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Tutorial: 在React中使用GraphQL mutation</h1><div class="meta"><div class="postdate"><time datetime="2018-10-21" itemprop="datePublished">2018-10-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e在本教程中，您将学习如何使用简单的mutation来修改服务器上的数据并保持客户端上的状态同步。 具体来说，我们将创建一个将项目添加到列表的mutation。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011484902f00001a99.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e本文是关于GraphQL \x2b React的教程系列的一部分。 以下是其他部分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b\x22\x3ePart 1 —前端: 用GraphQL读取声明性数据\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-part-2-server-99d0528c7928\x22\x3ePart 2 — 服务器端: 分五步设置一个简单的GraphQL服务器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3ePart 3 —Mutations (您正在阅读的这一章)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3ePart 4 — 友好的的UI和客户端存储更新的mutation\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/medium.com\/p\/tutorial-graphql-input-types-and-client-caching-f11fa0421cfd\x22\x3ePart 5 —输入类型和自定义解析器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-server-side-e51c32dc2951\x22\x3ePart 6 — 服务器订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76\x22\x3ePart 7 —客户端上的GraphQL订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823\x22\x3ePart 8 — 分页\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在本教程中，我们将执行以下操作：\x3c\/p\x3e\n\x3cp\x3e1.将我们的前端连接到服务器\n2.在服务器上定义GraphQL变化\n3.从客户端上的React组件调用GraphQL变体\x3c\/p\x3e\n\x3cp\x3e更新客户端上的状态以确保它与服务器同步每个步骤都非常简单，因此完成整个教程只需要25分钟。如果你还没有完成第1部分和第2部分，你可以先做或者直接跳到这里，并从GitHub仓库中查看本教程的开始状态：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3egit \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehttps\x3c\/span\x3e:\/\/github.com\/apollographql\/graphql-tutorial.gitcd graphql-tutorialgit fetchgit checkout t3-\x3cspan class=\x22hljs-literal\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e我建议你查看t3-start分支，即使你已经完成了第1和第2部分，因为我们已经对App.css和App.js进行了一些修改，以改善应用的布局和文件夹结构。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e要检查是否有效，让我们启动GraphQL服务器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servernpm install \x26amp;\x26amp; npm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e# ...# GraphQL Server is now running on http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost:4000\/graphiql\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们还要在一个单独的控制台中启动为我们的前端软件包提供服务的dev服务器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs apache\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e# assuming that you\x27re in the graphql-tutorial directory\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e clientnpm install \x26amp;\x26amp; npm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e# ...# The app is running at:##    http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost:3000\/\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果它有效，你已经准备好写下你的第一个 mutation!\x3c\/p\x3e\n\x3ch4\x3e1. 将前端连接到服务器\x3c\/h4\x3e\n\x3cp\x3e在上一篇教程中，我们构建了我们的服务器，但是我们没有将它连接到我们的前端。 为此，我们只需要在服务器和客户端上进行两个较小的更改。\x3c\/p\x3e\n\x3cp\x3e由于服务器在端口400o上运行，客户端从端口3000上运行，因此我们需要在服务器上启用 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Access_control_CORS\x22\x3eCORS\x3c\/a\x3e。 在本教程中，我们将使用Express \/ Connect的cors包：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs apache\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e# in the server directory (not the client!!)\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs sql\x22\x3enpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e--save cors\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在我们只需在server\/server.js中导入cors并修改以下行以允许来自我们前端源的跨源请求：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e ...\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e cors \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27cors\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs ada\x22\x3e\/\/ ... const server = express();server.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e, cors({ origin: \x3cspan class=\x22hljs-symbol\x22\x3e\x27http\x3c\/span\x3e:\/\/localhost:\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e\x27 }));\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在前端，我们需要从react-apollo导入createNetworkInterface，然后用连接到服务器的mockNetworkInterface替换它：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e client\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eApp.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {  ApolloClient,  ApolloProvider,  createNetworkInterface, \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x26lt;-- \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e line \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e!} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-apollo\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e您可以删除用于创建mockNetworkInterface（包括导入）的所有代码，并将其替换为以下代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst networkInterface\x3c\/span\x3e = createNetworkInterface({   uri: \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:4000\/graphql\x27\x3c\/span\x3e,});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst\x3cspan class=\x22hljs-built_in\x22\x3e client \x3c\/span\x3e= new ApolloClient({  networkInterface,});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e您的客户端现在已连接到服务器，您应该看到以下信息 \x3ca href=\x22http:\/\/localhost:3000\/\x22\x3elocalhost:3000\x3c\/a\x3e:\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0161d8feb30dff6503.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e2. 在服务器上定义GraphQL mutation\x3c\/h4\x3e\n\x3cp\x3e现在客户端连接到服务器，我们可以开始真正的任务 - 编写一个mutation，将channel添加到我们的channel列表中。\x3c\/p\x3e\n\x3cp\x3e首先，我们将通过将其添加到server \/ src \/ schema.js中来定义模式中的mutation：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst typeDefs =\x3cspan class=\x22hljs-built_in\x22\x3e type \x3c\/span\x3eChannel {  id: ID!                # \x3cspan class=\x22hljs-string\x22\x3e\x22!\x22\x3c\/span\x3e denotes a required field  name: String}type Query {  channels: [Channel]    # \x3cspan class=\x22hljs-string\x22\x3e\x22[]\x22\x3c\/span\x3e means this is a list of channels}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs ocaml\x22\x3e# \x3cspan class=\x22hljs-type\x22\x3eThe\x3c\/span\x3e mutation root \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, used \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e define all mutations.\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMutation\x3c\/span\x3e {  # \x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e mutation \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e add a \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e channel \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e the \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e channels  addChannel(name: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eChannel\x3c\/span\x3e};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们刚刚添加的新Mutation类型定义了一个单一mutation - addChannel - 它只接受一个参数，即新channel的名称。 mutation返回一个channel对象，然后我们可以选择字段，就像查询一样。 以下是一个有效的mutation示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs less\x22\x3e# \x3cspan class=\x22hljs-selector-tag\x22\x3ean\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eexample\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3emutation\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ecall\x3c\/span\x3e\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:mutation\x3c\/span\x3e {  \x3cspan class=\x22hljs-selector-tag\x22\x3eaddChannel\x3c\/span\x3e(\x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22basketball\x22\x3c\/span\x3e){    \x3cspan class=\x22hljs-selector-tag\x22\x3eid\x3c\/span\x3e    \x3cspan class=\x22hljs-selector-tag\x22\x3ename\x3c\/span\x3e  }}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当然，除非我们为它定义一个解析器函数，否则这个mutation不会做任何事情。 我们的解析函数存在于server\/src\/resolvers.js中，所以让我们来看看并为我们的新addChannel mutation添加一个解析函数。 解析函数必须将提供的名称作为参数，并在将其添加到现有列表之前为新channel生成一个ID。\x3c\/p\x3e\n\x3cp\x3e让我们更改server\/src\/resolvers.js以添加新的nextId变量并为Mutation.addChanel定义解析器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nix\x22\x3econst \x3cspan class=\x22hljs-attr\x22\x3echannels\x3c\/span\x3e = \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3enextId\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e const resolvers = {  Query: {    channels: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e channels;\n},  },  Mutation: {    addChannel: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(root, args)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      const newChannel = { id: nextId\x2b\x2b, name: args.name };\nchannels.push(newChannel);\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newChannel;\n},  },};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如你所看到的，解析器只是推动一个新的channel到channels，递增nextId并返回新创建的channel。 如果你前往 \x3ca href=\x22http:\/\/localhost:4000\/graphiql?query=mutation%20%7B%0A%20%20addChannel%28name%3A%20%22basketball%22%29%7B%0A%20%20%20%20id%0A%20%20%20%20name%0A%20%20%7D%0A%7D\x22\x3elocalhost:4000\/graphiql\x3c\/a\x3e, 你应该能够从上面运行示例mutation并获得响应。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01bb856a60cb422b56.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e如果您在localhost：3000上重新加载客户端应用程序，您现在应该看到“basketball”channel出现。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011c9d222ab8a531d0.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3eNote:\x3c\/strong\x3e channels目前仅存储在内存中，因此每次重新启动服务器时，新添加的channel都将消失。 我们将在未来的教程中将事物与持久存储挂钩。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch4\x3e3. 从React组件调用 mutation\x3c\/h4\x3e\n\x3cp\x3e现在我们已经验证了mutation在服务器上运行，让我们编写必要的代码从客户端调用它。 首先，我们将在src\/components\/AddChannel.js中创建一个输入组件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst AddChannel = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  const handleKeyUp = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(evt)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (evt.keyCode === \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e) {      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(evt.target.value);\nevt.target.value = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n}  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (      );};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3eAddChannel;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们的AddChannel组件非常简单。 到目前为止，它只包含一个文本输入元素和一个handleKeyUp函数，该函数将输入文本输出到控制台，并在用户返回时清除输入字段（代码13）。\x3c\/p\x3e\n\x3cp\x3e让我们将其导入到src\/components\/ChannelsListWithData.js中，并将其放置在我们的channel列表之前：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e AddChannel \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/AddChannel\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e...\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs moonscript\x22\x3econst ChannelsList = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e({ data: {loading, \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e, channels }})\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (loading) {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Loading ...;\n}  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e) {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e.message};\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs lisp\x22\x3e  return (           \x3cspan class=\x22hljs-name\x22\x3e\/\/\x3c\/span\x3e \x26lt;-- This is the new line.      { channels.map( \x3cspan class=\x22hljs-name\x22\x3ech\x3c\/span\x3e =\x26gt;         ({ch.name})      )}      )\x3cspan class=\x22hljs-comment\x22\x3e;};\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果有效，您现在应该在用户界面中看到“新channel”输入：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011736da21ef950b38.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e为了使我们的输入组件调用GraphQL mutation，我们必须将它与来自react-apollo的GraphQL高阶组件（HOC）连接起来 (\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b#573b\x22\x3e就像我们在第一篇教程中所做的一样\x3c\/a\x3e). 对于mutation，graphql HOC传递一个mutate prop，我们将调用它来执行mutation。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { gql, graphql } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-apollo\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e AddChannel = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ mutate }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handleKeyUp = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (evt.keyCode === \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e) {      evt.persist();\nmutate({         \x3cspan class=\x22hljs-attr\x22\x3evariables\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: evt.target.value }      })      .then( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {        evt.target.value = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n});\n}  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (      );};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3econst addChannelMutation = gql  mutation addChannel($\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e: String!) {    addChannel(\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e: $\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e) {      \x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e      \x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e    }  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs lisp\x22\x3econst AddChannelWithMutation = graphql(  \x3cspan class=\x22hljs-name\x22\x3eaddChannelMutation\x3c\/span\x3e)(\x3cspan class=\x22hljs-name\x22\x3eAddChannel\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3eAddChannelWithMutation;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e让我们看看它是否工作并在输入框中输入内容。 在你进入后文字消失了吗？ 如果确实如此，mutation是成功的，您应该在重新加载页面后看到该项目。 当然，不得不重新加载页面并不是一个很好的用户交互，因此在下一节中，我们将了解为什么Apollo无法知道mutation意味着什么，以及我们需要拿新项目做什么来使列表重新呈现。\x3c\/p\x3e\n\x3ch4\x3e4. 更新客户端状态使用mutation\x3c\/h4\x3e\n\x3cp\x3e我们的channel列表没有自动重新呈现的原因是，Apollo无法知道我们刚刚调用的mutation与呈现我们列表的频道查询有任何关系。 只有服务器知道，但它没有办法通知我们的客户 (为此我们需要一个\x3ca href=\x22https:\/\/medium.com\/p\/new-release-of-graphql-subscriptions-for-javascript-f11be19e6569\x22\x3e订阅\x3c\/a\x3e, 我们将在未来的教程中介绍).\x3c\/p\x3e\n\x3cp\x3e要在突变后更新客户端状态，我们有三种选择：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/dev.apollodata.com\/react\/cache-updates.html#refetchQueries\x22\x3eRefetch\x3c\/a\x3e 可能受mutation影响的查询\x3c\/li\x3e\n\x3cli\x3e基于mutation结果手动 \x3ca href=\x22http:\/\/dev.apollodata.com\/react\/mutations.html#update-after-mutation\x22\x3e更新客户端状态\x3c\/a\x3e \x3c\/li\x3e\n\x3cli\x3e使用 GraphQL \x3ca href=\x22https:\/\/medium.com\/p\/new-release-of-graphql-subscriptions-for-javascript-f11be19e6569\x22\x3e订阅\x3c\/a\x3e 来通知我们更新\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e重新读取选项是迄今为止最简单的一种，它是让应用程序快速运行的好方法，所以我们现在就会这样做。\x3c\/p\x3e\n\x3cp\x3e为了告诉Apollo Client我们想要在我们的mutation完成后重新获取channel，我们通过调用中的refetchQueries选项将它传递给mutate。 我们将从ChannelsListWithData.js中导出并将其导入AddChannel.js中，而不是再次写入频道查询。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs 1c\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ AddChannel.js\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e ...\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { channelsListQuery } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/ChannelsListWithData\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e...\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e    mutate({       \x3cspan class=\x22hljs-string\x22\x3evariables:\x3c\/span\x3e { \x3cspan class=\x22hljs-string\x22\x3ename:\x3c\/span\x3e evt.target.value },      \x3cspan class=\x22hljs-string\x22\x3erefetchQueries:\x3c\/span\x3e [ { \x3cspan class=\x22hljs-string\x22\x3equery:\x3c\/span\x3e channelsListQuery }], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;-- new    })\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e...\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，如果我们添加一个新频道，列表应该立即刷新！\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01134f4c61f4ef1016.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e就是这样; 你已经实现了我们的第一个GraphQL mutation！ \x3c\/p\x3e\n\x3cp\x3e当然，这只会在您进行变更后更新UI。 如果mutation是由另一个客户端发起的，那么直到您做出自己的mutation并从服务器重新获取列表，您才会发现。 大多数情况下，这不是问题，但对于实时应用程序，Apollo有一个很好的技巧，可以向程序员几乎毫不费力地透明地向所有客户端传播更新：轮询查询。\x3c\/p\x3e\n\x3cp\x3e为了打开它，只需将src \/ components \/ ChannelsListWithData.js中的channelsListQuery传递给pollInterval选项即可：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3egraphql(channelsListQuery, {  options: { pollInterval: 5000 },})(ChannelsList);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e有了这个简单的变化，Apollo会每5秒重新运行一次查询，并且您的用户界面将更新最新的channel列表。 您可以通过打开一个新的浏览器窗口并在其中添加一个channel来进行测试。 新的channel应该在一小段延迟后出现在另一个窗口中。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e恭喜，您已经在GraphQL \x2b React教程的第三步中结束了！ 您已经为GraphQL模式添加了一个mutation，为其编写了一个解析器，并从React组件中调用了mutation，并确保通过重新调取和轮询来更新UI。 结合本教程系列的第1和第2部分，您现在已经熟悉了使用Apollo编写完整的React \x2b GraphQL应用程序的所有基本知识。\x3c\/p\x3e\n\x3cp\x3e要了解如何使您的mutation更加高效并且显然更快，请继续下一部分，您将了解良好的的用户界面和存储更新！\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ePart 4:\x3c\/strong\x3e \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3e具有良好的用户界面和客户端存储更新的GraphQL mutation\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cem\x3e如果您喜欢本教程并想继续学习Apollo和GraphQL，请务必点击下面的“关注”按钮，并在Twitter上关注我们 [\x3c\/em\x3e@apollographql_](\x3ca href=\x22https:\/\/twitter.com\/apollographql\x22\x3ehttps:\/\/twitter.com\/apollographql\x3c\/a\x3e) \x3cem\x3eand\x3c\/em\x3e \x3ca href=\x22https:\/\/twitter.com\/helferjs\x22\x3e\x3cem\x3e@helferjs\x3c\/em\x3e\x3c\/a\x3e_._\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01e7df7341936f1cad.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/tutorial-graphql-mutations-with-react">www.zcfy.cc</a> 原文标题: Tutorial: 在React中使用GraphQL mutation 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/32ffef6d/" target="_blank">https://alili.tech/archive/32ffef6d/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>