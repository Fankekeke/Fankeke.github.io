<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webpack配置"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webpack配置 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/37kkml4eopd/",
				"appid": "1613049289050283", 
				"title": "webpack配置 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-11-29T09:34:56"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/eb0xdfxfdet/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dwajbk6ehhh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&text=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&text=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&title=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&is_video=false&description=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webpack%e9%85%8d%e7%bd%ae&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&title=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&title=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&title=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f37kkml4eopd%2f&title=webpack%e9%85%8d%e7%bd%ae"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webpack配置</h1><div class="meta"><div class="postdate"><time datetime="2018-11-29" itemprop="datePublished">2018-11-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ewebpack配置\x3c\/h1\x3e\n\x3cblockquote\x3e查看所有文档页面：\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/2%E9%85%8D%E7%BD%AE\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e全栈开发\x3c\/a\x3e，获取更多信息。\x3cp\x3e原文链接：\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/2%E9%85%8D%E7%BD%AE\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第2章 配置\x3c\/a\x3e，原文广告模态框遮挡，阅读体验不好，所以整理成本文，方便查找。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e配置 Webpack 的方式有两种：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e通过一个 JavaScript 文件描述配置，例如使用 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 文件里的配置；\x3c\/li\x3e\n\x3cli\x3e执行 Webpack 可执行文件时通过命令行参数传入，例如 \x3ccode\x3ewebpack --devtool source-map\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这两种方式可以相互搭配，例如执行 Webpack 时通过命令 \x3ccode\x3ewebpack --config webpack-dev.config.js\x3c\/code\x3e 指定配置文件，再去 \x3ccode\x3ewebpack-dev.config.js\x3c\/code\x3e 文件里描述部分配置。\x3c\/p\x3e\n\x3cp\x3e按照配置\x3cstrong\x3e所影响的功能\x3c\/strong\x3e来划分，可分为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3eEntry\x3c\/strong\x3e 配置模块的入口；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eOutput\x3c\/strong\x3e 配置如何输出最终想要的代码；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eModule\x3c\/strong\x3e 配置处理模块的规则；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eResolve\x3c\/strong\x3e 配置寻找模块的规则；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3ePlugins\x3c\/strong\x3e 配置扩展插件；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eDevServer\x3c\/strong\x3e 配置 DevServer；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e其它配置项\x3c\/strong\x3e 其它零散的配置项；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e整体配置结构\x3c\/strong\x3e 整体地描述各配置项的结构；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e多种配置类型\x3c\/strong\x3e 配置文件不止可以返回一个 Object，还有其他返回形式；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e配置总结\x3c\/strong\x3e 寻找配置 Webpack 的规律，减少思维负担。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eEntry\x3c\/h2\x3e\n\x3cp\x3eWebpack 在寻找相对路径的文件时会以 context 为根目录，context 默认为执行启动 Webpack 时所在的当前工作目录。\x3c\/p\x3e\n\x3cp\x3e如果想改变 context 的默认配置，可以在配置文件里设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  context: path.resolve(__dirname, \x27app\x27)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  context: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意， context 必须是一个绝对路径的字符串。 除此之外，还可以通过在启动 Webpack 时带上参数 \x3ccode\x3ewebpack --context\x3c\/code\x3e 来设置 context。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eChunk 名称\x3c\/h3\x3e\n\x3cp\x3eWebpack 会为每个生成的 Chunk 取一个名称，Chunk 的名称和 Entry 的配置有关：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果 entry 是一个 \x3ccode\x3estring\x3c\/code\x3e 或 \x3ccode\x3earray\x3c\/code\x3e，就只会生成一个 Chunk，这时 Chunk 的名称是 \x3ccode\x3emain\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e如果 entry 是一个 \x3ccode\x3eobject\x3c\/code\x3e，就可能会出现多个 Chunk，这时 Chunk 的名称是 \x3ccode\x3eobject\x3c\/code\x3e 键值对里键的名称。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e配置动态 Entry\x3c\/h3\x3e\n\x3cp\x3e假如项目里有多个页面需要为每个页面的入口配置一个 Entry ，但这些页面的数量可能会不断增长，则这时 Entry 的配置会受到到其他因素的影响导致不能写成静态的值。其解决方法是把 Entry 设置成一个函数去动态返回上面所说的配置，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 同步函数\nentry: () =\x3e {\n  return {\n    a:\x27.\/pages\/a\x27,\n    b:\x27.\/pages\/b\x27,\n  }\n};\n\/\/ 异步函数\nentry: () =\x3e {\n  return new Promise((resolve)=\x3e{\n    resolve({\n       a:\x27.\/pages\/a\x27,\n       b:\x27.\/pages\/b\x27,\n    });\n  });\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 同步函数\nentry: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    a:\x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/a\x27\x3c\/span\x3e,\n    b:\x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/b\x27\x3c\/span\x3e,\n  }\n};\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 异步函数\nentry: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    resolve({\n       a:\x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/a\x27\x3c\/span\x3e,\n       b:\x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/b\x27\x3c\/span\x3e,\n    });\n  });\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eOutput\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eoutput\x3c\/code\x3e 配置如何输出最终想要的代码。\x3ccode\x3eoutput\x3c\/code\x3e 是一个 \x3ccode\x3eobject\x3c\/code\x3e，里面包含一系列配置项：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3efilename\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eoutput.filename\x3c\/code\x3e 配置输出文件的名称，为 string 类型。 如果只有一个输出文件，则可以把它写成静态不变的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22filename: \x27bundle.js\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3efilename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27bundle.js\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是在有多个 Chunk 要输出时，就需要借助模版和变量了。前面说到 Webpack 会为每个 Chunk取一个名称，可以根据 Chunk 的名称来区分输出的文件名：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22filename: \x27[name].js\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3efilename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27[name].js\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码里的 \x3ccode\x3e[name]\x3c\/code\x3e 代表用内置的 \x3ccode\x3ename\x3c\/code\x3e 变量去替换\x3ccode\x3e[name]\x3c\/code\x3e，这时你可以把它看作一个字符串模块函数， 每个要输出的 Chunk 都会通过这个函数去拼接出输出的文件名称。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e变量名\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e含义\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eid\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eChunk 的唯一标识，从0开始\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ename\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eChunk 的名称\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ehash\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eChunk 的唯一标识的 Hash 值\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3echunkhash\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eChunk 内容的 Hash 值\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e其中 \x3ccode\x3ehash\x3c\/code\x3e 和 \x3ccode\x3echunkhash\x3c\/code\x3e 的长度是可指定的，\x3ccode\x3e[hash:8]\x3c\/code\x3e 代表取8位 Hash 值，默认是20位。\x3c\/p\x3e\n\x3cblockquote\x3e注意 ExtractTextWebpackPlugin 插件是使用 \x3ccode\x3econtenthash\x3c\/code\x3e 来代表哈希值而不是 \x3ccode\x3echunkhash\x3c\/code\x3e， 原因在于 ExtractTextWebpackPlugin 提取出来的内容是代码内容本身而不是由一组模块组成的 Chunk。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3echunkFilename\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eoutput.chunkFilename\x3c\/code\x3e 配置无入口的 Chunk 在输出时的文件名称。 \x3ccode\x3echunkFilename\x3c\/code\x3e 和上面的 \x3ccode\x3efilename\x3c\/code\x3e 非常类似，但 chunkFilename 只用于指定在运行过程中生成的 Chunk 在输出时的文件名称。 常见的会在运行时生成 Chunk 场景有在使用 \x3ccode\x3eCommonChunkPlugin\x3c\/code\x3e、使用 \x3ccode\x3eimport(\x27path\/to\/module\x27)\x3c\/code\x3e 动态加载等时。 chunkFilename 支持和 filename 一致的内置变量。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3epath\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoutput.path\x3c\/code\x3e 配置输出文件存放在本地的目录，必须是 string 类型的绝对路径。通常通过 Node.js 的 \x3ccode\x3epath\x3c\/code\x3e 模块去获取绝对路径：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22path: path.resolve(__dirname, \x27dist_[hash]\x27)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3epath\x3c\/span\x3e.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27dist_[hash]\x27\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3epublicPath\x3c\/h3\x3e\n\x3cp\x3e在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的 URL 地址。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoutput.publicPath\x3c\/code\x3e 配置发布到线上资源的 URL 前缀，为string 类型。 默认值是空字符串 \x3ccode\x3e\x27\x27\x3c\/code\x3e，即使用相对路径。\x3c\/p\x3e\n\x3cp\x3e把构建出的资源文件上传到 CDN 服务上，以利于加快页面的打开速度。配置代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22filename:\x27[name]_[chunkhash:8].js\x27\npublicPath: \x27https:\/\/cdn.example.com\/assets\/\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3efilename:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27[name]_[chunkhash:8].js\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3epublicPath:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/cdn.example.com\/assets\/\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时发布到线上的 HTML 在引入 JavaScript 文件时就需要：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x27https:\/\/cdn.example.com\/assets\/a_12345678.js\x27\x3e\x3c\/script\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/cdn.example.com\/assets\/a_12345678.js\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用该配置项时要小心，稍有不慎将导致资源加载404错误。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoutput.path\x3c\/code\x3e 和 \x3ccode\x3eoutput.publicPath\x3c\/code\x3e 都支持字符串模版，内置变量只有一个：\x3ccode\x3ehash\x3c\/code\x3e 代表一次编译操作的 Hash 值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecrossOriginLoading\x3c\/h3\x3e\n\x3cp\x3eWebpack 输出的部分代码块可能需要异步加载，而异步加载是通过 \x3ccode\x3eJSONP\x3c\/code\x3e 方式实现的。 \x3ccode\x3eJSONP\x3c\/code\x3e 的原理是动态地向 HTML 中插入一个 \x3ccode\x3e\x26lt;script src=\x22url\x22\x26gt;\x26lt;\/script\x26gt;\x3c\/code\x3e 标签去加载异步资源。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoutput.crossOriginLoading\x3c\/code\x3e 则是用于配置这个异步插入的标签的 \x3ccode\x3ecrossorigin\x3c\/code\x3e 值。\x3c\/p\x3e\n\x3cp\x3escript 标签的 \x3ccode\x3ecrossorigin\x3c\/code\x3e 属性可以取以下值：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3efalse\x3c\/code\x3e(默认) 在加载此脚本资源时不会带上用户的 Cookies；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3euse-credentials\x3c\/code\x3e 在加载此脚本资源时会带上用户的 Cookies。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通常用设置 \x3ccode\x3ecrossorigin\x3c\/code\x3e 来获取异步加载的脚本执行时的详细错误信息。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3elibraryTarget 和 library\x3c\/h3\x3e\n\x3cp\x3e当用 Webpack 去构建一个可以被其他模块导入使用的库时需要用到它们。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eoutput.libraryTarget\x3c\/code\x3e 配置以何种方式导出库。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eoutput.library\x3c\/code\x3e 配置导出库的名称。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e假如配置了 \x3ccode\x3eoutput.library=\x27LibraryName\x27\x3c\/code\x3e，则输出和使用的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Webpack 输出的代码\nvar LibraryName = lib_code;\n\n\/\/ 使用库的方法\nLibraryName.doSomething();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e LibraryName = lib_code;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用库的方法\x3c\/span\x3e\nLibraryName.doSomething();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假如 \x3ccode\x3eoutput.library\x3c\/code\x3e 为空，则将直接输出：\x3ccode\x3elib_code\x3c\/code\x3e\x3c\/p\x3e\n\x3cblockquote\x3e其中 \x3ccode\x3elib_code\x3c\/code\x3e 代指导出库的代码内容，是有返回值的一个自执行函数。\x3c\/blockquote\x3e\n\x3cp\x3e它们通常搭配在一起使用。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoutput.libraryTarget\x3c\/code\x3e 是字符串的枚举类型，支持以下配置。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3evar (默认)\x3c\/h3\x3e\n\x3cp\x3e编写的库将通过 \x3ccode\x3evar\x3c\/code\x3e 被赋值给通过 \x3ccode\x3elibrary\x3c\/code\x3e 指定名称的变量。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ecommonjs\x3c\/h3\x3e\n\x3cp\x3e编写的库将通过 CommonJS2 规范导出，输出和使用的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Webpack 输出的代码\nmodule.exports = lib_code;\n\n\/\/ 使用库的方法\nrequire(\x27library-name-in-npm\x27).doSomething();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = lib_code;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用库的方法\x3c\/span\x3e\nrequire(\x3cspan class=\x22hljs-string\x22\x3e\x27library-name-in-npm\x27\x3c\/span\x3e).doSomething();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3eCommonJS2 和 CommonJS 规范很相似，差别在于 CommonJS 只能用 \x3ccode\x3eexports\x3c\/code\x3e 导出，而 CommonJS2 在 CommonJS 的基础上增加了 \x3ccode\x3emodule.exports\x3c\/code\x3e 的导出方式。\x3c\/blockquote\x3e\n\x3cp\x3e在 \x3ccode\x3eoutput.libraryTarget\x3c\/code\x3e 为 commonjs2 时，配置 \x3ccode\x3eoutput.library\x3c\/code\x3e 将没有意义。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3ethis\x3c\/h3\x3e\n\x3cp\x3e编写的库将通过 \x3ccode\x3ethis\x3c\/code\x3e 被赋值给通过 \x3ccode\x3elibrary\x3c\/code\x3e 指定的名称，输出和使用的代码如下：\x3c\/p\x3e\n\x3cp\x3e\/\/ Webpack 输出的代码\x3cbr\x3ethis[\x27LibraryName\x27] = lib_code;\x3c\/p\x3e\n\x3cp\x3e\/\/ 使用库的方法\x3cbr\x3ethis.LibraryName.doSomething();\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ewindow\x3c\/h3\x3e\n\x3cp\x3e编写的库将通过 \x3ccode\x3ewindow\x3c\/code\x3e 被赋值给通过 \x3ccode\x3elibrary\x3c\/code\x3e 指定的名称，即把库挂载到 \x3ccode\x3ewindow\x3c\/code\x3e 上，输出和使用的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Webpack 输出的代码\nwindow[\x27LibraryName\x27] = lib_code;\n\n\/\/ 使用库的方法\nwindow.LibraryName.doSomething();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27LibraryName\x27\x3c\/span\x3e] = lib_code;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用库的方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.LibraryName.doSomething();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eglobal\x3c\/h3\x3e\n\x3cp\x3e编写的库将通过 \x3ccode\x3eglobal\x3c\/code\x3e 被赋值给通过 \x3ccode\x3elibrary\x3c\/code\x3e 指定的名称，即把库挂载到 \x3ccode\x3eglobal\x3c\/code\x3e 上，输出和使用的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/\/ Webpack 输出的代码\nglobal[\x27LibraryName\x27] = lib_code;\n\n\/\/ 使用库的方法\nglobal.LibraryName.doSomething();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eglobal\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27LibraryName\x27\x3c\/span\x3e] = lib_code;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用库的方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eglobal\x3c\/span\x3e.LibraryName.doSomething();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3elibraryExport\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eoutput.libraryExport\x3c\/code\x3e 配置要导出的模块中哪些子模块需要被导出。 它只有在 \x3ccode\x3eoutput.libraryTarget\x3c\/code\x3e 被设置成 \x3ccode\x3ecommonjs\x3c\/code\x3e 或者 \x3ccode\x3ecommonjs2\x3c\/code\x3e 时使用才有意义。\x3c\/p\x3e\n\x3cp\x3e假如要导出的模块源代码是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const a=1;\nexport default b=2;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e b=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在想让构建输出的代码只导出其中的 \x3ccode\x3ea\x3c\/code\x3e，可以把 \x3ccode\x3eoutput.libraryExport\x3c\/code\x3e 设置成 \x3ccode\x3ea\x3c\/code\x3e，那么构建输出的代码和使用方法将变成如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Webpack 输出的代码\nmodule.exports = lib_code[\x27a\x27];\n\n\/\/ 使用库的方法\nrequire(\x27library-name-in-npm\x27)===1;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = lib_code[\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用库的方法\x3c\/span\x3e\nrequire(\x3cspan class=\x22hljs-string\x22\x3e\x27library-name-in-npm\x27\x3c\/span\x3e)===\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3eModule\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e配置 Loader\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3erules\x3c\/code\x3e 配置模块的读取和解析规则，通常用来配置 \x3ccode\x3eLoader\x3c\/code\x3e。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 \x3ccode\x3erules\x3c\/code\x3e 时大致通过以下方式：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cstrong\x3e条件匹配\x3c\/strong\x3e：通过 \x3ccode\x3etest\x3c\/code\x3e 、 \x3ccode\x3einclude\x3c\/code\x3e 、 \x3ccode\x3eexclude\x3c\/code\x3e 三个配置项来命中 Loader 要应用规则的文件。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e应用规则\x3c\/strong\x3e：对选中后的文件通过 \x3ccode\x3euse\x3c\/code\x3e 配置项来应用 Loader，可以只应用一个 Loader 或者按照\x3cstrong\x3e从后往前\x3c\/strong\x3e的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e重置顺序\x3c\/strong\x3e：一组 Loader 的执行顺序\x3cstrong\x3e默认是从右到左执行\x3c\/strong\x3e，通过 \x3ccode\x3eenforce\x3c\/code\x3e 选项可以让其中一个 Loader 的执行顺序放到最前或者最后。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n  rules: [\n    {\n      \/\/ 命中 JavaScript 文件\n      test: \/\\.js$\/,\n      \/\/ 用 babel-loader 转换 JavaScript 文件\n      \/\/ ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度\n      use: [\x27babel-loader?cacheDirectory\x27],\n      \/\/ 只命中src目录里的js文件，加快 Webpack 搜索速度\n      include: path.resolve(__dirname, \x27src\x27)\n    },\n    {\n      \/\/ 命中 SCSS 文件\n      test: \/\\.scss$\/,\n      \/\/ 使用一组 Loader 去处理 SCSS 文件。\n      \/\/ 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。\n      use: [\x27style-loader\x27, \x27css-loader\x27, \x27sass-loader\x27],\n      \/\/ 排除 node_modules 目录下的文件\n      exclude: path.resolve(__dirname, \x27node_modules\x27),\n    },\n    {\n      \/\/ 对非文本文件采用 file-loader 加载\n      test: \/\\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$\/,\n      use: [\x27file-loader\x27],\n    },\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3emodule: {\n  rules: [\n    {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 命中 JavaScript 文件\x3c\/span\x3e\n      test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用 babel-loader 转换 JavaScript 文件\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度\x3c\/span\x3e\n      use: [\x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader?cacheDirectory\x27\x3c\/span\x3e],\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只命中src目录里的js文件，加快 Webpack 搜索速度\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3einclude\x3c\/span\x3e: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e)\n    },\n    {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 命中 SCSS 文件\x3c\/span\x3e\n      test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.scss$\/\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用一组 Loader 去处理 SCSS 文件。\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。\x3c\/span\x3e\n      use: [\x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27sass-loader\x27\x3c\/span\x3e],\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除 node_modules 目录下的文件\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eexclude\x3c\/span\x3e: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e),\n    },\n    {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对非文本文件采用 file-loader 加载\x3c\/span\x3e\n      test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$\/\x3c\/span\x3e,\n      use: [\x3cspan class=\x22hljs-string\x22\x3e\x27file-loader\x27\x3c\/span\x3e],\n    },\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 Loader 需要传入很多参数时，你还可以通过一个 \x3ccode\x3eObject\x3c\/code\x3e 来描述，例如在上面的 \x3ccode\x3ebabel-loader\x3c\/code\x3e 配置中有如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22use: [\n  {\n    loader:\x27babel-loader\x27,\n    options:{\n      cacheDirectory:true,\n    },\n    \/\/ enforce:\x27post\x27 的含义是把该 Loader 的执行顺序放到最后\n    \/\/ enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面\n    enforce:\x27post\x27\n  },\n  \/\/ 省略其它 Loader\n]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3euse\x3c\/span\x3e: [\n  {\n    \x3cspan class=\x22hljs-attribute\x22\x3eloader\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3eoptions\x3c\/span\x3e:{\n      \x3cspan class=\x22hljs-attribute\x22\x3ecacheDirectory\x3c\/span\x3e:true,\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ enforce:\x27post\x27 的含义是把该 Loader 的执行顺序放到最后\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3eenforce\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27post\x27\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略其它 Loader\x3c\/span\x3e\n]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子中 \x3ccode\x3etest include exclude\x3c\/code\x3e 这三个命中文件的配置项只传入了一个字符串或正则，其实它们还都支持数组类型，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  test:[\n    \/\\.jsx?$\/,\n    \/\\.tsx?$\/\n  ],\n  include:[\n    path.resolve(__dirname, \x27src\x27),\n    path.resolve(__dirname, \x27tests\x27),\n  ],\n  exclude:[\n    path.resolve(__dirname, \x27node_modules\x27),\n    path.resolve(__dirname, \x27bower_modules\x27),\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attribute\x22\x3etest\x3c\/span\x3e:[\n    \/\\.jsx?$\/,\n    \/\\.tsx?$\/\n  ],\n  include:[\n    path.\x3cspan class=\x22hljs-built_in\x22\x3eresolve\x3c\/span\x3e(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e),\n    path.\x3cspan class=\x22hljs-built_in\x22\x3eresolve\x3c\/span\x3e(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27tests\x27\x3c\/span\x3e),\n  ],\n  exclude:[\n    path.\x3cspan class=\x22hljs-built_in\x22\x3eresolve\x3c\/span\x3e(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e),\n    path.\x3cspan class=\x22hljs-built_in\x22\x3eresolve\x3c\/span\x3e(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27bower_modules\x27\x3c\/span\x3e),\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e数组里的每项之间是\x3cstrong\x3e或\x3c\/strong\x3e的关系，即文件路径符合数组中的任何一个条件就会被命中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3enoParse\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3enoParse\x3c\/code\x3e 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能。 原因是一些库例如 jQuery 、ChartJS 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enoParse\x3c\/code\x3e 是可选配置项，类型需要是 \x3ccode\x3eRegExp\x3c\/code\x3e、\x3ccode\x3e[RegExp]\x3c\/code\x3e、\x3ccode\x3efunction\x3c\/code\x3e 其中一个。\x3c\/p\x3e\n\x3cp\x3e例如想要忽略掉 jQuery 、ChartJS，可以使用如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 使用正则表达式\nnoParse: \/jquery|chartjs\/\n\n\/\/ 使用函数，从 Webpack 3.0.0 开始支持\nnoParse: (content)=\x3e {\n  \/\/ content 代表一个模块的文件路径\n  \/\/ 返回 true or false\n  return \/jquery|chartjs\/.test(content);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 使用正则表达式\nnoParse: \x3cspan class=\x22hljs-regexp\x22\x3e\/jquery|chartjs\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 使用函数，从 Webpack \x3cspan class=\x22hljs-number\x22\x3e3.0\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e 开始支持\nnoParse: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(content)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e content 代表一个模块的文件路径\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 返回 \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-regexp\x22\x3e\/jquery|chartjs\/\x3c\/span\x3e.test(content);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e注意被忽略掉的文件里不应该包含 \x3ccode\x3eimport\x3c\/code\x3e 、 \x3ccode\x3erequire\x3c\/code\x3e 、 \x3ccode\x3edefine\x3c\/code\x3e 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3eparser\x3c\/h3\x3e\n\x3cp\x3e因为 Webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能，支持 \x3ccode\x3eAMD\x3c\/code\x3e、\x3ccode\x3eCommonJS\x3c\/code\x3e、\x3ccode\x3eSystemJS\x3c\/code\x3e、\x3ccode\x3eES6\x3c\/code\x3e。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eparser\x3c\/code\x3e 属性可以更细粒度的配置哪些模块语法要解析哪些不解析，和 \x3ccode\x3enoParse\x3c\/code\x3e 配置项的区别在于 \x3ccode\x3eparser\x3c\/code\x3e 可以精确到语法层面， 而 \x3ccode\x3enoParse\x3c\/code\x3e 只能控制哪些文件不被解析。 \x3ccode\x3eparser\x3c\/code\x3e 使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n  rules: [\n    {\n      test: \/\\.js$\/,\n      use: [\x27babel-loader\x27],\n      parser: {\n      amd: false, \/\/ 禁用 AMD\n      commonjs: false, \/\/ 禁用 CommonJS\n      system: false, \/\/ 禁用 SystemJS\n      harmony: false, \/\/ 禁用 ES6 import\/export\n      requireInclude: false, \/\/ 禁用 require.include\n      requireEnsure: false, \/\/ 禁用 require.ensure\n      requireContext: false, \/\/ 禁用 require.context\n      browserify: false, \/\/ 禁用 browserify\n      requireJs: false, \/\/ 禁用 requirejs\n      }\n    },\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attr\x22\x3emodule:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  rules:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e[\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      test:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\\.js$\/,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      use:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e[\x27babel-loader\x27],\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      parser:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      amd:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eAMD\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      commonjs:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eCommonJS\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      system:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eSystemJS\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      harmony:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eES6\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eimport\/export\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      requireInclude:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3erequire.include\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      requireEnsure:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3erequire.ensure\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      requireContext:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3erequire.context\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      browserify:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ebrowserify\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      requireJs:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e禁用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3erequirejs\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e]\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3eResolve\x3c\/h2\x3e\n\x3cp\x3eWebpack 在启动后会从配置的入口模块出发找出所有依赖的模块，\x3ccode\x3eResolve\x3c\/code\x3e 配置 Webpack 如何寻找模块所对应的文件。 Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你也可以根据自己的需要修改默认的规则。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3ealias\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eresolve.alias\x3c\/code\x3e 配置项通过别名来把原导入路径映射成一个新的导入路径。例如使用以下配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Webpack alias 配置\nresolve:{\n  alias:{\n    components: \x27.\/src\/components\/\x27\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack alias 配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eresolve\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3ealias\x3c\/span\x3e:{\n    \x3cspan class=\x22hljs-attribute\x22\x3ecomponents\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/components\/\x27\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当你通过 \x3ccode\x3eimport Button from \x27components\/button\x27\x3c\/code\x3e 导入时，实际上被 \x3ccode\x3ealias\x3c\/code\x3e 等价替换成了 \x3ccode\x3eimport Button from \x27.\/src\/components\/button\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e以上 \x3ccode\x3ealias\x3c\/code\x3e 配置的含义是把导入语句里的 \x3ccode\x3ecomponents\x3c\/code\x3e 关键字替换成 \x3ccode\x3e.\/src\/components\/\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这样做可能会命中太多的导入语句，\x3ccode\x3ealias\x3c\/code\x3e 还支持 \x3ccode\x3e$\x3c\/code\x3e 符号来缩小范围到只命中以关键字结尾的导入语句：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22resolve:{\n  alias:{\n    \x27react$\x27: \x27\/path\/to\/react.min.js\x27\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eresolve\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3ealias\x3c\/span\x3e:{\n    \x3cspan class=\x22hljs-string\x22\x3e\x27react$\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/path\/to\/react.min.js\x27\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ereact$\x3c\/code\x3e 只会命中以 \x3ccode\x3ereact\x3c\/code\x3e 结尾的导入语句，即只会把 \x3ccode\x3eimport \x27react\x27\x3c\/code\x3e 关键字替换成 \x3ccode\x3eimport \x27\/path\/to\/react.min.js\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3emainFields\x3c\/h3\x3e\n\x3cp\x3e有一些第三方模块会针对不同环境提供几分代码。 例如分别提供采用 ES5 和 ES6 的2份代码，这2份代码的位置写在 \x3ccode\x3epackage.json\x3c\/code\x3e 文件里，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;jsnext:main\x26quot;: \x26quot;es\/index.js\x26quot;,\/\/ 采用 ES6 语法的代码入口文件\n  \x26quot;main\x26quot;: \x26quot;lib\/index.js\x26quot; \/\/ 采用 ES5 语法的代码入口文件\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22jsnext:main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22es\/index.js\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用 ES6 语法的代码入口文件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x22main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22lib\/index.js\x22\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用 ES5 语法的代码入口文件\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWebpack 会根据 \x3ccode\x3emainFields\x3c\/code\x3e 的配置去决定优先采用哪份代码，\x3ccode\x3emainFields\x3c\/code\x3e 默认如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mainFields: [\x27browser\x27, \x27main\x27]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3emainFields:\x3c\/span\x3e [\x3cspan class=\x22hljs-string\x22\x3e\x27browser\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWebpack 会按照数组里的顺序去 \x3ccode\x3epackage.json\x3c\/code\x3e 文件里寻找，只会使用找到的第一个。\x3c\/p\x3e\n\x3cp\x3e假如你想优先采用 ES6 的那份代码，可以这样配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mainFields: [\x27jsnext:main\x27, \x27browser\x27, \x27main\x27]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3emainFields:\x3c\/span\x3e [\x3cspan class=\x22hljs-string\x22\x3e\x27jsnext:main\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27browser\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3eextensions\x3c\/h3\x3e\n\x3cp\x3e在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试访问文件是否存在。 \x3ccode\x3eresolve.extensions\x3c\/code\x3e 用于配置在尝试过程中用到的后缀列表，默认是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22extensions: [\x27.js\x27, \x27.json\x27]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3eextensions:\x3c\/span\x3e [\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.json\x27\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3emodules\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eresolve.modules\x3c\/code\x3e 配置 Webpack 去哪些目录下寻找第三方模块，默认是只会去 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下寻找。 \x3c\/p\x3e\n\x3cp\x3e有时你的项目里会有一些模块会大量被其它模块依赖和导入，由于其它模块的位置分布不定，针对不同的文件都要去计算被导入模块文件的相对路径， 这个路径有时候会很长，就像这样 \x3ccode\x3eimport \x27..\/..\/..\/components\/button\x27\x3c\/code\x3e 这时你可以利用 \x3ccode\x3emodules\x3c\/code\x3e 配置项优化，假如那些被大量导入的模块都在 \x3ccode\x3e.\/src\/components\x3c\/code\x3e 目录下，把 \x3ccode\x3emodules\x3c\/code\x3e 配置成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22modules:[\x27.\/src\/components\x27,\x27node_modules\x27]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3emodules:\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/components\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e后，你可以简单通过 \x3ccode\x3eimport \x27button\x27\x3c\/code\x3e 导入。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3edescriptionFiles\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eresolve.descriptionFiles\x3c\/code\x3e 配置描述第三方模块的文件名称，也就是 \x3ccode\x3epackage.json\x3c\/code\x3e 文件。默认如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22descriptionFiles: [\x27package.json\x27]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3edescriptionFiles:\x3c\/span\x3e [\x3cspan class=\x22hljs-string\x22\x3e\x27package.json\x27\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader26\x22\x3eenforceExtension\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eresolve.enforceExtension\x3c\/code\x3e 如果配置为 \x3ccode\x3etrue\x3c\/code\x3e 所有导入语句都必须要带文件后缀， 例如开启前 \x3ccode\x3eimport \x27.\/foo\x27\x3c\/code\x3e 能正常工作，开启后就必须写成 \x3ccode\x3eimport \x27.\/foo.js\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader27\x22\x3eenforceModuleExtension\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eenforceModuleExtension\x3c\/code\x3e 和 \x3ccode\x3eenforceExtension\x3c\/code\x3e 作用类似，但 \x3ccode\x3eenforceModuleExtension\x3c\/code\x3e 只对 \x3ccode\x3enode_modules\x3c\/code\x3e 下的模块生效。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eenforceModuleExtension\x3c\/code\x3e 通常搭配 \x3ccode\x3eenforceExtension\x3c\/code\x3e 使用，在 \x3ccode\x3eenforceExtension:true\x3c\/code\x3e 时，因为安装的第三方模块中大多数导入语句没带文件后缀， 所以这时通过配置 \x3ccode\x3eenforceModuleExtension:false\x3c\/code\x3e 来兼容第三方模块。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader28\x22\x3ePlugins\x3c\/h2\x3e\n\x3cp\x3ePlugin 用于扩展 Webpack 功能，各种各样的 Plugin 几乎让 Webpack 可以做任何构建相关的事情。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader29\x22\x3e配置 Plugin\x3c\/h3\x3e\n\x3cp\x3ePlugin 的配置很简单，\x3ccode\x3eplugins\x3c\/code\x3e 配置项接受一个数组，数组里每一项都是一个要使用的 Plugin 的实例，Plugin 需要的参数通过\x3cstrong\x3e构造函数\x3c\/strong\x3e传入。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const CommonsChunkPlugin = require(\x27webpack\/lib\/optimize\/CommonsChunkPlugin\x27);\n\nmodule.exports = {\n  plugins: [\n    \/\/ 所有页面都会用到的公共代码提取到 common 代码块中\n    new CommonsChunkPlugin({\n      name: \x27common\x27,\n      chunks: [\x27a\x27, \x27b\x27]\n    }),\n  ]\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e CommonsChunkPlugin = require(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\/lib\/optimize\/CommonsChunkPlugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  plugins: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所有页面都会用到的公共代码提取到 common 代码块中\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e CommonsChunkPlugin({\n      name: \x3cspan class=\x22hljs-string\x22\x3e\x27common\x27\x3c\/span\x3e,\n      chunks: [\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e]\n    }),\n  ]\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 Plugin 的难点在于掌握 Plugin 本身提供的配置项，而不是如何在 Webpack 中接入 Plugin。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader30\x22\x3eDevServer\x3c\/h2\x3e\n\x3cp\x3e要配置 DevServer ，除了在配置文件里通过 \x3ccode\x3edevServer\x3c\/code\x3e 传入参数外，还可以通过命令行参数传入。 注意只有在通过 \x3ccode\x3eDevServer\x3c\/code\x3e 去启动 Webpack 时配置文件里 \x3ccode\x3edevServer\x3c\/code\x3e 才会生效，因为这些参数所对应的功能都是 DevServer 提供的，Webpack 本身并不认识 \x3ccode\x3edevServer\x3c\/code\x3e 配置项。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader31\x22\x3ehot\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.hot\x3c\/code\x3e 配置是否启用模块热替换功能。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eDevServer\x3c\/code\x3e 默认的行为是在发现源代码被更新后会通过自动刷新整个页面来做到实时预览，开启模块热替换功能后将在不刷新整个页面的情况下通过用新模块替换老模块来做到实时预览。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader32\x22\x3einline\x3c\/h3\x3e\n\x3cp\x3eDevServer 的实时预览功能依赖一个注入到页面里的代理客户端去接受来自 DevServer 的命令和负责刷新网页的工作。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edevServer.inline\x3c\/code\x3e 用于配置是否自动注入这个代理客户端到将运行在页面里的 Chunk 里去，默认是会自动注入。 DevServer 会根据你是否开启 \x3ccode\x3einline\x3c\/code\x3e 来调整它的自动刷新策略：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果开启 \x3ccode\x3einline\x3c\/code\x3e，DevServer 会在构建完变化后的代码时通过代理客户端控制网页刷新。\x3c\/li\x3e\n\x3cli\x3e如果关闭 \x3ccode\x3einline\x3c\/code\x3e，DevServer 将无法直接控制要开发的网页。这时它会通过 \x3ccode\x3eiframe\x3c\/code\x3e 的方式去运行要开发的网页，当构建完变化后的代码时通过刷新 \x3ccode\x3eiframe\x3c\/code\x3e 来实现实时预览。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你想使用 DevServer 去自动刷新网页实现实时预览，最方便的方法是直接开启 \x3ccode\x3einline\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader33\x22\x3ehistoryApiFallback\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.historyApiFallback\x3c\/code\x3e 用于方便的开发使用了 HTML5 History API 的单页应用。 \x3c\/p\x3e\n\x3cp\x3e这类单页应用要求服务器在针对任何命中的路由时都返回一个对应的 HTML 文件，例如在访问 \x3ccode\x3ehttp:\/\/localhost\/user\x3c\/code\x3e 和 \x3ccode\x3ehttp:\/\/localhost\/home\x3c\/code\x3e 时都返回 \x3ccode\x3eindex.html\x3c\/code\x3e 文件， 浏览器端的 JavaScript 代码会从 URL 里解析出当前页面的状态，显示出对应的界面。\x3c\/p\x3e\n\x3cp\x3e配置 \x3ccode\x3ehistoryApiFallback\x3c\/code\x3e 最简单的做法是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22historyApiFallback: true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attr\x22\x3ehistoryApiFallback:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这会导致任何请求都会返回 \x3ccode\x3eindex.html\x3c\/code\x3e 文件，这只能用于只有一个 HTML 文件的应用。    \x3c\/p\x3e\n\x3cp\x3e如果你的应用由多个单页应用组成，这就需要 DevServer 根据不同的请求来返回不同的 HTML 文件，配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22historyApiFallback: {\n  \/\/ 使用正则匹配命中路由\n  rewrites: [\n    \/\/ \/user 开头的都返回 user.html\n    { from: \/^\\\/user\/, to: \x27\/user.html\x27 },\n    { from: \/^\\\/game\/, to: \x27\/game.html\x27 },\n    \/\/ 其它的都返回 index.html\n    { from: \/.\/, to: \x27\/index.html\x27 },\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3ehistoryApiFallback\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用正则匹配命中路由\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3erewrites\x3c\/span\x3e: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/user 开头的都返回 user.html\x3c\/span\x3e\n    { \x3cspan class=\x22hljs-attribute\x22\x3efrom\x3c\/span\x3e: \/^\\\/user\/, \x3cspan class=\x22hljs-attribute\x22\x3eto\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/user.html\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attribute\x22\x3efrom\x3c\/span\x3e: \/^\\\/game\/, \x3cspan class=\x22hljs-attribute\x22\x3eto\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/game.html\x27\x3c\/span\x3e },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其它的都返回 index.html\x3c\/span\x3e\n    { \x3cspan class=\x22hljs-attribute\x22\x3efrom\x3c\/span\x3e: \/.\/, \x3cspan class=\x22hljs-attribute\x22\x3eto\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/index.html\x27\x3c\/span\x3e },\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader34\x22\x3econtentBase\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.contentBase\x3c\/code\x3e 配置 DevServer HTTP 服务器的文件根目录。 默认情况下为当前执行目录，通常是项目根目录，所有一般情况下你不必设置它，除非你有额外的文件需要被 DevServer 服务。 例如你想把项目根目录下的 \x3ccode\x3epublic\x3c\/code\x3e 目录设置成 DevServer 服务器的文件根目录，你可以这样配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22devServer:{\n  contentBase: path.join(__dirname, \x27public\x27)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3edevServer\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3econtentBase\x3c\/span\x3e: path.\x3cspan class=\x22hljs-built_in\x22\x3ejoin\x3c\/span\x3e(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27public\x27\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里需要指出可能会让你疑惑的地方，DevServer 服务器通过 HTTP 服务暴露出的文件分为两类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e暴露本地文件。\x3c\/li\x3e\n\x3cli\x3e暴露 Webpack 构建出的结果，由于构建出的结果交给了 DevServer，所以你在使用了 DevServer 时在本地找不到构建出的文件。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3econtentBase\x3c\/code\x3e 只能用来配置暴露本地文件的规则，你可以通过 \x3ccode\x3econtentBase:false\x3c\/code\x3e 来关闭暴露本地文件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader35\x22\x3eheaders\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.headers\x3c\/code\x3e 配置项可以在 HTTP 响应中注入一些 HTTP 响应头，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22devServer:{\n  headers: {\n    \x27X-foo\x27:\x27bar\x27\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3edevServer\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3eheaders\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x27X-foo\x27\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader36\x22\x3ehost\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.host\x3c\/code\x3e 配置项用于配置 DevServer 服务监听的地址。 \x3c\/p\x3e\n\x3cp\x3e例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 \x3ccode\x3e--host 0.0.0.0\x3c\/code\x3e。 \x3ccode\x3ehost\x3c\/code\x3e 的默认值是 \x3ccode\x3e127.0.0.1\x3c\/code\x3e 即只有本地可以访问 DevServer 的 HTTP 服务。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader37\x22\x3eport\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.port\x3c\/code\x3e 配置项用于配置 DevServer 服务监听的端口，默认使用 \x3ccode\x3e8080\x3c\/code\x3e 端口。 如果 \x3ccode\x3e8080\x3c\/code\x3e 端口已经被其它程序占有就使用 \x3ccode\x3e8081\x3c\/code\x3e，如果 \x3ccode\x3e8081\x3c\/code\x3e 还是被占用就使用 \x3ccode\x3e8082\x3c\/code\x3e，以此类推。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader38\x22\x3eallowedHosts\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.allowedHosts\x3c\/code\x3e 配置一个白名单列表，只有 HTTP 请求的 HOST 在列表里才正常返回，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22allowedHosts: [\n  \/\/ 匹配单个域名\n  \x27host.com\x27,\n  \x27sub.host.com\x27,\n  \/\/ host2.com 和所有的子域名 *.host2.com 都将匹配\n  \x27.host2.com\x27\n]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3eallowedHosts:\x3c\/span\x3e [\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配单个域名\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x27host.com\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27sub.host.com\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ host2.com 和所有的子域名 *.host2.com 都将匹配\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x27.host2.com\x27\x3c\/span\x3e\n]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader39\x22\x3edisableHostCheck\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.disableHostCheck\x3c\/code\x3e 配置项用于配置是否关闭用于 DNS 重绑定的 HTTP 请求的 HOST 检查。 \x3c\/p\x3e\n\x3cp\x3eDevServer 默认只接受来自本地的请求，关闭后可以接受来自任何 HOST 的请求。 它通常用于搭配 \x3ccode\x3e--host 0.0.0.0\x3c\/code\x3e 使用，因为你想要其它设备访问你本地的服务，但访问时是直接通过 IP 地址访问而不是 HOST 访问，所以需要关闭 HOST 检查。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader40\x22\x3ehttps\x3c\/h3\x3e\n\x3cp\x3eDevServer 默认使用 HTTP 协议服务，它也能通过 HTTPS 协议服务。 有些情况下你必须使用 HTTPS，例如 HTTP2 和 Service Worker 就必须运行在 HTTPS 之上。 要切换成 HTTPS 服务，最简单的方式是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22devServer:{\n  https: true\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3edevServer\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3ehttps\x3c\/span\x3e: true\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eDevServer 会自动的为你生成一份 HTTPS 证书。\x3c\/p\x3e\n\x3cp\x3e如果你想用自己的证书可以这样配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22devServer:{\n  https: {\n    key: fs.readFileSync(\x27path\/to\/server.key\x27),\n    cert: fs.readFileSync(\x27path\/to\/server.crt\x27),\n    ca: fs.readFileSync(\x27path\/to\/ca.pem\x27)\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3edevServer\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attribute\x22\x3ehttps\x3c\/span\x3e: {\n    key: fs.\x3cspan class=\x22hljs-built_in\x22\x3ereadFileSync\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\/to\/server.key\x27\x3c\/span\x3e),\n    cert: fs.\x3cspan class=\x22hljs-built_in\x22\x3ereadFileSync\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\/to\/server.crt\x27\x3c\/span\x3e),\n    ca: fs.\x3cspan class=\x22hljs-built_in\x22\x3ereadFileSync\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\/to\/ca.pem\x27\x3c\/span\x3e)\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader41\x22\x3eclientLogLevel\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.clientLogLevel\x3c\/code\x3e 配置在客户端的日志等级，这会影响到你在浏览器开发者工具控制台里看到的日志内容。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eclientLogLevel\x3c\/code\x3e 是\x3cstrong\x3e枚举类型\x3c\/strong\x3e，可取如下之一的值 \x3ccode\x3enone | error | warning | info\x3c\/code\x3e。 默认为 \x3ccode\x3einfo\x3c\/code\x3e 级别，即输出所有类型的日志，设置成 \x3ccode\x3enone\x3c\/code\x3e 可以不输出任何日志。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader42\x22\x3ecompress\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.compress\x3c\/code\x3e 配置是否启用 gzip 压缩。\x3ccode\x3eboolean\x3c\/code\x3e 为类型，默认为 \x3ccode\x3efalse\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader43\x22\x3eopen\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevServer.open\x3c\/code\x3e 用于在 DevServer 启动且第一次构建完时自动用你系统上默认的浏览器去打开要开发的网页。 同时还提供 \x3ccode\x3edevServer.openPage\x3c\/code\x3e 配置项用于打开指定 URL 的网页。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader44\x22\x3e其它配置项\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader45\x22\x3eTarget\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3etarget\x3c\/code\x3e 配置项可以让 Webpack 构建出针对不同运行环境的代码。 target 可以是以下之一：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3etarget值\x3c\/th\x3e\n\x3cth\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eweb\x3c\/td\x3e\n\x3ctd\x3e针对浏览器 \x3cstrong\x3e(默认)\x3c\/strong\x3e，所有代码都集中在一个文件里\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3enode\x3c\/td\x3e\n\x3ctd\x3e针对 Node.js，使用 \x3ccode\x3erequire\x3c\/code\x3e 语句加载 Chunk 代码\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3easync-node\x3c\/td\x3e\n\x3ctd\x3e针对 Node.js，异步加载 Chunk 代码\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ewebworker\x3c\/td\x3e\n\x3ctd\x3e针对 WebWorker\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eelectron-main\x3c\/td\x3e\n\x3ctd\x3e针对 \x3ca href=\x22https:\/\/electronjs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eElectron\x3c\/a\x3e 主线程\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eelectron-renderer\x3c\/td\x3e\n\x3ctd\x3e针对 Electron 渲染线程\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e例如当你设置 \x3ccode\x3etarget:\x27node\x27\x3c\/code\x3e 时，源代码中导入 Node.js 原生模块的语句 \x3ccode\x3erequire(\x27fs\x27)\x3c\/code\x3e 将会被保留，\x3ccode\x3efs\x3c\/code\x3e 模块的内容不会打包进 Chunk 里。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader46\x22\x3eDevtool\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3edevtool\x3c\/code\x3e 配置 Webpack 如何生成 Source Map，默认值是 \x3ccode\x3efalse\x3c\/code\x3e 即不生成 Source Map，想为构建出的代码生成 Source Map 以方便调试，可以这样配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.export = {\n  devtool: \x27source-map\x27\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e = {\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader47\x22\x3eWatch 和 WatchOptions\x3c\/h3\x3e\n\x3cp\x3e前面介绍过 Webpack 的监听模式，它支持监听文件更新，在文件发生变化时重新编译。在使用 Webpack 时监听模式默认是关闭的，想打开需要如下配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.export = {\n  watch: true\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e = {\n  watch: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在使用 DevServer 时，监听模式默认是开启的。\x3c\/p\x3e\n\x3cp\x3e除此之外，Webpack 还提供了 \x3ccode\x3ewatchOptions\x3c\/code\x3e 配置项去更灵活的控制监听模式，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.export = {\n  \/\/ 只有在开启监听模式时，watchOptions 才有意义\n  \/\/ 默认为 false，也就是不开启\n  watch: true,\n  \/\/ 监听模式运行时的参数\n  \/\/ 在开启监听模式时，才有意义\n  watchOptions: {\n    \/\/ 不监听的文件或文件夹，支持正则匹配\n    \/\/ 默认为空\n    ignored: \/node_modules\/,\n    \/\/ 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\n    \/\/ 默认为 300ms  \n    aggregateTimeout: 300,\n    \/\/ 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的\n    \/\/ 默认每1000豪秒去问1次\n    poll: 1000\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3emodule.export = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有在开启监听模式时，watchOptions 才有意义\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为 false，也就是不开启\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e  watch:\x3c\/span\x3e true,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听模式运行时的参数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在开启监听模式时，才有意义\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e  watchOptions:\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不监听的文件或文件夹，支持正则匹配\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为空\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e    ignored:\x3c\/span\x3e \/node_modules\/,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为 300ms  \x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e    aggregateTimeout:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认每1000豪秒去问1次\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e    poll:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader48\x22\x3eExternals\x3c\/h3\x3e\n\x3cp\x3eExternals 用来告诉 Webpack 要构建的代码中使用了哪些不用被打包的模块，也就是说这些模版是外部环境提供的，Webpack 在打包时可以忽略它们。\x3c\/p\x3e\n\x3cp\x3e有些 JavaScript 运行环境可能内置了一些全局变量或者模块，例如在你的 HTML HEAD 标签里通过以下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;path\/to\/jquery.js\x26quot;\x3e\x3c\/script\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22path\/to\/jquery.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e引入 jQuery 后，全局变量 \x3ccode\x3ejQuery\x3c\/code\x3e 就会被注入到网页的 JavaScript 运行环境里。\x3c\/p\x3e\n\x3cp\x3e如果想在使用模块化的源代码里导入和使用 jQuery，可能需要这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import $ from \x27jquery\x27;\n$(\x27.my-element\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e $ \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27jquery\x27\x3c\/span\x3e;\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27.my-element\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构建后你会发现输出的 Chunk 里包含的 jQuery 库的内容，这导致 jQuery 库出现了2次，浪费加载流量，最好是 Chunk 里不会包含 jQuery 库的内容。\x3c\/p\x3e\n\x3cp\x3eExternals 配置项就是为了解决这个问题。\x3c\/p\x3e\n\x3cp\x3e通过 \x3ccode\x3eexternals\x3c\/code\x3e 可以告诉 Webpack JavaScript 运行环境已经内置了那些全局变量，针对这些全局变量不用打包进代码中而是直接使用全局变量。 要解决以上问题，可以这样配置 \x3ccode\x3eexternals\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.export = {\n  externals: {\n    \/\/ 把导入语句里的 jquery 替换成运行环境里的全局变量 jQuery\n    jquery: \x27jQuery\x27\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e = {\n  externals: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把导入语句里的 jquery 替换成运行环境里的全局变量 jQuery\x3c\/span\x3e\n    jquery: \x3cspan class=\x22hljs-string\x22\x3e\x27jQuery\x27\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader49\x22\x3eResolveLoader\x3c\/h3\x3e\n\x3cp\x3eResolveLoader 用来告诉 Webpack 如何去寻找 Loader，因为在使用 Loader 时是通过其包名称去引用的， Webpack 需要根据配置的 Loader 包名去找到 Loader 的实际代码，以调用 Loader 去处理源文件。\x3c\/p\x3e\n\x3cp\x3eResolveLoader 的默认配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  resolveLoader:{\n    \/\/ 去哪个目录下寻找 Loader\n    modules: [\x27node_modules\x27],\n    \/\/ 入口文件的后缀\n    extensions: [\x27.js\x27, \x27.json\x27],\n    \/\/ 指明入口文件位置的字段\n    mainFields: [\x27loader\x27, \x27main\x27]\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  resolveLoader:{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去哪个目录下寻找 Loader\x3c\/span\x3e\n    modules: [\x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 入口文件的后缀\x3c\/span\x3e\n    extensions: [\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.json\x27\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指明入口文件位置的字段\x3c\/span\x3e\n    mainFields: [\x3cspan class=\x22hljs-string\x22\x3e\x27loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e]\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该配置项常用于加载本地的 Loader。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader50\x22\x3e整体配置结构\x3c\/h2\x3e\n\x3cp\x3e之前的章节分别讲述了每个配置项的具体含义，但没有描述它们所处的位置和数据结构，下面通过一份代码来描述清楚：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\n\nmodule.exports = {\n    \/\/ entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。\n    \/\/ 类型可以是 string | object | array\n    entry: \x27.\/app\/entry\x27, \/\/ 只有1个入口，入口只有1个文件\n    entry: [\x27.\/app\/entry1\x27, \x27.\/app\/entry2\x27], \/\/ 只有1个入口，入口有2个文件\n    entry: { \/\/ 有2个入口\n        a: \x27.\/app\/entry-a\x27,\n        b: [\x27.\/app\/entry-b1\x27, \x27.\/app\/entry-b2\x27]\n    },\n\n    \/\/ 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。\n    output: {\n        \/\/ 输出文件存放的目录，必须是 string 类型的绝对路径。\n        path: path.resolve(__dirname, \x27dist\x27),\n\n        \/\/ 输出文件的名称\n        filename: \x27bundle.js\x27, \/\/ 完整的名称\n        filename: \x27[name].js\x27, \/\/ 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称\n        filename: \x27[chunkhash].js\x27, \/\/ 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件\n\n        \/\/ 发布到线上的所有资源的 URL 前缀，string 类型\n        publicPath: \x27\/assets\/\x27, \/\/ 放到指定目录下\n        publicPath: \x27\x27, \/\/ 放到根目录下\n        publicPath: \x27https:\/\/cdn.example.com\/\x27, \/\/ 放到 CDN 上去\n\n        \/\/ 导出库的名称，string 类型\n        \/\/ 不填它时，默认输出格式是匿名的立即执行函数\n        library: \x27MyLibrary\x27,\n\n        \/\/ 导出库的类型，枚举类型，默认是 var\n        \/\/ 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ，\n        libraryTarget: \x27umd\x27,\n\n        \/\/ 是否包含有用的文件路径信息到生成的代码里去，boolean 类型\n        pathinfo: true,\n\n        \/\/ 附加 Chunk 的文件名称\n        chunkFilename: \x27[id].js\x27,\n        chunkFilename: \x27[chunkhash].js\x27,\n\n        \/\/ JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用\n        jsonpFunction: \x27myWebpackJsonp\x27,\n\n        \/\/ 生成的 Source Map 文件名称\n        sourceMapFilename: \x27[file].map\x27,\n\n        \/\/ 浏览器开发者工具里显示的源码模块名称\n        devtoolModuleFilenameTemplate: \x27webpack:\/\/\/[resource-path]\x27,\n\n        \/\/ 异步加载跨域的资源时使用的方式\n        crossOriginLoading: \x27use-credentials\x27,\n        crossOriginLoading: \x27anonymous\x27,\n        crossOriginLoading: false,\n    },\n\n    \/\/ 配置模块相关\n    module: {\n        rules: [ \/\/ 配置 Loader\n            {\n                test: \/\\.jsx?$\/, \/\/ 正则匹配命中要使用 Loader 的文件\n                include: [ \/\/ 只会命中这里面的文件\n                    path.resolve(__dirname, \x27app\x27)\n                ],\n                exclude: [ \/\/ 忽略这里面的文件\n                    path.resolve(__dirname, \x27app\/demo-files\x27)\n                ],\n                use: [ \/\/ 使用那些 Loader，有先后次序，从后往前执行\n                    \x27style-loader\x27, \/\/ 直接使用 Loader 的名称\n                    {\n                        loader: \x27css-loader\x27,\n                        options: { \/\/ 给 html-loader 传一些参数\n                        }\n                    }\n                ]\n            },\n        ],\n        noParse: [ \/\/ 不用解析和处理的模块\n            \/special-library\\.js$\/  \/\/ 用正则匹配\n        ],\n    },\n\n    \/\/ 配置插件\n    plugins: [],\n\n    \/\/ 配置寻找模块的规则\n    resolve: {\n        modules: [ \/\/ 寻找模块的根目录，array 类型，默认以 node_modules 为根目录\n            \x27node_modules\x27,\n            path.resolve(__dirname, \x27app\x27)\n        ],\n        extensions: [\x27.js\x27, \x27.json\x27, \x27.jsx\x27, \x27.css\x27], \/\/ 模块的后缀名\n        alias: { \/\/ 模块别名配置，用于映射模块\n            \/\/ 把 \x27module\x27 映射 \x27new-module\x27，同样的 \x27module\/path\/file\x27 也会被映射成 \x27new-module\/path\/file\x27\n            \x27module\x27: \x27new-module\x27,\n            \/\/ 使用结尾符号 $ 后，把 \x27only-module\x27 映射成 \x27new-module\x27，\n            \/\/ 但是不像上面的，\x27module\/path\/file\x27 不会被映射成 \x27new-module\/path\/file\x27\n            \x27only-module$\x27: \x27new-module\x27,\n        },\n        alias: [ \/\/ alias 还支持使用数组来更详细的配置\n            {\n                name: \x27module\x27, \/\/ 老的模块\n                alias: \x27new-module\x27, \/\/ 新的模块\n                \/\/ 是否是只映射模块，如果是 true 只有 \x27module\x27 会被映射，如果是 false \x27module\/inner\/path\x27 也会被映射\n                onlyModule: true,\n            }\n        ],\n        symlinks: true, \/\/ 是否跟随文件软链接去搜寻模块的路径\n        descriptionFiles: [\x27package.json\x27], \/\/ 模块的描述文件\n        mainFields: [\x27main\x27], \/\/ 模块的描述文件里的描述入口的文件的字段名称\n        enforceExtension: false, \/\/ 是否强制导入语句必须要写明文件后缀\n    },\n\n    \/\/ 输出文件性能检查配置\n    performance: {\n        hints: \x27warning\x27, \/\/ 有性能问题时输出警告\n        hints: \x27error\x27, \/\/ 有性能问题时输出错误\n        hints: false, \/\/ 关闭性能检查\n        maxAssetSize: 200000, \/\/ 最大文件大小 (单位 bytes)\n        maxEntrypointSize: 400000, \/\/ 最大入口文件大小 (单位 bytes)\n        assetFilter: function (assetFilename) { \/\/ 过滤要检查的文件\n            return assetFilename.endsWith(\x27.css\x27) || assetFilename.endsWith(\x27.js\x27);\n        }\n    },\n\n    devtool: \x27source-map\x27, \/\/ 配置 source-map 类型\n\n    context: __dirname, \/\/ Webpack 使用的根目录，string 类型必须是绝对路径\n\n    \/\/ 配置输出代码的运行环境\n    target: \x27web\x27, \/\/ 浏览器，默认\n    target: \x27webworker\x27, \/\/ WebWorker\n    target: \x27node\x27, \/\/ Node.js，使用 `require` 语句加载 Chunk 代码\n    target: \x27async-node\x27, \/\/ Node.js，异步加载 Chunk 代码\n    target: \x27node-webkit\x27, \/\/ nw.js\n    target: \x27electron-main\x27, \/\/ electron, 主线程\n    target: \x27electron-renderer\x27, \/\/ electron, 渲染线程\n\n    externals: { \/\/ 使用来自 JavaScript 运行环境提供的全局变量\n        jquery: \x27jQuery\x27\n    },\n\n    stats: { \/\/ 控制台输出日志控制\n        assets: true,\n        colors: true,\n        errors: true,\n        errorDetails: true,\n        hash: true,\n    },\n\n    devServer: { \/\/ DevServer 相关的配置\n        proxy: { \/\/ 代理到后端服务接口\n            \x27\/api\x27: \x27http:\/\/localhost:3000\x27\n        },\n        contentBase: path.join(__dirname, \x27public\x27), \/\/ 配置 DevServer HTTP 服务器的文件根目录\n        compress: true, \/\/ 是否开启 gzip 压缩\n        historyApiFallback: true, \/\/ 是否开发 HTML5 History API 网页\n        hot: true, \/\/ 是否开启模块热替换功能\n        https: false, \/\/ 是否开启 HTTPS 模式\n    },\n\n    profile: true, \/\/ 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳\n\n    cache: false, \/\/ 是否启用缓存提升构建速度\n\n    watch: true, \/\/ 是否开始\n    watchOptions: { \/\/ 监听模式选项\n        \/\/ 不监听的文件或文件夹，支持正则匹配。默认为空\n        ignored: \/node_modules\/,\n        \/\/ 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\n        \/\/ 默认为300ms\n        aggregateTimeout: 300,\n        \/\/ 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次\n        poll: 1000\n    },\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型可以是 string | object | array\x3c\/span\x3e\n    entry: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有1个入口，入口只有1个文件\x3c\/span\x3e\n    entry: [\x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry2\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有1个入口，入口有2个文件\x3c\/span\x3e\n    entry: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有2个入口\x3c\/span\x3e\n        a: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry-a\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry-b1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\/entry-b2\x27\x3c\/span\x3e]\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。\x3c\/span\x3e\n    output: {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件存放的目录，必须是 string 类型的绝对路径。\x3c\/span\x3e\n        path: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27dist\x27\x3c\/span\x3e),\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件的名称\x3c\/span\x3e\n        filename: \x3cspan class=\x22hljs-string\x22\x3e\x27bundle.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 完整的名称\x3c\/span\x3e\n        filename: \x3cspan class=\x22hljs-string\x22\x3e\x27[name].js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称\x3c\/span\x3e\n        filename: \x3cspan class=\x22hljs-string\x22\x3e\x27[chunkhash].js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布到线上的所有资源的 URL 前缀，string 类型\x3c\/span\x3e\n        publicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27\/assets\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 放到指定目录下\x3c\/span\x3e\n        publicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 放到根目录下\x3c\/span\x3e\n        publicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/cdn.example.com\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 放到 CDN 上去\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出库的名称，string 类型\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不填它时，默认输出格式是匿名的立即执行函数\x3c\/span\x3e\n        library: \x3cspan class=\x22hljs-string\x22\x3e\x27MyLibrary\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出库的类型，枚举类型，默认是 var\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ，\x3c\/span\x3e\n        libraryTarget: \x3cspan class=\x22hljs-string\x22\x3e\x27umd\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否包含有用的文件路径信息到生成的代码里去，boolean 类型\x3c\/span\x3e\n        pathinfo: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 附加 Chunk 的文件名称\x3c\/span\x3e\n        chunkFilename: \x3cspan class=\x22hljs-string\x22\x3e\x27[id].js\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3echunkFilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27[chunkhash].js\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用\x3c\/span\x3e\n        jsonpFunction: \x3cspan class=\x22hljs-string\x22\x3e\x27myWebpackJsonp\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成的 Source Map 文件名称\x3c\/span\x3e\n        sourceMapFilename: \x3cspan class=\x22hljs-string\x22\x3e\x27[file].map\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 浏览器开发者工具里显示的源码模块名称\x3c\/span\x3e\n        devtoolModuleFilenameTemplate: \x3cspan class=\x22hljs-string\x22\x3e\x27webpack:\/\/\/[resource-path]\x27\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异步加载跨域的资源时使用的方式\x3c\/span\x3e\n        crossOriginLoading: \x3cspan class=\x22hljs-string\x22\x3e\x27use-credentials\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecrossOriginLoading\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27anonymous\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecrossOriginLoading\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置模块相关\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3erules\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置 Loader\x3c\/span\x3e\n            {\n                \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.jsx?$\/\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正则匹配命中要使用 Loader 的文件\x3c\/span\x3e\n                include: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只会命中这里面的文件\x3c\/span\x3e\n                    path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e)\n                ],\n                \x3cspan class=\x22hljs-attr\x22\x3eexclude\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 忽略这里面的文件\x3c\/span\x3e\n                    path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27app\/demo-files\x27\x3c\/span\x3e)\n                ],\n                \x3cspan class=\x22hljs-attr\x22\x3euse\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用那些 Loader，有先后次序，从后往前执行\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直接使用 Loader 的名称\x3c\/span\x3e\n                    {\n                        \x3cspan class=\x22hljs-attr\x22\x3eloader\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e,\n                        \x3cspan class=\x22hljs-attr\x22\x3eoptions\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给 html-loader 传一些参数\x3c\/span\x3e\n                        }\n                    }\n                ]\n            },\n        ],\n        \x3cspan class=\x22hljs-attr\x22\x3enoParse\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不用解析和处理的模块\x3c\/span\x3e\n            \/special-library\\.js$\/  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用正则匹配\x3c\/span\x3e\n        ],\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置插件\x3c\/span\x3e\n    plugins: [],\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置寻找模块的规则\x3c\/span\x3e\n    resolve: {\n        \x3cspan class=\x22hljs-attr\x22\x3emodules\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 寻找模块的根目录，array 类型，默认以 node_modules 为根目录\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e,\n            path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e)\n        ],\n        \x3cspan class=\x22hljs-attr\x22\x3eextensions\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.json\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.jsx\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.css\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块的后缀名\x3c\/span\x3e\n        alias: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块别名配置，用于映射模块\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把 \x27module\x27 映射 \x27new-module\x27，同样的 \x27module\/path\/file\x27 也会被映射成 \x27new-module\/path\/file\x27\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\x27module\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27new-module\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用结尾符号 $ 后，把 \x27only-module\x27 映射成 \x27new-module\x27，\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但是不像上面的，\x27module\/path\/file\x27 不会被映射成 \x27new-module\/path\/file\x27\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\x27only-module$\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27new-module\x27\x3c\/span\x3e,\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3ealias\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ alias 还支持使用数组来更详细的配置\x3c\/span\x3e\n            {\n                \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27module\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 老的模块\x3c\/span\x3e\n                alias: \x3cspan class=\x22hljs-string\x22\x3e\x27new-module\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新的模块\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否是只映射模块，如果是 true 只有 \x27module\x27 会被映射，如果是 false \x27module\/inner\/path\x27 也会被映射\x3c\/span\x3e\n                onlyModule: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            }\n        ],\n        \x3cspan class=\x22hljs-attr\x22\x3esymlinks\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否跟随文件软链接去搜寻模块的路径\x3c\/span\x3e\n        descriptionFiles: [\x3cspan class=\x22hljs-string\x22\x3e\x27package.json\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块的描述文件\x3c\/span\x3e\n        mainFields: [\x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块的描述文件里的描述入口的文件的字段名称\x3c\/span\x3e\n        enforceExtension: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否强制导入语句必须要写明文件后缀\x3c\/span\x3e\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件性能检查配置\x3c\/span\x3e\n    performance: {\n        \x3cspan class=\x22hljs-attr\x22\x3ehints\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27warning\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有性能问题时输出警告\x3c\/span\x3e\n        hints: \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有性能问题时输出错误\x3c\/span\x3e\n        hints: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 关闭性能检查\x3c\/span\x3e\n        maxAssetSize: \x3cspan class=\x22hljs-number\x22\x3e200000\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最大文件大小 (单位 bytes)\x3c\/span\x3e\n        maxEntrypointSize: \x3cspan class=\x22hljs-number\x22\x3e400000\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最大入口文件大小 (单位 bytes)\x3c\/span\x3e\n        assetFilter: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eassetFilename\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 过滤要检查的文件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e assetFilename.endsWith(\x3cspan class=\x22hljs-string\x22\x3e\x27.css\x27\x3c\/span\x3e) || assetFilename.endsWith(\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e);\n        }\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3edevtool\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置 source-map 类型\x3c\/span\x3e\n\n    context: __dirname, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 使用的根目录，string 类型必须是绝对路径\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置输出代码的运行环境\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27web\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 浏览器，默认\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27webworker\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ WebWorker\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27node\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Node.js，使用 `require` 语句加载 Chunk 代码\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27async-node\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Node.js，异步加载 Chunk 代码\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27node-webkit\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nw.js\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27electron-main\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ electron, 主线程\x3c\/span\x3e\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27electron-renderer\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ electron, 渲染线程\x3c\/span\x3e\n\n    externals: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用来自 JavaScript 运行环境提供的全局变量\x3c\/span\x3e\n        jquery: \x3cspan class=\x22hljs-string\x22\x3e\x27jQuery\x27\x3c\/span\x3e\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3estats\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 控制台输出日志控制\x3c\/span\x3e\n        assets: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecolors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eerrors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eerrorDetails\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ehash\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3edevServer\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ DevServer 相关的配置\x3c\/span\x3e\n        proxy: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 代理到后端服务接口\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\x27\/api\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:3000\x27\x3c\/span\x3e\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3econtentBase\x3c\/span\x3e: path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27public\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置 DevServer HTTP 服务器的文件根目录\x3c\/span\x3e\n        compress: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开启 gzip 压缩\x3c\/span\x3e\n        historyApiFallback: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开发 HTML5 History API 网页\x3c\/span\x3e\n        hot: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开启模块热替换功能\x3c\/span\x3e\n        https: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开启 HTTPS 模式\x3c\/span\x3e\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3eprofile\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳\x3c\/span\x3e\n\n    cache: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否启用缓存提升构建速度\x3c\/span\x3e\n\n    watch: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开始\x3c\/span\x3e\n    watchOptions: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听模式选项\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不监听的文件或文件夹，支持正则匹配。默认为空\x3c\/span\x3e\n        ignored: \x3cspan class=\x22hljs-regexp\x22\x3e\/node_modules\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为300ms\x3c\/span\x3e\n        aggregateTimeout: \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次\x3c\/span\x3e\n        poll: \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e\n    },\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader51\x22\x3e多种配置类型\x3c\/h2\x3e\n\x3cp\x3e除了通过导出一个 Object 来描述 Webpack 所需的配置外，还有其它更灵活的方式，以简化不同场景的配置。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader52\x22\x3e导出一个 Function\x3c\/h3\x3e\n\x3cp\x3e在大多数时候你需要从同一份源代码中构建出多份代码，例如一份用于开发时，一份用于发布到线上。\x3c\/p\x3e\n\x3cp\x3e如果采用导出一个 Object 来描述 Webpack 所需的配置的方法，需要写两个文件。 一个用于开发环境，一个用于线上环境。再在启动时通过 \x3ccode\x3ewebpack --config webpack.config.js\x3c\/code\x3e 指定使用哪个配置文件。\x3c\/p\x3e\n\x3cp\x3e采用导出一个 Function 的方式，能通过 JavaScript 灵活的控制配置，做到只写一个配置文件就能完成以上要求。\x3c\/p\x3e\n\x3cp\x3e导出一个 Function 的使用方式如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\nconst UglifyJsPlugin = require(\x27webpack\/lib\/optimize\/UglifyJsPlugin\x27);\n\nmodule.exports = function (env = {}, argv) {\n    const plugins = [];\n\n    const isProduction = env[\x27production\x27];\n\n    \/\/ 在生成环境才压缩\n    if (isProduction) {\n        plugins.push(\n            \/\/ 压缩输出的 JS 代码\n            new UglifyJsPlugin()\n        )\n    }\n\n    return {\n        plugins: plugins,\n        \/\/ 在生成环境不输出 Source Map\n        devtool: isProduction ? undefined : \x27source-map\x27,\n    };\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e UglifyJsPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\/lib\/optimize\/UglifyJsPlugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eenv = {}, argv\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e plugins = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isProduction = env[\x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e];\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在生成环境才压缩\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isProduction) {\n        plugins.push(\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩输出的 JS 代码\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e UglifyJsPlugin()\n        )\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e: plugins,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在生成环境不输出 Source Map\x3c\/span\x3e\n        devtool: isProduction ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e,\n    };\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在运行 Webpack 时，会给这个函数传入2个参数，分别是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eenv\x3c\/code\x3e：当前运行时的 Webpack 专属环境变量，\x3ccode\x3eenv\x3c\/code\x3e 是一个 Object。读取时直接访问 Object 的属性，设置它需要在启动 Webpack 时带上参数。例如启动命令是 \x3ccode\x3ewebpack --env.production --env.bao=foo\x3c\/code\x3e 时，则 \x3ccode\x3eenv\x3c\/code\x3e 的值是 \x3ccode\x3e{\x22production\x22:\x22true\x22,\x22bao\x22:\x22foo\x22}\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eargv\x3c\/code\x3e：代表在启动 Webpack 时所有通过命令行传入的参数，例如 \x3ccode\x3e--config、--env、--devtool\x3c\/code\x3e，可以通过 \x3ccode\x3ewebpack -h\x3c\/code\x3e 列出所有 Webpack 支持的命令行参数。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e就以上配置文件而言，在开发时执行命令 webpack 构建出方便调试的代码，在需要构建出发布到线上的代码时执行 \x3ccode\x3ewebpack --env.production\x3c\/code\x3e 构建出压缩的代码。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader53\x22\x3e导出一个返回 Promise 的函数\x3c\/h3\x3e\n\x3cp\x3e在有些情况下你不能以同步的方式返回一个描述配置的 Object，Webpack 还支持导出一个返回 Promise 的函数，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(env = {}, argv) {\n  return new Promise((resolve, reject) =\x3e {\n    setTimeout(() =\x3e {\n      resolve({\n        \/\/ ...\n      })\n    }, 5000)\n  })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eenv = {}, argv\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      resolve({\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n      })\n    }, \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e)\n  })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader54\x22\x3e导出多份配置\x3c\/h3\x3e\n\x3cp\x3e除了只导出一份配置外，Webpack 还支持导出一个数组，数组中可以包含每份配置，并且每份配置都会执行一遍构建。\x3c\/p\x3e\n\x3cp\x3e使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = [\n  \/\/ 采用 Object 描述的一份配置\n  {\n    \/\/ ...\n  },\n  \/\/ 采用函数描述的一份配置\n  function() {\n    return {\n      \/\/ ...\n    }\n  },\n  \/\/ 采用异步函数描述的一份配置\n  function() {\n    return Promise();\n  }\n]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = [\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用 Object 描述的一份配置\x3c\/span\x3e\n  {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用函数描述的一份配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    }\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用异步函数描述的一份配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e();\n  }\n]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上配置会导致 Webpack 针对这三份配置执行三次不同的构建。\x3c\/p\x3e\n\x3cp\x3e这特别适合于用 Webpack 构建一个要上传到 Npm 仓库的库，因为库中可能需要包含多种模块化格式的代码，例如 CommonJS、UMD。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader55\x22\x3e配置总结\x3c\/h2\x3e\n\x3cp\x3e从前面的配置看来选项很多，Webpack 内置了很多功能。 \x3c\/p\x3e\n\x3cp\x3e你不必都记住它们，只需要大概明白 Webpack 原理和核心概念去判断选项大致属于哪个大模块下，再去查详细的使用文档。\x3c\/p\x3e\n\x3cp\x3e通常你可用如下经验去判断如何配置 Webpack：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e想让\x3cstrong\x3e源文件\x3c\/strong\x3e加入到构建流程中去被 Webpack 控制，配置 \x3ccode\x3eentry\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e想自定义\x3cstrong\x3e输出文件的位置和名称\x3c\/strong\x3e，配置 \x3ccode\x3eoutput\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e想自定义\x3cstrong\x3e寻找依赖模块时的策略\x3c\/strong\x3e，配置 \x3ccode\x3eresolve\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e想自定义\x3cstrong\x3e解析和转换文件的策略\x3c\/strong\x3e，配置 \x3ccode\x3emodule\x3c\/code\x3e，通常是配置 \x3ccode\x3emodule.rules\x3c\/code\x3e 里的 Loader。\x3c\/li\x3e\n\x3cli\x3e其它的大部分需求可能要通过 Plugin 去实现，配置 \x3ccode\x3eplugin\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webpack配置</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014982619">https://segmentfault.com/a/1190000014982619</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/37kkml4eopd/" target="_blank">https://alili.tech/archive/37kkml4eopd/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>