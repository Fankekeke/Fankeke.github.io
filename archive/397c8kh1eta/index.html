<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/397c8kh1eta/",
				"appid": "1613049289050283", 
				"title": "另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-25T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/gnzyhhtlhz/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1zj70htq813/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&text=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&text=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&title=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&is_video=false&description=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&title=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&title=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&title=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f397c8kh1eta%2f&title=%e5%8f%a6%e8%be%9f%e8%b9%8a%e5%be%84%ef%bc%9avue%e5%8d%95%e9%a1%b5%e9%9d%a2%ef%bc%8c%e5%a4%9a%e8%b7%af%e7%94%b1%ef%bc%8c%e5%89%8d%e8%bf%9b%e5%88%b7%e6%96%b0%ef%bc%8c%e5%90%8e%e9%80%80%e4%b8%8d%e5%88%b7%e6%96%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新</h1><div class="meta"><div class="postdate"><time datetime="2018-12-25" itemprop="datePublished">2018-12-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e目的：vue-cli构建的vue单页面应用，某些特定的页面，实现前进刷新，后退不刷新，类似app般的用户体验。\x3cbr\x3e注：　此处的刷新特指当进入此页面时，触发ajax请求，向服务器获取数据。不刷新特指当进入此页面时，不触发ajax请求，而是使用之前缓存的数据，以便减少服务器请求，用户体验更流畅。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e项目需求：\x3c\/h3\x3e\n\x3cp\x3e任何技术的探索，都来自项目的需求。之前经手的一个项目是微信端商城，使用的是传统的mvc模式，利用的是jq\x2bjs，因此对于商城的项目需求比较熟悉。目前在学习vue，练手一个商城，遇到之前经常提及而无法很好解决的需求。有些页面需要前进刷新，后退不刷新。比如，从商城的【首页】--\x26gt;【详情页】--\x26gt;【订单提交页】，每次打开新页面都需要获取新数据，但是按下返回键后，就不需要再获取新数据了，而滚动条还保留在之前的位置。最常见的操作是从【首页】--\x26gt;【详情页】，然后在从【详情页】--\x26gt;【首页】，如此反复。\x3cbr\x3e实例如图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYPIY?w=377\x26amp;h=672\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYPIY?w=377\x26amp;h=672\x22 alt=\x22首页\x22 title=\x22首页\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYPIn?w=381\x26amp;h=671\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYPIn?w=381\x26amp;h=671\x22 alt=\x22详情页\x22 title=\x22详情页\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYPIw?w=374\x26amp;h=671\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYPIw?w=374\x26amp;h=671\x22 alt=\x22订单提交页\x22 title=\x22订单提交页\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e前人经验：\x3c\/h3\x3e\n\x3cp\x3e前人栽树，后人好乘凉。技术圈的分享一直都在蓬勃发展。遇到问题，我们可以尽情去搜索，去寻找大佬的足迹。针对上述需求，看到一个分享\x3ca href=\x22http:\/\/www.jianshu.com\/p\/0b0222954483\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-router 之 keep-alive\x3c\/a\x3e，比较符合我的需求，但是使用到我的项目上发现，稍微有点不适合。此分享技术要点，比较适合两个页面之前的跳转，返回。而我的页面是多个路由（2\x2b）之间的跳转，返回。无奈，只能去自己探索发现。不过此技术要点给了我很好的启发，特此感谢作者。@ RoamIn\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e实现思路：\x3c\/h3\x3e\n\x3cp\x3e注：demo中，index页面包含三个链接导航。page1--\x26gt;page2--\x26gt;page3.依次前进，每次前进到一个新页面都需要获取数据，而按下后退键后，从page3返回到page2，page2不再获取新数据，而是使用之前缓存的数据。从page2返回到page1时，page1不再获取新数据，而是使用之前的数据。所以，page1和page2需要缓存，page3不需要缓存。可以把page1想象成首页，page2想象成详情页，page3想象成订单提交页。这样方便理解。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ch4\x3e利用keep-alive 缓存需要缓存的页面\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e在app.vue中改写router-view\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ckeep-alive\x3e\n    \x3crouter-view v-if=\x26quot;$route.meta.keepAlive\x26quot;\x3e\n        \x3c!-- 这里是会被缓存的视图组件，比如 page1,page2 --\x3e\n    \x3c\/router-view\x3e\n\x3c\/keep-alive\x3e\n\n\x3crouter-view v-if=\x26quot;!$route.meta.keepAlive\x26quot;\x3e\n    \x3c!-- 这里是不被缓存的视图组件，比如 page3 --\x3e\n\x3c\/router-view\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ekeep-alive\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-if\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22$route.meta.keepAlive\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 这里是会被缓存的视图组件，比如 page1,page2 --\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ekeep-alive\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-if\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22!$route.meta.keepAlive\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 这里是不被缓存的视图组件，比如 page3 --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e在router\/index.js中添加\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/advanced\/meta.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e路由元信息\x3c\/a\x3e，设置需要缓存的页面\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22routes: [{\n        path: \x27\/\x27,\n        name: \x27index\x27,\n        component: index,\n        meta: {\n            keepAlive: false, \/\/此组件不需要被缓存\n        }\n    },\n    {\n        path: \x27\/page1\x27,\n        name: \x27page1\x27,\n        component: page1,\n        meta: {\n            keepAlive: true, \/\/此组件需要被缓存\n            \n        }\n    },\n    {\n        path: \x27\/page2\x27,\n        name: \x27page2\x27,\n        component: page2,\n        meta: {\n            keepAlive: true, \/\/ 此组件需要被缓存\n           \n        }\n    },\n    {\n        path: \x27\/page3\x27,\n        name: \x27page3\x27,\n        component: page3,\n        meta: {\n            keepAlive: false, \/\/ 此组件不需要被缓存\n        }\n    }\n]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3eroutes\x3c\/span\x3e: [{\n        \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27index\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: index,\n        \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: false, \x3cspan class=\x22hljs-comment\x22\x3e\/\/此组件不需要被缓存\x3c\/span\x3e\n        }\n    },\n    {\n        \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/page1\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page1\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: page1,\n        \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: true, \x3cspan class=\x22hljs-comment\x22\x3e\/\/此组件需要被缓存\x3c\/span\x3e\n            \n        }\n    },\n    {\n        \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/page2\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page2\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: page2,\n        \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: true, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此组件需要被缓存\x3c\/span\x3e\n           \n        }\n    },\n    {\n        \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/page3\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page3\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: page3,\n        \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: false, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此组件不需要被缓存\x3c\/span\x3e\n        }\n    }\n]\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e钩子函数的执行顺序\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e不使用keep-alive\x3cbr\x3e beforeRouteEnter --\x26gt; created --\x26gt; mounted --\x26gt; destroyed\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用keep-alive\x3cbr\x3e beforeRouteEnter --\x26gt; created --\x26gt; mounted --\x26gt; activated --\x26gt; deactivated\x3cbr\x3e 再次进入缓存的页面，只会触发beforeRouteEnter --\x26gt;activated --\x26gt; deactivated 。created和mounted不会再执行。我们可以利用不同的钩子函数，做不同的事。\x3cstrong\x3e务必理解上述钩子函数的执行时机和执行顺序，本教程的核心就依赖于此钩子函数\x3c\/strong\x3e\x3cbr\x3e\x3cem\x3eactivated和deactivated是使用keep-alive后，vue中比较重要的两个钩子函数，建议详细了解下\x3c\/em\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ch4\x3e需缓存的页面的写法\x3c\/h4\x3e\n\x3cp\x3e注：demo中的page1和page2，这两个页面都需要缓存，思路一样，以下以page1为例，page2不再赘述。\x3cbr\x3e示例文件：\x3cem\x3ecomponents\/page1.vue\x3c\/em\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3edata中初始化一个str字符串，存放从后台获取的数据\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     data() {\n       return {\n         msg: \x26quot;我是第一个页面\x26quot;,\n         str: \x26quot;\x26quot;  \/\/ 加载页面后执行获取数据的方法，插入到此\n       };\n     }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e     data() {\n       \x3cspan class=\x22hljs-class\x22\x3ereturn \x3c\/span\x3e{\n\x3cspan class=\x22hljs-symbol\x22\x3e         msg:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22我是第一个页面\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e         str:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载页面后执行获取数据的方法，插入到此\x3c\/span\x3e\n       };\n     }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3emethods中创建一个方法，模拟从后台获取数据\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     methods: {\n       getData() {\n         \/\/ getData方法，模拟从后台请求数据\n         this.str = \x26quot;我是通过调用方法加载的数据。。。\x26quot;;\n       }\n     }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs axapta\x22\x3e\x3ccode\x3e     methods: {\n       getData() {\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getData方法，模拟从后台请求数据\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3estr\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22我是通过调用方法加载的数据。。。\x22\x3c\/span\x3e;\n       }\n     }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e修改router\/index.js中的配置\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e每次进入页面，我们都需要知晓是从哪个页面进来的，用以判断是否需要获取数据。以这个page1页面为例，当我们知晓是从page2过来的，我们就可以认为是用户操作了返回键，这时page1页面就不需要再获取新数据了，使用之前缓存的数据就可以了。如果是从别的页面过来的，我们就需要获取数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们可以通过\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/advanced\/navigation-guards.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebeforeRouteEnter\x3c\/a\x3e这个钩子函数中的from参数判断是从哪个页面过来的，这个参数执行时，组件实例还没创建，所有不能在data中定义变量。我们可以在路由中定义一个变量，用来判断。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在router\/index.js的meta中添加isBack变量，默认false\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     {\n          path: \x27\/page1\x27,\n          name: \x27page1\x27,\n          component: page1,\n          meta: {\n              keepAlive: true, \/\/此组件需要被缓存\n              isBack:false, \/\/用于判断上一个页面是哪个\n          }\n      },\n      {\n          path: \x27\/page2\x27,\n          name: \x27page2\x27,\n          component: page2,\n          meta: {\n              keepAlive: true, \/\/ 此组件需要被缓存\n              isBack:false, \/\/用于判断上一个页面是哪个\n          }\n      },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e     {\n          \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/page1\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page1\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: page1,\n          \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n              \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: true, \x3cspan class=\x22hljs-comment\x22\x3e\/\/此组件需要被缓存\x3c\/span\x3e\n              \x3cspan class=\x22hljs-attribute\x22\x3eisBack\x3c\/span\x3e:false, \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于判断上一个页面是哪个\x3c\/span\x3e\n          }\n      },\n      {\n          \x3cspan class=\x22hljs-attribute\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/page2\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page2\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attribute\x22\x3ecomponent\x3c\/span\x3e: page2,\n          \x3cspan class=\x22hljs-attribute\x22\x3emeta\x3c\/span\x3e: {\n              \x3cspan class=\x22hljs-attribute\x22\x3ekeepAlive\x3c\/span\x3e: true, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此组件需要被缓存\x3c\/span\x3e\n              \x3cspan class=\x22hljs-attribute\x22\x3eisBack\x3c\/span\x3e:false, \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于判断上一个页面是哪个\x3c\/span\x3e\n          }\n      },\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ebeforeRouteEnter中判断是从哪个页面过来的\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e判断是从哪个路由过来的，如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    beforeRouteEnter(to, from, next) {\n      \/\/ 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）\n      \/\/ 参考 https:\/\/router.vuejs.org\/zh-cn\/advanced\/navigation-guards.html\n      \/\/ 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack\n      \/\/ 参考 https:\/\/router.vuejs.org\/zh-cn\/advanced\/meta.html\n      if(from.name==\x27page2\x27){\n          to.meta.isBack=true;\n          \/\/判断是从哪个路由过来的，\n          \/\/如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可\n      }\n  \n      next();\n    },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3e    beforeRouteEnter(\x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e, next) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参考 https:\/\/router.vuejs.org\/zh-cn\/advanced\/navigation-guards.html\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参考 https:\/\/router.vuejs.org\/zh-cn\/advanced\/meta.html\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e==\x3cspan class=\x22hljs-string\x22\x3e\x27page2\x27\x3c\/span\x3e){\n          \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e.meta.isBack=\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断是从哪个路由过来的，\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可\x3c\/span\x3e\n      }\n  \n      next();\n    },\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eactivated中执行getData这个获取数据的方法\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e因为这个页面需要缓存。只有第一次进入时才会执行created和mounted方法，再次进入就不执行了。而activated每次进入都执行，所以在这个钩子函数中获取数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22activated() {\n  if(!this.$route.meta.isBack){\n    \/\/ 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\n    this.getData();\n  }\n  \/\/ 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据\n  this.$route.meta.isBack=false\n\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eactivated() {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.meta.isBack){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getData();\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.meta.isBack=\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e这样就可以了？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e当这样设置完毕后，你执行起来，貌似是可以了。第一次进入page1，能获取新数据，从page2返回时，不再获取新数据了，而是使用之前缓存的数据。但这样还有一个问题，当用户从page1进入page2后，因为某种原因，手动刷新了page2的页面。这时再返回到page1，发现之前缓存的数据丢失了，而且也没有再重新获取。所以我们还需要再添加一个判断条件，当用户手动刷新页面后，再返回时就需要重新获取数据了。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如何添加这个条件，判断用户是否刷新了页面呢？我们知道，当使用keep-alive后，只有第一次进入后会触发created钩子函数，再次进入就不再执行了。当用户刷新了页面，这个钩子函数就会又执行，所以，我们可以利用这个小技巧来做点文章。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3edata中定义变量isFirstEnter用来判断是否第一次进入，或是否刷新了页面，默认false\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   data() {\n     return {\n       msg: \x26quot;我是第一个页面\x26quot;,\n       str: \x26quot;\x26quot;,  \/\/ 加载页面后执行获取数据的方法，插入到此\n       isFirstEnter:false \/\/ 是否第一次进入，默认false\n     };\n   },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e   data() {\n     \x3cspan class=\x22hljs-class\x22\x3ereturn \x3c\/span\x3e{\n\x3cspan class=\x22hljs-symbol\x22\x3e       msg:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22我是第一个页面\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e       str:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载页面后执行获取数据的方法，插入到此\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e       isFirstEnter:\x3c\/span\x3efalse \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否第一次进入，默认false\x3c\/span\x3e\n     };\n   },\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ecreated中把isFirstEnter变为true，说明是第一次进入或刷新了页面\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   created() {\n     this.isFirstEnter=true;\n     \/\/ 只有第一次进入或者刷新页面后才会执行此钩子函数\n     \/\/ 使用keep-alive后（2\x2b次）进入不会再执行此钩子函数\n   },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e   created() {\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isFirstEnter=\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有第一次进入或者刷新页面后才会执行此钩子函数\x3c\/span\x3e\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用keep-alive后（2\x2b次）进入不会再执行此钩子函数\x3c\/span\x3e\n   },\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eactivated中增加判断条件\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   activated() {\n     if(!this.$route.meta.isBack || this.isFirstEnter){\n         \/\/ 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\n         \/\/ 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据\n         this.str=\x27\x27\/\/ 把数据清空，可以稍微避免让用户看到之前缓存的数据\n         this.getData();\n     }\n     \/\/ 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据\n     this.$route.meta.isBack=false\n     \/\/ 恢复成默认的false，避免isBack一直是true，导致每次都获取新数据\n     this.isFirstEnter=false;\n \n   },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e   activated() {\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.meta.isBack || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isFirstEnter){\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\x3c\/span\x3e\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.str=\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把数据清空，可以稍微避免让用户看到之前缓存的数据\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getData();\n     }\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据\x3c\/span\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.meta.isBack=\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复成默认的false，避免isBack一直是true，导致每次都获取新数据\x3c\/span\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isFirstEnter=\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n \n   },\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e这样应该就可以了\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ch4\x3e不需要缓存页面的写法\x3c\/h4\x3e\n\x3cp\x3e注：demo中的page3，这个页面不需要缓存，该怎么写就怎么写，不需要做特别的设置。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e其它设置：\x3c\/h3\x3e\n\x3cp\x3e使用keep-alive后，可能有点小问题：第二个页面可能继承第一个页面的滚动条的高度。（在我项目中遇到的）\x3cbr\x3e比如：page1向下滚动后，再进入page2，这时page2的滚动条可能是之前的高度，可能不会在顶部。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e解决方法一\x3cbr\x3e每次离开记录滚动条的高度，再次进入时根据项目需要再恢复之前的高度，或者置顶。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e解决方法二（推荐）\x3cbr\x3erouter\/index.js中添加如下代码（如不理解，请看参考链接）\x3cbr\x3e参考：\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/essentials\/history-mode.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 History 模式\x3c\/a\x3e　　　　　\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/advanced\/scroll-behavior.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e滚动行为\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  mode: \x27history\x27,\n  scrollBehavior(to, from, savedPosition) {\n      if (savedPosition) {\n          return savedPosition\n      } else {\n          return {\n              x: 0,\n              y: 0\n          }\n      }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e  mode: \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e,\n  scrollBehavior(to, from, savedPosition) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (savedPosition) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e savedPosition\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n              x: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n              y: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n          }\n      }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e疑问点：\x3c\/h3\x3e\n\x3cp\x3e在此次demo练习中，打印了一下钩子函数的执行顺序，发现一个疑问点(我对钩子函数理解也很浅显)：\x3cbr\x3e从page1进入page2时，先执行了page2的beforeRouteEnter和created方法，然后才执行page1的deactivated方法。\x3cbr\x3e所以我把这两个初始化设置，放在了activated里面，而没有放在deactivated中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    this.$route.meta.isBack=false;\n    this.isFirstEnter=false;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.meta.isBack=\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isFirstEnter=\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYRj2?w=296\x26amp;h=244\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYRj2?w=296\x26amp;h=244\x22 alt=\x22钩子函数执行顺序\x22 title=\x22钩子函数执行顺序\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e结束语：\x3c\/h3\x3e\n\x3cp\x3e为了解决这个前进刷新后退不刷新问题，让我整整苦恼了一周时间，想了很多方法，也没能解决。最后综合各个大佬经验，试验了很多次，才归结出这个比较‘low’的方法。\x3cbr\x3e目前，我也是vue小白，也在探索着前进，如果这个方法能解决你遇到的难题，我很高兴。如果你认为的确很low，求轻喷。\x3cbr\x3edemo在下方的GitHub中，欢迎star。\x3cbr\x3e也欢迎大家提供意见和建议，谢谢大家\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e\x3ca href=\x22https:\/\/github.com\/bingyang519\/vueGoBack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub\x3c\/a\x3e\x3c\/h2\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012083511">https://segmentfault.com/a/1190000012083511</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/397c8kh1eta/" target="_blank">https://alili.tech/archive/397c8kh1eta/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>