<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="跟着例子一步步学习redux&#43;react-redux"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>跟着例子一步步学习redux&#43;react-redux | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3bvk488gkec/",
				"appid": "1613049289050283", 
				"title": "跟着例子一步步学习redux&#43;react-redux | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-16T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2uett07zngt/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1k3ep9brhs2/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&text=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&text=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&title=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&is_video=false&description=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&title=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&title=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&title=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3bvk488gkec%2f&title=%e8%b7%9f%e7%9d%80%e4%be%8b%e5%ad%90%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ad%a6%e4%b9%a0redux%2breact-redux"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">跟着例子一步步学习redux&#43;react-redux</h1><div class="meta"><div class="postdate"><time datetime="2018-12-16" itemprop="datePublished">2018-12-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e本文不会拿redux、react-redux等一些react的名词去讲解，然后把各自用法举例说明，这样其实对一些react新手或者不太熟悉redux模式的开发人员不够友好，他们并不知道这样使用的原因。本文通过一个简单的例子展开，一点点自己去实现一个redux\x2breact-redux，让大家充分理解redux\x2breact-redux出现的必要。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e预备知识\x3c\/h2\x3e\n\x3cp\x3e在阅读本文之前，希望大家对以下知识点能提前有所了解并且上好厕所（文章有点长）：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e状态提升的概念\x3c\/li\x3e\n\x3cli\x3ereact高阶组件(函数)\x3c\/li\x3e\n\x3cli\x3ees6基础\x3c\/li\x3e\n\x3cli\x3epure 组件(纯函数)\x3c\/li\x3e\n\x3cli\x3eDumb 组件\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eReact.js的context\x3c\/h2\x3e\n\x3cp\x3e这一节的内容其实是讲一个react当中一个你可能永远用不到的特性——context，但是它对你理解react-redux很有好处。那么context是干什么的呢？看下图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xty?w=909\x26amp;h=622\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xty?w=909\x26amp;h=622\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e假设现在这个组件树代表的应用是用户可以自主换主题色的，每个子组件会根据主题色的不同调整自己的字体颜色。“主题色”这个状态是所有组件共享的状态，根据\x3cstrong\x3e状态提升\x3c\/strong\x3e中所提到的，需要把这个状态提升到根节点的 Index 上，然后把这个状态通过 props 一层层传递下去：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xt1?w=910\x26amp;h=609\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xt1?w=910\x26amp;h=609\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e如果要改变主题色，在 Index 上可以直接通过 this.setState({ themeColor: \x27red\x27 }) 来进行。这样整颗组件树就会重新渲染，子组件也就可以根据重新传进来的 props.themeColor 来调整自己的颜色。\x3c\/p\x3e\n\x3cp\x3e但这里的问题也是非常明显的，我们需要把 themeColor 这个状态一层层手动地从组件树顶层往下传，每层都需要写 props.themeColor。如果我们的组件树很层次很深的话，这样维护起来简直是灾难。\x3c\/p\x3e\n\x3cp\x3e如果这颗组件树能够全局共享这个状态就好了，我们要的时候就去取这个状态，不用手动地传：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xHa?w=780\x26amp;h=596\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xHa?w=780\x26amp;h=596\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e就像这样，Index 把 state.themeColor 放到某个地方，这个地方是每个 Index 的子组件都可以访问到的。当某个子组件需要的时候就直接去那个地方拿就好了，而不需要一层层地通过 props 来获取。不管组件树的层次有多深，任何一个组件都可以直接到这个公共的地方提取 themeColor 状态。\x3c\/p\x3e\n\x3cp\x3eReact.js 的 context 就是这么一个东西，某个组件只要往自己的 context 里面放了某些状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间组件的传递。一个组件的 context 只有它的子组件能够访问。\x3cbr\x3e下面我们看看 React.js 的 context 代码怎么写，我们先把整体的组件树搭建起来。\x3cbr\x3e用create-react-app创建工程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22create-react-app react-redux-demo1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dsconfig\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecreate-react-app\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ereact-redux-\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3edemo1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们修改 App，让它往自己的 context 里面放一个 themeColor：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport PropTypes from \x27prop-types\x27;\nimport Header from \x27.\/header\x27;\nimport Main from \x27.\/main\x27;\nimport \x27.\/App.css\x27;\n\nclass App extends Component {\n  static childContextTypes = {\n    themeColor :PropTypes.string\n  }\n  constructor () {\n    super()\n    this.state = {\n      themeColor : \x27red\x27\n    }\n  }\n  getChildContext () {\n    return {\n      themeColor : this.state.themeColor\n    }\n  }\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cHeader \/\x3e\n        \x3cMain \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nexport default App;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Header \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/header\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Main \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/main\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.css\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e childContextTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e :PropTypes.string\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e\n    }\n  }\n  getChildContext () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.themeColor\n    }\n  }\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMain\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e App;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数里面的内容其实就很好理解，就是往 state 里面初始化一个 themeColor 状态。getChildContext 这个方法就是设置 context 的过程，它返回的对象就是 context（也就是上图中处于中间的方块），所有的子组件都可以访问到这个对象。我们用 this.state.themeColor 来设置了 context 里面的 themeColor。\x3c\/p\x3e\n\x3cp\x3e接下来我们要看看子组件怎么获取这个状态，修改 App 的孙子组件 Title和Content：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/title.js\nclass Title extends Component {\n  static contextTypes = {\n    themeColor: PropTypes.string\n  }\n\n  render () {\n    return (\n      \x3ch1 style=\x22{{\x22 color: this.context.themeColor \x22}}\x22\x3eReact.js 小书标题\x3c\/h1\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/title.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTitle\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static contextTypes = {\n    themeColor: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.string\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;h1 style=\x22{{\x22 color: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.themeColor \x22}}\x22\x26gt;\x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.js 小书标题\x26lt;\/h1\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/content.js\nimport React, { Component } from \x27react\x27;\nclass Content extends Component {\n    render () {\n        return (\n        \x3cdiv\x3e\n            \x3ch2\x3ethis is 内容\x3c\/h2\x3e\n        \x3c\/div\x3e\n        )\n    }\n}\n\nexport default Content;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/content.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eContent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x26lt;div\x26gt;\n            \x26lt;h2\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e is 内容\x26lt;\/h2\x26gt;\n        \x26lt;\/div\x26gt;\n        )\n    }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个组件可以通过 getChildContext 方法返回一个对象，这个对象就是子树的 context，提供 context 的组件必须提供 childContextTypes 作为 context 的声明和验证。\x3c\/p\x3e\n\x3cp\x3e如果一个组件设置了 context，那么它的子组件都可以直接访问到里面的内容，它就像这个组件为根的子树的全局变量。任意深度的子组件都可以通过 contextTypes 来声明你想要的 context 里面的哪些状态，然后可以通过 this.context 访问到那些状态。\x3c\/p\x3e\n\x3cp\x3econtext 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e动手实现Redux\x3c\/h2\x3e\n\x3cp\x3e上节内容讲了React.js的content的特性，这个跟redux和react-redux什么关系呢？看下去就知道了，这边先卖个关子：）。Redux 和 React-redux 并不是同一个东西。Redux 是一种架构模式（Flux 架构的一种变种），它不关注你到底用什么库，你可以把它应用到 React 和 Vue，甚至跟 jQuery 结合都没有问题。\x3cstrong\x3e而 React-redux 就是把 Redux 这种架构模式和 React.js 结合起来的一个库，就是 Redux 架构在 React.js 中的体现。\x3c\/strong\x3e这节主要讲如何自己手动实现一个redux模式。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e“大张旗鼓”的修改共享状态\x3c\/h3\x3e\n\x3cp\x3e用 create-react-app 新建一个项目：react-redux-demo2：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22create-react-app react-redux-demo2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dsconfig\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecreate-react-app\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ereact-redux-\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3edemo2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e修改 public\/index.html 里面的 body 结构为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbody\x3e\n    \x3cdiv id=\x27title\x27\x3e\x3c\/div\x3e\n    \x3cdiv id=\x27content\x27\x3e\x3c\/div\x3e\n\x3c\/body\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27title\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27content\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e删除 src\/index.js 里面所有的代码，添加下面代码，代表我们应用的状态：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const appState = {\n  title: {\n    text: \x27this is title\x27,\n    color: \x27red\x27,\n  },\n  content: {\n    text: \x27this is content\x27,\n    color: \x27blue\x27\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e appState = {\n  title: {\n    \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27this is title\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\n  },\n  content: {\n    \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27this is content\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们新增几个渲染函数，它会把上面状态的数据渲染到页面上：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function renderApp (appState) {\n  renderTitle(appState.title)\n  renderContent(appState.content)\n}\n\nfunction renderTitle (title) {\n  const titleDOM = document.getElementById(\x27title\x27)\n  titleDOM.innerHTML = title.text\n  titleDOM.style.color = title.color\n}\n\nfunction renderContent (content) {\n  const contentDOM = document.getElementById(\x27content\x27)\n  contentDOM.innerHTML = content.text\n  contentDOM.style.color = content.color\n}\nrenderApp(appState)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction renderApp (appState) {\n  renderTitle(appState.\x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e)\n  renderContent(appState.\x3cspan class=\x22hljs-built_in\x22\x3econtent\x3c\/span\x3e)\n}\n\nfunction renderTitle (\x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e) {\n  const titleDOM = document.getElementById(\x27\x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e\x27)\n  titleDOM.innerHTML = \x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e.text\n  titleDOM.\x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e\n}\n\nfunction renderContent (\x3cspan class=\x22hljs-built_in\x22\x3econtent\x3c\/span\x3e) {\n  const contentDOM = document.getElementById(\x27\x3cspan class=\x22hljs-built_in\x22\x3econtent\x3c\/span\x3e\x27)\n  contentDOM.innerHTML = \x3cspan class=\x22hljs-built_in\x22\x3econtent\x3c\/span\x3e.text\n  contentDOM.\x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3econtent\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e\n}\nrenderApp(appState)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很简单，renderApp 会调用 rendeTitle 和 renderContent，而这两者会把 appState 里面的数据通过原始的 DOM 操作更新到页面上。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2AsZ?w=942\x26amp;h=366\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2AsZ?w=942\x26amp;h=366\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e这是一个很简单的 App，但是它存在一个重大的隐患，我们渲染数据的时候，使用的是一个共享状态 appState，每个人都可以修改它。\x3cstrong\x3e这里的矛盾就是：“模块（组件）之间需要共享数据”，和“数据可能被任意修改导致不可预料的结果”之间的矛盾。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e为了解决这个问题，我们可以学习 React.js 团队的做法，把事情搞复杂一些，提高数据修改的门槛：模块（组件）之间可以共享数据，也可以改数据。但是我们约定，这个数据并不能直接改，你只能执行某些我允许的某些修改，而且你修改的必须\x3cstrong\x3e大张旗鼓\x3c\/strong\x3e地告诉我。\x3c\/p\x3e\n\x3cp\x3e我们定义一个函数，叫 dispatch，它专门负责数据的修改：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function dispatch (action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      appState.title.text = action.text\n      break\n    case \x27UPDATE_TITLE_COLOR\x27:\n      appState.title.color = action.color\n      break\n    default:\n      break\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode\x3efunction dispatch (action) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (action.type) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e:\n      appState.title.\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e = action.\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e:\n      appState.title.\x3cspan class=\x22hljs-keyword\x22\x3ecolor\x3c\/span\x3e = action.\x3cspan class=\x22hljs-keyword\x22\x3ecolor\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有对数据的操作必须通过 dispatch 函数。它接受一个参数 action，这个 action 是一个普通的 JavaScript 对象，里面必须包含一个 type 字段来声明你到底想干什么。dispatch 在 swtich 里面会识别这个 type 字段，能够识别出来的操作才会执行对 appState 的修改。\x3c\/p\x3e\n\x3cp\x3e任何的模块如果想要修改 appState.title.text，必须大张旗鼓地调用 dispatch：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22dispatch({ type: \x27UPDATE_TITLE_TEXT\x27, text: \x27this is dispatch\x27 }) \/\/ 修改标题文本\ndispatch({ type: \x27UPDATE_TITLE_COLOR\x27, color: \x27blue\x27 }) \/\/ 修改标题颜色\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e({ type: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e, text: \x3cspan class=\x22hljs-string\x22\x3e\x27this is dispatch\x27\x3c\/span\x3e })\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题文本\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e({ type: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e, color: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e })\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题颜色\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们再也不用担心共享数据状态的修改的问题，我们只要把控了 dispatch，所有的对 appState 的修改就无所遁形，毕竟只有一根箭头指向 appState 了。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2ALF?w=804\x26amp;h=657\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2ALF?w=804\x26amp;h=657\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e构建共享状态仓库\x3c\/h3\x3e\n\x3cp\x3e上一节我们有了 appState 和 dispatch，现在我们把它们集中到一个地方，给这个地方起个名字叫做 store，然后构建一个函数 createStore，用来专门生产这种 state 和 dispatch 的集合，这样别的 App 也可以用这种模式了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createStore (state, stateChanger) {\n  const getState = () =\x3e state\n  const dispatch = (action) =\x3e stateChanger(state, action)\n  return { getState, dispatch }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction createStore (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger) {\n  const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  const dispatch = (action) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action)\n  return { getState, dispatch }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecreateStore 接受两个参数，一个是表示应用程序状态的 state；另外一个是 stateChanger，它来描述应用程序状态会根据 action 发生什么变化，其实就是相当于本节开头的 dispatch 代码里面的内容。\x3c\/p\x3e\n\x3cp\x3ecreateStore 会返回一个对象，这个对象包含两个方法 getState 和 dispatch。getState 用于获取 state 数据，其实就是简单地把 state 参数返回。\x3c\/p\x3e\n\x3cp\x3edispatch 用于修改数据，和以前一样会接受 action，然后它会把 state 和 action 一并传给 stateChanger，那么 stateChanger 就可以根据 action 来修改 state 了。\x3c\/p\x3e\n\x3cp\x3e现在有了 createStore，我们可以这么修改原来的代码，保留原来所有的渲染函数不变，修改数据生成的方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let appState = {\n  title: {\n    text: \x27this is title\x27,\n    color: \x27red\x27,\n  },\n  content: {\n    text: \x27this is content\x27,\n    color: \x27blue\x27\n  }\n}\n\nfunction stateChanger (state, action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      state.title.text = action.text\n      break\n    case \x27UPDATE_TITLE_COLOR\x27:\n      state.title.color = action.color\n      break\n    default:\n      break\n  }\n}\n\nconst store = createStore(appState, stateChanger)\n\nrenderApp(store.getState()) \/\/ 首次渲染页面\nstore.dispatch({ type: \x27UPDATE_TITLE_TEXT\x27, text: \x27this is dispatch\x27 }) \/\/ 修改标题文本\nstore.dispatch({ type: \x27UPDATE_TITLE_COLOR\x27, color: \x27blue\x27 }) \/\/ 修改标题颜色\nrenderApp(store.getState()) \/\/ 把新的数据渲染到页面上\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3elet appState = {\n  title: {\n    text: \x3cspan class=\x22hljs-string\x22\x3e\x27this is title\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-attribute\x22\x3econtent\x3c\/span\x3e: {\n    text: \x3cspan class=\x22hljs-string\x22\x3e\x27this is content\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e\n  }\n}\n\nfunction stateChanger (state, action) {\n  switch (action.type) {\n    case \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e:\n      state\x3cspan class=\x22hljs-selector-class\x22\x3e.title\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.text\x3c\/span\x3e = action\x3cspan class=\x22hljs-selector-class\x22\x3e.text\x3c\/span\x3e\n      break\n    case \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e:\n      state\x3cspan class=\x22hljs-selector-class\x22\x3e.title\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.color\x3c\/span\x3e = action\x3cspan class=\x22hljs-selector-class\x22\x3e.color\x3c\/span\x3e\n      break\n    default:\n      break\n  }\n}\n\nconst store = createStore(appState, stateChanger)\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3erenderApp\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(store.getState()\x3c\/span\x3e\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首次渲染页面\x3c\/span\x3e\nstore.dispatch({ type: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e, text: \x3cspan class=\x22hljs-string\x22\x3e\x27this is dispatch\x27\x3c\/span\x3e }) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题文本\x3c\/span\x3e\nstore.dispatch({ type: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e }) \/\/ 修改标题颜色\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3erenderApp\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(store.getState()\x3c\/span\x3e\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把新的数据渲染到页面上\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e针对每个不同的 App，我们可以给 createStore 传入初始的数据 appState，和一个描述数据变化的函数 stateChanger，然后生成一个 store。需要修改数据的时候通过 store.dispatch，需要获取数据的时候通过 store.getState。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e监控数据变化\x3c\/h3\x3e\n\x3cp\x3e上面代码有个问题，就是每次dispatch修改数据的时候，其实只是数据发生了变化，如果我们不手动调用renderApp，页面不会发生变化。如何数据变化的时候程序能够智能一点地自动重新渲染数据，而不是手动调用？\x3c\/p\x3e\n\x3cp\x3e往 dispatch里面加 renderApp 就好了，但是这样 createStore 就不够通用了。我们希望用一种通用的方式“监听”数据变化，然后重新渲染页面，这里要用到观察者模式。修改 createStore：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createStore (state, stateChanger) {\n  const listeners = []\n  const subscribe = (listener) =\x3e listeners.push(listener)\n  const getState = () =\x3e state\n  const dispatch = (action) =\x3e {\n    stateChanger(state, action)\n    listeners.forEach((listener) =\x3e listener())\n  }\n  return { getState, dispatch, subscribe }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction createStore (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger) {\n  const listeners = []\n  const subscribe = (listener) =\x26gt; listeners.push(listener)\n  const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  const dispatch = (action) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action)\n    listeners.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach((listener) =\x26gt; listener())\n  }\n  return { getState, dispatch, subscribe }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在 createStore 里面定义了一个数组 listeners，还有一个新的方法 subscribe，可以通过 store.subscribe(listener) 的方式给 subscribe 传入一个监听函数，这个函数会被 push 到数组当中。每当 dispatch 的时候，监听函数就会被调用，这样我们就可以在每当数据变化时候进行重新渲染：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const store = createStore(appState, stateChanger)\nstore.subscribe(() =\x3e renderApp(store.getState()))\n\nrenderApp(store.getState()) \/\/ 首次渲染页面\nstore.dispatch({ type: \x27UPDATE_TITLE_TEXT\x27, text: \x27this is dispatch\x27 }) \/\/ 修改标题文本\nstore.dispatch({ type: \x27UPDATE_TITLE_COLOR\x27, color: \x27blue\x27 }) \/\/ 修改标题颜色\n\/\/ ...后面不管如何 store.dispatch，都不需要重新调用 renderApp\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(appState, stateChanger)\nstore.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e renderApp(store.getState()))\n\nrenderApp(store.getState()) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首次渲染页面\x3c\/span\x3e\nstore.dispatch({ \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e, text: \x3cspan class=\x22hljs-string\x22\x3e\x27this is dispatch\x27\x3c\/span\x3e }) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题文本\x3c\/span\x3e\nstore.dispatch({ \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e, color: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e }) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题颜色\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...后面不管如何 store.dispatch，都不需要重新调用 renderApp\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e共享结构的对象来提高性能\x3c\/h3\x3e\n\x3cp\x3e其实我们之前的例子当中是有比较严重的\x3cstrong\x3e性能问题\x3c\/strong\x3e的。我们在每个渲染函数的开头打一些 Log 看看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function renderApp (appState) {\n  console.log(\x27render app...\x27)\n  renderTitle(appState.title)\n  renderContent(appState.content)\n}\n\nfunction renderTitle (title) {\n  console.log(\x27render title...\x27)\n  const titleDOM = document.getElementById(\x27title\x27)\n  titleDOM.innerHTML = title.text\n  titleDOM.style.color = title.color\n}\n\nfunction renderContent (content) {\n  console.log(\x27render content...\x27)\n  const contentDOM = document.getElementById(\x27content\x27)\n  contentDOM.innerHTML = content.text\n  contentDOM.style.color = content.color\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderApp\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eappState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render app...\x27\x3c\/span\x3e)\n  renderTitle(appState.title)\n  renderContent(appState.content)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderTitle\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etitle\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render title...\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e titleDOM = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27title\x27\x3c\/span\x3e)\n  titleDOM.innerHTML = title.text\n  titleDOM.style.color = title.color\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderContent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3econtent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render content...\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e contentDOM = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27content\x27\x3c\/span\x3e)\n  contentDOM.innerHTML = content.text\n  contentDOM.style.color = content.color\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e依旧执行一次初始化渲染，和两次更新，这里代码保持不变：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22renderApp(store.getState()) \/\/ 首次渲染页面\nstore.dispatch({ type: \x27UPDATE_TITLE_TEXT\x27, text: \x27this is dispatch\x27 }) \/\/ 修改标题文本\nstore.dispatch({ type: \x27UPDATE_TITLE_COLOR\x27, color: \x27blue\x27 }) \/\/ 修改标题颜色\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3erenderApp\x3c\/span\x3e(store.getState()) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首次渲染页面\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3estore\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.dispatch\x3c\/span\x3e({ \x3cspan class=\x22hljs-attribute\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_TEXT\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27this is dispatch\x27\x3c\/span\x3e }) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题文本\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3estore\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.dispatch\x3c\/span\x3e({ \x3cspan class=\x22hljs-attribute\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27UPDATE_TITLE_COLOR\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e }) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改标题颜色\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2ASQ?w=696\x26amp;h=282\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2ASQ?w=696\x26amp;h=282\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e可以看到问题就是，每当更新数据就重新渲染整个 App，但其实我们两次更新都没有动到 appState 里面的 content 字段的对象，而动的是 title 字段。其实并不需要重新 renderContent，它是一个多余的更新操作，现在我们需要优化它。\x3c\/p\x3e\n\x3cp\x3e这里提出的解决方案是，在每个渲染函数执行渲染操作之前先做个判断，判断传入的新数据和旧的数据是不是相同，相同的话就不渲染了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function renderApp (newAppState, oldAppState = {}) { \/\/ 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderApp\x3c\/span\x3e \x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eAppState\x3c\/span\x3e, oldAppState = {}) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eif (newAppState === oldAppState) return \/\/ 数据没有变化就不渲染了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  console.log(\x27render app...\x27)\n  renderTitle(newAppState.title, oldAppState.title)\n  renderContent(newAppState.content, oldAppState.content)\n}\n\nfunction renderTitle (newTitle, oldTitle = {}) {\n  if (newTitle === oldTitle) return \/\/ 数据没有变化就不渲染了\n  console.log(\x27render title...\x27)\n  const titleDOM = document.getElementById(\x27title\x27)\n  titleDOM.innerHTML = newTitle.text\n  titleDOM.style.color = newTitle.color\n}\n\nfunction renderContent (newContent, oldContent = {}) {\n  if (newContent === oldContent) return \/\/ 数据没有变化就不渲染了\n  console.log(\x27render content...\x27)\n  const contentDOM = document.getElementById(\x27content\x27)\n  contentDOM.innerHTML = newContent.text\n  contentDOM.style.color = newContent.color\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render app...\x27\x3c\/span\x3e)\n  renderTitle(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eAppState\x3c\/span\x3e.title, oldAppState.title)\n  renderContent(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eAppState\x3c\/span\x3e.content, oldAppState.content)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderTitle\x3c\/span\x3e \x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e, oldTitle = {}) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e === oldTitle) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据没有变化就不渲染了\x3c\/span\x3e\n  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render title...\x27\x3c\/span\x3e)\n  const titleDOM = document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27title\x27\x3c\/span\x3e)\n  titleDOM.innerHTML = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e.text\n  titleDOM.style.color = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e.color\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderContent\x3c\/span\x3e \x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e, oldContent = {}) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e === oldContent) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据没有变化就不渲染了\x3c\/span\x3e\n  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render content...\x27\x3c\/span\x3e)\n  const contentDOM = document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27content\x27\x3c\/span\x3e)\n  contentDOM.innerHTML = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e.text\n  contentDOM.style.color = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e.color\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们用一个 oldState 变量保存旧的应用状态，在需要重新渲染的时候把新旧数据传进入去：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const store = createStore(appState, stateChanger)\nlet oldState = store.getState() \/\/ 缓存旧的 state\nstore.subscribe(() =\x3e {\n  const newState = store.getState() \/\/ 数据可能变化，获取新的 state\n  renderApp(newState, oldState) \/\/ 把新旧的 state 传进去渲染\n  oldState = newState \/\/ 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n})\n...\nfunction stateChanger (state, action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      state.title.text = action.text\n      break\n    case \x27UPDATE_TITLE_COLOR\x27:\n      state.title.color = action.color\n      break\n    default:\n      break\n  }\n}\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3econst store = createStore(appState, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger)\nlet oldState = store.getState() \/\/ 缓存旧的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\nstore.subscribe(() =\x26gt; {\n  const newState = store.getState() \/\/ 数据可能变化，获取新的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  renderApp(newState, oldState) \/\/ 把新旧的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 传进去渲染\n  oldState = newState \/\/ 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n})\n...\nfunction \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title.text = action.text\n      break\n    case \x27UPDATE_TITLE_COLOR\x27:\n      \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title.color = action.color\n      break\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      break\n  }\n}\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实上面一顿操作根本达不到我们的预期的要求，你会发现还是渲染了content，这些引用指向的还是原来的对象，只是对象内的内容发生了改变。所以即使你在每个渲染函数开头加了那个判断又什么用？就像下面这段代码一样自欺欺人：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let people = {\n    name:\x27ddvdd\x27\n}\nconst oldPeople = people\npeople.name = \x27yjy\x27\noldPeople !== people \/\/false 其实两个引用指向的是同一个对象，我们却希望它们不同。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e people = {\n    name:\x3cspan class=\x22hljs-string\x22\x3e\x27ddvdd\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldPeople = people\npeople.name = \x3cspan class=\x22hljs-string\x22\x3e\x27yjy\x27\x3c\/span\x3e\noldPeople !== people \x3cspan class=\x22hljs-comment\x22\x3e\/\/false 其实两个引用指向的是同一个对象，我们却希望它们不同。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那怎么样才能达到我们要的要求呢？引入共享结构的对象概念：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = { a: 1, b: 2}\nconst obj2 = { ...obj } \/\/ =\x3e { a: 1, b: 2 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3econst obj = { \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}\nconst obj2 = { ..\x3cspan class=\x22hljs-selector-class\x22\x3e.obj\x3c\/span\x3e } \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { a: 1, b: 2 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3econst obj2 = { ...obj } 其实就是新建一个对象 obj2，然后把 obj 所有的属性都复制到 obj2 里面，相当于对象的浅复制。上面的 obj 里面的内容和 obj2 是完全一样的，但是却是两个不同的对象。除了浅复制对象，还可以覆盖、拓展对象属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = { a: 1, b: 2}\nconst obj2 = { ...obj, b: 3, c: 4} \/\/ =\x3e { a: 1, b: 3, c: 4 }，覆盖了 b，新增了 c\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3econst obj = { \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}\nconst obj2 = { ..\x3cspan class=\x22hljs-selector-class\x22\x3e.obj\x3c\/span\x3e, \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, c: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { a: 1, b: 3, c: 4 }，覆盖了 b，新增了 c\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以把这种特性应用在 appstate 的更新上，\x3cstrong\x3e我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍\x3c\/strong\x3e。我们修改 stateChanger，让它修改数据的时候，并不会直接修改原来的数据 state，而是产生上述的共享结构的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function stateChanger (state, action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      return { \/\/ 构建新的对象并且返回\n        ...state,\n        title: {\n          ...state.title,\n          text: action.text\n        }\n      }\n    case \x27UPDATE_TITLE_COLOR\x27:\n      return { \/\/ 构建新的对象并且返回\n        ...state,\n        title: {\n          ...state.title,\n          color: action.color\n        }\n      }\n    default:\n      return state \/\/ 没有修改，返回原来的对象\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) {\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      return { \/\/ 构建新的对象并且返回\n        ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,\n        title: {\n          ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title,\n          text: action.text\n        }\n      }\n    case \x27UPDATE_TITLE_COLOR\x27:\n      return { \/\/ 构建新的对象并且返回\n        ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,\n        title: {\n          ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title,\n          color: action.color\n        }\n      }\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      return \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e \/\/ 没有修改，返回原来的对象\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为 stateChanger 不会修改原来对象了，而是返回对象，所以我们需要修改一下 createStore。让它用每次 stateChanger(state, action) 的调用结果覆盖原来的 state：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createStore (state, stateChanger) {\n  const listeners = []\n  const subscribe = (listener) =\x3e listeners.push(listener)\n  const getState = () =\x3e state\n  const dispatch = (action) =\x3e {\n    state = stateChanger(state, action) \/\/ 覆盖原对象\n    listeners.forEach((listener) =\x3e listener())\n  }\n  return { getState, dispatch, subscribe }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction createStore (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger) {\n  const listeners = []\n  const subscribe = (listener) =\x26gt; listeners.push(listener)\n  const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  const dispatch = (action) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) \/\/ 覆盖原对象\n    listeners.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach((listener) =\x26gt; listener())\n  }\n  return { getState, dispatch, subscribe }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好了，我们在运行下看看结果是不是变成我们预期的那样了？\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2A3J?w=706\x26amp;h=244\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2A3J?w=706\x26amp;h=244\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e我就喜欢叫它 “reducer”\x3c\/h3\x3e\n\x3cp\x3e经过了这么多节的优化，我们有了一个很通用的 createStore，主要传入appState、stateChanger就能使用。那么appState和stateChanger是否可以合并到一起去呢？显然可以：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function stateChanger (state, action) {\n  if (!state) {\n    return {\n      title: {\n        text: \x27this is title\x27,\n        color: \x27red\x27,\n      },\n      content: {\n        text: \x27this is content\x27,\n        color: \x27blue\x27\n      }\n    }\n  }\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      return {\n        ...state,\n        title: {\n          ...state.title,\n          text: action.text\n        }\n      }\n    case \x27UPDATE_TITLE_COLOR\x27:\n      return {\n        ...state,\n        title: {\n          ...state.title,\n          color: action.color\n        }\n      }\n    default:\n      return state\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) {\n  if (!\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) {\n    return {\n      title: {\n        text: \x27this is title\x27,\n        color: \x27red\x27,\n      },\n      content: {\n        text: \x27this is content\x27,\n        color: \x27blue\x27\n      }\n    }\n  }\n  switch (action.type) {\n    case \x27UPDATE_TITLE_TEXT\x27:\n      return {\n        ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,\n        title: {\n          ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title,\n          text: action.text\n        }\n      }\n    case \x27UPDATE_TITLE_COLOR\x27:\n      return {\n        ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,\n        title: {\n          ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title,\n          color: action.color\n        }\n      }\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      return \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3estateChanger 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能。如果有传入 state 就生成更新数据，否则就是初始化数据。这样我们可以优化 createStore 成一个参数，因为 state 和 stateChanger 合并到一起了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createStore (stateChanger) {\n  let state = null\n  const listeners = []\n  const subscribe = (listener) =\x3e listeners.push(listener)\n  const getState = () =\x3e state\n  const dispatch = (action) =\x3e {\n    state = stateChanger(state, action)\n    listeners.forEach((listener) =\x3e listener())\n  }\n  dispatch({}) \/\/ 初始化 state\n  return { getState, dispatch, subscribe }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction createStore (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger) {\n  let \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = null\n  const listeners = []\n  const subscribe = (listener) =\x26gt; listeners.push(listener)\n  const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  const dispatch = (action) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eChanger(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action)\n    listeners.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach((listener) =\x26gt; listener())\n  }\n  dispatch({}) \/\/ 初始化 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  return { getState, dispatch, subscribe }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecreateStore 内部的 state 不再通过参数传入，而是一个局部变量 let state = null。createStore 的最后会手动调用一次 dispatch({})，dispatch 内部会调用 stateChanger，这时候的 state 是 null，所以这次的 dispatch 其实就是初始化数据了。createStore 内部第一次的 dispatch 导致 state 初始化完成，后续外部的 dispatch 就是修改数据的行为了。\x3c\/p\x3e\n\x3cp\x3e我们给 stateChanger 这个玩意起一个通用的名字：reducer，不要问为什么，它就是个名字而已，修改 createStore 的参数名字：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createStore (reducer) {\n  let state = null\n  const listeners = []\n  const subscribe = (listener) =\x3e listeners.push(listener)\n  const getState = () =\x3e state\n  const dispatch = (action) =\x3e {\n    state = reducer(state, action)\n    listeners.forEach((listener) =\x3e listener())\n  }\n  dispatch({}) \/\/ 初始化 state\n  return { getState, dispatch, subscribe }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction createStore (reducer) {\n  let \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = null\n  const listeners = []\n  const subscribe = (listener) =\x26gt; listeners.push(listener)\n  const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  const dispatch = (action) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = reducer(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action)\n    listeners.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach((listener) =\x26gt; listener())\n  }\n  dispatch({}) \/\/ 初始化 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  return { getState, dispatch, subscribe }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是一个最终形态的 createStore，它接受的参数叫 reducer，reducer 是一个函数，细心的朋友会发现，它其实是一个\x3cstrong\x3e纯函数\x3c\/strong\x3e（Pure Function）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eRedux在React当中的实践\x3c\/h2\x3e\n\x3cp\x3e看到这里你会发现自己莫名其妙的对redux已经了解的差不多了，甚至还自己动手实现了一个。文章进行到这里，偷偷告诉大家才过了一半。。。没上过厕所的去上下，回来我们继续：）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e搭建工程\x3c\/h3\x3e\n\x3cp\x3e前面我们在react.js的context中提出，我们可用把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。\x3c\/p\x3e\n\x3cp\x3e既然这样，为什么不把 context 和 store 结合起来？毕竟 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。我们还是以“主题色”这个例子来讲解，假设我们有这么一颗组件树：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2BaO?w=899\x26amp;h=679\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2BaO?w=899\x26amp;h=679\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3eHeader 和 Content 的组件的文本内容会随着主题色的变化而变化，而 Content 下的子组件 ThemeSwitch 有两个按钮，可以切换红色和蓝色两种主题，按钮的颜色也会随着主题色的变化而变化。\x3c\/p\x3e\n\x3cp\x3e用 create-react-app 新建一个工程react-redux-demo3：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22create-react-app react-redux-demo3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dsconfig\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecreate-react-app\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ereact-redux-\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3edemo3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装好后在 src\/ 目录下新增三个文件：Header.js、Content.js、ThemeSwitch.js。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/.\/src\/Header.js\nimport React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nclass Header extends Component {\n  render () {\n    return (\n      \x3ch1\x3ethis is header\x3c\/h1\x3e\n    )\n  }\n}\n\nexport default Header\n\n\/\/.\/src\/Content.js\nimport React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport ThemeSwitch from \x27.\/ThemeSwitch\x27\n\nclass Content extends Component {\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cp\x3ethis is content\x3c\/p\x3e\n        \x3cThemeSwitch \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nexport default Content\n\n\/\/.\/src\/ThemeSwitch.js\nimport React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nclass ThemeSwitch extends Component {\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cbutton\x3eRed\x3c\/button\x3e\n        \x3cbutton\x3eBlue\x3c\/button\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nexport default ThemeSwitch\n\n\/\/修改app.js\nimport React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport ReactDOM from \x27react-dom\x27\nimport Header from \x27.\/Header\x27\nimport Content from \x27.\/Content\x27\nimport \x27.\/index.css\x27\n\nclass App extends Component {\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cHeader \/\x3e\n        \x3cContent \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nexport default App\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/.\/src\/Header.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHeader\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3ethis is header\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Header\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/.\/src\/Content.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ThemeSwitch \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/ThemeSwitch\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eContent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3ethis is content\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eThemeSwitch\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Content\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/.\/src\/ThemeSwitch.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemeSwitch\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3eRed\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3eBlue\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e ThemeSwitch\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/修改app.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Header \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/Header\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Content \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/Content\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/index.css\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eContent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e App\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们就简单地把整个组件树搭建起来了，用 npm start 启动工程，然后可以看到页面上显示：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Be4?w=1012\x26amp;h=502\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Be4?w=1012\x26amp;h=502\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e结合 context 和 store\x3c\/h3\x3e\n\x3cp\x3e既然要把 store 和 context 结合起来，我们就先在 src目下创建store.js 和 reducer.js俩文件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/store.js\nfunction createStore (reducer) {\n    let state = null\n    const listeners = []\n    const subscribe = (listener) =\x3e listeners.push(listener)\n    const getState = () =\x3e state\n    const dispatch = (action) =\x3e {\n      state = reducer(state, action)\n      listeners.forEach((listener) =\x3e listener())\n    }\n    dispatch({}) \/\/ 初始化 state\n    return { getState, dispatch, subscribe }\n}\n\nexport default createStore\n\n\/\/reducer.js\nconst themeReducer = (state, action) =\x3e {\n    if (!state) return {\n      themeColor: \x27red\x27\n    }\n    switch (action.type) {\n      case \x27CHANGE_COLOR\x27:\n        return { ...state, themeColor: action.themeColor }\n      default:\n        return state\n    }\n}\nexport default themeReducer\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/store.js\nfunction createStore (reducer) {\n    let \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = null\n    const listeners = []\n    const subscribe = (listener) =\x26gt; listeners.push(listener)\n    const getState = () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    const dispatch = (action) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = reducer(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action)\n      listeners.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach((listener) =\x26gt; listener())\n    }\n    dispatch({}) \/\/ 初始化 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    return { getState, dispatch, subscribe }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e createStore\n\n\/\/reducer.js\nconst themeReducer = (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) =\x26gt; {\n    if (!\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) return {\n      themeColor: \x27red\x27\n    }\n    switch (action.type) {\n      case \x27CHANGE_COLOR\x27:\n        return { ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, themeColor: action.themeColor }\n      \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n        return \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    }\n}\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e themeReducer\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ethemeReducer 定义了一个表示主题色的状态 themeColor，并且规定了一种操作 CHNAGE_COLOR，只能通过这种操作修改颜色。现在我们把 store 放到 App 的 context 里面，这样每个子组件都可以获取到 store 了，修改 src\/App.js 里面的 App：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport ReactDOM from \x27react-dom\x27\nimport Header from \x27.\/Header\x27\nimport Content from \x27.\/Content\x27\n\nimport createStore from \x27.\/store\x27\nimport themeReducer from \x27.\/reducer\x27\n\nconst store = createStore(themeReducer)\n\nclass App extends Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n\n  getChildContext () {\n    return { store }\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cHeader \/\x3e\n        \x3cContent \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\nexport default App\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Header \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/Header\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Content \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/Content\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e createStore \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e themeReducer \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/reducer\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(themeReducer)\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e childContextTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: PropTypes.object\n  }\n\n  getChildContext () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { store }\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eContent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e App\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后修改 src\/Header.js、Content.js、ThemeSwitch.js，让它从 App 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/header.js\nclass Header extends Component {\n  static contextTypes = {\n    store: PropTypes.object\n  }\n\n  constructor () {\n    super()\n    this.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    this._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = this.context\n    const state = store.getState()\n    this.setState({ themeColor: state.themeColor })\n  }\n\n  render () {\n    return (\n      \x3ch1 style=\x22{{\x22 color: this.state.themeColor \x22}}\x22\x3ethis is header\x3c\/h1\x3e\n    )\n  }\n}\n\n\/\/content.js\nclass Content extends Component {\n  static contextTypes = {\n    store: PropTypes.object\n  }\n\n  constructor () {\n    super()\n    this.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    this._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = this.context\n    const state = store.getState()\n    this.setState({ themeColor: state.themeColor })\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cp style=\x22{{\x22 color: this.state.themeColor \x22}}\x22\x3ethis is content\x3c\/p\x3e\n        \x3cThemeSwitch \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n \n\/\/themeswitch.js\nclass ThemeSwitch extends Component {\n  static contextTypes = {\n    store: PropTypes.object\n  }\n\n  constructor () {\n    super()\n    this.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    this._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = this.context\n    const state = store.getState()\n    this.setState({ themeColor: state.themeColor })\n  }\n\n  \/\/ dispatch action 去改变颜色\n  handleSwitchColor (color) {\n    const { store } = this.context\n    store.dispatch({\n      type: \x27CHANGE_COLOR\x27,\n      themeColor: color\n    })\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cbutton\n          style=\x22{{\x22 color: this.state.themeColor \x22}}\x22\n          onClick={this.handleSwitchColor.bind(this, \x27red\x27)}\x3eRed\x3c\/button\x3e\n        \x3cbutton\n          style=\x22{{\x22 color: this.state.themeColor \x22}}\x22\n          onClick={this.handleSwitchColor.bind(this, \x27blue\x27)}\x3eBlue\x3c\/button\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/header.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHeader\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static contextTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  }\n\n  constructor () {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    const state = store.getState()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ themeColor: state.themeColor })\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;h1 style=\x22{{\x22 color: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.themeColor \x22}}\x22\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e is header\x26lt;\/h1\x26gt;\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/content.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eContent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static contextTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  }\n\n  constructor () {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    const state = store.getState()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ themeColor: state.themeColor })\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;p style=\x22{{\x22 color: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.themeColor \x22}}\x22\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e is content\x26lt;\/p\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eThemeSwitch\x3c\/span\x3e \/\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/themeswitch.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemeSwitch\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static contextTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  }\n\n  constructor () {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { themeColor: \x27\x27 }\n  }\n\n  componentWillMount () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateThemeColor()\n  }\n\n  _updateThemeColor () {\n    const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    const state = store.getState()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ themeColor: state.themeColor })\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dispatch action 去改变颜色\x3c\/span\x3e\n  handleSwitchColor (color) {\n    const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    store.dispatch({\n      \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e: \x3cspan class=\x22hljs-symbol\x22\x3e\x27CHANGE_COLO\x3c\/span\x3eR\x27,\n      themeColor: color\n    })\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;button\n          style=\x22{{\x22 color: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.themeColor \x22}}\x22\n          onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSwitchColor.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27re\x3c\/span\x3ed\x27)}\x26gt;\x3cspan class=\x22hljs-type\x22\x3eRed\x3c\/span\x3e\x26lt;\/button\x26gt;\n        \x26lt;button\n          style=\x22{{\x22 color: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.themeColor \x22}}\x22\n          onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSwitchColor.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27blu\x3c\/span\x3ee\x27)}\x26gt;\x3cspan class=\x22hljs-type\x22\x3eBlue\x3c\/span\x3e\x26lt;\/button\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在 constructor 里面初始化了组件自己的 themeColor 状态。然后在生命周期中 componentWillMount 调用 _updateThemeColor，_updateThemeColor 会从 context 里面把 store 取出来，然后通过 store.getState() 获取状态对象，并且用里面的 themeColor 字段设置组件的 state.themeColor。\x3c\/p\x3e\n\x3cp\x3e然后在 render 函数里面获取了 state.themeColor 来设置标题的样式，页面上就会显示：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Bj4?w=1218\x26amp;h=538\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Bj4?w=1218\x26amp;h=538\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们给两个按钮都加上了 onClick 事件监听，并绑定到了 handleSwitchColor 方法上，两个按钮分别给这个方法传入不同的颜色 red 和 blue，handleSwitchColor 会根据传入的颜色 store.dispatch 一个 action 去修改颜色。\x3c\/p\x3e\n\x3cp\x3e当然你现在点击按钮还是没有反应的。因为点击按钮的时候，只是更新 store 里面的 state，而并没有在 store.state 更新以后去重新渲染数据，我们其实就是忘了 store.subscribe 了。\x3c\/p\x3e\n\x3cp\x3e给 Header.js、Content.js、ThemeSwitch.js 的 componentWillMount 生命周期都加上监听数据变化重新渲染的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\n  componentWillMount () {\n    const { store } = this.context\n    this._updateThemeColor()\n    store.subscribe(() =\x3e this._updateThemeColor())\n  }\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e...\n  componentWillMount () {\n    const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateThemeColor()\n    store.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateThemeColor())\n  }\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过 store.subscribe，在数据变化的时候重新调用 _updateThemeColor，而 _updateThemeColor 会去 store 里面取最新的 themeColor 然后通过 setState 重新渲染组件，这时候组件就更新了。现在可以自由切换主题色了：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Blg?w=744\x26amp;h=462\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Blg?w=744\x26amp;h=462\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们顺利地把 store 和 context 结合起来，这是 Redux 和 React.js 的第一次胜利会师，当然还有很多需要优化的地方。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3econnect 和 mapStateToProps\x3c\/h3\x3e\n\x3cp\x3e我们来观察一下刚写下的这几个组件，可以轻易地发现它们有两个重大的问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cstrong\x3e有大量重复的逻辑：\x3c\/strong\x3e它们基本的逻辑都是，取出 context，取出里面的 store，然后用里面的状态设置自己的状态，这些代码逻辑其实都是相同的。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e对 context 依赖性过强：\x3c\/strong\x3e这些组件都要依赖 context 来取数据，使得这个组件复用性基本为零。想一下，如果别人需要用到里面的 ThemeSwitch 组件，但是他们的组件树并没有 context 也没有 store，他们没法用这个组件了。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e对于第一个问题我们可以用\x3cstrong\x3e高阶组件（高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。）\x3c\/strong\x3e来解决，可以把一些可复用的逻辑放在高阶组件当中，高阶组件包装的新组件和原来组件之间通过 props 传递信息，减少代码的重复程度。\x3c\/p\x3e\n\x3cp\x3e对于第二个问题，我们得弄清楚一件事情，到底什么样的组件才叫复用性强的组件。如果一个组件对外界的依赖过于强，那么这个组件的移植性会很差，就像这些严重依赖 context 的组件一样。\x3c\/p\x3e\n\x3cp\x3e如果一个组件的渲染只依赖于外界传进去的 props 和自己的 state，而并不依赖于其他的外界的任何数据，也就是说像纯函数一样，给它什么，它就吐出（渲染）什么出来。这种组件的复用性是最强的，别人使用的时候根本不用担心任何事情，只要看看 PropTypes 它能接受什么参数，然后把参数传进去控制它就行了。\x3c\/p\x3e\n\x3cp\x3e我们把这种组件叫做 Pure Component，因为它就像纯函数一样，可预测性非常强，对参数（props）以外的数据零依赖，也不产生副作用。这种组件也叫 Dumb Component，因为它们呆呆的，让它干啥就干啥。写组件的时候尽量写 Dumb Component 会提高我们的组件的可复用性。\x3c\/p\x3e\n\x3cp\x3e到这里思路慢慢地变得清晰了，我们需要高阶组件帮助我们从 context 取数据，我们也需要写 Dumb 组件帮助我们提高组件的复用性。所以我们尽量多地写 Dumb 组件，然后用高阶组件把它们包装一层，高阶组件和 context 打交道，把里面数据取出来通过 props 传给 Dumb 组件。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Boo?w=889\x26amp;h=499\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Boo?w=889\x26amp;h=499\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们把这个高阶组件起名字叫 connect，因为它把 Dumb 组件和 context 连接（connect）起来了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nexport connect = (WrappedComponent) =\x3e {\n  class Connect extends Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    \/\/ TODO: 如何从 store 取数据？\n\n    render () {\n      return \x3cWrappedComponent \/\x3e\n    }\n  }\n\n  return Connect\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27prop\x3c\/span\x3e-types\x27\n\nexport connect = (\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt; {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    static contextTypes = {\n      store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e 如何从 store 取数据？\x3c\/span\x3e\n\n    render () {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e \/\x26gt;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eConnect\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3econnect 函数接受一个组件 WrappedComponent 作为参数，把这个组件包含在一个新的组件 Connect 里面，Connect 会去 context 里面取出 store。现在要把 store 里面的数据取出来通过 props 传给 WrappedComponent。\x3c\/p\x3e\n\x3cp\x3e但是每个传进去的组件需要 store 里面的数据都不一样的，所以除了给高阶组件传入 Dumb 组件以外，还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据。为了解决这个问题，我们可以给高阶组件传入类似下面这样的函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const mapStateToProps = (state) =\x3e {\n  return {\n    themeColor: state.themeColor,\n    themeName: state.themeName,\n    fullName: `${state.firstName} ${state.lastName}`\n    ...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3econst mapStateToProps = (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) =\x26gt; {\n  return {\n    themeColor: \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.themeColor,\n    themeName: \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.themeName,\n    fullName: `${\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.firstName} ${\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.lastName}`\n    ...\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数会接受 store.getState() 的结果作为参数，然后返回一个对象，这个对象是根据 state 生成的。mapStateTopProps 相当于告知了 Connect 应该如何去 store 里面取数据，然后可以把这个函数的返回结果传给被包装的组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\n\nexport const connect = (mapStateToProps) =\x3e (WrappedComponent) =\x3e {\n  class Connect extends Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    render () {\n      const { store } = this.context\n      let stateProps = mapStateToProps(store.getState())\n      \/\/ {...stateProps} 意思是把从store里面所需要的属性拿出来全部通过 `props` 方式传递进去\n      return \x3cWrappedComponent {...stateProps} \/\x3e\n    }\n  }\n\n  return Connect\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27prop\x3c\/span\x3e-types\x27\n\nexport const connect = (mapStateToProps) =\x26gt; (\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt; {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    static contextTypes = {\n      store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n    }\n\n    render () {\n      const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n      let stateProps = mapStateToProps(store.getState())\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ {...stateProps} 意思是把从store里面所需要的属性拿出来全部通过 `props` 方式传递进去\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e {...stateProps} \/\x26gt;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eConnect\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好了既然有了connect这个高阶组件，我们来看看之前的代码怎么改造？我们把上面 connect 的函数代码单独分离到一个模块当中，在 src\/ 目录下新建一个 react-redux.js，把上面的 connect 函数的代码复制进去，然后就可以在 src\/Header.js 里面使用了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport { connect } from \x27.\/react-redux\x27\n\nclass Header extends Component {\n  static propTypes = {\n    themeColor: PropTypes.string\n  }\n\n  render () {\n    return (\n      \x3ch1 style=\x22{{\x22 color: this.props.themeColor \x22}}\x22\x3ethis is header\x3c\/h1\x3e\n    )\n  }\n}\n\nconst mapStateToProps = (state) =\x3e {\n  return {\n    themeColor: state.themeColor\n  }\n}\nHeader = connect(mapStateToProps)(Header)\n\nexport default Header\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { connect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/react-redux\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHeader\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e propTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e: PropTypes.string\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor:\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ethis.props.themeColor\x3c\/span\x3e \x22}}\x22\x26gt;\x3c\/span\x3ethis is header\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e: state.themeColor\n  }\n}\nHeader = connect(mapStateToProps)(Header)\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Header\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到 Header 删掉了大部分关于 context 的代码，它除了 props 什么也不依赖，它是一个 Pure Component，然后通过 connect 取得数据。我们不需要知道 connect 是怎么和 context 打交道的，只要传一个 mapStateToProps 告诉它应该从store里面取哪些数据就可以了。同样的方式修改 src\/Content.js，这里不贴了，留给大家自己去完成。\x3c\/p\x3e\n\x3cp\x3e现在的 connect 还没有监听数据变化然后重新渲染，所以现在点击按钮只有按钮会变颜色。我们给 connect 的高阶组件增加监听数据变化重新渲染的逻辑，稍微重构一下 connect：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const connect = (mapStateToProps) =\x3e (WrappedComponent) =\x3e {\n  class Connect extends Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor () {\n      super()\n      this.state = { allProps: {} }\n    }\n\n    componentWillMount () {\n      const { store } = this.context\n      this._updateProps()\n      store.subscribe(() =\x3e this._updateProps())\n    }\n\n    _updateProps () {\n      const { store } = this.context\n      let stateProps = mapStateToProps(store.getState(), this.props) \/\/ 额外传入 props，让获取数据更加灵活方便\n      this.setState({\n        allProps: { \/\/ 整合普通的 props 和从 state 生成的 props\n          ...stateProps,\n          ...this.props\n        }\n      })\n    }\n\n    render () {\n      return \x3cWrappedComponent {...this.state.allProps} \/\x3e\n    }\n  }\n\n  return Connect\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport const connect = (mapStateToProps) =\x26gt; (WrappedComponent) =\x26gt; {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    static contextTypes = {\n      store: PropTypes.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n      \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { allProps: {} }\n    }\n\n    componentWillMount () {\n      const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateProps()\n      store.subscribe(() =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateProps())\n    }\n\n    _updateProps () {\n      const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n      let stateProps = mapStateToProps(store.getState(), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 额外传入 props，让获取数据更加灵活方便\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        allProps: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 整合普通的 props 和从 state 生成的 props\x3c\/span\x3e\n          ...stateProps,\n          ...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n        }\n      })\n    }\n\n    render () {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;WrappedComponent {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.allProps} \/\x26gt;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Connect\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在 Connect 组件的 constructor 里面初始化了 state.allProps，它是一个对象，用来保存需要传给被包装组件的所有的参数。生命周期 componentWillMount 会调用调用 _updateProps 进行初始化，然后通过 store.subscribe 监听数据变化重新调用 _updateProps。\x3c\/p\x3e\n\x3cp\x3e为了让 connect 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 Connect 的 props 原封不动地传给 WrappedComponent。所以在 _updateProps 里面会把 stateProps 和 this.props 合并到 this.state.allProps 里面，再通过 render 方法把所有参数都传给 WrappedComponent。\x3c\/p\x3e\n\x3cp\x3emapStateToProps 也发生点变化，它现在可以接受两个参数了，我们会把传给 Connect 组件的 props 参数也传给它，那么它生成的对象配置性就更强了，我们可以根据 store 里面的 state 和外界传入的 props 生成我们想传给被包装组件的参数。\x3c\/p\x3e\n\x3cp\x3e现在已经很不错了，Header.js 和 Content.js 的代码都大大减少了，并且这两个组件 connect 之前都是 Dumb 组件。接下来会继续重构 ThemeSwitch。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3emapDispatchToProps\x3c\/h3\x3e\n\x3cp\x3e在重构 ThemeSwitch 的时候我们发现，ThemeSwitch 除了需要 store 里面的数据以外，还需要 store 来 dispatch：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\n  \/\/ dispatch action 去改变颜色\n  handleSwitchColor (color) {\n    const { store } = this.context\n    store.dispatch({\n      type: \x27CHANGE_COLOR\x27,\n      themeColor: color\n    })\n  }\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e...\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dispatch action 去改变颜色\x3c\/span\x3e\n  handleSwitchColor (\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n    store.dispatch({\n      type: \x3cspan class=\x22hljs-string\x22\x3e\x27CHANGE_COLOR\x27\x3c\/span\x3e,\n      themeColor: \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e\n    })\n  }\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e目前版本的 connect 是达不到这个效果的，我们需要改进它。\x3c\/p\x3e\n\x3cp\x3e想一下，既然可以通过给 connect 函数传入 mapStateToProps 来告诉它如何获取、整合状态，我们也可以想到，可以给它传入另外一个参数来告诉它我们的组件需要如何触发 dispatch。我们把这个参数叫 mapDispatchToProps：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const mapDispatchToProps = (dispatch) =\x3e {\n  return {\n    onSwitchColor: (color) =\x3e {\n      dispatch({ type: \x27CHANGE_COLOR\x27, themeColor: color })\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst mapDispatchToProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(dispatch)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    onSwitchColor: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(color)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      dispatch({ type: \x3cspan class=\x22hljs-string\x22\x3e\x27CHANGE_COLOR\x27\x3c\/span\x3e, themeColor: color })\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。\x3c\/p\x3e\n\x3cp\x3e调整 connect 让它能接受这样的 mapDispatchToProps：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const connect = (mapStateToProps, mapDispatchToProps) =\x3e (WrappedComponent) =\x3e {\n  class Connect extends Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor () {\n      super()\n      this.state = {\n        allProps: {}\n      }\n    }\n\n    componentWillMount () {\n      const { store } = this.context\n      this._updateProps()\n      store.subscribe(() =\x3e this._updateProps())\n    }\n\n    _updateProps () {\n      const { store } = this.context\n      let stateProps = mapStateToProps\n        ? mapStateToProps(store.getState(), this.props)\n        : {} \/\/ 防止 mapStateToProps 没有传入\n      let dispatchProps = mapDispatchToProps\n        ? mapDispatchToProps(store.dispatch, this.props)\n        : {} \/\/ 防止 mapDispatchToProps 没有传入\n      this.setState({\n        allProps: {\n          ...stateProps,\n          ...dispatchProps,\n          ...this.props\n        }\n      })\n    }\n\n    render () {\n      return \x3cWrappedComponent {...this.state.allProps} \/\x3e\n    }\n  }\n  return Connect\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport const connect = (mapStateToProps, mapDispatchToProps) =\x26gt; (WrappedComponent) =\x26gt; {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    static contextTypes = {\n      store: PropTypes.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n      \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n        allProps: {}\n      }\n    }\n\n    componentWillMount () {\n      const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateProps()\n      store.subscribe(() =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateProps())\n    }\n\n    _updateProps () {\n      const { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context\n      let stateProps = mapStateToProps\n        ? mapStateToProps(store.getState(), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props)\n        : {} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 防止 mapStateToProps 没有传入\x3c\/span\x3e\n      let dispatchProps = mapDispatchToProps\n        ? mapDispatchToProps(store.dispatch, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props)\n        : {} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 防止 mapDispatchToProps 没有传入\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        allProps: {\n          ...stateProps,\n          ...dispatchProps,\n          ...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n        }\n      })\n    }\n\n    render () {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;WrappedComponent {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.allProps} \/\x26gt;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Connect\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 _updateProps 内部，我们把store.dispatch 作为参数传给 mapDispatchToProps ，它会返回一个对象 dispatchProps。接着把 stateProps、dispatchProps、this.props 三者合并到 this.state.allProps 里面去，这三者的内容都会在 render 函数内全部传给被包装的组件。\x3c\/p\x3e\n\x3cp\x3e这时候我们就可以重构 ThemeSwitch，让它摆脱 store.dispatch：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport { connect } from \x27.\/react-redux\x27\n\nclass ThemeSwitch extends Component {\n  static propTypes = {\n    themeColor: PropTypes.string,\n    onSwitchColor: PropTypes.func\n  }\n\n  handleSwitchColor (color) {\n    if (this.props.onSwitchColor) {\n      this.props.onSwitchColor(color)\n    }\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cbutton\n          style=\x22{{\x22 color: this.props.themeColor \x22}}\x22\n          onClick={this.handleSwitchColor.bind(this, \x27red\x27)}\x3eRed\x3c\/button\x3e\n        \x3cbutton\n          style=\x22{{\x22 color: this.props.themeColor \x22}}\x22\n          onClick={this.handleSwitchColor.bind(this, \x27blue\x27)}\x3eBlue\x3c\/button\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nconst mapStateToProps = (state) =\x3e {\n  return {\n    themeColor: state.themeColor\n  }\n}\nconst mapDispatchToProps = (dispatch) =\x3e {\n  return {\n    onSwitchColor: (color) =\x3e {\n      dispatch({ type: \x27CHANGE_COLOR\x27, themeColor: color })\n    }\n  }\n}\nThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)\n\nexport default ThemeSwitch\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { connect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/react-redux\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemeSwitch\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e propTypes = {\n    \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e: PropTypes.string,\n    \x3cspan class=\x22hljs-attr\x22\x3eonSwitchColor\x3c\/span\x3e: PropTypes.func\n  }\n\n  handleSwitchColor (color) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onSwitchColor) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onSwitchColor(color)\n    }\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor:\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ethis.props.themeColor\x3c\/span\x3e \x22}}\x22\n          \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleSwitchColor.bind(this,\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3ered\x3c\/span\x3e\x27)}\x26gt;\x3c\/span\x3eRed\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor:\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ethis.props.themeColor\x3c\/span\x3e \x22}}\x22\n          \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleSwitchColor.bind(this,\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3eblue\x3c\/span\x3e\x27)}\x26gt;\x3c\/span\x3eBlue\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e: state.themeColor\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapDispatchToProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edispatch\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3eonSwitchColor\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ecolor\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      dispatch({ \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27CHANGE_COLOR\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ethemeColor\x3c\/span\x3e: color })\n    }\n  }\n}\nThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e ThemeSwitch\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时候这三个组件的重构都已经完成了，代码大大减少、不依赖 context，并且功能和原来一样。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eProvider\x3c\/h3\x3e\n\x3cp\x3e我们要把 context 相关的代码从所有业务组件中清除出去，现在的代码里面还有一个地方是被污染的。那就是 src\/App.js 里面的 App：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\nclass Index extends Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n\n  getChildContext () {\n    return { store }\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e\n        \x3cHeader \/\x3e\n        \x3cContent \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e...\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eIndex\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static childContextTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  }\n\n  getChildContext () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { store }\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e \/\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实它要用 context 就是因为要把 store 存放到里面，好让子组件 connect 的时候能够取到 store。我们可以额外构建一个组件来做这种脏活，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 context 了。\x3c\/p\x3e\n\x3cp\x3e我们把这个组件叫 Provider，因为它提供（provide）了 store，把它放在react-redux.js：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class Provider extends Component {\n  static propTypes = {\n    store: PropTypes.object,\n    children: PropTypes.any\n  }\n\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n\n  getChildContext () {\n    return {\n      store: this.props.store\n    }\n  }\n\n  render () {\n    return (\n      \x3cdiv\x3e{this.props.children}\x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static propTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e,\n    children: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.any\n  }\n\n  static childContextTypes = {\n    store: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e\n  }\n\n  getChildContext () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      store: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.store\n    }\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children}\x26lt;\/div\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eProvider 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来。它还会把外界传给它的 props.store 放到 context，这样子组件 connect 的时候都可以获取到。\x3c\/p\x3e\n\x3cp\x3e可以用它来重构我们的 src\/index.js：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\nimport \x27.\/index.css\x27;\nimport App from \x27.\/App\x27;\nimport createStore from \x27.\/store\x27\nimport { Provider } from \x27.\/react-redux\x27\nimport themeReducer from \x27.\/reducer\x27\n\nconst store = createStore(themeReducer)\n\nReactDOM.render(\n    \x3cProvider store={store}\x3e\n        \x3cApp \/\x3e\n    \x3c\/Provider\x3e, document.getElementById(\x27root\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/index.css\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e createStore \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Provider } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/react-redux\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e themeReducer \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/reducer\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(themeReducer)\n\nReactDOM.render(\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{store}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eApp\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eProvider\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们就把所有关于 context 的代码从组件里面删除了。做完这些你其实已经自己动手完成了一个react-redux的开发，不信？怎么可能那么简单？至今为止都没用react-redux。。。那么现在来看一件神奇的事情，把 src\/ 目录下 Header.js、ThemeSwitch.js、Content.js 的模块中的.\/react-redux 导入的 connect 改成从第三方 react-redux 模块中导入。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { connect } from \x27.\/react-redux\x27 \n\/\/改成\nimport { connect } from \x27react-redux\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econnect\x3c\/span\x3e } from \x3cspan class=\x22hljs-string\x22\x3e\x27.\/react-redux\x27\x3c\/span\x3e \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/改成\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econnect\x3c\/span\x3e } from \x3cspan class=\x22hljs-string\x22\x3e\x27react-redux\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e删除自己写的 createStore，改成使用第三方模块 redux 的 createStore；Provider 本来从本地的 .\/react-redux 引入，改成从第三方 react-redux 模块中引入。其余代码保持不变。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { createStore } from \x27redux\x27\n\nimport { Provider } from \x27react-redux\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createStore } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Provider } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-redux\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着删除 src\/react-redux.js，它的已经用处不大了。最后启动工程 npm start：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2BY3?w=1060\x26amp;h=454\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2BY3?w=1060\x26amp;h=454\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们看到项目神奇的运行了，好了文章到了这里也算结束了，第一遍消化不了的建议多看几篇！\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader15\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/ddvdd008\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文章所有例子的github地址\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/huziketang.com\/books\/react\/lesson1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e参考链接-胡子大大\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/09\/redux_tutorial_part_three_react-redux.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e参考链接-阮一峰\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>跟着例子一步步学习redux+react-redux</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012976767">https://segmentfault.com/a/1190000012976767</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3bvk488gkec/" target="_blank">https://alili.tech/archive/3bvk488gkec/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>