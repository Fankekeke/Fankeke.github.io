<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript的异常处理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript的异常处理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3jtxuq8a7kk/",
				"appid": "1613049289050283", 
				"title": "JavaScript的异常处理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mrkjrjf04f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/y0rzgivpkls/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&text=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&text=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&title=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&is_video=false&description=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&title=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&title=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&title=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3jtxuq8a7kk%2f&title=JavaScript%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript的异常处理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-29" itemprop="datePublished">2018-12-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e当 \x3cstrong\x3eJavaScript\x3c\/strong\x3e 引擎执行 \x3cstrong\x3eJavaScript\x3c\/strong\x3e 代码时，有可能会发生各种异常，例如是语法异常，语言中缺少的功能，由于来自服务器或用户的异常输出而导致的异常。\x3c\/p\x3e\n\x3cp\x3e而 \x3cstrong\x3eJavascript\x3c\/strong\x3e 引擎是单线程的，因此一旦遇到异常，\x3cstrong\x3eJavascript\x3c\/strong\x3e 引擎通常会停止执行，阻塞后续代码并抛出一个异常信息，因此对于可预见的异常，我们应该捕捉并正确展示给用户或开发者。\x3c\/p\x3e\n\x3ch2\x3eError对象\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3ethrow\x3c\/strong\x3e 和 \x3cstrong\x3ePromise.reject()\x3c\/strong\x3e 可以抛出字符串类型的异常，而且可以抛出一个 \x3cstrong\x3eError\x3c\/strong\x3e 对象类型的异常。\x3c\/p\x3e\n\x3cp\x3e一个 \x3cstrong\x3eError\x3c\/strong\x3e 对象类型的异常不仅包含一个异常信息，同时也包含一个追溯栈这样你就可以很容易通过追溯栈找到代码出错的行数了。\x3c\/p\x3e\n\x3cp\x3e所以推荐抛出 \x3cstrong\x3eError\x3c\/strong\x3e 对象类型的异常，而不是字符串类型的异常。\x3c\/p\x3e\n\x3cp\x3e创建自己的异常构造函数\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efunction MyError(message) {\n    var instance = new Error(message);\n    instance.name = \x27MyError\x27;\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n}\n\nMyError.prototype = Object.create(Error.prototype, {\n    constructor: {\n        value: MyError,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    }\n});\n\nif (Object.setPrototypeOf) {\n    Object.setPrototypeOf(MyError, Error);\n} else {\n    MyError.__proto__ = Error;\n}\n\nexport default MyError;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在代码中抛出自定义的异常类型并捕捉\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3etry {\n    throw new MyError(\x22some message\x22);\n} catch(e){\n    console.log(e.name \x2b \x22:\x22 \x2b e.message);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3eThrow\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3ethrow expression; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3ethrow\x3c\/strong\x3e 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（\x3cstrong\x3ethrow\x3c\/strong\x3e 之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个 \x3cstrong\x3ecatch\x3c\/strong\x3e 块。如果调用者函数中没有 \x3cstrong\x3ecatch\x3c\/strong\x3e 块，程序将会终止。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3etry {\n    console.log(\x27before throw error\x27);\n    throw new Error(\x27throw error\x27);\n    console.log(\x27after throw error\x27);\n} catch (err) {\n    console.log(err.message);\n}\n\n\/\/ before throw error\n\/\/ throw error\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3eTry \/ Catch\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3etry {\n   try_statements\n}\n[catch (exception) {\n   catch_statements\n}]\n[finally {\n   finally_statements\n}]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3etry\/catch\x3c\/strong\x3e 主要用于捕捉异常。\x3cstrong\x3etry\/catch\x3c\/strong\x3e 语句包含了一个 \x3cstrong\x3etry\x3c\/strong\x3e 块, 和至少有一个 \x3cstrong\x3ecatch\x3c\/strong\x3e 块或者一个 \x3cstrong\x3efinally\x3c\/strong\x3e 块，下面是三种形式的 \x3cstrong\x3etry\x3c\/strong\x3e 声明:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3etry...catch\x3c\/li\x3e\n\x3cli\x3etry...finally\x3c\/li\x3e\n\x3cli\x3etry...catch...finally\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3etry\x3c\/strong\x3e 块中放入可能会产生异常的语句或函数\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecatch\x3c\/strong\x3e 块中包含要执行的语句，当 \x3cstrong\x3etry\x3c\/strong\x3e 块中抛出异常时，\x3cstrong\x3ecatch\x3c\/strong\x3e 块会捕捉到这个异常信息，并执行 \x3cstrong\x3ecatch\x3c\/strong\x3e 块中的代码，如果在 \x3cstrong\x3etry\x3c\/strong\x3e 块中没有异常抛出，这 \x3cstrong\x3ecatch\x3c\/strong\x3e 块将会跳过。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3efinally\x3c\/strong\x3e 块在 \x3cstrong\x3etry\x3c\/strong\x3e 块和 \x3cstrong\x3ecatch\x3c\/strong\x3e 块之后执行。无论是否有异常抛出或着是否被捕获它总是执行。当在 \x3cstrong\x3efinally\x3c\/strong\x3e 块中抛出异常信息时会覆盖掉 \x3cstrong\x3etry\x3c\/strong\x3e 块中的异常信息。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3etry {\n    try {\n        throw new Error(\x27can not find it1\x27);\n    } finally {\n        throw new Error(\x27can not find it2\x27);\n    }\n} catch (err) {\n    console.log(err.message);\n}\n\n\/\/ can not find it2\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果从 \x3cstrong\x3efinally\x3c\/strong\x3e 块中返回一个值，那么这个值将会成为整个 \x3cstrong\x3etry-catch-finally\x3c\/strong\x3e 的返回值，无论是否有 \x3cstrong\x3ereturn\x3c\/strong\x3e 语句在 \x3cstrong\x3etry\x3c\/strong\x3e 和 \x3cstrong\x3ecatch\x3c\/strong\x3e 中。这包括在 \x3cstrong\x3ecatch\x3c\/strong\x3e 块里抛出的异常。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efunction test() {\n    try {\n        throw new Error(\x27can not find it1\x27);\n        return 1;\n    } catch (err) {\n        throw new Error(\x27can not find it2\x27);\n        return 2;\n    } finally {\n        return 3;\n    }\n}\n\nconsole.log(test()); \/\/ 3\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3eTry \/ Catch 性能\x3c\/h3\x3e\n\x3cp\x3e有一个大家众所周知的反优化模式就是使用 \x3cstrong\x3etry\/catch\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e在V8（其他JS引擎也可能出现相同情况）函数中使用了 \x3cstrong\x3etry\/catch\x3c\/strong\x3e 语句不能够被V8编译器优化。参考\x3ca href=\x22http:\/\/www.html5rocks.com\/en\/tutorials\/speed\/v8\/\x22 rel=\x22nofollow noreferrer\x22\x3ehttp:\/\/www.html5rocks.com\/en\/tutorials\/speed\/v8\/\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2\x3ewindow.onerror\x3c\/h2\x3e\n\x3cp\x3e通过在 \x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 上定义一个事件监听函数，程序中其他代码产生的未被捕获的异常往往就会被 \x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 上面注册的监听函数捕获到。并且同时捕获到一些关于异常的信息。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ewindow.onerror = function (message, source, lineno, colno, error) { }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3emessage\x3c\/code\x3e：异常信息（字符串）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esource\x3c\/code\x3e：发生异常的脚本URL（字符串）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3elineno\x3c\/code\x3e：发生异常的行号（数字）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecolno\x3c\/code\x3e：发生异常的列号（数字）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eerror\x3c\/code\x3e：Error对象（对象）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e注意：Safari 和 IE10 还不支持在 \x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 的回调函数中使用第五个参数，也就是一个 \x3cstrong\x3eError\x3c\/strong\x3e 对象并带有一个追溯栈\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3etry\/catch\x3c\/strong\x3e 不能够捕获异步代码中的异常，但是其将会把异常抛向全局然后 \x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 可以将其捕获。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3etry {\n    setTimeout(() =\x26gt; {\n        throw new Error(\x22some message\x22);\n    }, 0);\n} catch (err) {\n    console.log(err);\n}\n\/\/ Uncaught Error: some message\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3ewindow.onerror = (msg, url, line, col, err) =\x26gt; {\n    console.log(err);\n}\nsetTimeout(() =\x26gt; {\n    throw new Error(\x22some message\x22);\n}, 0);\n\/\/ Error: some message\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在Chrome中，\x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 能够检测到从别的域引用的script文件中的异常，并且将这些异常标记为\x3ccode\x3eScript error\x3c\/code\x3e。如果你不想处理这些从别的域引入的script文件，那么可以在程序中通过\x3ccode\x3eScript error\x3c\/code\x3e标记将其过滤掉。然而，在Firefox、Safari或者IE11中，并不会引入跨域的JS异常，即使在Chrome中，如果使用 \x3cstrong\x3etry\/catch\x3c\/strong\x3e 将这些讨厌的代码包围，那么Chrome也不会再检测到这些跨域异常。\x3c\/p\x3e\n\x3cp\x3e在Chrome中，如果你想通过 \x3cstrong\x3ewindow.onerror\x3c\/strong\x3e 来获取到完整的跨域异常信息，那么这些跨域资源必须提供合适的跨域头信息。\x3c\/p\x3e\n\x3ch2\x3ePromise中的异常\x3c\/h2\x3e\n\x3ch3\x3ePromise中抛出异常\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode\x3enew Promise((resolve,reject)=\x26gt;{\n    reject();\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.resolve().then((resolve,reject)=\x26gt;{\n    reject();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.reject();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3ethrow expression; \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3ePromise中捕捉异常\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode\x3epromiseObj.then(undefined, (err)=\x26gt;{\n    catch_statements\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3epromiseObj.catch((exception)=\x26gt;{\n    catch_statements\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3cstrong\x3eJavaScript\x3c\/strong\x3e 函数中，只有 \x3cstrong\x3ereturn\x3c\/strong\x3e \/ \x3cstrong\x3eyield\x3c\/strong\x3e \/ \x3cstrong\x3ethrow\x3c\/strong\x3e 会中断函数的执行，其他的都无法阻止其运行到结束的。\x3c\/p\x3e\n\x3cp\x3e在 \x3cstrong\x3eresolve\x3c\/strong\x3e \/ \x3cstrong\x3ereject\x3c\/strong\x3e 之前加上 \x3cstrong\x3ereturn\x3c\/strong\x3e 能阻止往下继续运行。\x3c\/p\x3e\n\x3cp\x3ewithout \x3ccode\x3ereturn\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.resolve()\n.then(() =\x26gt; {\n    console.log(\x27before excute reject\x27);\n    reject(new Error(\x27throw error\x27));\n    console.log(\x27after excute reject\x27);\n})\n.catch((err) =\x26gt; {\n    console.log(err.message);\n});\n\n\/\/ before excute reject\n\/\/ throw error\n\/\/ after excute reject\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3euse \x3ccode\x3ereturn\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.resolve()\n.then(() =\x26gt; {\n    console.log(\x27before excute reject\x27);\n    return reject(new Error(\x27throw error\x27));\n    console.log(\x27after excute reject\x27);\n})\n.catch((err) =\x26gt; {\n    console.log(err.message);\n});\n\n\/\/ before excute reject\n\/\/ throw error\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3eThrow or Reject\x3c\/h3\x3e\n\x3cp\x3e无论是 \x3cstrong\x3etry\/catch\x3c\/strong\x3e 还是 \x3cstrong\x3epromise\x3c\/strong\x3e 都能捕获到的是“同步”异常\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ereject\x3c\/strong\x3e 是回调，而 \x3cstrong\x3ethrow\x3c\/strong\x3e 只是一个同步的语句，如果在另一个异步的上下文中抛出，在当前上下文中是无法捕获到的。\x3c\/p\x3e\n\x3cp\x3e因此在 \x3cstrong\x3ePromise\x3c\/strong\x3e 中使用 \x3cstrong\x3ereject\x3c\/strong\x3e 抛出异常。否则 \x3cstrong\x3ecatch\x3c\/strong\x3e 有可能会捕捉不到。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.resolve()\n.then(() =\x26gt; {\n    setTimeout(()=\x26gt;{\n        throw new Error(\x27throw error\x27);\n    },0);\n})\n.catch((err) =\x26gt; {\n    console.log(err);\n});\n\n\/\/ Uncaught Error: throw error\x3c\/code\x3e\x3c\/pre\x3e\n\x3cpre\x3e\x3ccode\x3ePromise.resolve()\n.then(() =\x26gt; {\n    return new Promise((resolve, reject) =\x26gt; {\n        setTimeout(() =\x26gt; {\n            reject(new Error(\x27throw error\x27));\n        }, 0);\n    });\n})\n.catch((err) =\x26gt; {\n    console.log(err);\n});\n\n\/\/ Error: throw error\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3ewindow.onunhandledrejection\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ewindow.onunhandledrejection\x3c\/code\x3e 与 \x3ccode\x3ewindow.onerror\x3c\/code\x3e 类似，在一个JavaScript Promise 被 \x3cstrong\x3ereject\x3c\/strong\x3e 但是没有 \x3cstrong\x3ecatch\x3c\/strong\x3e 来捕捉这个 \x3cstrong\x3ereject\x3c\/strong\x3e时触发。并且同时捕获到一些关于异常的信息。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ewindow.onunhandledrejection = event =\x26gt; { \n    console.log(event.reason);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eevent\x3c\/code\x3e事件是 \x3cstrong\x3ePromiseRejectionEvent\x3c\/strong\x3e 的实例，它有两个属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eevent.promise\x3c\/code\x3e：被 rejected 的 JavaScript Promise\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eevent.reason\x3c\/code\x3e：一个值或 Object 表明为什么 promise 被 rejected，是 \x3cstrong\x3ePromise.reject()\x3c\/strong\x3e 中的内容。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3ewindow.rejectionhandled\x3c\/h2\x3e\n\x3cp\x3e因为 \x3cstrong\x3ePromise\x3c\/strong\x3e 可以延后调用 \x3cstrong\x3ecatch\x3c\/strong\x3e 方法，若在抛出 \x3cstrong\x3ereject\x3c\/strong\x3e 时未调用 \x3cstrong\x3ecatch\x3c\/strong\x3e 进行捕捉，但稍后再次调用 \x3cstrong\x3ecatch\x3c\/strong\x3e，此时会触发 \x3cstrong\x3erejectionhandled\x3c\/strong\x3e 事件。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ewindow.onrejectionhandled = event =\x26gt;\n{\n    console.log(\x27rejection handled\x27);\n}\n\nlet p = Promise.reject(new Error(\x27throw error\x27));\n\nsetTimeout(()=\x26gt;{\n    p.catch(e=\x26gt;{console.log(e)});\n},1000);\n\n\/\/ Uncaught (in promise) Error: throw error\n\/\/ 1秒后输出\n\/\/ Error: throw error\n\/\/ rejection handled\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e统一异常处理\x3c\/h2\x3e\n\x3cp\x3e代码中抛出的异常，一种是要展示给用户，一种是展示给开发者。\x3c\/p\x3e\n\x3cp\x3e对于展示给用户的异常，一般使用 \x3cstrong\x3ealert\x3c\/strong\x3e 或 \x3cstrong\x3etoast\x3c\/strong\x3e 展示；对于展示给开发者的异常，一般输出到控制台。\x3c\/p\x3e\n\x3cp\x3e在一个函数或一个代码块中可以把抛出的异常统一捕捉起来，按照不同的异常类型以不同的方式展示，对于。\x3c\/p\x3e\n\x3cp\x3e需要点击确认的异常类型：\x3cbr\x3e\x3cem\x3eensureError.js\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efunction EnsureError(message = \x27Default Message\x27) {\n    this.name = \x27EnsureError\x27;\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nEnsureError.prototype = Object.create(Error.prototype);\nEnsureError.prototype.constructor = EnsureError;\n\nexport default EnsureError;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e弹窗提示的异常类型：\x3cbr\x3e\x3cem\x3etoastError.js\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efunction ToastError(message = \x27Default Message\x27) {\n    this.name = \x27ToastError\x27;\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nToastError.prototype = Object.create(Error.prototype);\nToastError.prototype.constructor = ToastError;\n\nexport default ToastError;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e提示开发者的异常类型：\x3cbr\x3e\x3cem\x3edevError.js\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efunction DevError(message = \x27Default Message\x27) {\n    this.name = \x27ToastError\x27;\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nDevError.prototype = Object.create(Error.prototype);\nDevError.prototype.constructor = DevError;\n\nexport default DevError;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e异常处理器：\x3cbr\x3e抛出普通异常时，可以带上 \x3cstrong\x3estackoverflow\x3c\/strong\x3e 上问题的列表，方便开发者查找原因。\x3cbr\x3e\x3cem\x3eerrorHandler.js\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eimport EnsureError from \x27.\/ensureError.js\x27;\nimport ToastError from \x27.\/toastError.js\x27;\nimport DevError from \x27.\/devError.js\x27;\nimport EnsurePopup from \x27.\/ensurePopup.js\x27;\nimport ToastPopup from \x27.\/toastPopup.js\x27;\n\nfunction errorHandler(err) {\n    if (err instanceof EnsureError) {\n        EnsurePopup(err.message);\n    } else if (err instanceof ToastError) {\n        ToastPopup(err.message);\n    }else if( err instanceof DevError){\n        DevError(err.message);\n    }else{\n        error.message \x2b= ` https:\/\/stackoverflow.com\/questions?q=${encodeURI(error.message)}`\n        console.error(err.message);    \n    }\n}\n\nwindow.onerror = (msg, url, line, col, err) =\x26gt; {\n    errorHandler(err);\n}\n\nwindow.onunhandledrejection = event =\x26gt;{\n    errorHandler(event.reason);\n};\n\nexport default errorHandler;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e欢迎关注：\x3ca href=\x22https:\/\/segmentfault.com\/u\/leechikit\/articles\x22\x3eLeechikit\x3c\/a\x3e\x3cbr\x3e原文链接：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000011481099\x22\x3esegmentfault.com\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e到此本文结束，欢迎提问和指正。\x3cbr\x3e写原创文章不易，若本文对你有帮助，请点赞、推荐和关注作者支持。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript的异常处理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011481099">https://segmentfault.com/a/1190000011481099</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3jtxuq8a7kk/" target="_blank">https://alili.tech/archive/3jtxuq8a7kk/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>