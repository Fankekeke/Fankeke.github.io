<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="immer.js 简介及源码解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>immer.js 简介及源码解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3r5yi1198ot/",
				"appid": "1613049289050283", 
				"title": "immer.js 简介及源码解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-15T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pbi9mqtlnno/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/u7v3hllbzh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&text=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&text=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&title=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&is_video=false&description=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&title=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&title=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&title=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3r5yi1198ot%2f&title=immer.js%20%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">immer.js 简介及源码解析</h1><div class="meta"><div class="postdate"><time datetime="2018-12-15" itemprop="datePublished">2018-12-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV27Dy?w=1400\x26amp;h=544\x22 src=\x22https:\/\/static.alili.tech\/img\/bV27Dy?w=1400\x26amp;h=544\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e博客链接：\x3ca href=\x22https:\/\/zhangzhao.name\/2018\/02\/01\/immer%20-%20immutable\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e下一代状态管理工具 immer 简介及源码解析\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eJS 里面的变量类型可以大致分为基本类型和引用类型。在使用过程中，引用类型经常会产生一些无法意识到的副作用，所以在现代 JS 开发过程中，大家都有意识的写下断开引用的不可变数据类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 引用带来的副作用\nvar a = [{ val: 1 }]\nvar b = a.map(item =\x3e item.val = 2)\n\n\/\/ 期望：b 的每一个元素的 val 值变为 2\nconsole.log(a[0].val) \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引用带来的副作用\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = [{ \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e }]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = a.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e item.val = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 期望：b 的每一个元素的 val 值变为 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上述例子我们可以发现，本意是只想让 b 中的每一个元素的值变为 2 ，但却无意中改掉了 a 中每一个元素的结果，这是不符合预期的。接下来如果某个地方使用到了 a ，很容易发生一些我们难以预料并且难以 debug 的 bug。\x3c\/p\x3e\n\x3cp\x3e在有了这样的问题之后，一般来说当需要传递一个对象进一个函数时，我们可以使用 \x3ccode\x3eObject.assign\x3c\/code\x3e 或者 \x3ccode\x3e...\x3c\/code\x3e 对对象进行解构，成功断掉一层的引用。\x3c\/p\x3e\n\x3cp\x3e例如上面的问题我们可以改用下面的这种写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = [{ val: 1 }]\nvar b = a.map(item =\x3e ({ ...item, val: 2 }))\n\nconsole.log(a[0].val) \/\/ 1\nconsole.log(b[0].val) \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = [{ \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e }]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = a.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({ ...item, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }))\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样做其实还会有一个问题，无论是 \x3ccode\x3eObject.assign\x3c\/code\x3e 还是 \x3ccode\x3e...\x3c\/code\x3e 的解构操作，断掉的引用也只是一层，如果对象嵌套超过一层，这样做还是有一定的风险。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = [\n  { val: 1, desc: { text: \x27a\x27 } }\n]\nvar b = a.map(item =\x3e ({ ...item, val: 2 }))\n\nconsole.log(a === b)           \/\/ false\nconsole.log(a.desc === b.desc) \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = [\n  { \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3edesc\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e } }\n]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = a.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({ ...item, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }))\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a === b)           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.desc === b.desc) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样一来，后面的代码如果一不小心在一个函数内部给 \x3ccode\x3eb.desc\x3c\/code\x3e 对象里面的内容通过“点”进行赋值，就一定会改变具有相同引用的 \x3ccode\x3ea.desc\x3c\/code\x3e 部分的值，这当然是不符合我们的预期的。\x3c\/p\x3e\n\x3cp\x3e所以在这之后，大多数情况下我们会考虑 \x3cstrong\x3e深拷贝\x3c\/strong\x3e 这样的操作来完全避免上面遇到的所有问题。深拷贝，顾名思义就是在遍历过程中，如果遇到了可能出现引用的数据类型，就会递归的完全创建一个新的类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 一个简单的深拷贝函数，去掉了一些胶水部分\n\/\/ 用户态输入一定是一个 Plain Object，并且所有 value 也是 Plain Object\nfunction deepClone(a) {\n  const keys = Object.keys(a)\n  return keys.reduce((memo, current) =\x3e {\n    const value = a[current]\n    if (typeof value === \x27object\x27) {\n      return {\n        ...memo,\n        [current]: deepClone(value),\n      }\n    }\n    return {\n      ...memo,\n      [current]: value,\n    }\n  }, {})\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个简单的深拷贝函数，去掉了一些胶水部分\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用户态输入一定是一个 Plain Object，并且所有 value 也是 Plain Object\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edeepClone\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(a)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e keys.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ememo, current\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = a[current]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e value === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        ...memo,\n        [current]: deepClone(value),\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      ...memo,\n      [current]: value,\n    }\n  }, {})\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用上面的 deepClone 函数进行简单测试\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = {\n  val: 1,\n  desc: {\n    text: \x27a\x27,\n  },\n}\nvar b = deepClone(a)\n\nb.val = 2\nconsole.log(a.val) \/\/ 1\nconsole.log(b.val) \/\/ 2\n\nb.desc.text = \x27b\x27\nconsole.log(a.desc.text) \/\/ \x27a\x27\nconsole.log(b.desc.text) \/\/ \x27b\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = {\n  \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edesc\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n  },\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = deepClone(a)\n\nb.val = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\nb.desc.text = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.desc.text) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27a\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.desc.text) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27b\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的这个 \x3ccode\x3edeepClone\x3c\/code\x3e 可以满足简单的需求，但是真正在生产工作中，我们需要考虑非常多的因素。举例来说：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ekey 里面 getter，setter 以及原型链上的内容如何处理\x3c\/li\x3e\n\x3cli\x3evalue 是一个 Symbol 如何处理\x3c\/li\x3e\n\x3cli\x3evalue 是其他非 Plain Object 如何处理\x3c\/li\x3e\n\x3cli\x3evalue 内部出现了一些循环引用如何处理\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e因为有太多不确定因素，所以我还是推荐使用大型开源项目里面的工具函数，比较常用的为大家所熟知的就是 \x3ccode\x3elodash.cloneDeep\x3c\/code\x3e，无论是安全性还是效果都有所保障。\x3c\/p\x3e\n\x3cp\x3e其实，这样的概念我们常称作 immutable ，意为不可变的数据，其实理解为不可变关系更为恰当。每当我们创建一个被 \x3ccode\x3edeepClone\x3c\/code\x3e 过的数据，新的数据进行有副作用 (side effect) 的操作都不会影响到之前的数据，这也就是 immutable 的精髓和本质。\x3c\/p\x3e\n\x3cp\x3e然而 deepClone 这种函数虽然断绝了引用关系实现了 immutable，但是开销实在太大。所以在 2014 年，facebook 的 immutable-js 横空出世，即保证了 immutable ，又兼顾了性能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eimmutable-js 简介\x3c\/h2\x3e\n\x3cp\x3eimmutable-js 使用了另一套数据结构的 API ，与我们的常见操作有些许不同，它将所有的原生对象都会转化成 immutable-js 的内部对象，并且任何操作最终都会返回一个新的 immutable 的值。\x3c\/p\x3e\n\x3cp\x3e上面的例子使用 immutable-js 就需要这样改造一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { fromJS } = require(\x27immutable\x27)\nconst data = {\n  val: 1,\n  desc: {\n    text: \x27a\x27,\n  },\n}\n\nconst a = fromJS(data)\n\nconst b = a.set(\x27val\x27, 2)\nconsole.log(a.get(\x27val\x27)) \/\/ 1\nconsole.log(b.get(\x27val\x27)) \/\/ 2\n\nconst pathToText = [\x27desc\x27, \x27text\x27]\nconst c = a.setIn([...pathToText], \x27c\x27)\nconsole.log(a.getIn([...pathToText])) \/\/ \x27a\x27\nconsole.log(c.getIn([...pathToText])) \/\/ \x27c\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { fromJS } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27immutable\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {\n  \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edesc\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n  },\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = fromJS(data)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a.set(\x3cspan class=\x22hljs-string\x22\x3e\x27val\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.get(\x3cspan class=\x22hljs-string\x22\x3e\x27val\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.get(\x3cspan class=\x22hljs-string\x22\x3e\x27val\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pathToText = [\x3cspan class=\x22hljs-string\x22\x3e\x27desc\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e c = a.setIn([...pathToText], \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.getIn([...pathToText])) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27a\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(c.getIn([...pathToText])) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27c\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于性能方面，immutable-js 也有它的优势，举个简单的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { fromJS } = require(\x27immutable\x27)\nconst data = {\n  content: {\n    time: \x272018-02-01\x27,\n    val: \x27Hello World\x27,\n  },\n  desc: {\n    text: \x27a\x27,\n  },\n}\n\nconst a = fromJS(data)\nconst b = a.setIn([\x27desc\x27, \x27text\x27], \x27b\x27)\nconsole.log(b.get(\x27desc\x27) === a.get(\x27desc\x27))       \/\/ false\nconsole.log(b.get(\x27content\x27) === a.get(\x27content\x27)) \/\/ true\n\nconst c = a.toJS()\nconst d = b.toJS()\nconsole.log(c.desc === d.desc)       \/\/ false\nconsole.log(c.content === d.content) \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { fromJS } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27immutable\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {\n  \x3cspan class=\x22hljs-attr\x22\x3econtent\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3etime\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x272018-02-01\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3edesc\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n  },\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = fromJS(data)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a.setIn([\x3cspan class=\x22hljs-string\x22\x3e\x27desc\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.get(\x3cspan class=\x22hljs-string\x22\x3e\x27desc\x27\x3c\/span\x3e) === a.get(\x3cspan class=\x22hljs-string\x22\x3e\x27desc\x27\x3c\/span\x3e))       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.get(\x3cspan class=\x22hljs-string\x22\x3e\x27content\x27\x3c\/span\x3e) === a.get(\x3cspan class=\x22hljs-string\x22\x3e\x27content\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e c = a.toJS()\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e d = b.toJS()\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(c.desc === d.desc)       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(c.content === d.content) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的例子可以看出来，在 immutable-js 的数据结构中，深层次的对象在没有修改的情况下仍然能够保证严格相等。这里的严格相等就可以认为是没有新建这个对象，仍然在内部保持着之前的引用，但是修改却不会同步的修改。\x3c\/p\x3e\n\x3cp\x3e经常使用 React 的同学肯定也对 immutable-js 不陌生，这也就是为什么 immutable-js 会极大提高 React 页面性能的原因之一了。\x3c\/p\x3e\n\x3cp\x3e当然能够达到 immutable 效果的当然不只这几个个例，这篇文章我主要想介绍实现 immutable 的库其实是 immer。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eimmer 简介\x3c\/h2\x3e\n\x3cp\x3eimmer 的作者同时也是 mobx 的作者，一个看起来非常感性的中年大叔。mobx 又像是把 Vue 的一套东西融合进了 React，已经在社区取得了不错的反响。immer 则是他在 immutable 方面所做的另一个实践，在 2018-02-01，immer 成功发布了 \x3cstrong\x3e1.0.0\x3c\/strong\x3e 版本，我差不多在一个月前开始关注这个项目，所以大清早看到作者在 twitter 上发的通告，有感而发今天写下这篇文章，算是简单介绍一下 immer 这个 immutable 框架的使用以及内部简单的实现原理。\x3c\/p\x3e\n\x3cp\x3e与 immutable-js 最大的不同，immer 是使用原生数据结构的 API 而不是内置的 API，举个简单例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const produce = require(\x27immer\x27)\n\nconst state = {\n  done: false,\n  val: \x27string\x27,\n}\n\nconst newState = produce(state, (draft) =\x3e {\n  draft.done = true\n})\n\nconsole.log(state.done) \/\/ false\nconsole.log(newState.done) \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e produce = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27immer\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e state = {\n  \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e,\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newState = produce(state, (draft) =\x26gt; {\n  draft.done = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(state.done) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(newState.done) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有需要更改的逻辑都可以放进 produce 的第二个参数的函数内部，即使给对象内的元素直接赋值，也不会对原对象产生任何影响。\x3c\/p\x3e\n\x3cp\x3e简单介绍完使用之后，下面就开始简单介绍它的内部实现。不过在这之前，想先通过上面的例子简单的发散思考一下。\x3c\/p\x3e\n\x3cp\x3e通过文章最开始的例子我们就能明白，给函数传入一个对象，直接通过“点”操作符对里面的一个属性进行更改是一定会改变外面的结果的。而上面的这个例子中，\x3ccode\x3edraft\x3c\/code\x3e 参数穿入进去，与 \x3ccode\x3estate\x3c\/code\x3e 一样也有 done 这个属性，但是在通过 \x3ccode\x3edraft.done\x3c\/code\x3e 改变值之后，原来的 \x3ccode\x3estate.done\x3c\/code\x3e 并没有发生改变。其实到这里，结合之前研究 vue 源码的经验，我当时就笃定，这里一定用了 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e，draft 通过“点”操作的之后，一些数据的结果被劫持了，然后做了一些新的操作。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eimmer 原理解析\x3c\/h2\x3e\n\x3cp\x3e真正翻开源码，诚然里面确实有 defineProperty 的身影，不过在另一个标准的文件中，用了一种新的方式，那就是 ES6 中新增的 Proxy 对象。而在日常的业务过程中，应该很少有前端工程师会用到 Proxy 对象，因为它的应用场景确实有些狭隘，所以这里简单介绍一下 Proxy 对象的使用。\x3c\/p\x3e\n\x3cp\x3eProxy 对象接受两个参数，第一个参数是需要操作的对象，第二个参数是设置对应拦截的属性，这里的属性同样也支持 get，set 等等，也就是劫持了对应元素的读和写，能够在其中进行一些操作，最终返回一个 Proxy 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const proxy = new Proxy({}, {\n  get(target, key) {\n    console.log(\x27proxy get key\x27, key)\n  },\n  set(target, key, value) {\n    console.log(\x27value\x27, value)\n  }\n})\n\nproxy.info     \/\/ \x27proxy get key info\x27\nproxy.info = 1 \/\/ \x27value 1\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e proxy = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eProxy\x3c\/span\x3e({}, {\n  get(target, key) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27proxy get key\x27\x3c\/span\x3e, key)\n  },\n  set(target, key, value) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e, value)\n  }\n})\n\nproxy.info     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27proxy get key info\x27\x3c\/span\x3e\nproxy.info = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27value 1\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这个例子中传入的第一个参数是一个空对象，当然我们可以用其他对象有内容的对象代替它。例如维护一份 state 在内部，来判断是否有变化，下面这个例子就是一个构造函数，如果将它的实例传入 Proxy 对象作为第一个参数，就能够后面的处理对象中使用其中的方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Store {\n  constructor(state) {\n    this.modified = false\n    this.source = state\n    this.copy = null\n  }\n  get(key) {\n    if (!this.modified) return this.source[key]\n    return this.copy[key]\n  }\n  set(key, value) {\n    if (!this.modified) this.modifing()\n    return this.copy[key] = value\n  }\n  modifing() {\n    if (this.modified) return\n    this.modified = true\n    this.copy = Array.isArray(this.source)\n      ? this.source.slice()\n      : { ...this.source }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(state) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modified = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source = state\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.copy = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  }\n  get(key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modified) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.copy[key]\n  }\n  set(key, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modified) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modifing()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.copy[key] = value\n  }\n  modifing() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modified) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modified = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.copy = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source)\n      ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source.slice()\n      : { ...this.source }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这个构造函数相比源代码省略了很多判断的部分。实例上面有 modified，source，copy 三个属性，有 get，set，modifing 三个方法。modified 作为内置的 flag，判断如何进行设置和返回。\x3c\/p\x3e\n\x3cp\x3e里面最关键的就应该是 \x3ccode\x3emodifing\x3c\/code\x3e 这个函数，如果触发了 setter 并且之前没有改动过的话，就会手动将 \x3ccode\x3emodified\x3c\/code\x3e 这个 flag 设置为 \x3ccode\x3etrue\x3c\/code\x3e，并且手动通过原生的 API 实现一层 immutable。\x3c\/p\x3e\n\x3cp\x3e对于 Proxy 的第二个参数，就更加简单了。在这个例子中，只是简单做一层转发，任何对元素的读取和写入都转发到前面的实例内部方法去。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const PROXY_FLAG = \x27@@SYMBOL_PROXY_FLAG\x27\nconst handler = {\n  get(target, key) {\n    if (key === PROXY_FLAG) return target\n    return target.get(key)\n  },\n  set(target, key, value) {\n    return target.set(key, value)\n  },\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PROXY_FLAG = \x3cspan class=\x22hljs-string\x22\x3e\x27@@SYMBOL_PROXY_FLAG\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handler = {\n  get(target, key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key === PROXY_FLAG) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target.get(key)\n  },\n  set(target, key, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target.set(key, value)\n  },\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里在 getter 里面加一个 flag 的目的就在于将来从 proxy 对象中获取 store 实例更加方便。\x3c\/p\x3e\n\x3cp\x3e最终我们能够完成这个 produce 函数，创建 store 实例后创建 proxy 实例。然后将创建的 proxy 实例传入第二个函数中去。这样无论在内部做怎样有副作用的事情，最终都会在 store 实例内部将它解决。最终得到了修改之后的 proxy 对象，而 proxy 对象内部已经维护了两份 state ，通过判断 modified 的值来确定究竟返回哪一份。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function produce(state, producer) {\n  const store = new Store(state)\n  const proxy = new Proxy(store, handler)\n\n  producer(proxy)\n\n  const newState = proxy[PROXY_FLAG]\n  if (newState.modified) return newState.copy\n  return newState.source\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproduce\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate, producer\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Store(state)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e proxy = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eProxy\x3c\/span\x3e(store, handler)\n\n  producer(proxy)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newState = proxy[PROXY_FLAG]\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newState.modified) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newState.copy\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newState.source\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，一个分割成 Store 构造函数，handler 处理对象和 produce 处理 state 这三个模块的最简版就完成了，将它们组合起来就是一个最最最 tiny 版的 immer ，里面去除了很多不必要的校验和冗余的变量。但真正的 immer 内部也有其他的功能，例如深度克隆情况下的结构共享等等。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e性能\x3c\/h2\x3e\n\x3cp\x3e性能方面，就用 immer 官方 README 里面的介绍来说明情况。\x3c\/p\x3e\n\x3cp\x3e这是一个关于 immer 性能的简单测试。这个测试使用了 100000 个组件元素，并且更新其中的 10000 个。freeze 表示状态树在生成之后已被冻结。这是一个最佳的开发实践，因为它可以防止开发人员意外修改状态树。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV242e?w=775\x26amp;h=535\x22 src=\x22https:\/\/static.alili.tech\/img\/bV242e?w=775\x26amp;h=535\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过上图的观察，基本可以得出：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e从 immer 的角度来看，这个性能环境比其他框架和库要恶劣的多，因为它必须代理的根节点相对于其余的数据集来说大得多\x3c\/li\x3e\n\x3cli\x3e从 mutate 和 deepclone 来看，mutate 基准确定了数据更改费用的基线，没有不可变性（或深度克隆情况下的结构共享）\x3c\/li\x3e\n\x3cli\x3e使用 Proxy 的 immer 大概是手写 reducer 的两倍，当然这在实践中可以忽略不计\x3c\/li\x3e\n\x3cli\x3eimmer 大致和 immutable-js 一样快。但是，immutable-js 最后经常需要 toJS 操作，这里的性能的开销是很大的。例如将不可变的 JS 对象转换回普通的对象，将它们传递给组件中，或着通过网络传输等等（还有将从例如服务器接收到的数据转换为 immutable-js 内置对象的前期成本）\x3c\/li\x3e\n\x3cli\x3eimmer 的 ES5 实现速度明显较慢。对于大多数的 reducer 来说，这并不重要，因为处理大量数据的 reducer 可以完全不（或者仅部分）使用 immer 的 produce 函数。幸运的是，immer 完全支持这种选择性加入的情况\x3c\/li\x3e\n\x3cli\x3e在 freeze 的版本中，只有 mutate，deepclone 和原生 reducer 才能够递归地冻结全状态树，而其他测试用例只冻结树的修改部分\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e写在后面\x3c\/h2\x3e\n\x3cp\x3e其实纵观 immer 的实现，核心的原理就是放在了对对象读写的劫持，从表现形式上立刻就能让人想到 vue ，mobx 从核心原理上来说也是对对象的读写劫持，最近有另一篇非常火的文章 -- 如何让 \x3ccode\x3e(a == 1 \x26amp;\x26amp; a == 2 \x26amp;\x26amp; a == 3)\x3c\/code\x3e 为 true，也相信不少的小伙伴读过，除了那个肉眼不可见字符的答案，其他答案也算是对对象的读写劫持从而达到目标。\x3c\/p\x3e\n\x3cp\x3e所以说在 JS 中，很多知识相辅相成，有多少种方式能让 (a == 1 \x26amp;\x26amp; a == 2 \x26amp;\x26amp; a == 3) 为 true，理论上有多少种答案就会有多少种 MVVM 的组成方式，甚至就有多少种方法能够实现这样的 immutable。所以任何一点点小的知识点的聚合，未来都可能影响前端的发展。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>immer.js 简介及源码解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013088373">https://segmentfault.com/a/1190000013088373</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3r5yi1198ot/" target="_blank">https://alili.tech/archive/3r5yi1198ot/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>