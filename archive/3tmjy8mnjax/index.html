<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue 模板编译原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue 模板编译原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3tmjy8mnjax/",
				"appid": "1613049289050283", 
				"title": "Vue 模板编译原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fetdbeamjf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bvzyw5s3wdo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&text=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&text=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&title=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&is_video=false&description=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&title=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&title=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&title=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3tmjy8mnjax%2f&title=Vue%20%e6%a8%a1%e6%9d%bf%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue 模板编译原理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22http:\/\/www.codedata.cn\/hacknews\/152110789460328114\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文地址\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3eVue 模板编译原理\x3c\/h1\x3e\n\x3cp\x3e关于vue的内部原理其实有很多个重要的部分，变化侦测，模板编译，virtualDOM，整体运行流程等。\x3c\/p\x3e\n\x3cp\x3e之前写过一篇\x3ca href=\x22https:\/\/github.com\/berwin\/Blog\/issues\/17\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《深入浅出 - vue变化侦测原理》\x3c\/a\x3e 讲了关于变化侦测的实现原理。\x3c\/p\x3e\n\x3cp\x3e那今天主要把 \x3cstrong\x3e模板编译\x3c\/strong\x3e 这部分的实现原理单独拿出来讲一讲。\x3c\/p\x3e\n\x3cp\x3e本文我可能不会在文章中说太多细节部分的处理，我会把 vue 对模板编译这部分的整体原理讲清楚，主要是让读者读完文章后对模板编译的整体实现原理有一个清晰的思路和理解。\x3c\/p\x3e\n\x3cp\x3e关于 Vue 编译原理这块的整体逻辑主要分三个部分，也可以说是分三步，这三个部分是有前后关系的：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e第一步是将 \x3ccode\x3e模板字符串\x3c\/code\x3e 转换成 \x3ccode\x3eelement ASTs\x3c\/code\x3e（解析器）\x3c\/li\x3e\n\x3cli\x3e第二步是对 \x3ccode\x3eAST\x3c\/code\x3e 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）\x3c\/li\x3e\n\x3cli\x3e第三步是 使用 \x3ccode\x3eelement ASTs\x3c\/code\x3e 生成 \x3ccode\x3erender\x3c\/code\x3e 函数代码字符串（代码生成器）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e解析器\x3c\/h2\x3e\n\x3cp\x3e解析器主要干的事是将 \x3ccode\x3e模板字符串\x3c\/code\x3e 转换成 \x3ccode\x3eelement ASTs\x3c\/code\x3e，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;div\x26gt;\n  \x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这样一个简单的 \x3ccode\x3e模板\x3c\/code\x3e 转换成 \x3ccode\x3eelement AST\x3c\/code\x3e 后是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  tag: \x26quot;div\x26quot;\n  type: 1,\n  staticRoot: false,\n  static: false,\n  plain: true,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n      {\n      tag: \x26quot;p\x26quot;\n      type: 1,\n      staticRoot: false,\n      static: false,\n      plain: true,\n      parent: {tag: \x26quot;div\x26quot;, ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n          type: 2,\n          text: \x26quot;\x22{{\x22name\x22}}\x22\x26quot;,\n          static: false,\n          expression: \x26quot;_s(name)\x26quot;\n      }]\n    }\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e{\n  tag: \x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e\n  type: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  staticRoot: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  plain: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n      {\n      tag: \x3cspan class=\x22hljs-string\x22\x3e\x22p\x22\x3c\/span\x3e\n      type: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n      staticRoot: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      plain: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      parent: {tag: \x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e, ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n          type: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n          text: \x3cspan class=\x22hljs-string\x22\x3e\x22\x22{{\x22name\x22}}\x22\x22\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n          expression: \x3cspan class=\x22hljs-string\x22\x3e\x22_s(name)\x22\x3c\/span\x3e\n      }]\n    }\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们先用这个简单的例子来说明这个解析器的内部究竟发生了什么。\x3c\/p\x3e\n\x3cp\x3e这段模板字符串会扔到 \x3ccode\x3ewhile\x3c\/code\x3e 中去循环，然后 \x3cstrong\x3e一段一段\x3c\/strong\x3e 的截取，把截取到的 \x3cstrong\x3e每一小段字符串\x3c\/strong\x3e 进行解析，直到最后截没了，也就解析完了。\x3c\/p\x3e\n\x3cp\x3e上面这个简单的模板截取的过程是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;div\x26gt;\n  \x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那是根据什么截的呢？换句话说截取字符串有什么规则么？\x3c\/p\x3e\n\x3cp\x3e当然有\x3c\/p\x3e\n\x3cp\x3e只要判断模板字符串是不是以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头我们就可以知道我们接下来要截取的这一小段字符串是 \x3ccode\x3e标签\x3c\/code\x3e 还是 \x3ccode\x3e文本\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e举个?：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e 这样的一段字符串是以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的，那么我们通过正则把 \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e 这一部分 \x3ccode\x3ematch\x3c\/code\x3e 出来，就可以拿到这样的数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  tagName: \x27div\x27,\n  attrs: [],\n  unarySlash: \x27\x27,\n  start: 0,\n  end: 5\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e{\n  tagName: \x27div\x27,\n  attrs: [],\n  unarySlash: \x27\x27,\n  start: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n  end: \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好奇如何用正则解析出 tagName 和 attrs 等信息的同学可以看下面这个demo代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ncname = \x27[a-zA-Z_][\\\\w\\\\-\\\\.]*\x27\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^\x3c${qnameCapture}`)\nconst startTagClose = \/^\\s*(\\\/?)\x3e\/\nlet html = `\x3cdiv\x3e\x3c\/div\x3e`\nlet index = 0\nconst start = html.match(startTagOpen)\n\nconst match = {\n  tagName: start[1],\n  attrs: [],\n  start: 0\n}\nhtml = html.substring(start[0].length)\nindex \x2b= start[0].length\nlet end, attr\nwhile (!(end = html.match(startTagClose)) \x26amp;\x26amp; (attr = html.match(attribute))) {\n  html = html.substring(attr[0].length)\n  index \x2b= attr[0].length\n  match.attrs.push(attr)\n}\nif (end) {\n  match.unarySlash = end[1]\n  html = html.substring(end[0].length)\n  index \x2b= end[0].length\n  match.end = index\n}\nconsole.log(match)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3econst ncname = \x27[a-zA-\x3cspan class=\x22hljs-type\x22\x3eZ_\x3c\/span\x3e][\\\\w\\\\-\\\\.]*\x27\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new \x3cspan class=\x22hljs-type\x22\x3eRegExp\x3c\/span\x3e(`^\x26lt;${qnameCapture}`)\nconst startTagClose = \/^\\s*(\\\/?)\x26gt;\/\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e html = `\x26lt;div\x26gt;\x26lt;\/div\x26gt;`\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nconst start = html.match(startTagOpen)\n\nconst match = {\n  tagName: start[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],\n  attrs: [],\n  start: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n}\nhtml = html.substring(start[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length)\nindex \x2b= start[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e end, attr\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (!(end = html.match(startTagClose)) \x26amp;\x26amp; (attr = html.match(attribute))) {\n  html = html.substring(attr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length)\n  index \x2b= attr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length\n  match.attrs.push(attr)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (end) {\n  match.unarySlash = end[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n  html = html.substring(end[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length)\n  index \x2b= end[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length\n  match.end = index\n}\nconsole.log(match)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eStack\x3c\/h3\x3e\n\x3cp\x3e用正则把 \x3ccode\x3e开始标签\x3c\/code\x3e 中包含的数据（attrs, tagName 等）解析出来之后还要做一个很重要的事，就是要维护一个 \x3ccode\x3estack\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e那这个 \x3ccode\x3estack\x3c\/code\x3e 是用来干什么的呢？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e这个 \x3ccode\x3estack\x3c\/code\x3e 是用来记录一个层级关系的，用来记录DOM的深度。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e更准确的说，当解析到一个 \x3ccode\x3e开始标签\x3c\/code\x3e 或者 \x3ccode\x3e文本\x3c\/code\x3e，无论是什么， \x3ccode\x3estack\x3c\/code\x3e 中的最后一项，永远是当前正在被解析的节点的 \x3ccode\x3eparentNode\x3c\/code\x3e 父节点。\x3c\/p\x3e\n\x3cp\x3e通过 \x3ccode\x3estack\x3c\/code\x3e 解析器就可以把当前解析到的节点 \x3ccode\x3epush\x3c\/code\x3e 到 父节点的 \x3ccode\x3echildren\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e也可以把当前正在解析的节点的 \x3ccode\x3eparent\x3c\/code\x3e 属性设置为 父节点。\x3c\/p\x3e\n\x3cp\x3e事实上也确实是这么做的。\x3c\/p\x3e\n\x3cp\x3e但并不是只要解析到一个标签的开始部分就把当前标签 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3estack\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e因为在 HTML 中有一种 \x3ccode\x3e自闭和标签\x3c\/code\x3e，比如 \x3ccode\x3einput\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;input \/\x26gt;\x3c\/code\x3e 这种 \x3ccode\x3e自闭和的标签\x3c\/code\x3e 是不需要 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3estack\x3c\/code\x3e 中的，因为 \x3ccode\x3einput\x3c\/code\x3e 并不存在子节点。\x3c\/p\x3e\n\x3cp\x3e所以当解析到一个标签的开始时，要判断当前被解析的标签是否是自闭和标签，如果不是自闭和标签才 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3estack\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (!unary) {\n  currentParent = element\n  stack.push(element)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!unary) {\n  currentParent = element\n  stack.push(element)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在有了 DOM 的层级关系，也可以解析出DOM的 \x3ccode\x3e开始标签\x3c\/code\x3e，这样每解析一个 \x3ccode\x3e开始标签\x3c\/code\x3e 就生成一个 \x3ccode\x3eASTElement\x3c\/code\x3e (存储当前标签的attrs，tagName 等信息的object）\x3c\/p\x3e\n\x3cp\x3e并且把当前的 \x3ccode\x3eASTElement\x3c\/code\x3e push 到 \x3ccode\x3eparentNode\x3c\/code\x3e 的 \x3ccode\x3echildren\x3c\/code\x3e 中，同时给当前 \x3ccode\x3eASTElement\x3c\/code\x3e 的 \x3ccode\x3eparent\x3c\/code\x3e 属性设置为 \x3ccode\x3estack\x3c\/code\x3e 中的最后一项\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22currentParent.children.push(element)\nelement.parent = currentParent\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3ecurrentParent.children.push(element)\nelement.parent = currentParent\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\n\x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的几种情况\x3c\/h3\x3e\n\x3cp\x3e但并不是所有以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的字符串都是 \x3ccode\x3e开始标签\x3c\/code\x3e，以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的字符串有以下几种情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e开始标签 \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e结束标签 \x3ccode\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3eHTML注释 \x3ccode\x3e\x26lt;!-- 我是注释 --\x26gt;\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3eDoctype \x3ccode\x3e\x26lt;!DOCTYPE html\x26gt;\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e条件注释（\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Conditional_comment#Downlevel-revealed_conditional_comment\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDownlevel-revealed conditional comment\x3c\/a\x3e）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当然我们解析器在解析的过程中遇到的最多的是 \x3ccode\x3e开始标签\x3c\/code\x3e \x3ccode\x3e结束标签\x3c\/code\x3e 和 \x3ccode\x3e注释\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e截取文本\x3c\/h3\x3e\n\x3cp\x3e我们继续上面的例子解析，\x3ccode\x3ediv\x3c\/code\x3e 的 \x3ccode\x3e开始标签\x3c\/code\x3e 解析之后剩余的模板字符串是下面的样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一次我们在解析发现 模板字符串 不是以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头了。\x3c\/p\x3e\n\x3cp\x3e那么如果模板字符串不是以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的怎么处理呢？？\x3c\/p\x3e\n\x3cp\x3e其实如果字符串不是以 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头可能会出现这么几种情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22我是text \x3cdiv\x3e\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e我是text \x26lt;div\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22我是text \x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e我是text \x26lt;\/p\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不论是哪种情况都会将标签前面的文本部分解析出来，截取这段文本其实并不难，看下面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 可以直接将本 demo 放到浏览器 console 中去执行\nconst html = \x27我是text \x3c\/p\x3e\x27\nlet textEnd = html.indexOf(\x27\x3c\x27)\nconst text = html.substring(0, textEnd)\nconsole.log(text)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以直接将本 demo 放到浏览器 console 中去执行\x3c\/span\x3e\nconst html = \x27我是text \x26lt;\/p\x26gt;\x27\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e textEnd = html.indexOf(\x27\x26lt;\x27)\nconst text = html.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, textEnd)\nconsole.log(text)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然 vue 对文本的截取不只是这么简单，vue对文本的截取做了很安全的处理，如果 \x3ccode\x3e\x26lt;\x3c\/code\x3e 是文本的一部分，那上面 DEMO 中截取的内容就不是我们想要的，例如这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a \x3c b \x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ea \x26lt; b \x26lt;\/p\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果是这样的文本，上面的 demo 肯定就挂了，截取出的文本就会遗漏一部分，而 vue 对这部分是进行了处理的，看下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let textEnd = html.indexOf(\x27\x3c\x27)\nlet text, rest, next\nif (textEnd \x3e= 0) {\n  rest = html.slice(textEnd)\n  \/\/ 剩余部分的 HTML 不符合标签的格式那肯定就是文本\n  \/\/ 并且还是以 \x3c 开头的文本\n  while (\n    !endTag.test(rest) \x26amp;\x26amp;\n    !startTagOpen.test(rest) \x26amp;\x26amp;\n    !comment.test(rest) \x26amp;\x26amp;\n    !conditionalComment.test(rest)\n  ) {\n    \/\/ \x3c in plain text, be forgiving and treat it as text\n    next = rest.indexOf(\x27\x3c\x27, 1)\n    if (next \x3c 0) break\n    textEnd \x2b= next\n    rest = html.slice(textEnd)\n  }\n  text = html.substring(0, textEnd)\n  html = html.substring(0, textEnd)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e textEnd = html.indexOf(\x27\x26lt;\x27)\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e text, rest, next\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (textEnd \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  rest = html.slice(textEnd)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 剩余部分的 HTML 不符合标签的格式那肯定就是文本\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并且还是以 \x26lt; 开头的文本\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\n    !endTag.test(rest) \x26amp;\x26amp;\n    !startTagOpen.test(rest) \x26amp;\x26amp;\n    !comment.test(rest) \x26amp;\x26amp;\n    !conditionalComment.test(rest)\n  ) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt; in plain text, be forgiving and treat it as text\x3c\/span\x3e\n    next = rest.indexOf(\x27\x26lt;\x27, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (next \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    textEnd \x2b= next\n    rest = html.slice(textEnd)\n  }\n  text = html.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, textEnd)\n  html = html.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, textEnd)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码的逻辑是如果文本截取完之后，剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 开头不符合标签的格式规则，那么肯定就是有没截取完的文本\x3c\/p\x3e\n\x3cp\x3e这个时候只需要循环把 \x3ccode\x3etextEnd\x3c\/code\x3e 累加，直到剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 符合标签的规则之后在一次性把 \x3ccode\x3etext\x3c\/code\x3e 从 \x3ccode\x3e模板字符串\x3c\/code\x3e 中截取出来就好了。\x3c\/p\x3e\n\x3cp\x3e继续上面的例子，当前剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 是这个样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e截取之后剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 是这个样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e被截取出来的文本是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;\n \x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22\n \x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e截取之后就需要对文本进行解析，不过在解析文本之前需要进行预处理，也就是先简单加工一下文本，vue 是这样做的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const children = currentParent.children\ntext = inPre || text.trim()\n  ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n  \/\/ only preserve whitespace if its not right after a starting tag\n  : preserveWhitespace \x26amp;\x26amp; children.length ? \x27 \x27 : \x27\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3econst children = currentParent.children\ntext = inPre || text.trim()\n  ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ only preserve whitespace if its not right after a starting tag\x3c\/span\x3e\n  : preserveWhitespace \x26amp;\x26amp; children.length ? \x27 \x27 : \x27\x27\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码的意思是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e如果文本不为空，判断父标签是不是script或style，\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果是则什么都不管，\x3c\/li\x3e\n\x3cli\x3e如果不是需要 \x3ccode\x3edecode\x3c\/code\x3e 一下编码，使用github上的 he 这个类库的 \x3ccode\x3edecodeHTML\x3c\/code\x3e 方法\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果文本为空，判断有没有兄弟节点，也就是 \x3ccode\x3eparent.children.length\x3c\/code\x3e 是不是为 0\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果大于0 返回 \x3ccode\x3e\x27 \x27\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e如果为 0 返回 \x3ccode\x3e\x27\x27\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e结果发现这一次的 text 正好命中最后的那个 \x3ccode\x3e\x27\x27\x3c\/code\x3e，所以这一次就什么都不用做继续下一轮解析就好\x3c\/p\x3e\n\x3cp\x3e继续上面的例子，现在的 \x3ccode\x3e模板字符串\x3c\/code\x3e 变是这个样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;p\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着解析 \x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e，解析流程和上面的 \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e 一样就不说了，直接继续：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x22{{\x22name\x22}}\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x22{{\x22name\x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过上面写的文本的截取方式这一次截取出来的文本是这个样子的 \x3ccode\x3e\x22\x22{{\x22name\x22}}\x22\x22\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e解析文本\x3c\/h3\x3e\n\x3cp\x3e其实解析文本节点并不难，只需要将文本节点 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3ecurrentParent.children.push(ast)\x3c\/code\x3e 就行了。\x3c\/p\x3e\n\x3cp\x3e但是带变量的文本和不带变量的纯文本是不同的处理方式。\x3c\/p\x3e\n\x3cp\x3e带变量的文本是指 \x3ccode\x3eHello \x22{{\x22 name \x22}}\x22\x3c\/code\x3e 这个 \x3ccode\x3ename\x3c\/code\x3e 就是变量。\x3c\/p\x3e\n\x3cp\x3e不带变量的文本是这样的 \x3ccode\x3eHello Berwin\x3c\/code\x3e 这种没有访问数据的纯文本。\x3c\/p\x3e\n\x3cp\x3e纯文本比较简单，直接将 文本节点的ast \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3eparent\x3c\/code\x3e 节点的 \x3ccode\x3echildren\x3c\/code\x3e 中就行了，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22children.push({\n  type: 3,\n  text: \x27我是纯文本\x27\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3echildren.push({\n  type: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n  text: \x27我是纯文本\x27\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而带变量的文本要多一个解析文本变量的操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const expression = parseText(text, delimiters) \/\/ 对变量解析 \x22{{\x22name\x22}}\x22 =\x3e _s(name)\nchildren.push({\n  type: 2,\n  expression,\n  text\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3econst expression = parseText(text, delimiters) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对变量解析 \x22{{\x22name\x22}}\x22 =\x26gt; _s(name)\x3c\/span\x3e\nchildren.push({\n  type: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n  expression,\n  text\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面例子中 \x3ccode\x3e\x22\x22{{\x22name\x22}}\x22\x22\x3c\/code\x3e 是一个带变量的文本，经过 \x3ccode\x3eparseText\x3c\/code\x3e 解析后 \x3ccode\x3eexpression\x3c\/code\x3e 是 \x3ccode\x3e_s(name)\x3c\/code\x3e，所以最后 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3ecurrentParent.children\x3c\/code\x3e 中的节点是这个样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  expression: \x26quot;_s(name)\x26quot;,\n  text: \x26quot;\x22{{\x22name\x22}}\x22\x26quot;,\n  type: 2\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e{\n  expression: \x3cspan class=\x22hljs-string\x22\x3e\x22_s(name)\x22\x3c\/span\x3e,\n  text: \x3cspan class=\x22hljs-string\x22\x3e\x22\x22{{\x22name\x22}}\x22\x22\x3c\/span\x3e,\n  type: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e结束标签的处理\x3c\/h3\x3e\n\x3cp\x3e现在文本解析完之后，剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 变成了这个样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/p\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;\/p\x26gt;\n\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一次还是用上面说的办法，\x3ccode\x3ehtml.indexOf(\x27\x26lt;\x27) === 0\x3c\/code\x3e，发现是 \x3ccode\x3e\x26lt;\x3c\/code\x3e 开头的，然后用正则去 \x3ccode\x3ematch\x3c\/code\x3e 发现符合 \x3ccode\x3e结束标签的格式\x3c\/code\x3e，把它截取出来。\x3c\/p\x3e\n\x3cp\x3e并且还要做一个处理是用当前标签名在 \x3ccode\x3estack\x3c\/code\x3e 从后往前找，将找到的 \x3ccode\x3estack\x3c\/code\x3e 中的位置往后的所有标签全部删除（意思是，已经解析到当前的结束标签，那么它的子集肯定都是解析过的，试想一下当前标签都关闭了，它的子集肯定也都关闭了，所以需要把当前标签位置往后从 \x3ccode\x3estack\x3c\/code\x3e中都清掉）\x3c\/p\x3e\n\x3cp\x3e结束标签不需要解析，只需要将 \x3ccode\x3estack\x3c\/code\x3e 中的当前标签删掉就好。\x3c\/p\x3e\n\x3cp\x3e虽然不用解析，但 \x3ccode\x3evue\x3c\/code\x3e 还是做了一个优化处理，\x3ccode\x3echildren\x3c\/code\x3e 中的最后一项如果是空格 \x3ccode\x3e\x22 \x22\x3c\/code\x3e，则删除最后这一项：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (lastNode \x26amp;\x26amp; lastNode.type === 3 \x26amp;\x26amp; lastNode.text === \x27 \x27 \x26amp;\x26amp; !inPre) {\n  element.children.pop()\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lastNode \x26amp;\x26amp; lastNode.type === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x26amp;\x26amp; lastNode.text === \x27 \x27 \x26amp;\x26amp; !inPre) {\n  element.children.pop()\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为最后这一项空格是没有用的，举个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e\n  \x3cli\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;ul\x26gt;\n  \x26lt;li\x26gt;\x26lt;\/li\x26gt;\n\x26lt;\/ul\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面例子中解析成 \x3ccode\x3eelement ASTs\x3c\/code\x3e之后 \x3ccode\x3eul\x3c\/code\x3e 的结束标签 \x3ccode\x3e\x26lt;\/ul\x26gt;\x3c\/code\x3e 和 \x3ccode\x3eli\x3c\/code\x3e 的结束标签 \x3ccode\x3e\x26lt;\/li\x26gt;\x3c\/code\x3e 之间有一个空格，这个空格也属于文本节点在 \x3ccode\x3eul\x3c\/code\x3e 的 \x3ccode\x3echildren\x3c\/code\x3e 中，这个空格是没有用的，把这个空格删掉每次渲染dom都会少渲染一个文本节点，可以节省一定的性能开销。\x3c\/p\x3e\n\x3cp\x3e现在剩余的 \x3ccode\x3e模板字符串\x3c\/code\x3e 已经不多了，是下面的样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后解析文本，就是一个其实就是一个空格的文本节点。\x3c\/p\x3e\n\x3cp\x3e然后再一次解析结束标签 \x3ccode\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解析完毕退出 \x3ccode\x3ewhile\x3c\/code\x3e 循环。\x3c\/p\x3e\n\x3cp\x3e解析完之后拿到的 \x3ccode\x3eelement ASTs\x3c\/code\x3e 就是文章开头写的那样。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结一下\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e其实这样一个模板解析器的原理不是特别难，主要就是两部分内容，一部分是 \x3ccode\x3e截取\x3c\/code\x3e 字符串，一部分是对截取之后的字符串做 \x3ccode\x3e解析\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e每截取一段标签的开头就 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3estack\x3c\/code\x3e中，解析到标签的结束就 \x3ccode\x3epop\x3c\/code\x3e 出来，当所有的字符串都截没了也就解析完了。\x3c\/p\x3e\n\x3cp\x3e上文中的例子是比较简单的，不涉及一些循环啊，什么的，注释的处理这些也都没有涉及到，但其实这篇文章中想表达的内容也不是来扣细节的，如果扣细节可能要写一本小书才够，一篇文章的字数可能只够把一个大体的逻辑给大家讲清楚，希望同学们见谅，如果对细节感兴趣可以在下面评论，咱们一起讨论共同学习进步~\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e优化器\x3c\/h2\x3e\n\x3cp\x3e优化器的目标是找出那些静态节点并打上标记，而静态节点指的是 \x3ccode\x3eDOM\x3c\/code\x3e 不需要发生变化的节点，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e我是静态节点，我不需要发生变化\x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;p\x26gt;我是静态节点，我不需要发生变化\x26lt;\/p\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e标记静态节点有两个好处：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e每次重新渲染的时候不需要为静态节点创建新节点\x3c\/li\x3e\n\x3cli\x3e在 Virtual DOM 中 patching 的过程可以被跳过\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e优化器的实现原理主要分两步：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e第一步：用递归的方式将所有节点添加 \x3ccode\x3estatic\x3c\/code\x3e 属性，标识是不是静态节点\x3c\/li\x3e\n\x3cli\x3e第二步：标记所有静态根节点\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e什么是静态根节点？ 答：子节点全是静态节点的节点就是静态根节点，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e\n  \x3cli\x3e我是静态节点，我不需要发生变化\x3c\/li\x3e\n  \x3cli\x3e我是静态节点2，我不需要发生变化\x3c\/li\x3e\n  \x3cli\x3e我是静态节点3，我不需要发生变化\x3c\/li\x3e\n\x3c\/ul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;ul\x26gt;\n  \x26lt;li\x26gt;我是静态节点，我不需要发生变化\x26lt;\/li\x26gt;\n  \x26lt;li\x26gt;我是静态节点\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e，我不需要发生变化\x26lt;\/li\x26gt;\n  \x26lt;li\x26gt;我是静态节点\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e，我不需要发生变化\x26lt;\/li\x26gt;\n\x26lt;\/ul\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eul 就是静态根节点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e如何将所有节点标记 \x3ccode\x3estatic\x3c\/code\x3e 属性？\x3c\/h3\x3e\n\x3cp\x3evue 判断一个节点是不是静态节点的做法其实并不难：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e先根据自身是不是静态节点做一个标记 \x3ccode\x3enode.static = isStatic(node)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e然后在循环 \x3ccode\x3echildren\x3c\/code\x3e，如果 \x3ccode\x3echildren\x3c\/code\x3e 中出现了哪怕一个节点不是静态节点，在将当前节点的标记修改成 \x3ccode\x3efalse\x3c\/code\x3e： \x3ccode\x3enode.static = false\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch4\x3e如何判断一个节点是不是静态节点？\x3c\/h4\x3e\n\x3cp\x3e也就是说 \x3ccode\x3eisStatic\x3c\/code\x3e 这个函数是如何判断静态节点的？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { \/\/ expression\n    return false\n  }\n  if (node.type === 3) { \/\/ text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings \x26amp;\x26amp; \/\/ no dynamic bindings\n    !node.if \x26amp;\x26amp; !node.for \x26amp;\x26amp; \/\/ not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) \x26amp;\x26amp; \/\/ not a built-in\n    isPlatformReservedTag(node.tag) \x26amp;\x26amp; \/\/ not a component\n    !isDirectChildOfTemplateFor(node) \x26amp;\x26amp;\n    Object.keys(node).every(isStaticKey)\n  ))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction isStatic (node: \x3cspan class=\x22hljs-type\x22\x3eASTNode\x3c\/span\x3e): boolean {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.type === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ expression\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.type === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ text\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!(node.pre || (\n    !node.hasBindings \x26amp;\x26amp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ no dynamic bindings\x3c\/span\x3e\n    !node.\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e \x26amp;\x26amp; !node.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not v-if or v-for or v-else\x3c\/span\x3e\n    !isBuiltInTag(node.tag) \x26amp;\x26amp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not a built-in\x3c\/span\x3e\n    isPlatformReservedTag(node.tag) \x26amp;\x26amp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not a component\x3c\/span\x3e\n    !isDirectChildOfTemplateFor(node) \x26amp;\x26amp;\n    \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.keys(node).every(isStaticKey)\n  ))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e先解释一下，在上文讲的解析器中将 \x3ccode\x3e模板字符串\x3c\/code\x3e 解析成 \x3ccode\x3eAST\x3c\/code\x3e 的时候，会根据不同的文本类型设置一个 \x3ccode\x3etype\x3c\/code\x3e：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3etype\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e1\x3c\/td\x3e\n\x3ctd\x3e元素节点\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e2\x3c\/td\x3e\n\x3ctd\x3e带变量的动态文本节点\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e3\x3c\/td\x3e\n\x3ctd\x3e不带变量的纯文本节点\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e所以上面 \x3ccode\x3eisStatic\x3c\/code\x3e 中的逻辑很明显，如果 \x3ccode\x3etype === 2\x3c\/code\x3e 那肯定不是 \x3ccode\x3e静态节点\x3c\/code\x3e 返回 \x3ccode\x3efalse\x3c\/code\x3e，如果 \x3ccode\x3etype === 3\x3c\/code\x3e 那就是静态节点，返回 \x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e那如果 \x3ccode\x3etype === 1\x3c\/code\x3e，就有点复杂了，元素节点判断是不是静态节点的条件很多，咱们先一个个看。\x3c\/p\x3e\n\x3cp\x3e首先如果 \x3ccode\x3enode.pre\x3c\/code\x3e 为 \x3ccode\x3etrue\x3c\/code\x3e 直接认为当前节点是静态节点，关于 \x3ccode\x3enode.pre\x3c\/code\x3e 是什么 \x3ca href=\x22https:\/\/vuejs.org\/v2\/api\/#v-pre\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e请狠狠的点击我\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e其次 \x3ccode\x3enode.hasBindings\x3c\/code\x3e 不能为 \x3ccode\x3etrue\x3c\/code\x3e。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enode.hasBindings\x3c\/code\x3e 属性是在解析器转换 \x3ccode\x3eAST\x3c\/code\x3e 时设置的，如果当前节点的 \x3ccode\x3eattrs\x3c\/code\x3e 中，有 \x3ccode\x3ev-\x3c\/code\x3e、\x3ccode\x3e@\x3c\/code\x3e、\x3ccode\x3e:\x3c\/code\x3e开头的 \x3ccode\x3eattr\x3c\/code\x3e，就会把 \x3ccode\x3enode.hasBindings\x3c\/code\x3e 设置为 \x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const dirRE = \/^v-|^@|^:\/\nif (dirRE.test(attr)) {\n  \/\/ mark element as dynamic\n  el.hasBindings = true\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3econst dirRE = \/^v-|^@|^:\/\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dirRE.test(attr)) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mark element as dynamic\x3c\/span\x3e\n  el.hasBindings = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e并且元素节点不能有 \x3ccode\x3eif\x3c\/code\x3e 和 \x3ccode\x3efor\x3c\/code\x3e属性。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enode.if\x3c\/code\x3e 和 \x3ccode\x3enode.for\x3c\/code\x3e 也是在解析器转换 \x3ccode\x3eAST\x3c\/code\x3e 时设置的。\x3c\/p\x3e\n\x3cp\x3e在解析的时候发现节点使用了 \x3ccode\x3ev-if\x3c\/code\x3e，就会在解析的时候给当前节点设置一个 \x3ccode\x3eif\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e就是说元素节点不能使用 \x3ccode\x3ev-if\x3c\/code\x3e \x3ccode\x3ev-for\x3c\/code\x3e \x3ccode\x3ev-else\x3c\/code\x3e 等指令。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e并且元素节点不能是 \x3ccode\x3eslot\x3c\/code\x3e 和 \x3ccode\x3ecomponent\x3c\/code\x3e。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e并且元素节点不能是组件。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cList\x3e\x3c\/List\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\x3cspan class=\x22hljs-type\x22\x3eList\x3c\/span\x3e\x26gt;\x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eList\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不能是上面这样的自定义组件\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e并且元素节点的父级节点不能是带 \x3ccode\x3ev-for\x3c\/code\x3e 的 \x3ccode\x3etemplate\x3c\/code\x3e，查看详情 \x3ca href=\x22https:\/\/vuejs.org\/v2\/guide\/list.html#v-for-on-a-lt-template-gt\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e请狠狠的点击我\x3c\/a\x3e。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e并且元素节点上不能出现额外的属性。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e额外的属性指的是不能出现 \x3ccode\x3etype\x3c\/code\x3e  \x3cbr\x3e\x3ccode\x3etag\x3c\/code\x3e \x3ccode\x3eattrsList\x3c\/code\x3e \x3ccode\x3eattrsMap\x3c\/code\x3e \x3ccode\x3eplain\x3c\/code\x3e \x3ccode\x3eparent\x3c\/code\x3e \x3ccode\x3echildren\x3c\/code\x3e \x3ccode\x3eattrs\x3c\/code\x3e \x3ccode\x3estaticClass\x3c\/code\x3e \x3ccode\x3estaticStyle\x3c\/code\x3e 这几个属性之外的其他属性，如果出现其他属性则认为当前节点不是静态节点。\x3c\/p\x3e\n\x3cp\x3e只有符合上面所有条件的节点才会被认为是静态节点。\x3c\/p\x3e\n\x3ch4\x3e如何标记所有节点？\x3c\/h4\x3e\n\x3cp\x3e上面讲如何判断单个节点是否是静态节点，\x3ccode\x3eAST\x3c\/code\x3e 是一棵树，我们如何把所有的节点都打上标记（\x3ccode\x3estatic\x3c\/code\x3e）呢？\x3c\/p\x3e\n\x3cp\x3e还有一个问题是，判断 \x3cstrong\x3e元素节点\x3c\/strong\x3e是不是\x3cstrong\x3e静态节点\x3c\/strong\x3e不能光看它自身是不是\x3cstrong\x3e静态节点\x3c\/strong\x3e，如果它的\x3cstrong\x3e子节点\x3c\/strong\x3e不是\x3cstrong\x3e静态节点\x3c\/strong\x3e，那就算它自身符合上面讲的\x3cstrong\x3e静态节点\x3c\/strong\x3e的条件，它也不是\x3cstrong\x3e静态节点\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e所以在 vue 中有这样一行代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let i = 0, l = node.children.length; i \x3c l; i\x2b\x2b) {\n  const child = node.children[i]\n  markStatic(child)\n  if (!child.static) {\n    node.static = false\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = node.children.length; i \x26lt; l; i\x2b\x2b) {\n  const child = node.children[i]\n  markStatic(child)\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!child.\x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e) {\n    node.\x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emarkStatic\x3c\/code\x3e 可以给节点标记，规则上面刚讲过，vue.js 通过循环 \x3ccode\x3echildren\x3c\/code\x3e 打标记，然后每个不同的子节点又会走相同的逻辑去循环它的 \x3ccode\x3echildren\x3c\/code\x3e 这样递归下来所有的节点都会被打上标记。\x3c\/p\x3e\n\x3cp\x3e然后在循环中判断，如果某个子节点不是 \x3cstrong\x3e静态节点\x3c\/strong\x3e，那么讲当前节点的标记改为 \x3ccode\x3efalse\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这样一圈下来之后 \x3ccode\x3eAST\x3c\/code\x3e 上的所有节点都被准确的打上了标记。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e如何标记静态根节点？\x3c\/h3\x3e\n\x3cp\x3e标记静态根节点其实也是递归的过程。\x3c\/p\x3e\n\x3cp\x3evue 中的实现大概是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    \/\/ For a node to qualify as a static root, it should have children that\n    \/\/ are not just static text. Otherwise the cost of hoisting out will\n    \/\/ outweigh the benefits and it\x27s better off to just always render it fresh.\n    if (node.static \x26amp;\x26amp; node.children.length \x26amp;\x26amp; !(\n      node.children.length === 1 \x26amp;\x26amp;\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i \x3c l; i\x2b\x2b) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction markStaticRoots (node: \x3cspan class=\x22hljs-type\x22\x3eASTNode\x3c\/span\x3e, isInFor: boolean) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.type === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ For a node to qualify as a static root, it should have children that\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ are not just static text. Otherwise the cost of hoisting out will\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ outweigh the benefits and it\x27s better off to just always render it fresh.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.\x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e \x26amp;\x26amp; node.children.length \x26amp;\x26amp; !(\n      node.children.length === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x26amp;\x26amp;\n      node.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].type === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n    )) {\n      node.staticRoot = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      node.staticRoot = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.children) {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = node.children.length; i \x26lt; l; i\x2b\x2b) {\n        markStaticRoots(node.children[i], isInFor || !!node.\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e)\n      }\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码其实就一个意思：\x3c\/p\x3e\n\x3cp\x3e当前节点是\x3cstrong\x3e静态节点\x3c\/strong\x3e，并且有\x3cstrong\x3e子节点\x3c\/strong\x3e，并且\x3cstrong\x3e子节点\x3c\/strong\x3e不是单个\x3cstrong\x3e静态文本节点\x3c\/strong\x3e这种情况会将当前节点标记为\x3cstrong\x3e根静态节点\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e额，，可能有点绕口，重新解释下。\x3c\/p\x3e\n\x3cp\x3e上面我们标记 \x3cstrong\x3e静态节点\x3c\/strong\x3e 的时候有一段逻辑是只有所有 \x3cstrong\x3e子节点\x3c\/strong\x3e 都是 \x3cstrong\x3e静态节点\x3c\/strong\x3e，当前节点才是真正的 \x3cstrong\x3e静态节点\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e所以这里我们如果发现一个节点是 \x3cstrong\x3e静态节点\x3c\/strong\x3e，那就能证明它的所有 \x3cstrong\x3e子节点\x3c\/strong\x3e 也都是静态节点，而我们要标记的是 \x3cstrong\x3e静态根节点\x3c\/strong\x3e，所以如果一个静态节点只包含了一个\x3cstrong\x3e文本节点\x3c\/strong\x3e那就不会被标记为 \x3cstrong\x3e静态根节点\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e其实这么做也是为了性能考虑，vue 在注释中也说了，如果把一个只包含静态文本的节点标记为根节点，那么它的成本会超过收益~\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结一下\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e整体逻辑其实就是递归 \x3ccode\x3eAST\x3c\/code\x3e 这颗树，然后将 \x3cstrong\x3e静态节点\x3c\/strong\x3e 和 \x3cstrong\x3e静态根节点\x3c\/strong\x3e 找到并打上标记。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e代码生成器\x3c\/h2\x3e\n\x3cp\x3e代码生成器的作用是使用 \x3ccode\x3eelement ASTs\x3c\/code\x3e 生成 \x3ccode\x3erender\x3c\/code\x3e 函数代码字符串。\x3c\/p\x3e\n\x3cp\x3e使用本文开头举的例子中的模板生成后的 \x3ccode\x3eAST\x3c\/code\x3e 来生成 \x3ccode\x3erender\x3c\/code\x3e 后是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  render: `with(this){return _c(\x27div\x27,[_c(\x27p\x27,[_v(_s(name))])])}`\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e{\n  render: `with(this){\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _c(\x27div\x27,[_c(\x27p\x27,[_v(_s(name))])])}`\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e格式化后是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22with(this){\n  return _c(\n    \x27div\x27,\n    [\n      _c(\n        \x27p\x27,\n        [\n          _v(_s(name))\n        ]\n      )\n    ]\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3ewith(this){\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _c(\n    \x27div\x27,\n    [\n      _c(\n        \x27p\x27,\n        [\n          _v(_s(name))\n        ]\n      )\n    ]\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成后的代码字符串中看到了有几个函数调用 \x3ccode\x3e_c\x3c\/code\x3e，\x3ccode\x3e_v\x3c\/code\x3e，\x3ccode\x3e_s\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e_c\x3c\/code\x3e 对应的是 \x3ccode\x3ecreateElement\x3c\/code\x3e，它的作用是创建一个元素。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e第一个参数是一个HTML标签名\x3c\/li\x3e\n\x3cli\x3e第二个参数是元素上使用的属性所对应的数据对象，可选项\x3c\/li\x3e\n\x3cli\x3e第三个参数是 \x3ccode\x3echildren\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e例如：\x3c\/p\x3e\n\x3cp\x3e一个简单的模板：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp title=\x26quot;Berwin\x26quot; @click=\x26quot;c\x26quot;\x3e1\x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;p title=\x3cspan class=\x22hljs-string\x22\x3e\x22Berwin\x22\x3c\/span\x3e @click=\x3cspan class=\x22hljs-string\x22\x3e\x22c\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x26lt;\/p\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成后的代码字符串是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22`with(this){return _c(\x27p\x27,{attrs:{\x26quot;title\x26quot;:\x26quot;Berwin\x26quot;},on:{\x26quot;click\x26quot;:c\x22}}\x22,[_v(\x26quot;1\x26quot;)])}`\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e`with(this){\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _c(\x27p\x27,{attrs:{\x3cspan class=\x22hljs-string\x22\x3e\x22title\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22Berwin\x22\x3c\/span\x3e},on:{\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e\x22}}\x22,[_v(\x3cspan class=\x22hljs-string\x22\x3e\x221\x22\x3c\/span\x3e)])}`\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e格式化后：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22with(this){\n  return _c(\n    \x27p\x27,\n    {\n      attrs:{\x26quot;title\x26quot;:\x26quot;Berwin\x26quot;},\n      on:{\x26quot;click\x26quot;:c}\n    },\n    [_v(\x26quot;1\x26quot;)]\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3ewith(this){\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _c(\n    \x27p\x27,\n    {\n      attrs:{\x3cspan class=\x22hljs-string\x22\x3e\x22title\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22Berwin\x22\x3c\/span\x3e},\n      on:{\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e}\n    },\n    [_v(\x3cspan class=\x22hljs-string\x22\x3e\x221\x22\x3c\/span\x3e)]\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于 \x3ccode\x3ecreateElement\x3c\/code\x3e 想了解更多\x3ca href=\x22https:\/\/vuejs.org\/v2\/guide\/render-function.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e请狠狠的点击我\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e_v\x3c\/code\x3e 的意思是创建一个文本节点。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e_s\x3c\/code\x3e 是返回参数中的字符串。\x3c\/p\x3e\n\x3cp\x3e代码生成器的总体逻辑其实就是使用 \x3ccode\x3eelement ASTs\x3c\/code\x3e 去递归，然后拼出这样的 \x3ccode\x3e_c(\x27div\x27,[_c(\x27p\x27,[_v(_s(name))])])\x3c\/code\x3e 字符串。\x3c\/p\x3e\n\x3cp\x3e那如何拼这个字符串呢？？\x3c\/p\x3e\n\x3cp\x3e请看下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function genElement (el: ASTElement, state: CodegenState) {\n  const data = el.plain ? undefined : genData(el, state)\n  const children = el.inlineTemplate ? null : genChildren(el, state, true)\n    \n  let code = `_c(\x27${el.tag}\x27${\n    data ? `,${data}` : \x27\x27 \/\/ data\n  }${\n    children ? `,${children}` : \x27\x27 \/\/ children\n  })`\n  \n  return code\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction genElement (el: \x3cspan class=\x22hljs-type\x22\x3eASTElement\x3c\/span\x3e, state: \x3cspan class=\x22hljs-type\x22\x3eCodegenState\x3c\/span\x3e) {\n  const data = el.plain ? undefined : genData(el, state)\n  const children = el.inlineTemplate ? null : genChildren(el, state, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n    \n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e code = `_c(\x27${el.tag}\x27${\n    data ? `,${data}` : \x27\x27 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ data\x3c\/span\x3e\n  }${\n    children ? `,${children}` : \x27\x27 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ children\x3c\/span\x3e\n  })`\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e code\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为 _c 的参数需要 \x3ccode\x3etagName\x3c\/code\x3e、\x3ccode\x3edata\x3c\/code\x3e 和 \x3ccode\x3echildren\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e所以上面这段代码的主要逻辑就是用 \x3ccode\x3egenData\x3c\/code\x3e 和 \x3ccode\x3egenChildren\x3c\/code\x3e 获取 \x3ccode\x3edata\x3c\/code\x3e 和 \x3ccode\x3echildren\x3c\/code\x3e，然后拼到 \x3ccode\x3e_c\x3c\/code\x3e 中去，拼完后把拼好的 \x3ccode\x3e\x22_c(tagName, data, children)\x22\x3c\/code\x3e 返回。\x3c\/p\x3e\n\x3cp\x3e所以我们现在比较关心的两个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3edata 如何生成的（genData 的实现逻辑）？\x3c\/li\x3e\n\x3cli\x3echildren 如何生成的（genChildren 的实现逻辑）？\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们先看 \x3ccode\x3egenData\x3c\/code\x3e 是怎样的实现逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function genData (el: ASTElement, state: CodegenState): string {\n  let data = \x27{\x27\n  \/\/ key\n  if (el.key) {\n    data \x2b= `key:${el.key},`\n  }\n  \/\/ ref\n  if (el.ref) {\n    data \x2b= `ref:${el.ref},`\n  }\n  if (el.refInFor) {\n    data \x2b= `refInFor:true,`\n  }\n  \/\/ pre\n  if (el.pre) {\n    data \x2b= `pre:true,`\n  }\n  \/\/ ... 类似的还有很多种情况\n  data = data.replace(\/,$\/, \x27\x27) \x2b \x27}\x27\n  return data\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction genData (el: \x3cspan class=\x22hljs-type\x22\x3eASTElement\x3c\/span\x3e, state: \x3cspan class=\x22hljs-type\x22\x3eCodegenState\x3c\/span\x3e): string {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = \x27{\x27\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ key\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (el.key) {\n    data \x2b= `key:${el.key},`\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ref\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (el.ref) {\n    data \x2b= `ref:${el.ref},`\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (el.refInFor) {\n    data \x2b= `refInFor:\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,`\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ pre\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (el.pre) {\n    data \x2b= `pre:\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,`\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 类似的还有很多种情况\x3c\/span\x3e\n  data = data.replace(\/,$\/, \x27\x27) \x2b \x27}\x27\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e data\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，就是根据 \x3ccode\x3eAST\x3c\/code\x3e 上当前节点上都有什么属性，然后针对不同的属性做一些不同的处理，最后拼出一个字符串~\x3c\/p\x3e\n\x3cp\x3e然后我们在看看 \x3ccode\x3egenChildren\x3c\/code\x3e 是怎样的实现的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function genChildren (\n  el: ASTElement,\n  state: CodegenState\n): string | void {\n  const children = el.children\n  if (children.length) {\n    return `[${children.map(c =\x3e genNode(c, state)).join(\x27,\x27)}]`\n  }\n}\n\nfunction genNode (node: ASTNode, state: CodegenState): string {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 \x26amp;\x26amp; node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction genChildren (\n  el: \x3cspan class=\x22hljs-type\x22\x3eASTElement\x3c\/span\x3e,\n  state: \x3cspan class=\x22hljs-type\x22\x3eCodegenState\x3c\/span\x3e\n): string | void {\n  const children = el.children\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children.length) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e `[${children.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e =\x26gt; genNode(\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e, state)).\x3cspan class=\x22hljs-built_in\x22\x3ejoin\x3c\/span\x3e(\x27,\x27)}]`\n  }\n}\n\nfunction genNode (node: \x3cspan class=\x22hljs-type\x22\x3eASTNode\x3c\/span\x3e, state: \x3cspan class=\x22hljs-type\x22\x3eCodegenState\x3c\/span\x3e): string {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.type === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e genElement(node, state)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.type === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x26amp;\x26amp; node.isComment) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e genComment(node)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e genText(node)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面代码中可以看出，生成 \x3ccode\x3echildren\x3c\/code\x3e 的过程其实就是循环 \x3ccode\x3eAST\x3c\/code\x3e 中当前节点的 \x3ccode\x3echildren\x3c\/code\x3e，然后把每一项在重新按不同的节点类型去执行 \x3ccode\x3egenElement\x3c\/code\x3e \x3ccode\x3egenComment\x3c\/code\x3e \x3ccode\x3egenText\x3c\/code\x3e。如果 \x3ccode\x3egenElement\x3c\/code\x3e 中又有 \x3ccode\x3echildren\x3c\/code\x3e 在循环生成，如此反复递归，最后一圈跑完之后能拿到一个完整的 \x3ccode\x3erender\x3c\/code\x3e 函数代码字符串，就是类似下面这个样子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;_c(\x27div\x27,[_c(\x27p\x27,[_v(_s(name))])])\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22_c(\x27div\x27,[_c(\x27p\x27,[_v(_s(name))])])\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后把生成的 \x3ccode\x3ecode\x3c\/code\x3e 装到 \x3ccode\x3ewith\x3c\/code\x3e 里。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function generate (\n  ast: ASTElement | void,\n  options: CompilerOptions\n): CodegenResult {\n  const state = new CodegenState(options)\n  \/\/ 如果ast为空，则创建一个空div\n  const code = ast ? genElement(ast, state) : \x27_c(\x26quot;div\x26quot;)\x27\n  return {\n    render: `with(this){return ${code\x22}}\x22`\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3eexport function generate (\n  ast: \x3cspan class=\x22hljs-type\x22\x3eASTElement\x3c\/span\x3e | void,\n  options: \x3cspan class=\x22hljs-type\x22\x3eCompilerOptions\x3c\/span\x3e\n): \x3cspan class=\x22hljs-type\x22\x3eCodegenResult\x3c\/span\x3e {\n  const state = new \x3cspan class=\x22hljs-type\x22\x3eCodegenState\x3c\/span\x3e(options)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果ast为空，则创建一个空div\x3c\/span\x3e\n  const code = ast ? genElement(ast, state) : \x27_c(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e)\x27\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    render: `with(this){\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ${code\x22}}\x22`\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于代码生成器的部分到这里就说完了，其实源码中远不止这么简单，很多细节我都没有去说，我只说了一个大体的流程，对具体细节感兴趣的同学可以自己去看源码了解详情。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e本篇文章我们说了 vue 对模板编译的整体流程分为三个部分：解析器（parser），优化器（optimizer）和代码生成器（code generator）。\x3c\/p\x3e\n\x3cp\x3e解析器（parser）的作用是将 \x3ccode\x3e模板字符串\x3c\/code\x3e 转换成 \x3ccode\x3eelement ASTs\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e优化器（optimizer）的作用是找出那些静态节点和静态根节点并打上标记。\x3c\/p\x3e\n\x3cp\x3e代码生成器（code generator）的作用是使用 \x3ccode\x3eelement ASTs\x3c\/code\x3e 生成 render函数代码（generate render function code from element ASTs）。\x3c\/p\x3e\n\x3cp\x3e用一张图来表示：\x3c\/p\x3e\n\x3cp\x3e[图片上传失败...(image-4ad47f-1521111234756)]\x3c\/p\x3e\n\x3cp\x3e解析器（parser）的原理是一小段一小段的去截取字符串，然后维护一个 \x3ccode\x3estack\x3c\/code\x3e 用来保存DOM深度，每截取到一段标签的开始就 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3estack\x3c\/code\x3e 中，当所有字符串都截取完之后也就解析出了一个完整的 \x3ccode\x3eAST\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e优化器（optimizer）的原理是用递归的方式将所有节点打标记，表示是否是一个 \x3ccode\x3e静态节点\x3c\/code\x3e，然后再次递归一遍把 \x3ccode\x3e静态根节点\x3c\/code\x3e 也标记出来。\x3c\/p\x3e\n\x3cp\x3e代码生成器（code generator）的原理也是通过递归去拼一个函数执行代码的字符串，递归的过程根据不同的节点类型调用不同的生成方法，如果发现是一颗元素节点就拼一个 \x3ccode\x3e_c(tagName, data, children)\x3c\/code\x3e 的函数调用字符串，然后 \x3ccode\x3edata\x3c\/code\x3e 和 \x3ccode\x3echildren\x3c\/code\x3e 也是使用 \x3ccode\x3eAST\x3c\/code\x3e 中的属性去拼字符串。\x3c\/p\x3e\n\x3cp\x3e如果 \x3ccode\x3echildren\x3c\/code\x3e 中还有 \x3ccode\x3echildren\x3c\/code\x3e 则递归去拼。\x3c\/p\x3e\n\x3cp\x3e最后拼出一个完整的 \x3ccode\x3erender\x3c\/code\x3e 函数代码。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue 模板编译原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013763590">https://segmentfault.com/a/1190000013763590</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3tmjy8mnjax/" target="_blank">https://alili.tech/archive/3tmjy8mnjax/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>