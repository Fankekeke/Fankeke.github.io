<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="jQuery 效率提升建议"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>jQuery 效率提升建议 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/40kocp3tsaf/",
				"appid": "1613049289050283", 
				"title": "jQuery 效率提升建议 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/w0a2a335zdm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/exjty65028/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&text=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&text=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&title=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&is_video=false&description=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&title=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&title=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&title=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f40kocp3tsaf%2f&title=jQuery%20%e6%95%88%e7%8e%87%e6%8f%90%e5%8d%87%e5%bb%ba%e8%ae%ae"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">jQuery 效率提升建议</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3ejQuery简洁通用的方法集把编码者从繁重的工作中解脱出来，也拉低了进入javascript的门槛，初学者对浏览器兼容性一无所知的情况下，几行代码就可以写出超炫的特效。网上有一篇文章转载比较泛滥，已经不知道原文作者了，里面针对jQuery效率提升建议非常科学，现在重新组织里面的内容并转载。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1.使用最新版本的jQuery\x3c\/h2\x3e\n\x3cp\x3ejQuery的版本更新很快，你应该总是使用最新的版本。因为新版本会改进性能，还有很多新功能。 下面就来看看，不同版本的jQuery性能差异有多大。这里是三条最常见的jQuery选择语句：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x27.elem\x27)\n$(\x27.elem\x27, context)\ncontext.find(\x27.elem\x27)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27.elem\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27.elem\x27\x3c\/span\x3e, context)\ncontext.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.elem\x27\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们用1.4.2、1.4.4、1.6.2三个版本的jQuery测试，看看浏览器在1秒内能够执行多少次。结果如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVX36N?w=555\x26amp;h=299\x22 src=\x22https:\/\/static.alili.tech\/img\/bVX36N?w=555\x26amp;h=299\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，1.6.2版本的运行次数，远远超过两个老版本。尤其是第一条语句，性能有数倍的提高。其他语句的测试，比如\x3ccode\x3e.attr(“value”)\x3c\/code\x3e和\x3ccode\x3e.val()\x3c\/code\x3e，也是新版本的jQuery表现好于老版本。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2.正确使用选择器\x3c\/h2\x3e\n\x3cp\x3e在jquery中，你可以用多种选择器，选择同一个网页元素。每种选择器的性能是不一样的，你应该了解它们的性能差异。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e最快的选择器：id选择器和元素标签选择器\x3cp\x3e举例来说，下面的语句性能最佳：\x3cbr\x3e\x3ccode\x3e$(\x27#id\x27)\x3c\/code\x3e\x3cbr\x3e\x3ccode\x3e$(\x27form\x27)\x3c\/code\x3e\x3cbr\x3e\x3ccode\x3e$(\x27input\x27)\x3c\/code\x3e\x3cbr\x3e遇到这些选择器的时候，jQuery内部会自动调用浏览器的原生方法（比如\x3ccode\x3egetElementById()\x3c\/code\x3e），所以它们的执行速度快。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e较慢的选择器：class选择器\x3cbr\x3e\x3ccode\x3e$(\x27.className\x27)\x3c\/code\x3e的性能，取决于不同的浏览器。Firefox、Safari、Chrome、Opera浏览器，都有原生方法\x3ccode\x3egetElementByClassName()\x3c\/code\x3e，所以速度并不慢。但是，IE5-IE8都没有部署这个方法，所以这个选择器在IE中会相当慢，jQuery历次更新对IE8之前的版本来说是没有用处的。\x3c\/li\x3e\n\x3cli\x3e最慢的选择器：伪类选择器和属性选择器\x3cp\x3e先来看例子。找出网页中所有的隐藏元素，就要用到伪类选择器：\x3cbr\x3e\x3ccode\x3e$(\x27:hidden\x27)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e属性选择器的例子则是：\x3cbr\x3e\x3ccode\x3e$(\x27[attribute=value]\x27)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这两种语句是最慢的，因为浏览器没有针对它们的原生方法。但是，一些浏览器的新版本，增加了\x3ccode\x3equerySelector()\x3c\/code\x3e和\x3ccode\x3equerySelectorAll()\x3c\/code\x3e方法，因此会使这类选择器的性能有大幅提高。  \x3c\/p\x3e\n\x3cp\x3e最后是不同选择器的性能比较图。  \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVX366?w=461\x26amp;h=258\x22 src=\x22https:\/\/static.alili.tech\/img\/bVX366?w=461\x26amp;h=258\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，ID选择器遥遥领先，然后是标签选择器，第三是Class选择器，其他选择器都非常慢。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3.理解子元素和父元素的关系\x3c\/h2\x3e\n\x3cp\x3e下面六个选择器，都是从父元素中选择子元素。你知道哪个速度最快，哪个速度最慢吗？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x27.child\x27, $parent)\n$parent.find(\x27.child\x27)\n$parent.children(\x27.child\x27)\n$(\x27#parent \x3e .child\x27)\n$(\x27#parent .child\x27)\n$(\x27.child\x27, $(\x27#parent\x27))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27.child\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-variable\x22\x3e$parent\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$parent\x3c\/span\x3e.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.child\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$parent\x3c\/span\x3e.children(\x3cspan class=\x22hljs-string\x22\x3e\x27.child\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27#parent \x26gt; .child\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27#parent .child\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27.child\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-variable\x22\x3e$(\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27#parent\x27\x3c\/span\x3e))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们一句句来看。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3e$(\x27.child\x27, $parent)\x3c\/code\x3e\x3cbr\x3e这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。jQuery会自动把这条语句转成\x3ccode\x3e$.parent.find(\x27child\x27)\x3c\/code\x3e，这会导致一定的性能损失。它比最快的形式慢了5%-10%。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$parent.find(\x27.child\x27)\x3c\/code\x3e\x3cbr\x3e这条是最快的语句。\x3ccode\x3e.find()\x3c\/code\x3e方法会调用浏览器的原生方法（\x3ccode\x3egetElementById\x3c\/code\x3e，\x3ccode\x3egetElementByName\x3c\/code\x3e，\x3ccode\x3egetElementByTagName\x3c\/code\x3e等等），所以速度较快。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$parent.children(\x27.child\x27)\x3c\/code\x3e\x3cbr\x3e这条语句在jQuery内部，会使用\x3ccode\x3e$.sibling()\x3c\/code\x3e和javascript的\x3ccode\x3enextSibling()\x3c\/code\x3e方法，一个个遍历节点。它比最快的形式大约慢50%。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$(\x27#parent \x26gt; .child\x27)\x3c\/code\x3e\x3cbr\x3ejQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选\x3ccode\x3e.child\x3c\/code\x3e，然后再一个个过滤出父元素\x3ccode\x3e#parent\x3c\/code\x3e，这导致它比最快的形式大约慢70%。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$(\x27#parent .child\x27)\x3c\/code\x3e\x3cbr\x3e这条语句与上一条是同样的情况。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$(\x27.child\x27, $(\x27#parent\x27))\x3c\/code\x3e\x3cbr\x3ejQuery内部会将这条语句转成\x3ccode\x3e$(\x27#parent\x27).find(\x27.child\x27)\x3c\/code\x3e，比最快的形式慢了23%。所以，最佳选择是\x3ccode\x3e$parent.find(\x27.child\x27)\x3c\/code\x3e。而且，由于\x3ccode\x3e$parent\x3c\/code\x3e往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e4.不要过度使用jQuery\x3c\/h2\x3e\n\x3cp\x3ejQuery速度再快，也无法与原生的javascript方法相比。所以有原生方法可以使用的场合，尽量避免使用jQuery。\x3cbr\x3e请看下面的例子，为a元素绑定一个处理点击事件的函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x27a\x27).click(function(){\n    alert($(this).attr(\x27id\x27));\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e$(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e).click(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    alert($(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).attr(\x3cspan class=\x22hljs-string\x22\x3e\x27id\x27\x3c\/span\x3e));\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码的意思是，点击a元素后，弹出该元素的id属性。为了获取这个属性，必须连续两次调用jQuery，第一次是\x3ccode\x3e$(this)\x3c\/code\x3e，第二次是\x3ccode\x3eattr(\x27id\x27)\x3c\/code\x3e。\x3cbr\x3e事实上，这种处理完全不必要。更正确的写法是，直接采用javascript原生方法调用\x3ccode\x3ethis.id\x3c\/code\x3e，根据测试，\x3ccode\x3ethis.id\x3c\/code\x3e的速度比\x3ccode\x3e$(this).attr(\x27id\x27)\x3c\/code\x3e快了20多倍。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e5.做好缓存\x3c\/h2\x3e\n\x3cp\x3e选中某一个网页元素，是开销很大的步骤。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。 比如，下面这样的写法就是糟糕的写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22jQuery(\x27#top\x27).find(\x27p.classA\x27);\njQuery(\x27#top\x27).find(\x27p.classB\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ejQuery\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27#top\x27\x3c\/span\x3e)\x3cspan class=\x22hljs-selector-class\x22\x3e.find\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27p.classA\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-selector-tag\x22\x3ejQuery\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27#top\x27\x3c\/span\x3e)\x3cspan class=\x22hljs-selector-class\x22\x3e.find\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27p.classB\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更好的写法是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var cached = jQuery(\x27#top\x27);\ncached.find(\x27p.classA\x27);\ncached.find(\x27p.classB\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3evar cached = jQuery(\x3cspan class=\x22hljs-string\x22\x3e\x27#top\x27\x3c\/span\x3e);\ncached.\x3cspan class=\x22hljs-built_in\x22\x3efind\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27p.classA\x27\x3c\/span\x3e);\ncached.\x3cspan class=\x22hljs-built_in\x22\x3efind\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27p.classB\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据测试，缓存比不缓存，快了2-3倍。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e6.使用链式写法\x3c\/h2\x3e\n\x3cp\x3ejQuery的一大特点，就是允许使用链式写法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e$(\x27div\x27).find(\x27h3\x27).eq(2).html(\x27Hello\x27);\x3c\/code\x3e\x3cbr\x3e采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。根据测试，链式写法比（不使用缓存的）非链式写法，大约快了25%。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e7.事件的委托处理（EventDelegation）\x3c\/h2\x3e\n\x3cp\x3ejavascript的事件模型，采用”冒泡”模式，也就是说，子元素的事件会逐级向上”冒泡”，成为父元素的事件。\x3cbr\x3e利用这一点，可以大大简化事件的绑定。比如，有一个表格（table元素），里面有100个格子（td元素），现在要求在每个格子上面绑定一个点击事件（click），请问是否需要将下面的命令执行100次？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x26quot;td\x26quot;).bind(\x26quot;click\x26quot;, function(){\n    $(this).toggleClass(\x26quot;click\x26quot;);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e$(\x3cspan class=\x22hljs-string\x22\x3e\x22td\x22\x3c\/span\x3e).bind(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).toggleClass(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e回答是不需要，我们只要把这个事件绑定在table元素上面就可以了，因为td元素发生点击事件之后，这个事件会”冒泡”到父元素table上面，从而被监听到。\x3cbr\x3e因此，这个事件只需要在父元素绑定1次即可，而不需要在子元素上绑定100次，从而大大提高性能。这就叫事件的”委托处理”，也就是子元素”委托”父元素处理这个事件。\x3cbr\x3e具体的写法有两种。第一种是采用\x3ccode\x3e.delegate()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x26quot;table\x26quot;).delegate(\x26quot;td\x26quot;,\x26quot;click\x26quot;, function(){\n    $(this).toggleClass(\x26quot;click\x26quot;);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e$(\x3cspan class=\x22hljs-string\x22\x3e\x22table\x22\x3c\/span\x3e).delegate(\x3cspan class=\x22hljs-string\x22\x3e\x22td\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).toggleClass(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二种是采用\x3ccode\x3e.live()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x26quot;table\x26quot;).each(function(){\n    $(\x26quot;td\x26quot;, this).live(\x26quot;click\x26quot;,function(){\n        $(this).toggleClass(\x26quot;click\x26quot;);\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e$(\x3cspan class=\x22hljs-string\x22\x3e\x22table\x22\x3c\/span\x3e).each(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x22td\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).live(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).toggleClass(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e);\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这两种写法基本等价。唯一的区别在于，\x3ccode\x3e.delegate()\x3c\/code\x3e是当事件冒泡到指定的父元素时触发，\x3ccode\x3e.live()\x3c\/code\x3e则是当事件冒泡到文档的根元素后触发，因此\x3ccode\x3e.delegate()\x3c\/code\x3e比\x3ccode\x3e.live()\x3c\/code\x3e稍快一点。此外，这两种方法相比传统的\x3ccode\x3e.bind()\x3c\/code\x3e方法还有一个好处，那就是对动态插入的元素也有效，.bind()只对已经存在的DOM元素有效，对动态插入的元素无效。\x3cbr\x3e根据测试，委托处理比不委托处理，快了几十倍。在委托处理的情况下，\x3ccode\x3e.delegate()\x3c\/code\x3e又比\x3ccode\x3e.live()\x3c\/code\x3e大约快26%。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e8.少改动DOM结构\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e改动DOM结构开销很大，因此不要频繁使用\x3ccode\x3e.append()\x3c\/code\x3e、\x3ccode\x3e.insertBefore()\x3c\/code\x3e和\x3ccode\x3e.insetAfter()\x3c\/code\x3e这样的方法。\x3cbr\x3e如果要插入多个元素，就先把它们合并，然后再一次性插入。根据测试，合并插入比不合并插入，快了将近10倍。\x3c\/li\x3e\n\x3cli\x3e如果你要对一个DOM元素进行大量处理，应该先用\x3ccode\x3e.detach()\x3c\/code\x3e方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据测试，使用\x3ccode\x3e.detach()\x3c\/code\x3e方法比不使用时，快了60%。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果你要在DOM元素上储存数据，不要写成下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var elem = $(\x27#elem\x27);\nelem.data(key,value);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e = $(\x27#\x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e\x27);\n\x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e.data(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e,value);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而要写成\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var elem = $(\x27#elem\x27);\n$.data(elem,key,value);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e = $(\x27#\x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e\x27);\n$.data(\x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e,value);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据测试， 后一种写法要比前一种写法，快了将近10倍。因为\x3ccode\x3eelem.data()\x3c\/code\x3e方法是定义在jQuery函数的prototype对象上面的， 而\x3ccode\x3e$.data()\x3c\/code\x3e方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。（此处可以参阅下面第10点。）\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e9.正确处理循环\x3c\/h2\x3e\n\x3cp\x3e循环总是一种比较耗时的操作，如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。\x3cbr\x3ejavascript原生循环方法for和while，要比jQuery的\x3ccode\x3e.each()\x3c\/code\x3e方法快，应该优先使用原生方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e10.尽量少生成jQuery对象\x3c\/h2\x3e\n\x3cp\x3e每当你使用一次选择器（比如\x3ccode\x3e$(\x27#id\x27)\x3c\/code\x3e），就会生成一个jQuery对象。jQuery对象是一个很庞大的对象，带有很多属性和方法，会占用不少资源。所以，尽量少生成jQuery对象。\x3cbr\x3e举例来说，许多jQuery方法都有两个版本，一个是供jQuery对象使用的版本，另一个是供jQuery函数使用的版本。下面两个例子，都是取出一个元素的文本，使用的都是\x3ccode\x3etext()\x3c\/code\x3e方法。你既可以使用针对jQuery对象的版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var $text = $(\x26quot;#text\x26quot;);\nvar $ts = $text.text();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e $text = $(\x3cspan class=\x22hljs-string\x22\x3e\x22#text\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e $ts = $text.text();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也可以使用针对jQuery函数的版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var $text = $(\x26quot;#text\x26quot;);\nvar $ts = $.text($text);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode\x3evar $text = $(\x3cspan class=\x22hljs-string\x22\x3e\x22#text\x22\x3c\/span\x3e);\nvar $ts = $.\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e($text);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于后一种针对jquery函数的版本不通过jQuery对象操作，所以相对开销较小，速度比较快。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e11.小结\x3c\/h2\x3e\n\x3cp\x3ejQuery对象方法和自身函数运行速度我进行了一下对比，分别测试了文章中提到的text和data，text测试结果不是很明显，\x3ccode\x3e$.text\x3c\/code\x3e比对象方法text略占上风。对象data由于会对dom变更，速度会远慢于jQuery函数data。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>jQuery 效率提升建议</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011893165">https://segmentfault.com/a/1190000011893165</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/40kocp3tsaf/" target="_blank">https://alili.tech/archive/40kocp3tsaf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>