<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript引擎基础：优化原型"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript引擎基础：优化原型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/44173d64/",
				"appid": "1613049289050283", 
				"title": "JavaScript引擎基础：优化原型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/db5efcc5/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/a5ceba90/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&text=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&text=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&title=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&is_video=false&description=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f44173d64%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&title=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&title=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&title=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f44173d64%2f&title=JavaScript%e5%bc%95%e6%93%8e%e5%9f%ba%e7%a1%80%ef%bc%9a%e4%bc%98%e5%8c%96%e5%8e%9f%e5%9e%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript引擎基础：优化原型</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e本文对所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎(\x3ca href=\x22https:\/\/twitter.com\/v8js\x22\x3ehttps:\/\/twitter.com\/v8js)\x3c\/a\x3e。作为一名 JavaScript 开发者，深入了解 JavaScript 引擎是如何工作的将有助于你了解自己所写代码的性能特征。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/mathiasbynens.be\/notes\/shapes-ics\x22\x3e前一篇\x3c\/a\x3e文章中，我们讨论了 JavaScript 引擎是如何通过 Shapes 和 Inline Caches 来优化访问对象与数组的。本文将介绍引擎在优化流程中的一些权衡与取舍，并对其在优化原型属性访问方面的优化加速工作进行介绍。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e .如果你倾向看视频演讲，请移步 \x3ca href=\x22https:\/\/www.youtube.com\/watch?v=IFWulQnM5E0\x22\x3eYouTube\x3c\/a\x3e 查看更多。\x3c\/p\x3e\n\x3ch2\x3e优化层级与执行效率的取舍\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/mathiasbynens.be\/notes\/shapes-ics\x22\x3e前一篇文章\x3c\/a\x3e 讨论了现代 JavaScript 引擎通用的工作流程：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s2.ssl.qhres.com\/static\/4b3250c77560ffe9.svg\x22 alt=\x22To execute JavaScript, engines use an interpreter and one or more optimization tiers.\x22\x3e\x3c\/p\x3e\n\x3cp\x3e我们也指出，尽管从高级抽象层面来看，引擎之间的处理流程都很相似，但他们在优化流程上通常都存在差异。为什么呢？为什么有些引擎的优化层级会比其他引擎多一些？事实证明，在快速获取可运行的代码与花费更多时间获得最优运行性能的代码之间存在一些取舍与平衡点。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s0.ssl.qhres.com\/static\/6574f46dd24b2af1.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e解释器可以快速生成字节码，但字节码通常效率不高。 相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码。\x3c\/p\x3e\n\x3cp\x3e这正是 V8 在使用的模型。它的解释器叫 Ignition，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s2.ssl.qhres.com\/static\/7fbc0b3140720fe0.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e我们往往需要在启动延迟与执行速度之间做出一些取舍，而这便是一些 JavaScript 引擎决定是否在流程中加入优化层的原因所在。例如，SpiderMonkey 在解释器和完整的 IonMonkey 优化编译器之间添加了一个 Baseline 层：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s3.ssl.qhres.com\/static\/09c5c0245e6d11e3.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e解释器可以快速生成字节码，但字节码执行起来相对较慢。Baseline 生成代码需要花费更长的时间，但能提供更好的运行时性能。最后，IonMonkey 优化编译器花费最长时间来生成机器码，但该代码运行起来非常高效。\x3c\/p\x3e\n\x3cp\x3e让我们通过一个具体的例子，看看不同引擎中的优化流程都有哪些差异。这是一些在循环中会经常出现的代码。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nimrod\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eresult\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e4242424242\x3c\/span\x3e; \x2b\x2bi) {\n    \x3cspan class=\x22hljs-literal\x22\x3eresult\x3c\/span\x3e \x2b= i;\n}\nconsole.log(\x3cspan class=\x22hljs-literal\x22\x3eresult\x3c\/span\x3e);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eV8开始在 Ignition 解释器中运行字节码。从某些方面来看，代码是否足够 hot 由引擎决定，引擎还负责调度 TurboFan 前端，它是 TurboFan 中负责处理集成分析数据和构建代码在机器层面表示的一部分。这部分结果之后会被发送到另一个线程上的 TurboFan 优化器被进一步优化。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s1.ssl.qhres.com\/static\/dffba67a00a752da.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e当优化器运行时，V8 会继续在 Ignition 中执行字节码。 当优化器处理完成后，我们获得可执行的机器码，执行流程便会继续下去\x3c\/p\x3e\n\x3cp\x3eSpiderMonkey 引擎也开始在解释器中运行字节码。但它有一个额外的 Baseline 层，这意味着比较 hot 的代码会首先被发送到 Baseline。 Baseline 编译器在主线程上生成 Baseline 代码，并在完成后继续后面的执行。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s4.ssl.qhres.com\/static\/6c6f54513e64a658.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e如果 Baseline 代码运行了一段时间，SpiderMonkey 最终会激活 IonMonkey 前端，并启动优化器 - 这与 V8 非常相似。当 IonMonkey 进行优化时，代码在 Baseline 中会一直运行。当优化器处理完成后，被执行的是优化后的代码而不是 Baseline 代码。\x3c\/p\x3e\n\x3cp\x3eChakra 的架构与 SpiderMonkey 非常相似，但 Chakra 尝试通过并行处理更多内容来避免阻塞主线程。Chakra 不在主线程上运行编译器，而是将不同编译器可能需要的字节码和分析数据复制出来，将其发送到一个专用的编译器进程。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s2.ssl.qhres.com\/static\/35f20da7a2fcc4fd.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e当代码准备就绪，引擎便开始运行 SimpleJIT 代码而不是字节码。 对于 FullJIT 来说流程同样如此。这种方法的好处是，与运行完整的编译器（前端）相比，复制所产生的中断时间通常要短得多。但其缺点在于这种启发式复制可能会遗漏某些优化所需的某些信息，因此它在一定程度上是用代码质量来换时间的消耗。\x3c\/p\x3e\n\x3cp\x3e在 JavaScriptCore 中，所有优化编译器都与主 JavaScript 执行完全并发运行；根本没有复制阶段！相反，主线程仅仅是触发了另一个线程上的编译作业。然后，编译器使用复杂的加锁方式从主线程中获取到要访问的分析数据。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s4.ssl.qhres.com\/static\/3b24c6d64b3199eb.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e这种方法的优点在于它减少了主线程上由 JavaScript 优化引起的抖动。 缺点是它需要处理复杂的多线程问题并为各种操作付出一些加锁的成本。\x3c\/p\x3e\n\x3cp\x3e我们已经讨论过在使用解释器快速生成代码或使用优化编译器生成可高效执行代码之间的一些权衡。但还有另一个权衡：内存使用！为了说明这一点，来看一个简单的两数相加 JvaScript 函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dockerfile\x22\x3efunction \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e(x, y) {\n\x3c\/span\x3e    return x \x2b y;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e(1, 2);\n\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这是我们使用 V8 中的 Ignition 解释器为 add 函数生成的字节码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dockerfile\x22\x3eStackCheck\nLdar a1\n\x3cspan class=\x22hljs-keyword\x22\x3eAdd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e a0, [0]\n\x3c\/span\x3eReturn\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不要在意这些字节码 ——你不需要了解细节。关键在于它只是四条指令！\x3c\/p\x3e\n\x3cp\x3e当代码变得 hot，TurboFan 便会开始处理以生成如下高度优化的机器码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs x86asm\x22\x3eleaq \x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e,[\x3cspan class=\x22hljs-built_in\x22\x3erip\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0x0\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e,[\x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e-\x3cspan class=\x22hljs-number\x22\x3e0x37\x3c\/span\x3e]\ntestb [\x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0xf\x3c\/span\x3e],\x3cspan class=\x22hljs-number\x22\x3e0x1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ejnz\x3c\/span\x3e CompileLazyDeoptimizedCode\n\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3ersp\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ersi\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erdi\x3c\/span\x3e\ncmpq \x3cspan class=\x22hljs-built_in\x22\x3ersp\x3c\/span\x3e,[\x3cspan class=\x22hljs-built_in\x22\x3er13\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0xe88\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3ejna\x3c\/span\x3e StackOverflow\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erax\x3c\/span\x3e,[\x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0x18\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3etest\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eal\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0x1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ejnz\x3c\/span\x3e Deoptimize\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erbx\x3c\/span\x3e,[\x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0x10\x3c\/span\x3e]\ntestb \x3cspan class=\x22hljs-built_in\x22\x3erbx\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0x1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ejnz\x3c\/span\x3e Deoptimize\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erdx\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3erbx\x3c\/span\x3e\nshrq \x3cspan class=\x22hljs-built_in\x22\x3erdx\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3erax\x3c\/span\x3e\nshrq \x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e\naddl \x3cspan class=\x22hljs-built_in\x22\x3erdx\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3ercx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ejo\x3c\/span\x3e Deoptimize\nshlq \x3cspan class=\x22hljs-built_in\x22\x3erdx\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erax\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3erdx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emovq\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ersp\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3epop\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erbp\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eret\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0x18\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这么一大堆代码，这比四行要远远超出更多！通常来说，字节码比机器码更紧凑，特别是对比优化过的机器码。但另一方面，字节码需要解释器才能执行，而优化过机器码可以由处理器直接执行。\x3c\/p\x3e\n\x3cp\x3e这就是为什么 JavaScript 引擎不简单粗暴”优化一切”的主要原因之一。正如我们之前所见，生成优化的机器码也需要很长时间，而最重要的是，我们刚刚了解到优化的机器码也需要更多的内存。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s4.ssl.qhres.com\/static\/7745735fec980b69.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结:\x3c\/strong\x3e JavaScript 引擎之所以具有不同优化层，就在于使用解释器快速生成代码或使用优化编译器生成高效代码之间存在一个基本权衡。通过添加更多优化层可以让你做出更细粒度的决策，但是以额外的复杂性和开销为代价。此外，在优化级别和生成代码所占用的内存之间也存在折衷。这就是为什么 JavaScript 引擎仅尝试优化比较 hot 功能的原因所在。\x3c\/p\x3e\n\x3ch2\x3e原型属性访问优化\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/mathiasbynens.be\/notes\/shapes-ics#optimizing-property-access\x22\x3e上一篇文章\x3c\/a\x3e 解释了 JavaScript 引擎如何使用 Shapes 和 Inline Caches 优化对象属性加载。回顾一下，引擎将对象的 Shape 与对象值分开存储。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s0.ssl.qhres.com\/static\/3087c8fd4323793d.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3eShapes 可以实现称为 Inline Caches 或简称 ICs 的优化。通过组合，Shapes 和 ICs 可以加快代码中相同位置的重复属性访问速度。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s1.ssl.qhres.com\/static\/dfed740115e04ffc.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch3\x3eClass和基于原型的编程\x3c\/h3\x3e\n\x3cp\x3e既然我们知道如何在 JavaScript 对象上快速进行属性访问，那么让我们看一下最近添加到 JavaScript 中的特性：class（类）。JavaScript 中的类语法如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x;\n    }\n    getX() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x;\n    }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e尽管它看上去是 JavaScript 中的一个全新概念，但它仅仅是基于原型编程的语法糖：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(x)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x;\n}\n\nBar.prototype.getX = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetX\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x;\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这里，我们在 Bar.prototype 对象上分配一个 getX 属性。这与其他任何对象的工作方式完全相同，因为\x3cstrong\x3e原型只是 JavaScript 中的对象\x3c\/strong\x3e！在基于原型的编程语言（如 JavaScript）中，方法通过原型共享，而字段则存储在实际的实例上。\x3c\/p\x3e\n\x3cp\x3e让我们来实际看看，当我们创建一个名为 foo 的 Bar 新实例时，幕后所发生的事情。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e foo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bar(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过运行此代码创建的实例具有一个带有属性 “x” 的 shape。foo 的原型是属于 class Bar 的 Bar.prototype。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s4.ssl.qhres.com\/static\/0cf96e0c1703e975.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3eBar.prototype 有自己的 shape，其中包含一个属性 \x27getX\x27，取值则是函数 getX，它在调用时只返回 this.x。Bar.prototype 的原型是 Object.prototype，它是 JavaScript 语言的一部分。由于 Object.prototype 是原型树的根节点，因此它的原型是 null。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s0.ssl.qhres.com\/static\/ecb0485cf520b78b.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e如果你在这个类上创建另一个实例，那么两个实例将共享对象 shape。两个实例都指向相同的 Bar.prototype 对象。\x3c\/p\x3e\n\x3ch3\x3e原型属性访问\x3c\/h3\x3e\n\x3cp\x3e好的，现在我们知道当我们定义一个类并创建一个新实例时会发生什么。但是如果我们在一个实例上调用一个方法会发生什么，比如我们在这里做了什么？\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x; }\n    getX() { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x; }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e foo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bar(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e x = foo.getX();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/        ^^^^^^^^^^\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你可以将任何方法视为两个单独的步骤：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs autoit\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e x = foo.getX()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\/\/ is actually two steps:\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $getX = foo.getX\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e x = $getX.\x3cspan class=\x22hljs-built_in\x22\x3ecall\x3c\/span\x3e(foo)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e第1步：是加载这个方法，它只是原型上的一个属性（其值恰好是一个函数）。第2步：是使用实例作为 this 值来调用该函数。让我们来看看第一步，即从实例 foo 中加载方法 getX。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s2.ssl.qhres.com\/static\/a0281d20f0a52903.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e引擎从 foo 实例开始，并且意识到 foo 的 shape 上没有 \x27getX\x27 属性，所以它必须向原型链追溯。我们到了 Bar.prototype，查看它的原型 shape，发现它在偏移0处有 \x27getX\x27 属性。我们在 Bar.prototype 的这个偏移处查找该值，并找到我们想要的JSFunction getX。就是以上这样！\x3c\/p\x3e\n\x3cp\x3eJavaScript的灵活性使我们可以改变原型的链接，举个例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e foo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bar(\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e);\nfoo.getX();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ → true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(foo, \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e);\nfoo.getX();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ → Uncaught TypeError: foo.getX is not a function\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这个例子中，我们调用了foo,getX()函数两次，但是每次都有不同的含义和结果。这就是为什么尽管原型只是 JavaScript 中的对象，但优化原型属性访问对于 JavaScript 引擎而言比优化常规对象的属性访问更具挑战性的原因了。\x3c\/p\x3e\n\x3cp\x3e粗略的来看，加载原型属性是一个非常频繁的操作：每次调用一个方法时都会发生这种情况！\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x; }\n    getX() { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x; }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e foo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bar(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e x = foo.getX();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/        ^^^^^^^^^^\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e之前，我们讨论了引擎如何通过使用 Shapes 和 Inline Caches 来优化访问常规属性的。 我们如何在具有相似 shape 的对象上优化原型属性的重复访问呢？ 我们在上面已经看过是如何访问属性的。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s0.ssl.qhres.com\/static\/29646a52a2460f43.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e为了在这种特殊情况下实现快速重复访问，我们需要知道这三件事：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3efoo的 shape 不包含 \x27getX\x27 并且没有改变过。这意味着没有人通过添加或删除属性或通过更改其中一个属性来更改对象 foo。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3efoo 的原型仍然是最初的 Bar.prototype。这意味着没有人通过使用Object.setPrototypeOf() 或通过赋予特殊的 \x3cem\x3eproto\x3c\/em\x3e 属性来更改 foo 的原型。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eBar.prototype 的形状包含 \x27getX\x27 并且没有改变。这意味着没有人通过添加或删除属性或更改其中一个属性来更改 Bar.prototype。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e一般情况下，这意味着我们必须对实例本身执行1次检查，并对每个原型进行2次检查，直到找到我们正在寻找的属性所在原型。(1 \x2b 2N )次检查（其中 N 是所涉及的原型的数量）对于这种情况听起来可能不太糟糕，因为这里原型链相对较浅 - 但是引擎通常必须处理更长的原型链，就像常见的 DOM 类一样。下面是一个例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs pf\x22\x3econst \x3cspan class=\x22hljs-built_in\x22\x3eanchor\x3c\/span\x3e = document.createElement(\x27a\x27);\n\/\/ → HTMLAnchorElement\n\nconst title = \x3cspan class=\x22hljs-built_in\x22\x3eanchor\x3c\/span\x3e.getAttribute(\x27title\x27);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们有一个 HTMLAnchorElement，在其上调用 getAttribute() 方法。这个简单的锚元素原型链就已经涉及6个原型！大多数有趣的 DOM 方法并不是直接存在于 HTMLAnchorElement 原型中，而是在原型链的更高层。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s3.ssl.qhres.com\/static\/fd0b3aa99f88edf1.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e我们可以在 Element的原型链上找到 getAttribute() 方法。这意味着我们每次调用 anchor.getAttribute() 时，JavaScript引擎都需要……\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e检测到 \x27getAttribute\x27 不在锚对象本身上，\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e检测到直属的原型链是HTMLAnchorElement.prototype,\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e断言原型上缺少\x27getAttribute\x27 ,\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e检查它的下一个原型是 HTMLElement.prototype,\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e断言也不存在与 \x27getAttribute\x27 这个原型上,\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最终检测出下一个原型是 Element.prototype，\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最后找到 \x27getAttribute\x27。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e总共有7次检测！由于这是 Web 上一种非常常见的代码，因此引擎会应用技巧来减少原型上属性加载所需的检查次数。\x3c\/p\x3e\n\x3cp\x3e回到最初的例子，我们在foo上访问getX总共进行了三次检查：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x; }\n    getX() { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x; }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e foo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bar(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $getX = foo.getX;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在直到我们找到携带目标属性的原型之前，我们需要对原型链上的每个对象进行 shape 的缺失检查。如果我们可以通过将原型检查折叠到缺失检查来减少检查次数，那就太好了。而这基本上就是引擎所做的：引擎将原型链在 Shape 上，\x3cstrong\x3e而不是直接链在实例上\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s2.ssl.qhres.com\/static\/03335cde9d0a1f67.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e每个 shape 都指向原型。这也意味着每次 foo 原型发生变化时，引擎都会转换到一个新 shape。 现在我们只需要检查一个对象的 shape，这样既可以断言某些属性的缺失，也可以保护原型链链接。\x3c\/p\x3e\n\x3cp\x3e通过这种方法，我们可以将检查次数从 1 \x2b 2N 降到 1 \x2b N，以便在原型上更快地访问属性。但这仍相当昂贵，因为它在原型链的长度上仍然是线性的。 为了进一步将检查次数减少到一个常量级别，引擎采用了不同的技巧，尤其是对于相同属性访问的后续执行。\x3c\/p\x3e\n\x3ch3\x3eValidity cells\x3c\/h3\x3e\n\x3cp\x3eV8专门为此目的处理原型的 shape。每个原型都具有一个不与其他对象（特别是不与其他原型共享）共享且独特的 shape，且每个原型的 shape 都具有与之关联的一个特殊 ValidityCell。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s5.ssl.qhres.com\/static\/677908aab86d1483.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e只要有人更改其相关原型或其祖先的任何原型，此 ValidityCell 就会失效。让我们来看看它是如何工作的。\x3c\/p\x3e\n\x3cp\x3e为了加速原型的后续访问，V8 建立了一个 Inline Cache，其中包含四个字段：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s3.ssl.qhres.com\/static\/1ea3c306acc8c7bb.svg\x22 alt=\x22The Inline Cache for prototype loads has four fields: ValidityCell, Prototype, Shape, and Offset.\x22\x3e\x3c\/p\x3e\n\x3cp\x3e在第一次运行此代码预热 inline cache 时，V8 会记住目标属性在原型中的偏移量，找到属性的原型（本例中为 Bar.prototype），实例的 shape（在这种情况下为 foo 的 shape），以及与实例 shape 链接的直接原型中 ValidityCell 的链接（在本例中也恰好是 Bar.prototype）。\x3c\/p\x3e\n\x3cp\x3e下次 inline cache 命中时，引擎必须检查实例的 shape 和 ValidityCell。如果它仍然有效，则引擎可以直接到达 Prototype 上的 Offset 位置，跳过其他查找。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s3.ssl.qhres.com\/static\/1dbbc3bb477862a9.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e当原型改变时，shape 将重新分配，且先前的 ValidityCell 失效。因此，Inline Cache 在下次执行时会失效，从而导致性能下降。\x3c\/p\x3e\n\x3cp\x3e回到之前的 DOM 示例，这意味着对 Object.prototype 的任何更改不仅会使 Object.prototype本身的 inline cache 失效，而且还会使其下游的所有原型失效，包括EventTarget.prototype，Node.prototype，Element.prototype 等，直到 HTMLAnchorElement.prototype 为止。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/s0.ssl.qhres.com\/static\/b6b3dd08eff7e084.svg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e实际上，在运行代码时修改 Object.prototype 意味着完全抛弃性能上的考虑。不要这样做！\x3c\/p\x3e\n\x3cp\x3e让我们用一个具体的例子来探讨这个问题。 假设我们有一个类叫做 Bar，并且我们有一个函数 loadX，它调用 Bar 对象上的方法。 我们用同一个类的实例多调用这个 loadX 函数几次。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* … *\/\x3c\/span\x3e }\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eloadX\x3c\/span\x3e\x3c\/span\x3e(bar) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bar.getX(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ IC for \x27getX\x27 on Bar instances.\x3c\/span\x3e\n}\n\nloadX(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eBar\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e));\nloadX(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eBar\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ IC in loadX now links the ValidityCell for\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Bar.prototype.\x3c\/span\x3e\n\nObject.prototype.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMethod\x3c\/span\x3e = y =\x26gt; y;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The ValidityCell in the loadX IC is invalid\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ now, because Object.prototype changed.\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eloadX 中的 inline cache 现在指向 Bar.prototype 的 ValidityCell。 如果你之后执行了类似于改变 Object.prototype（这是 JavaScript 中所有原型的根节点）的操作，则ValidityCell 将失效，且现有的 inline cache 会在下次命中时丢失，从而导致性能下降。\x3c\/p\x3e\n\x3cp\x3e修改 Object.prototype 被认为是一个不好的操作，因为它使引擎在此之前为原型访问准备的所有 inline cache 都失效。 这是另一个不推荐的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* … *\/\x3c\/span\x3e };\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Run critical code:\x3c\/span\x3e\nsomeObject.foo();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ End of critical code.\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.foo;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们扩展了 Object.prototype，它使引擎在此之前存储的所有原型 inline cache 均无效了。然后我们运行一些用到新原型方法的代码。引擎此时则需要从头开始，并为所有原型属性的访问设置新的 inline cache。最后，我们删除了之前添加的原型方法。\x3c\/p\x3e\n\x3cp\x3e删除，这听起来像个好主意，对吧？然而在这种情况下，它只会让情况变得更糟！删除属性会修改 Object.prototype，因此所有 inline cache 会再次失效，而引擎又必须从头开始。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结：\x3c\/strong\x3e 虽然原型只是对象，但它们由 JavaScript 引擎专门处理，以优化在原型上查找方法的性能表现。把你的原型放在一旁！或者，如果你确实需要修改原型，请在其他代码运行之前执行此操作，这样至少不会让引擎所做的优化付诸东流。\x3c\/p\x3e\n\x3ch2\x3eTake-aways\x3c\/h2\x3e\n\x3cp\x3e我们已经了解了 JavaScript 引擎是如何存储对象与类的，Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型的。基于这些知识，我们认为有一个普适实用的 JavaScript 编码技巧，可以帮助提高性能：\x3cstrong\x3e请勿随意修改原型对象\x3c\/strong\x3e（即便你真的需要，那么请在其他代码运行之前做这件事）。\x3c\/p\x3e\n\x3ch2\x3e翻译\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/hijiangtao.github.io\/2018\/08\/21\/Prototypes\/\x22\x3e中文参考翻译\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/shlrur.github.io\/javascripts\/javascript-engine-fundamentals-optimizing-prototypes\/\x22\x3e韩文参考翻译\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/javascript-engine-fundamentals-optimizing-prototypes">https://www.zcfy.cc/article/javascript-engine-fundamentals-optimizing-prototypes</a> 原文标题: JavaScript引擎基础：优化原型</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/44173d64/" target="_blank">https://alili.tech/archive/44173d64/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>