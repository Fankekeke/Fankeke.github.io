<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="js处理异步函数：从callback到promise"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>js处理异步函数：从callback到promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/4dfubuwj8kf/",
				"appid": "1613049289050283", 
				"title": "js处理异步函数：从callback到promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3bx0h7b08wt/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2b5cb5g1jme/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&text=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&text=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&title=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&is_video=false&description=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&title=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&title=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&title=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4dfubuwj8kf%2f&title=js%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%ef%bc%9a%e4%bb%8ecallback%e5%88%b0promise"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">js处理异步函数：从callback到promise</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e函数的执行分为同步和异步两种。\x3cbr\x3e同步即为 同步连续执行，通俗点讲就是做完一件事，再去做另一件事。\x3cbr\x3e异步即为 先做一件事，中间可以去做其他事情，稍后再回来做第一件事情。\x3cbr\x3e同时还要记住两个特性：1.异步函数是没有返回值的，return不管用哦  2.try{}catch(e){}不能捕获异步函数中的异常。\x3c\/p\x3e\n\x3cp\x3ejs在处理异步回调函数的情况有着越来越值得推崇的方法及类库，下面会依次介绍js处理异步函数的发展史，及源码解读。\x3cbr\x3e（本文代码是运行在node环境中）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e1.callback\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let fs = require(\x27fs\x27);\nfs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,function(err,data){\n    console.log(data);\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,data\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果只有一个异步请求，那用callback还好，但是相信大多数前端开发者都遇到过这两种情况：\x3cbr\x3ea.一个异步请求获取到的结果是下一个异步请求的参数。(一直嵌套callback，代码不好管理会形成回调地狱);\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let fs = require(\x27fs\x27);\n    fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n        fs.readFile(data,\x27utf8\x27,(err,data)=\x3e{\n            console.log(data);\n        })\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3elet fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err,data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        fs.readFile(data,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err,data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n        })\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eb.发出两个请求，只有当两个请求都成功获取到数据，在执行下一步操作。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let fs =require(\x27fs\x27);\n    fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n        console.log(data);\n    })\n    fs.readFile(\x27.\/2.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n        console.log(data);\n    })\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3elet fs =\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err,data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    })\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/2.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err,data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    })\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e像类似这种情况，只有当读取到1.txt 和2.txt的文件的时候，我们同时获取到两个异步请求的结果。我们可以写一个计数器的函数，统一处理回调;\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function after(time,callback){\n    let arr = [];\n    return function(data){\n        arr.push(data)\n        if(--time==0){\n            callback(arr);\n        }\n    }\n}\n  \/\/统一处理回调结果的回调传到after函数中。\n  let out = after(2,(res)=\x3e{console.log(res)});\n  let fs =require(\x27fs\x27);\n    fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n        out(data);\n    })\n    fs.readFile(\x27.\/2.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n        out(data);\n    })\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eafter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etime,callback\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{\n        arr.push(data)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(--time==\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e){\n            callback(arr);\n        }\n    }\n}\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/统一处理回调结果的回调传到after函数中。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e out = after(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res)});\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fs =\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,data\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        out(data);\n    })\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/2.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,data\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        out(data);\n    })\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3etips：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e方便我们更好的了解计数器的实现原理，我们需要了解一个概念：高阶函数\x3cbr\x3e高阶函数：可以把函数作为参数 或者 return返回出一个函数。\x3cbr\x3e举个例子：\x3c\/p\x3e\n\x3cp\x3e①.判断一个变量是不是属于一个类型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isType(type,content){\n   return Object.protoType.toString.call(content) ==`[Object ${type}]`\n}\nlet a = [1,2,3];\nisType(\x27Array\x27, a) == true;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype,content\x3c\/span\x3e)\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.protoType.toString.call(content) ==\x3cspan class=\x22hljs-string\x22\x3e`[Object \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e]`\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\nisType(\x3cspan class=\x22hljs-string\x22\x3e\x27Array\x27\x3c\/span\x3e, a) == \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e②.js数据类型有好多，我们每次调用都要传入他的类型，麻不麻烦。所以我们写一个方法，可以批量生成函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isType(type){\n    return function(content){\n        return Object.protoType.toString.call(content) == `[Oject ${type}]`\n    }\n}\nlet isArray = isType(\x27Array\x27);\nlet a = [1,2,3]\nisArray(a);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtent\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.protoType.toString.call(content) == \x3cspan class=\x22hljs-string\x22\x3e`[Oject \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e]`\x3c\/span\x3e\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isArray = isType(\x3cspan class=\x22hljs-string\x22\x3e\x27Array\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\nisArray(a);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e前两种示例讲的是return返回一个函数，下面示例是一个预置函数及返回函数参数的结合示例（预置函数）。\x3c\/p\x3e\n\x3cp\x3e③.场景加入我有一个函数，执行第三次的时候我想输出\x27我很可爱\x27;平常我们可以这样去实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let time =0;\n     function say(){\n         if(\x2b\x2bitem==3){\n         console.log(\x27我很可爱\x27)\n         }\n     }\n     say();\n     say();\n     say();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3elet \x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e =\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n     function \x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e(){\n         \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x2b\x2b\x3cspan class=\x22hljs-built_in\x22\x3eitem\x3c\/span\x3e==\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e){\n         console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27我很可爱\x27)\n         }\n     }\n     \x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e();\n     \x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e();\n     \x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e高阶函数实现的话：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function after(time,callback){\n        return function(){\n            if(--time ==0){\n                   callback();\n            }\n        }\n     }\n     function say(){\n         console.log(\x27我很可爱\x27);\n     }\n     let out =after(3,say)\n     out();\n     out();\n     out();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eafter\x3c\/span\x3e(time,callback){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3efunction(){\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-comment\x22\x3e--time ==0){\x3c\/span\x3e\n                   callback();\n            }\n        }\n     }\n     \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esay\x3c\/span\x3e(){\n         console.log(\x27我很可爱\x27);\n     }\n     let \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e =after(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,say)\n     \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e();\n     \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e();\n     \x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e高阶函数实现了将计时任务与业务逻辑拆分，高阶函数的实现主要得益于作用域的查找。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e2.Promise\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e在看完了上面的callback讲述，主要其实还是讲述了callback的弊端:\x3cbr\x3ea.回调地狱(callback无法解决)\x3cbr\x3eb.并发请求，同时拿到结果(可通过计数器方式，但是太费劲，不太乐观)\x3cbr\x3e这个时候duang~duang~duang~，ES6带着Promise来了~\x3cbr\x3ePromise主要是es6提供的主要用于处理异步请求的一个对象，他能够很好的解决回调地狱以及并发请求。\x3cbr\x3e在写promise源码之前，我们先通过几个调用promise的示例，了解一下promise的一些原理及特性,这在我们封装promise的时候能够起到很大的作用：\x3cbr\x3e普通调用实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let fs = require(\x27fs\x27);\nlet p = new Promise(function(resolve,reject){\n  fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,(err,data)=\x3e{\n      err?reject(err):resolve(data);\n  })\n})\n\np.then((data)=\x3e{console.log(data)},(err)=\x3e{console.log(err)});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n  fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,data\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      err?reject(err):resolve(data);\n  })\n})\n\np.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e1.promise实例可以多次调用then方法;\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  p.then((data)=\x3e{console.log(data)},(err)=\x3e{console.log(err)});\n  p.then((data)=\x3e{console.log(data)},(err)=\x3e{console.log(err)});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e  p.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)});\n  p.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2.promise实例可以支持then方法的链式调用，jquery实现链式是通过返回当前的this。但是promise不可以通过返回this来实现。因为后续通过链式增加的then不是通过原始的promise对象的状态来决定走成功还是走失败的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22p.then((data)=\x3e{console.log(data)},(err)=\x3e{console.log(err)}).then((data)=\x3e{console.log(data)})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3ep.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.只要then方法中的成功回调和失败回调，有返回值(包括undefiend)，都会走到下个then方法中的成功回调中，并且把返回值作为下个then成功回调的参数传进去。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22第一个then走成功：\np.then((data)=\x3e{return undefined},(err)={console.log()}).then((data)=\x3e{console.log(data)})\n输出：undefiend\n第一个then走失败：\n  p.then((data)=\x3e{console.log(1)},(err)={return undefined).then((data)=\x3e{console.log(data)})\n输出：undefiend\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e第一个then走成功：\np.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e},\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)={\x3cspan class=\x22hljs-params\x22\x3econsole\x3c\/span\x3e.\x3cspan class=\x22hljs-params\x22\x3elog\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e}).\x3cspan class=\x22hljs-params\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)}\x3c\/span\x3e)\n输出：\x3cspan class=\x22hljs-params\x22\x3eundefiend\x3c\/span\x3e\n第一个\x3cspan class=\x22hljs-params\x22\x3ethen\x3c\/span\x3e走失败：\n  \x3cspan class=\x22hljs-params\x22\x3ep\x3c\/span\x3e.\x3cspan class=\x22hljs-params\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-params\x22\x3e1\x3c\/span\x3e)},(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)={\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\x3c\/span\x3e).\x3cspan class=\x22hljs-params\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)}\x3c\/span\x3e)\n输出：\x3cspan class=\x22hljs-params\x22\x3eundefiend\x3c\/span\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.只要then方法中的成功回调和失败回调，有一个抛出异常，则都会走到下一个then中的失败回调中;\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22第一个then走成功：\np.then((data)=\x3e{throw new Err(\x26quot;错误\x26quot;)},(err)={console.log(1)}).then((data)=\x3e{console.log(\x27成功\x27)},(err)=\x3e{console.log(err)})\n输出：错误\n第一个then走失败：\n  p.then((data)=\x3e{console.log(1)},(err)={throw new Err(\x26quot;错误\x26quot;)).then((data)=\x3e{console.log(\x27成功\x27)},(err)=\x3e{console.log(err)})\n输出：错误\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e第一个\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e走成功：\np.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Err(\x3cspan class=\x22hljs-string\x22\x3e\x22错误\x22\x3c\/span\x3e)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e={console.log\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3c\/span\x3e}).then(\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27成功\x27\x3c\/span\x3e)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)})\n输出：错误\n第一个\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e走失败：\n  p.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e={throw new Err\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22错误\x22\x3c\/span\x3e)\x3c\/span\x3e).then(\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27成功\x27\x3c\/span\x3e)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)})\n输出：错误\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5.成功和失败 只能走一个，如果成功了，就不会走失败，如果失败了，就不会走成功;\x3c\/p\x3e\n\x3cp\x3e6.如果then方法中，返回的不是一个普通值，仍旧是一个promise对象，该如何处理？\x3cbr\x3e  答案：它会等待这个promise的执行结果，并且传给下一个then方法。如果成功，就把这个promise的结果传给下一个then的成功回调并且执行，如果失败就把错误传给下一个then的失败回调并且执行。\x3c\/p\x3e\n\x3cp\x3e7.具备catch捕获错误;如果catche前面的所有then方法都没有失败回调，则catche会捕获到错误信息执行他就是用来兜儿底用的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22p是一个失败的回调:\np.then((data)=\x3e{console.log(\x27成功\x27)}).then((data)=\x3e{成功}).catche(e){console.log(\x27错误\x27)}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3ep是一个失败的回调:\np.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27成功\x27\x3c\/span\x3e)}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{成功}).catche(e){\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27错误\x27\x3c\/span\x3e)}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e8.返回的结果和 promise是同一个，永远不会成功和失败\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var  r  = new Promise(function(resolve,reject){\n   return r;\n})\nr.then(function(){\n    console.log(1)\n},function(err){\n    console.log(err)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  r  = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e r;\n})\nr.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是经过调用es6提供的promise，发现的一些特性，下面我们会根据这些特性去封装Promise类。\x3c\/p\x3e\n\x3cp\x3e一.我们先通过初步了解的promise和简单的基本调用，简单的实现一个promise；\x3c\/p\x3e\n\x3cp\x3e1.Promise支持传入一个参数，函数类型，这个函数往往是我们自己发起异步请求的函数，我们称它为执行器actuator,这个函数会在调用new Promise()的作用域内立即执行，并且传入两个函数一个resolve另一个是reject作为参数;\x3c\/p\x3e\n\x3cp\x3e2.promise对象支持.then()的方法，then方法支持两个参数一个为onFulfilled成功回调另一个为onRejected失败回调;onFulfilled接受参数data为异步请求拿到的数据，onRejected接受的参数为捕获到的异常错误。\x3c\/p\x3e\n\x3cp\x3e3.当异步回调成功时，执行resolve，并且把回调结果传给resolve函数。失败则执行reject，把异常信息传给reject函数。(这一步往往是在actuator执行器函数中我们自己去控制执行的)\x3c\/p\x3e\n\x3cp\x3e4.一个promise对象，执行了resolve，就不会在去执行reject。执行了reject，也不会在去执行resolve；\x3cbr\x3e 所以promise内部中有一个类似状态机的机制，它分为三种状态，创建一个promise对象，默认状态为\x27pending\x27状态，当执行了resolve，则该状态变为\x27fulfilled\x27，若果执行了reject则该状态变为\x27rejected\x27,所以我们在then方法中需要根据状态作出判断;\x3c\/p\x3e\n\x3cp\x3e5.promise对象已经是成功状态或是失败状态时，都可以继续通过then传入函数，会通过当前的状态，来决定执行成功还失败，并且把结果或是错误传给相应的函数。所以我们需要拿到的结果和捕获的错误。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function Promise(fn){\n    this.status = \x27pending\x27;\/\/状态机\n    \/\/一个promise支持执行多个then，所以需要一个池子把他的回调函数存储起来，统一遍历执行；\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks =[]; \n    \/\/保存结果或者错误异常\n    this.result = \x27\x27;\/\/当前promise回调成功获取到的数据;\n    this.reason = \x27\x27;\/\/当前promise失败的原因\n    var self = this;\n    function resolve(data){\n        \/\/执行了reject就不能执行resolve，所以必须保证是pending状态；\n        \/\/当执行回调成功，在执行器调用resolve，我们去遍历成功回调的池子，依次执行;\n        \/\/保存结果，并且将当前状态设置为\x27fulfilled\x27\n        if(self.status==\x27pending\x27){\n            self.result = data;\n            self.status = \x27fulfilled\x27;\n            self.onFulfilledCallbacks.forEach((fn)=\x3e{\n                fn(data);\n            })\n        }\n          \n    }\n    function reject(err){\n        \/\/执行了resolve就不能执行reject，所以必须保证是pending状态；\n        \/\/当执行回调失败，在执行器调用reject，我们去遍历成功回调的池子，依次执行;\n        \/\/保存错误原因并且将当前状态设置为\x27rejected\x27\n        if(self.status==\x27pending\x27){\n          self.reason= err;\n          self.status =\x27rejected\x27;\n          self.onRejectedCallbacks.forEach((fn)=\x3e{\n              fn(err);\n          })\n        }\n    }\n    fn(resolve,reject)\n}\nPromise.prototype.then= function(onFulfilled,onRejected){\n   \/\/如果当前promise对象成功状态，则直接执行onFulfilled回调函数，并且把拿到的已经保存的成功数据传进去。\n   if(this.status ==\x27fulfilled\x27){\n       onFulfilled(this.result)    \n   }\n   \/\/如果当前promise对象失败状态，则直接执行rejected回调函数，并且把已经保存的补货失败的原因传进去。\n   if(this.status ==\x27rejected\x27){\n       onRejected(this.reason);\n   }\n   if(this.status == \x27pending\x27){\n       this.onFulfilledCallbacks.push(onFulfilled);\n       this.onRejectedCallbacks.push(onRejected);\n   }\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status = \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/状态机\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/一个promise支持执行多个then，所以需要一个池子把他的回调函数存储起来，统一遍历执行；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFulfilledCallbacks = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onRejectedCallbacks =[]; \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/保存结果或者错误异常\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.result = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/当前promise回调成功获取到的数据;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reason = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/当前promise失败的原因\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e self = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行了reject就不能执行resolve，所以必须保证是pending状态；\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/当执行回调成功，在执行器调用resolve，我们去遍历成功回调的池子，依次执行;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/保存结果，并且将当前状态设置为\x27fulfilled\x27\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(self.status==\x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n            self.result = data;\n            self.status = \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e;\n            self.onFulfilledCallbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n                fn(data);\n            })\n        }\n          \n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行了resolve就不能执行reject，所以必须保证是pending状态；\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/当执行回调失败，在执行器调用reject，我们去遍历成功回调的池子，依次执行;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/保存错误原因并且将当前状态设置为\x27rejected\x27\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(self.status==\x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n          self.reason= err;\n          self.status =\x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e;\n          self.onRejectedCallbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n              fn(err);\n          })\n        }\n    }\n    fn(resolve,reject)\n}\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.prototype.then= \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eonFulfilled,onRejected\x3c\/span\x3e)\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果当前promise对象成功状态，则直接执行onFulfilled回调函数，并且把拿到的已经保存的成功数据传进去。\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status ==\x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e){\n       onFulfilled(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.result)    \n   }\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果当前promise对象失败状态，则直接执行rejected回调函数，并且把已经保存的补货失败的原因传进去。\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status ==\x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e){\n       onRejected(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reason);\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status == \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n       \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFulfilledCallbacks.push(onFulfilled);\n       \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onRejectedCallbacks.push(onRejected);\n   }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e到目前为止我们已经封装了一个简易版的promise了，我们可以通过一些case去测试一下，是否满足上面所描述的特性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let fs = require(\x27fs\x27);\nlet p = new Promise((resolve,reject)=\x3e{\n   fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,function (err,data) {\n              err ? reject(err):resolve(data);\n   })\n});\np.then(data=\x3e{console.log(data)},err=\x3e{console.log(err)}); \np.then(data=\x3e{console.log(data)},err=\x3e{console.log(err)});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n   fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr,data\x3c\/span\x3e) \x3c\/span\x3e{\n              err ? reject(err):resolve(data);\n   })\n});\np.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)}); \np.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e二、我们简易版的promise类，已经初步实现了一些promise的基本特性;这一节我们我们简易版的promise进行改版，把promise的更复杂的功能增加进去。\x3c\/p\x3e\n\x3cp\x3e1.当我们调用promise时，传入的执行器会立刻执行，执行器函数内部是一个同步的过程，我们可以用try...catch捕获错误，并且应该直接调用失败的函数。\x3c\/p\x3e\n\x3cp\x3e2.promise支持链式写法，then后面继续.then ,原理并不是像jquery一样返回一个this;而是不管当前promise状态是什么，都返回一个新的promise对象，官方文档命名这个新的promise对象为promise2。\x3cbr\x3e3.链式写法中第二个then中的回调走成功还是走失败，取决于上一个then中返回的promise（就是promise2）对象的状态。 而 promise2对象的状态，是由第一个then的参数（成功回调函数或失败回调函数）的返回值决定的。如果返回的是一个值（包括返回的是undefined、\x22\x22），则第二个then走成功;如果返回的仍旧是一个promise对象，那么promise2会等待返回的这个promise对象的回调结果而确定promise2的状态值，如果回调结果拿到的是一个值（成功），那么promise2会将此值作为参数传入字节的reosolve中并执行,如果回调中抛出异常（失败），那么promise2会把异常传到reject中并且执行；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Promise(fn){\n    this.status = \x27pending\x27;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks =[]; \n    this.result = \x27\x27;\n    this.reason = \x27\x27;\n    var self = this;\n    function resolve(data){\n        if(self.status==\x27pending\x27){\n            self.result = data;\n            self.status = \x27fulfilled\x27;\n            self.onFulfilledCallbacks.forEach((fn)=\x3e{\n                fn(data);\n            })\n        }\n          \n    }\n    function reject(err){           \n        if(self.status==\x27pending\x27){\n          self.reason= err;\n          self.status =\x27rejected\x27;\n          self.onRejectedCallbacks.forEach((fn)=\x3e{\n              fn(err);\n          })\n        }\n    }\n    try{\n        fn(resolve,reject)\n    }catch(e){\n        reject(e)\n    }\n    \n}\nPromise.prototype.then= function(onFulfilled,onRejected){\n   \/\/then方法什么都不传，也可以支持连续调用  \n   onFulfilled = onFulfilled ?onFulfilled :function(data){ return data};\n   onRejected =onFulfilled ? onFulfilled :function(err){throw new Error(err)}\n   let self = this;\n   let Promise2;\/\/声明primise2\n   if(this.status ==\x27fulfilled\x27){\n       Promise2 = new Promise(function(resolve,reject){\n           \/\/promise2的状态，决定下一个then方法中执行成功还是失败。\n           \/\/promise2的状态,是由第一个then的onFulfilled的返回值决定的。\n           \/\/当我们执行onFulfilled(我们通过then方法传进来的自己的函数)的时候，是同步操作，需要通过trycatch捕获异常，如果发现异常就直接走下一个then的reject失败回调。\n           \/\/promise官方文档规定，每一个resolve或是reject回调的执行必须保证是在异步中执行，所以我们强制加定时器，保证onFulfilled是异步执行的。\n           setTimeOut(function(){\n               try{\n                   let x = onFulfilled(self.result);\n                   \/\/获取到返回值，需要去解析，从而判断出promise2应该走失败还是成功。    \n                   resolvePromise(Promise2,x,resolve,reject)                                              \n               }catch(e){\n                  \/\/执行reject,下一个then就会走失败\n                   reject(e);\n               }\n           })                                                      \n       })          \n   }\n   if(this.status ==\x27rejected\x27){\n     Promise2 = new Promise(function(resolve,reject){\n       setTimeout(function(){\n           try{\n               let x = onRejected(self.reason);\n               resolvePromise(Promise2,x,resolve,reject)\n           }catch(e){\n               reject(e)\n           }\n       })\n     })\n       \n   }\n   if(this.status == \x27pending\x27){\n   Promise2 = new Promise(function(resolve,reject){\n        self.onFulfilledCallbacks.push(function(){\n            setTimeout(function(){\n                try{\n                    let x =  onFulfilled(self.result);\n                    resolvePromise(Promise2,x,resolve,reject);\n                }catch (e){\n                    reject(e)\n                }\n            })\n\n        });\n        self.onRejectedCallbacks.push(function(){\n            setTimeout(function(){\n                try {\n                    let x =  onRejected(self.reason);\n                    resolvePromise(Promise2,x,resolve,reject)\n                }catch (e){\n                    reject(e);\n                }\n            })\n\n        });\n    })\n   }\n   return Promise2;\n}\n\nfunction resolvePromise(promise2,x,resolve,reject){\n    \/\/此处如果相等会爆出类型错误；\n    if(promise2 == x){\n        reject(new TypeError(\x27循环引用了\x27))\n    }\n    \/\/如果x是对象或函数(引用类型的值),则需要进一步判断。（这块儿要想的多一些，因为x是开发人员写的函数返回的，第一个then中回调返回的）\n    \/\/若果x是一个普通值，则直接执行resolve，并且传给下个then的成功; \n    \/\/如果返回的是一个promise对象，则promise2则会等待返回的promise对象执行完成，如果执行完成后，看这个promise走的成功还是失败，如果失败则抛出异常。如果成功则将获取的数据作为onFulfilled返回的结果，用于判断promise2走成功或者失败，因为返回的结果可能还是promise对象，所以用递归去执行，知道拿到数据或者异常。（递归）\n    \/\/判断是不是promise对象，通过有没有then方法\n    \/\/捕获异常是因为判断不严谨，存在then方法，可能也不是promise对象，调用它的then可能会报错。      \n    let called =false;\n    if(x!==null \x26amp;\x26amp;(typeof x ==\x27object\x27|| typeof x ==\x27function\x27)){        \n           try{\n               let then =x.then;\n               if(typeof then ==\x27function\x27){\n                   \/\/promise对象\n                   then.call(x,function(y){\n                       if(called)return;\n                       called = true;\n                       resolvePromise(promise2,y,resolve,reject)\n                   },function(err){\n                       if(called)return;\n                       called = true;\n                       reject(err)\n                   })\n               \n               }else{\n                   \/\/普通对象\n                   resolve(x)\n               }\n           }catch(e){\n              if(called)return;\n              called = true;\n              reject(e)\n           }\n    }else{\n        resolve(x);\n    }    \n}\n\n 到此，Promise的大部分特性都已经具备了。但是Promise对象还有一些其他的方法，可供调用，比如说catch方法，还有他的私有属性all 、race、defferd，如果前面的Promise封装懂了，那这些方法就so easy了，下面会根据这些方法的功能一一进行封装,\n \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status = \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFulfilledCallbacks = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onRejectedCallbacks =[]; \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.result = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reason = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e self = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(self.status==\x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n            self.result = data;\n            self.status = \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e;\n            self.onFulfilledCallbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n                fn(data);\n            })\n        }\n          \n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{           \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(self.status==\x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n          self.reason= err;\n          self.status =\x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e;\n          self.onRejectedCallbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n              fn(err);\n          })\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n        fn(resolve,reject)\n    }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e){\n        reject(e)\n    }\n    \n}\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.prototype.then= \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eonFulfilled,onRejected\x3c\/span\x3e)\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/then方法什么都不传，也可以支持连续调用  \x3c\/span\x3e\n   onFulfilled = onFulfilled ?onFulfilled :\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e data};\n   onRejected =onFulfilled ? onFulfilled :\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(err)}\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e self = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e Promise2;\x3cspan class=\x22hljs-comment\x22\x3e\/\/声明primise2\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status ==\x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e){\n       Promise2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise2的状态，决定下一个then方法中执行成功还是失败。\x3c\/span\x3e\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise2的状态,是由第一个then的onFulfilled的返回值决定的。\x3c\/span\x3e\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/当我们执行onFulfilled(我们通过then方法传进来的自己的函数)的时候，是同步操作，需要通过trycatch捕获异常，如果发现异常就直接走下一个then的reject失败回调。\x3c\/span\x3e\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise官方文档规定，每一个resolve或是reject回调的执行必须保证是在异步中执行，所以我们强制加定时器，保证onFulfilled是异步执行的。\x3c\/span\x3e\n           setTimeOut(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n               \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n                   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = onFulfilled(self.result);\n                   \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取到返回值，需要去解析，从而判断出promise2应该走失败还是成功。    \x3c\/span\x3e\n                   resolvePromise(Promise2,x,resolve,reject)                                              \n               }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e){\n                  \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行reject,下一个then就会走失败\x3c\/span\x3e\n                   reject(e);\n               }\n           })                                                      \n       })          \n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status ==\x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e){\n     Promise2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n       setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n               \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = onRejected(self.reason);\n               resolvePromise(Promise2,x,resolve,reject)\n           }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e){\n               reject(e)\n           }\n       })\n     })\n       \n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status == \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e){\n   Promise2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n        self.onFulfilledCallbacks.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x =  onFulfilled(self.result);\n                    resolvePromise(Promise2,x,resolve,reject);\n                }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e){\n                    reject(e)\n                }\n            })\n\n        });\n        self.onRejectedCallbacks.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x =  onRejected(self.reason);\n                    resolvePromise(Promise2,x,resolve,reject)\n                }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e){\n                    reject(e);\n                }\n            })\n\n        });\n    })\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Promise2;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolvePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epromise2,x,resolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处如果相等会爆出类型错误；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(promise2 == x){\n        reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27循环引用了\x27\x3c\/span\x3e))\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果x是对象或函数(引用类型的值),则需要进一步判断。（这块儿要想的多一些，因为x是开发人员写的函数返回的，第一个then中回调返回的）\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/若果x是一个普通值，则直接执行resolve，并且传给下个then的成功; \x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果返回的是一个promise对象，则promise2则会等待返回的promise对象执行完成，如果执行完成后，看这个promise走的成功还是失败，如果失败则抛出异常。如果成功则将获取的数据作为onFulfilled返回的结果，用于判断promise2走成功或者失败，因为返回的结果可能还是promise对象，所以用递归去执行，知道拿到数据或者异常。（递归）\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断是不是promise对象，通过有没有then方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/捕获异常是因为判断不严谨，存在then方法，可能也不是promise对象，调用它的then可能会报错。      \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e called =\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(x!==\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp;(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e x ==\x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e|| \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e x ==\x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)){        \n           \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n               \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e then =x.then;\n               \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e then ==\x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n                   \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise对象\x3c\/span\x3e\n                   then.call(x,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ey\x3c\/span\x3e)\x3c\/span\x3e{\n                       \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(called)\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n                       called = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n                       resolvePromise(promise2,y,resolve,reject)\n                   },\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\n                       \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(called)\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n                       called = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n                       reject(err)\n                   })\n               \n               }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n                   \x3cspan class=\x22hljs-comment\x22\x3e\/\/普通对象\x3c\/span\x3e\n                   resolve(x)\n               }\n           }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e){\n              \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(called)\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n              called = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n              reject(e)\n           }\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n        resolve(x);\n    }    \n}\n\n 到此，\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e的大部分特性都已经具备了。但是\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e对象还有一些其他的方法，可供调用，比如说\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e方法，还有他的私有属性all 、race、defferd，如果前面的\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e封装懂了，那这些方法就so easy了，下面会根据这些方法的功能一一进行封装,\n \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e1.all方法处理 并发请求，同时获得结果。一个失败，则失败，都成功，才算成功.这个时候我们就想到前面我们写的计数器的用法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 Promise.all([read(\x27.\/1.txt\x27),read(\x27.\/2.txt\x27)]).then(res=\x3e{console.log(res)})\n \n Promise.all = function(promiseArray){               \n       return new Promise(function(resolve,reject){\n           var result = [];\n           var i=0;\n           function processData(index,res){\n               result[index] = res;\n               if(\x2b\x2bi==promiseArray.length){\n                   resolve(result)\n               } \n           }\n           promiseArray.forEach((item,index)=\x3e{\n               item.then(res=\x3e{processData(index,res)},reject)\n           })\n       })        \n };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([read(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e),read(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/2.txt\x27\x3c\/span\x3e)]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res)})\n \n \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epromiseArray\x3c\/span\x3e)\x3c\/span\x3e{               \n       \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n           \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n           \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocessData\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eindex,res\x3c\/span\x3e)\x3c\/span\x3e{\n               result[index] = res;\n               \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x2b\x2bi==promiseArray.length){\n                   resolve(result)\n               } \n           }\n           promiseArray.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem,index\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n               item.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{processData(index,res)},reject)\n           })\n       })        \n };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2.race方法，Pomise.race，顾名思义“赛拍”，传入多个异步promise，只要有一个成功，则就成功，有一个失败则失败，后面也可跟then方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.race = function(promiseArray){\n    return new Promise(function(resolve,reject){\n        promiseArray.forEach((item,index)=\x3e{\n            item.then(resolve,reject);\n        })\n    })\n}\nPromise.race([read(\x27.\/1.txt\x27),read(\x27.\/5.txt\x27)]).then(res=\x3e{console.log(res)},err=\x3e{console.log(err)})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.race = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epromiseArray\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n        promiseArray.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem,index\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n            item.then(resolve,reject);\n        })\n    })\n}\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.race([read(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e),read(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/5.txt\x27\x3c\/span\x3e)]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res)},err=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.生成一个成功的promise，把传入的参数，传入到then的成功回调中,该方法返回一个promise\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.resolve=function(value){\n    return new Promise(function(resolve,reject){\n        \/\/promise规范 resolve和reject函数必须是在异步回调中执行\n        setTimeout(function(){\n            resolve(value);\n        })\n    })\n}\nPromise.resolve(\x27123\x27).then(res=\x3e{console.log(res)})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise规范 resolve和reject函数必须是在异步回调中执行\x3c\/span\x3e\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            resolve(value);\n        })\n    })\n}\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27123\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res)})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.生成一个失败的promise，把传入的参数，传入到then的失败回调中。该方法返回一个promise\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.reject = function(err){\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            reject(err);\n        })\n\n    })\n}\nPromise.reject(\x27error\x27).then(res=\x3e{console.log(res)},err=\x3e{console.log(err)})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            reject(err);\n        })\n\n    })\n}\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res)},err=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5.catch托底捕获错误，这个方法是实例的共有方法，应该放到Promise的原型上，每一个                promise实例都可以调用.它支持一个参数，该参数是之前所有的then中，并没有失败回调，当发        生错误时，最后统一在catch中进行捕获\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.prototype.catch = function(calllback){\nreturn this.then(null,callback)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3ePromise.prototype.\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e(calllback){\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.then(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e6.很多人都用过jquery的deferrd对象，他和promise的deffer对象很类似。promise的deferred对象只是对promise进行了一次封装\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.defer = Promise.deferred=function(){\n    var obj = {};\n    obj.promise = new Promise(function(resolve,reject){\n        obj.resolve = resolve;\n        obj.reject = reject;\n    })\n    return obj;\n}\n    let fs = require(\x27fs\x27);\n function read2 (url){\n    var deferr = Promise.deferred();\n    fs.readFile(\x27.\/1.txt\x27,\x27utf8\x27,(err,res)=\x3e{\n        err?deferr.reject(err):deferr.resolve(res);\n    })\n     return deferr;\n}\nread2(\x27.\/1.txt\x27).then(data=\x3e{console.log(data)})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.defer = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.deferred=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {};\n    obj.promise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)\x3c\/span\x3e{\n        obj.resolve = resolve;\n        obj.reject = reject;\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj;\n}\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eread2\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e deferr = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.deferred();\n    fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,(err,res)=\x26gt;{\n        err?deferr.reject(err):deferr.resolve(res);\n    })\n     \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deferr;\n}\nread2(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，一个完整的Promise.js封装完成，当然最后是需要模块化导出的，我们采用CommonJS规范导出一个模块 采用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = Promise;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = Promise;\n\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>js处理异步函数：从callback到promise</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013871753">https://segmentfault.com/a/1190000013871753</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/4dfubuwj8kf/" target="_blank">https://alili.tech/archive/4dfubuwj8kf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>