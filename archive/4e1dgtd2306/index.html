<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="再谈JavaScript面向对象思想及继承"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>再谈JavaScript面向对象思想及继承 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/4e1dgtd2306/",
				"appid": "1613049289050283", 
				"title": "再谈JavaScript面向对象思想及继承 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-27T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qe19amcr0z9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rc7t740bam7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&text=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&text=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&title=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&is_video=false&description=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&title=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&title=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&title=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4e1dgtd2306%2f&title=%e5%86%8d%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%80%9d%e6%83%b3%e5%8f%8a%e7%bb%a7%e6%89%bf"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">再谈JavaScript面向对象思想及继承</h1><div class="meta"><div class="postdate"><time datetime="2018-12-27" itemprop="datePublished">2018-12-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e为什么说是再谈呢，网上讲解这个的博客的很多，我开始学习也是看过，敲过就没了，自以为理解了就结束了，书到用时方恨少啊。实际开发中一用就打磕巴，于是在重新学习了之后分享出来。开了这么一个宏观的题目，需要做一下简单说明，这篇文章将会讲解以下几个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e什么是面向对象编程思想，为什么要用面向对象思想。\x3c\/li\x3e\n\x3cli\x3ejs中的面向对象思想和其他静态语言相比有什么不同。\x3c\/li\x3e\n\x3cli\x3ejs中prototype，constructor，__proto__这些都是什么鬼？怎么用他们实现面向对象中的继承。\x3c\/li\x3e\n\x3cli\x3e一些小感悟小建议之类的吧啦吧啦。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e下面我们直接开始干货。。。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e面向对象 what\x27s it? why ues it?\x3c\/h2\x3e\n\x3cp\x3e什么是面向对象编程？当作者刚开始工作时，怀着对面向对象编程的无限敬仰和好奇，问了同事Java大牛这个问题，他的回答引我深思：不要面向对象编程，要面向工资编程。言归正传，面向对象中的对象，当然不是男女朋友的对象，ECMAScript中，对象是一个无序属性集，这里的“属性”可以是基本值、另一个对象或者函数。实际应用可以理解为一本书，一个人，一个班级，所以万物都是对象。对象的属性怎么理解，以人为例，指人的名字、身高、体重等等，对象的属性还可以是函数称之为方法，指代对象的一些操作，动作。如人的说话，走路等等。提到面向对象，那就需要提到面向过程，我们不用官方的方式来解释，从实际问题中思考。\x3c\/p\x3e\n\x3cp\x3e假设现在项目需求为画一个三角形，一个矩形。直接编写代码时，我们肯定考虑的是第一步 画三角形 第二步 画矩形。我们会编写一个三角形函数triangle() 一个矩形函数rect() 然后一步步调用，这是面向过程的思想。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function triangle() {...}\nfunction rect() {...}\n\ntriangle();\nrect();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3efunction triangle() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction rect() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\n\ntriangle();\nrect();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e面向对象中我们首先会抽象问题，矩形三角形都是对象，他们的类型都是形状。他们有各自的边长顶点，那么我们会先创建一个基本对象 形状 \x3ccode\x3eShape\x3c\/code\x3e 属性有顶点、边长，三角形\x3ccode\x3eTriangle\x3c\/code\x3e和矩形\x3ccode\x3eRect\x3c\/code\x3e都是基本对象扩展出的新对象，有各自的画图方法draw()，然后用对象得到具体的指向对象(即实例，后文解释)\x3ccode\x3etriangle\x3c\/code\x3e调用\x3ccode\x3edraw\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Shape() {...}\nfunction Triangle() {...}\nfunction Rect() {...}\n\nlet triangle = new Triang();\ntriangle.draw();\nlet rect = new Rect();\nrect.draw();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-type\x22\x3eShape\x3c\/span\x3e() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction \x3cspan class=\x22hljs-type\x22\x3eTriangle\x3c\/span\x3e() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction \x3cspan class=\x22hljs-type\x22\x3eRect\x3c\/span\x3e() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e triangle = new \x3cspan class=\x22hljs-type\x22\x3eTriang\x3c\/span\x3e();\ntriangle.draw();\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rect = new \x3cspan class=\x22hljs-type\x22\x3eRect\x3c\/span\x3e();\nrect.draw();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e面对一个问题，面向过程的思路是第一步做什么，第二步做什么 面向对象则需要先分析出问题中的对象都有什么，对象的属性、方法是什么，让对象要做什么。\x3cbr\x3e假设现在需要获得画出矩形的边长，面向对象中只需要在\x3ccode\x3eRect\x3c\/code\x3e中加上一个方法就可以，面向过程则需要拿到画出的矩形，再得到边长，相比较而言面向对象易于扩展。\x3c\/p\x3e\n\x3cp\x3e面向对象中有三大特征，封装，继承，多态。封装指将变化封装起来，外面调用时不需要知道内部的实现，继承指的是一个对象可以共享父级对象的一些属性，比如上文的问题中，形状\x3ccode\x3eShape\x3c\/code\x3e有顶点这个属性，三角形和矩形都可以继承该属性而不需要再重新定义。多态指的是封装之后的变化如何处理，比如上文中将\x3ccode\x3edraw\x3c\/code\x3e函数放在形状\x3ccode\x3eShape\x3c\/code\x3e中，内部实现就是连接点，三角形和矩形调用父级对象的\x3ccode\x3edraw\x3c\/code\x3e，三角形与矩形的顶点不同。\x3c\/p\x3e\n\x3cp\x3e为什么要使用面向对象？面向对象因为封装，继承，多态的特征使程序更易于扩展，维护，重用。比如在另外一个环境中我们需要画三角形，我们只需要将三角形这个对象及形状父级对象引入，剩下关于三角形的操作都是三角形这个对象的内部实现。维护起来去该对象的该方法找错，比在整个环境中找三角形函数要好很多。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3ejs中的面向对象\x3c\/h2\x3e\n\x3cp\x3e面向对象中类指的是同一类型对象的抽象，首字母大写，比如上文中的形状 \x3ccode\x3eShape\x3c\/code\x3e 类，三角形是通过\x3ccode\x3eShape\x3c\/code\x3e扩展而来，则也是一个类，\x3ccode\x3eShape\x3c\/code\x3e称之为它的父类，它是\x3ccode\x3eShape\x3c\/code\x3e的子类，同理 \x3ccode\x3eRect\x3c\/code\x3e也是\x3ccode\x3eShape\x3c\/code\x3e的一个子类。类的具体抽象称之为实例，通常为小写，创建实例的过程称之为实例化。上文中\x3ccode\x3etriangle\x3c\/code\x3e就是一个\x3ccode\x3eTriangle\x3c\/code\x3e三角形的实例，指具体画出的那个三角形。关于父类，子类，实例我们再用一个一个示例来展示\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22父类 Animal \n子类 Cat 实例 cat1_tom\n子类 Dog 实例 dog1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs inform7\x22\x3e\x3ccode\x3e父类 \x3cspan class=\x22hljs-keyword\x22\x3eAnimal\x3c\/span\x3e \n子类 Cat 实例 cat1_tom\n子类 Dog 实例 dog1\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eAnimal 指所有动物，Cat 指所有猫 继承Animal 是动物的一个子类，cat1_tom 指的具体一个叫 tom 的猫。有了类我们就需要给类加一些标识，以区分类之间的区别、即属性和方法。\x3c\/p\x3e\n\x3ch4\x3e1.走出‘类’，走进原型\x3c\/h4\x3e\n\x3cp\x3e当我们弄清楚了类是什么，JavaScript没有类的概念，是通过原型来实现面向对象。在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。\x3c\/p\x3e\n\x3cp\x3e从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。而克隆出来的这个对象会记住他的原型，由谁克隆而来，同时也会共享原型的属性和方法。这样一个一个对象克隆而来，则形成了一条原型链。对上文中的例子而言，三角形的原型是形状，猫和狗的原型是动物。\x3c\/p\x3e\n\x3ch4\x3e2.构造函数\x3c\/h4\x3e\n\x3cp\x3e在java中\x3ccode\x3enew Class()\x3c\/code\x3enew 之后跟的是一个类名，而在js中类之后跟的是一个构造函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Shape(name) {\n  this.val = 1;\n  this.name = name;\n  this.all = \x27图形\x27;\n  return this.name\n}\nlet a = Shape(\x27a\x27); \/\/ \x27a\x27\n\nlet shape1 = new Shape(\x27triangle\x27); \nlet shape2 = new Shape(\x27rect\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eShape\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.all = \x3cspan class=\x22hljs-string\x22\x3e\x27图形\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = Shape(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27a\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e shape1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Shape(\x3cspan class=\x22hljs-string\x22\x3e\x27triangle\x27\x3c\/span\x3e); \n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e shape2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Shape(\x3cspan class=\x22hljs-string\x22\x3e\x27rect\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数的定义与一般函数的定义相同，注意首字母大写。构造函数本质上还是一个函数，可以传参可以有返回值，只是内部使用了this变量，函数存在调用问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e直接调用：在浏览器环境中相当于在window上挂在了val这个属性，值为1。请注意这个特点，如果Shape.call(obj) 即相当于设定obj对象的val为1。\x3c\/li\x3e\n\x3cli\x3enew 调用：生成一个实例，即生成一个新对象，这个this指向当前新生成的对象。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3econstructor和prototype\x3c\/h2\x3e\n\x3cp\x3e这里的概念还希望大家阅读缓慢 最好能在浏览器或者node环境下敲一下理解更深。请首先一定理解何为实例何为构造函数(构造器)。他们的关系是 \x3cbr\x3e__A为B的构造函数 则 B为A的一个实例__。\x3c\/p\x3e\n\x3ch4\x3e在山的那边，海的那边，有一个prototype ，还有一个__proto__\x3c\/h4\x3e\n\x3cp\x3e首先创建一个Cat的构造函数，希望say是Cat的实例共享属性，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Cat(name) {\n  this.name = name;\n  this.say = function() {console.log(this.name)};\n}\n\nlet cat1 = new Cat(\x27tom\x27); \nlet cat2 = new Cat(\x27bob\x27);\ncat1.say === cat2.say \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)};\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27tom\x27\x3c\/span\x3e); \n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27bob\x27\x3c\/span\x3e);\ncat1.say === cat2.say \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是发现cat1 cat2的共有方法all并没有共享，每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费， 那么引入prototype对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Cat(name) {\n  this.name = name;\n}\nCat.prototype.say = function() {\n  console.log(this.name);\n}\nlet cat1 = new Cat(\x27tom\x27); \nlet cat2 = new Cat(\x27bob\x27);\ncat1.say === cat2.say \ncat1.say === Cat.prototype.say; \/\/ true\ncat1.prototype; \/\/ undefined\ncat1.hasOwnProperty(\x27say\x27);\/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\nCat.prototype.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27tom\x27\x3c\/span\x3e); \n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27bob\x27\x3c\/span\x3e);\ncat1.say === cat2.say \ncat1.say === Cat.prototype.say; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\ncat1.prototype; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\ncat1.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27say\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e__实例对象的constructor属性指向其构造函数(1)__，这样看起来实例对象好像“继承”了prototype对象一样。__实例没有prototype__，上文最后一行代码通过hasOwnPropertyk可以判断say这个方法并不是cat1自己的方法，__如果一个方法没有在实例对象自身找到，则向其构造函数prototype中开始寻找(2)__。\x3c\/p\x3e\n\x3cp\x3e既然实例是继承自构造器的prototype，那么有没有一个属性可以直接表示对象的继承关系呢？答案是有的\x3ccode\x3e__proto__\x3c\/code\x3e，很多浏览器都实现了这个属性，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat1.__proto__ === Cat.prototype \/\/ true\nCat.__proto__ === Function.prototype; \/\/ true\nFunction.prototype.__proto__ === Object.prototype; \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3ecat1.__proto__ === Cat.prototype \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nCat.__proto__ === \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eprototype\x3c\/span\x3e;\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eprototype\x3c\/span\x3e.__\x3cspan class=\x22hljs-title\x22\x3eproto__\x3c\/span\x3e === \x3cspan class=\x22hljs-title\x22\x3eObject\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eprototype\x3c\/span\x3e;\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上我们可以发现 Cat 构造器的原型为Function.prototype ，Cat.prototype的原型为Object.prototype，所以当cat1调toString时 Cat.prototype上没有找到 就去Function.prototype上寻找，这就构成了原型链。但是对象的原型链查找和构造函数的原型查找又有一点小区别(不查Function)，构造器生成的实例对象原型链的查找过程可以如下表示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat1 \n =\x3e cat1.__proto__(Cat.prototype) \n =\x3e cat1.__proto__.__proto__(Function.prototype) \n =\x3e cat1.__proto__.__proto__.__proto__ (Object.prototype)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3ecat1 \n =\x26gt; cat1.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e(Cat.prototype) \n =\x26gt; cat1.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e(Function.prototype) \n =\x26gt; cat1.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e.\x3cspan class=\x22hljs-strong\x22\x3e__proto__\x3c\/span\x3e (Object.prototype)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还有通过对象字面量创建的对象的原型链查找方式\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let obj = {};\nobj =\x3e obj.__proto__(Object.prototype) ;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ebnf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3elet obj\x3c\/span\x3e = {};\n\x3cspan class=\x22hljs-attribute\x22\x3eobj\x3c\/span\x3e =\x26gt; obj.__proto__(Object.prototype) ;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里根据上文__加粗(2)__的语言可以得到__Function.prototype 的构造函数是Object(3)__。关于两者的关系，我们后续继续讨论。\x3c\/p\x3e\n\x3ch4\x3e大家都有constructor\x3c\/h4\x3e\n\x3cp\x3e上文的两个实例对象cat1 cat2，他们都具有一个属性constructor，指向实例的构建函数Cat，意思是他们由Cat创建而来。__实例有一个constructor属性，指向其构造函数(4)__\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat1.constructor === Cat; \/\/ true\ncat1.constructor === Cat; \/\/ true\nCat.constructor === Function; \/\/ true\nCat.prototype.constructor === Cat; \/\/ true\n\nObject.constructor === Function;\/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3ecat1.\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e === Cat; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\ncat1.\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e === Cat; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nCat.\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e === \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e;\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nCat.prototype.\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e === Cat; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e === \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e;\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数同样具有construtor，指向Function，Cat.prototype同样具有construtor，指向他自身，__构造函数的prototype对象的constructor指向该构造函数(5)__。\x3c\/p\x3e\n\x3cp\x3e根据上文最后一行代码 可以判断Object 的构造函数 是Function。则我们可以得到Object是Function的一个实例。如下Object 与 Function的关系是\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eObject是Function的一个实例。\x3c\/li\x3e\n\x3cli\x3eFunction.prototype 是 Object 的 一个实例。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e根据上文总结如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e实例对象的constructor指向其构造器。\x3c\/li\x3e\n\x3cli\x3e实例对象没有prototype。\x3c\/li\x3e\n\x3cli\x3e实例对象可以通过构造函数的prototype对象实现属性方法共享。’\x3c\/li\x3e\n\x3cli\x3e实例对象的\x3ccode\x3e__proto__\x3c\/code\x3e原型指向其构造函数的prototype对象\x3c\/li\x3e\n\x3cli\x3e构造器的constructor指向 Function。\x3c\/li\x3e\n\x3cli\x3e构造函数的prototype可以挂在公共属性方法，prototype的constructor属性指向该构造函数。\x3c\/li\x3e\n\x3cli\x3e构造函数的\x3ccode\x3e__proto__\x3c\/code\x3e原型指向 Function.prototype。\x3c\/li\x3e\n\x3cli\x3e构造函数prototype对象的\x3ccode\x3e__proto__\x3c\/code\x3e原型指向Object.prototype。\x3c\/li\x3e\n\x3cli\x3e对象原型指的是对象的\x3ccode\x3e__proto__\x3c\/code\x3e属性。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch4\x3e继承方式的渐进式\x3c\/h4\x3e\n\x3cp\x3e通过上面的知识我们已经了解了原型的概念，接下来我们来一步一步实现基于原型的继承。\x3cbr\x3e在继承之前，我们有必要统一一下概念及名词，\x3c\/p\x3e\n\x3ch6\x3e实例的归实例 构造器的归构造器\x3c\/h6\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  let name = name; \/\/ 私有属性\n  this.getName = function() { \/\/ 特权方法 也是实例方法\n      this.log(name);\n    return name;\n  }\n  this.color = \x27none\x27; \/\/ 实例属性\n  this.say = function() { \/\/ 实例方法\n    console.log(this.color);\n  }\n}\nAnimal.prototype.a = 1; \/\/ 公共属性\nAnimal.prototype.log = function(sth) { \/\/ 公共方法\n  consoel.log(sth)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e name = name; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 私有属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 特权方法 也是实例方法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.log(name);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e name;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color);\n  }\n}\nAnimal.prototype.a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 公共属性\x3c\/span\x3e\nAnimal.prototype.log = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esth\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 公共方法\x3c\/span\x3e\n  consoel.log(sth)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ejs没有严格意义的私有成员，所以对象属性都算做公开，所以我们在私有 公有上不做赘述，只是判断改属性是在实例上 还是在构造函数的prototype上。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e私有属性：指的是构造器内部的属性，构造器外部不可以获得，只能通过特权方法来访问。\x3c\/li\x3e\n\x3cli\x3e特权方法：一般称有权访问私有变量和私有函数的公有方法为特权方法，但是js没有共有方法的概念，这个方法是挂载在实例上的。\x3c\/li\x3e\n\x3cli\x3e实例属性(方法)：实例属性指的是挂载在实例自身的属性。\x3c\/li\x3e\n\x3cli\x3e公共属性(方法)：公共属性指的是挂在在构造器的prototype对象上的属性。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch6\x3e1.  直接修改prototype\x3c\/h6\x3e\n\x3cp\x3e我们已经知道实例对象可以通过构造函数的prototype对象实现属性方法共享。即实例对象继承了构造器的.prototype对象，那么构造器和构造器之间的继承是不是也可以用这样的方式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal() {\n  this.special = \x27猫\x27;\n};\nfunction Cat() {}\nlet cat1 = new Cat();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.special = \x3cspan class=\x22hljs-string\x22\x3e\x27猫\x27\x3c\/span\x3e;\n};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上，cat1要继承Animal的special属性，\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e首先 cat1 作为构造器Cat 的一个实例可以继承 Cat.prototype 对象中得属性。\x3c\/li\x3e\n\x3cli\x3eCat.prototype 作为一个对象则应该继承 Animal.protoype.\x3c\/li\x3e\n\x3cli\x3eCat.prototype 应该作为构造函数Animal的一个实例。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal() {\n  this.special = \x27猫\x27;\n  this.arr = [2,3];\n};\nfunction Cat() {}\nCat.prototype = new Animal();\nlet cat1 = new Cat();\ncat1.special; \/\/ \x27猫\x27;\n\nlet cat2 = new Cat();\ncat1.special = \x27狗\x27;\ncat2.special; \/\/ \x27猫\x27\ncat1.special === Cat.prototype.special; \/\/ false\ncat1.arr.push(1);\ncat1.arr; \/\/ [2,3,1];\ncat1.arr; \/\/ [2,3,1];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.special = \x3cspan class=\x22hljs-string\x22\x3e\x27猫\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\nCat.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal();\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat();\ncat1.special; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27猫\x27;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat();\ncat1.special = \x3cspan class=\x22hljs-string\x22\x3e\x27狗\x27\x3c\/span\x3e;\ncat2.special; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27猫\x27\x3c\/span\x3e\ncat1.special === Cat.prototype.special; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\ncat1.arr.push(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ncat1.arr; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [2,3,1];\x3c\/span\x3e\ncat1.arr; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [2,3,1];\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然我们很简单就实现了继承，但是问题一转变，就出现了bug。比如我现在希望cat1 cat2 的special 都是公共属性，arr 是实例属性。可以发现cat1操作了special 这个公共属性，cat2.special并没有改变，但是cat1.arr 改变后 cat2.arr 也改变了。其次，构造器之间的继承不能传递参数，那让我们更正2.0\x3c\/p\x3e\n\x3ch6\x3e2. 构造函数的函数特性\x3c\/h6\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  this.name = name;\n  this.arr = [2,3];\n};\nAnimal.prototype.special = \x27猫\x27;\n\nfunction Cat(name) { \n  Animal.apply(this, arguments);\n}\n\nCat.prototype = new Animal();\n\nlet cat1 = new Cat(\x27tom\x27);\nlet cat2 = new Cat(\x27mary\x27);\n\ncat1.special = \x27狗\x27; \ncat2.special; \/\/ 猫;\ncat1.hasOwnProperty(\x27special\x27); \/\/ true\ncat2.hasOwnProperty(\x27special;); \/\/ false,\n\ncat1.arr.push(1);\ncat1.arr; \/\/ [2,3,1];\ncat2.arr; \/\/ [2,3];\n\ncat1.name; \/\/ \x27tom\x27\ncat2.name; \/\/ \x27mary\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e\x3c\/span\x3e(name) {\n  \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n};\nAnimal.prototype.special = \x3cspan class=\x22hljs-string\x22\x3e\x27猫\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e\x3c\/span\x3e(name) { \n  Animal.apply(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, arguments);\n}\n\nCat.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eAnimal\x3c\/span\x3e();\n\nlet cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27tom\x27\x3c\/span\x3e);\nlet cat2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27mary\x27\x3c\/span\x3e);\n\ncat1.special = \x3cspan class=\x22hljs-string\x22\x3e\x27狗\x27\x3c\/span\x3e; \ncat2.special; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 猫;\x3c\/span\x3e\ncat1.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27special\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\ncat2.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27special;); \/\/ false,\n\ncat1.arr.push(1);\ncat1.arr; \/\/ [2,3,1];\ncat2.arr; \/\/ [2,3];\n\ncat1.name; \/\/ \x27\x3c\/span\x3etom\x3cspan class=\x22hljs-string\x22\x3e\x27\ncat2.name; \/\/ \x27\x3c\/span\x3emary\x3cspan class=\x22hljs-string\x22\x3e\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3especial作为公共的属性挂载在父级构造器prototype上，虽然我们修改了cat1.special cat2.special没有改变，这主要是因为cat1.special 的改变是作用在实例而不是原型上，大家可以把这个公共属性改成数组或对象 作为一个引用存储，就可以发现special是公共属性。cat1.arr的操作不影响cat2.arr的操作。而且可以实现构造器直接传参，这里实在子级构造器的内部直接调用父级构造器，构造器调用方式的区别前文也介绍过了。\x3c\/p\x3e\n\x3cp\x3e看到这里，好像我们已经实现继承了，但是依然存在问题啊。代码的构建从来都是改大于写。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat1.constructor; \/\/ [Function: Animal]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coq\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ecat1.\x3cspan class=\x22hljs-built_in\x22\x3econstructor\x3c\/span\x3e; \/\/ [\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e: Animal]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e前文提到实例对象的constructor属性应该指向其构造函数，这里直接指向了父级构造器；在Cat构造器内部有一份Animal的实例属性，在Cat.prototype上同样有一份Animal的实例属性，属性重复。\x3c\/p\x3e\n\x3ch6\x3e3. 利用空构造器过滤实例属性\x3c\/h6\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  this.name = name;\n  this.arr = [2,3];\n};\nAnimal.prototype.special = \x27猫\x27;\n\nfunction Cat(name) { \n  Animal.apply(this, arguments);\n}\n\nlet F = function() {};\nF.prototype = Animal.prototype;\nCat.prototype = new F();\nCat.prototype.constructor = Cat;\nCat.__proto__ = Animal.prototype;\n\nlet cat1 = new Cat(\x27tom\x27);\nlet cat2 = new Cat(\x27mary\x27);\n\ncat1.constructor;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n};\nAnimal.prototype.special = \x3cspan class=\x22hljs-string\x22\x3e\x27猫\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{ \n  Animal.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{};\nF.prototype = Animal.prototype;\nCat.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\nCat.prototype.constructor = Cat;\nCat.__proto__ = Animal.prototype;\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27tom\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cat2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27mary\x27\x3c\/span\x3e);\n\ncat1.constructor;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里新建了一个空构造器 F() 让F.prototype = Animal.prototype，子级构造器\x3cbr\x3eCat.prototype = new F(); 这样在Cat.prototype中就没有那一份Animal实例化之后的数据。再将Cat.prototype.constructor 重新指会 构造器本身，则cat1.constructor ye的指向也没有问题了。同时修正了Cat的原型指向。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e首先感谢阅读完全文，到这里，相信基本对于原型继承实现面向对象编程没有什么问题了。之后的主要矛盾在于问题的抽象上，如何抽象合适的对象，哪些属性和方法作为公共的，哪些作为实例的，这只有日积月累的经验才能给自己最好的答案。关键还是在于理解了基础概念，多用，多练，就会发先问题。我就是自以为理解了，但是在construtor指向上老犯糊涂，还有关于Object 与 Function，多用是加深理解的最好方式了，不妨以后再解决问题是，多考虑一下面向对象。\x3c\/p\x3e\n\x3cp\x3e其次，不能限定自己必须使用什么，不管是黑猫还是白猫，抓住老鼠就是好猫，代码的最终目的是为解决问题而生，同时代码是用来读的，不论是什么样的编程思路，逻辑清晰，可扩展，可复用，健壮性完好那就是好代码。\x3c\/p\x3e\n\x3cp\x3e最后的最后，文中若有错误，还请及时指正。最后一个学习方法的分享，当接触一个新的知识点或者工具，1.先会用 知道这个东西是什么(what?) 怎么用(how?)， 2. 会用之后不妨了解一下原理看看内部实现（why?)，3. 等研究的比较深刻了，自然而然对在何种情况使用(where, when)。编程学习还是要带着问题去学习，有问题，才会记得更深刻，没问题的两种人，要么真的会了，要么一点都不会，再次感谢阅读~~~~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>再谈JavaScript面向对象思想及继承</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011770117">https://segmentfault.com/a/1190000011770117</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/4e1dgtd2306/" target="_blank">https://alili.tech/archive/4e1dgtd2306/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>