<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="谈谈前端异常捕获与上报"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>谈谈前端异常捕获与上报 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5dgy9o9cvqf/",
				"appid": "1613049289050283", 
				"title": "谈谈前端异常捕获与上报 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2t0c52b56b/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/e77jkqqljw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&text=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&text=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&title=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&is_video=false&description=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&title=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&title=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&title=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5dgy9o9cvqf%2f&title=%e8%b0%88%e8%b0%88%e5%89%8d%e7%ab%af%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7%e4%b8%8e%e4%b8%8a%e6%8a%a5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">谈谈前端异常捕获与上报</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e关于\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e微信公众号：前端呼啦圈（Love-FED）\x3c\/li\x3e\n\x3cli\x3e我的博客：\x3ca href=\x22http:\/\/www.cnblogs.com\/luozhihao\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e劳卜的博客\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e知乎专栏：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/font-end\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端呼啦圈\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3eHello，大家好，又与大家见面了，这次给大家分享下前端异常监控中需要了解的异常捕获与上报机制的一些要点，同时包含了实战性质的参考代码和流程。\x3c\/p\x3e\n\x3cp\x3e首先，我们为什么要进行异常捕获和上报呢？\x3c\/p\x3e\n\x3cp\x3e正所谓百密一疏，一个经过了大量测试及联调的项目在有些时候还是会有十分隐蔽的bug存在，这种复杂而又不可预见性的问题唯有通过完善的监控机制才能有效的减少其带来的损失，因此对于直面用户的前端而言，异常捕获与上报是至关重要的。\x3c\/p\x3e\n\x3cp\x3e虽然目前市面上已经有一些非常完善的前端监控系统存在，如\x3ca href=\x22https:\/\/sentry.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esentry\x3c\/a\x3e、\x3ca href=\x22https:\/\/www.bugsnag.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebugsnag\x3c\/a\x3e等，但是知己知彼，才能百战不殆，唯有了解原理，摸清逻辑，使用起来才能得心应手。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e异常捕获方法\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1. try catch\x3c\/h3\x3e\n\x3cp\x3e通常，为了判断一段代码中是否存在异常，我们会这一写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22try {\n    var a = 1;\n    var b = a \x2b c;\n} catch (e) {\n    \/\/ 捕获处理\n    console.log(e); \/\/ ReferenceError: c is not defined\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = a \x2b c;\n} \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 捕获处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ReferenceError: c is not defined\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用try catch能够很好的捕获异常并对应进行相应处理，不至于让页面挂掉，但是其存在一些弊端，比如需要在捕获异常的代码上进行包裹，会导致页面臃肿不堪，不适用于整个项目的异常捕获。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2. window.onerror\x3c\/h3\x3e\n\x3cp\x3e相比try catch来说window.onerror提供了全局监听异常的功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) {\n    console.log(\x27errorMessage: \x27 \x2b errorMessage); \/\/ 异常信息\n    console.log(\x27scriptURI: \x27 \x2b scriptURI); \/\/ 异常文件路径\n    console.log(\x27lineNo: \x27 \x2b lineNo); \/\/ 异常行号\n    console.log(\x27columnNo: \x27 \x2b columnNo); \/\/ 异常列号\n    console.log(\x27error: \x27 \x2b error); \/\/ 异常堆栈信息\n};\n\nconsole.log(a);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerrorMessage, scriptURI, lineNo, columnNo, error\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27errorMessage: \x27\x3c\/span\x3e \x2b errorMessage); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常信息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27scriptURI: \x27\x3c\/span\x3e \x2b scriptURI); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常文件路径\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27lineNo: \x27\x3c\/span\x3e \x2b lineNo); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常行号\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27columnNo: \x27\x3c\/span\x3e \x2b columnNo); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常列号\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27error: \x27\x3c\/span\x3e \x2b error); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常堆栈信息\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013983115?w=700\x26amp;h=244\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013983115?w=700\x26amp;h=244\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ewindow.onerror即提供了我们错误的信息，还提供了错误行列号，可以精准的进行定位，如此似乎正是我们想要的，但是接下来便是填坑过程。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e异常捕获问题\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e1. Script error.\x3c\/h3\x3e\n\x3cp\x3e我们合乎情理地在本地页面进行尝试捕获异常，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!-- http:\/\/localhost:3031\/ --\x3e\n\x3cscript\x3e\nwindow.onerror = function() {\n    console.log(arguments);\n};\n\x3c\/script\x3e\n\x3cscript src=\x26quot;http:\/\/cdn.xxx.com\/index.js\x26quot;\x3e\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- http:\/\/localhost:3031\/ --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n};\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/cdn.xxx.com\/index.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们把静态资源放到异域上进行优化加载，但是捕获的异常信息却是：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013983116?w=701\x26amp;h=227\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013983116?w=701\x26amp;h=227\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e经过分析发现，跨域之后window.onerror是无法捕获异常信息的，所以统一返回Script error.，解决方案便是script属性配置 crossorigin=\x22anonymous\x22 并且服务器添加Access-Control-Allow-Origin。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;http:\/\/cdn.xxx.com\/index.js\x26quot; crossorigin=\x26quot;anonymous\x26quot;\x3e\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/cdn.xxx.com\/index.js\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecrossorigin\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22anonymous\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一般的CDN网站都会将Access-Control-Allow-Origin配置为*，意思是所有域都可以访问。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2. sourceMap\x3c\/h3\x3e\n\x3cp\x3e解决跨域或者将脚本存放在同域之后，你可能会将代码压缩一下再发布，这时候便出现了压缩后的代码无法找到原始报错位置的问题。如图，我们用webpack将代码打包压缩成bundle.js：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ webpack.config.js\nvar path = require(\x27path\x27);\n\n\/\/ webpack 4.1.1\nmodule.exports = {\n    mode: \x27development\x27,\n    entry: \x27.\/client\/index.js\x27,\n    output: {\n        filename: \x27bundle.js\x27,\n        path: path.resolve(__dirname, \x27client\x27)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack.config.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack 4.1.1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n    \x3cspan class=\x22hljs-attr\x22\x3emode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27development\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eentry\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/client\/index.js\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eoutput\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27bundle.js\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27client\x27\x3c\/span\x3e)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后我们页面引入的脚本文件是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22!function(e){var o={};function n(r){if(o[r])return o[r].exports;var t=o[r]={i:r,l:!1,exports:{\x22}}\x22...;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e!\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o={};\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3en\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3er\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(o[r])\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e o[r].exports;\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e t=o[r]={\x3cspan class=\x22hljs-attr\x22\x3ei\x3c\/span\x3e:r,\x3cspan class=\x22hljs-attr\x22\x3el\x3c\/span\x3e:!\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3eexports\x3c\/span\x3e:{\x22}}\x22...;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以我们看到的异常信息是这样的：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013983117?w=699\x26amp;h=240\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013983117?w=699\x26amp;h=240\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3elineNo可能是一个非常小的数字，一般是1，而columnNo会是一个很大的数字，这里是730，因为所有代码都压缩到了一行。\x3c\/p\x3e\n\x3cp\x3e那么该如何解决呢？聪明的童鞋可能已经猜到启用source-map了，没错，我们利用webpack打包压缩后生成一份对应脚本的map文件就能进行追踪了，在webpack中开启source-map功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n    ...\n    devtool: \x27#source-map\x27,\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n    ...\n    devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27#source-map\x27\x3c\/span\x3e,\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e打包压缩的文件末尾会带上这样的注释：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22!function(e){var o={};function n(r){if(o[r])return o[r].exports;var t=o[r]={i:r,l:!1,exports:{\x22}}\x22...;\n\/\/# sourceMappingURL=bundle.js.map\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e!\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o={};\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3en\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3er\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(o[r])\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e o[r].exports;\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e t=o[r]={\x3cspan class=\x22hljs-attr\x22\x3ei\x3c\/span\x3e:r,\x3cspan class=\x22hljs-attr\x22\x3el\x3c\/span\x3e:!\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3eexports\x3c\/span\x3e:{\x22}}\x22...;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/# sourceMappingURL=bundle.js.map\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e意思是该文件对应的map文件为bundle.js.map。下面便是一个source-map文件的内容，是一个JSON对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22version: 3, \/\/ Source map的版本\nsources: [\x26quot;webpack:\/\/\/webpack\/bootstrap\x26quot;, ...], \/\/ 转换前的文件\nnames: [\x26quot;installedModules\x26quot;, \x26quot;__webpack_require__\x26quot;, ...], \/\/ 转换前的所有变量名和属性名\nmappings: \x26quot;aACA,IAAAA,KAGA,SAAAC...\x26quot;, \/\/ 记录位置信息的字符串\nfile: \x26quot;bundle.js\x26quot;, \/\/ 转换后的文件名\nsourcesContent: [\x26quot;\/\/ The module cache var installedModules = {};...\x26quot;], \/\/ 源代码\nsourceRoot: \x26quot;\x26quot; \/\/ 转换前的文件所在的目录\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eversion: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Source map的版本\x3c\/span\x3e\nsources: [\x3cspan class=\x22hljs-string\x22\x3e\x22webpack:\/\/\/webpack\/bootstrap\x22\x3c\/span\x3e, ...], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换前的文件\x3c\/span\x3e\nnames: [\x3cspan class=\x22hljs-string\x22\x3e\x22installedModules\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22__webpack_require__\x22\x3c\/span\x3e, ...], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换前的所有变量名和属性名\x3c\/span\x3e\nmappings: \x3cspan class=\x22hljs-string\x22\x3e\x22aACA,IAAAA,KAGA,SAAAC...\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录位置信息的字符串\x3c\/span\x3e\nfile: \x3cspan class=\x22hljs-string\x22\x3e\x22bundle.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换后的文件名\x3c\/span\x3e\nsourcesContent: [\x3cspan class=\x22hljs-string\x22\x3e\x22\/\/ The module cache var installedModules = {};...\x22\x3c\/span\x3e], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 源代码\x3c\/span\x3e\nsourceRoot: \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换前的文件所在的目录\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你想详细了解关于sourceMap的知识，可以前往：\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2013\/01\/javascript_source_map.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Source Map 详解\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e如此，既然我们拿到了对应脚本的map文件，那么我们该如何进行解析获取压缩前文件的异常信息呢？这个我会在下面异常上报的时候进行介绍。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e3. MVVM框架\x3c\/h3\x3e\n\x3cp\x3e现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，那么很可能会竹篮打水一场空，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。比如\x3cstrong\x3eVue 2.x中我们应该这样捕获全局异常\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.config.errorHandler = function (err, vm, info) {\n    let { \n        message, \/\/ 异常信息\n        name, \/\/ 异常名称\n        script,  \/\/ 异常脚本url\n        line,  \/\/ 异常行号\n        column,  \/\/ 异常列号\n        stack  \/\/ 异常堆栈信息\n    } = err;\n    \n    \/\/ vm为抛出异常的 Vue 实例\n    \/\/ info为 Vue 特定的错误信息，比如错误所在的生命周期钩子\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.config.errorHandler = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr, vm, info\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e { \n        message, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常信息\x3c\/span\x3e\n        name, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常名称\x3c\/span\x3e\n        script,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常脚本url\x3c\/span\x3e\n        line,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常行号\x3c\/span\x3e\n        column,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常列号\x3c\/span\x3e\n        stack  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常堆栈信息\x3c\/span\x3e\n    } = err;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm为抛出异常的 Vue 实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ info为 Vue 特定的错误信息，比如错误所在的生命周期钩子\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e目前script、line、column这3个信息打印出来是undefined，不过这些信息在stack中都可以找到，可以通过正则匹配去进行获取，然后进行上报。\x3c\/p\x3e\n\x3cp\x3e同样的在react也提供了异常处理的方式，在 React 16.x 版本中引入了 Error Boundary：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    componentDidCatch(error, info) {\n        this.setState({ hasError: true });\n        \n        \/\/ 将异常信息上报给服务器\n        logErrorToMyService(error, info); \n    }\n\n    render() {\n        if (this.state.hasError) {\n            return \x27出错了\x27;\n        }\n    \n        return this.props.children;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eErrorBoundary\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { \x3cspan class=\x22hljs-attr\x22\x3ehasError\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e };\n    }\n\n    componentDidCatch(error, info) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3ehasError\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将异常信息上报给服务器\x3c\/span\x3e\n        logErrorToMyService(error, info); \n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasError) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27出错了\x27\x3c\/span\x3e;\n        }\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们就可以这样使用该组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cErrorBoundary\x3e\n    \x3cMyWidget \/\x3e\n\x3c\/ErrorBoundary\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs apache\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;ErrorBoundary\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;MyWidget \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/ErrorBoundary\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e详见官方文档：\x3ca href=\x22https:\/\/reactjs.org\/blog\/2017\/07\/26\/error-handling-in-react-16.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eError Handling in React 16\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e异常上报\x3c\/h2\x3e\n\x3cp\x3e以上介绍了前端异常捕获的相关知识点，那么接下来我们既然成功捕获了异常，那么该如何上报呢？\x3c\/p\x3e\n\x3cp\x3e在脚本代码没有被压缩的情况下可以直接捕获后上传对应的异常信息，这里就不做介绍了，下面主要讲解常见的处理压缩文件上报的方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e1. 提交异常\x3c\/h3\x3e\n\x3cp\x3e当捕获到异常时，我们可以将异常信息传递给接口，以window.onerror为例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) {\n\n    \/\/ 构建错误对象\n    var errorObj = {\n        errorMessage: errorMessage || null,\n        scriptURI: scriptURI || null,\n        lineNo: lineNo || null,\n        columnNo: columnNo || null,\n        stack: error \x26amp;\x26amp; error.stack ? error.stack : null\n    };\n\n    if (XMLHttpRequest) {\n        var xhr = new XMLHttpRequest();\n    \n        xhr.open(\x27post\x27, \x27\/middleware\/errorMsg\x27, true); \/\/ 上报给node中间层处理\n        xhr.setRequestHeader(\x27Content-Type\x27, \x27application\/json\x27); \/\/ 设置请求头\n        xhr.send(JSON.stringify(errorObj)); \/\/ 发送参数\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerrorMessage, scriptURI, lineNo, columnNo, error\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构建错误对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e errorObj = {\n        \x3cspan class=\x22hljs-attr\x22\x3eerrorMessage\x3c\/span\x3e: errorMessage || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3escriptURI\x3c\/span\x3e: scriptURI || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3elineNo\x3c\/span\x3e: lineNo || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecolumnNo\x3c\/span\x3e: columnNo || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3estack\x3c\/span\x3e: error \x26amp;\x26amp; error.stack ? error.stack : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    };\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (XMLHttpRequest) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\n    \n        xhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x27post\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\/middleware\/errorMsg\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上报给node中间层处理\x3c\/span\x3e\n        xhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27Content-Type\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置请求头\x3c\/span\x3e\n        xhr.send(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(errorObj)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发送参数\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e2. sourceMap解析\x3c\/h3\x3e\n\x3cp\x3e其实source-map格式的文件是一种数据类型，既然是数据类型那么肯定有解析它的办法，目前市面上也有专门解析它的相应工具包，在浏览器环境或者node环境下比较流行的是一款叫做\x27source-map\x27的插件。\x3c\/p\x3e\n\x3cp\x3e通过require该插件，前端浏览器可以对map文件进行解析，但因为前端解析速度较慢，所以这里不做推荐，我们还是使用服务器解析。如果你的应用有node中间层，那么你完全可以将异常信息提交到中间层，然后解析map文件后将数据传递给后台服务器，中间层代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const express = require(\x27express\x27);\nconst fs = require(\x27fs\x27);\nconst router = express.Router();\nconst fetch = require(\x27node-fetch\x27);\nconst sourceMap = require(\x27source-map\x27);\nconst path = require(\x27path\x27);\nconst resolve = file =\x3e path.resolve(__dirname, file);\n\n\/\/ 定义post接口\nrouter.post(\x27\/errorMsg\/\x27, function(req, res) {\n    let error = req.body; \/\/ 获取前端传过来的报错对象\n    let url = error.scriptURI; \/\/ 压缩文件路径\n\n    if (url) {\n        let fileUrl = url.slice(url.indexOf(\x27client\/\x27)) \x2b \x27.map\x27; \/\/ map文件路径\n\n        \/\/ 解析sourceMap\n        let smc = new sourceMap.SourceMapConsumer(fs.readFileSync(resolve(\x27..\/\x27 \x2b fileUrl), \x27utf8\x27)); \/\/ 返回一个promise对象\n        \n        smc.then(function(result) {\n        \n            \/\/ 解析原始报错数据\n            let ret = result.originalPositionFor({\n                line: error.lineNo, \/\/ 压缩后的行号\n                column: error.columnNo \/\/ 压缩后的列号\n            });\n            \n            let url = \x27\x27; \/\/ 上报地址\n        \n            \/\/ 将异常上报至后台\n            fetch(url, {\n                method: \x27POST\x27,\n                headers: {\n                    \x27Content-Type\x27: \x27application\/json\x27\n                },\n                body: JSON.stringify({\n                    errorMessage: error.errorMessage, \/\/ 报错信息\n                    source: ret.source, \/\/ 报错文件路径\n                    line: ret.line, \/\/ 报错文件行号\n                    column: ret.column, \/\/ 报错文件列号\n                    stack: error.stack \/\/ 报错堆栈\n                })\n            }).then(function(response) {\n                return response.json();\n            }).then(function(json) {\n                res.json(json);         \n            });\n        })\n    }\n});\n\nmodule.exports = router;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e express = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27express\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e router = express.Router();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fetch = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27node-fetch\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sourceMap = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resolve = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e =\x26gt;\x3c\/span\x3e path.resolve(__dirname, file);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义post接口\x3c\/span\x3e\nrouter.post(\x3cspan class=\x22hljs-string\x22\x3e\x27\/errorMsg\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e error = req.body; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取前端传过来的报错对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e url = error.scriptURI; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩文件路径\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (url) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e fileUrl = url.slice(url.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27client\/\x27\x3c\/span\x3e)) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27.map\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ map文件路径\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析sourceMap\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e smc = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e sourceMap.SourceMapConsumer(fs.readFileSync(resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/\x27\x3c\/span\x3e \x2b fileUrl), \x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个promise对象\x3c\/span\x3e\n        \n        smc.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) \x3c\/span\x3e{\n        \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析原始报错数据\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ret = result.originalPositionFor({\n                \x3cspan class=\x22hljs-attr\x22\x3eline\x3c\/span\x3e: error.lineNo, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩后的行号\x3c\/span\x3e\n                column: error.columnNo \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩后的列号\x3c\/span\x3e\n            });\n            \n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上报地址\x3c\/span\x3e\n        \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将异常上报至后台\x3c\/span\x3e\n            fetch(url, {\n                \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27POST\x27\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3eheaders\x3c\/span\x3e: {\n                    \x3cspan class=\x22hljs-string\x22\x3e\x27Content-Type\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e\n                },\n                \x3cspan class=\x22hljs-attr\x22\x3ebody\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify({\n                    \x3cspan class=\x22hljs-attr\x22\x3eerrorMessage\x3c\/span\x3e: error.errorMessage, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错信息\x3c\/span\x3e\n                    source: ret.source, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错文件路径\x3c\/span\x3e\n                    line: ret.line, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错文件行号\x3c\/span\x3e\n                    column: ret.column, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错文件列号\x3c\/span\x3e\n                    stack: error.stack \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错堆栈\x3c\/span\x3e\n                })\n            }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response.json();\n            }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ejson\x3c\/span\x3e) \x3c\/span\x3e{\n                res.json(json);         \n            });\n        })\n    }\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = router;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们通过前端传过来的异常文件路径获取服务器端map文件地址，然后将压缩后的行列号传递给sourceMap返回的promise对象进行解析，通过originalPositionFor方法我们能获取到原始的报错行列号和文件地址，最后通过ajax将需要的异常信息统一传递给后台存储，完成异常上报。下图可以看到控制台打印出了经过解析后的真是报错位置和文件：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013983118?w=558\x26amp;h=224\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013983118?w=558\x26amp;h=224\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e附：\x3ca href=\x22https:\/\/www.npmjs.com\/package\/source-map\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esource-map API\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e3. 注意点\x3c\/h3\x3e\n\x3cp\x3e以上是异常捕获和上报的主要知识点和流程，还有一些需要注意的地方，比如你的应用访问量很大，那么一个小异常都可能会把你的服务器搞挂，所以上报的时候可以进行信息过滤和采样等，设置一个调控开关，服务器也可以对相似的异常进行过滤，在一个时间段内不进行多次存储。另外window.onerror这样的异常捕获不能捕获promise的异常错误信息，这点需要注意。\x3c\/p\x3e\n\x3cp\x3e最终大致的流程图如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013983119?w=850\x26amp;h=627\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013983119?w=850\x26amp;h=627\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e结语\x3c\/h2\x3e\n\x3cp\x3e前端异常捕获与上报是前端异常监控的前提，了解并做好了异常数据的收集和分析才能实现一个完善的错误响应和处理机制，最终达成数据可视化。本文详细实例代码地址：\x3ca href=\x22https:\/\/github.com\/luozhihao\/error-catch-report\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/luozhihao\/error-catch-report\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>谈谈前端异常捕获与上报</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013983109">https://segmentfault.com/a/1190000013983109</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5dgy9o9cvqf/" target="_blank">https://alili.tech/archive/5dgy9o9cvqf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>