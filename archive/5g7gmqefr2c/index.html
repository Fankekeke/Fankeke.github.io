<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="很少教程会教你的：ReactJS最佳实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>很少教程会教你的：ReactJS最佳实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5g7gmqefr2c/",
				"appid": "1613049289050283", 
				"title": "很少教程会教你的：ReactJS最佳实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/nh8rh70wc1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ukjzk74300f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&text=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&text=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&title=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&is_video=false&description=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&title=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&title=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&title=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5g7gmqefr2c%2f&title=%e5%be%88%e5%b0%91%e6%95%99%e7%a8%8b%e4%bc%9a%e6%95%99%e4%bd%a0%e7%9a%84%ef%bc%9aReactJS%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">很少教程会教你的：ReactJS最佳实践</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e1 前言\x3c\/h2\x3e\n\x3cp\x3e我自己使用ReactJS有一定时间了，慢慢的也积累了很多所谓的Best Practice，之前内容比较少，都是记在脑子里，后来就记在有道云笔记里，而且原本打算在团队内部开分享会议的时候，在团队内部分享的，但由于种种原因一直没有机会，索性干脆整理一下分享在社区了，也省的像之前用AngularJS的时候，有很多的心得在长时间不用之后慢慢都忘记了。正所谓好记性不如烂笔头嘛，尤其是时间久了。\x3c\/p\x3e\n\x3cp\x3e以下所有的代码，内容几乎都是ES6，如果你还没有开始用ES6代码，可以在准备好简历之后，恶狠狠的指着你们总监的鼻子羞辱他，因为我个人觉得离开ES6，ReactJS带来的开发的便捷性会大打折扣。好不了解ES6的猿可以去网上找阮一峰老师的在线教程，九浅一深，啊不！由浅入深的学习ES6。文章也假设你对React有一定的了解，知道React的各个生命周期阶段的函数，但不要求精通。（这不废话嘛！精通了还看这篇文章干嘛。）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2 奇淫技巧\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e2.1 \x3ccode\x3econtext\x3c\/code\x3e的妙用\x3c\/h3\x3e\n\x3ch4\x3e2.1.1 使用场景\x3c\/h4\x3e\n\x3cp\x3e话不多说，看图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXFKY?w=800\x26amp;h=448\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXFKY?w=800\x26amp;h=448\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图片来源：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004636213\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e有时候会有这样一种情况，组件嵌套层次很深，而最又内层组件又需要最外层组件的一个属性，比如图中D组件需要A组件中的一个属性username，这时候最容易想到的就是:A组件内把这个username作为props传给B组件，B组件再原封不动的传给C组件，C再传给D，而B,C组件有可能都没有用到这个username，只是作为中间媒介在传递属性。但是你依然不得不书写这个props，针对这种情况就可以用到ReactJS中的context。\x3c\/p\x3e\n\x3ch4\x3e2.1.2 使用方法\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 组件A\nclass A extends Component {\n    \/\/ 其他代码省略，只上关键代码\n    constructor(props) {\n        super(props);\n        this.state = {\n            username: \x27Neil\x27\n        };\n    }\n    getChildContext() {\n        return {\n            username: this.state.username\n        };\n    }\n}\n\nA.childContextTypes = {\n    username: PropTypes.string\n};\n\n\/\/ 组件D\nclass D extends Component {\n    render() {\n        return \x3cdiv\x3e{this.context.username}\x3c\/div\x3e\n    }\n}\nD.contextChild = {\n    username: PropTypes.string\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 组件A\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其他代码省略，只上关键代码\x3c\/span\x3e\n    constructor(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            username: \x3cspan class=\x22hljs-symbol\x22\x3e\x27Nei\x3c\/span\x3el\x27\n        };\n    }\n    getChildContext() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            username: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.username\n        };\n    }\n}\n\n\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e.childContextTypes = {\n    username: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.string\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 组件D\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eD\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.username}\x26lt;\/div\x26gt;\n    }\n}\n\x3cspan class=\x22hljs-type\x22\x3eD\x3c\/span\x3e.contextChild = {\n    username: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.string\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到\x3ccode\x3econtext\x3c\/code\x3e的使用还是比较简单的，根组件A作为\x3ccode\x3eContext Provider\x3c\/code\x3e,需要在其中添加一个成员方法\x3ccode\x3egetChildContext\x3c\/code\x3e（该方法必须返回一个对象），和一个静态属性\x3ccode\x3echildContextTypes\x3c\/code\x3e。然后为任何一个你想使用该context的子组件添加一个静态属性\x3ccode\x3econtextTypes\x3c\/code\x3e来告诉React你要用哪个\x3ccode\x3econtext\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e2.1.3 注意事项\x3c\/h4\x3e\n\x3cp\x3e虽然使用比较简单，但是官方也明确表示，并不推荐使用context，因为这会使得原本简单并可控的React单向数据流变得复杂，不可预期。所以使用中还是有以下几点需要注意：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e推荐把不经常变动的值作为context传递，比如在组件树中，username就像一个全局常量一样，不经常变动。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e在上面的例子中，组件使用context以后，在D组件的生命周期的这几个函数中会有额外多余的参数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3econstructor(props, context)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillReceiveProps(nextProps, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eshouldComponentUpdate(nextProps, nextState, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillUpdate(nextProps, nextState, nextContext)\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e在React15之前的本版本中，\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e会有\x3ccode\x3eprevContext\x3c\/code\x3e参数，但是最新的React16版本不再接收此参数。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e在无状态的函数式组件（\x3ccode\x3eStateless Functional Components\x3c\/code\x3e，关于什么是函数式组件，后面会讲到）中也可以使用\x3ccode\x3econtext\x3c\/code\x3e，比如：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const D = (props, context) =\x3e {\n    return \x3cdiv\x3e{context.username}\x3c\/div\x3e\n};\n\nD.contextChild = {username: PropTypes.string};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e D = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops, context\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{context.username}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n};\n\nD.contextChild = {\x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e: PropTypes.string};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e尽量不要更新\x3ccode\x3econtext\x3c\/code\x3e。\x3ccode\x3econtext\x3c\/code\x3e只适用于传递那些不经常变动的变量，但是如果你不得不更改context，例如上面的例子中A组件中的username实际上来自于A的\x3ccode\x3estate\x3c\/code\x3e，假如我们在A中调用\x3ccode\x3ethis.setState({username: \x27Michel\x27})\x3c\/code\x3e， 那么在D组件中context也会更新。因为A组件中声明的\x3ccode\x3egetChildContext\x3c\/code\x3e方法在A组件的初始化阶段和更新阶段都会被调用。\x3cstrong\x3e但要注意的是，假如B组件或者C组件实现了\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，并在某些条件下返回了false，那么，D组件中的context将不会再更新。\x3c\/strong\x3e因为此时，B组件或者C组件的render并不会重新被调用。D组件也就不会更新（换句话说，在D组件生命周期的更新阶段，任何的hook函数都不会被调用）。\x3cstrong\x3e所以我们应极力避免更新context\x3c\/strong\x3e，因为这会使应用的数据流变得非常混乱，这背离了React的设计思想。\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2.2 自定义组件\x3ccode\x3eref\x3c\/code\x3e属性的使用\x3c\/h3\x3e\n\x3cp\x3eReact组件基本分为两类，一类是原生的组件比如\x3ccode\x3ediv\x3c\/code\x3e,\x3ccode\x3espan\x3c\/code\x3e,\x3ccode\x3eul\x3c\/code\x3e等等这类的HTML标签（其实你也可以直接叫他HTML DOM元素，只是我自己认为他也是一类组件），一类是自定义组件，包括用\x3ccode\x3eclass\x3c\/code\x3e定义的组件和用函数定义的组件，\x3ccode\x3eref\x3c\/code\x3e属性在这两种组件中所代表的含义是不一样的。\x3c\/p\x3e\n\x3ch4\x3e2.2.1 \x3ccode\x3eref\x3c\/code\x3e在\x3ccode\x3eHTML\x3c\/code\x3e标签上使用\x3c\/h4\x3e\n\x3cp\x3e看代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CustomComponent extends React.Component {\n  render() {\n    return (\n      \x3cdiv\x3e\n      \x3cinput type=\x26quot;text\x26quot;\n          ref={(input) =\x3e { this.textInput = input; \x22}}\x22 \/\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustomComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n      \x26lt;input \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e\n          ref={(input) =\x26gt; { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.textInput = input; \x22}}\x22 \/\x26gt;\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时在\x3ccode\x3eCustomComponent\x3c\/code\x3e组件内部的\x3ccode\x3einput\x3c\/code\x3e标签上有一个\x3ccode\x3eref\x3c\/code\x3e属性，该属性是一个匿名函数，该函数有一个形参，代表的是\x3ccode\x3einput\x3c\/code\x3e这个标签的\x3cstrong\x3eDOM对象的引用\x3c\/strong\x3e，然后再函数体中将该对象赋值给\x3ccode\x3ethis.textInput\x3c\/code\x3e属性。\x3c\/p\x3e\n\x3ch4\x3e2.2.2 ref在自定义组件上的应用\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Parent extends React.Component {\n  render() {\n    return (\x3cChild ref={component =\x3e {this.child = component\x22}}\x22\/\x3e);\n  }\n}\n\nclass Child extends React.Component {\n  render() {return (\x3cdiv\x3e I am a child.\x3c\/div\x3e);}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x26lt;\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e ref={component =\x26gt; {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.child = component\x22}}\x22\/\x26gt;);\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x26lt;div\x26gt; \x3cspan class=\x22hljs-type\x22\x3eI\x3c\/span\x3e am a child.\x26lt;\/div\x26gt;);}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上例中，我们在父组件\x3ccode\x3eParent\x3c\/code\x3e中调用了\x3ccode\x3eChild\x3c\/code\x3e组件，\x3ccode\x3eChild\x3c\/code\x3e组件上同样传递了这个特殊的属性\x3ccode\x3eref\x3c\/code\x3e，在匿名函数体内，同样将函数的参数赋值给\x3ccode\x3ethis.child\x3c\/code\x3e，此时在控制台中打印出\x3ccode\x3ethis.child\x3c\/code\x3e：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXJ5z?w=1203\x26amp;h=165\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXJ5z?w=1203\x26amp;h=165\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到该对象就是\x3cstrong\x3e组件实例化之后的对象\x3c\/strong\x3e，包含\x3ccode\x3eprops\x3c\/code\x3e, \x3ccode\x3econtext\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e等属性。\x3cstrong\x3e这种特性可以允许我们访问某个子组件的内部状态\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch4\x3e2.2.3 \x3ccode\x3eref\x3c\/code\x3e在函数式组件上的使用\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eref\x3c\/code\x3e属性不可以在函数式组件上使用，假如将上例的\x3ccode\x3eChild\x3c\/code\x3e改为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Child = (props) =\x3e {\n    return (\x3cdiv\x3e I am a child.\x3c\/div\x3e);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Child = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e I am a child.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时在\x3ccode\x3eParent\x3c\/code\x3e组件中便不能为\x3ccode\x3eChild\x3c\/code\x3e组件添加\x3ccode\x3eref\x3c\/code\x3e属性，因为函数式组件没有实例，但是可以在函数式组件内部使用\x3ccode\x3eref\x3c\/code\x3e属性，比如我们在\x3ccode\x3eChild\x3c\/code\x3e组件中使用\x3ccode\x3eref\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2.3 将某个\x3ccode\x3eprops\x3c\/code\x3e复制给\x3ccode\x3estate\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e之所以想把这个拿出来说一说是因为在我刚开始学React的时候，团队的加拿大Leader在review我代码的时候，看到我写了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CustomComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            username: props.username\n        };\n    }      \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustomComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            username: props.username\n        };\n    }      \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之后，要求我不要这么写，说这么写是不规范的。其实后来看官方文档，这么写也是可以的。只不过在组件的\x3ccode\x3eprops.username\x3c\/code\x3e更新之后，\x3ccode\x3ethis.state.username\x3c\/code\x3e并不再更新。如果想保证两者值同步，可以在组件的生命周期函数\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e中更新\x3ccode\x3estate\x3c\/code\x3e,\x3cstrong\x3e因为在组件的更新阶段，\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e函数是唯一一个可以在更新组件之前再次调用\x3ccode\x3esetState\x3c\/code\x3e来更新组件状态的地方\x3c\/strong\x3e，需要注意的是如果的组件的更新是因为某个地方调用\x3ccode\x3esetState\x3c\/code\x3e，那么在组件的更新阶段这个函数并不会被调用，以避免陷入死循环。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentWillReceiveProps(nextProps) {\n    this.setState({username: nextProps.username});\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ecomponentWillReceiveProps\x3c\/span\x3e(nextProps) {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setState\x3c\/span\x3e({\x3cspan class=\x22hljs-attribute\x22\x3eusername\x3c\/span\x3e: nextProps.username});\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e3 最佳实践\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e3.1 避免直接在组件上写用bind函数\x3c\/h3\x3e\n\x3cp\x3e很多React教程在讲到React事件处理的时候，都会有类似的写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ButtonList extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            state: props.username\n        };\n    }\n    \n    handleClick() {\n        const {count} = this.state;\n        this.setState({count: count \x2b 1});\n    }\n    \n    render() {\n        return (\n          \/\/ 假设Button是我们自定义的一个组件，这个组件需要一个onClick属性，属性类型必须为函数\n          \x3cButton onClick={this.handleClick.bind(this)} \/\x3e\n        )    \n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButtonList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            state: props.username\n        };\n    }\n    \n    handleClick() {\n        const {count} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({count: count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e});\n    }\n    \n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 假设Button是我们自定义的一个组件，这个组件需要一个onClick属性，属性类型必须为函数\x3c\/span\x3e\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)} \/\x26gt;\n        )    \n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的写法并没有错，但是可有可能会引起一些性能问题，因为\x3ccode\x3eButtonList\x3c\/code\x3e的\x3ccode\x3erender\x3c\/code\x3e函数每一次被调用的时候，都会创建一个新的函数，然后赋值给\x3ccode\x3eonClick\x3c\/code\x3e属性，在\x3ccode\x3eButton\x3c\/code\x3e组件内部属性的比较又是用\x3ccode\x3e===\x3c\/code\x3e，在某些情况下，这样会引起Button组件不必要的重新渲染。深究其原因是因为每次调用\x3ccode\x3ebind\x3c\/code\x3e函数都会返回一个新的函数(还没彻底弄明白\x3ccode\x3ebind\x3c\/code\x3e函数原理的猿可以看\x3ca href=\x22http:\/\/www.admin10000.com\/document\/6711.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇文章\x3c\/a\x3e)。比如，下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function print() {\n    console.log(this.a);\n}\nlet obj = {a: \x27A\x27}\nprint.bind(obj) === print.bind(obj);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n    console.log(this.a);\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobj\x3c\/span\x3e = \x3cspan class=\x22hljs-comment\x22\x3e{a: \x27A\x27}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e === \x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一行代码比较的结果始终是false，因为每次调用bind函数都会返回一个新的函数对象的引用。这就是为什么要尽量避免在行内写bind函数，\x3ccode\x3e\x26lt;Button type=\x27button\x27 onClick={(event) =\x26gt; {\x22}}\x22 \/\x26gt;\x3c\/code\x3e这样的写法也有相同的问题，因为这样相当于每次都声明一个新的匿名函数。最佳的写法是在\x3ccode\x3econstructor\x3c\/code\x3e内写\x3ccode\x3ethis.handleClick = this.handleClick.bind(this)\x3c\/code\x3e（相当于在组件初始化时，就把\x3ccode\x3ebind\x3c\/code\x3e函数返回的新函数保存在一个成员变量中，这样，在组件的更新阶段，每次给\x3ccode\x3eonClick\x3c\/code\x3e属性都传递的都是同一个函数的引用），并在组件上这样写\x3ccode\x3e\x26lt;Button onClick={this.handleClick} \/\x26gt;\x3c\/code\x3e。\x3cbr\x3e但是，假如在演示组件\x3ccode\x3eButtonList\x3c\/code\x3e有十几个函数需要绑定，你可能会抱怨，每添加一个事件处理函数，都要写类似这样的代码，导致组件臃肿不堪。身为一个有逼格的程序猿，怎么可以干这种重复的机械运动呢！这时，你可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor() {\n    \/\/ 省略其他非关键代码,并假设我们已经声明了以下事件处理函数\n    this.bind([\n      \x27eventHandler1\x27,\n      \x27eventHandler2\x27,\n      \x27eventHandler3\x27,\n      \x27eventHandler4\x27,\n      \x27eventHandler5\x27\n    ])\n}\n\nbind(methodArray) {\n    methodArray.forEach(method =\x3e this[method] = this[method].bind(this));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略其他非关键代码,并假设我们已经声明了以下事件处理函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bind([\n      \x3cspan class=\x22hljs-string\x22\x3e\x27eventHandler1\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27eventHandler2\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27eventHandler3\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27eventHandler4\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27eventHandler5\x27\x3c\/span\x3e\n    ])\n}\n\nbind(methodArray) {\n    methodArray.forEach(method =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[method] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[method].bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e3.2 多用函数式组件（Stateless Functional Component, SFC）\x3c\/h3\x3e\n\x3ch4\x3e3.2.1 使用方法\x3c\/h4\x3e\n\x3cp\x3eReact中自定义组件，最简单的写法可以是这样:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Custom(props) {\n    \/\/ props以函数参数的形式传递\n    return(\x3cdiv\x3eThis is a functional component, {props.name}\x3c\/div\x3e);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustom\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ props以函数参数的形式传递\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eThis is a functional component, {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也可以用ES6语法这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Custom extend Component {\n    render() {\n        return(\x3cdiv\x3eThis is a functional component\x3c\/div\x3e);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustom\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextend\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eThis is a functional component\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这两种写法属于不同类型的组件，前一种称为函数式组件，后一种称为class类组件。这两种组件在使用上有一些区别，比如2.2.2小结讲到的ref属性的使用。这里推荐使用第一种写法。因为第一种写法的代码量更少，而且函数式组件也有更加优秀的性能表现（关于两种组件的性能比较，我还没找更多的证据，据说能够减少很多无意义的检测和内存分配）总之这样写，更加优雅（装逼）啦。如果你在用ES6语法，前一种写法还可以是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Custom = ({name}) =\x3e {\n    return(\x3cdiv\x3eThis is a functional component, {name}\x3c\/div\x3e);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Custom = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{name}\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eThis is a functional component, {name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这中写法最迷人的地方在于代码量很少，代码易读，看函数声明很容知道该组件需要哪些属性。\x3c\/p\x3e\n\x3ch4\x3e3.2.2 注意事项\x3c\/h4\x3e\n\x3cp\x3e函数式组件虽好，但不是任何情况下都能使用函数式组件。这里给两条参照标准：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e正如该组件的英文名称：Stateless Functional Component，只有在组件没有状态的时候才适用。\x3c\/li\x3e\n\x3cli\x3e函数式组件没有生命周期的hook函数，如果你想调用任何一个生命周期钩子函数，请使用类组件。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e3.3 避免直接修改\x3ccode\x3eporps\x3c\/code\x3e或者\x3ccode\x3estate\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e关于这条，很多人在一开始学习React的时候就被灌输了这个概念：\x3cstrong\x3e不能在组件内部修改porps ，修改state要用setState\x3c\/strong\x3e。但是在一些复杂的情况下，大家往往会在不经意间犯了这两个错误。看下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 假设data是这样的结构:\n\/\/ data = [\n\/\/     {\n\/\/         name: \x27Lily\x27,\n\/\/         age: 19\n\/\/     },\n\/\/     {\n\/\/         name: \x27Tom\x27,\n\/\/         age: 20\n\/\/     }\n\/\/ ];\nconst data = this.props.data;\ndata.push({name: \x27Neil\x27, age: 22});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 假设data是这样的结构:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ data = [\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/     {\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/         name: \x27Lily\x27,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/         age: 19\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/     },\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/     {\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/         name: \x27Tom\x27,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/         age: 20\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/     }\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ];\x3c\/span\x3e\nconst \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.push({name: \x3cspan class=\x22hljs-string\x22\x3e\x27Neil\x27\x3c\/span\x3e, age: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e包括我的同事在内，他们经常会写类似这样的代码，然后困惑的跑来问我，为什么组件没有按照预期更新，因为这样的写法，已经更新了props。这涉及到JS中一个很重的知识点：\x3cstrong\x3eJS中将对象（Function和Array也是对象）赋值给某一个变量，本质上是把对象的引用赋值给这个变量，作为函数的实参传递时也是一样的道理\x3c\/strong\x3e（如果还不明白什么是对象的引用，网上有很多教程解释的很清楚，我比较懒，就不解释这么基础的概念了）。比如下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let obj = {a: 1};\nfunction test(obj) {\n    obj.a = 2;\n}\ntest(obj);\nconsole.log(obj.a); \/\/ 打印出2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3elet obj = \x3cspan class=\x22hljs-comment\x22\x3e{a: 1}\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n    obj.a = 2;\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj)\x3c\/span\x3e;\x3c\/span\x3e\nconsole.log(obj.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打印出2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以在组件内这样的代码：\x3ccode\x3edata.push({name: \x27Neil\x27, age: 22})\x3c\/code\x3e实际上已经更改了实际上已经不经意间在子组件内修改了父组件的传来的props。如果将示例中的代码换成\x3ccode\x3econst data = this.state.data; data.push({name: \x27Neil\x27, age: 22});\x3c\/code\x3e后也会有相同的问题。正确的写法应该是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 利用ES6的spread语法\n\/\/ Spread会返回一个新数组，并将新数组的引用赋值给变量data，\n\/\/ 修改data也就不会影响this.props.data\nconst data = [...this.props.data];\n\n\/\/ 或者不利用ES6你在ES5中也可以这样：\n\/\/ concat函数也会返回一个新的数组\nvar data = [].concat(this.props.data);\n\n\/\/ 如果this.props.data是一个对象（字面量对象，非数组对象或函数对象）\n\/\/ assign函数也会返回一个新的对象。\nvar data = Object.assign({}, this.props.data);\n\n\ndata.push({name: \x27Neil\x27, age: 22});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用ES6的spread语法\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Spread会返回一个新数组，并将新数组的引用赋值给变量data，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改data也就不会影响this.props.data\x3c\/span\x3e\nconst \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = [...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者不利用ES6你在ES5中也可以这样：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ concat函数也会返回一个新的数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = [].concat(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果this.props.data是一个对象（字面量对象，非数组对象或函数对象）\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ assign函数也会返回一个新的对象。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = Object.assign({}, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\n\n\n\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.push({name: \x3cspan class=\x22hljs-string\x22\x3e\x27Neil\x27\x3c\/span\x3e, age: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e4 最后\x3c\/h2\x3e\n\x3cp\x3e还有其他的东西，由于篇幅和时间有限没来得及写，以后有机会写一写。文章有任何错误之处，请不吝赐教或轻喷。附上参考文章及链接：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/reactjs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/reactjs.org\/\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004636213\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.react.express\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.react.express\/\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007553885\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.admin10000.com\/document\/6711.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.admin10000.com\/doc...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>很少教程会教你的：ReactJS最佳实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011891035">https://segmentfault.com/a/1190000011891035</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5g7gmqefr2c/" target="_blank">https://alili.tech/archive/5g7gmqefr2c/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>