<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webpack源码之运行流程"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webpack源码之运行流程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5jjlnghbqq7/",
				"appid": "1613049289050283", 
				"title": "webpack源码之运行流程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/w85hqdsjihg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hyiueowb0mw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&text=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&text=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&title=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&is_video=false&description=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&title=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&title=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&title=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5jjlnghbqq7%2f&title=webpack%e6%ba%90%e7%a0%81%e4%b9%8b%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webpack源码之运行流程</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e引言\x3c\/h2\x3e\n\x3cp\x3e通过前面几张的铺垫,下面开始分析webpack源码核心流程,大体上可以分为初始化,编译,输出三个阶段,下面开始分析\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初始化\x3c\/h2\x3e\n\x3cblockquote\x3e这个阶段整体流程做了什么? 启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e详细分析\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/通过yargs获得shell中的参数\nyargs.parse(process.argv.slice(2), (err, argv, output) =\x3e {\n    \/\/把webpack.config.js中的参数和shell参数整合到options对象上\n    let options;\n        options = require(\x26quot;.\/convert-argv\x26quot;)(argv);\n\n    function processOptions(options) {\n\n        const firstOptions = [].concat(options)[0];\n        const webpack = require(\x26quot;webpack\x26quot;);\n\n        let compiler;\n            \/\/通过webpack方法创建compile对象,Compiler 负责文件监听和启动编译。\n            \/\/Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。\n            compiler = webpack(options);\n\n\n        if (firstOptions.watch || options.watch) {\n\n            compiler.watch(watchOptions, compilerCallback);\n            \/\/启动一次新的编译。\n        } else compiler.run(compilerCallback);\n    }\n\n    processOptions(options);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/通过yargs获得shell中的参数\x3c\/span\x3e\nyargs.parse(process.argv.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, argv, output\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把webpack.config.js中的参数和shell参数整合到options对象上\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e options;\n        options = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/convert-argv\x22\x3c\/span\x3e)(argv);\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocessOptions\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e firstOptions = [].concat(options)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22webpack\x22\x3c\/span\x3e);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e compiler;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/通过webpack方法创建compile对象,Compiler 负责文件监听和启动编译。\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。\x3c\/span\x3e\n            compiler = webpack(options);\n\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (firstOptions.watch || options.watch) {\n\n            compiler.watch(watchOptions, compilerCallback);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/启动一次新的编译。\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e compiler.run(compilerCallback);\n    }\n\n    processOptions(options);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 从源码中摘取了初始化的的第一步,做了简化,当运行webpack命令的的时候,运行的是webpack-cli下webpack.js,其内容是一个自执行函数,上面是执行的第一步,进行参数的解析合并处理,并创建compiler实例,然后启动编译运行run方法,其中关键步骤 compiler = webpack(options); 详细展开如下所示\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const webpack = (options, callback) =\x3e {\n    \/\/参数合法性校验\n    const webpackOptionsValidationErrors = validateSchema(\n        webpackOptionsSchema,\n        options\n    );\n\n    let compiler;\n    if (Array.isArray(options)) {\n        compiler = new MultiCompiler(options.map(options =\x3e webpack(options)));\n    } else if (typeof options === \x26quot;object\x26quot;) {\n        options = new WebpackOptionsDefaulter().process(options);\n        \/\/创建compiler对象\n        compiler = new Compiler(options.context);\n        compiler.options = options;\n        new NodeEnvironmentPlugin().apply(compiler);\n        \/\/注册配置文件中的插件,依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。\n        if (options.plugins \x26amp;\x26amp; Array.isArray(options.plugins)) {\n            for (const plugin of options.plugins) {\n                plugin.apply(compiler);\n            }\n        }\n        \/\/开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。\n        compiler.hooks.environment.call();\n        compiler.hooks.afterEnvironment.call();\n        \/\/注册内部插件\n        compiler.options = new WebpackOptionsApply().process(options, compiler);\n    }\n\n    return compiler;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3econst webpack = (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e, callback) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/参数合法性校验\x3c\/span\x3e\n    const webpackOptionsValidationErrors = validateSchema(\n        webpackOptionsSchema,\n        \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e\n    );\n\n    let compiler;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e)) {\n        compiler = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MultiCompiler(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.map(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e =\x26gt; webpack(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e)));\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WebpackOptionsDefaulter().process(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建compiler对象\x3c\/span\x3e\n        compiler = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Compiler(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.context);\n        compiler.\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NodeEnvironmentPlugin().apply(compiler);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/注册配置文件中的插件,依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.plugins \x26amp;\x26amp; Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.plugins)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (const plugin of \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.plugins) {\n                plugin.apply(compiler);\n            }\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。\x3c\/span\x3e\n        compiler.hooks.environment.\x3cspan class=\x22hljs-keyword\x22\x3ecall\x3c\/span\x3e();\n        compiler.hooks.afterEnvironment.\x3cspan class=\x22hljs-keyword\x22\x3ecall\x3c\/span\x3e();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/注册内部插件\x3c\/span\x3e\n        compiler.\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WebpackOptionsApply().process(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e, compiler);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e compiler;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  注册插件过程不在展开,webpack内置插件真的很多啊\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e编译\x3c\/h2\x3e\n\x3cblockquote\x3e这个阶段整体流程做了什么? 从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e详细分析\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.hooks.beforeRun.callAsync(this, err =\x3e {\n            if (err) return finalCallback(err);\n\n            this.hooks.run.callAsync(this, err =\x3e {\n                if (err) return finalCallback(err);\n\n                this.readRecords(err =\x3e {\n                    if (err) return finalCallback(err);\n\n                    this.compile(onCompiled);\n                });\n            });\n        });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.beforeRun.callAsync(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, err =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e finalCallback(err);\n\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.run.callAsync(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, err =\x26gt; {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e finalCallback(err);\n\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.readRecords(err =\x26gt; {\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e finalCallback(err);\n\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compile(onCompiled);\n                });\n            });\n        });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 从执行run方法开始,开始执行编译流程,run方法触发了before-run、run两个事件，然后通过readRecords读取文件，通过compile进行打包,该方法中实例化了一个Compilation类\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22compile(callback) {\n        const params = this.newCompilationParams();\n        this.hooks.beforeCompile.callAsync(params, err =\x3e {\n            if (err) return callback(err);\n\n            this.hooks.compile.call(params);\n\/\/ 每编译一次都会创建一个compilation对象（比如watch 文件时，一改动就会执行），但是compile只会创建一次\n            const compilation = this.newCompilation(params);\n\/\/ make事件触发了  事件会触发SingleEntryPlugin监听函数，调用compilation.addEntry方法\n            this.hooks.make.callAsync(compilation, err =\x3e {\n                if (err) return callback(err);\n                \n            });\n        });\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3ecompile(\x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e) {\n        const params = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eCompilationParams\x3c\/span\x3e();\n        \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.hooks.beforeCompile.callAsync(params, err =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e(err);\n\n            \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.hooks.compile.call(params);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每编译一次都会创建一个compilation对象（比如watch 文件时，一改动就会执行），但是compile只会创建一次\x3c\/span\x3e\n            const compilation = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eCompilation\x3c\/span\x3e(params);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ make事件触发了  事件会触发SingleEntryPlugin监听函数，调用compilation.addEntry方法\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.hooks.make.callAsync(compilation, err =\x26gt; {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e(err);\n                \n            });\n        });\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  打包时触发before-compile、compile、make等事件,同时创建非常重要的compilation对象,内部有声明了很多钩子,初始化模板等等\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.hooks = {\n    buildModule: new SyncHook([\x26quot;module\x26quot;]),\n    seal: new SyncHook([]),\n    optimize: new SyncHook([]),\n};\n\/\/拼接最终生成代码的主模板会用到\nthis.mainTemplate = new MainTemplate(this.outputOptions);\n\/\/拼接最终生成代码的chunk模板会用到\nthis.chunkTemplate = new ChunkTemplate(this.outputOptions); \n \/\/拼接最终生成代码的热更新模板会用到\nthis.hotUpdateChunkTemplate = new HotUpdateChunkTemplate()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks = {\n    buildModule: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SyncHook([\x3cspan class=\x22hljs-string\x22\x3e\x22module\x22\x3c\/span\x3e]),\n    seal: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SyncHook([]),\n    optimize: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SyncHook([]),\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/拼接最终生成代码的主模板会用到\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mainTemplate = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MainTemplate(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.outputOptions);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/拼接最终生成代码的chunk模板会用到\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.chunkTemplate = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ChunkTemplate(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.outputOptions); \n \x3cspan class=\x22hljs-comment\x22\x3e\/\/拼接最终生成代码的热更新模板会用到\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hotUpdateChunkTemplate = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HotUpdateChunkTemplate()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/监听comple的make hooks事件，通过内部的 SingleEntryPlugin 从入口文件开始执行编译\n        compiler.hooks.make.tapAsync(\n            \x26quot;SingleEntryPlugin\x26quot;,\n            (compilation, callback) =\x3e {\n                const { entry, name, context } = this;\n\n                const dep = SingleEntryPlugin.createDependency(entry, name);\n                compilation.addEntry(context, dep, name, callback);\n            }\n        );\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/监听comple的make hooks事件，通过内部的 SingleEntryPlugin 从入口文件开始执行编译\x3c\/span\x3e\n        compiler.hooks.make.tapAsync(\n            \x3cspan class=\x22hljs-string\x22\x3e\x22SingleEntryPlugin\x22\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompilation, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { entry, name, context } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = SingleEntryPlugin.createDependency(entry, name);\n                compilation.addEntry(context, dep, name, callback);\n            }\n        );\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  监听compile的make hooks事件，通过内部的 SingleEntryPlugin 从入口文件开始执行编译,调用compilation.addEntry方法,根据模块的类型获取对应的模块工厂并创建模块,开始构建模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\ndoBuild(options, compilation, resolver, fs, callback) {\n    const loaderContext = this.createLoaderContext(\n        resolver,\n        options,\n        compilation,\n        fs\n    );\n    \/\/调用loader处理模块\n    runLoaders(\n        {\n            resource: this.resource,\n            loaders: this.loaders,\n            context: loaderContext,\n            readResource: fs.readFile.bind(fs)\n        },\n        (err, result) =\x3e {\n           \n            \n            const resourceBuffer = result.resourceBuffer;\n            const source = result.result[0];\n            const sourceMap = result.result.length \x3e= 1 ? result.result[1] : null;\n            const extraInfo = result.result.length \x3e= 2 ? result.result[2] : null;\n            \n\n            this._source = this.createSource(\n                this.binary ? asBuffer(source) : asString(source),\n                resourceBuffer,\n                sourceMap\n            );\n            \/\/loader处理完之后 得到_source  然后ast接着处理\n            this._ast =\n                typeof extraInfo === \x26quot;object\x26quot; \x26amp;\x26amp;\n                extraInfo !== null \x26amp;\x26amp;\n                extraInfo.webpackAST !== undefined\n                    ? extraInfo.webpackAST\n                    : null;\n            return callback();\n        }\n    );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\ndoBuild(options, compilation, resolver, fs, callback) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e loaderContext = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createLoaderContext(\n        resolver,\n        options,\n        compilation,\n        fs\n    );\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用loader处理模块\x3c\/span\x3e\n    runLoaders(\n        {\n            resource: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.resource,\n            loaders: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.loaders,\n            context: loaderContext,\n            readResource: fs.readFile.bind(fs)\n        },\n        \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, result\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n           \n            \n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resourceBuffer = result.resourceBuffer;\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e source = result.result[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sourceMap = result.result.length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? result.result[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e extraInfo = result.result.length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e ? result.result[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \n\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._source = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createSource(\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.binary ? asBuffer(source) : asString(source),\n                resourceBuffer,\n                sourceMap\n            );\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/loader处理完之后 得到_source  然后ast接着处理\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._ast =\n                \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e extraInfo === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e \x26amp;\x26amp;\n                extraInfo !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp;\n                extraInfo.webpackAST !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n                    ? extraInfo.webpackAST\n                    : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback();\n        }\n    );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  SingleEntryPlugin这个内存插件主要作用是从entry读取文件,根据文件类型和配置的 Loader 执行runLoaders,然后将loader处理后的文件通过acorn抽象成抽象语法树AST,遍历AST，构建该模块的所有依赖。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e输出\x3c\/h2\x3e\n\x3cblockquote\x3e这个阶段整体流程做了什么? 把编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e详细分析\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/\/所有依赖build完成，开始对chunk进行优化（抽取公共模块、加hash等）\ncompilation.seal(err =\x3e {\n    if (err) return callback(err);\n\n    this.hooks.afterCompile.callAsync(compilation, err =\x3e {\n        if (err) return callback(err);\n\n        return callback(null, compilation);\n    });\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs hsp\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/所有依赖build完成，开始对chunk进行优化（抽取公共模块、加hash等）\x3c\/span\x3e\ncompilation.seal(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n    this.hooks.afterCompile.callAsync(compilation, \x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback(null, compilation)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  compilation.seal主要是对chunk进行优化,生成编译后的源码,比较重要,详细展开如下所示\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/代码生成前面优化\nthis.hooks.optimize.call();\nthis.hooks.optimizeTree.callAsync(this.chunks, this.modules, err =\x3e {\n \n    this.hooks.beforeHash.call();\n    this.createHash();\n    this.hooks.afterHash.call();\n\n    if (shouldRecord) this.hooks.recordHash.call(this.records);\n\n    this.hooks.beforeModuleAssets.call();\n    this.createModuleAssets();\n    if (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n        this.hooks.beforeChunkAssets.call();\n        \/\/生成最终打包输出的chunk资源,根据template文件,详细步骤如下所示\n        this.createChunkAssets();\n    }\n    \n});\n--------------------------------------\n\/\/取出最后文件需要的模板\nconst template = chunk.hasRuntime()\n                    ? this.mainTemplate\n                    : this.chunkTemplate;\n\/\/通过模板最终生成webpack_require格式的内容,他这个是内部封装的拼接渲染逻辑,也没用什么ejs,handlebar等这些模板工具\nsource = fileManifest.render();\n\/\/生成的资源保存在compilation.assets,方便下一步emitAssets步骤中,把文件输出到硬盘\nthis.assets[file] = source;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/代码生成前面优化\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.optimize.call();\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.optimizeTree.callAsync(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.chunks, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.modules, err =\x26gt; {\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.beforeHash.call();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createHash();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.afterHash.call();\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (shouldRecord) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.recordHash.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.records);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.beforeModuleAssets.call();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createModuleAssets();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.shouldGenerateChunkAssets.call() !== \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.beforeChunkAssets.call();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/生成最终打包输出的chunk资源,根据template文件,详细步骤如下所示\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createChunkAssets();\n    }\n    \n});\n--------------------------------------\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/取出最后文件需要的模板\x3c\/span\x3e\nconst template = chunk.hasRuntime()\n                    ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mainTemplate\n                    : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.chunkTemplate;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/通过模板最终生成webpack_require格式的内容,他这个是内部封装的拼接渲染逻辑,也没用什么ejs,handlebar等这些模板工具\x3c\/span\x3e\nsource = fileManifest.render();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/生成的资源保存在compilation.assets,方便下一步emitAssets步骤中,把文件输出到硬盘\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.assets[file] = source;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/把处理好的assets输出到output的path中\n    emitAssets(compilation, callback) {\n        let outputPath;\n    \n        const emitFiles = err =\x3e {\n            if (err) return callback(err);\n    \n            asyncLib.forEach(\n                compilation.assets,\n                (source, file, callback) =\x3e {\n                    const writeOut = err =\x3e {\n                        \/\/输出打包后的文件到配置中指定的目录下\n                        this.outputFileSystem.writeFile(targetPath, content, callback);\n                    };\n    \n                    writeOut();\n                }\n            );\n        };\n    \n        this.hooks.emit.callAsync(compilation, err =\x3e {\n            if (err) return callback(err);\n            outputPath = compilation.getPath(this.outputPath);\n            this.outputFileSystem.mkdirp(outputPath, emitFiles);\n        });\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把处理好的assets输出到output的path中\x3c\/span\x3e\n    emitAssets(compilation, callback) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e outputPath;\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e emitFiles = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback(err);\n    \n            asyncLib.forEach(\n                compilation.assets,\n                \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3esource, file, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e writeOut = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/输出打包后的文件到配置中指定的目录下\x3c\/span\x3e\n                        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.outputFileSystem.writeFile(targetPath, content, callback);\n                    };\n    \n                    writeOut();\n                }\n            );\n        };\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hooks.emit.callAsync(compilation, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callback(err);\n            outputPath = compilation.getPath(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.outputPath);\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.outputFileSystem.mkdirp(outputPath, emitFiles);\n        });\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e如果单独看这篇文章的话,理解起来会比较困难,推荐一下与之相关的系列铺垫文章,上面是我对webpack源码运行流程的总结,  整个流程已经跑通了,不过还有蛮多点值得深入挖掘的。清明在家宅了3天,过得好快,明天公司组织去奥森公园寻宝行动,期待ing 。\x3c\/p\x3e\n\x3cp\x3e推荐\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014031536\x22\x3ewebpack源码之tapable\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014056619\x22 target=\x22_blank\x22\x3ewebpack源码之plugin机制\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014178462\x22\x3ewebpack源码之ast简介\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014205729\x22 target=\x22_blank\x22\x3ewebpack源码之loader机制\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e参考源码\x3cbr\x3ewebpack: \x224.4.1\x22\x3cbr\x3ewebpack-cli: \x222.0.13\x22\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webpack源码之运行流程</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014221014">https://segmentfault.com/a/1190000014221014</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5jjlnghbqq7/" target="_blank">https://alili.tech/archive/5jjlnghbqq7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>