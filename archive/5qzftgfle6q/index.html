<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="ES6 变量作用域与提升：变量的生命周期详解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>ES6 变量作用域与提升：变量的生命周期详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5qzftgfle6q/",
				"appid": "1613049289050283", 
				"title": "ES6 变量作用域与提升：变量的生命周期详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-04T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/rpohaayze7s/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0ofupboo62op/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&text=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&text=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&title=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&is_video=false&description=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&title=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&title=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&title=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qzftgfle6q%2f&title=ES6%20%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e6%8f%90%e5%8d%87%ef%bc%9a%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">ES6 变量作用域与提升：变量的生命周期详解</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/28494566\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES6 变量作用域与提升：变量的生命周期详解\x3c\/a\x3e从属于笔者的\x3ca href=\x22https:\/\/parg.co\/bjK\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e现代 JavaScript 开发：语法基础与实践技巧\x3c\/a\x3e系列文章。本文详细讨论了 JavaScript 中作用域、执行上下文、不同作用域下变量提升与函数提升的表现、顶层对象以及如何避免创建全局对象等内容；建议阅读前文\x3ca href=\x22https:\/\/parg.co\/bjn\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e ES6 变量声明与赋值\x3c\/a\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e变量作用域与提升\x3c\/h1\x3e\n\x3cp\x3e在 ES6 之前，JavaScript 中只存在着函数作用域；而在 ES6 中，JavaScript 引入了 let、const 等变量声明关键字与块级作用域，在不同作用域下变量与函数的提升表现也是不一致的。在 JavaScript 中，所有绑定的声明会在控制流到达它们出现的作用域时被初始化；这里的作用域其实就是所谓的执行上下文（Execution Context），每个执行上下文分为内存分配（Memory Creation Phase）与执行（Execution）这两个阶段。在执行上下文的内存分配阶段会进行变量创建，即开始进入了变量的生命周期；变量的生命周期包含了声明（Declaration phase）、初始化（Initialization phase）与赋值（Assignment phase）过程这三个过程。\x3c\/p\x3e\n\x3cp\x3e传统的 var 关键字声明的变量允许在声明之前使用，此时该变量被赋值为 undefined；而函数作用域中声明的函数同样可以在声明前使用，其函数体也被提升到了头部。这种特性表现也就是所谓的提升（Hoisting）；虽然在 ES6 中以 let 与 const 关键字声明的变量同样会在作用域头部被初始化，不过这些变量仅允许在实际声明之后使用。在作用域头部与变量实际声明处之间的区域就称为所谓的暂时死域（Temporal Dead Zone），TDZ 能够避免传统的提升引发的潜在问题。另一方面，由于 ES6 引入了块级作用域，在块级作用域中声明的函数会被提升到该作用域头部，即允许在实际声明前使用；而在部分实现中该函数同时被提升到了所处函数作用域的头部，不过此时被赋值为 undefined。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e作用域\x3c\/h1\x3e\n\x3cp\x3e作用域（Scope）即代码执行过程中的变量、函数或者对象的可访问区域，作用域决定了变量或者其他资源的可见性；计算机安全中一条基本原则即是用户只应该访问他们需要的资源，而作用域就是在编程中遵循该原则来保证代码的安全性。除此之外，作用域还能够帮助我们提升代码性能、追踪错误并且修复它们。JavaScript 中的作用域主要分为全局作用域（Global Scope）与局部作用域（Local Scope）两大类，在 ES5 中定义在函数内的变量即是属于某个局部作用域，而定义在函数外的变量即是属于全局作用域。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e全局作用域\x3c\/h2\x3e\n\x3cp\x3e当我们在浏览器控制台或者 Node.js 交互终端中开始编写 JavaScript 时，即进入了所谓的全局作用域：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ the scope is by default global\nvar name = \x27Hammad\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e the scope \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eby\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e\nvar name = \x3cspan class=\x22hljs-string\x22\x3e\x27Hammad\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e定义在全局作用域中的变量能够被任意的其他作用域中访问：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var name = \x27Hammad\x27;\n\nconsole.log(name); \/\/ logs \x27Hammad\x27\n\nfunction logName() {\n    console.log(name); \/\/ \x27name\x27 is accessible here and everywhere else\n}\n\nlogName(); \/\/ logs \x27Hammad\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3evar name = \x3cspan class=\x22hljs-symbol\x22\x3e\x27Hammad\x3c\/span\x3e\x27;\n\nconsole.log(name); \/\/ logs \x3cspan class=\x22hljs-symbol\x22\x3e\x27Hammad\x3c\/span\x3e\x27\n\n\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elogName\x3c\/span\x3e() {\n    console.log(name); \/\/ \x3cspan class=\x22hljs-symbol\x22\x3e\x27name\x3c\/span\x3e\x27 \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e accessible here \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e everywhere \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n}\n\nlogName(); \/\/ logs \x3cspan class=\x22hljs-symbol\x22\x3e\x27Hammad\x3c\/span\x3e\x27\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e函数作用域\x3c\/h2\x3e\n\x3cp\x3e定义在某个函数内的变量即从属于当前函数作用域，在每次函数调用中都会创建出新的上下文；换言之，我们可以在不同的函数中定义同名变量，这些变量会被绑定到各自的函数作用域中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Global Scope\nfunction someFunction() {\n    \/\/ Local Scope #1\n    function someOtherFunction() {\n        \/\/ Local Scope #2\n    }\n}\n\n\/\/ Global Scope\nfunction anotherFunction() {\n    \/\/ Local Scope #3\n}\n\/\/ Global Scope\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Global Scope\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Local Scope #1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeOtherFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Local Scope #2\x3c\/span\x3e\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Global Scope\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eanotherFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Local Scope #3\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Global Scope\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数作用域的缺陷在于粒度过大，在使用闭包或者其他特性时导致异常的变量传递：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var callbacks = [];\n\n\/\/ 这里的 i 被提升到了当前函数作用域头部\nfor (var i = 0; i \x3c= 2; i\x2b\x2b) {\n    callbacks[i] = function () {\n            return i * 2;\n        };\n}\n\nconsole.log(callbacks[0]()); \/\/6\nconsole.log(callbacks[1]()); \/\/6\nconsole.log(callbacks[2]()); \/\/6\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbacks = [];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的 i 被提升到了当前函数作用域头部\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; i\x2b\x2b) {\n    callbacks[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n        };\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(callbacks[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/6\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(callbacks[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/6\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(callbacks[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/6\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e块级作用域\x3c\/h2\x3e\n\x3cp\x3e类似于 if、switch 条件选择或者 for、while 这样的循环体即是所谓的块级作用域；在 ES5 中，要实现块级作用域，即需要在原来的函数作用域上包裹一层，即在需要限制变量提升的地方手动设置一个变量来替代原来的全局变量，譬如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var callbacks = [];\nfor (var i = 0; i \x3c= 2; i\x2b\x2b) {\n    (function (i) {\n        \/\/ 这里的 i 仅归属于该函数作用域\n        callbacks[i] = function () {\n            return i * 2;\n        };\n    })(i);\n}\ncallbacks[0]() === 0;\ncallbacks[1]() === 2;\ncallbacks[2]() === 4;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbacks = [];\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; i\x2b\x2b) {\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(i)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的 i 仅归属于该函数作用域\x3c\/span\x3e\n        callbacks[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n        };\n    })(i);\n}\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而在 ES6 中，可以直接利用 \x3ccode\x3elet\x3c\/code\x3e 关键字达成这一点：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let callbacks = []\nfor (let i = 0; i \x3c= 2; i\x2b\x2b) {\n    \/\/ 这里的 i 属于当前块作用域\n    callbacks[i] = function () {\n        return i * 2\n    }\n}\ncallbacks[0]() === 0\ncallbacks[1]() === 2\ncallbacks[2]() === 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3elet callbacks = []\nfor (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的 i 属于当前块作用域\x3c\/span\x3e\n    callbacks[i] = function () {\n        return i * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    }\n}\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\ncallbacks[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]() === \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e词法作用域\x3c\/h2\x3e\n\x3cp\x3e词法作用域是 JavaScript 闭包特性的重要保证，笔者在\x3ca href=\x22https:\/\/parg.co\/bF0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e基于 JSX 的动态数据绑定\x3c\/a\x3e一文中也介绍了如何利用词法作用域的特性来实现动态数据绑定。一般来说，在编程语言里我们常见的变量作用域就是词法作用域与动态作用域（Dynamic Scope），绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的 Write-Time，即编程时的上下文，而动态作用域以及常见的 this 的用法，都是 Run-Time，即运行时上下文。词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用。JavaScript 是典型的词法作用域的语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域。此二者的对比可以参考如下这个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    console.log( a ); \/\/ 2 in Lexical Scope ，But 3 in Dynamic Scope\n}\n\nfunction bar() {\n    var a = 3;\n    foo();\n}\n\nvar a = 2;\n\nbar();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( a ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2 in Lexical Scope ，But 3 in Dynamic Scope\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n    foo();\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\nbar();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e执行上下文与提升\x3c\/h1\x3e\n\x3cp\x3e作用域（Scope）与上下文（Context）常常被用来描述相同的概念，不过上下文更多的关注于代码中 \x3ccode\x3ethis\x3c\/code\x3e 的使用，而作用域则与变量的可见性相关；而 JavaScript 规范中的执行上下文（Execution Context）其实描述的是变量的作用域。众所周知，JavaScript 是单线程语言，同时刻仅有单任务在执行，而其他任务则会被压入执行上下文队列中（更多知识可以阅读 \x3ca href=\x22https:\/\/parg.co\/bjF\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEvent Loop 机制详解与实践应用\x3c\/a\x3e）；每次函数调用时都会创建出新的上下文，并将其添加到执行上下文队列中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e执行上下文\x3c\/h2\x3e\n\x3cp\x3e每个执行上下文又会分为内存创建（Creation Phase）与代码执行（Code Execution Phase）两个步骤，在创建步骤中会进行变量对象的创建（Variable Object）、作用域链的创建以及设置当前上下文中的 \x3ccode\x3ethis\x3c\/code\x3e 对象。所谓的 Variable Object ，又称为 Activation Object，包含了当前执行上下文中的所有变量、函数以及具体分支中的定义。当某个函数被执行时，解释器会先扫描所有的函数参数、变量以及其他声明：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27variableObject\x27: {\n    \/\/ contains function arguments, inner variable and function declarations\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\x27variableObject\x3c\/span\x3e\x27: {\n    \/\/ contains \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3earguments,\x3c\/span\x3e inner variable and \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edeclarations\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 Variable Object 创建之后，解释器会继续创建作用域链（Scope Chain）；作用域链往往指向其副作用域，往往被用于解析变量。当需要解析某个具体的变量时，JavaScript 解释器会在作用域链上递归查找，直到找到合适的变量或者任何其他需要的资源。作用域链可以被认为是包含了其自身 Variable Object 引用以及所有的父 Variable Object 引用的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27scopeChain\x27: {\n    \/\/ contains its own variable object and other variable objects of the parent execution contexts\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27scopeChain\x27\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ contains its own variable object and other variable objects of the parent execution contexts\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而执行上下文则可以表述为如下抽象对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22executionContextObject = {\n    \x27scopeChain\x27: {}, \/\/ contains its own variableObject and other variableObject of the parent execution contexts\n    \x27variableObject\x27: {}, \/\/ contains function arguments, inner variable and function declarations\n    \x27this\x27: valueOfThis\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3eexecutionContextObject = {\n    \x3cspan class=\x22hljs-symbol\x22\x3e\x27scopeChain\x3c\/span\x3e\x27: {}, \/\/ contains its own variableObject \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e other variableObject \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e the parent execution contexts\n    \x3cspan class=\x22hljs-symbol\x22\x3e\x27variableObject\x3c\/span\x3e\x27: {}, \/\/ contains \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3earguments,\x3c\/span\x3e inner variable and \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edeclarations\x3c\/span\x3e\n    \x27this\x27: valueOfThis\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e变量的生命周期与提升\x3c\/h2\x3e\n\x3cp\x3e变量的生命周期包含着变量声明（Declaration Phase）、变量初始化（Initialization Phase）以及变量赋值（Assignment Phase）三个步骤；其中声明步骤会在作用域中注册变量，初始化步骤负责为变量分配内存并且创建作用域绑定，此时变量会被初始化为 undefined，最后的分配步骤则会将开发者指定的值分配给该变量。传统的使用 var 关键字声明的变量的生命周期如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640230\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640230\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而 let 关键字声明的变量生命周期如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640231\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640231\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如上文所说，我们可以在某个变量或者函数定义之前访问这些变量，这即是所谓的变量提升（Hoisting）。传统的 var 关键字声明的变量会被提升到作用域头部，并被赋值为 undefined：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ var hoisting\nnum;     \/\/ =\x3e undefined  \nvar num;  \nnum = 10;  \nnum;     \/\/ =\x3e 10  \n\/\/ function hoisting\ngetPi;   \/\/ =\x3e function getPi() {...}  \ngetPi(); \/\/ =\x3e 3.14  \nfunction getPi() {  \n  return 3.14;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\/\/ \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hoisting\nnum;     \/\/ =\x26gt; undefined  \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e num;  \nnum = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;  \nnum;     \/\/ =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e  \n\/\/ function hoisting\ngetPi;   \/\/ =\x26gt; function getPi() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e  \ngetPi(); \/\/ =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e.\x3cspan class=\x22hljs-number\x22\x3e14\x3c\/span\x3e  \nfunction getPi() {  \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e.\x3cspan class=\x22hljs-number\x22\x3e14\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e变量提升只对 var 命令声明的变量有效，如果一个变量不是用 var 命令声明的，就不会发生变量提升。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(b);\nb = 1;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b);\nb = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的语句将会报错，提示 \x3ccode\x3eReferenceError: b is not defined\x3c\/code\x3e，即变量 b 未声明，这是因为 b 不是用 var 命令声明的，JavaScript 引擎不会将其提升，而只是视为对顶层对象的 b 属性的赋值。ES6 引入了块级作用域，块级作用域中使用 \x3ccode\x3elet\x3c\/code\x3e 声明的变量同样会被提升，只不过不允许在实际声明语句前使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3e let x = x;\nReferenceError: x is not defined\n    at repl:1:9\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\n    at REPLServer.defaultEval (repl.js:239:29)\n    at bound (domain.js:301:14)\n    at REPLServer.runBound [as eval] (domain.js:314:12)\n    at REPLServer.onLine (repl.js:433:10)\n    at emitOne (events.js:120:20)\n    at REPLServer.emit (events.js:210:7)\n    at REPLServer.Interface._onLine (readline.js:278:10)\n    at REPLServer.Interface._line (readline.js:625:8)\n\x3e let x = 1;\nSyntaxError: Identifier \x27x\x27 has already been declared\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e\x26gt; let x = x\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3eReferenceError:\x3c\/span\x3e x is not defined\n    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e repl:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e ContextifyScript.\x3cspan class=\x22hljs-keyword\x22\x3eScript.runInThisContext \x3c\/span\x3e(vm.\x3cspan class=\x22hljs-keyword\x22\x3ejs:44:33)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.defaultEval (repl.\x3cspan class=\x22hljs-keyword\x22\x3ejs:239:29)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ebound \x3c\/span\x3e(domain.\x3cspan class=\x22hljs-keyword\x22\x3ejs:301:14)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.runBound [as eval] (domain.\x3cspan class=\x22hljs-keyword\x22\x3ejs:314:12)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.onLine (repl.\x3cspan class=\x22hljs-keyword\x22\x3ejs:433:10)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e emitOne (events.\x3cspan class=\x22hljs-keyword\x22\x3ejs:120:20)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.emit (events.\x3cspan class=\x22hljs-keyword\x22\x3ejs:210:7)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.Interface._onLine (readline.\x3cspan class=\x22hljs-keyword\x22\x3ejs:278:10)\n\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eat\x3c\/span\x3e REPLServer.Interface._line (readline.\x3cspan class=\x22hljs-keyword\x22\x3ejs:625:8)\n\x3c\/span\x3e\x26gt; let x = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3eSyntaxError:\x3c\/span\x3e Identifier \x3cspan class=\x22hljs-string\x22\x3e\x27x\x27\x3c\/span\x3e has already \x3cspan class=\x22hljs-keyword\x22\x3ebeen \x3c\/span\x3edeclared\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e函数的生命周期与提升\x3c\/h2\x3e\n\x3cp\x3e基础的函数提升同样会将声明提升至作用域头部，不过不同于变量提升，函数同样会将其函数体定义提升至头部；譬如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function b() {  \n   a = 10;  \n   return;  \n   function a() {} \n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eb\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{  \n   a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;  \n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;  \n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{} \n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e会被编译器修改为如下模式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function b() {\n  function a() {}\n  a = 10;\n  return;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eb\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n  a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在内存创建步骤中，JavaScript 解释器会通过 function 关键字识别出函数声明并且将其提升至头部；函数的生命周期则比较简单，声明、初始化与赋值三个步骤都被提升到了作用域头部：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640232\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640232\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果我们在作用域中重复地声明同名函数，则会由后者覆盖前者：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22sayHello();\n\nfunction sayHello () {\n    function hello () {\n        console.log(\x27Hello!\x27);\n    }\n    \n    hello();\n    \n    function hello () {\n        console.log(\x27Hey!\x27);\n    }\n}\n\n\/\/ Hey!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esayHello();\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayHello\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehello\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello!\x27\x3c\/span\x3e);\n    }\n    \n    hello();\n    \n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehello\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Hey!\x27\x3c\/span\x3e);\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Hey!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而 JavaScript 中提供了两种函数的创建方式，函数声明（Function Declaration）与函数表达式（Function Expression）；函数声明即是以 function 关键字开始，跟随者函数名与函数体。而函数表达式则是先声明函数名，然后赋值匿名函数给它；典型的函数表达式如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var sayHello = function() {\n  console.log(\x27Hello!\x27);\n};\n\nsayHello();\n\n\/\/ Hello!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sayHello = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello!\x27\x3c\/span\x3e);\n};\n\nsayHello();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Hello!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数表达式遵循变量提升的规则，函数体并不会被提升至作用域头部：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22sayHello();\n\nfunction sayHello () {\n    function hello () {\n        console.log(\x27Hello!\x27);\n    }\n    \n    hello();\n    \n    var hello = function () {\n        console.log(\x27Hey!\x27);\n    }\n}\n\n\/\/ Hello!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esayHello();\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayHello\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehello\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello!\x27\x3c\/span\x3e);\n    }\n    \n    hello();\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hello = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Hey!\x27\x3c\/span\x3e);\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Hello!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 ES5 中，是不允许在块级作用域中创建函数的；而 ES6 中允许在块级作用域中创建函数，块级作用域中创建的函数同样会被提升至当前块级作用域头部与函数作用域头部。不同的是函数体并不会再被提升至函数作用域头部，而仅会被提升到块级作用域头部：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22f; \/\/ Uncaught ReferenceError: f is not defined\n(function () {\n  f; \/\/ undefined\n  x; \/\/ Uncaught ReferenceError: x is not defined\n  if (true) {\n    f();\n    let x;\n    function f() { console.log(\x27I am function!\x27); }\n  }\n  \n}());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3ef; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Uncaught ReferenceError: f is not defined\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e {\x3c\/span\x3e\n  f; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  x; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Uncaught ReferenceError: x is not defined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n    f();\n    \x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e x;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e {\x3c\/span\x3e console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27I am \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e!\x27); }\n  }\n  \n}\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e避免全局变量\x3c\/h1\x3e\n\x3cp\x3e在计算机编程中，全局变量指的是在所有作用域中都能访问的变量。全局变量是一种不好的实践，因为它会导致一些问题，比如一个已经存在的方法和全局变量的覆盖，当我们不知道变量在哪里被定义的时候，代码就变得很难理解和维护了。在 ES6 中可以利用 \x3ccode\x3elet\x3c\/code\x3e 关键字来声明本地变量，好的 JavaScript 代码就是没有定义全局变量的。在 JavaScript 中，我们有时候会无意间创建出全局变量，即如果我们在使用某个变量之前忘了进行声明操作，那么该变量会被自动认为是全局变量，譬如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sayHello(){\n  hello = \x26quot;Hello World\x26quot;;\n  return hello;\n}\nsayHello();\nconsole.log(hello);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayHello\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  hello = \x3cspan class=\x22hljs-string\x22\x3e\x22Hello World\x22\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hello;\n}\nsayHello();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hello);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上述代码中因为我们在使用 sayHello 函数的时候并没有声明 hello 变量，因此其会创建作为某个全局变量。如果我们想要避免这种偶然创建全局变量的错误，可以通过强制使用 \x3ca href=\x22https:\/\/www.sitepoint.com\/premium\/books\/javascript-novice-to-ninja\/preview\/strict-mode-719892c\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3estrict mode\x3c\/a\x3e 来禁止创建全局变量。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e函数包裹\x3c\/h2\x3e\n\x3cp\x3e为了避免全局变量，第一件事情就是要确保所有的代码都被包在函数中。最简单的办法就是把所有的代码都直接放到一个函数中去:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(win) {\n    \x26quot;use strict\x26quot;; \/\/ 进一步避免创建全局变量\n    var doc = window.document;\n    \/\/ 在这里声明你的变量\n    \/\/ 一些其他的代码\n}(window));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ewin\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e    \x22use strict\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 进一步避免创建全局变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e doc = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在这里声明你的变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些其他的代码\x3c\/span\x3e\n}(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e声明命名空间\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MyApp = {\n    namespace: function(ns) {\n        var parts = ns.split(\x26quot;.\x26quot;),\n            object = this, i, len;\n        for(i = 0, len = parts.lenght; i \x3c len; i \x2b\x2b) {\n            if(!object[parts[i]]) {\n                object[parts[i]] = {};\n            }\n            object = object[parts[i]];\n        }\n    return object;\n    }\n};\n\n\/\/ 定义命名空间\nMyApp.namespace(\x26quot;Helpers.Parsing\x26quot;);\n\n\/\/ 你现在可以使用该命名空间了\nMyApp.Helpers.Parsing.DateParser = function() {\n    \/\/做一些事情\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyApp = {\n    \x3cspan class=\x22hljs-attr\x22\x3enamespace\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ens\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parts = ns.split(\x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e),\n            object = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, i, len;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = parts.lenght; i \x26lt; len; i \x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!object[parts[i]]) {\n                object[parts[i]] = {};\n            }\n            object = object[parts[i]];\n        }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e object;\n    }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义命名空间\x3c\/span\x3e\nMyApp.namespace(\x3cspan class=\x22hljs-string\x22\x3e\x22Helpers.Parsing\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 你现在可以使用该命名空间了\x3c\/span\x3e\nMyApp.Helpers.Parsing.DateParser = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/做一些事情\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e模块化\x3c\/h2\x3e\n\x3cp\x3e另一项开发者用来避免全局变量的技术就是封装到模块 \x3ccode\x3eModule\x3c\/code\x3e 中。一个模块就是不需要创建新的全局变量或者命名空间的通用的功能。不要将所有的代码都放一个负责执行任务或者发布接口的函数中。这里以异步模块定义 \x3ccode\x3eAsynchronous Module Definition (AMD)\x3c\/code\x3e 为例，更详细的 JavaScript 模块化相关知识参考 \x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/26231889\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript 模块演化简史\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/定义\ndefine( \x26quot;parsing\x26quot;, \/\/模块名字\n        [ \x26quot;dependency1\x26quot;, \x26quot;dependency2\x26quot; ], \/\/ 模块依赖\n        function( dependency1, dependency2) { \/\/工厂方法\n\n            \/\/ Instead of creating a namespace AMD modules\n            \/\/ are expected to return their public interface\n            var Parsing = {};\n            Parsing.DateParser = function() {\n              \/\/do something\n            };\n            return Parsing;\n        }\n);\n\n\/\/ 通过 Require.js 加载模块\nrequire([\x26quot;parsing\x26quot;], function(Parsing) {\n    Parsing.DateParser(); \/\/ 使用模块\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义\x3c\/span\x3e\ndefine( \x3cspan class=\x22hljs-string\x22\x3e\x22parsing\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/模块名字\x3c\/span\x3e\n        [ \x3cspan class=\x22hljs-string\x22\x3e\x22dependency1\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22dependency2\x22\x3c\/span\x3e ], \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块依赖\x3c\/span\x3e\n        function( dependency1, dependency2) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/工厂方法\x3c\/span\x3e\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of creating a namespace AMD modules\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ are expected to return their public interface\x3c\/span\x3e\n            var Parsing = {};\n            Parsing.DateParser = function() {\n              \x3cspan class=\x22hljs-comment\x22\x3e\/\/do something\x3c\/span\x3e\n            };\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Parsing;\n        }\n);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 Require.js 加载模块\x3c\/span\x3e\nrequire([\x3cspan class=\x22hljs-string\x22\x3e\x22parsing\x22\x3c\/span\x3e], function(Parsing) {\n    Parsing.DateParser(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用模块\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>ES6 变量作用域与提升：变量的生命周期详解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010640225">https://segmentfault.com/a/1190000010640225</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5qzftgfle6q/" target="_blank">https://alili.tech/archive/5qzftgfle6q/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>