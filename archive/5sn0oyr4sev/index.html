<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 ) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5sn0oyr4sev/",
				"appid": "1613049289050283", 
				"title": "深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 ) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wt2j05lr81/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hzoxzgki51/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5sn0oyr4sev%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20js%20this%20%e7%bb%91%e5%ae%9a%20%28%20%e6%97%a0%e9%9c%80%e6%ad%bb%e8%ae%b0%e7%a1%ac%e8%83%8c%ef%bc%8c%e5%b0%be%e9%83%a8%e6%9c%89%e6%80%bb%e7%bb%93%e5%92%8c%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90%20%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3ejs 的 this 绑定问题，让多数新手懵逼，部分老手觉得恶心,这是因为this的绑定 ‘难以捉摸’，出错的时候还往往不知道为什么，相当反逻辑。\x3cbr\x3e让我们考虑下面代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var people = {\n    name : \x26quot;海洋饼干\x26quot;,\n    getName : function(){\n        console.log(this.name);\n    }\n};\nwindow.onload = function(){\n    xxx.onclick =  people.getName;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e people = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22海洋饼干\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n};\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    xxx.onclick =  people.getName;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在平时搬砖时比较常见的this绑定问题，大家可能也写给或者遇到过，当xxx.onclick触发时，输出什么呢 ？\x3c\/p\x3e\n\x3cp\x3e为了方便测试，我将代码简化:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var people = {\n    Name: \x26quot;海洋饼干\x26quot;,\n    getName : function(){\n        console.log(this.Name);\n    }\n};\nvar bar = people.getName;\n\nbar();    \/\/ undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e people = {\n    \x3cspan class=\x22hljs-attr\x22\x3eName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22海洋饼干\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.Name);\n    }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = people.getName;\n\nbar();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过这个小例子带大家感受一下\x3ccode\x3ethis\x3c\/code\x3e恶心的地方，我最开始遇到这个问题的时候也是一脸懵逼，因为代码里的\x3ccode\x3ethis\x3c\/code\x3e在创建时指向非常明显啊，指向自己 \x3ccode\x3epeople\x3c\/code\x3e 对象，但是实际上指向 \x3ccode\x3ewindow\x3c\/code\x3e 对象，这就是我马上要和大家说的 \x3cstrong\x3e\x3ccode\x3ethis\x3c\/code\x3e 绑定规则\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1 . \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e什么是\x3ccode\x3ethis\x3c\/code\x3e ？在讨论\x3ccode\x3ethis\x3c\/code\x3e绑定前，我们得先搞清楚this代表什么。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ethis是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3ethis指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时\x3c\/strong\x3e。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 \x3cstrong\x3e这，这个\x3c\/strong\x3e ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 \x3cstrong\x3e这个\x3c\/strong\x3e）\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2 . \x3ccode\x3ethis\x3c\/code\x3e 绑定规则\x3c\/h2\x3e\n\x3cp\x3e掌握了下面介绍的4种绑定的规则，那么\x3cstrong\x3e你只要看到函数调用就可以判断 \x3ccode\x3ethis\x3c\/code\x3e 的指向了\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e2 .1 默认绑定\x3c\/h2\x3e\n\x3cp\x3e考虑下面代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    var a = 1 ;\n    console.log(this.a);    \/\/ 10\n}\nvar a = 10;\nfoo();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\nfoo();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种就是典型的默认绑定，我们看看foo调用的位置，”光杆司令“，像 \x3cstrong\x3e这种直接使用而不带任何修饰的函数调用\x3c\/strong\x3e ，就 \x3cstrong\x3e默认且只能\x3c\/strong\x3e 应用 默认绑定。\x3c\/p\x3e\n\x3cp\x3e那默认绑定到哪呢，一般是\x3ccode\x3ewindow\x3c\/code\x3e上，严格模式下 是\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e2 .2 隐性绑定\x3c\/h2\x3e\n\x3cp\x3e代码说话:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a : 10,\n    foo : foo\n}\nfoo();                \/\/ ?\n\nobj.foo();            \/\/ ?\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n    console.log(this.a);\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobj\x3c\/span\x3e = \x3cspan class=\x22hljs-comment\x22\x3e{\n    a : 10,\n    foo : foo\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\nobj.foo();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e答案 : undefined 10\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3efoo()\x3c\/code\x3e的这个写法熟悉吗，就是我们刚刚写的默认绑定,等价于打印\x3ccode\x3ewindow.a\x3c\/code\x3e,故输出\x3ccode\x3eundefined\x3c\/code\x3e ,\x3cbr\x3e下面\x3ccode\x3eobj.foo()\x3c\/code\x3e这种大家应该经常写，这其实就是我们马上要讨论的 \x3cstrong\x3e隐性绑定\x3c\/strong\x3e 。\x3c\/p\x3e\n\x3cp\x3e函数foo执行的时候有了\x3cstrong\x3e上下文对象\x3c\/strong\x3e，即 \x3ccode\x3eobj\x3c\/code\x3e。这种情况下，\x3cstrong\x3e函数里的this默认绑定为上下文对象\x3c\/strong\x3e，等价于打印\x3ccode\x3eobj.a\x3c\/code\x3e,故输出\x3ccode\x3e10\x3c\/code\x3e 。\x3c\/p\x3e\n\x3cp\x3e如果是链性的关系，比如 \x3ccode\x3exx.yy.obj.foo();\x3c\/code\x3e, 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e2 .3 显性绑定\x3c\/h2\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e2 .3 .1 隐性绑定的限制\x3c\/h2\x3e\n\x3cp\x3e在我们刚刚的 \x3cstrong\x3e隐性绑定中有一个致命的限制，就是上下文必须包含我们的函数\x3c\/strong\x3e ，例：\x3ccode\x3evar obj = { foo : foo }\x3c\/code\x3e,如果上下文不包含我们的函数用隐性绑定明显是要出错的，\x3cstrong\x3e不可能每个对象都要加这个函数\x3c\/strong\x3e ,那样的话扩展,维护性太差了，我们接下来聊的就是直接 \x3cstrong\x3e给函数强制性绑定this\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e2 .3 .2 call apply bind\x3c\/h2\x3e\n\x3cp\x3e这里我们就要用到 js 给我们提供的函数 call 和 apply，\x3cstrong\x3e它们的作用都是改变函数的this指向\x3c\/strong\x3e，\x3cstrong\x3e第一个参数都是 设置this对象\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e两个函数的区别：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ecall从第二个参数开始所有的参数都是 原函数的参数。\x3c\/li\x3e\n\x3cli\x3eapply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a,b){\n    console.log(a\x2bb);\n}\nfoo.call(null,\x27海洋\x27,\x27饼干\x27);        \/\/ 海洋饼干  这里this指向不重要就写null了\nfoo.apply(null, [\x27海洋\x27,\x27饼干\x27] );     \/\/ 海洋饼干\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea,b\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a\x2bb);\n}\nfoo.call(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27海洋\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27饼干\x27\x3c\/span\x3e);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 海洋饼干  这里this指向不重要就写null了\x3c\/span\x3e\nfoo.apply(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27海洋\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27饼干\x27\x3c\/span\x3e] );     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 海洋饼干\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了 call，apply函数以外，还有一个改变this的函数 bind ，它和call,apply都不同。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ebind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回\x3c\/strong\x3e。例:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    console.log(this.a);\n}\nvar obj = { a : 10 };\n\nfoo = foo.bind(obj);\nfoo();                    \/\/ 10\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e };\n\nfoo = foo.bind(obj);\nfoo();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（bind函数非常特别，下次和大家一起讨论它的源码）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e2 .3 .2 显性绑定\x3c\/h2\x3e\n\x3cp\x3e开始正题，上代码，就用上面隐性绑定的例子 :\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a : 10            \/\/去掉里面的foo\n}\nfoo.call(obj);        \/\/ 10\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e            \x3cspan class=\x22hljs-comment\x22\x3e\/\/去掉里面的foo\x3c\/span\x3e\n}\nfoo.call(obj);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将隐性绑定例子中的 上下文对象 里的函数去掉了，显然现在不能用 \x3ccode\x3e上下文.函数\x3c\/code\x3e 这种形式来调用函数，大家看代码里的显性绑定代码\x3ccode\x3efoo.call(obj)\x3c\/code\x3e，看起来很怪，和我们之前所了解的函数调用不一样。\x3c\/p\x3e\n\x3cp\x3e其实call 是 foo 上的一个函数,在改变this指向的同时执行这个函数。\x3c\/p\x3e\n\x3cp\x3e（想要深入理解 [\x3ccode\x3ecall apply bind this硬绑定,软绑定,箭头函数绑定\x3c\/code\x3e ] 等更多黑科技 的小伙伴欢迎关注我或本文的评论，最近我会单独做一期放到一起写一篇文章）（\x3cstrong\x3e不想看的小伙伴不用担心，不影响对本文的理解\x3c\/strong\x3e）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e2 .4 new 绑定\x3c\/h2\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e2 .4 .1 什么是 \x3ccode\x3enew\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e学过面向对象的小伙伴对new肯定不陌生，js的new和传统的面向对象语言的new的作用都是创建一个新的对象，但是他们的机制完全不同。\x3c\/p\x3e\n\x3cp\x3e创建一个新对象少不了一个概念，那就是\x3ccode\x3e构造函数\x3c\/code\x3e，传统的面向对象 构造函数 是类里的一种特殊函数，要创建对象时使用\x3ccode\x3enew 类名()\x3c\/code\x3e的形式去调用类中的构造函数，而js中就不一样了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ejs中的只要用new修饰的 函数就是\x27构造函数\x27\x3c\/strong\x3e，准确来说是 \x3cstrong\x3e函数的\x3ccode\x3e构造调用\x3c\/code\x3e\x3c\/strong\x3e，因为在js中并不存在所谓的\x27构造函数\x27。\x3c\/p\x3e\n\x3cp\x3e那么用new 做到函数的\x3ccode\x3e构造调用\x3c\/code\x3e后，js帮我们做了什么工作呢:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建一个新对象。\x3c\/li\x3e\n\x3cli\x3e把这个新对象的\x3ccode\x3e__proto__\x3c\/code\x3e属性指向 原函数的\x3ccode\x3eprototype\x3c\/code\x3e属性。(即继承原函数的原型)\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e将这个新对象绑定到 此函数的this上 \x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e返回新对象，如果这个函数没有返回其他\x3cstrong\x3e对象\x3c\/strong\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第三条就是我们下面要聊的new绑定\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e2 .4 .2 new 绑定\x3c\/h2\x3e\n\x3cp\x3e不哔哔，看代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    this.a = 10;\n    console.log(this);\n}\nfoo();                    \/\/ window对象\nconsole.log(window.a);    \/\/ 10   默认绑定\n\nvar obj = new foo();      \/\/ foo{ a : 10 }  创建的新对象的默认名为函数名\n                          \/\/ 然后等价于 foo { a : 10 };  var obj = foo;\nconsole.log(obj.a);       \/\/ 10    new绑定\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\nfoo();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.a);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10   默认绑定\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo();      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ foo{ a : 10 }  创建的新对象的默认名为函数名\x3c\/span\x3e\n                          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后等价于 foo { a : 10 };  var obj = foo;\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj.a);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10    new绑定\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e使用new调用函数后，函数会 \x3cem\x3e以自己的名字 命名 和 创建\x3c\/em\x3e 一个新的对象，并返回。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    this.a = 10;\n    return new String(\x26quot;捣蛋鬼\x26quot;);\n}\nvar obj = new foo();\nconsole.log(obj.a);       \/\/ undefined\nconsole.log(obj);         \/\/ \x26quot;捣蛋鬼\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22捣蛋鬼\x22\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj.a);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22捣蛋鬼\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e2 .5 this绑定优先级\x3c\/h2\x3e\n\x3cp\x3e\x3cem\x3e过程是些无聊的代码测试，我直接写出优先级了\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new 绑定 \x3e 显示绑定 \x3e 隐式绑定 \x3e 默认绑定\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e\x3c\/span\x3e绑定 \x26gt; 显示绑定 \x26gt; 隐式绑定 \x26gt; 默认绑定\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e3 . 总结\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e如果函数被\x3ccode\x3enew\x3c\/code\x3e 修饰\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   this绑定的是新创建的对象，例:var bar = new foo();  函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e   \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e绑定的是新创建的对象，例:\x3cspan class=\x22hljs-type\x22\x3evar bar \x3c\/span\x3e= \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3efoo\x3c\/span\x3e();  函数 foo 中的 \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e\x3c\/span\x3e绑定 .\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果函数是使用\x3ccode\x3ecall,apply,bind\x3c\/code\x3e来调用的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e绑定的是 call,apply,bind 的第一个参数.例: foo.\x3cspan class=\x22hljs-keyword\x22\x3ecall\x3c\/span\x3e(obj); , foo 中的 \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e 就是 obj , 这样的绑定方式叫 显性绑定 .\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果函数是在某个 上下文对象 下被调用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   this绑定的是那个上下文对象，例 : var obj = { foo : foo };    obj.foo();  foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e绑定的是那个上下文对象，例 : \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { foo : foo };    obj.foo();  foo 中的 \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e 就是 obj . 这样的绑定方式叫 隐性绑定 .\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果都不是，即使用默认绑定\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   例:function foo(){...} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).\n   这样的绑定方式叫 默认绑定 .\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e   例:function foo()\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).\n   这样的绑定方式叫 默认绑定 .\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e4 . 面试题解析\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e1.\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = 10;\nvar obj = {\n    x: 20,\n    f: function(){\n        console.log(this.x);        \/\/ ?\n        var foo = function(){ \n            console.log(this.x);    \n            }\n        foo();                      \/\/ ?\n    }\n};\nobj.f();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x);    \n            }\n        foo();                      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n    }\n};\nobj.f();\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e-----------------------答案---------------------\x3cbr\x3e答案 ： 20 10\x3cbr\x3e解析 ：考点 \x3cstrong\x3e1.\x3c\/strong\x3e this默认绑定 \x3cstrong\x3e2.\x3c\/strong\x3e this隐性绑定\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = 10;\nvar obj = {\n    x: 20,\n    f: function(){\n        console.log(this.x);    \/\/ 20\n                                \/\/ 典型的隐性绑定,这里 f 的this指向上下文 obj ,即输出 20\n        function foo(){ \n            console.log(this.x); \n            }\n        foo();       \/\/ 10\n                     \/\/有些人在这个地方就想当然的觉得 foo 在函数 f 里,也在 f 里执行，\n                     \/\/那 this 肯定是指向obj 啊 , 仔细看看我们说的this绑定规则 , 对应一下很容易\n                     \/\/发现这种\x27光杆司令\x27，是我们一开始就示范的默认绑定,这里this绑定的是window\n    }\n};\nobj.f();             \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n                                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 典型的隐性绑定,这里 f 的this指向上下文 obj ,即输出 20\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x); \n            }\n        foo();       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n                     \x3cspan class=\x22hljs-comment\x22\x3e\/\/有些人在这个地方就想当然的觉得 foo 在函数 f 里,也在 f 里执行，\x3c\/span\x3e\n                     \x3cspan class=\x22hljs-comment\x22\x3e\/\/那 this 肯定是指向obj 啊 , 仔细看看我们说的this绑定规则 , 对应一下很容易\x3c\/span\x3e\n                     \x3cspan class=\x22hljs-comment\x22\x3e\/\/发现这种\x27光杆司令\x27，是我们一开始就示范的默认绑定,这里this绑定的是window\x3c\/span\x3e\n    }\n};\nobj.f();             \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e2.\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(arg){\n    this.a = arg;\n    return this\n};\n\nvar a = foo(1);\nvar b = foo(10);\n\nconsole.log(a.a);    \/\/ ?\nconsole.log(b.a);    \/\/ ?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earg\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = arg;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = foo(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = foo(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.a);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b.a);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e-----------------------答案---------------------\x3c\/p\x3e\n\x3cp\x3e答案 ： undefined 10\x3cbr\x3e解析 ：考点 \x3cstrong\x3e1.\x3c\/strong\x3e 全局污染 \x3cstrong\x3e2.\x3c\/strong\x3e this默认绑定 \x3c\/p\x3e\n\x3cp\x3e这道题很有意思，问题基本上都集中在第一undefined上，这其实是题目的小陷阱，但是追栈的过程绝对精彩\x3cbr\x3e让我们一步步分析这里发生了什么：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3efoo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window\x3cstrong\x3e.\x3c\/strong\x3ea = 1,return window;\x3c\/li\x3e\n\x3cli\x3evar a = foo(1) 等价于 window\x3cstrong\x3e.\x3c\/strong\x3ea = window , 很多人都忽略了\x3cstrong\x3evar a 就是window.a \x3c\/strong\x3e，将刚刚赋值的 1 替换掉了。\x3c\/li\x3e\n\x3cli\x3e所以这里的 a 的值是 window , a\x3cstrong\x3e.\x3c\/strong\x3ea 也是window ， 即window\x3cstrong\x3e.\x3c\/strong\x3ea = window ; window\x3cstrong\x3e.\x3c\/strong\x3ea\x3cstrong\x3e.\x3c\/strong\x3ea = window;\x3c\/li\x3e\n\x3cli\x3efoo(10) 和第一次一样，都是默认绑定，这个时候，\x3cstrong\x3e将window.a 赋值成 10\x3c\/strong\x3e ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)\x3c\/li\x3e\n\x3cli\x3evar b = foo(10); 等价于 window.b = window;\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10;\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e3.\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = 10;\nvar obj = {\n    x: 20,\n    f: function(){ console.log(this.x); }\n};\nvar bar = obj.f;\nvar obj2 = {\n    x: 30,\n    f: obj.f\n}\nobj.f();\nbar();\nobj2.f();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x); }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.f;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: obj.f\n}\nobj.f();\nbar();\nobj2.f();\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e-----------------------答案---------------------\x3cbr\x3e答案：20 10 30\x3cbr\x3e解析：传说中的送分题，考点，辨别this绑定\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = 10;\nvar obj = {\n    x: 20,\n    f: function(){ console.log(this.x); }\n};\nvar bar = obj.f;\nvar obj2 = {\n    x: 30,\n    f: obj.f\n}\nobj.f();    \/\/ 20\n            \/\/有上下文，this为obj，隐性绑定\nbar();      \/\/ 10\n            \/\/\x27光杆司令\x27 默认绑定  （ obj.f 只是普通的赋值操作 ）\nobj2.f();   \/\/30\n            \/\/不管 f 函数怎么折腾，this只和 执行位置和方式有关，即我们所说的绑定规则\n            \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x); }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.f;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: obj.f\n}\nobj.f();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/有上下文，this为obj，隐性绑定\x3c\/span\x3e\nbar();      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27光杆司令\x27 默认绑定  （ obj.f 只是普通的赋值操作 ）\x3c\/span\x3e\nobj2.f();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/30\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/不管 f 函数怎么折腾，this只和 执行位置和方式有关，即我们所说的绑定规则\x3c\/span\x3e\n            \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e4.\x3c\/strong\x3e 压轴题了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    getName = function () { console.log (1); };\n    return this;\n}\nfoo.getName = function () { console.log(2);};\nfoo.prototype.getName = function () { console.log(3);};\nvar getName = function () { console.log(4);};\nfunction getName () { console.log(5);}\n \nfoo.getName ();                \/\/ ?\ngetName ();                    \/\/ ?\nfoo().getName ();              \/\/ ?\ngetName ();                    \/\/ ?\nnew foo.getName ();            \/\/ ?\nnew foo().getName ();          \/\/ ?\nnew new foo().getName ();      \/\/ ?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log (\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); };\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n}\nfoo.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);};\nfoo.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetName\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);}\n \nfoo.getName ();                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\ngetName ();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\nfoo().getName ();              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\ngetName ();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo.getName ();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo().getName ();          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo().getName ();      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e-----------------------答案---------------------\x3cbr\x3e答案：2 4 1 1 2 3 3 \x3cbr\x3e解析：考点 1. new绑定 2.隐性绑定 3. 默认绑定 4.变量污染\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    getName = function () { console.log (1); }; \n            \/\/这里的getName 将创建到全局window上\n    return this;\n}\nfoo.getName = function () { console.log(2);};   \n        \/\/这个getName和上面的不同，是直接添加到foo上的\nfoo.prototype.getName = function () { console.log(3);}; \n        \/\/ 这个getName直接添加到foo的原型上，在用new创建新对象时将直接添加到新对象上 \nvar getName = function () { console.log(4);}; \n        \/\/ 和foo函数里的getName一样, 将创建到全局window上\nfunction getName () { console.log(5);}    \n        \/\/ 同上，但是这个函数不会被使用，因为函数声明的提升优先级最高，所以上面的函数表达式将永远替换\n        \/\/ 这个同名函数，除非在函数表达式赋值前去调用getName()，但是在本题中，函数调用都在函数表达式\n        \/\/ 之后，所以这个函数可以忽略了\n        \n        \/\/ 通过上面对 getName的分析基本上答案已经出来了\n\nfoo.getName ();                \/\/ 2\n                               \/\/ 下面为了方便，我就使用输出值来简称每个getName函数\n                               \/\/ 这里有小伙伴疑惑是在 2 和 3 之间，觉得应该是3 , 但其实直接设置\n                               \/\/ foo.prototype上的属性，对当前这个对象的属性是没有影响的,如果要使\n                               \/\/ 用的话，可以foo.prototype.getName() 这样调用 ，这里需要知道的是\n                               \/\/ 3 并不会覆盖 2，两者不冲突 ( 当你使用new 创建对象时，这里的\n                               \/\/ Prototype 将自动绑定到新对象上，即用new 构造调用的第二个作用)\n                               \ngetName ();                    \/\/ 4 \n                               \/\/ 这里涉及到函数提升的问题，不知道的小伙伴只需要知道 5 会被 4 覆盖，\n                               \/\/ 虽然 5 在 4 的下面，其实 js 并不是完全的自上而下，想要深入了解的\n                               \/\/ 小伙伴可以看文章最后的链接\n                               \nfoo().getName ();              \/\/ 1 \n                               \/\/ 这里的foo函数执行完成了两件事, 1. 将window.getName设置为1,\n                               \/\/ 2. 返回window , 故等价于 window.getName(); 输出 1\ngetName ();                    \/\/ 1\n                               \/\/ 刚刚上面的函数刚把window.getName设置为1,故同上 输出 1\n                               \nnew foo.getName ();            \/\/ 2\n                               \/\/ new 对一个函数进行构造调用 , 即 foo.getName ,构造调用也是调用啊\n                               \/\/ 该执行还是执行，然后返回一个新对象，输出 2 (虽然这里没有接收新\n                               \/\/ 创建的对象但是我们可以猜到，是一个函数名为 foo.getName 的对象\n                               \/\/ 且__proto__属性里有一个getName函数，是上面设置的 3 函数)\n                               \nnew foo().getName ();          \/\/ 3\n                               \/\/ 这里特别的地方就来了,new 是对一个函数进行构造调用,它直接找到了离它\n                               \/\/ 最近的函数,foo(),并返回了应该新对象,等价于 var obj = new foo();\n                               \/\/ obj.getName(); 这样就很清晰了,输出的是之前绑定到prototype上的\n                               \/\/ 那个getName  3 ,因为使用new后会将函数的prototype继承给 新对象\n                               \nnew new foo().getName ();      \/\/ 3\n                               \/\/ 哈哈，这个看上去很吓人，让我们来分解一下：\n                               \/\/ var obj = new foo();\n                               \/\/ var obj1 = new obj.getName();\n                               \/\/ 好了，仔细看看, 这不就是上两题的合体吗,obj 有getName 3, 即输出3\n                               \/\/ obj 是一个函数名为 foo的对象,obj1是一个函数名为obj.getName的对象\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log (\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); }; \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里的getName 将创建到全局window上\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n}\nfoo.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);};   \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/这个getName和上面的不同，是直接添加到foo上的\x3c\/span\x3e\nfoo.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);}; \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个getName直接添加到foo的原型上，在用new创建新对象时将直接添加到新对象上 \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);}; \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 和foo函数里的getName一样, 将创建到全局window上\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetName\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);}    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同上，但是这个函数不会被使用，因为函数声明的提升优先级最高，所以上面的函数表达式将永远替换\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个同名函数，除非在函数表达式赋值前去调用getName()，但是在本题中，函数调用都在函数表达式\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 之后，所以这个函数可以忽略了\x3c\/span\x3e\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过上面对 getName的分析基本上答案已经出来了\x3c\/span\x3e\n\nfoo.getName ();                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面为了方便，我就使用输出值来简称每个getName函数\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里有小伙伴疑惑是在 2 和 3 之间，觉得应该是3 , 但其实直接设置\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ foo.prototype上的属性，对当前这个对象的属性是没有影响的,如果要使\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用的话，可以foo.prototype.getName() 这样调用 ，这里需要知道的是\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3 并不会覆盖 2，两者不冲突 ( 当你使用new 创建对象时，这里的\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Prototype 将自动绑定到新对象上，即用new 构造调用的第二个作用)\x3c\/span\x3e\n                               \ngetName ();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4 \x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里涉及到函数提升的问题，不知道的小伙伴只需要知道 5 会被 4 覆盖，\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 虽然 5 在 4 的下面，其实 js 并不是完全的自上而下，想要深入了解的\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 小伙伴可以看文章最后的链接\x3c\/span\x3e\n                               \nfoo().getName ();              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1 \x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的foo函数执行完成了两件事, 1. 将window.getName设置为1,\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 返回window , 故等价于 window.getName(); 输出 1\x3c\/span\x3e\ngetName ();                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 刚刚上面的函数刚把window.getName设置为1,故同上 输出 1\x3c\/span\x3e\n                               \n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo.getName ();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ new 对一个函数进行构造调用 , 即 foo.getName ,构造调用也是调用啊\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该执行还是执行，然后返回一个新对象，输出 2 (虽然这里没有接收新\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建的对象但是我们可以猜到，是一个函数名为 foo.getName 的对象\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 且__proto__属性里有一个getName函数，是上面设置的 3 函数)\x3c\/span\x3e\n                               \n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo().getName ();          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里特别的地方就来了,new 是对一个函数进行构造调用,它直接找到了离它\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最近的函数,foo(),并返回了应该新对象,等价于 var obj = new foo();\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj.getName(); 这样就很清晰了,输出的是之前绑定到prototype上的\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 那个getName  3 ,因为使用new后会将函数的prototype继承给 新对象\x3c\/span\x3e\n                               \n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo().getName ();      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 哈哈，这个看上去很吓人，让我们来分解一下：\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ var obj = new foo();\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ var obj1 = new obj.getName();\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 好了，仔细看看, 这不就是上两题的合体吗,obj 有getName 3, 即输出3\x3c\/span\x3e\n                               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj 是一个函数名为 foo的对象,obj1是一个函数名为obj.getName的对象\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e5 . 箭头函数的this绑定 \x3cem\x3e(2017.9.18更新)\x3c\/em\x3e\n\x3c\/h2\x3e\n\x3cp\x3e箭头函数，一种特殊的函数，不使用\x3ccode\x3efunction\x3c\/code\x3e关键字，而是使用\x3ccode\x3e=\x26gt;\x3c\/code\x3e，学名 \x3ccode\x3e胖箭头\x3c\/code\x3e(2333),它和普通函数的区别：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e箭头函数不使用我们上面介绍的四种绑定，而是\x3cstrong\x3e完全根据外部作用域来决定this\x3c\/strong\x3e。(它的父级是使用我们的规则的哦)\x3c\/li\x3e\n\x3cli\x3e箭头函数的this绑定无法被修改 (这个特性非常爽（滑稽）)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e先看个代码巩固一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    return ()=\x3e{\n        console.log(this.a);\n    }\n}\nfoo.a = 10;\n\n\/\/ 1. 箭头函数关联父级作用域this\n\nvar bar = foo();            \/\/ foo默认绑定\nbar();                      \/\/ undefined 哈哈，是不是有小伙伴想当然了\n\nvar baz = foo.call(foo);    \/\/ foo 显性绑定\nbaz();                      \/\/ 10 \n\n\/\/ 2. 箭头函数this不可修改\n\/\/这里我们使用上面的已经绑定了foo 的 baz\nvar obj = {\n    a : 999\n}\nbaz.call(obj);              \/\/ 10\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);\n    }\n}\nfoo.a = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. 箭头函数关联父级作用域this\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ foo默认绑定\x3c\/span\x3e\nbar();                      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined 哈哈，是不是有小伙伴想当然了\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e baz = foo.call(foo);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ foo 显性绑定\x3c\/span\x3e\nbaz();                      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10 \x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 箭头函数this不可修改\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里我们使用上面的已经绑定了foo 的 baz\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e999\x3c\/span\x3e\n}\nbaz.call(obj);              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e来来来，实战一下，还记得我们之前第一个例子吗，将它改成箭头函数的形式(可以彻底解决恶心的this绑定问题)：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var people = {\n    Name: \x26quot;海洋饼干\x26quot;,\n    getName : function(){\n        console.log(this.Name);\n    }\n};\nvar bar = people.getName;\n\nbar();    \/\/ undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e people = {\n    \x3cspan class=\x22hljs-attr\x22\x3eName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22海洋饼干\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.Name);\n    }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = people.getName;\n\nbar();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e====================修改后====================\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var people = {\n    Name: \x26quot;海洋饼干\x26quot;,\n    getName : function(){\n        return ()=\x3e{\n            console.log(this.Name);\n        }\n    }\n};\nvar bar = people.getName(); \/\/获得一个永远指向people的函数，不用想this了,岂不是美滋滋？\n\nbar();    \/\/ 海洋饼干 \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e people = {\n    \x3cspan class=\x22hljs-attr\x22\x3eName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22海洋饼干\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.Name);\n        }\n    }\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = people.getName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/获得一个永远指向people的函数，不用想this了,岂不是美滋滋？\x3c\/span\x3e\n\nbar();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 海洋饼干 \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可能会有人不解为什么在箭头函数外面再套一层，直接写不就行了吗，搞这么麻烦干嘛，其实这\x3cstrong\x3e也是箭头函数很多人用不好的地方\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj= {\n    that : this,\n    bar : function(){\n        return ()=\x3e{\n            console.log(this);\n        }\n    },\n    baz : ()=\x3e{\n        console.log(this);\n    }\n}\nconsole.log(obj.that);  \/\/ window\nobj.bar()();            \/\/ obj\nobj.baz();              \/\/ window\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj= {\n    \x3cspan class=\x22hljs-attr\x22\x3ethat\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ebar\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        }\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3ebaz\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj.that);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window\x3c\/span\x3e\nobj.bar()();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj\x3c\/span\x3e\nobj.baz();              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e我们先要搞清楚一点，obj的当前作用域是window,如 obj.that === window。\x3c\/li\x3e\n\x3cli\x3e如果不用function（function有自己的函数作用域）将其包裹起来，那么默认绑定的父级作用域就是window。\x3c\/li\x3e\n\x3cli\x3e用function包裹的目的就是将箭头函数绑定到当前的对象上。函数的作用域是当前这个对象，然后箭头函数会自动绑定函数所在作用域的this，即obj。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e美滋滋，溜了溜了\x3c\/p\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3cp\x3e参考书籍：你不知道的JavaScript\x26lt;上卷\x26gt; ＫＹＬＥ　ＳＩＭＰＳＯＮ　著　（推荐）\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011194676">https://segmentfault.com/a/1190000011194676</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5sn0oyr4sev/" target="_blank">https://alili.tech/archive/5sn0oyr4sev/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>