<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tutorial: 分页"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Tutorial: 分页 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/66bfda4/",
				"appid": "1613049289050283", 
				"title": "Tutorial: 分页 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-22T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fa871c5d/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/99750d9b/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&text=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&text=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&title=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&is_video=false&description=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Tutorial%3a%20%e5%88%86%e9%a1%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&title=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&title=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&title=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66bfda4%2f&title=Tutorial%3a%20%e5%88%86%e9%a1%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Tutorial: 分页</h1><div class="meta"><div class="postdate"><time datetime="2018-10-22" itemprop="datePublished">2018-10-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3chr\x3e\n\x3cp\x3e这是我们的完整的React \x2b GraphQL教程系列的第8部分。 每个部分都是独立的，并且引入了一个新的关键概念，因此您可以单独执行每个部分，也可以按照整个系列学习 - 当然这取决于您！\x3c\/p\x3e\n\x3cp\x3e以下是我们迄今为止所涉及的部分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b\x22\x3ePart 1: 前端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-part-2-server-99d0528c7928\x22\x3ePart 2: 服务端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-mutations-764d7ec23c15\x22\x3ePart 3: 基础的 GraphQL Mutations\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3ePart 4: 友好的用户界面和客户端存储更新\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/medium.com\/p\/tutorial-graphql-input-types-and-client-caching-f11fa0421cfd\x22\x3ePart 5:输入类型和自定义解析器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-server-side-e51c32dc2951\x22\x3ePart 6: 订阅服务器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76\x22\x3ePart 7: 客户端上的GraphQL订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在第6部分和第7部分中，我们介绍了如何向服务器添加订阅以及在客户端中热修改服务器。 在本部分中，我们将添加分页，以便您的服务器可以以更小的块发送数据，而不是一次发送所有内容。 到最后，你会知道以下部分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用游标和限制来控制从服务器返回的数据量\x3c\/li\x3e\n\x3cli\x3e使用Apollo客户端获取更多功能\x3c\/li\x3e\n\x3cli\x3e响应按钮点击实现基于光标的分页\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e首先，让我们克隆git仓库并安装依赖关系。 即使您完成了教程的前几部分，我们也建议您重新克隆存储库，因为我们已经对上一步中的应用程序的文件结构进行了一些有用的更改。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3egit clone https:\x3cspan class=\x22hljs-string\x22\x3e\/\/github.com\/apollographql\/graphql-tutorial.gitcd\x3c\/span\x3e graphql-tutorialgit checkout t8-startcd server \x26amp;\x26amp; npm install \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ecd\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e..\/client\x3c\/span\x3e \x26amp;\x26amp; npm install \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ecd\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e..\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e为了确保它的工作，让我们启动服务器和客户端，每个都在一个单独的终端中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servernpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在另一个终端中输入：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e clientnpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当您将浏览器导航到\x3ca href=\x22http:\/\/localhost:3000\x22\x3ehttp:\/\/localhost:3000\x3c\/a\x3e 时，您应该会看到我们的消息应用程序的主页。 当你点击“faker”频道时，你会看到一长串随机生成的消息。 （我们需要为这一步生成一个长列表，以演示如何避免一次加载它。）\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01dff36efab2c10c8f.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e与其预先加载所有这些消息，我们可以实现分页并且一次只加载一页的价值数据。\x3c\/p\x3e\n\x3ch3\x3e更新架构\x3c\/h3\x3e\n\x3cp\x3e我们首先对服务器的模式进行一些更改，以公开一个API来加载更小的项目块。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eserver\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eschema.js\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst typeDefs =\x3cspan class=\x22hljs-built_in\x22\x3e type \x3c\/span\x3eChannel {  id: ID!                # \x3cspan class=\x22hljs-string\x22\x3e\x22!\x22\x3c\/span\x3e denotes a required field  name: String  messages: [Message]  # messages will be returned \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e a MessageFeed object wrapper  messageFeed(cursor: String): MessageFeed  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eMessageInput\x3c\/span\x3e{  \x3cspan class=\x22hljs-attribute\x22\x3echannelId\x3c\/span\x3e: ID!  text: String}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e# ...\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e {  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!  text: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e  createdAt: \x3cspan class=\x22hljs-type\x22\x3eInt\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs vim\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e MessageFeed {  # \x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e specifies the place in the \x3cspan class=\x22hljs-keyword\x22\x3elist\x3c\/span\x3e where we \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e off  \x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e: String!    # this \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e chunk of \x3cspan class=\x22hljs-keyword\x22\x3emessages\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ebe\x3c\/span\x3e returned  message\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e [Message]!}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e除了返回正确的消息块之外，messageFeed类型还返回一个游标，该游标告诉客户端我们在列表中的位置。 然后，当我们想要加载更多的消息时，我们可以将这个值传递回服务器，告诉它接下来给我们的消息。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e分页中的游标是什么?\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e游标是指向我们在数据中遗漏的位置的指针。 更具体地说，游标是可以保存客户端可以传递给服务器的任何值的变量，以帮助它找到应该开始返回数据的点。 不管你使用什么样的价值，事实上，从客户的角度来看，它应该是不透明的。\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e在这个例子中，我们将使用时间戳作为游标。 这比指向数组中的实际消息ID或消息索引要好得多。 如果我们使用ID或索引，则删除和插入的消息可能会导致问题：我们可能无法找到该特定ID，或者索引现在可能指向不同的消息。 在我们的网站阅读更多\x3c\/em\x3e \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/understanding-pagination-rest-graphql-and-relay-b10f835549e7\x22\x3e\x3cem\x3eprevious article about understanding pagination\x3c\/em\x3e\x3c\/a\x3e_._\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e接下来，让我们为服务器上的解析器文件中的messageFeed添加一个新的解析器。 让我们在查询解析器下添加加粗的代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e  Query: {    channels: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e channels;\n},\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e    channel: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(root, { id })\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e getChannel(id);\n},  },\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs arduino\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ The new resolvers are under the Channel type  Channel: {    messageFeed: (channel, { cursor }) =\x26gt; {      \/\/ The cursor passed in by the client will be an      \/\/ integer timestamp. If no cursor is passed in,      \/\/ set the cursor equal to the time at which the      \/\/ last message in the channel was created.      if (!cursor) {        cursor =          channel.messages[channel.messages.length - 1].createdAt;\x3c\/span\x3e\n}            \x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs nimrod\x22\x3e      \/\/ limit \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e the number \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e messages we will \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e.      \/\/ \x3cspan class=\x22hljs-type\x22\x3eWe\x3c\/span\x3e could pass it \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e an argument but \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e this      \/\/ \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e\x27s use a \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e value.      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e limit = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newestMessageIndex = channel.messages.findIndex(        message =\x26gt; message.createdAt === cursor      );\n\/\/ find index \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e message created at time held \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e cursor\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We need to return a new cursor to the client so that it      \/\/ can find the next page. Let\x27s set newCursor to the      \/\/ createdAt time of the last message in this messageFeed:      const newCursor =        channel.messages[newestMessageIndex - limit].createdAt;\x3c\/span\x3e\nconst messageFeed = {        messages: \x3cspan class=\x22hljs-type\x22\x3echannel\x3c\/span\x3e.messages.slice(          \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestMessageIndex\x3c\/span\x3e - limit,          \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestMessageIndex\x3c\/span\x3e        ),        cursor: \x3cspan class=\x22hljs-type\x22\x3enewCursor\x3c\/span\x3e,      };\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e messageFeed;\n},  },\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e请注意，如果没有将光标传递给查询，我们将光标设置为等于创建最近消息的时间，并且服务器将返回最近的消息。 这样，客户端可以轻松查询最初的页面加载时的最新消息。 我们还使用10的限制来指定要获取的消息数量，并相应地更新由messageFeed返回的游标，以便客户端稍后可以获取下一页的项目。\x3c\/p\x3e\n\x3ch4\x3eTest it out\x3c\/h4\x3e\n\x3cp\x3e此时，您应该能够测试您的服务器以确保上述所有代码都正确运行。 在浏览器中导航到 \x3ca href=\x22http:\/\/localhost:4000\/graphiql\x22\x3ehttp:\/\/localhost:4000\/graphiql\x3c\/a\x3e ，然后运行以下查询：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t012d42c097310e0f5b.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e您会看到我们现在可以通过messageFeed包装器检索邮件，该邮件还向我们提供了有关下一页的光标的信息，而且我们一次只能获得10个项目，而不是整个列表。 如果我们通过光标，我们得到了一个参数，我们得到了10个消息的新列表，它们代表我们离开的地方：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01e14e88233fc698ae.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e现在，让我们使用我们新发现的功能，通过加载正在显示的消息来提高客户端的效率。\x3c\/p\x3e\n\x3ch3\x3e更新客户端\x3c\/h3\x3e\n\x3cp\x3e在src \/ components \/ ChannelDetails.js（在客户端代码中），将频道详细信息查询替换为以下查询，其中包括新的messageFeed字段和一些关于分页的信息：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs arduino\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e channelDetailsQuery = gql  query ChannelDetailsQuery($channelId: ID!, $\x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e) {    channel(id: $channelId) {      id      name      messageFeed(\x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e: $\x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e) @connection(key: \x3cspan class=\x22hljs-string\x22\x3e\x22messageFeed\x22\x3c\/span\x3e) {        \x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e        messages {          id          \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e        }      }    }  };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e由于我们将在UI中显示的消息现在嵌套在messageFeed下，我们还需要更新我们的ChannelDetails组件。 对粗体渲染函数进行粗体更改以访问messageFeed属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3e    return\x3c\/span\x3e (                        {channel.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e}                          );\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e更新后的查询现在一次只能返回10条消息，而不是返回通道中的所有消息。\x3c\/p\x3e\n\x3ch4\x3e更新我们的变异和订阅代码\x3c\/h4\x3e\n\x3cp\x3e我们现在加载嵌套在messageFeed字段下的消息，所以这些消息将存储在Apollo客户端缓存中。 您可以通过打开Chrome开发工具并检查商店选项卡来确认：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01394223ea308ad2f7.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e因此，我们需要更新我们的订阅和突变代码，该代码更新该列表以注意该嵌套，基本上用channel.messageFeed.messages替换channel.messages。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eIn src\/components\/AddMessage.js:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs armasm\x22\x3e\/\/ don’t double \x3cspan class=\x22hljs-keyword\x22\x3eadd \x3c\/span\x3ethe messageif (!\x3cspan class=\x22hljs-meta\x22\x3edata\x3c\/span\x3e.channel.messageFeed.messages.find((msg) =\x26gt;    msg.id === \x3cspan class=\x22hljs-keyword\x22\x3eaddMessage.id)) \x3c\/span\x3e{  \/\/ \x3cspan class=\x22hljs-keyword\x22\x3eAdd \x3c\/span\x3eour Message from the mutation to the \x3cspan class=\x22hljs-meta\x22\x3eend\x3c\/span\x3e.  \x3cspan class=\x22hljs-meta\x22\x3edata\x3c\/span\x3e.channel.messageFeed.messages.\x3cspan class=\x22hljs-keyword\x22\x3epush(addMessage);}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cstrong\x3eSimilarly, in src\/components\/ChannelDetails.js:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e don’t double add the messageif (!prev.channel.messageFeed.messages.find(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(msg)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e    msg.id === newMessage.id)) {\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Object.assign({}, prev, {    channel: Object.assign({}, prev.channel, {      messageFeed: {        messages: […prev.channel.messageFeed.messages, newMessage],      }    })  });} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {  return prev;}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，进入用户界面，在相同频道中打开两个制表符，然后测试添加消息。 它应该通过突变支持和订阅在屏幕和其他屏幕上正确显示。\x3c\/p\x3e\n\x3cp\x3e如果你被困在这一步，请检查[第8步开始和结束之间的差异]（\x3ca href=\x22https:\/\/github.com\/apollographql\/graphql-tutorial\/compare\/t8-start...t8-end）\x22\x3ehttps:\/\/github.com\/apollographql\/graphql-tutorial\/compare\/t8-start...t8-end）\x3c\/a\x3e 到 查看所有必要的更改。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e连接指令\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e_我们还在查询中将_connection _directive添加到 _messageFeed _field。 这是一个专门的客户端指令，用于控制该字段下的数据如何缓存在Apollo客户端存储中。 由于处理分页的字段通常会有一些额外的参数，如_cursor _或\x3cem\x3elimit\x3c\/em\x3e，我们要确保我们有一个干净的缓存键，不包含这些参数._\x3c\/p\x3e\n\x3cp\x3e_I在这种情况下，我们指定从该字段返回的数据应该存储在key_messageFeed_下，这使得从添加新消息的突变中添加到该列表更容易。 如果我们没有在该字段上使用_connection_directive，那么我们的mutation _update_function将需要重现最初传递给该字段的参数的确切集合._\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e现在我们准备添加fetchMore函数，这是我们在Apollo客户端添加分页的主要方式。 我们将定义一个名为loadOlderMessages的函数，可以通过传递给我们ChannelDetails组件的道具来访问它。 该函数将使用Apollo Client附加到数据通道的fetchMore方法。\x3c\/p\x3e\n\x3cp\x3e让我们将粗体代码添加到选项字段旁的channelDetailsQuery容器中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eexport\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3e default \x3c\/span\x3e(graphql(channelDetailsQuery, {  options: (props) =\x26gt; ({    variables: {       channelId: props.match.params.channelId,    },  }),\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e  props: (props) =\x26gt; {    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e: props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e,      loadOlderMessages: () =\x26gt; {        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.fetchMore({          variables: {            channelId: props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.channel.id,            cursor: props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.channel.messageFeed.cursor,          },\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e          updateQuery(previousResult, { fetchMoreResult }) {            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevMessageFeed =              previousResult.channel.messageFeed;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newMessageFeed =              fetchMoreResult.channel.messageFeed;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs vim\x22\x3e            const newChannelData = {...previousResult.channel,              messageFeed: {                message\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e [                  ...newMessageFeed.\x3cspan class=\x22hljs-keyword\x22\x3emessages\x3c\/span\x3e,                  ...prevMessageFeed.\x3cspan class=\x22hljs-keyword\x22\x3emessages\x3c\/span\x3e                ],                \x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e: newMessageFeed.\x3cspan class=\x22hljs-built_in\x22\x3ecursor\x3c\/span\x3e              }            }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3e            const newData\x3c\/span\x3e =  {              ...previousResult,              channel: newChannelData            };\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs abnf\x22\x3e            return newData\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n}        })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n}    }\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n}})(ChannelDetails))\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eloadOlderMessages函数使用消息所属通道的id和第一个channelDetailsQuery返回的游标调用fetchMore。 fetchMore函数将默认使用原始查询（在本例中为channelDetailsQuery），所以我们只传入新变量。 请注意，我们实际上需要在loadOlderMessages函数中指定游标，因为我们不再需要最近的消息。 一旦从服务器返回新数据，我们使用Apollo Client的updateQuery函数将新数据与现有数据合并，这将导致您的UI组件的扩展列表重新呈现。 作为最后一步，让我们在ChannelDetails组件中添加一个\x27Load Old Messages\x27按钮。 用粗体代码更新渲染功能：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e (                        Load Older Messages                                {channel.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e}                            );\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，如果您访问\x3ca href=\x22http:\/\/localhost:3000\/channel\/1\x22\x3ehttp:\/\/localhost:3000\/channel\/1\x3c\/a\x3e， 然后单击“Load Older Messages”按钮， 出现在屏幕的顶部，并且已经显示的消息将被压入列表中！ 并且，您已经实现了基于光标的分页。\x3c\/p\x3e\n\x3ch3\x3e总结\x3c\/h3\x3e\n\x3cp\x3e恭喜，您已经在本系列教程的第8部分结束了！ 您已经学会了如何使用游标，限制和fetchMore函数更新您的服务器和客户端，并在您的应用中实现基于光标的分页。 随着更多的变化像auth，我们将在后面的教程中介绍，您的应用程序将准备好实际使用！\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3eThanks to my mentor\x3c\/em\x3e \x3ca href=\x22https:\/\/medium.com\/@stubailo\x22\x3e\x3cem\x3eSashko Stubailo\x3c\/em\x3e\x3c\/a\x3e \x3cem\x3eand fellow intern\x3c\/em\x3e \x3ca href=\x22https:\/\/medium.com\/@klaire_tan\x22\x3e\x3cem\x3eKlaire Tan\x3c\/em\x3e\x3c\/a\x3e \x3cem\x3efor helping me understand pagination and write this tutorial!\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014fc6606574d991f5.jpg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/tutorial-pagination">https://www.zcfy.cc/article/tutorial-pagination</a></p><h2 id="原文标题">原文标题</h2><p>Tutorial: 分页</p><h2>本文链接：</h2><a href="https://alili.tech/archive/66bfda4/" target="_blank">https://alili.tech/archive/66bfda4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>