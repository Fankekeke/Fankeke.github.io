<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="ReactV16.3即将更改的生命周期"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>ReactV16.3即将更改的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/66f04d69/",
				"appid": "1613049289050283", 
				"title": "ReactV16.3即将更改的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3c853404/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/67b05647/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&text=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&text=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&title=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&is_video=false&description=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&title=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&title=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&title=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f66f04d69%2f&title=ReactV16.3%e5%8d%b3%e5%b0%86%e6%9b%b4%e6%94%b9%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">ReactV16.3即将更改的生命周期</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3eMarch 27, 2018 by \x3ca href=\x22https:\/\/github.com\/bvaughn\x22\x3eBrian Vaughn\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e一年多来，React团队一直致力于实现异步渲染。上个月，他在JSConf冰岛的演讲中，\x3ca href=\x22https:\/\/reactjs.org\/blog\/2018\/03\/01\/sneak-peek-beyond-react-16.html\x22\x3e丹揭示了一些令人兴奋的新的异步渲染可能性\x3c\/a\x3e。现在，我们希望与您分享我们在学习这些功能时学到的一些经验教训，以及一些帮助您准备组件以在启动时进行异步渲染的方法。\x3c\/p\x3e\n\x3cp\x3e我们了解到的最大问题之一是，我们的一些传统组件生命周期会导致一些不安全的编码实践。他们是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillMount\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这些生命周期方法经常被误解和滥用;此外，我们预计他们的潜在滥用可能在异步渲染方面有更大的问题。因此，我们将在即将发布的版本中为这些生命周期添加一个“UNSAFE_”前缀。 （这里，“不安全”不是指安全性，而是表示使用这些生命周期的代码将更有可能在未来的React版本中存在缺陷，特别是一旦启用了异步渲染）。\x3c\/p\x3e\n\x3ch2\x3e\x3ca href=\x22https:\/\/reactjs.org\/#gradual-migration-path\x22\x3e\x3c\/a\x3e逐步迁移路径\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/reactjs.org\/blog\/2016\/02\/19\/new-versioning-scheme.html\x22\x3eReact遵循语义版本控制\x3c\/a\x3e, 所以这种改变将是渐进的。我们目前的计划是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e16.3\x3c\/strong\x3e：为不安全生命周期引入别名UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps和UNSAFE_componentWillUpdate。 （旧的生命周期名称和新的别名都可以在此版本中使用。） \x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e未来的16.x版本\x3c\/strong\x3e：为componentWillMount，componentWillReceiveProps和componentWillUpdate启用弃用警告。 （旧的生命周期名称和新的别名都可以在此版本中使用，但旧名称会记录DEV模式警告。） \x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e17.0：\x3c\/strong\x3e删除componentWillMount，componentWillReceiveProps和componentWillUpdate。 （从现在开始，只有新的“UNSAFE_”生命周期名称将起作用。）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e请注意，如果您是React应用程序开发人员，那么您不必对遗留方法进行任何操作。即将发布的16.3版本的主要目的是让开源项目维护人员在任何弃用警告之前更新其库。这些警告将在未来的16.x版本发布之前不会启用。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们在Facebook上维护了超过50,000个React组件，我们不打算立即重写它们。我们知道迁移需要时间。我们将采用逐步迁移路径以及React社区中的所有人。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2\x3e\x3ca href=\x22https:\/\/reactjs.org\/#migrating-from-legacy-lifecycles\x22\x3e从传统生命周期迁移\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3e如果您想开始使用React 16.3中引入的新组件API（或者如果您是维护人员提前更新库），以下是一些示例，我们希望这些示例可以帮助您开始考虑组件的变化。随着时间的推移，我们计划在文档中添加额外的“配方”，以展示如何以避免有问题的生命周期的方式执行常见任务。\x3c\/p\x3e\n\x3cp\x3e在开始之前，我们将简要概述为16.3版计划的生命周期更改：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eWe are \x3cstrong\x3eadding the following lifecycle aliases\x3c\/strong\x3e: \x3ccode\x3eUNSAFE_componentWillMount\x3c\/code\x3e, \x3ccode\x3eUNSAFE_componentWillReceiveProps\x3c\/code\x3e, and \x3ccode\x3eUNSAFE_componentWillUpdate\x3c\/code\x3e. (Both the old lifecycle names and the new aliases will be supported.)\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eWe are \x3cstrong\x3eintroducing two new lifecycles\x3c\/strong\x3e, static \x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e and \x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e.\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们正在\x3cstrong\x3e添加以下生命周期别名\x3c\/strong\x3e：\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e(1) UNSAFE_componentWillMount，\x3c\/p\x3e\n\x3cp\x3e(2) UNSAFE_componentWillReceiveProps\x3c\/p\x3e\n\x3cp\x3e(3) UNSAFE_componentWillUpdate。 （旧的生命周期名称和新的别名都将受支持。） \x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e我们介绍了\x3cstrong\x3e两个新的生命周期\x3c\/strong\x3e，分别是getDerivedStateFromProps和getSnapshotBeforeUpdate。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#new-lifecycle-getderivedstatefromprops\x22\x3e新的生命周期:\x3c\/a\x3e \x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static getDerivedStateFromProps(nextProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e新的静态\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e生命周期在组件实例化以及接收新\x3ccode\x3eprops\x3c\/code\x3e后调用。它可以返回一个对象来更新\x3ccode\x3estate\x3c\/code\x3e，或者返回null来表示新的\x3ccode\x3eprops\x3c\/code\x3e不需要任何\x3ccode\x3estate\x3c\/code\x3e更新。\x3c\/p\x3e\n\x3cp\x3e与\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e一起，这个新的生命周期应该覆盖传统\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e的所有用例。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#new-lifecycle-getsnapshotbeforeupdate\x22\x3e新的生命周期:\x3c\/a\x3e \x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e新的\x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）\x3c\/p\x3e\n\x3cp\x3e与\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e一起，这个新的生命周期将覆盖旧版\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e的所有用例。\x3c\/p\x3e\n\x3cp\x3eYou can find their type signatures \x3ca href=\x22https:\/\/gist.github.com\/gaearon\/88634d27abbc4feeb40a698f760f3264\x22\x3ein this gist\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e我们看看如何在使用这两种生命周期的，例子如下:\x3c\/p\x3e\n\x3ch2\x3e\x3ca href=\x22https:\/\/reactjs.org\/#examples\x22\x3e例如：\x3c\/a\x3e\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#initializing-state\x22\x3eInitializing state\x3c\/a\x3e（初始化状态）\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#fetching-external-data\x22\x3eFetching external data\x3c\/a\x3e（获取外部数据）\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#adding-event-listeners-or-subscriptions\x22\x3eAdding event listeners (or subscriptions)\x3c\/a\x3e（添加事件监听）\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#updating-state-based-on-props\x22\x3eUpdating \x3ccode\x3estate\x3c\/code\x3e based on props\x3c\/a\x3e（基于\x3ccode\x3eprops\x3c\/code\x3e更新\x3ccode\x3estate\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#invoking-external-callbacks\x22\x3eInvoking external callbacks\x3c\/a\x3e(调用外部的\x3ccode\x3ecallbacks\x3c\/code\x3e)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#side-effects-on-props-change\x22\x3eSide effects on props change\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#fetching-external-data-when-props-change\x22\x3eFetching external data when props change\x3c\/a\x3e（\x3ccode\x3eprops\x3c\/code\x3e改变时获取外部数据）\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/reactjs.org\/#reading-dom-properties-before-an-update\x22\x3eReading DOM properties before an update\x3c\/a\x3e(在更新之前读取DOM属性)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\n\x3cp\x3e注意\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e为简洁起见，下面的示例是使用实验类属性转换编写的，但如果没有它，则应用相同的迁移策略。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#initializing-state\x22\x3e初始化状态：\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e这个例子展示了一个调用\x3ccode\x3ecomponentWillMount\x3c\/code\x3e中带有\x3ccode\x3esetState\x3c\/code\x3e的组件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {};\n\n  componentWillMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      currentColor: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.defaultColor,\n      palette: \x3cspan class=\x22hljs-symbol\x22\x3e\x27rg\x3c\/span\x3eb\x27,\n    });\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这种类型的组件最简单的重构是将状态初始化移动到构造函数或属性初始值设定项，如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    currentColor: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.defaultColor,\n    palette: \x3cspan class=\x22hljs-symbol\x22\x3e\x27rg\x3c\/span\x3eb\x27,\n  };\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#fetching-external-data\x22\x3e获取外部数据\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e以下是使用\x3ccode\x3ecomponentWillMount\x3c\/code\x3e获取外部数据的组件示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  };\n\n  componentWillMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = asyncLoadData().then(\n      externalData =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({externalData});\n      }\n    );\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest.cancel();\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.externalData === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render loading state ...\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render real UI ...\x3c\/span\x3e\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e上述代码对于服务器呈现（其中不使用外部数据的地方）和即将到来的异步呈现模式（其中请求可能被多次启动）是有问题的。\x3c\/p\x3e\n\x3cp\x3e对于大多数用例，建议的升级路径是将数据提取移入\x3ccode\x3ecomponentDidMount\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  };\n\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = asyncLoadData().then(\n      externalData =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({externalData});\n      }\n    );\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest.cancel();\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.externalData === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render loading state ...\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render real UI ...\x3c\/span\x3e\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e有一个常见的错误观念认为，在\x3ccode\x3ecomponentWillMount中\x3c\/code\x3e提取可以避免第一个空的渲染。在实践中，这从来都不是真的，因为React总是在\x3ccode\x3ecomponentWillMount\x3c\/code\x3e之后立即执行渲染。如果数据在\x3ccode\x3ecomponentWillMount\x3c\/code\x3e触发的时间内不可用，则无论你在哪里提取数据，第一个渲染仍将显示加载状态。这就是为什么在绝大多数情况下将提取移到\x3ccode\x3ecomponentDidMount\x3c\/code\x3e没有明显效果。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cblockquote\x3e\n\x3cp\x3e注意：\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e一些高级用例（例如，像Relay这样的库）可能想要尝试使用热切的预取异步数据。在这里可以找到一个这样做的\x3ca href=\x22https:\/\/gist.github.com\/bvaughn\/89700e525ff423a75ffb63b1b1e30a8f\x22\x3e例子\x3c\/a\x3e。 \x3c\/p\x3e\n\x3cp\x3e从长远来看，在React组件中获取数据的规范方式可能基于\x3ca href=\x22https:\/\/reactjs.org\/blog\/2018\/03\/01\/sneak-peek-beyond-react-16.html\x22\x3eJSConf冰岛推出的“悬念”API\x3c\/a\x3e。简单的数据提取解决方案以及像Apollo和Relay这样的库都可以在后台使用。它比上述任一解决方案的冗余性都要小得多，但不会在16.3版本中及时完成。 \x3c\/p\x3e\n\x3cp\x3e当支持服务器渲染时，目前需要同步提供数据 - \x3ccode\x3ecomponentWillMount\x3c\/code\x3e通常用于此目的，但构造函数可以用作替换。即将到来的\x3ccode\x3e悬念API\x3c\/code\x3e将使得异步数据在客户端和服务器呈现中都可以清晰地获取。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#adding-event-listeners-or-subscriptions\x22\x3e添加时间监听\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e下面是一个在安装时监听外部事件调度程序的组件示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentWillMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      subscribedValue: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.value,\n    });\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is not safe; it can leak!\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.subscribe(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubscriptionChange\n    );\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.unsubscribe(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubscriptionChange\n    );\n  }\n\n  handleSubscriptionChange = dataSource =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      subscribedValue: dataSource.value,\n    });\n  };\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不幸的是，这会导致服务器渲染（\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e永远不会被调用）和异步渲染（在渲染完成之前渲染可能被中断，导致\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e不被调用）的内存泄漏。\x3c\/p\x3e\n\x3cp\x3e人们经常认为\x3ccode\x3ecomponentWillMount\x3c\/code\x3e和\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e总是配对，但这并不能保证。只有调用\x3ccode\x3ecomponentDidMount\x3c\/code\x3e后，React才能保证稍后调用\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e进行清理。\x3c\/p\x3e\n\x3cp\x3e出于这个原因，添加事件监听的推荐方式是使用componentDidMount生命周期：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    subscribedValue: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.value,\n  };\n\n  componentDidMount() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Event listeners are only safe to add after mount,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ So they won\x27t leak if mount is interrupted or errors.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.subscribe(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubscriptionChange\n    );\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ External values could change between render and mount,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ In some cases it may be important to handle this case.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.subscribedValue !==\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.value\n    ) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        subscribedValue: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.value,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dataSource.unsubscribe(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubscriptionChange\n    );\n  }\n\n  handleSubscriptionChange = dataSource =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      subscribedValue: dataSource.value,\n    });\n  };\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e有时候更新监听以响应属性变化很重要。如果您使用的是像Redux或MobX这样的库，库的容器组件会为您处理。对于应用程序作者，我们创建了一个小型库create-subscription来帮助解决这个问题。我们会将它与React 16.3一起发布。\x3c\/p\x3e\n\x3cp\x3eRather than passing a subscribable \x3ccode\x3edataSource\x3c\/code\x3e prop as we did in the example above, we could use \x3ccode\x3ecreate-subscription\x3c\/code\x3e to pass in the subscribed value:\x3c\/p\x3e\n\x3cp\x3e我们可以使用create-subscription来传递监听的值，而不是像上例那样传递监听 的\x3ccode\x3edataSource\x3c\/code\x3e prop。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {createSubscription} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27create-subscription\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Subscription = createSubscription({\n  getCurrentValue(sourceProp) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Return the current value of the subscription (sourceProp).\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e sourceProp.value;\n  },\n\n  subscribe(sourceProp, callback) {\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleSubscriptionChange\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      callback(sourceProp.value);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Subscribe (e.g. add an event listener) to the subscription (sourceProp).\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Call callback(newValue) whenever a subscription changes.\x3c\/span\x3e\n    sourceProp.subscribe(handleSubscriptionChange);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Return an unsubscribe method.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunsubscribe\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      sourceProp.unsubscribe(handleSubscriptionChange);\n    };\n  },\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Rather than passing the subscribable source to our ExampleComponent,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ We could just pass the subscribed value directly:\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;Subscription source={dataSource}\x26gt;`\x3c\/span\x3e\n  {value =\x26gt; \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;ExampleComponent subscribedValue={value} \/\x26gt;`\x3c\/span\x3e}\n\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;\/Subscription\x26gt;`\x3c\/span\x3e;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e注意\x26gt;\x26gt;像Relay \/ Apollo这样的库应该使用与创建订阅相同的技术手动管理订阅（如此处所引用的），并采用最适合其库使用的优化方式。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#updating-state-based-on-props\x22\x3e基于\x3ccode\x3eprops\x3c\/code\x3e更新\x3ccode\x3estate\x3c\/code\x3e\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e以下是使用旧版\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e生命周期基于新的道具值更新状态的组件示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    isScrollingDown: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  };\n\n  componentWillReceiveProps(nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.currentRow !== nextProps.currentRow) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        isScrollingDown:\n          nextProps.currentRow \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.currentRow,\n      });\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e尽管上面的代码本身并没有问题，但\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e生命周期通常会被错误地用于解决问题。因此，该方法将被弃用。\x3c\/p\x3e\n\x3cp\x3e从版本16.3开始，更新\x3ccode\x3estate\x3c\/code\x3e以响应\x3ccode\x3eprops\x3c\/code\x3e更改的推荐方法是使用新的静态getDerivedStateFromProps生命周期。 （生命周期在组件创建时以及每次收到新道具时调用）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Initialize state in constructor,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Or with a property initializer.\x3c\/span\x3e\n  state = {\n    isScrollingDown: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    lastRow: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextProps.currentRow !== prevState.lastRow) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        isScrollingDown:\n          nextProps.currentRow \x26gt; prevState.lastRow,\n        lastRow: nextProps.currentRow,\n      };\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Return null to indicate no change to state.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eYou may notice in the example above that \x3ccode\x3eprops.currentRow\x3c\/code\x3e is mirrored in state (as \x3ccode\x3estate.lastRow\x3c\/code\x3e). This enables \x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e to access the previous props value in the same way as is done in \x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e你可能会注意到在上面的例子中，\x3ccode\x3eprops.currentRow\x3c\/code\x3e是一个镜像状态（如state.lastRow）。这使得\x3ccode\x3egetDerivedStateFromProp\x3c\/code\x3es可以像在\x3ccode\x3ecomponentWillReceiveProp\x3c\/code\x3es中一样访问以前的props值。\x3c\/p\x3e\n\x3cp\x3e您可能想知道为什么我们不只是将先前的\x3ccode\x3eprops\x3c\/code\x3e作为参数传递给\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e。我们在设计API时考虑了这个选项，但最终决定反对它，原因有两个：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eA \x3ccode\x3eprevProps\x3c\/code\x3e parameter would be null the first time \x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e was called (after instantiation), requiring an if-not-null check to be added any time \x3ccode\x3eprevProps\x3c\/code\x3e was accessed.\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eNot passing the previous props to this function is a step toward freeing up memory in future versions of React. (If React does not need to pass previous props to lifecycles, then it does not need to keep the previous \x3ccode\x3eprops\x3c\/code\x3e object in memory.)\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在第一次调用\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e（实例化后）时，\x3ccode\x3eprevProps\x3c\/code\x3e参数将为null，需要在访问prevProps时添加if-not-null检查。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e没有将以前的\x3ccode\x3eprops\x3c\/code\x3e传递给这个函数，在未来版本的React中释放内存的一个步骤。 （如果React不需要将先前的道具传递给生命周期，那么它不需要将先前的道具对象保留在内存中。）\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\n\x3cp\x3eNote\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cblockquote\x3e\n\x3cp\x3e如果您正在编写共享组件，那么\x3ccode\x3ereact-lifecycles-compat polyfill\x3c\/code\x3e可以使新的\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e生命周期与旧版本的React一起使用。详细了解如何在下面使用它。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3c\/blockquote\x3e\n\x3c\/blockquote\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#invoking-external-callbacks\x22\x3e调用外部回调函数\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e下面是一个在内部状态发生变化时调用外部函数的组件示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentWillUpdate(nextProps, nextState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.someStatefulValue !==\n      nextState.someStatefulValue\n    ) {\n      nextProps.onChange(nextState.someStatefulValue);\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在异步模式下使用\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e都是不安全的，因为外部回调可能会多次调用只更新一次。相反，应该使用\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e生命周期，因为它保证每次更新只调用一次：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentDidUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.someStatefulValue !==\n      prevState.someStatefulValue\n    ) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onChange(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.someStatefulValue);\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#side-effects-on-props-change\x22\x3eprops改变的副作用\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e与上述 \x3ca href=\x22https:\/\/reactjs.org\/#invoking-external-callbacks\x22\x3e事例\x3c\/a\x3e类似，有时组件在道具更改时会产生副作用。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentWillReceiveProps(nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isVisible !== nextProps.isVisible) {\n      logVisibleChange(nextProps.isVisible);\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e与\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e一样，\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e可能会多次调用但是只更新一次。出于这个原因，避免在此方法中导致的副作用非常重要。相反，应该使用\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e，因为它保证每次更新只调用一次：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentDidUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isVisible !== prevProps.isVisible) {\n      logVisibleChange(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isVisible);\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#fetching-external-data-when-props-change\x22\x3eprops改变时获取外部数据\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e以下是根据\x3ccode\x3eprops\x3c\/code\x3evalues提取外部数据的组件示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  };\n\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._loadAsyncData(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.id);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextProps.id !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.id) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e});\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._loadAsyncData(nextProps.id);\n    }\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest.cancel();\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.externalData === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render loading state ...\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render real UI ...\x3c\/span\x3e\n    }\n  }\n\n  _loadAsyncData(id) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = asyncLoadData(id).then(\n      externalData =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({externalData});\n      }\n    );\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e此组件的推荐升级路径是将数据更新移动到\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e中。在渲染新道具之前，您还可以使用新的\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e生命周期清除陈旧的数据：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Store prevId in state so we can compare when props change.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Clear out previously-loaded data (so we don\x27t render stale stuff).\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextProps.id !== prevState.prevId) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        externalData: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        prevId: nextProps.id,\n      };\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ No state update necessary\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._loadAsyncData(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.id);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.externalData === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._loadAsyncData(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.id);\n    }\n  }\n\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest.cancel();\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.externalData === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render loading state ...\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render real UI ...\x3c\/span\x3e\n    }\n  }\n\n  _loadAsyncData(id) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = asyncLoadData(id).then(\n      externalData =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._asyncRequest = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({externalData});\n      }\n    );\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e注意\x26gt;如果您使用支持取消的HTTP库（如\x3ca href=\x22https:\/\/www.npmjs.com\/package\/axios\x22\x3eaxios\x3c\/a\x3e），那么卸载时取消正在进行的请求很简单。对于原生Promise，\x3ca href=\x22https:\/\/gist.github.com\/bvaughn\/982ab689a41097237f6e9860db7ca8d6\x22\x3e您可以使用如下所示的方法\x3c\/a\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3\x3e\x3ca href=\x22https:\/\/reactjs.org\/#reading-dom-properties-before-an-update\x22\x3e在更新之前读取DOM属性\x3c\/a\x3e\x3c\/h3\x3e\n\x3cp\x3e下面是一个组件的例子，它在更新之前从DOM中读取属性，以便在列表中保持滚动位置：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eScrollingList\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  listRef = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  previousScrollOffset = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  componentWillUpdate(nextProps, nextState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Are we adding new items to the list?\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Capture the scroll position so we can adjust scroll later.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.list.length \x26lt; nextProps.list.length) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.previousScrollOffset =\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollHeight - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollTop;\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If previousScrollOffset is set, we\x27ve just added new items.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Adjust scroll so these new items don\x27t push the old ones out of view.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.previousScrollOffset !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollTop =\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollHeight -\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.previousScrollOffset;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.previousScrollOffset = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      `\x26lt;div\x26gt;`\n        {\x3cspan class=\x22hljs-comment\x22\x3e\/* ...contents... *\/\x3c\/span\x3e}\n      `\x26lt;\/div\x26gt;`\n    );\n  }\n\n  setListRef = ref =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef = ref;\n  };\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在上面的例子中，\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e被用来读取DOM属性。但是，对于异步渲染，“render”阶段生命周期（如\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e和\x3ccode\x3erender\x3c\/code\x3e）与“commit”阶段生命周期（如\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e）之间可能存在延迟。如果用户在这段时间内做了类似调整窗口大小的操作，则从\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e中读取的\x3ccode\x3escrollHeight\x3c\/code\x3e值将失效。\x3c\/p\x3e\n\x3cp\x3e解决此问题的方法是使用新的“commit”阶段生命周期\x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e。在数据发生变化之前立即调用该方法（例如，在更新DOM之前）。它可以将React的值作为参数传递给\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e，在数据发生变化后立即调用它。\x3c\/p\x3e\n\x3cp\x3e这两个生命周期可以像这样一起使用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eScrollingList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  listRef = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Are we adding new items to the list?\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Capture the scroll position so we can adjust scroll later.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (prevProps.list.length \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.list.length) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollHeight - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollTop\n      );\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If we have a snapshot value, we\x27ve just added new items.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Adjust scroll so these new items don\x27t push the old ones out of view.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (snapshot here is the value returned from getSnapshotBeforeUpdate)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (snapshot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollTop =\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      `\x26lt;div\x26gt;`\n        {\x3cspan class=\x22hljs-comment\x22\x3e\/* ...contents... *\/\x3c\/span\x3e}\n      `\x26lt;\/div\x26gt;`\n    );\n  }\n\n  setListRef = ref =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listRef = ref;\n  };\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e注意\x26gt;\x26gt;如果您正在编写共享组件，那么\x3ccode\x3ereact-lifecycles-compat polyfill\x3c\/code\x3e可以使新的\x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e生命周期与旧版本的React一起使用。\x3ca href=\x22https:\/\/reactjs.org\/#open-source-project-maintainers\x22\x3e详细了解如何使用它\x3c\/a\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e\x3ca href=\x22https:\/\/reactjs.org\/#other-scenarios\x22\x3e其它情况\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3e除了以上的一些常见的例子，还可能会有别的情况本篇文章没有涵盖到，如果您以本博文未涉及的方式使用\x3ccode\x3ecomponentWillMount\x3c\/code\x3e，\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e或\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e，并且不确定如何迁移这些传统生命周期，你可以提供您的代码示例和我们的文档，并且一起提交一个新问题。我们将在更新这份文件时提供新的替代模式。\x3c\/p\x3e\n\x3ch2\x3e\x3ca href=\x22https:\/\/reactjs.org\/#open-source-project-maintainers\x22\x3e开源项目维护者\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3e开源维护人员可能想知道这些更改对于共享组件意味着什么。如果实现上述建议，那么依赖于新的静态\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e生命周期的组件会发生什么情况？你是否还必须发布一个新的主要版本，并降低React 16.2及更高版本的兼容性？\x3c\/p\x3e\n\x3cp\x3e当React 16.3发布时，我们还将发布一个新的npm包， \x3ca href=\x22https:\/\/github.com\/reactjs\/react-lifecycles-compat\x22\x3e\x3ccode\x3ereact-lifecycles-compat\x3c\/code\x3e\x3c\/a\x3e。该npm包会填充组件，以便新的\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e和\x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e生命周期也可以与旧版本的React（0.14.9\x2b）一起使用。\x3c\/p\x3e\n\x3cp\x3e要使用这个polyfill，首先将它作为依赖项添加到您的库中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dockerfile\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e# Yarn\x3c\/span\x3e\nyarn \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e react-lifecycles-compat\n\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# NPM\x3c\/span\x3e\nnpm install react-lifecycles-compat --save\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，更新您的组件以使用新的生命周期（如上所述）。\x3c\/p\x3e\n\x3cp\x3e最后，使用polyfill将组件向后兼容旧版本的React：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {polyfill} from \x3cspan class=\x22hljs-symbol\x22\x3e\x27react\x3c\/span\x3e-lifecycles-compat\x27;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static getDerivedStateFromProps(nextProps, prevState) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Your state update logic here ...\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Polyfill your component to work with older versions of React:\x3c\/span\x3e\npolyfill(\x3cspan class=\x22hljs-type\x22\x3eExampleComponent\x3c\/span\x3e);\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eExampleComponent\x3c\/span\x3e;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/reactjs\/reactjs.org\/tree\/master\/content\/blog\/2018-03-27-update-on-async-rendering.md\x22\x3e文章来源\x3c\/a\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/update-on-async-rendering">https://www.zcfy.cc/article/update-on-async-rendering</a> 原文标题: ReactV16.3即将更改的生命周期 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/66f04d69/" target="_blank">https://alili.tech/archive/66f04d69/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>