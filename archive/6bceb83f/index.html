<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="初学者应该了解的数据结构：Array、HashMap 与 List"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>初学者应该了解的数据结构：Array、HashMap 与 List | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6bceb83f/",
				"appid": "1613049289050283", 
				"title": "初学者应该了解的数据结构：Array、HashMap 与 List | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3afe893/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/fcaaa7e6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&is_video=false&description=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bceb83f%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9aArray%e3%80%81HashMap%20%e4%b8%8e%20List"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">初学者应该了解的数据结构：Array、HashMap 与 List</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t019eeef36aa559bfc6.jpg\x22 alt=\x22Data Structures for Beginners: Arrays, HashMaps, and Lists\x22\x3e \x3c\/p\x3e\n\x3cp\x3e当开发程序时，我们（通常）需要在内存中存储数据。根据操作数据方式的不同，可能会选择不同的数据结构。有很多常用的数据结构，如：Array、Map、Set、List、Tree、Graph 等等。（然而）为程序选取合适的数据结构可能并不容易。因此，希望这篇文章能帮助你了解（不同数据结构的）表现，以求在工作中合理地使用它们。\x3c\/p\x3e\n\x3cp\x3e本文主要聚焦于线性的数据结构，如：Array、Set、List、Sets、Stacks、Queues 等等。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e本篇是以下教程的一部分（译者注：如果大家觉得还不错，我会翻译整个系列的文章）:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e初学者应该了解的数据结构与算法（DSA）\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/04\/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial\/\x22\x3e算法的时间复杂性与大 O 符号\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/05\/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course\/\x22\x3e每个程序员应该知道的八种时间复杂度\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e初学者应该了解的数据结构：Array、HashMap 与 List  \x3cstrong\x3e👈 即本文\x3c\/strong\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/05\/14\/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial\/\x22\x3e初学者应该了解的数据结构： Graph\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e初学者应该了解的数据结构：Tree (\x3cstrong\x3e敬请期待\x3c\/strong\x3e)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/24\/Analysis-of-Recursive-Algorithms\/\x22\x3e附录 I：递归算法分析\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3chr\x3e\n\x3ch1\x3e（操作）数据结构的时间复杂度\x3c\/h1\x3e\n\x3cp\x3e下表是本文所讨论内容的概括。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e加个书签、收藏或分享本文，以便不时之需。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e* = 运行时分摊\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e数据结构\x3c\/th\x3e\n\x3cth\x3e插入\x3c\/th\x3e\n\x3cth\x3e访问\x3c\/th\x3e\n\x3cth\x3e查找\x3c\/th\x3e\n\x3cth\x3e删除\x3c\/th\x3e\n\x3cth\x3e备注\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eArray\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入最后位置复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e(Hash)\x3cstrong\x3eMap\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e重新计算哈希会影响插入时间。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eMap\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过二叉搜索树实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e（使用 HashMap）\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1）*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e由 HashMap 实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e (使用 List)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.add\x22\x3eO(n)\x3c\/a\x3e\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.has\x22\x3eO(n)\x3c\/a\x3e]\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.delete\x22\x3eO(n)\x3c\/a\x3e\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过 List 实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e (使用二叉搜索树)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过二叉搜索树实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eLinked List\x3c\/strong\x3e (单向)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在起始位置添加或删除元素，复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eLinked List\x3c\/strong\x3e (双向）\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在起始或结尾添加或删除元素，复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e。然而在其他位置是  \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eStack\x3c\/strong\x3e (由 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)]\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入与删除都遵循与后进先出（LIFO）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (简单地由 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入（Array.shift）操作的复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (由 Array 实现，但进行了改进)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入操作的最差情况复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。然而分摊后是 \x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (由 List 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e使用双向链表\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e注意： \x3cstrong\x3e二叉搜索树\x3c\/strong\x3e 与其他树结构、图结构，将在另一篇文章中讨论。 \x3c\/p\x3e\n\x3ch1\x3e原始数据类型\x3c\/h1\x3e\n\x3cp\x3e原始数据类型是构成数据结构最基础的元素。下面列举出一些原始原始数据类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e整数，如：1, 2, 3, …\x3c\/li\x3e\n\x3cli\x3e字符，如：a, b, \x221\x22, \x22*\x22\x3c\/li\x3e\n\x3cli\x3e布尔值， true 与 false.\x3c\/li\x3e\n\x3cli\x3e浮点数 ，如：3.14159, 1483e-2.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1\x3eArray\x3c\/h1\x3e\n\x3cp\x3e数组可由零个或多个元素组成。由于数组易于使用且检索性能优越，它是最常用的数据结构之一。\x3c\/p\x3e\n\x3cp\x3e你可以将数组想象成一个抽屉，可以将数据存到匣子中。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e数组就像是将东西存到匣子中的抽屉\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01065921bb094fc5ae.jpg\x22 alt=\x22\x22 title=\x22Array is like a drawer that stores things on bins\x22\x3e\x3c\/p\x3e\n\x3cp\x3e当你想查找某个元素时，你可以直接打开对应编号的匣子（时间复杂度为 \x3cem\x3eO(1)\x3c\/em\x3e）。然而，如果你忘记了匣子里存着什么，就必须逐个打开所有的匣子（时间复杂度为 \x3cem\x3eO(n)\x3c\/em\x3e），直到找到所需的东西。数组也是如此。\x3c\/p\x3e\n\x3cp\x3e根据编程语言的不同，数组存在一些差异。对于 JavaScript 和 Ruby 等动态语言而言，数组可以包含不同的数据类型：数字，字符串，对象甚至函数。而在 Java 、 C 、C \x2b\x2b 之类的强类型语言中，你必须在使用数组之前，定好它的长度与数据类型。JavaScript 会在需要时自动增加数组的长度。\x3c\/p\x3e\n\x3ch2\x3eArray 的内置方法\x3c\/h2\x3e\n\x3cp\x3e根据编程序言的不同，数组（方法）的实现稍有不同。\x3c\/p\x3e\n\x3cp\x3e比如在 JavaScript 中，我们可以使用 \x3ccode\x3eunshift\x3c\/code\x3e 与 \x3ccode\x3epush\x3c\/code\x3e 添加元素到数组的头或尾，同时也可以使用 \x3ccode\x3eshift\x3c\/code\x3e 与 \x3ccode\x3epop\x3c\/code\x3e 删除数组的首个或最后一个元素。让我们来定义一些本文用到的数组常用方法。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e常用的 JS 数组内置函数\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e函数\x3c\/th\x3e\n\x3cth\x3e复杂度\x3c\/th\x3e\n\x3cth\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Array\/push\x22\x3earray.\x3cstrong\x3epush\x3c\/strong\x3e(element1[, …[, elementN]])\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将一个或多个元素添加到数组的末尾\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22http:\/\/devdocs.io\/javascript\/global_objects\/array\/pop\x22\x3earray.\x3cstrong\x3epop\x3c\/strong\x3e()\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e移除数组末尾的元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Array\/shift\x22\x3earray.\x3cstrong\x3eshift\x3c\/strong\x3e()\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e移除数组开头的元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Array\/unshift\x22\x3earray.\x3cstrong\x3eunshift\x3c\/strong\x3e(element1[, …[, elementN]])\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将一个或多个元素添加到数组的开头\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Array\/slice\x22\x3earray.\x3cstrong\x3eslice\x3c\/strong\x3e([beginning[, end]])\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e返回浅拷贝原数组从 \x3ccode\x3ebeginning\x3c\/code\x3e 到 \x3ccode\x3eend\x3c\/code\x3e（不包括 \x3ccode\x3eend\x3c\/code\x3e）部分组成的新数组\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Array\/splice\x22\x3earray.\x3cstrong\x3esplice\x3c\/strong\x3e(start[, deleteCount[, item1[,…]]])\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e改变 (插入或删除) 数组\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch2\x3e向数组插入元素\x3c\/h2\x3e\n\x3cp\x3e将元素插入到数组有很多方式。你可以将新数据添加到数组末尾，也可以添加到数组开头。\x3c\/p\x3e\n\x3cp\x3e先看看如何添加到末尾：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3einsertToTail\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, element)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.push(element);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(insertToTail(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; [ 1, 2, 3, 4 ]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e根据\x3ca href=\x22https:\/\/tc39.github.io\/ecma262\/#sec-array.prototype.push\x22\x3e规范\x3c\/a\x3e，\x3ccode\x3epush\x3c\/code\x3e 操作只是将一个新元素添加到数组的末尾。因此，\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3eArray.push\x3c\/code\x3e 的时间复杂度度是 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e现在看看如添加到开头：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3einsertToHead\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, element)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.unshift(element);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(insertToHead(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; [ 0, 1, 2, 3, ]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你觉得添加元素到数组开头的函数，时间复杂度是什么呢？看起来和上面（\x3ccode\x3epush\x3c\/code\x3e）差不多，除了调用的方法是 \x3ccode\x3eunshift\x3c\/code\x3e 而不是 \x3ccode\x3epush\x3c\/code\x3e。但这有个问题，\x3ca href=\x22https:\/\/tc39.github.io\/ecma262\/#sec-array.prototype.unshift\x22\x3e\x3ccode\x3eunshift\x3c\/code\x3e\x3c\/a\x3e 是通过将数组的每一项移到下一项，腾出首项的空间来容纳新添加的元素。所以它是遍历了一次数组的。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3eArray.unshift\x3c\/code\x3e 的时间复杂度度是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e访问数组中的元素\x3c\/h2\x3e\n\x3cp\x3e如果你知道待查找元素在数组中的索引，那你可以通过以下方法直接访问该元素：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs php\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaccess\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(array, index)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[index];\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27word\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3.14\x3c\/span\x3e, { a: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e }];\naccess(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 1\x3c\/span\x3e\naccess(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; {a: 1}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如上面你所看到的的代码一样，访问数组中的元素耗时是恒定的：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e访问数组中元素的时间复杂度是  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cem\x3e注意：通过索引修改数组的值所花费的时间也是恒定的。\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2\x3e在数组中查找元素\x3c\/h2\x3e\n\x3cp\x3e如果你想查找某个元素但不知道对应的索引时，那只能通过遍历数组的每个元素，直到找到为止。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs zephir\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esearch\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(array, element)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n       index \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e.length;\n       index\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (element === \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[index]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27word\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3.14\x3c\/span\x3e, { a: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e }];\nconsole.log(search(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27word\x27\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 1\x3c\/span\x3e\nconsole.log(search(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3.14\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 2\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e鉴于使用了 \x3ccode\x3efor\x3c\/code\x3e 循环，那么：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在数组中查找元素的时间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e在数组中删除元素\x3c\/h2\x3e\n本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。 \n\n\x3cp\x3e先一起思考下这两种情况：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从数组的末尾删除元素所需时间是恒定的，也就是  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/li\x3e\n\x3cli\x3e然而，无论是从数组的开头或是中间位置删除元素，你都需要调整（删除元素后面的）元素位置。因此复杂度为 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e说多无谓，看代码好了：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3eremove\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, element)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = search(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, element);\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array1 = [\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(remove(array1, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; [ 0, 2, 3 ]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们使用了上面定义的 \x3ccode\x3esearch\x3c\/code\x3e 函数来查找元素的的索引，复杂度为 \x3cem\x3eO(n)\x3c\/em\x3e。然后使用\x3ca href=\x22https:\/\/tc39.github.io\/ecma262\/#sec-array.prototype.splice\x22\x3eJS 内置的 \x3ccode\x3esplice\x3c\/code\x3e\x3c\/a\x3e 方法，它的复杂度也是 \x3cem\x3eO(n)\x3c\/em\x3e。那（删除函数）总的时间复杂度不是 \x3cem\x3eO(2n)\x3c\/em\x3e 吗?记住，（对于时间复杂度而言，）我们并不关心常量。\x3c\/p\x3e\n\x3cp\x3e对于上面列举的两种情况，考虑最坏的情况：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在数组中删除某项元素的时间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e数组方法的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e在下表中，小结了数组（方法）的时间复杂度：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e数组方法的时间复杂度\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e操作方法\x3c\/th\x3e\n\x3cth\x3e最坏情况\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e访问 (\x3ccode\x3eArray.[]\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e添加新元素至开头 (\x3ccode\x3eArray.unshift\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e添加新元素至末尾 (\x3ccode\x3eArray.push\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e查找 (通过值而非索引)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e删除 (\x3ccode\x3eArray.splice\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1\x3eHashMaps\x3c\/h1\x3e\n\x3cp\x3eHashMap有很多名字，如 HashTableHashMap、Map、Dictionary、Associative Array 等。概念上它们都是一致的，实现上稍有不同。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e哈希表是一种将键  \x3cstrong\x3e映射到\x3c\/strong\x3e  值的数据结构。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e回想一下关于抽屉的比喻，现在匣子有了标签，不再是按数字顺序了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eHashMap 也和抽屉一样存储东西，通过不同标识来区分不同匣子。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0163970c4b4cfa192e.jpg\x22 alt=\x22\x22 title=\x22HashMap is like a drawer that stores things on bins and label them\x22\x3e\x3c\/p\x3e\n\x3cp\x3e此例中，如果你要找一个玩具，你不需要依次打开第一个、第二个和第三个匣子来查看玩具是否在内。直接代开被标识为“玩具”的匣子即可。这是一个巨大的进步，查找元素的时间复杂度从 \x3cem\x3eO(n)\x3c\/em\x3e 降为  \x3cem\x3eO(1)\x3c\/em\x3e 了。\x3c\/p\x3e\n\x3cp\x3e数字是数组的索引，而标识则作为 HashMap 存储数据的键。HashMap 内部通过 \x3cem\x3e哈希函数\x3c\/em\x3e 将键（也就是标识）转化为索引。\x3c\/p\x3e\n\x3cp\x3e至少有两种方式可以实现 hashmap：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cstrong\x3e数组\x3c\/strong\x3e：通过哈希函数将键映射为数组的索引。（查找）最差情况： O(n)，平均： O(1)。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e二叉搜索树\x3c\/strong\x3e: 使用自平衡二叉搜索树查找值（另外的文章会详细介绍）。 （查找）最差情况： \x3cem\x3eO(log n)\x3c\/em\x3e，平均：\x3cem\x3eO(log n)\x3c\/em\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们会介绍树与二叉搜索树，现在先不用担心太多。实现 Map 最常用的方式是使用 \x3cstrong\x3e数组\x3c\/strong\x3e与哈希转换函数。让我们（通过数组）来实现它吧\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e通过数组实现 HashMap\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011f6faa6e24b662ce.jpg\x22 alt=\x22\x22 title=\x22HashMap: hash function translates keys into bucket (array) indexes\x22\x3e\x3c\/p\x3e\n\x3cp\x3e正如上图所示，每个键都被转换为一个 \x3cstrong\x3ehash code\x3c\/strong\x3e。由于数组的大小是有限的（如此例中是10），（如发生冲突，）我们必须使用模函数找到对应的桶（译者注：桶指的是数组的项），再循环遍历该桶（来寻找待查询的值）。每个桶内，我们存储的是一组组的键值对，如果桶内存储了多个键值对，将采用集合来存储它们。\x3c\/p\x3e\n\x3cp\x3e我们将讲述 HashMap 的组成，让我们先从\x3cstrong\x3e哈希函数\x3c\/strong\x3e开始吧。\x3c\/p\x3e\n\x3ch2\x3e哈希函数\x3c\/h2\x3e\n\x3cp\x3e实现 HashMap 的第一步是写出一个哈希函数。这个函数会将键映射为对应（索引的）值。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3e完美的哈希函数\x3c\/strong\x3e 是为每一个不同的键映射为不同的索引。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e借助理想的哈希函数，可以实现访问与查找在恒定时间内完成。然而，完美的哈希函数在实践中是难以实现的。你很可能会碰到两个不同的键被映射为同一索引的情况，也就是 _冲突_。\x3c\/p\x3e\n\x3cp\x3e当使用类似数组之类的数据结构作为 HashMap 的实现时，冲突是难以避免的。因此，解决冲突的其中一种方式是在同一个桶中存储多个值。当我们试图访问某个键对应的值时，如果在对应的桶中发现多组键值对，则需要遍历它们（以寻找该键对应的值），时间复杂度为 \x3cem\x3eO(n)\x3c\/em\x3e。然而，在大多数（HashMap）的实现中， HashMap 会动态调整数组的长度以免冲突发生过多。因此我们可以说\x3cstrong\x3e分摊后\x3c\/strong\x3e的查找时间为 \x3cem\x3eO(1)\x3c\/em\x3e。本文中我们将通过一个例子，讲述分摊的含义。\x3c\/p\x3e\n\x3ch2\x3eHashMap 的简单实现\x3c\/h2\x3e\n\x3cp\x3e一个简单（但糟糕）的哈希函数可以是这样的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3eclass NaiveHashMap {\n\n  constructor(initialCapacity = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eArray\x3c\/span\x3e(initialCapacity);\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[index] = value;\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[index];\n  }\n\n  hash(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e.toString().length;\n  }\n\n  getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e indexHash = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hash(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = indexHash % \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/hash-maps\/hash-map-1.js\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e我们直接使用桶而不是抽屉与匣子，相信你能明白喻义的意思 :)\x3c\/p\x3e\n\x3cp\x3eHashMap 的初始容量（译者注：容量指的是用于存储数据的数组长度，即桶的数量）是2（两个桶）。当我们往里面存储多个元素时，通过求余 \x3ccode\x3e%\x3c\/code\x3e 计算出该键应存入桶的编号（，并将数据存入该桶中）。\x3c\/p\x3e\n\x3cp\x3e留意代码的第18行（即 \x3ccode\x3ereturn key.toString().length;\x3c\/code\x3e）。之后我们会对此进行一点讨论。现在先让我们使用一下这个新的 HashMap 吧。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Usage:\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27assert\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hashMap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NaiveHashMap();\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(hashMap.buckets);\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n  bucket #0: \x26lt;1 empty item\x26gt;,\n  bucket #1: 8\n*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this one is ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ got overwritten by art 😱\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ got overwritten by art 😱\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ got overwritten by art 😱\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这个 HashMap 允许我们通过 \x3ccode\x3eset\x3c\/code\x3e 方法设置一组键值对，通过往 \x3ccode\x3eget\x3c\/code\x3e 方法传入一个键来获取对应的值。其中的关键是哈希函数，当我们存入多组键值时，看看这 HashMap 的表现。\x3c\/p\x3e\n\x3cp\x3e你能说出这个简单实现的 HashMap 存在的问题吗？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1) Hash function\x3c\/strong\x3e 转换出太多相同的索引。如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ehash\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ehash\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这会产生非常多的冲突。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e2)\x3c\/strong\x3e 完全不处理\x3cstrong\x3e冲突\x3c\/strong\x3e的情况。\x3ccode\x3ecat\x3c\/code\x3e 与 \x3ccode\x3edog\x3c\/code\x3e 会重写彼此在 HashMap 中的值（它们均在桶 #1 中）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e3 数组长度\x3c\/strong\x3e。 即使我们有一个更好的哈希函数，由于数组的长度是2，少于存入元素的数量，还是会产生很多冲突。我们希望 HashMap 的初始容量大于我们存入数据的数量。\x3c\/p\x3e\n\x3ch2\x3e改进哈希函数\x3c\/h2\x3e\n\x3cblockquote\x3e\n\x3cp\x3eHashMap 的主要目标是将数组查找与访问的时间复杂度，从  \x3cem\x3eO(n)\x3c\/em\x3e  降至 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e为此，我们需要：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e一个合适的哈希函数，尽可能地减少冲突。\x3c\/li\x3e\n\x3cli\x3e一个长度足够大的数组用于保存数据。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让我们重新设计哈希函数，不再采用字符串的长度为 hash code，取而代之是使用字符串中每个字符的\x3ca href=\x22https:\/\/simple.wikipedia.org\/wiki\/ASCII\x22\x3eascii 码\x3c\/a\x3e的总和为 hash code。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3ehash(key) {\n  let hashValue = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stringKey = key.toString();\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e \x26lt; stringKey.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e charCode = stringKey.charCodeAt(\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e);\n    hashValue \x2b= charCode;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hashValue;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e再试一次：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ehash\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 312  (c=99 \x2b a=97 \x2b t=116)\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ehash\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 314 (d=100 \x2b o=111 \x2b g=103)\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这函数比之前的要好！这是因为相同长度的单词由不一样的字母组成，因而 ascii 码的总和不一样。\x3c\/p\x3e\n\x3cp\x3e然而，仍然有问题！单词 rat 与 art 转换后都是327，产生\x3cstrong\x3e冲突\x3c\/strong\x3e了！ 💥\x3c\/p\x3e\n\x3cp\x3e可以通过根据字符位置左移它的 ascii 码来解决：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3ehash(key) {\n  let hashValue = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stringKey = `${key}`;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e \x26lt; stringKey.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e charCode = stringKey.charCodeAt(\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e);\n    hashValue \x2b= charCode \x26lt;\x26lt; (\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hashValue;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在继续试验，下面列举出了十六进制的数字，这样可以方便我们观察位移。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs less\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ r = 114 or 0x72; a = 97 or 0x61; t = 116 or 0x74\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 7,627,122 (r: 114 * 1 \x2b a: 97 * 256 \x2b t: 116 * 65,536) or in hex: 0x726174 (r: 0x72 \x2b a: 0x6100 \x2b t: 0x740000)\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 7,631,457 or 0x617274\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然而，以下两种类型有何不同呢？\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs less\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 49\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 49\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x271,2,3\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 741485668\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 741485668\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3402815551\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ehash\x3c\/span\x3e(undefined) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3402815551\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e天啊，仍然有问题！！不同的数据类型不应该返回相同的 hash code！\x3c\/p\x3e\n\x3cp\x3e该如何解决呢？\x3c\/p\x3e\n\x3cp\x3e其中一种方式是在哈希函数中，将数据的类型作为转换 hash code 的一部分。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3ehash(key) {\n  let hashValue = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stringTypeKey = `${key}${typeof key}`;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e \x26lt; stringTypeKey.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e charCode = stringTypeKey.charCodeAt(\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e);\n    hashValue \x2b= charCode \x26lt;\x26lt; (\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hashValue;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e让我们让我们再试一次：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1843909523\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1927012762\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash(\x3cspan class=\x22hljs-string\x22\x3e\x271,2,3\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2668498381\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e])); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2533949129\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash(\x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5329828264\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hash(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 6940203017\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eYay!!! 🎉 我们终于有了更好的哈希函数！\x3c\/p\x3e\n\x3cp\x3e同时，我们可以改变 HashMap 的原始容量以减少冲突，让我们在下一节中优化 HashMap。\x3c\/p\x3e\n\x3ch2\x3e更完善的 HashMap 实现\x3c\/h2\x3e\n\x3cp\x3e通过优化好的哈希函数，HashMap 可以表现得更好。\x3c\/p\x3e\n\x3cp\x3e尽管冲突仍可能发生，但通过一些方式可以很好地处理它们。\x3c\/p\x3e\n\x3cp\x3e对于我们的 HashMap，希望有以下改进：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e哈希函数\x3c\/strong\x3e， 检查类型与计算各字符（ascii 码的总和）以减少冲突的发生。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e处理冲突\x3c\/strong\x3e，通过将值添加到集合中来解决这问题，同时需要一个计数器追踪冲突的数量。 \x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e更完善 HashMap 实现\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/hash-maps\/hash-map-2.js\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3eclass DecentHashMap {\n  constructor(initialCapacity = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eArray\x3c\/span\x3e(initialCapacity);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.collisions = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bucketIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].push({\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value});\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.collisions\x2b\x2b; }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex] = [{\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value}];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bucketIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let arrayIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; arrayIndex \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].length; arrayIndex\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e entry = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex][arrayIndex];\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(entry.\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e entry.value\n      }\n    }\n  }\n  hash(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    let hashValue = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stringTypeKey = `${\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e}${typeof \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e}`;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; stringTypeKey.length; index\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e charCode = stringTypeKey.charCodeAt(index);\n      hashValue \x2b= charCode \x26lt;\x26lt; (index * \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hashValue;\n  }\n  getIndex(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e indexHash = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hash(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = indexHash % \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e看看这个 HashMap 表现如何：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Usage:\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27assert\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hashMap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e DecentHashMap();\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27collisions: \x27\x3c\/span\x3e, hashMap.collisions); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(hashMap.buckets);\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n  bucket #0: [ { key: \x27cat\x27, value: 2 }, { key: \x27art\x27, value: 8 } ]\n  bucket #1: [ { key: \x27rat\x27, value: 7 }, { key: \x27dog\x27, value: 1 } ]\n*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this one is ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Good. Didn\x27t got overwritten by art\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Good. Didn\x27t got overwritten by art\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Good. Didn\x27t got overwritten by art\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e完善后的 HashMap 很好地完成了工作，但仍然有一些问题。使用改良后的哈希函数不容易产生重复的值，这非常好。然而，在桶#0与桶#1中都有两个值。这是为什么呢？？\x3c\/p\x3e\n\x3cp\x3e由于 HashMap 的容量是2，尽管算出来的 hash code 是不一样的，当求余后算出所需放进桶的编号时，结果不是桶#0就是桶#1。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3ehash(\x27cat\x27) =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789411390\x3c\/span\x3e; bucketIndex =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789411390\x3c\/span\x3e % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nhash(\x27art\x27) =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789415740\x3c\/span\x3e; bucketIndex =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789415740\x3c\/span\x3e % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nhash(\x27dog\x27) =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3788563007\x3c\/span\x3e; bucketIndex =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3788563007\x3c\/span\x3e % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\nhash(\x27rat\x27) =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789411405\x3c\/span\x3e; bucketIndex =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e3789411405\x3c\/span\x3e % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e很自然地想到，可以通过增加 HashMap 的原始容量来解决这个问题，但原始容量应该是多少呢？先来看看容量是如何影响 HashMap 的表现的。\x3c\/p\x3e\n\x3cp\x3e如果初始容量是1，那么所有的键值对都会被存入同一个桶，即桶#0。查找操作并不比纯粹用数组存储数据的时间复杂度简单，它们都是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e而假设将初始容量定为10：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hashMapSize10 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e DecentHashMap(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\nhashMapSize10.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\nhashMapSize10.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\nhashMapSize10.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nhashMapSize10.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27collisions: \x27\x3c\/span\x3e, hashMapSize10.collisions); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27hashMapSize10\\n\x27\x3c\/span\x3e, hashMapSize10.buckets);\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n  bucket#0: [ { key: \x27cat\x27, value: 2 }, { key: \x27art\x27, value: 8 } ],\n            \x26lt;4 empty items\x26gt;,\n  bucket#5: [ { key: \x27rat\x27, value: 7 } ],\n            \x26lt;1 empty item\x26gt;,\n  bucket#7: [ { key: \x27dog\x27, value: 1 } ],\n            \x26lt;2 empty items\x26gt;\n*\/\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e换个角度看：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011f6faa6e24b662ce.jpg\x22 alt=\x22\x22 title=\x22HashMap: hash function translates keys into bucket (array) indexes\x22\x3e\x3c\/p\x3e\n\x3cp\x3e正如你所看到的，通过增加 HashMap 的容量，能有效减少冲突次数。\x3c\/p\x3e\n\x3cp\x3e那换个更大的试试怎样，比如 💯:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hashMapSize100 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e DecentHashMap(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\nhashMapSize100.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\nhashMapSize100.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\nhashMapSize100.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nhashMapSize100.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27collisions: \x27\x3c\/span\x3e, hashMapSize100.collisions); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27hashMapSize100\\n\x27\x3c\/span\x3e, hashMapSize100.buckets);\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n            \x26lt;5 empty items\x26gt;,\n  bucket#5: [ { key: \x27rat\x27, value: 7 } ],\n            \x26lt;1 empty item\x26gt;,\n  bucket#7: [ { key: \x27dog\x27, value: 1 } ],\n            \x26lt;32 empty items\x26gt;,\n  bucket#41: [ { key: \x27art\x27, value: 8 } ],\n            \x26lt;49 empty items\x26gt;,\n  bucket#90: [ { key: \x27cat\x27, value: 2 } ],\n            \x26lt;9 empty items\x26gt;\n*\/\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eYay! 🎊 没有冲突！\x3c\/p\x3e\n\x3cp\x3e通过增加初始容量，可以很好的减少冲突，但会消耗\x3cstrong\x3e更多的内存\x3c\/strong\x3e，而且很可能许多桶都没被使用。\x3c\/p\x3e\n\x3cp\x3e如果我们的 HashMap 能根据需要自动调整容量，这不是更好吗？这就是所谓的\x3cstrong\x3erehash\x3c\/strong\x3e（重新计算哈希值），我们将在下一节将实现它！\x3c\/p\x3e\n\x3ch2\x3e优化HashMap 的实现\x3c\/h2\x3e\n\x3cp\x3e如果 HashMap 的容量足够大，那就不会产生任何冲突，因此查找操作的时间复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e。然而，我们怎么知道容量多大才是足够呢，100？1000？还是一百万？\x3c\/p\x3e\n\x3cp\x3e（从开始就）分配大量的内存（去建立数组）是不合理的。因此，我们能做的是根据装载因子动态地调整容量。这操作被称为 \x3cstrong\x3erehash\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e装载因子\x3c\/strong\x3e是用于衡量一个 HashMap 满的程度，可以通过存储键值对的数量除以 HashMap 的容量得到它。\x3c\/p\x3e\n\x3cp\x3e根据这思路，我们将实现最终版的 HashMap：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e最佳的 HasnMap 实现\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHashMap\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(initialCapacity = \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e, loadFactor = \x3cspan class=\x22hljs-number\x22\x3e0.75\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets = new Array(initialCapacity);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.loadFactor = loadFactor;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.collisions = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keys = [];\n  }\n  hash(key) {\n    let hashValue = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    const stringTypeKey = `${key}${typeof key}`;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; stringTypeKey.length; index\x2b\x2b) {\n      const charCode = stringTypeKey.charCodeAt(index);\n      hashValue \x2b= charCode \x26lt;\x26lt; (index * \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hashValue;\n  }\n  _getBucketIndex(key) {\n    const hashValue = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hash(key);\n    const bucketIndex = hashValue % \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bucketIndex;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(key, value) {\n    const {bucketIndex, entryIndex} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getIndexes(key);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(entryIndex === undefined) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize array and save key\/value\x3c\/span\x3e\n      const keyIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keys.push({content: key}) - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep track of the key index\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex] || [];\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].push({key, value, keyIndex});\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size\x2b\x2b;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Optional: keep count of collisions\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.collisions\x2b\x2b; }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ override existing value\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex][entryIndex].value = value;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check if a rehash is due\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.loadFactor \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getLoadFactor() \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.loadFactor) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rehash(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets.length * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(key) {\n    const {bucketIndex, entryIndex} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getIndexes(key);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(entryIndex === undefined) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex][entryIndex].value;\n  }\n  has(key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(key);\n  }\n  _getIndexes(key) {\n    const bucketIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getBucketIndex(key);\n    const values = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex] || [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let entryIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; entryIndex \x26lt; values.length; entryIndex\x2b\x2b) {\n      const entry = values[entryIndex];\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(entry.key === key) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {bucketIndex, entryIndex};\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {bucketIndex};\n  }\n  delete(key) {\n    const {bucketIndex, entryIndex, keyIndex} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getIndexes(key);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(entryIndex === undefined) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets[bucketIndex].splice(entryIndex, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    delete \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keys[keyIndex];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size--;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n  rehash(newCapacity) {\n    const newMap = new HashMap(newCapacity);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keys.forEach(key =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(key) {\n        newMap.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(key.content, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(key.content));\n      }\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update bucket\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets = newMap.buckets;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.collisions = newMap.collisions;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Optional: both `keys` has the same content except that the new one doesn\x27t have empty spaces from deletions\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keys = newMap.keys;\n  }\n  getLoadFactor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buckets.length;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/hash-maps\/hash-map.js\x22\x3e完整代码\x3c\/a\x3e\n（译者注：其实 \x3ccode\x3ehas\x3c\/code\x3e 方法有问题，只是不影响阅读。）\x3c\/p\x3e\n\x3cp\x3e注意第99行至第114行（即 \x3ccode\x3erehash\x3c\/code\x3e 函数），那里是 rehash 魔法发生的地方。我们创造了一个新的 HashMap，它拥有原来 HashMap两倍的容量。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e测试\x3c\/strong\x3e一下上面的新实现吧：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27assert\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hashMap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eHashMap\x3c\/span\x3e();\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.getLoadFactor(), \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27songs\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27pets\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27tests\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27art\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.getLoadFactor(), \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\/\x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Pineapple\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Pen Pineapple Apple Pen\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Despacito\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Luis Fonsi\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Bailando\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Enrique Iglesias\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Dura\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Daddy Yankee\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Lean On\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Major Lazer\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Adele\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27All About That Bass\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Meghan Trainor\x27\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27This Is What You Came For\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Calvin Harris \x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.collisions, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.getLoadFactor(), \x3cspan class=\x22hljs-number\x22\x3e0.75\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.buckets.length, \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e);\nhashMap.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Wake Me Up\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Avicii\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;--- Trigger REHASH\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.collisions, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.getLoadFactor(), \x3cspan class=\x22hljs-number\x22\x3e0.40625\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(hashMap.buckets.length, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意，在 HashMap 存储了12项之后，装载因子将超过0.75，因而触发 rehash，HashMap 容量加倍（从16到32）。同时，我们也能看到冲突从2降低为0。\x3c\/p\x3e\n\x3cp\x3e这版本实现的 HashMap 能以很低的时间复杂度进行常见的操作，如：插入、查找、删除、编辑等。\x3c\/p\x3e\n\x3cp\x3e小结一下，HashMap 的性能取决于：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e哈希函数能根据不同的键输出不同的值。\x3c\/li\x3e\n\x3cli\x3eHashMap 容量的大小。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们终于处理好了各种问题 🔨。有了不错的哈希函数，可以根据不同输入返回不同输出。同时，我们也有 \x3ccode\x3erehash\x3c\/code\x3e 函数根据需要动态地调整 HashMap的容量。这实在太好了！\x3c\/p\x3e\n\x3ch2\x3eHashMap 中插入元素的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e往一个 HashMap 插入元素需要两样东西：一个键与一个值。可以使用上文开发优化后的 HashMap 或内置的对象进行操作：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3einsert\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e, key, \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e[key] = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hash = {};\nconsole.log(insert(hash, \x3cspan class=\x22hljs-string\x22\x3e\x27word\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { word: 1 }\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在新版的 JavaScript 中，你可以使用 Map。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3efunction insertMap(\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value) {\n  \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, value);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Map();\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(insertMap(\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27word\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Map { \x27word\x27 =\x26gt; 1 }\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e。我们将使用 Map 而不是普通的对象，这是由于 Map 的键可以是任何东西而对象的键只能是字符串或者数字。此外，Map 可以保持插入的顺序。\x3c\/p\x3e\n\x3cp\x3e进一步说，\x3ccode\x3eMap.set\x3c\/code\x3e 只是将元素插入到数组（如上文 \x3ccode\x3eDecentHashMap.set\x3c\/code\x3e 所示），类似于 \x3ccode\x3eArray.push\x3c\/code\x3e，因此可以说：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e往 HashMap 中插入元素，时间复杂度是 \x3cem\x3eO(1)\x3c\/em\x3e。如果需要 rehash，那么复杂度则是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3erehash 能将冲突可能性降至最低。rehash 操作时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e ，但不是每次插入操作都要执行，仅在需要时执行。\x3c\/p\x3e\n\x3ch2\x3eHashMap 中查找或访问元素的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e这是 \x3ccode\x3eHashMap.get\x3c\/code\x3e 方法，我们通过往里面传递一个键来获取对应的值。让我们回顾一下 \x3ccode\x3eDecentHashMap.get\x3c\/code\x3e 的实现：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs maxima\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e（\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e）{\n  const hashIndex = this .getIndex（\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e）;\n  const \x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e = this .\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e [hashIndex];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e（\x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ; index \x26lt;\x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; index \x2b\x2b）{\n    const entry = \x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e [index];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e（entry.\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e）{\n      返回 entry.value\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果并未发生冲突，那么 \x3ccode\x3evalues\x3c\/code\x3e 只会有一个值，访问的时间复杂度是 \x3cem\x3eO(1)\x3c\/em\x3e。但我们也知道，冲突总是会发生的。如果 HashMap 的初始容量太小或哈希函数设计糟糕，那么大多数元素访问的时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eHashMap 访问操作的时间复杂度平均是 \x3cem\x3eO(1)\x3c\/em\x3e，最坏情况是 \x3cem\x3eO(n)\x3c\/em\x3e 。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e进阶提示：\x3c\/strong\x3e另一个（将访问操作的）时间复杂度从 \x3cem\x3eO(n)\x3c\/em\x3e 降至  \x3cem\x3eO(log n)\x3c\/em\x3e 的方法是使用 \x3cem\x3e二叉搜索树\x3c\/em\x3e 而不是数组进行底层存储。事实上，当存储的\x3ca href=\x22http:\/\/hg.openjdk.java.net\/jdk9\/jdk9\/jdk\/file\/f08705540498\/src\/java.base\/share\/classes\/java\/util\/HashMap.java#l257\x22\x3e元素超过8 个\x3c\/a\x3e时， \x3ca href=\x22http:\/\/hg.openjdk.java.net\/jdk9\/jdk9\/jdk\/file\/f08705540498\/src\/java.base\/share\/classes\/java\/util\/HashMap.java#l145\x22\x3eJava  HashMap 的底层实现\x3c\/a\x3e会从数组转为树。\x3c\/p\x3e\n\x3ch2\x3eHashMap 中修改或删除元素的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e修改(\x3ccode\x3eHashMap.set\x3c\/code\x3e)或删除（\x3ccode\x3eHashMap.delete\x3c\/code\x3e）键值对，分摊后的时间复杂度是 \x3cem\x3eO(1)\x3c\/em\x3e。如果冲突很多，可能面对的就是最坏情况，复杂度为  \x3cem\x3eO(n)\x3c\/em\x3e。然而伴随着 rehash 操作，可以大大减少最坏情况的发生的几率。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eHashMap 修改或删除操作的时间复杂度平均是 \x3cem\x3eO(1)\x3c\/em\x3e ，最坏情况是 \x3cem\x3eO(n)\x3c\/em\x3e。 \x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3eHashMap 方法的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e在下表中，小结了 HashMap（方法）的时间复杂度：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eHashMap 方法的时间复杂度\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e操作方法\x3c\/th\x3e\n\x3cth\x3e最坏情况\x3c\/th\x3e\n\x3cth\x3e平均\x3c\/th\x3e\n\x3cth\x3e备注\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e访问或查找 (\x3ccode\x3eHashMap.get\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e 是冲突极多的极端情况\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e插入或修改 (\x3ccode\x3eHashMap.set\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e 只发生在装载因子超过0.75，触发 rehash 时\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e删除 (\x3ccode\x3eHashMap.delete\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e 是冲突极多的极端情况\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1\x3eSets\x3c\/h1\x3e\n\x3cp\x3e集合跟数组非常相像。它们的区别是集合中的元素是唯一的。\x3c\/p\x3e\n\x3cp\x3e我们该如何实现一个集合呢（也就是没有重复项的数组）？可以使用数组实现，在插入新元素前先检查该元素是否存在。但检查是否存在的时间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e。能对此进行优化吗？之前开发的 Map （插入操作）分摊后时间复杂度度才 \x3cem\x3eO(1)\x3c\/em\x3e！\x3c\/p\x3e\n\x3ch2\x3eSet 的实现\x3c\/h2\x3e\n\x3cp\x3e可以使用 JavaScript 内置的 Set。然而通过自己实现它，可以更直观地了解它的时间复杂度。我们将使用上文优化后带有 rehash 功能的 HashMap 来实现它。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3econst HashMap = require(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/hash-maps\/hash-map\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySet\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap = new HashMap();\n  }\n  add(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(value);\n  }\n  has(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap.has(value);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e size() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap.size;\n  }\n  delete(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap.delete(value);\n  }\n  entries() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hashMap.keys.reduce((acc, key) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(key !== undefined) {\n        acc.push(key.content);\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e acc\n    }, []);\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（译者注：由于 HashMap 的 \x3ccode\x3ehas\x3c\/code\x3e 方法有问题，导致 Set 的 \x3ccode\x3ehas\x3c\/code\x3e 方法也有问题）\x3c\/p\x3e\n\x3cp\x3e我们使用 \x3ccode\x3eHashMap.set\x3c\/code\x3e 为集合不重复地添加元素。我们将待存储的值作为 HashMap的键，由于哈希函数会将键映射为唯一的索引，因而起到排重的效果。\x3c\/p\x3e\n\x3cp\x3e检查一个元素是否已存在于集合中，可以使用 \x3ccode\x3ehashMap.has\x3c\/code\x3e 方法，它的时间复杂度平均是 \x3cem\x3eO(1)\x3c\/em\x3e。集合中绝大多数的方法分摊后时间复杂度为 \x3cem\x3eO(1)\x3c\/em\x3e，除了 \x3ccode\x3eentries\x3c\/code\x3e 方法，它的事件复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e注意：使用 JavaScript 内置的集合时，它的  \x3ccode\x3eSet.has\x3c\/code\x3e 方法时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。这是由于它的使用了 List 作为内部实现，需要检查每一个元素。你可以在\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.has\x22\x3e这\x3c\/a\x3e查阅相关的细节。\x3c\/p\x3e\n\x3cp\x3e下面有些例子，说明如何使用这个集合：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27assert\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const set = new Set(); \/\/ Using the built-in\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySet(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Using our own implementation\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27uno\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ should NOT add this one twice\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.has(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.has(\x3cspan class=\x22hljs-string\x22\x3e\x27dos\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ assert.deepEqual(Array.from(set), [\x27one\x27, \x27uno\x27]);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.delete(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.delete(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.has(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e.equal(\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这个例子中，MySet 与 JavaScript 中内置的 Set 均可作为容器。\x3c\/p\x3e\n\x3ch2\x3eSet 方法的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e根据 HashMap 实现的的 Set，可以小结出的时间复杂度如下（与 HashMap 非常相似）：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eSet 方法的时间复杂度\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e操作方法\x3c\/th\x3e\n\x3cth\x3e最坏情况\x3c\/th\x3e\n\x3cth\x3e平均\x3c\/th\x3e\n\x3cth\x3e备注\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e访问或查找 (\x3ccode\x3eSet.has\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e 是冲突极多的极端情况\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e插入或修改 (\x3ccode\x3eSet.add\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e 只发生在装载因子超过0.75，触发 rehash 时\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e删除 (\x3ccode\x3eSet.delete\x3c\/code\x3e)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e是冲突极多的极端情况)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1\x3eLinked Lists\x3c\/h1\x3e\n\x3cp\x3e链表是一种一个节点链接到下一个节点的数据结构。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01fa68db515c83eaa0.jpg\x22 alt=\x22\x22 title=\x22LinkedList\x22\x3e\x3c\/p\x3e\n\x3cp\x3e链表是（本文）第一种不用数组（作为底层）实现的数据结构。我们使用节点来实现，节点存储了一个元素，并指向下一个节点（若没有下一个节点，则为空）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e {\n  constructor(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当每个节点都指向它的下了一个节点时，我们就拥有了一条由若干节点组成链条，即\x3cstrong\x3e单向链表\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2\x3eSingly Linked Lists\x3c\/h2\x3e\n\x3cp\x3e对于单向链表而言，我们只需关心每个节点都有指向下一个节点的引用。\x3c\/p\x3e\n\x3cp\x3e从首个节点或称之为根节点开始构建（单向链表）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLinkedList\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e每个链表都有四个基础操作：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eaddLast：将一个元素添加至链表尾部。\x3c\/li\x3e\n\x3cli\x3eremoveLast：删除链表的最后一个元素。\x3c\/li\x3e\n\x3cli\x3eaddFirst：将一个元素添加到链表的首部。\x3c\/li\x3e\n\x3cli\x3eremoveFirst：删除链表的首个元素。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e向链表末尾添加与删除一个元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e（对添加操作而言，）有两种情况。1）如果链表根节点不存在，那么将新节点设置为链表的根节点。2）若存在根节点，则必须不断查询下一个节点，直到链表的末尾，并将新节点添加到最后。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eaddLast(value) { \/\/ similar Array.push\n  const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= new\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e(value\x3c\/span\x3e);\n  if(this.root) {\n    let currentNode = this.root;\n    while(currentNode \x26amp;\x26amp; currentNode.next) {\n      currentNode = currentNode.next;\n    }\n    currentNode.next = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  } else\x3c\/span\x3e {\n    this.root = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  }\n}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e上述代码的时间复杂度是多少呢？如果是作为根节点添加进链表，时间复杂度是  \x3cem\x3eO(1)\x3c\/em\x3e，然而寻找最后一个节点的时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e.。\x3c\/p\x3e\n\x3cp\x3e删除末尾的节点与上述代码相差无几。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs gradle\x22\x3eremoveLast() {\n  let current = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root;\n  let target;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(current \x26amp;\x26amp; current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(current \x26amp;\x26amp; current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e \x26amp;\x26amp; current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e) {\n      current = current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e;\n    }\n    target = current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e;\n    current.\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root = \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n    target = current;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(target) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target.value;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e时间复杂度也是 \x3cem\x3eO(n)\x3c\/em\x3e。这是由于我们必须依次往下，直到找到倒数第二个节点，并将它 \x3ccode\x3enext\x3c\/code\x3e 的引用指向 \x3ccode\x3enull\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e向链表开头添加与删除一个元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e往链表开头添加一个元素（的代码）如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eaddFirst(value) {\n  const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= new\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e(value\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3enext\x3c\/span\x3e = this.first;\n  this.first = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e向链表的开头进行增删操作，所耗费的时间是恒定的，因为我们持有根元素的引用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs aspectj\x22\x3eremoveFirst(value) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e ? \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.next : \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.value;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（译者注：作者原文 \x3ccode\x3eremoveFirst\x3c\/code\x3e 的代码放错了，上述代码是译者实现的）\x3c\/p\x3e\n\x3cp\x3e如你所见，对链表的开头进行增删操作，时间复杂度永远是  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e从链表的任意位置删除元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e删除链表首尾的元素，可以使用 \x3ccode\x3eremoveFirst\x3c\/code\x3e 或 \x3ccode\x3eremoveLast\x3c\/code\x3e。然而，如若移除的节点在链表的中间，则需要将待删除节点的前一个节点指向待删除节点的下一个节点，从而从链表中删除该节点：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs aspectj\x22\x3eremove(index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(index === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eremoveFirst\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\n  }\n  let current;\n  let \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e;  i\x2b\x2b, current = \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.next) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(i === index) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.next) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if it doesn\x27t have next it means that it is the last\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eremoveLast\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\n      }\n      current.next = \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.next;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size--;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.value;\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（译者注：原文实现有点问题，译者稍作了点修改。\x3ccode\x3eremoveLast\x3c\/code\x3e 的调用其实浪费了性能，但可读性上增加了，因而此处未作修改。）\x3c\/p\x3e\n\x3cp\x3e注意， \x3ccode\x3eindex\x3c\/code\x3e 是从0开始的：0是第一个节点，1是第二个，如此类推。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在链表任意一处删除节点，时间复杂度为  \x3cem\x3eO(n)\x3c\/em\x3e.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e在链表中查找元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在链表中查找一个元素与删除元素的代码差不多：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs fortran\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econtains\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n  for (let current = this.first, \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; current;  \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e\x2b\x2b, current = current.next) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(current.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e === \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e;\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这个方法查找链表中第一个与给定值相等的节点（的索引）。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在链表中查找一个元素，时间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e单向链表操作方法的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e在下表中，小结了单向链表（方法）的时间复杂度：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e操作方法\x3c\/th\x3e\n\x3cth\x3e时间复杂度\x3c\/th\x3e\n\x3cth\x3e注释\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eaddFirst\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的开头\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eaddLast\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的末尾\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eadd\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的任意地方\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremoveFirst\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表的首个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremoveLast\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表最后一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremove\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表中任意一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3econtains\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在链表中查找任意元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e注意，当我们增删链表的最后一个元素时，该操作的时间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e…\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e但只要持有最后一个节点的引用，可以从原来的 \x3cem\x3eO(n)\x3c\/em\x3e，降至与增删首个元素一致，变为 \x3cem\x3eO(1)\x3c\/em\x3e！\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e我们将在下一节实现这功能！\x3c\/p\x3e\n\x3ch2\x3eDoubly Linked Lists\x3c\/h2\x3e\n\x3cp\x3e当我们有一串节点，每一个都有指向下一个节点的引用，也就是拥有了一个\x3cstrong\x3e单向链表\x3c\/strong\x3e。而当一串节点，每一个既有指向下一个节点的引用，也有指向上一个节点的引用时，这串节点就是\x3cstrong\x3e双向链表\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01c1739573cb495ec3.jpg\x22 alt=\x22\x22 title=\x22Doubly Linked List\x22\x3e\x3c\/p\x3e\n\x3cp\x3e双向链表的节点有两个引用（分别指向前一个和后一个节点），因此需要保持追踪首个与最后一个节点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.previous = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n}\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLinkedList\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ head\/root element\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ last element of the list\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ total number of elements in the list\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（双向链表的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e添加或删除链表的首个元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e由于持有首个节点的引用，因而添加或删除首个元素的操作是十分简单的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eaddFirst(value) {\n  const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= new\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e(value\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3enext\x3c\/span\x3e = this.first;\n  if(this.first) {\n    this.first.previous = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  } else\x3c\/span\x3e {\n    this.last = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  }\n  this\x3c\/span\x3e.first = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e; \/\/ update\x3c\/span\x3e head\n  this.size\x2b\x2b;\n  return \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（\x3ccode\x3eLinkedList.prototype.addFirst\x3c\/code\x3e 的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e注意，我们需要十分谨慎地更新节点的 \x3ccode\x3eprevious\x3c\/code\x3e 引用、双向链表的 \x3ccode\x3esize\x3c\/code\x3e 与双向链表最后一个节点的引用。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3eremoveFirst() {\n  const first = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(first) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = first.next;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first.previous = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size--;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e first.value;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（\x3ccode\x3eLinkedList.prototype.removeFirst\x3c\/code\x3e 的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e时间复杂度是什么呢？\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e无论是单向链表还是双向链表，添加与删除首个节点的操作耗费时间都是恒定的，时间复杂度为 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e添加或删除链表的最后一个元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e从双向链表的末尾\x3c\/em\x3e添加或删除一个元素稍有点麻烦。当你查询单向链表（操作的时间复杂度）时，这两个操作都是 \x3cem\x3eO(n)\x3c\/em\x3e，这是由于需要遍历整条链表，直至找到最后一个元素。然而，双向链表持有最后一个节点的引用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eaddLast(value) {\n  const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= new\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e(value\x3c\/span\x3e);\n  if(this.first) {\n    \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eprevious\x3c\/span\x3e = this.last;\n    this.last.next = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    this\x3c\/span\x3e.last = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  } else\x3c\/span\x3e {\n    this.first = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    this\x3c\/span\x3e.last = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  }\n  this\x3c\/span\x3e.size\x2b\x2b;\n  return \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（\x3ccode\x3eLinkedList.prototype.addLast\x3c\/code\x3e 的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e同样，我们需要小心地更新引用与处理一些特殊情况，如链表中只有一个元素时。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3eremoveLast() {\n  let current = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first;\n  let target;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(current \x26amp;\x26amp; current.next) {\n    target = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last;\n    current = target.previous;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = current;\n    current.next = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    target = current;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(target) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size--;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target.value;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（\x3ccode\x3eLinkedList.prototype.removeLast\x3c\/code\x3e 的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e使用了双向链表，我们不再需要遍历整个链表直至找到倒数第二个元素。可以直接使用 \x3ccode\x3ethis.last.previous\x3c\/code\x3e 来找到它，时间复杂度是 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e下文将介绍队列相关的知识，本文中队列是使用两个数组实现的。可以改为使用双向链表实现队列，因为（双向链表）添加首个元素与删除最后一个元素时间复杂度都是 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e添加一个元素至链表任意一处\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e借助 \x3ccode\x3eaddFirst\x3c\/code\x3e 与 \x3ccode\x3eaddLast\x3c\/code\x3e，可以实现将一个元素添加到链表任意一处，实现如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3eadd(value, index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(index === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.addFirst(value);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let current = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.first, i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt;= \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.size;  i\x2b\x2b, current = (current \x26amp;\x26amp; current.next)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(i === index) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(i === \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.size) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if it doesn\x27t have next it means that it is the last\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.addLast(value);\n      }\n      const \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e(value);\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e.previous = current.previous;\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e.next = current;\n      current.previous.next = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(current.next) { current.next.previous = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e; }\n      \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.size\x2b\x2b;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e（\x3ccode\x3eLinkedList.prototype.add\x3c\/code\x3e 的\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/linked-lists\/linked-list.js\x22\x3e完整代码\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e如果添加元素的位置是在链表中间，我们就必须更新该元素前后节点的 \x3ccode\x3enext\x3c\/code\x3e 与 \x3ccode\x3eprevious\x3c\/code\x3e 引用。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e添加一个元素至链表任意一处的时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e双向链表方法的时间复杂度\x3c\/h2\x3e\n\x3cp\x3e双向链表每个方法的时间复杂度如下表：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e操作方法\x3c\/th\x3e\n\x3cth\x3e时间复杂度\x3c\/th\x3e\n\x3cth\x3e注释\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eaddFirst\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的开头\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eaddLast\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的末尾\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eadd\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e将元素插入到链表的任意地方\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremoveFirst\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表的首个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremoveLast\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表最后一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eremove\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e删除链表中任意一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3econtains\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在链表中查找任意元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e与单向链表相比，有了很大的改进（译者注：其实看场景，不要盲目认为双向链表一定比单向链表强）！（\x3ccode\x3eaddLast\x3c\/code\x3e 与 \x3ccode\x3eremoveLast\x3c\/code\x3e）操作时间复杂度从 \x3cem\x3eO(n)\x3c\/em\x3e 降至 \x3cem\x3eO(1)\x3c\/em\x3e ，这是由于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e添加对前一个节点的引用。\x3c\/li\x3e\n\x3cli\x3e持有链表最后一个节点的引用。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e删除首个或最后一个节点可以在恒定时间内完成，然而删除中间的节点时间复杂度仍然是 \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/p\x3e\n\x3ch1\x3eStacks\x3c\/h1\x3e\n\x3cp\x3e栈是一种越后被添加的元素，越先被弹出的数据结构。也就是后进先出（LIFO）.\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01399832fe71e12241.jpg\x22 alt=\x22\x22 title=\x22Stack: push and pop\x22\x3e\x3c\/p\x3e\n\x3cp\x3e让我们从零开始实现一个栈！\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStack\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = [];\n  }\n  push(element) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.push(element);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n  pop() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.pop();\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如你看到的，如果使用内置的  \x3ccode\x3eArray.push\x3c\/code\x3e 与 \x3ccode\x3eArray.pop\x3c\/code\x3e 实现一个栈，那是十分简单的。两个方法的时间复杂度都是 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e下面来看看栈的具体使用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Stack();\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.push(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.push(\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.push(\x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.pop(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ c\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.pop(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ b\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e.pop(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e最先被加入进去的元素 a 直到最后才被弹出。栈也可以通过链表来实现，对应方法的时间复杂度是一样的。\x3c\/p\x3e\n\x3cp\x3e这就是栈的全部内容啦！\x3c\/p\x3e\n\x3ch1\x3eQueues\x3c\/h1\x3e\n\x3cp\x3e队列是一种越先被添加的元素，越先被出列的数据结构。也就是先进先出（FIFO）。就如现实中排成一条队的人们一样，先排队的先被服务（也就是出列）。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01e5260f21b4a65ca5.jpg\x22 alt=\x22\x22 title=\x22Queue: enqueue and dequeue\x22\x3e\x3c\/p\x3e\n\x3cp\x3e可以通过数组来实现一个队列，代码与栈的实现相类似。\x3c\/p\x3e\n\x3ch2\x3e通过数组实现队列\x3c\/h2\x3e\n\x3cp\x3e通过 \x3ccode\x3eArray.push\x3c\/code\x3e 与 \x3ccode\x3eArray.shift\x3c\/code\x3e 可以实现一个简单（译者注：即不是最优的实现方式）的队列：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3eclass\x3cspan class=\x22hljs-built_in\x22\x3e Queue \x3c\/span\x3e{\n  constructor() {\n    this.input = [];\n  }\n  \x3cspan class=\x22hljs-builtin-name\x22\x3eadd\x3c\/span\x3e(element) {\n    this.input.push(element);\n  }\n  \x3cspan class=\x22hljs-builtin-name\x22\x3eremove\x3c\/span\x3e() {\n    return this.input.shift();\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3eQueue.add\x3c\/code\x3e 与 \x3ccode\x3eQueue.remove\x3c\/code\x3e 的时间复杂度是什么呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3eQueue.add\x3c\/code\x3e  使用 \x3ccode\x3eArray.push\x3c\/code\x3e 实现，可以在恒定时间内完成。这非常不错！\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eQueue.remove\x3c\/code\x3e 使用 \x3ccode\x3eArray.shift\x3c\/code\x3e 实现，\x3ccode\x3eArray.shift\x3c\/code\x3e 耗时是线性的（即  \x3cem\x3eO(n)\x3c\/em\x3e）。我们可以减少 \x3ccode\x3eQueue.remove\x3c\/code\x3e 的耗时吗？ \x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e试想一下，如果只用 \x3ccode\x3eArray.push\x3c\/code\x3e 与 \x3ccode\x3eArray.pop\x3c\/code\x3e 能实现一个队列吗？\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.output = [];\n  }\n  add(element) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.push(element);\n  }\n  remove() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.output.length) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.output.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.pop());\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.output.pop();\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，我们使用两个而不是一个数组来实现一个队列。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Queue();\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.add(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.add(\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.remove() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.add(\x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.remove() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ b\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.remove() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ c\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当我们第一次执行出列操作时，\x3ccode\x3eoutput\x3c\/code\x3e 数组是空的，因此将 \x3ccode\x3einput\x3c\/code\x3e 数组的内容反向添加到 \x3ccode\x3eoutput\x3c\/code\x3e 中，此时 \x3ccode\x3eoutput\x3c\/code\x3e 的值是 \x3ccode\x3e[\x27b\x27, \x27a\x27]\x3c\/code\x3e。然后再从 \x3ccode\x3eoutput\x3c\/code\x3e 中弹出元素。正如你所看到的，通过这个技巧实现的队列，元素输出的顺序也是先进先出（FIFO）的。\x3c\/p\x3e\n\x3cp\x3e那时间复杂度是什么呢？\x3c\/p\x3e\n\x3cp\x3e如果 \x3ccode\x3eoutput\x3c\/code\x3e 数组已经有元素了，那么出列操作就是恒定的 \x3cem\x3eO(1)\x3c\/em\x3e。而当 \x3ccode\x3eoutput\x3c\/code\x3e 需要被填充（即里面没有元素）时，时间复杂度变为 \x3cem\x3eO(n)\x3c\/em\x3e。\x3ccode\x3eoutput\x3c\/code\x3e 被填充后，出列操作耗时再次变为恒定。因此分摊后是 \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e也可以通过链表来实现队列，相关操作耗时也是恒定的。下一节将带来具体的实现。\x3c\/p\x3e\n\x3ch2\x3e通过双向链表实现队列\x3c\/h2\x3e\n\x3cp\x3e如果希望队列有最好的性能，就需要通过双向链表而不是数组来实现（译者注：并非数组实现就完全不好，空间上双向链表就不占优势，还是具体问题具体分析）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3econst LinkedList = require(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/linked-lists\/linked-list\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = new LinkedList();\n  }\n  add(element) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.addFirst(element);\n  }\n  remove() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.removeLast();\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e size() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.size;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过双向链表实现的队列，我们持有（双向链表中）首个与最后一个节点的引用，因此入列与出列的时间复杂度都是 \x3cem\x3eO(1)\x3c\/em\x3e。这就是为遇到的问题选择合适数据结构的重要性 💪。\x3c\/p\x3e\n\x3ch1\x3e总结\x3c\/h1\x3e\n\x3cp\x3e我们讨论了大部分线性的数据结构。可以看出，根据实现方法的不同，相同的数据结构也会有不同的时间复杂度。\x3c\/p\x3e\n\x3cp\x3e以下是本文讨论内容的总结：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e时间复杂度\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e* = 运行时分摊\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e数据结构\x3c\/th\x3e\n\x3cth\x3e插入\x3c\/th\x3e\n\x3cth\x3e访问\x3c\/th\x3e\n\x3cth\x3e查找\x3c\/th\x3e\n\x3cth\x3e删除\x3c\/th\x3e\n\x3cth\x3e备注\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eArray\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入最后位置复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e(Hash)\x3cstrong\x3eMap\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e重新计算哈希会影响插入时间。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eMap\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过二叉搜索树实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e（使用 HashMap）\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1）*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e由 HashMap 实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e (使用 List)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.add\x22\x3eO(n)\x3c\/a\x3e\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.has\x22\x3eO(n)\x3c\/a\x3e]\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-set.prototype.delete\x22\x3eO(n)\x3c\/a\x3e\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过 List 实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eSet\x3c\/strong\x3e (使用二叉搜索树)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(log(n))\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e通过二叉搜索树实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eLinked List\x3c\/strong\x3e (单向)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在起始位置添加或删除元素，复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eLinked List\x3c\/strong\x3e (双向）\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e在起始或结尾添加或删除元素，复杂度为  \x3cem\x3eO(1)\x3c\/em\x3e。然而在其他位置是  \x3cem\x3eO(n)\x3c\/em\x3e。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eStack\x3c\/strong\x3e (由 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)]\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入与删除都遵循与后进先出（LIFO）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (简单地由 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入（Array.shift）操作的复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (由 Array 实现，但进行了改进)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)*\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e插入操作的最差情况复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。然而分摊后是 \x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e (由 List 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e-\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e使用双向链表\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e注意： \x3cstrong\x3e二叉搜索树\x3c\/strong\x3e 与其他树结构、图结构，将在另一篇文章中讨论。\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/data-structures-for-beginners-arrays-hashmaps-and-lists">https://www.zcfy.cc/article/data-structures-for-beginners-arrays-hashmaps-and-lists</a> 原文标题: 初学者应该了解的数据结构：Array、HashMap 与 List 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/6bceb83f/" target="_blank">https://alili.tech/archive/6bceb83f/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>