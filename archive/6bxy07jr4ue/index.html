<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="GitChat · 前端 | 浅尝初试 React 技术栈"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>GitChat · 前端 | 浅尝初试 React 技术栈 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6bxy07jr4ue/",
				"appid": "1613049289050283", 
				"title": "GitChat · 前端 | 浅尝初试 React 技术栈 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-04T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/y478vyjth5e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6r09ttwndud/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&text=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&text=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&title=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&is_video=false&description=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&title=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&title=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&title=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6bxy07jr4ue%2f&title=GitChat%20%c2%b7%20%e5%89%8d%e7%ab%af%20%7c%20%e6%b5%85%e5%b0%9d%e5%88%9d%e8%af%95%20React%20%e6%8a%80%e6%9c%af%e6%a0%88"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">GitChat · 前端 | 浅尝初试 React 技术栈</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e来自 GitChat 作者：余博伦 \x3cbr\x3e更多IT技术分享，尽在微信公众号：GitChat 技术杂谈\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/gitbook.cn\/books\/595e1822fd12e512c486802d\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e进入 GitChat 阅读原文\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3eReact\x3c\/h3\x3e\n\x3ch4\x3eReact 是什么？\x3c\/h4\x3e\n\x3cp\x3eFacebook 官方对 React 定义是：用来构建用户界面的库（Library）。注意到这里的用词是库（Library）而不是框架（Framework）。React 不像早期版本的 Angular 这样功能非常完备的 mvvm 框架，它主要只专注于解决 MVC 当中 V 层，也就是视图层（View）方面的问题。\x3c\/p\x3e\n\x3cp\x3e不过我们也不必太过纠结库（Library）或框架（Framework）的定义。复杂的，给出你一整套解决方案的就叫框架（Framework）；简单的，专注解决一个问题并做到极致（Do one thing and do it well）的就叫库（Library）。\x3c\/p\x3e\n\x3cp\x3e不过我们还是习惯性地称 React 是一个 JavaScript 框架，因为除了 React 核心库本身，在 React 的生态圈当中，还有很多其他可以搭配协同的工具库，比如在这次分享当中我们要介绍的用来解决状态管理问题的 Redux ；用来提供前端路由功能的 react-router 。我们把这些工具库统称为 React 技术栈，组合使用 React 技术栈也就完全撑得起一个框架提供的功能了。\x3c\/p\x3e\n\x3ch4\x3eReact 有哪些特性？\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e声明式\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e说白了声明式就是你告诉程序你要一个什么样的东西的编写代码的方式。这也是在开发构建用户界面时最友好的方式。在 React 当中，你可以很轻松地告诉 React 你想要一个什么样的界面。我们使用一种叫做 JSX 的类似于 HTML\/XML 的 JavaScript 语法扩展来和 React 交流：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c应用\x3e\n    \x3c输入框\x3e\x3c\/输入框\x3e\n    \x3c按钮\x3e\x3c\/按钮\x3e\n\x3c\/应用\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs apache\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;应用\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;输入框\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/输入框\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;按钮\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/按钮\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/应用\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这就好像我们可以直接对 React 说：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e这里我要一个按钮！\x3cbr\x3e这里我要一个表单！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e是不是非常的直观明了呢？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e组件化\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在 React 当中，我们是以组件（Component）的概念来划分用户界面的。通常我们开发的页面都可以拆成一个个通用的组件，例如导航、表单、列表项、页脚等等。\x3c\/p\x3e\n\x3cp\x3e使用 React 可以在很大程度上提高你代码的可复用性，编写页面就如搭积木一般简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c应用\x3e\n    \x3c导航\/\x3e\n    \x3c注册表单\/\x3e\n    \x3c页脚\/\x3e\n\x3c\/应用\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs apache\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;应用\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;导航\/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;注册表单\/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;页脚\/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/应用\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这也同样意味着，我们除了可以在开发页面时复用自己编写的组件以外，还能把别人编写好的通用组件直接拿过来用。自定义一下样式，传个数据进去，组合起来，一个页面分分钟就搞定。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e一次学习，随处编写\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eReact 最强大的地方在于，其内部实现的虚拟DOM屏蔽了所有的底层实现，通过不同的渲染器（renderer），你编写的同一套代码可以用来构建包含 \x3cstrong\x3e浏览器\/桌面操作系统\/Android\/iOS\x3c\/strong\x3e 等几乎所有平台的用户界面。也就是说，掌握了 React 之后，你的能力将不止局限于写网页，而是可以在几乎所有的平台上开发用户界面。\x3c\/p\x3e\n\x3cp\x3e这也就是为什么我们使用 React 的时候需要调用两个库 react 和 react-dom，react 库文件用来实现 React 的核心功能，react-dom 则用来把它渲染到浏览器当中。\x3c\/p\x3e\n\x3cp\x3e目前已有的其他平台的解决方案还包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eReact Native\x3c\/li\x3e\n\x3cli\x3eReact VR\x3c\/li\x3e\n\x3cli\x3eReact XP\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e例如在使用 React Native 的时候，我们同样是使用 react 核心库来实现基础功能，然后通过 react-native 库将我们编写的界面渲染到移动端上。\x3c\/p\x3e\n\x3cp\x3e也就是说，有了 React 之后，我们可以用一种统一的描述方式来开发用户界面，至于在什么平台上实现，只要有相应的渲染器（renderer），我们就能够把我们开发的界面在对应的平台上面渲染出来。例如在美剧《西部世界》当中，React 甚至可以用来编写人工智能 Host 的故事线：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010641964\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010641964\x22 alt=\x22西部世界代码图.jpg\x22 title=\x22西部世界代码图.jpg\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e用 React 编写组件\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3eReact 组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们用 React 编写的代码绝大多数都是组件的代码。编写 React 组件需要遵循 React 内部的一系列规范，因此用 React 编写出来的应用自带前端工程化属性。不管新手还是老司机，只要是用 React 写组件，我们都能保证他写出来的代码是差不多的。这也就非常有利于一个项目组当中多个开发者之间进行协作。非常适合高级做架构，中级封组件，初级写业务的模式。\x3c\/p\x3e\n\x3cp\x3eReact 组件其实就相当于 JavaScript 当中的一种函数，接受应用数据作为参数，内部进行一系列处理（包含事件处理函数、生命周期函数等，此处不展开讲），返回一个 React 元素。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eReact 元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这里要注意到，React 组件和 React 元素是两个不同的概念。React 元素是 React 组件的一部分，也就是 React 组件返回的要拿来渲染的内容。\x3c\/p\x3e\n\x3ch4\x3eJSX\x3c\/h4\x3e\n\x3cp\x3e在 React 当中，我们通过一种叫做 JSX 的 JavaScript 语法扩展来描述 React 元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const title = \x3ch1\x3eCounter\x3c\/h1\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e title = \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eCounter\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里特别要注意的是，JSX 既不是原生的 HTML，也不是 jQuery 当中的字符串 \x3ccode\x3e$(\x27\x26lt;h1\x26gt;Counter\x26lt;\/h1\x26gt;\x27)\x3c\/code\x3e ，更不是 pug(jade) 当中的模板 \x3ccode\x3eh1 Counter\x3c\/code\x3e。这是 React 内部自己的一套实现，可以允许你像写 HTML 一样，在 JavaScript 代码当中直接写页面，React 会在随后的渲染过程当中自动把 JSX 转译成页面当中真实的 DOM 元素。\x3c\/p\x3e\n\x3ch4\x3e函数定义组件 \x26amp; 类定义组件\x3c\/h4\x3e\n\x3cp\x3e在 React 当中，有两种定义组件的方式。（注：在 react@15.6 当中已经废弃了 \x3ccode\x3ecreateClass\x3c\/code\x3e 方法，如果你从来没用过 React 请自动忽略）\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e函数定义组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e比较简单的一些，只接受外部传入的数据的组件，我们一般通过函数定义的方式来编写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Button = function(props) {\n    return \x3cbutton onClick={props.onClick}\x3e\x2b\x3c\/button\x3e;\n}\n\n\/\/ 当然也可以用 ES6 的 箭头函数 arrow function\n\nconst Number = ({ number }) =\x3e \x3cp\x3e{number}\x3c\/p\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Button = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{props.onClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当然也可以用 ES6 的 箭头函数 arrow function\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ number }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x26lt;p\x26gt;{number}\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/p\x26gt;;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eprops \x26amp; state\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e上述示例当中的 props 就是组件数据的一种。在 React 当中，最常用的组件数据有两种：props 和 state.\x3c\/p\x3e\n\x3cp\x3e其中 props 是从外部传入的，内部无法修改，用来渲染展示的数据。\x3c\/p\x3e\n\x3cp\x3e而 state 则是组件内部维护，可以跟随应用状态改变而改变的数据（例如用户输入的表单项）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e类定义组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e比较复杂的，需要处理事件，调用生命周期函数，与服务器交互数据的组件，我们通过类定义组件的方式来声明：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 从 React 库当中获取组件的基础支持\nconst { Component } = React;\n\/\/ 使用 ES6 当中的 class 关键字来声明组件\nclass Container extends Component {\n    \/* 类中的构造方法，调用super方法来确保我们能够获取到this，组件自身的 state 数据也在构造方法当中初始化。*\/\n    constructor() {\n        super();\n        this.state = {\n            number: 0\n        }\n    }\n    \/* 事件处理方法，在 React 当中我们通过调用 `setState` 方法来修改 state 数据，这样才能触发组件在界面当中自动重新渲染更新 *\/\n    handleClick() {\n        this.setState({number: this.state.number\x2b1});\n    }\n    \/\/ 渲染方法，返回 React 元素\n    render() {\n        return (\n            \x3cdiv\x3e\n                \x3cTitle \/\x3e\n                \x3cNumber number={this.state.number} \/\x3e\n                \x3cButton onClick={() =\x3e this.handleClick()} \/\x3e\n            \x3c\/div\x3e\n            );\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode class=\x22jsx\x22\x3e\/\/ 从 React 库当中获取组件的基础支持\nconst { Component } = React;\n\/\/ 使用 ES6 当中的 class 关键字来声明组件\nclass Container extends Component {\n    \/* 类中的构造方法，调用super方法来确保我们能够获取到this，组件自身的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 数据也在构造方法当中初始化。*\/\n    constructor() {\n        super();\n        this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {\n            number: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        }\n    }\n    \/* 事件处理方法，在 React 当中我们通过调用 `\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState` 方法来修改 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 数据，这样才能触发组件在界面当中自动重新渲染更新 *\/\n    handleClick() {\n        this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState({number: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.number\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e});\n    }\n    \/\/ 渲染方法，返回 React 元素\n    render() {\n        return (\n            \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;Title \/\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;Number number={this.state.number} \/\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;Button onClick={() =\x26gt;\x3c\/span\x3e this.handleClick()} \/\x26gt;\n            \x26lt;\/div\x26gt;\n            );\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e展示组件 \x26amp; 容器组件\x3c\/h4\x3e\n\x3cp\x3e在本文的开头我们已经介绍过了，React 是一个视图层的框架，也就是说它只有 V，而真正在编写前端代码的时候，除了页面展示的内容以外，我们还需要进行处理用户输入、验证表单、和服务器进行数据交互之类的操作。\x3c\/p\x3e\n\x3cp\x3e那么在实际的编码过程当中，我们要如何解耦这些应用的业务逻辑和用户界面的结构样式呢？\x3c\/p\x3e\n\x3cp\x3e这时我们就需要引入一组展示组件和容器组件的概念。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e展示组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e主要负责用户界面的结构和样式。\x3c\/li\x3e\n\x3cli\x3e从 props 接收父组件传递来的数据。\x3c\/li\x3e\n\x3cli\x3e大多数情况可以通过函数定义组件声明。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e容器组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e主要负责组件如何交互，业务逻辑等。\x3c\/li\x3e\n\x3cli\x3e拥有自身的state，从服务器获取数据，或与 redux 等其他数据处理模块协作。\x3c\/li\x3e\n\x3cli\x3e需要通过类定义组件声明，可以包含生命周期函数、事件处理函数等。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 展示组件\nconst Button = props =\x3e \x3cbutton onClick={props.onClick}\x3e\x2b\x3c\/button\x3e;\n\/\/ 容器组件\nclass Counter extends Component {\n  constructor() {\n    super();\n    this.state = {\n      number: 0\n    }\n  }\n  \n  handleClick() {\n    this.setState({number: this.state.number \x2b 1});\n  }\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cTitle \/\x3e\n        \x3cNumber number={this.state.number} \/\x3e\n        \x3cButton onClick={() =\x3e this.handleClick()} \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示组件\x3c\/span\x3e\nconst \x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e = props =\x26gt; \x26lt;button onClick={props.onClick}\x26gt;\x2b\x26lt;\/button\x26gt;;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 容器组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      number: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n  }\n  \n  handleClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({number: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.number \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e});\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eTitle\x3c\/span\x3e \/\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eNumber\x3c\/span\x3e number={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.number} \/\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e onClick={() =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick()} \/\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eRedux\x3c\/h3\x3e\n\x3ch4\x3eRedux 又是什么？\x3c\/h4\x3e\n\x3cp\x3e在上述 React 部分的介绍当中，我们已经提到了，React 用来处理数据的方式主要有 props 和 state 两种（另外还有一种不常用的 \x3ca href=\x22https:\/\/discountry.github.io\/react\/docs\/context.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3econtext\x3c\/a\x3e）。\x3c\/p\x3e\n\x3cp\x3e其中的 props 必须是从父组件传递到子组件，如果嵌套层级很多，props 必须逐级从保存数据的组件层层传递到使用 props 的组件当中。而 state 在使用的时候，必须通过调用 \x3ccode\x3ethis.setState()\x3c\/code\x3e 方法，在改变 state 值的同时，触发 React 组件运行的生命周期，来触发界面的更新。 \x3ccode\x3ethis.setState()\x3c\/code\x3e 方法可以传递数据、方法、回调函数。在同一次操作中，连续调用多次  \x3ccode\x3ethis.setState()\x3c\/code\x3e 方法也会造成许多难以预料的结果，仅仅通过看代码你很难判断出最后值会变成什么。\x3c\/p\x3e\n\x3cp\x3e而我们使用 React 开发界面的主要场景是在Web应用当中，不同于传统的以内容为主的网页。Web应用涉及到非常多的状态数据的改变，包括用户的交互、服务器通信、界面的动画、样式的改变等等内容。\x3c\/p\x3e\n\x3cp\x3e我们在开头也提到了，React 是一个专注于视图层的库，在数据的改变，状态管理方面，它并没有做得很好。因此，当我们的应用复杂到一定程度时，就需要引入一些其他的工具库来帮助我们解决状态管理的问题。\x3c\/p\x3e\n\x3ch4\x3e什么是状态管理\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Component(state) = View\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eComponent(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) = View\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过一个简单的公式来说明这个问题。在 React 的理念当中，组件其实就是一个方法，我们向组件方法传入数据得出要渲染的视图内容。\x3c\/p\x3e\n\x3cp\x3e这里之所以把传入的数据称为 \x3cstrong\x3e状态(state)\x3c\/strong\x3e ，是因为在一个应用当中，许多数据都是处于变化当中的，根据用户的不同操作响应发生改变（比如说在我们计数器的示例当中，点击按钮，计数器的数字就会随之改变增加）。\x3c\/p\x3e\n\x3cp\x3e也就是说，我们看到的视图，网页的内容，如果把应用状态数据不同的改变不同的时刻看作是一段动画的话，页面在某一刻显示的内容其实就是动画的某一帧。\x3c\/p\x3e\n\x3cp\x3e所以，我们在开发构建界面时，除了界面的样式和逻辑以外，如何处理状态数据就成了另外一个我们需要主要关注的问题。这一问题的解决方案，自然也就叫做状态管理了。\x3c\/p\x3e\n\x3ch4\x3e用 Redux 管理应用的状态数据\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/discountry.github.io\/react\/docs\/thinking-in-react.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 应用的开发理念\x3c\/a\x3e告诉我们，在一个应用当中，如果有两个组件需要使用同一数据，那么我们需要把这一组数据提升到它们共同的父组件当中保存；在实际开发当中，应该尽量控制有状态组件（含有 state 的组件）的数量。\x3c\/p\x3e\n\x3cp\x3e在一个Web应用当中，会涉及到显示数据的增删改查、服务器数据获取、界面切换显示内容等各种各样类型的状态数据改变。\x3c\/p\x3e\n\x3cp\x3e那么我们为什么不把所有的状态数据改变，用一种统一的方式描述；既然要控制有状态组件的数量，那么我们为什么不干脆直接把一个应用的所有状态数据存储在一个统一的地方集中管理？\x3c\/p\x3e\n\x3cp\x3e这也就是 Redux 的理念。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010641965\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010641965\x22 alt=\x22enter image description here\x22 title=\x22enter image description here\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3eAction\x3c\/h4\x3e\n\x3cp\x3eAction 就是我们上述的，用统一的形式，描述所有改变应用状态数据的操作的方法。说白了，它其实就是一个带有 \x3ccode\x3etype\x3c\/code\x3e 属性的 Javascript 对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  type: \x27INCREMENT\x27,\n  value: 1\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27INCREMENT\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例如在我们的计数器当中，点击按钮数字增加1的操作可以用上述格式内容的对象来描述表示。Redux 对 Action 的要求并不是非常严格，你只需要保证它包含 \x3ccode\x3etype\x3c\/code\x3e 属性，其余的内容完全由你自己决定。当然如果你希望你制定的 Action 更加符合规范，可以遵循 \x3ca href=\x22https:\/\/github.com\/acdlite\/flux-standard-action\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFlux Standard Action\x3c\/a\x3e 标准。\x3c\/p\x3e\n\x3ch4\x3eReducer\x3c\/h4\x3e\n\x3cp\x3eReducer 则是 Redux 的设计理念当中最核心的方法，它接受当前的状态数据以及触发的 Action 作为参数，根据内部 \x3ccode\x3eswitch\x3c\/code\x3e 结构的逻辑判断，返回一个新的状态数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(previousState, action) =\x3e newState\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e(previousState, action) =\x26gt; newState\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例如在我们的计数器当中，可以抽象编写出这样一个 Reducer 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function counter(state = 0, action) {\n    switch (action.type) {\n      case \x27INCREMENT\x27:\n        return state \x2b action.value\n      default:\n        return state\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecounter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, action\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (action.type) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27INCREMENT\x27\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e state \x2b action.value\n      \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e state\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以看到 counter 函数接受 state 和 action 两个参数，返回值则是经过一个 switch 结构判断的新的 state 数据。这样结构的函数也就是我们在使用 Redux 时编写的 Reducer 方法。\x3c\/p\x3e\n\x3cp\x3e这是 Redux 理念当中最核心的一个部分，它决定了一个应用当中的状态数据在不同的 Action 被触发时具体会如何改变。\x3c\/p\x3e\n\x3cp\x3e有关 Reducer 的更详细解释，可以参阅我之前发表的 \x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/25863768\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux 中的 reducer 到底是什么，以及它为什么叫 reducer\x3c\/a\x3e 一文。\x3c\/p\x3e\n\x3ch4\x3eStore\x3c\/h4\x3e\n\x3cp\x3eStore 则是 Redux 当中我们用来存储状态数据的地方，它提供了3个主要的方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e用来获取当前状态数据的 \x3ccode\x3egetState()\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e用来触发应用 action 动作的 \x3ccode\x3edispatch(action)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e用来订阅响应事件（state改变之后进行的操作）的 \x3ccode\x3esubscribe(listener)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e而在使用 Redux 时，我们可以通过它提供的 \x3ccode\x3ecreateStore\x3c\/code\x3e 方法，直接从 reducer 函数生成对应的 store :\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { createStore } = Redux;\n\nconst store = createStore(counter);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { createStore } = Redux;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(counter);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e在 React 应用当中使用 Redux\x3c\/h4\x3e\n\x3cp\x3e我们可以直接在 React 项目当中使用 Redux:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 把之前 React 的渲染函数命名为 render\nconst render = () =\x3e {\n  \/* 传入 store.getState() 获取 Redux 当中存储的状态数据\n   * 传入 store.dispatch() 方法来执行对应 action 修改状态数据\n   *\/\n  ReactDOM.render(\x3cCounter\n              number={store.getState()}\n              onIncrement={() =\x3e store.dispatch({\n                          type: \x27INCREMENT\x27,\n                          value: 1\n                        })}\n             \/\x3e,\n             document.getElementById(\x27root\x27));\n}\n\/\/ 调用一次 render 方法进行初次渲染\nrender()\n\/\/ 使用 store.subscribe 方法订阅 render 这样每次 store.dispatch 方法触发时就会自动调用 render\nstore.subscribe(render);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把之前 React 的渲染函数命名为 render\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e render = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 传入 store.getState() 获取 Redux 当中存储的状态数据\n   * 传入 store.dispatch() 方法来执行对应 action 修改状态数据\n   *\/\x3c\/span\x3e\n  ReactDOM.render(\x26lt;Counter\n              \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e={store.getState()}\n              onIncrement={\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e store.dispatch({\n                          \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27INCREMENT\x27\x3c\/span\x3e,\n                          value: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n                        })}\n             \/\x26gt;,\n             \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e));\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用一次 render 方法进行初次渲染\x3c\/span\x3e\nrender()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用 store.subscribe 方法订阅 render 这样每次 store.dispatch 方法触发时就会自动调用 render\x3c\/span\x3e\nstore.subscribe(render);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ereact-redux\x3c\/h4\x3e\n\x3cp\x3e当然，每次 Redux 当中的状态数据改变时都强制执行 ReactDOM 的 \x3ccode\x3erender\x3c\/code\x3e 方法并不是最优选择。事实上，社区已经开发出了一个名为 react-redux 的库专门来辅助我们对 React 和 Redux 进行协同使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* Provider 充当为整个 React 应用传入 Redux 当中 store 的容器组件\n * connect 用来为需要使用 store 的组件提供相应的状态数据或 dispatch 方法\n *\/\nconst { Provider, connect } = ReactRedux;\n\/* 我们通过 mapStateToProps 来将 Redux 当中的状态数据映射到 React 相应的 props 当中 *\/\nconst mapStateToProps = state =\x3e ({\n  number: state\n});\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n  }\n  \n  handleClick() {\n    \/\/ 在这里调用传入组件的 dispatch 方法\n    this.props.dispatch({\n      type: \x27INCREMENT\x27,\n      value: 1\n    });\n  }\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cTitle \/\x3e\n        \x3cNumber number={this.props.number} \/\x3e\n        \x3cButton onClick={() =\x3e this.handleClick()} \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\/* 我们需要通过 connect 方法来包装一下 React 的 Counter 组件，使其获取到 Redux 的 store 当中的方法和数据 *\/\nCounter = connect(mapStateToProps)(Counter);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* Provider 充当为整个 React 应用传入 Redux 当中 store 的容器组件\n * connect 用来为需要使用 store 的组件提供相应的状态数据或 dispatch 方法\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Provider, connect } = ReactRedux;\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 我们通过 mapStateToProps 来将 Redux 当中的状态数据映射到 React 相应的 props 当中 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3enumber\x3c\/span\x3e: state\n});\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n  }\n  \n  handleClick() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在这里调用传入组件的 dispatch 方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dispatch({\n      \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27INCREMENT\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    });\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;Title \/\x26gt;\n        \x26lt;Number number={this.props.number} \/\x26gt;\n        \x26lt;Button onClick={() =\x26gt; this.handleClick()} \/\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\/* 我们需要通过 connect 方法来包装一下 React 的 Counter 组件，使其获取到 Redux 的 store 当中的方法和数据 *\/\nCounter = connect(mapStateToProps)(Counter);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ereact-router\x3c\/h3\x3e\n\x3ch4\x3ereact-router 是什么？\x3c\/h4\x3e\n\x3cp\x3ereact-router 是 React 生态圈当中前端路由功能的实现。它最大的特点是可以不用添加额外的路由配置文件，像使用所有其他 React 组件的方式一样，只需要引入几个组件就可以轻松为你的 React 应用添加前端路由的功能。\x3c\/p\x3e\n\x3ch4\x3e什么是前端路由？\x3c\/h4\x3e\n\x3cp\x3e我们都知道，在传统的网站当用，一个 URL 就对应着某个特定的页面。当我们在浏览器地址栏当中输入这个 URL 的时候，浏览器就会从网站的服务器请求该页面，获取相应的内容。\x3c\/p\x3e\n\x3cp\x3e而在Web应用的开发当中，我们可以通过操纵浏览器暴露给我们的 history 接口以及异步服务器数据请求等方式，在前端就实现路由的切换，而不需要每次都让服务器后端解析 URL 路由请求再返回内容。\x3c\/p\x3e\n\x3cp\x3e使用前端路由可以很大程度上提升Web应用，尤其是单页面应用的使用体验。\x3c\/p\x3e\n\x3ch4\x3e在 React 应用当中使用 react-router\x3c\/h4\x3e\n\x3cp\x3ereact-router 的使用非常简单，它目前已经发行到了 v4 版本，而之前的3个版本在网络上也能找到非常多的应用。在这里我们仅拿最新的版本作为示例。在 react-router@4 版本当中，专门为Web端提供了高度封装好的 react-router-dom 库，这下我们几乎不需要任何的配置就可以直接使用前端路由功能了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 这里引入的3个方法全部都是封装好的 React 组件，使用方法和其他 React 组件几乎没有任何差别 *\/\nconst { HashRouter, Route, Redirect } = ReactRouterDOM;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 这里引入的3个方法全部都是封装好的 React 组件，使用方法和其他 React 组件几乎没有任何差别 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { HashRouter, Route, Redirect } = ReactRouterDOM;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eHashRouter\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eHashRouter\x3c\/code\x3e 为我们的应用提供了 hash 形式（也就是带#的路由）路由的功能支持。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\/* 在通常情况下，我们不需要为 HashRouter 进行任何设置，直接引入使用即可。 *\/}\n\x3cHashRouter\x3e\n  \x3cApp\/\x3e\n\x3c\/HashRouter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22xml\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-tag\x22\x3e{\/* 在通常情况下，我们不需要为 \x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e 进行任何设置，直接引入使用即可。 *\/}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eApp\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e主要到在 react-router 提供的所有类型的 \x3ccode\x3eRouter\x3c\/code\x3e 组件当中，第一级的子组件有且只能有一个。因此我们在使用的时候，通常在我们应用组件的最外层包裹上一个 \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e 标签：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cHashRouter\x3e\n  \x3cdiv\x3e\n    ...\n  \x3c\/div\x3e\n\x3c\/HashRouter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    ...\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里为了方便在线演示，所以我们使用了 \x3ccode\x3eHashRouter\x3c\/code\x3e 组件，在实际的开发当中，更经常使用的是 \x3ccode\x3eBrowserRouter\x3c\/code\x3e 组件，它可以为我们提供不带 \x3ccode\x3e#\x3c\/code\x3e 的前端路由支持，更加友好。\x3c\/p\x3e\n\x3ch4\x3eRoute\x3c\/h4\x3e\n\x3cp\x3e前端路由的主要功能就是通过判断不同的浏览器地址显示不同的内容，那么具体某个路由地址要怎么展示某个组件呢？\x3c\/p\x3e\n\x3cp\x3e这就是 \x3ccode\x3eRoute\x3c\/code\x3e 组件为我们提供的功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cHashRouter\x3e\n    \x3cdiv\x3e\n      \x3cRoute path=\x27\/:title?\x27 component={App} \/\x3e\n    \x3c\/div\x3e\n\x3c\/HashRouter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/:title?\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{App}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中的 path 属性用来设置匹配的目标路由地址，路由地址可以是固定的字符串，例如 home\/about\/user 之类的，也可以像我们示例中一样，以冒号开头将路由的地址作为参数，之后我们可以在组件当中获取到对应的路由参数（以 \x3ccode\x3e?\x3c\/code\x3e 结尾则表示这一参数是可选的）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Title = props =\x3e \x3ch1\x3e{props.title}\x3c\/h1\x3e;\n\nconst App = ({ match }) =\x3e (\n  \x3cProvider store={store}\x3e\n    \x3cCounter title={match.params.title} \/\x3e\n  \x3c\/Provider\x3e\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22xml\x22\x3econst Title = props =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{props.title}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e;\n\nconst App = (\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ match }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e) =\x26gt; (\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e=\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{store}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e=\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{match.params.title}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eProvider\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的 \x3ccode\x3ematch.params.title\x3c\/code\x3e 也就是我们路由参数当中对应的值了。\x3c\/p\x3e\n\x3ch4\x3eLink\x3c\/h4\x3e\n\x3cp\x3e有了前端路由的内容，我们还需要相应的前端路由的导航。前端路由导航的主要功能是实现浏览器地址栏 URL 的切换，并触发Web应用展示对应的内容，而不是像原生的 HTML 超链接试图向服务器发起对应 URL 的请求。\x3c\/p\x3e\n\x3cp\x3ereact-router 同样为我们提供了现成的 \x3ccode\x3eLink\x3c\/code\x3e 导航组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cHashRouter\x3e\n    \x3cdiv\x3e\n      \x3cul\x3e\n        \x3cli\x3e\x3cLink to=\x27\/react\x27\x3ereact\x3c\/Link\x3e\x3c\/li\x3e\n        \x3cli\x3e\x3cLink to=\x27\/redux\x27\x3eredux\x3c\/Link\x3e\x3c\/li\x3e\n        \x3cli\x3e\x3cLink to=\x27\/react-router\x27\x3ereact-router\x3c\/Link\x3e\x3c\/li\x3e\n      \x3c\/ul\x3e\n      \x3cRoute path=\x27\/:title?\x27 component={App} \/\x3e\n    \x3c\/div\x3e\n\x3c\/HashRouter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eto\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/react\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3ereact\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eto\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/redux\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eredux\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eto\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/react-router\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3ereact-router\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eLink\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/:title?\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{App}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eHashRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e备注\x3c\/h3\x3e\n\x3ch4\x3e使用到所有库的链接\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/facebook\/react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/reactjs\/redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eredux\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/ReactTraining\/react-router\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-router\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e使用库的方式\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e直接在浏览器中使用\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e为了方便我们在线演示，更快地直接上手，在本文的示例当中，我们均采用了直接在浏览器当中使用这些库的方法。在 Codepen 示例当中，我已经事先引入了所有库的 CDN 文件，这些库都会向页面暴露一个全局的对象，然后我们可以通过解构赋值的方式，获取到对象当中我们要使用的方法，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Component } = React;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Component } = React;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你是在本地进行练习，也可以通过 \x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e 标签引入相应库的 CDN 文件，之后通过相同的方式进行调用。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eP.S. 如果你使用最新版的 Chrome 进行调试，这些 ES6 的新特性都可以直接在浏览器当中运行，无需编译。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e通过 npm 来使用\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在正式的开发项目当中，我们会使用 npm 来管理安装各个库，之后通过 \x3ccode\x3eimport\x3c\/code\x3e的方式来调用：\x3c\/p\x3e\n\x3cp\x3e首先安装：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install react react-dom --save\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3enpm install react react-dom --save\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e分享源码完整示例\x3c\/h3\x3e\n\x3cp\x3e本文所有代码完整示例可以在 \x3ca href=\x22https:\/\/codepen.io\/collection\/DZBxNm\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitChat React Examples\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22collection\/DZBxNm\/\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e 在线查看调试。包含：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/codepen.io\/discountry\/pen\/XgwwNq\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 版计数器\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22discountry\/pen\/XgwwNq\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/codepen.io\/discountry\/pen\/mwYYpe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact\x2bRedux 版计数器\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22discountry\/pen\/mwYYpe\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/codepen.io\/discountry\/pen\/GEaazj\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact\x2bRedux\x2breact-redux 版计数器\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22discountry\/pen\/GEaazj\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/codepen.io\/discountry\/pen\/mwYZmw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact\x2bRedux\x2breact-redux\x2breact-router 版计数器\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22discountry\/pen\/mwYZmw\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e学习资源推荐\x3c\/h3\x3e\n\x3ch4\x3e文档\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/discountry.github.io\/react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 中文文档\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/cn.redux.js.org\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux 中文文档\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e知乎专栏\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/reactjs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从零学习React技术栈\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/leanreact\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLeanReact\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/purerender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epure render\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e编辑器插件\x3c\/h4\x3e\n\x3cul\x3e\x3cli\x3e\x3ca href=\x22https:\/\/marketplace.visualstudio.com\/items?itemName=discountry.react-redux-react-router-snippets\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVS Code React 技术栈代码补全插件\x3c\/a\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTSrW?w=640\x26amp;h=640\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTSrW?w=640\x26amp;h=640\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>GitChat · 前端 | 浅尝初试 React 技术栈</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010641959">https://segmentfault.com/a/1190000010641959</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6bxy07jr4ue/" target="_blank">https://alili.tech/archive/6bxy07jr4ue/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>