<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="自动化接口用例从 1 到 1000 过程中的实践和思考"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>自动化接口用例从 1 到 1000 过程中的实践和思考 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6cvhgnzn5eg/",
				"appid": "1613049289050283", 
				"title": "自动化接口用例从 1 到 1000 过程中的实践和思考 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-02T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/u5wsgzzzoh/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zi1qo3hu9ns/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&text=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&text=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&title=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&is_video=false&description=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&title=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&title=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&title=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6cvhgnzn5eg%2f&title=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%8e%a5%e5%8f%a3%e7%94%a8%e4%be%8b%e4%bb%8e%201%20%e5%88%b0%201000%20%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%80%9d%e8%80%83"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">自动化接口用例从 1 到 1000 过程中的实践和思考</h1><div class="meta"><div class="postdate"><time datetime="2018-12-02" itemprop="datePublished">2018-12-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e引言\x3c\/h2\x3e\n\x3cp\x3e当一个新人刚加入公司的时候，我们通常告诉新人怎么去写一个自动化用例：从工程配置到如何添加接口、如何使用断言，最后到如何将一个用例运行起来。  \x3c\/p\x3e\n\x3cp\x3e而在实际工作和业务场景中，我们常常面临着需要编写和组织一堆用例的情况：我们需要编写一个业务下的一系列的自动化接口用例，再把用例放到持续集成中不断运行。面临的问题比单纯让一个用例运行起来复杂的多。  \x3c\/p\x3e\n\x3cp\x3e本人加入有赞不到一年，从写下第 \x3cstrong\x3e1\x3c\/strong\x3e 个 case 开始，持续编写和运行了 \x3cstrong\x3e1000\x3c\/strong\x3e 多个 case ，在这过程中有了一些思考。在本文中，和大家探论下如何编写大量自动化接口用例以及保持结果稳定。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e一、执行效率\x3c\/h2\x3e\n\x3cp\x3e目前使用的测试框架是基于 spring ，被测接口是 dubbo 的服务。 dubbo 的架构如图（源自官网）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLSpm?w=450\x26amp;h=300\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLSpm?w=450\x26amp;h=300\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e服务使用方的初始化需要经历以下这几个步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e监听注册中心\x3c\/li\x3e\n\x3cli\x3e连接服务提供端\x3c\/li\x3e\n\x3cli\x3e创建消费端服务代理\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e本地调试用例时，发现速度非常慢，运行一个用例需要 30s，而实际执行用例逻辑的时间大概在 1s 左右，主要时耗在服务消费者的初始化阶段。  \x3c\/p\x3e\n\x3cp\x3e测试工程中，各服务的 test 类继承了同一个基类，基类里面做了各服务的初始化的步骤。在对接的服务数目较少时，需要初始化的对象较少，对用例运行的影响并不大，但随着业务的增多，服务数目也增多，导致跑 A 服务接口的用例时把大量未用到的 B 服务、C 服务也一起初始化了，导致整体时耗大大增加。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e解决办法\x3c\/strong\x3e：在运行用例时只初始化需要的服务使用方，减少不必要的初始化开销。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e二、用例编写和维护\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e一个用例示例\x3c\/h3\x3e\n\x3cp\x3e以一个简单的业务场景为例：商家可以在后台创建会员卡给店铺的会员领取，商家可以对会员卡进行更新操作，这里需要有一个自动化用例去覆盖这个场景。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV9XU6?w=1600\x26amp;h=1306\x22 src=\x22https:\/\/static.alili.tech\/img\/bV9XU6?w=1600\x26amp;h=1306\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e用例编写的基本步骤为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3estep 1 :准备数据构造新建会员卡和更新会员卡的对象\x3c\/li\x3e\n\x3cli\x3estep 2 :执行创建会员卡\x3c\/li\x3e\n\x3cli\x3estep 3 :执行更新会员卡\x3c\/li\x3e\n\x3cli\x3estep 4 :检查更新结果\x3c\/li\x3e\n\x3cli\x3estep 5 :清理创建的会员卡\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e转换成代码为:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    @Test\n    public void testUpdate() {\n        try {\n            \/*\n             * 创建新建和更新的卡对象\n             *\/\n            CardCreateDescriptionDTO descCreate = new CardCreateDescriptionDTO();\n            descCreate.setName(xxxx);\n            \/\/此处省略若干参数设置过程....\n            \n            CardUpdateDescriptionDTO descUpdate = new CardUpdateDescriptionDTO();\n            descUpdate.setName(xxxxx);\n            \/\/此处省略若干参数设置过程....\n            \/*\n             * 新建会员卡\n             *\/\n            cardAlias = cardService.create((int) kdtId, descCreate,operator).getCardAlias();\n             \/*\n             * 更新会员卡\n             *\/\n            cardService.update(kdtId, cardAlias, descUpdate, operator);\n            \/*\n             * 校验编辑是否生效\n             *\/\n            CardDTO cardDTO = cardService.getByCardAlias(cardAlias);\n            Assert.assertEquals(cardDTO.getName(), xxxx, \x26quot;会员卡更新失败\x26quot;);\n            \/\/此处省略若干参数校验过程....\n        } catch (Exception e) {\n            Assert.assertNull(e);\n        } finally {\n            try {\n                if(cardAlias!=null) {\n                    cardService.deleteByCardAlias((int) kdtId, cardAlias, operator);\n                }\n            } catch (Exception e) {\n                Assert.assertNull(e, e.getMessage());\n            }\n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e    @\x3cspan class=\x22hljs-function\x22\x3eTest\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etestUpdate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*\n             * 创建新建和更新的卡对象\n             *\/\x3c\/span\x3e\n            CardCreateDescriptionDTO descCreate = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e CardCreateDescriptionDTO();\n            descCreate.setName(xxxx);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处省略若干参数设置过程....\x3c\/span\x3e\n            \n            CardUpdateDescriptionDTO descUpdate = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e CardUpdateDescriptionDTO();\n            descUpdate.setName(xxxxx);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处省略若干参数设置过程....\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*\n             * 新建会员卡\n             *\/\x3c\/span\x3e\n            cardAlias = cardService.create((\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e) kdtId, descCreate,\x3cspan class=\x22hljs-keyword\x22\x3eoperator\x3c\/span\x3e).getCardAlias();\n             \x3cspan class=\x22hljs-comment\x22\x3e\/*\n             * 更新会员卡\n             *\/\x3c\/span\x3e\n            cardService.update(kdtId, cardAlias, descUpdate, \x3cspan class=\x22hljs-keyword\x22\x3eoperator\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*\n             * 校验编辑是否生效\n             *\/\x3c\/span\x3e\n            CardDTO cardDTO = cardService.getByCardAlias(cardAlias);\n            Assert.assertEquals(cardDTO.getName(), xxxx, \x3cspan class=\x22hljs-string\x22\x3e\x22会员卡更新失败\x22\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处省略若干参数校验过程....\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (Exception e) {\n            Assert.assertNull(e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(cardAlias!=\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                    cardService.deleteByCardAlias((\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e) kdtId, cardAlias, \x3cspan class=\x22hljs-keyword\x22\x3eoperator\x3c\/span\x3e);\n                }\n            } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (Exception e) {\n                Assert.assertNull(e, e.getMessage());\n            }\n        }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按照预期的步骤去写这个 case ，可以满足要求，但是如果需要扩展一下，编写诸如：更新某种类型的会员卡、只更新会员卡的有效期这样用例的时候，就会觉得按这个模式写 case 实在太长太啰嗦了，痛点在以下几个地方：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e数据准备比较麻烦，需要逐一设值\x3c\/li\x3e\n\x3cli\x3e数据检查部分逐字段检查，心好累\x3c\/li\x3e\n\x3cli\x3e每个创建相关的用例都需要清理资源，每次都需要做一次，太重复了\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e用例本身关注的是更新这个操作，却花了太多时间和精力在其他地方，很多是重复劳动。代码编写里有一个重要原则，\x3cstrong\x3eDRY（Don\x27t Repeat Yourself）\x3c\/strong\x3e，即所有重复的地方都可以考虑抽象提炼出来。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e三段式用例\x3c\/h3\x3e\n\x3cp\x3e可以将大部分用例的执行过程简化为三个部分：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e数据准备\x3c\/li\x3e\n\x3cli\x3e执行操作\x3c\/li\x3e\n\x3cli\x3e结果检查\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e用简单的三个部分来完成上述用例的改写：  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e数据准备\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    @DataProvider(name=\x26quot;dataTestUpdate\x26quot;)\n    public Object[][] dataTestUpdate() {\n        return new Object[][]{    \n{cardFactory.genRuleNoCreate(...),cardFactory.genRuleNoUpdate(...)},\n{cardFactory.genRuleCreate(...),cardFactory.genRuleUpdate(...)},\n{cardFactory.genPayCreate(...),cardFactory.genPayUpdate(...)}\n       };\n\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-variable\x22\x3e@DataProvider\x3c\/span\x3e(name=\x3cspan class=\x22hljs-string\x22\x3e\x22dataTestUpdate\x22\x3c\/span\x3e)\n    public Object[][] dataTestUpdate() {\n        \x3cspan class=\x22hljs-selector-tag\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eObject\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[]\x3c\/span\x3e{    \n{\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genRuleNoCreate\x3c\/span\x3e(...),\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genRuleNoUpdate\x3c\/span\x3e(...)},\n{\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genRuleCreate\x3c\/span\x3e(...),\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genRuleUpdate\x3c\/span\x3e(...)},\n{\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genPayCreate\x3c\/span\x3e(...),\x3cspan class=\x22hljs-selector-tag\x22\x3ecardFactory\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.genPayUpdate\x3c\/span\x3e(...)}\n       };\n\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e执行操作\x2b结果检查\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Test(dataProvider = \x26quot;dataTestUpdate\x26quot;)                 \n   public void testUpdate(CardCreateDescriptionDTO desc,CardUpdateDescriptionDTO updateDesc){                        \n       try {    \n           \/*\n           * 执行操作：创建\x2b更新\n           *\/                            \n           \/\/创建会员卡                                                     \n           CardDTO cardBaseDTO = createCard(kdtId,desc,operatorDTO);        \n           cardAlias=cardBaseDTO.getCardAlias();                                          \n           recycleCardAlias.add(cardAlias); \/\/将卡的标识放入垃圾桶后续进行回收                                                    \n           CardDTO ori = getCard(kdtId,cardAlias);     \n          \/\/更新会员卡                            \n          updateCard(kdtId,cardAlias,updateDesc,operatorDTO);                                                                                            \n           CardDTO updated = getCard(kdtId,cardAlias);    \n           \/*\n           * 结果检查\n           *\/                          \n      checkUpdateCardResult(ori,updated,updateDesc,kdtId);                                               \n                                                                                                 \n       } catch (Exception e) {                                                                   \n           Assert.assertNull(e);                                                                 \n       }                                                                                         \n                                                                                                 \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs axapta\x22\x3e\x3ccode\x3eTest(dataProvider = \x3cspan class=\x22hljs-string\x22\x3e\x22dataTestUpdate\x22\x3c\/span\x3e)                 \n   \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e testUpdate(CardCreateDescriptionDTO \x3cspan class=\x22hljs-keyword\x22\x3edesc\x3c\/span\x3e,CardUpdateDescriptionDTO updateDesc){                        \n       \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {    \n           \x3cspan class=\x22hljs-comment\x22\x3e\/*\n           * 执行操作：创建\x2b更新\n           *\/\x3c\/span\x3e                            \n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建会员卡                                                     \x3c\/span\x3e\n           CardDTO cardBaseDTO = createCard(kdtId,\x3cspan class=\x22hljs-keyword\x22\x3edesc\x3c\/span\x3e,operatorDTO);        \n           cardAlias=cardBaseDTO.getCardAlias();                                          \n           recycleCardAlias.add(cardAlias); \x3cspan class=\x22hljs-comment\x22\x3e\/\/将卡的标识放入垃圾桶后续进行回收                                                    \x3c\/span\x3e\n           CardDTO ori = getCard(kdtId,cardAlias);     \n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新会员卡                            \x3c\/span\x3e\n          updateCard(kdtId,cardAlias,updateDesc,operatorDTO);                                                                                            \n           CardDTO updated = getCard(kdtId,cardAlias);    \n           \x3cspan class=\x22hljs-comment\x22\x3e\/*\n           * 结果检查\n           *\/\x3c\/span\x3e                          \n      checkUpdateCardResult(ori,updated,updateDesc,kdtId);                                               \n                                                                                                 \n       } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (Exception e) {                                                                   \n           Assert.assertNull(e);                                                                 \n       }                                                                                         \n                                                                                                 \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中可行的优化点将在下面娓娓道来。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e测试数据的优化\x3c\/h3\x3e\n\x3cp\x3e在这个用例中，数据准备的部分使用了 \x3ccode\x3edataProvider\x3c\/code\x3e 来复用执行过程，这样不同参数但同一过程的数据可以放在一个 case 里进行执行和维护。\x3c\/p\x3e\n\x3cp\x3e数据生成使用了工厂方法 \x3ccode\x3eCardFactory\x3c\/code\x3e ，好处是简化了参数，避免了大量 set 操作（本身包装的就是 set 方法）;另一方面,根据实际的业务场景，可以考虑提供多个粒度的构造方法，比如以下两个构造方法需要提供的参数差别很大：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e第一个主要用在验证创建接口的场景，检查各个传入的参数是否生效。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    public CardCreateDescriptionDTO genRuleCreate(Boolean isPost,Integer discount,Long rate,Long pointsDef,\n                        String couponIds, Long num, Long growth,Long termToCardId,Long amount,Long points,Long trade){\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e CardCreateDescriptionDTO genRuleCreate(\x3cspan class=\x22hljs-keyword\x22\x3eBoolean\x3c\/span\x3e isPost,Integer discount,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e rate,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e pointsDef,\n                        String couponIds, \x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e num, \x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e growth,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e termToCardId,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e amount,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e points,\x3cspan class=\x22hljs-keyword\x22\x3eLong\x3c\/span\x3e trade){\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e第二个用在如删除的场景，所以只需要一个创建好的会员卡对象，并不是很关注创建的内容是什么。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    public CardCreateDescriptionDTO genRuleSimpleCreate(String name){\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e CardCreateDescriptionDTO genRuleSimpleCreate(\x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e{\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的优化过的用例中，能够执行更新操作的前置条件是需要有一个已经创建的会员卡，在实际用例编写的时候通过直接创建一个会员卡，然后执行更新完成后再回收删除这张会员卡来满足这个条件。另一种提供满足操作所需前置数据的方式是预置数据（预先生成数据）。\x3c\/p\x3e\n\x3cp\x3e以下情况可以考虑预置数据的方式：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e提高用例稳定性，解依赖，加快执行速度\x3c\/li\x3e\n\x3cli\x3e需要对特定的类型、状态的对象进行查询\x3c\/li\x3e\n\x3cli\x3e创建或者构造比较麻烦\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e典型的场景：比如编写查询的用例时预先创建满足条件的对象供查询用例使用。\x3c\/p\x3e\n\x3cp\x3e谈到预置数据，不得不谈的一个问题是数据管理。在编写用例的时候，\x3cem\x3e\x22我们往往需要一个____的资源\x22\x3c\/em\x3e，框框里面的即是对数据的描述和要求，比如我需要一个全新的账号，一个支付过的订单号，一张免费的会员卡，来完成我们的用例。所以需要对数据进行标记而不是简单硬编码的方式在用例中使用。 \x3c\/p\x3e\n\x3cp\x3e如：通过特定名字的变量名和数据进行关联。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/**只做查询卡，不做领卡删卡*\/\n    public Long queryCardUid = DataMocker.MOCK_YZUID.get(1);\n    \/**用户卡类操作，领卡删卡*\/\n    public Long takeCardUid = DataMocker.MOCK_YZUID.get(6);\n    \/**退款用*\/\n    public Long refundCardUid =DataMocker.MOCK_YZUID.get(4);\n \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/**只做查询卡，不做领卡删卡*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e Long queryCardUid = DataMocker.MOCK_YZUID.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**用户卡类操作，领卡删卡*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e Long takeCardUid = DataMocker.MOCK_YZUID.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**退款用*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e Long refundCardUid =DataMocker.MOCK_YZUID.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对数据进行标记后，会发现有一部分数据是用来验证写操作（如创建、更新），有一部分数据是查询使用。如果数据又要被写操作的 case 使用，又要被读操作的 case 使用，那么写操作的问题和异常就会影响读操作 case 的执行结果。所以，在代码工程中，可以进行约定，将读写用到的资源进行分离来降低数据的耦合：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e查询 case 用的账号不做更改对象的操作\x3c\/li\x3e\n\x3cli\x3e查询 case 用的对象不做修改、删除的操作\x3c\/li\x3e\n\x3cli\x3e验证增、删、改行为的资源使用特定账号，且资源最后做回收删除处理(因为资源总数有限)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后，用例执行完成后需要清理资源。这里的清理资源采用的是一个全局的 list 的方式保存需要清理的资源信息，在用例执行过程中往里增加数据:（\x3ccode\x3erecycleCardAlias.add(cardBaseDTO.getCardAlias());\x3c\/code\x3e）,\x3cbr\x3e然后用对应的方法取其中的数据进行删除，类似垃圾桶。与原有执行完就执行清理动作相比，使用垃圾桶更加灵活，可以选择控制下清理频率。\x3c\/p\x3e\n\x3cp\x3e比如每次在 \x3ccode\x3eAfterMethod\x3c\/code\x3e 或 \x3ccode\x3eAfterClass\x3c\/code\x3e 中去清理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/统一回收\n    @AfterMethod\n    public void tearDownMethod() {\n\n        for(int i =0;i\x3crecycleCardAlias.size();\x2b\x2bi) {\n            try {\n                deleteCard(kdtId, recycleCardAlias.get(i), cardOperatorDTO);\n            } catch (Exception e) {\n                logger.error(\x26quot;clear card fail: \x26quot; \x2b recycleCardAlias.get(i));\n            }\n        }\n        recycleCardAlias.clear();\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/统一回收\x3c\/span\x3e\n    @AfterMethod\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e tearDownMethod() {\n\n        \x3cspan class=\x22hljs-built_in\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e i =\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i\x26lt;recycleCardAlias.\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e();\x2b\x2bi) {\n            \x3cspan class=\x22hljs-built_in\x22\x3etry\x3c\/span\x3e {\n                deleteCard(kdtId, recycleCardAlias.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(i), cardOperatorDTO);\n            } \x3cspan class=\x22hljs-built_in\x22\x3ecatch\x3c\/span\x3e (Exception e) {\n                logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x22clear card fail: \x22\x3c\/span\x3e \x2b recycleCardAlias.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(i));\n            }\n        }\n        recycleCardAlias.\x3cspan class=\x22hljs-built_in\x22\x3eclear\x3c\/span\x3e();\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e对方法的适度封装\x3c\/h3\x3e\n\x3cp\x3e在实际编写用例的时候，有两个地方可以考虑进行方法封装，从来简化调用，方便维护：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e封装基本操作。如果删除操作依赖创建操作，查询操作依赖创建操作，那么创建操作可以看作是个基本操作，可以对创建操作包装一下，将注意力关注于实际需要执行和验证的地方。可以封装的东西很多，有参数封装、异常处理的封装、一些轮训、重新逻辑的封装。\x3ccode\x3ecreateCard()\x3c\/code\x3e、\x3ccode\x3egetCard()\x3c\/code\x3e、\x3ccode\x3edeleteCard\x3c\/code\x3e方法就是将接口、参数组装、检查等封装好的方法。\x3c\/li\x3e\n\x3cli\x3e封装检查方法。上述用例中的检查采用了一个检查方法代替了以往的多个assert：\x3cbr\x3e\x3ccode\x3echeckUpdateCardResult(ori,updated,updateDesc,kdtId);\x3c\/code\x3e ，在方法里包装了一些关键字段的比较，包括两个对象之间成员是否一致的比较。所有的更新操作的结果都需要满足：有变更的字段值变成新的值，未发生变更的值和原有一致。该方法实现了这种检查逻辑，所以写更新操作用例的同学不需要关注如何校验，而是关心如何更新，因为检查逻辑是现成的、通用的。将来检查逻辑发生变更，也只需要维护这一个方法即可。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e稳定性\x3c\/h2\x3e\n\x3cp\x3e当大批量用例进行运行时，用例集的失败率会变得较高，几个微小的瑕疵都会造成用例的失败，此时我们需要更加关注用例的稳定性。一些实践中比较好的措施和方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e减少外部依赖。如果执行过程需要依赖其他系统的接口的话，那么其他系统发生了变更或故障就会影响自身用例的进行。可以考虑通过预先生成的数据来替代调用外部接口生成数据在用例中使用。\x3c\/li\x3e\n\x3cli\x3e预置数据代替创建过程。由于操作越多稳定性越低，使用预置数据而不是实时生成它，速度更快，稳定性更高。\x3c\/li\x3e\n\x3cli\x3e使用不同账号等进行隔离。通过隔离，用例执行失败的脏数据就不会影响其他用例。\x3c\/li\x3e\n\x3cli\x3e调优：超时、等待时间。线上超时时间设置的比较短，测试环境的机器配置不如线上，需要适时调大超时和等待时间来保证接口调用不会超时。\x3c\/li\x3e\n\x3cli\x3e防御式编程。编写测试代码时不能假设数据已存在或者没有脏数据残留，所以预先的判断和清理很重要，比如检查到数据缺失就实时修复、用例运行之前考虑清除临时数据。\x3c\/li\x3e\n\x3cli\x3e定位并解决不稳定的问题。有时候偶现用例失败，可以考虑给被测应用增加日志，同时持续多次运行用例多次（如 testNg 里增加\x3ccode\x3ethreadPoolSize=1\x3c\/code\x3e, \x3ccode\x3einvocationCount=50\x3c\/code\x3e）来复现问题，最终解决问题。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e对于大规模用例的编写、组织和运行的问题，文中从三个方面给出了有赞测试的实践和思考：精简初始化来提高执行速度、优化用例编写降低编写和维护成本、多种方式提高用例稳定性，希望能给大家一些启发。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV50Mk?w=640\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/bV50Mk?w=640\x26amp;h=400\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>自动化接口用例从 1 到 1000 过程中的实践和思考</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014729467">https://segmentfault.com/a/1190000014729467</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6cvhgnzn5eg/" target="_blank">https://alili.tech/archive/6cvhgnzn5eg/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>