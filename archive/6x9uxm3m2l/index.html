<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 与 异步编程"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 与 异步编程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6x9uxm3m2l/",
				"appid": "1613049289050283", 
				"title": "JavaScript 与 异步编程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-30T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0lylrmvx75zb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/sg4mo0vwjr/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&text=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&text=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&title=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&is_video=false&description=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&title=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&title=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&title=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6x9uxm3m2l%2f&title=JavaScript%20%e4%b8%8e%20%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 与 异步编程</h1><div class="meta"><div class="postdate"><time datetime="2018-12-30" itemprop="datePublished">2018-12-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e什么是异步（Asynchrony）\x3c\/h2\x3e\n\x3cp\x3e按照\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Asynchrony_(computer_programming%29\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e维基百科\x3c\/a\x3e上的解释：独立于主控制流之外发生的事件就叫做异步。比如说有一段顺序执行的代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void function main() {\n  fA();\n  fB();\n}();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  fA();\n  fB();\n}();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3efA =\x26gt; fB 是顺序执行的，永远都是 \x3cem\x3efA\x3c\/em\x3e 在 \x3cem\x3efB\x3c\/em\x3e 的前面执行，他们就是 \x3cstrong\x3e同步\x3c\/strong\x3e 的关系。加入这时使用 \x3ccode\x3esetTimeout\x3c\/code\x3e 将 fA 延后\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void function main() {\n  setTimeout(fA, 1000);\n  fB();\n}();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  setTimeout(fA, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  fB();\n}();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时，fA 相对于 fB 就是异步的。main 函数只是声明了要在一秒后执行一次 fA，而并没有立刻执行它。这时，fA 的控制流就独立于 main 之外。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eJavaScript——天生异步的语言\x3c\/h2\x3e\n\x3cp\x3e因为 \x3ccode\x3esetTimeout\x3c\/code\x3e 的存在，至少在被 ECMA 标准化的那一刻起，JavaScript 就支持异步编程了。与其他语言的 \x3ccode\x3esleep\x3c\/code\x3e 不同，\x3ccode\x3esetTimeout\x3c\/code\x3e 是异步的——它不会阻挡当前程序继续往下执行。\x3c\/p\x3e\n\x3cp\x3e然而异步编程真正发展壮大，Ajax 的流行功不可没。Ajax 中的 A（Asynchronous）真正点到了异步的概念——这还是 IE5、IE6 的时代。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e回调函数——异步编程之痛\x3c\/h2\x3e\n\x3cp\x3e异步任务执行完毕之后怎样通知开发者呢？回调函数是最朴素的，容易想到的实现方式。于是从异步编程诞生的那一刻起，它就和回调函数绑在了一起。\x3c\/p\x3e\n\x3cp\x3e例如 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/WindowOrWorkerGlobalScope\/setTimeout\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esetTimeout\x3c\/a\x3e。这个函数会起一个定时器，在超过指定时间后执行指定的函数。比如在一秒后输出数字 1，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(() =\x3e {\n  console.log(1);\n}, 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e常规用法。如果需求有变，需要每秒输出一个数字（当然不是用 setInterval），JavaScript 的初学者可能会写出这样的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let i = 1; i \x3c 10; \x2b\x2bi) {\n  setTimeout(() =\x3e { \/\/ 错误！\n    console.log(i);\n  }, 1000);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; \x2b\x2bi) {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错误！\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n  }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行结果是等待 1 秒后，一次性输出了所有结果。因为这里的循环是同时启了 10 个定时器，每个定时器都等待 1 秒，结果当然是所有定时器在 1 秒后同时超时，触发回调函数。\x3c\/p\x3e\n\x3cp\x3e解法也简单，只需要在前一个定时器超时后再启动另一个定时器，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(() =\x3e {\n  console.log(1);\n  setTimeout(() =\x3e {\n    console.log(2);\n    setTimeout(() =\x3e {\n      console.log(3);\n      setTimeout(() =\x3e {\n        console.log(4);\n        setTimeout(() =\x3e {\n          console.log(5);\n          setTimeout(() =\x3e {\n            \/\/ ...\n          }, 1000);\n        }, 1000);\n      }, 1000)\n    }, 1000)\n  }, 1000)\n}, 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n          setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n          }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n        }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n      }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n  }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e层层嵌套，结果就是这样的漏斗形代码。可能有人想到了新标准中的 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Promise\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\x3c\/a\x3e，可以改写如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function timeout(delay) {\n  return new Promise(resolve =\x3e {\n    setTimeout(resolve, delay);\n  });\n}\n\ntimeout(1000).then(() =\x3e {\n  console.log(1);\n  return timeout(1000);\n}).then(() =\x3e {\n  console.log(2);\n  return timeout(1000);\n}).then(() =\x3e {\n  console.log(3);\n  return timeout(1000);\n}).then(() =\x3e {\n  console.log(4);\n  return timeout(1000);\n}).then(() =\x3e {\n  console.log(5);\n  return timeout(1000);\n}).then(() =\x3e {\n  \/\/ ..\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    setTimeout(resolve, delay);\n  });\n}\n\ntimeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ..\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e漏斗形代码是没了，但代码量本身并没减少多少。\x3ccode\x3ePromise\x3c\/code\x3e 并没能干掉回调函数。\x3c\/p\x3e\n\x3cp\x3e因为回调函数的存在，循环就无法使用。不能循环，那么只能考虑递归了，解法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let i = 1;\nfunction next() {\n  console.log(i);\n  if (\x2b\x2bi \x3c 10) {\n    setTimeout(next, 1000);\n  }\n}\nsetTimeout(next, 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x2b\x2bi \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) {\n    setTimeout(next, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  }\n}\nsetTimeout(next, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意虽然写法是递归，但由于 \x3ccode\x3enext\x3c\/code\x3e 函数都是由浏览器调用的，所以实际上并没有递归函数的调用栈结构。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eGenerator——JavaScript 中的半协程\x3c\/h2\x3e\n\x3cp\x3e很多语言都引入了协程来简化异步编程，JavaScript 也有类似的概念，叫做 \x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Generator_%28computer_programming%29\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGenerator\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Statements\/function\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN 上的解释\x3c\/a\x3e：Generator 是一种可以中途退出之后重入的函数。他们的函数上下文在每次重入后会被保持。简而言之，\x3ccode\x3eGenerator\x3c\/code\x3e 与普通 \x3ccode\x3eFunction\x3c\/code\x3e 最大的区别就是：\x3ccode\x3eGenerator\x3c\/code\x3e 自身保留上次调用的状态。\x3c\/p\x3e\n\x3cp\x3e举个简单的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function *gen() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nvoid function main() {\n  var iter = gen();\n  console.log(iter.next().value);\n  console.log(iter.next().value);\n  console.log(iter.next().value);\n}();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e *\x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e iter = gen();\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n}();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码的执行顺序是这样：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e请求 \x3ccode\x3egen\x3c\/code\x3e，得到一个迭代器 \x3ccode\x3eiter\x3c\/code\x3e。注意此时并未真正执行 \x3ccode\x3egen\x3c\/code\x3e 的函数体。\x3c\/li\x3e\n\x3cli\x3e调用 \x3ccode\x3eiter.next()\x3c\/code\x3e，执行 \x3ccode\x3egen\x3c\/code\x3e 的函数体。\x3c\/li\x3e\n\x3cli\x3e遇到 \x3ccode\x3eyield 1\x3c\/code\x3e，将 1 返回，\x3ccode\x3eiter.next()\x3c\/code\x3e 的返回值即为 { done: false, value: 1 }，输出 1\x3c\/li\x3e\n\x3cli\x3e调用 \x3ccode\x3eiter.next()\x3c\/code\x3e。从上次 \x3ccode\x3eyield\x3c\/code\x3e 出去的地方继续往下执行 \x3ccode\x3egen\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e遇到 \x3ccode\x3eyield 2\x3c\/code\x3e，将 2 返回，\x3ccode\x3eiter.next()\x3c\/code\x3e 的返回值即为 { done: false, value: 2 }，输出 2\x3c\/li\x3e\n\x3cli\x3e调用 \x3ccode\x3eiter.next()\x3c\/code\x3e。从上次 \x3ccode\x3eyield\x3c\/code\x3e 出去的地方继续往下执行 \x3ccode\x3egen\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e遇到 \x3ccode\x3ereturn 3\x3c\/code\x3e，将 3 返回，\x3ccode\x3ereturn\x3c\/code\x3e 表示整个函数已经执行完毕。\x3ccode\x3eiter.next()\x3c\/code\x3e 的返回值即为 { done: true, value: 3 }，输出 3\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e调用 Generator 函数只会返回一个迭代器，当用户主动调用了 \x3ccode\x3eiter.next()\x3c\/code\x3e 后，这个 Generator 函数才会真正执行。\x3c\/p\x3e\n\x3cp\x3e你可以使用 \x3ccode\x3efor ... of\x3c\/code\x3e 遍历一个 iterator，例如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (var i of gen()) {\n  console.log(i);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e gen()) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出 \x3ccode\x3e1 2\x3c\/code\x3e，最后 \x3ccode\x3ereturn 3\x3c\/code\x3e 的结果不算在内。想用 \x3ccode\x3eGenerator\x3c\/code\x3e 的各项生成一个数组也很简单，\x3ccode\x3eArray.from(gen())\x3c\/code\x3e 或直接用 \x3ccode\x3e[...gen()]\x3c\/code\x3e 即可，生成 \x3ccode\x3e[1, 2]\x3c\/code\x3e 同样不包含最后的 \x3ccode\x3ereturn 3\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eGenerator 是异步的吗\x3c\/h2\x3e\n\x3cp\x3eGenerator 也叫半协程（semicoroutine），自然与异步关系匪浅。那么 Generator 是异步的吗？\x3c\/p\x3e\n\x3cp\x3e既是也不是。前面提到，异步是相对的，例如上面的例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function *gen() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nvoid function main() {\n  var iter = gen();\n  console.log(iter.next().value);\n  console.log(iter.next().value);\n  console.log(iter.next().value);\n}();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e *\x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e iter = gen();\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iter.next().value);\n}();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以很直观的看到，gen 的方法体与 main 的方法体在交替执行，所以可以肯定的说，gen 相对于 main 是异步执行的。然而此段过程中，整个控制流都没有交回给浏览器，所以说 gen 和 main 相对于浏览器是同步执行的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e用 Generator 简化异步代码\x3c\/h2\x3e\n\x3cp\x3e回到最初的问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let i = 0; i \x3c 10; \x2b\x2bi) {\n  setTimeout(() =\x3e {\n    console.log(i);\n  }, 1000);\n  \/\/ 等待上面 setTimeout 执行完毕\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; \x2b\x2bi) {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n  }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待上面 setTimeout 执行完毕\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关键在于如何等待前面的 \x3ccode\x3esetTimeout\x3c\/code\x3e 触发回调后再执行下一轮循环。如果使用 \x3ccode\x3eGenerator\x3c\/code\x3e，我们可以考虑在 \x3ccode\x3esetTimeout\x3c\/code\x3e 后 \x3ccode\x3eyield\x3c\/code\x3e 出去（控制流返还给浏览器），然后在 \x3ccode\x3esetTimeout\x3c\/code\x3e 触发的回调函数中 \x3ccode\x3enext\x3c\/code\x3e，将控制流交还回给代码，执行下一段循环。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let iter;\n\nfunction* run() {\n  for (let i = 1; i \x3c 10; \x2b\x2bi) {\n    setTimeout(() =\x3e iter.next(), 1000);\n    yield; \/\/ 等待上面 setTimeout 执行完毕\n    console.log(i);\n  }\n}\n\niter = run();\niter.next();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e iter;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; \x2b\x2bi) {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e iter.next(), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待上面 setTimeout 执行完毕\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n  }\n}\n\niter = run();\niter.next();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码的执行顺序是这样：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e请求 \x3ccode\x3erun\x3c\/code\x3e，得到一个迭代器 \x3ccode\x3eiter\x3c\/code\x3e。注意此时并未真正执行 \x3ccode\x3erun\x3c\/code\x3e 的函数体。\x3c\/li\x3e\n\x3cli\x3e调用 \x3ccode\x3eiter.next()\x3c\/code\x3e，执行 \x3ccode\x3erun\x3c\/code\x3e 的函数体。\x3c\/li\x3e\n\x3cli\x3e循环开始，i 初始化为 1。\x3c\/li\x3e\n\x3cli\x3e执行 \x3ccode\x3esetTimeout\x3c\/code\x3e，启动一个定时器，回调函数延后 1 秒执行。\x3c\/li\x3e\n\x3cli\x3e遇到 \x3ccode\x3eyield\x3c\/code\x3e（即 \x3ccode\x3eyield undefined\x3c\/code\x3e），控制流返回到最后的 \x3ccode\x3eiter.next()\x3c\/code\x3e 之后。因为后面没有其他代码了，浏览器获得控制权，响应用户事件，执行其他异步代码等。\x3c\/li\x3e\n\x3cli\x3e1 秒后，\x3ccode\x3esetTimeout\x3c\/code\x3e 超时，执行回调函数 \x3ccode\x3e() =\x26gt; iter.next()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e调用 \x3ccode\x3eiter.next()\x3c\/code\x3e。从上次 \x3ccode\x3eyield\x3c\/code\x3e 出去的地方继续往下执行，即 \x3ccode\x3econsole.log(i)\x3c\/code\x3e，输出 i 的值。\x3c\/li\x3e\n\x3cli\x3e一次循环结束，i 自增为 2，回到第 4 步继续执行\x3c\/li\x3e\n\x3cli\x3e……\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这样即实现了类似同步 sleep 的要求。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3easync、await——用同步语法写异步代码\x3c\/h2\x3e\n\x3cp\x3e上面的代码毕竟需要手工定义迭代器变量，还要手工 \x3ccode\x3enext\x3c\/code\x3e；更重要的是与 \x3ccode\x3esetTimeout\x3c\/code\x3e 紧耦合，无法通用。\x3c\/p\x3e\n\x3cp\x3e我们知道 \x3ccode\x3ePromise\x3c\/code\x3e 是异步编程的未来。能不能把 \x3ccode\x3ePromise\x3c\/code\x3e 和 \x3ccode\x3eGenerator\x3c\/code\x3e 结合使用呢？这样考虑的结果就是 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Statements\/async_function\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3easync 函数\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e用 \x3ccode\x3easync\x3c\/code\x3e 得到代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function timeout(delay) {\n  return new Promise(resolve =\x3e {\n    setTimeout(resolve, delay);\n  });\n}\n\nasync function run() {\n  for (let i = 1; i \x3c 10; \x2b\x2bi) {\n    await timeout(1000);\n    console.log(i);\n  }\n}\nrun();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    setTimeout(resolve, delay);\n  });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; \x2b\x2bi) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\n  }\n}\nrun();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按照 \x3ca href=\x22https:\/\/docs.google.com\/document\/d\/1K38ct2dsxG_9OfmgErvFld4MPDC4Wkr8tPuqmSWu_3Y\/edit\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChrome 的设计文档\x3c\/a\x3e，\x3ccode\x3easync\x3c\/code\x3e 函数内部就是被编译为 \x3ccode\x3eGenerator\x3c\/code\x3e 执行的。\x3ccode\x3erun\x3c\/code\x3e 函数本身会返回一个 \x3ccode\x3ePromise\x3c\/code\x3e，用于使主调函数得知 \x3ccode\x3erun\x3c\/code\x3e 函数什么时候执行完毕。所以 \x3ccode\x3erun()\x3c\/code\x3e 后面也可以 \x3ccode\x3e.then(xxx)\x3c\/code\x3e，甚至直接 \x3ccode\x3eawait run()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e注意有时候我们的确需要几个异步事件并行执行（比如调用两个接口，等两个接口都返回后执行后续代码），这时就不要过度使用 \x3ccode\x3eawait\x3c\/code\x3e，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const a = await queryA(); \/\/ 等待 queryA 执行完毕后\nconst b = await queryB(); \/\/ 执行 queryB\ndoSomething(a, b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e queryA(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待 queryA 执行完毕后\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e queryB(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行 queryB\x3c\/span\x3e\ndoSomething(a, b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时 \x3ccode\x3equeryA\x3c\/code\x3e 和 \x3ccode\x3equeryB\x3c\/code\x3e 就是串行执行的。可以略作修改：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const promiseA = queryA(); \/\/ 执行 queryA\nconst b = await queryB(); \/\/ 执行 queryB 并等待其执行结束。这时同时 queryA 也在执行。\nconst a = await promiseA(); \/\/ 这时 queryB 已经执行结束。继续等待 queryA 执行结束\ndoSomething(a, b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseA = queryA(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行 queryA\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e queryB(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行 queryB 并等待其执行结束。这时同时 queryA 也在执行。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promiseA(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时 queryB 已经执行结束。继续等待 queryA 执行结束\x3c\/span\x3e\ndoSomething(a, b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我个人比较喜欢如下写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const [ a, b ] = await Promise.all([ queryA(), queryB() ]);\ndoSomething(a, b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [ a, b ] = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([ queryA(), queryB() ]);\ndoSomething(a, b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将 \x3ccode\x3eawait\x3c\/code\x3e 和 \x3ccode\x3ePromise\x3c\/code\x3e 结合使用，效果更佳！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3e如今 \x3ccode\x3easync\x3c\/code\x3e 函数已经被各大主流浏览器实现（除了 IE）。如果要兼容旧版浏览器，可以使用 \x3ccode\x3ebabel\x3c\/code\x3e 将其编译为 \x3ccode\x3eGenerator\x3c\/code\x3e。如果还要兼容只支持 ES5 的浏览器，还可以继续把 \x3ccode\x3eGenerator\x3c\/code\x3e 编译为 \x3ccode\x3eES5\x3c\/code\x3e。编译后的代码量比较大，小心代码膨胀。\x3c\/p\x3e\n\x3cp\x3e如果是用 node 写 Server，那就不用纠结了直接用就是了。\x3ca href=\x22https:\/\/github.com\/koajs\/koa\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ekoa\x3c\/a\x3e 是用 \x3ccode\x3easync\x3c\/code\x3e 是你的好帮手。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e完\x3c\/h2\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 与 异步编程</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011296630">https://segmentfault.com/a/1190000011296630</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6x9uxm3m2l/" target="_blank">https://alili.tech/archive/6x9uxm3m2l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>