<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="BetterScroll：可能是目前最好用的移动端滚动插件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>BetterScroll：可能是目前最好用的移动端滚动插件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/743c5acb/",
				"appid": "1613049289050283", 
				"title": "BetterScroll：可能是目前最好用的移动端滚动插件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-23T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/71ce8695/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/3afbff88/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&text=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&text=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&title=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&is_video=false&description=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&title=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&title=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&title=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f743c5acb%2f&title=BetterScroll%ef%bc%9a%e5%8f%af%e8%83%bd%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e5%a5%bd%e7%94%a8%e7%9a%84%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">BetterScroll：可能是目前最好用的移动端滚动插件</h1><div class="meta"><div class="postdate"><time datetime="2018-10-23" itemprop="datePublished">2018-10-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eBetterScroll 是一款重点解决移动端各种滚动场景需求的开源插件（\x3ca href=\x22https:\/\/github.com\/ustbhuangyi\/better-scroll\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub地址\x3c\/a\x3e），有下列功能支持滚动列表，下拉刷新，上拉刷新，轮播图，slider等功能。\x3cbr\x3e为了满足这些功能，better-scroll通过使用惯性滚动、边界回弹、滚动条淡入淡出来确保滚动的流畅。同时还支持很多API和事件，具体支持的事件可以查看官网讲的非常详细。\x3cbr\x3e由于它基于原生JavaScript 实现，不依赖任何框架，所以既可以原生 JavaScript 引用，也可以与目前前端 MVVM 框架结合使用，比如，其官网上的示例就是与 Vue 的结合。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e如何使用：\x3c\/h2\x3e\n\x3cp\x3e再讲如何使用的之前，我们先来了解一下他的滚动原理：在浏览器中的滚动中，当内容的高度高于外边容器的高度的时候也就出现了滚动条，我们可以通过使用滚动条来看到超出的部分.\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/bVY5fs?w=830\x26amp;h=632\x22 src=\x22https:\/\/static.alili.tech\/img\/bVY5fs?w=830\x26amp;h=632\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ebetter-scroll的原理正是基于这里，内容部分的宽度\/高度必须大于外部宽度\/高度。所以在使用\x3cbr\x3e的时候外部容器的需要设置固定宽度，还有一个问题需要设置overflow:hidden,这是因为为了隐藏超出部分。然后就是什么时候对better-scroll进行初始化，这个有点麻烦，但是所幸，作者已经在vue框架下进行封装，我们只需要像个麻瓜一样往里边填东西就行了。但是有一点需要注意：滚动的元素只能是第一个容器的第一个元素。源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ this.scroller就是滚动的内容，this.wrapper是容器\n    this.scroller = this.wrapper.children[0]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.scroller就是滚动的内容，this.wrapper是容器\x3c\/span\x3e\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.scroller\x3c\/span\x3e = this\x3cspan class=\x22hljs-selector-class\x22\x3e.wrapper\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.children\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们需要滚动多个内容怎么办呢，就用一个元素将其包裹住，让他成为容器的第一个子元素就行了。如何使用讲完了，我们来讲讲源码，毕竟这是一个源码解析的文章\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e核心代码：\x3c\/h2\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e1、scrollTo\x3c\/h1\x3e\n\x3cp\x3escrollTo()函数是better-scroll非常核心的一个函数，事实上我们在调用scrollToElement的\x3cbr\x3e时候，内部进行的操作还是scrollTo函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   BScroll.prototype.scrollTo = function (x, y, time=0, easing = ease.bounce) {\n        \/\/ useTransition是否使用css3 transition,isInTransition表示是否在滚动过程中\n        \/\/ this.x表示translate后的位置或者初始化this.x = 0\n        this.isInTransition = this.options.useTransition\n        \x26amp;\x26amp; time \x3e 0 \x26amp;\x26amp; (x !== this.x || y !== this.y)\n\n        \/\/ 如果使用的transition，就调用一系列transition的设置，默认是true\n        if (!time || this.options.useTransition) {\n            this._transitionProperty()\n            this._transitionTimingFunction(easing.style)\n            this._transitionTime(time)\n            \/\/ 这个函数会更改this.x\n            this._translate(x, y)\n\n            \/\/ time存在protoType表示不仅在屏幕滑动的时候， momentum 滚动动画运行过程中实时派发 scroll 事件\n            if (time \x26amp;\x26amp; this.options.probeType === 3) {\n                \/\/ 这个函数的作用是派发scroll事件\n                this._startProbe()\n            }\n\n            \/\/ wheel用于picker组件设置,不用管\n            if (this.options.wheel) {\n                if (y \x3e 0) {\n                    this.selectedIndex = 0\n                } else if (y \x3c this.maxScrollY) {\n                    this.selectedIndex = this.items.length - 1\n                } else {\n                    this.selectedIndex = Math.round(Math.abs(y \/ this.itemHeight))\n                }\n            } else {\n                \/\/ 进行动画this._animate\n                this._animate(x, y, time, easing.fn)\n            }\n        }\n    };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e   BScroll.prototype.scrollTo = function (x, y, time=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, easing = ease.bounce) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ useTransition是否使用css3 transition,isInTransition表示是否在滚动过程中\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.x表示translate后的位置或者初始化this.x = 0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isInTransition = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.useTransition\n        \x26amp;\x26amp; time \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; (x !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x || y !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y)\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果使用的transition，就调用一系列transition的设置，默认是true\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!time || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.useTransition) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._transitionProperty()\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._transitionTimingFunction(easing.style)\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._transitionTime(time)\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个函数会更改this.x\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._translate(x, y)\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ time存在protoType表示不仅在屏幕滑动的时候， momentum 滚动动画运行过程中实时派发 scroll 事件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (time \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.probeType === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个函数的作用是派发scroll事件\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._startProbe()\n            }\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ wheel用于picker组件设置,不用管\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.wheel) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (y \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (y \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollY) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.items.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex = Math.round(Math.abs(y \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.itemHeight))\n                }\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 进行动画this._animate\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._animate(x, y, time, easing.fn)\n            }\n        }\n    };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们来依次看看这个函数，其中简单的操作用代码注明，也就不做太多的描述，其中例如this._transition这种有关transform的都是改变他的位置而已，这里我需要说明一下，我们在制作轮播图的时候，别去使用transform这种方法来做轮播图，因为当我们需要获取transform属性值的时候，你会获取到的值是一个非常奇怪的矩阵，得到translateX或者translateY的值是一件非常痛苦的事，可以看看作者是如何获取transform的值的，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22matrix = matrix[style.transform].split(\x27)\x27)[0].split(\x27, \x27)\n            x = \x2b(matrix[12] || matrix[4])\n            y = \x2b(matrix[13] || matrix[5])\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e[\x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e].\x3cspan class=\x22hljs-built_in\x22\x3esplit\x3c\/span\x3e(\x27)\x27)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].\x3cspan class=\x22hljs-built_in\x22\x3esplit\x3c\/span\x3e(\x27, \x27)\n            x = \x2b(\x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e] || \x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e])\n            y = \x2b(\x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e] || \x3cspan class=\x22hljs-built_in\x22\x3ematrix\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e])\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我是一脸蒙蔽，要是你觉得你水平很高当我没说。this.options.probeType这个probeType配置表明的是我们需要在什么情况下派发scroll事件，在better-scroll的原理中是默认阻止浏览器的默认行为的，那我们是如何派发事件的呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  export function tap(e, eventName) {\n        let ev = document.createElement(\x27Event\x27)\n        ev.initEvent(eventName, true, true)\n        e.target.dispatchEvent(ev)\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etap\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee, eventName\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ev = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27Event\x27\x3c\/span\x3e)\n        ev.initEvent(eventName, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n        e.target.dispatchEvent(ev)\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建一个element,然后初始化，然后派发事件，我们就可以像addEventListener(\x27click\x27, fn, false)这样的方式来监听事件addEventListener(eventName, fn, false)。这儿有一个参数叫easing,我们来看看easing是什么\x3cbr\x3e下面是一个easing的一个选项：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 bounce: {\n        style: \x27cubic-bezier(0.165, 0.84, 0.44, 1)\x27,\n        fn: function (t) {\n            return 1 - (--t * t * t * t)\n        }\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e bounce: {\n        style: \x3cspan class=\x22hljs-symbol\x22\x3e\x27cubic\x3c\/span\x3e-bezier(\x3cspan class=\x22hljs-number\x22\x3e0.165\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0.84\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0.44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x27,\n        fn: \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\x3c\/span\x3e(t) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e1\x3c\/span\x3e - (\x3cspan class=\x22hljs-comment\x22\x3e--t * t * t * t)\x3c\/span\x3e\n        }\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到easing通过贝瑟尔函数，和fn让我们的动画显得不是那么僵硬。贝瑟尔函数可以去看看，他让动画不再那么突兀。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e2、refresh函数\x3c\/h1\x3e\n\x3cp\x3e在实际开发中，有时候从后端请求到数据后，我们dom结构发生变化，所以需要调用refresh方法，来看看他是什么玩意\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22BScroll.prototype.refresh = function () {\n    \/\/ return getBoundingRect getRect()\n    let wrapperRect = getRect(this.wrapper)\n    this.wrapperWidth = wrapperRect.width\n    this.wrapperHeight = wrapperRect.height\n\n    let scrollerRect = getRect(this.scroller)\n    this.scrollerWidth = scrollerRect.width\n    this.scrollerHeight = scrollerRect.height\n\n    const wheel = this.options.wheel\n    \/\/ wheel用于picker组件设置\n    if (wheel) {\n        this.items = this.scroller.children\n        this.options.itemHeight = this.itemHeight = this.items.length ? this.scrollerHeight \/ this.items.length : 0\n        if (this.selectedIndex === undefined) {\n            this.selectedIndex = wheel.selectedIndex || 0\n        }\n        this.options.startY = -this.selectedIndex * this.itemHeight\n        this.maxScrollX = 0\n        this.maxScrollY = -this.itemHeight * (this.items.length - 1)\n    } else {\n        \/\/ 允许滑动的距离\n        this.maxScrollX = this.wrapperWidth - this.scrollerWidth\n        this.maxScrollY = this.wrapperHeight - this.scrollerHeight\n    }\n\n    \/\/ 滚动原理容器的宽度小于scroller的宽度\n    \/\/ scrollX设置为true表示可以横向滚动\n    this.hasHorizontalScroll = this.options.scrollX \x26amp;\x26amp; this.maxScrollX \x3c 0\n    this.hasVerticalScroll = this.options.scrollY \x26amp;\x26amp; this.maxScrollY \x3c 0\n\n    \/\/ 如果水平不存在的话\n    if (!this.hasHorizontalScroll) {\n        this.maxScrollX = 0\n        this.scrollerWidth = this.wrapperWidth\n    }\n\n    if (!this.hasVerticalScroll) {\n        this.maxScrollY = 0\n        this.scrollerHeight = this.wrapperHeight\n    }\n\n    this.endTime = 0\n    \/\/ 移动方向\n    this.directionX = 0\n    this.directionY = 0\n    \/\/ return el.offsetLeft\n    \/\/ el.offsetLeft是距离父容器的距离\n    \/\/ el.getBoundingClientRect()返回的是距离页面的距离\n    this.wrapperOffset = offset(this.wrapper)\n\n    \/\/ 切换到refresh事件\n    this.trigger(\x27refresh\x27)\n\n    \/\/ 重置位置\n    this.resetPosition()\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eBScroll.prototype.refresh = function () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return getBoundingRect getRect()\x3c\/span\x3e\n    let wrapperRect = getRect(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapper)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperWidth = wrapperRect.width\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperHeight = wrapperRect.height\n\n    let scrollerRect = getRect(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scroller)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerWidth = scrollerRect.width\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerHeight = scrollerRect.height\n\n    const wheel = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.wheel\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ wheel用于picker组件设置\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (wheel) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.items = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scroller.children\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.itemHeight = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.itemHeight = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.items.length ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerHeight \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.items.length : \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex === undefined) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex = wheel.selectedIndex || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.startY = -\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selectedIndex * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.itemHeight\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollX = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollY = -\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.itemHeight * (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.items.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 允许滑动的距离\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollX = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperWidth - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerWidth\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollY = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperHeight - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerHeight\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 滚动原理容器的宽度小于scroller的宽度\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ scrollX设置为true表示可以横向滚动\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasHorizontalScroll = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.scrollX \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollX \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasVerticalScroll = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.scrollY \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollY \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果水平不存在的话\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasHorizontalScroll) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollX = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerWidth = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperWidth\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasVerticalScroll) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.maxScrollY = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollerHeight = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperHeight\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endTime = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移动方向\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directionX = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directionY = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return el.offsetLeft\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ el.offsetLeft是距离父容器的距离\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ el.getBoundingClientRect()返回的是距离页面的距离\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapperOffset = offset(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrapper)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 切换到refresh事件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.trigger(\x3cspan class=\x22hljs-string\x22\x3e\x27refresh\x27\x3c\/span\x3e)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置位置\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.resetPosition()\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们的dom结构发生变化的时候，我们就需要重新计算父容器和容器的大小了，这样就可以重新渲染了，这个函数没什么太难理解的部分，需要注意的是getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。他同element.style获取的有些不同getBoundingClientRect()获取到的值是相对视口左上角，意思是说在获取right值的时候，事实上是left\x2belement.clientWidth。而且getBoundingClientRect()是只能读取，而element.style不仅能读取，还能获取。el.offsetLeft返回的距离父容器的距离，如果我们需要得到元素距离document的距离的话我们就需要这样写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function offset(el) {\n    let left = 0\n    let top = 0\n\n    while (el) {\n        left -= el.offsetLeft\n        top -= el.offsetTop\n        el = el.offsetParent\n    }\n\n    return {\n        left,\n        top\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoffset\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(el)\x3c\/span\x3e {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e top = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eel\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e -= \x3cspan class=\x22hljs-keyword\x22\x3eel\x3c\/span\x3e.offsetLeft\n        top -= \x3cspan class=\x22hljs-keyword\x22\x3eel\x3c\/span\x3e.offsetTop\n        \x3cspan class=\x22hljs-keyword\x22\x3eel\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eel\x3c\/span\x3e.offsetParent\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e,\n        top\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一直找到没有父元素的时候，就找到元素距离document的距离了\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e3、trigger函数\x3c\/h1\x3e\n\x3cp\x3e在better-scroll的源码中，多次用到trigger函数，我们来看看他都做了什么\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 BScroll.prototype.trigger = function (type) {\n        let events = this._events[type]\n        if (!events) {\n            return\n        }\n\n        let len = events.length\n        let eventsCopy = [...events]\n        for (let i = 0; i \x3c len; i\x2b\x2b) {\n            let event = eventsCopy[i]\n            let [fn, context] = event\n            if (fn) {\n                fn.apply(context, [].slice.call(arguments,1))\n            }\n        }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs verilog\x22\x3e\x3ccode\x3e BScroll\x3cspan class=\x22hljs-variable\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-variable\x22\x3e.trigger\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e events = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-variable\x22\x3e._events\x3c\/span\x3e[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e]\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!events) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e len = events\x3cspan class=\x22hljs-variable\x22\x3e.length\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e eventsCopy = [..\x3cspan class=\x22hljs-variable\x22\x3e.events\x3c\/span\x3e]\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; len; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e = eventsCopy[i]\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e [fn, \x3cspan class=\x22hljs-keyword\x22\x3econtext\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (fn) {\n                fn\x3cspan class=\x22hljs-variable\x22\x3e.apply\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3econtext\x3c\/span\x3e, []\x3cspan class=\x22hljs-variable\x22\x3e.slice\x3c\/span\x3e\x3cspan class=\x22hljs-variable\x22\x3e.call\x3c\/span\x3e(arguments,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e))\n            }\n        }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3etrigger函数的作用就是切换到某个事件中，获取到事件，然后使用fn进行调用。没什么太大难度，这里想到一点能够体现es6的优越性的地方，比如a = [1,2,3] 在es5中如果我们需要获取a这个数组长度的时候，我们需要这样写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 let len = a.length\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e let len = \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.length\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是在es6中我们不再需要这样写了，这样写就行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let { length } = a\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e } = a\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果需要获取其他属性值，就麻瓜式往里边填。这里还涉及一个深拷贝的问题，数组和对象的深拷贝这里不做过多阐述。上述最重要的我认为就是这三个函数\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e总结：\x3c\/h2\x3e\n\x3cp\x3e这个better-scroll的源码条理清晰，毕竟滴滴D8的段位摆在那儿，非常适合阅读。还有一些就是我对源码分析的文章的看法。在写这个源码分析的文章的时候，我意识到一个问题，那就是不仅我自己能够看懂，以前我也写过vuex的源码分析，基本就是把代码全部贴上去，写了大概2万字，我现在觉得这种方法欠妥，正确的方式应该就是把重要的部分提取出来，最重要的引导一个思路。把代码整个贴出来，显得繁琐不说，又相当于读者自己把注释看了一遍而已，所以我认为正确的方式是弄出一个思路，读者尝试读源码的时候，能够有一个大概的概念。能够自己理清思路\x3c\/p\x3e\n\x3cp\x3e至于为什么这个标题不写better-scroll的源码分析呢，我怕有些人说有些源码分析的文章就是垃圾，所以至少在字面上进行改变(逃。。。)\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012135906">https://segmentfault.com/a/1190000012135906</a></p><h2 id="原文标题">原文标题</h2><p>BetterScroll：可能是目前最好用的移动端滚动插件</p><h2>本文链接：</h2><a href="https://alili.tech/archive/743c5acb/" target="_blank">https://alili.tech/archive/743c5acb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>