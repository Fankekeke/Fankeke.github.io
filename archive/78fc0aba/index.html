<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/78fc0aba/",
				"appid": "1613049289050283", 
				"title": "AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-22T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/e54a5961/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/90bbab67/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&text=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&text=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&title=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&is_video=false&description=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&title=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&title=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&title=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f78fc0aba%2f&title=AST%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e2%80%94%e2%80%94%e6%9c%80%e5%9f%ba%e7%a1%80%e7%9a%84javascript%e9%87%8d%e7%82%b9%e7%9f%a5%e8%af%86%ef%bc%8c99%25%e7%9a%84%e4%ba%ba%e6%a0%b9%e6%9c%ac%e4%b8%8d%e4%ba%86%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解</h1><div class="meta"><div class="postdate"><time datetime="2018-10-22" itemprop="datePublished">2018-10-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。\x3cp\x3e本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eJavascript就像一台精妙运作的机器，我们可以用它来完成一切天马行空的构思。\x3c\/p\x3e\n\x3cp\x3e我们对javascript生态了如指掌，却常忽视javascript本身。这台机器，究竟是哪些零部件在支持着它运行？\x3c\/p\x3e\n\x3cp\x3eAST在日常业务中也许很难涉及到，但当你不止于想做一个工程师，而想做工程师的工程师，写出vue、react之类的大型框架，或类似webpack、vue-cli前端自动化的工具，或者有批量修改源码的工程需求，那你必须懂得AST。AST的能力十分强大，且能帮你真正吃透javascript的语言精髓。\x3c\/p\x3e\n\x3cp\x3e事实上，在javascript世界中，你可以认为抽象语法树(AST)是最底层。 再往下，就是关于转换和编译的“黑魔法”领域了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e人生第一次拆解Javascript\x3c\/h2\x3e\n\x3cp\x3e小时候，当我们拿到一个螺丝刀和一台机器，人生中最令人怀念的梦幻时刻便开始了：\x3c\/p\x3e\n\x3cp\x3e我们把机器，拆成一个一个小零件，一个个齿轮与螺钉，用巧妙的机械原理衔接在一起...\x3c\/p\x3e\n\x3cp\x3e当我们把它重新照不同的方式组装起来，这时，机器重新又跑动了起来——世界在你眼中如获新生。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231515?w=658\x26amp;h=658\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231515?w=658\x26amp;h=658\x22 alt=\x22image\x22 title=\x22image\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过抽象语法树解析，我们可以像童年时拆解玩具一样，透视Javascript这台机器的运转，并且重新按着你的意愿来组装。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 现在，我们拆解一个简单的add函数\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add(a, b) {\n    return a \x2b b\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3efunction add(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n    return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先，我们拿到的这个语法块，是一个FunctionDeclaration(函数定义)对象。\x3c\/p\x3e\n\x3cp\x3e用力拆开，它成了三块：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e一个id，就是它的名字，即add\x3c\/li\x3e\n\x3cli\x3e两个params，就是它的参数，即[a, b]\x3c\/li\x3e\n\x3cli\x3e一块body，也就是大括号内的一堆东西\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eadd没办法继续拆下去了，它是一个最基础Identifier（标志）对象，用来作为函数的唯一标志，就像人的姓名一样。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    name: \x27add\x27\n    type: \x27identifier\x27\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n    \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e\n    type: \x3cspan class=\x22hljs-string\x22\x3e\x27identifier\x27\x3c\/span\x3e\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eparams继续拆下去，其实是两个Identifier组成的数组。之后也没办法拆下去了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[\n    {\n        name: \x27a\x27\n        type: \x27identifier\x27\n        ...\n    },\n    {\n        name: \x27b\x27\n        type: \x27identifier\x27\n        ...\n    }\n]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scheme\x22\x3e\x3ccode\x3e[\n    {\n        name: \x3cspan class=\x22hljs-symbol\x22\x3e\x27a\x3c\/span\x3e\x27\n        type: \x3cspan class=\x22hljs-symbol\x22\x3e\x27identifier\x3c\/span\x3e\x27\n        ...\n    },\n    {\n        name: \x3cspan class=\x22hljs-symbol\x22\x3e\x27b\x3c\/span\x3e\x27\n        type: \x3cspan class=\x22hljs-symbol\x22\x3e\x27identifier\x3c\/span\x3e\x27\n        ...\n    }\n]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来，我们继续拆开body\x3cbr\x3e我们发现，body其实是一个BlockStatement（块状域）对象，用来表示是\x3ccode\x3e{return a \x2b b}\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e打开Blockstatement，里面藏着一个ReturnStatement（Return域）对象，用来表示\x3ccode\x3ereturn a \x2b b\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e继续打开ReturnStatement,里面是一个BinaryExpression(二项式)对象，用来表示\x3ccode\x3ea \x2b b\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e继续打开BinaryExpression，它成了三部分，\x3ccode\x3eleft\x3c\/code\x3e，\x3ccode\x3eoperator\x3c\/code\x3e，\x3ccode\x3eright\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eoperator\x3c\/code\x3e 即\x3ccode\x3e\x2b\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eleft\x3c\/code\x3e 里面装的，是Identifier对象 \x3ccode\x3ea\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eright\x3c\/code\x3e 里面装的，是Identifer对象 \x3ccode\x3eb\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e就这样，我们把一个简单的add函数拆解完毕，用图表示就是\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231998?w=1380\x26amp;h=910\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22image\x22 title=\x22image\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e看！抽象语法树(Abstract Syntax Tree)，的确是一种标准的树结构。\x3c\/p\x3e\n\x3cp\x3e那么，上面我们提到的Identifier、Blockstatement、ReturnStatement、BinaryExpression， 这一个个小部件的说明书去哪查？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e请查看 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Mozilla\/Projects\/SpiderMonkey\/Parser_API#Node_objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAST对象文档\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e送给你的AST螺丝刀：recast\x3c\/h3\x3e\n\x3cp\x3e输入命令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i recast -S\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3enpm i \x3cspan class=\x22hljs-keyword\x22\x3erecast\x3c\/span\x3e -\x3cspan class=\x22hljs-built_in\x22\x3eS\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你即可获得一把操纵语法树的螺丝刀\x3c\/p\x3e\n\x3cp\x3e接下来，你可以在任意js文件下操纵这把螺丝刀，我们新建一个parse.js示意：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eparse.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 给你一把\x26quot;螺丝刀\x26quot;——recast\nconst recast = require(\x26quot;recast\x26quot;);\n\n\/\/ 你的\x26quot;机器\x26quot;——一段代码\n\/\/ 我们使用了很奇怪格式的代码，想测试是否能维持代码结构\nconst code =\n  `\n  function add(a, b) {\n    return a \x2b\n      \/\/ 有什么奇怪的东西混进来了\n      b\n  }\n  `\n\/\/ 用螺丝刀解析机器\nconst ast = recast.parse(code);\n\n\/\/ ast可以处理很巨大的代码文件\n\/\/ 但我们现在只需要代码块的第一个body，即add函数\nconst add  = ast.program.body[0]\n\nconsole.log(add)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给你一把\x22螺丝刀\x22——recast\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3erecast\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 你的\x22机器\x22——一段代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们使用了很奇怪格式的代码，想测试是否能维持代码结构\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code =\n  `\n  function add(a, b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有什么奇怪的东西混进来了\x3c\/span\x3e\n      b\n  }\n  `\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用螺丝刀解析机器\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ast = \x3cspan class=\x22hljs-keyword\x22\x3erecast\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eparse\x3c\/span\x3e(code);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ast可以处理很巨大的代码文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但我们现在只需要代码块的第一个body，即add函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e add  = ast.\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e.body[0]\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(add)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输入\x3ccode\x3enode parse.js\x3c\/code\x3e你可以查看到add函数的结构，与之前所述一致，通过\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Mozilla\/Projects\/SpiderMonkey\/Parser_API#Node_objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAST对象文档\x3c\/a\x3e可查到它的具体属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22FunctionDeclaration{\n    type: \x27FunctionDeclaration\x27,\n    id: ...\n    params: ...\n    body: ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3eFunctionDeclaration{\n    \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27FunctionDeclaration\x27\x3c\/span\x3e,\n    id: \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eparams\x3c\/span\x3e: \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n    body: \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你也可以继续使用console.log透视它的更内层，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(add.params[0])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.params\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[0]\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(add.body.body[0].argument.left)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.body\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.body\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[0]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.argument\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.left\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3erecast.types.builders 制作模具\x3c\/h2\x3e\n\x3cp\x3e一个机器，你只会拆开重装，不算本事。\x3c\/p\x3e\n\x3cp\x3e拆开了，还能改装，才算上得了台面。\x3c\/p\x3e\n\x3cp\x3erecast.types.builders里面提供了不少“模具”，让你可以轻松地拼接成新的机器。\x3c\/p\x3e\n\x3cp\x3e最简单的例子，我们想把之前的\x3ccode\x3efunction add(a, b){...}\x3c\/code\x3e声明，改成匿名函数式声明\x3ccode\x3econst add = function(a ,b){...}\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如何改装？\x3c\/p\x3e\n\x3cp\x3e第一步，我们创建一个VariableDeclaration变量声明对象，声明头为const， 内容为一个即将创建的VariableDeclarator对象。\x3c\/p\x3e\n\x3cp\x3e第二步，创建一个VariableDeclarator，放置add.id在左边， 右边是将创建的FunctionDeclaration对象\x3c\/p\x3e\n\x3cp\x3e第三步，我们创建一个FunctionDeclaration，如前所述的三个组件，id params body中，因为是匿名函数id设为空，params使用add.params，body使用add.body。\x3c\/p\x3e\n\x3cp\x3e这样，就创建好了\x3ccode\x3econst add = function(){}\x3c\/code\x3e的AST对象。\x3c\/p\x3e\n\x3cp\x3e在之前的parse.js代码之后，加入以下代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 引入变量声明，变量符号，函数声明三种“模具”\nconst {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders\n\n\/\/ 将准备好的组件置入模具，并组装回原来的ast对象。\nast.program.body[0] = variableDeclaration(\x26quot;const\x26quot;, [\n  variableDeclarator(add.id, functionExpression(\n    null, \/\/ Anonymize the function expression.\n    add.params,\n    add.body\n  ))\n]);\n\n\/\/将AST对象重新转回可以阅读的代码\nconst output = recast.print(ast).code;\n\nconsole.log(output)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入变量声明，变量符号，函数声明三种“模具”\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将准备好的组件置入模具，并组装回原来的ast对象。\x3c\/span\x3e\nast.program.body[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = variableDeclaration(\x3cspan class=\x22hljs-string\x22\x3e\x22const\x22\x3c\/span\x3e, [\n  variableDeclarator(\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e.id, functionExpression(\n    \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Anonymize the function expression.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e.params,\n    \x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e.body\n  ))\n]);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将AST对象重新转回可以阅读的代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e output = recast.\x3cspan class=\x22hljs-built_in\x22\x3eprint\x3c\/span\x3e(ast).code;\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(output)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，我们打印出了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const add = function(a, b) {\n  return a \x2b\n    \/\/ 有什么奇怪的东西混进来了\n    b\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有什么奇怪的东西混进来了\x3c\/span\x3e\n    b\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const output = recast.print(ast).code;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gauss\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3eoutput\x3c\/span\x3e = recast.\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e(ast).\x3cspan class=\x22hljs-built_in\x22\x3ecode\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实是recast.parse的逆向过程，具体公式为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22recast.print(recast.parse(source)).code === source\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3erecast\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3erecast\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eparse\x3c\/span\x3e(source)).code === source\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e打印出来还保留着“原装”的函数内容，连注释都没有变。\x3c\/p\x3e\n\x3cp\x3e我们其实也可以打印出美化格式的代码段：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const output = recast.prettyPrint(ast, { tabWidth: 2 }).code\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gauss\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3eoutput\x3c\/span\x3e = recast.prettyPrint(ast, { tabWidth: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }).\x3cspan class=\x22hljs-built_in\x22\x3ecode\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const add = function(a, b) {\n  return a \x2b b;\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs oxygene\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n  return a \x2b b;\n}\x3c\/span\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e现在，你是不是已经产生了“我可以通过AST树生成任何js代码”的幻觉？\x3cp\x3e我郑重告诉你，这不是幻觉。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e实战进阶：命令行修改js文件\x3c\/h2\x3e\n\x3cp\x3e除了parse\/print\/builder以外，Recast的三项主要功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3erun: 通过命令行读取js文件，并转化成ast以供处理。\x3c\/li\x3e\n\x3cli\x3etnt： 通过assert()和check()，可以验证ast对象的类型。\x3c\/li\x3e\n\x3cli\x3evisit: 遍历ast树，获取有效的AST对象并进行更改。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们通过一个系列小务来学习全部的recast工具库：\x3c\/p\x3e\n\x3cp\x3e创建一个用来示例文件，假设是demo.js\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3edemo.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add(a, b) {\n  return a \x2b b\n}\n\nfunction sub(a, b) {\n  return a - b\n}\n\nfunction commonDivision(a, b) {\n  while (b !== 0) {\n    if (a \x3e b) {\n      a = sub(a, b)\n    } else {\n      b = sub(b, a)\n    }\n  }\n  return a\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3efunction add(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n  return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\n\nfunction sub(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n  return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e - \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\n\nfunction commonDivision(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n  while (\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x26gt; b) {\n      \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e = sub(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e = sub(\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e, a)\n    }\n  }\n  return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3erecast.run —— 命令行文件读取\x3c\/h3\x3e\n\x3cp\x3e新建一个名为\x3ccode\x3eread.js\x3c\/code\x3e的文件，写入\x3cbr\x3e\x3cstrong\x3eread.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22recast.run( function(ast, printSource){\n    printSource(ast)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3erecast.run( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(ast, printSource)\x3c\/span\x3e\x3c\/span\x3e{\n    printSource(ast)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e命令行输入\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22node read demo.js\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eread\x3c\/span\x3e demo.js\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们查以看到js文件内容打印在了控制台上。\x3c\/p\x3e\n\x3cp\x3e我们可以知道，\x3ccode\x3enode read\x3c\/code\x3e可以读取\x3ccode\x3edemo.js\x3c\/code\x3e文件，并将demo.js内容转化为ast对象。\x3c\/p\x3e\n\x3cp\x3e同时它还提供了一个\x3ccode\x3eprintSource\x3c\/code\x3e函数，随时可以将ast的内容转换回源码，以方便调试。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3erecast.visit —— AST节点遍历\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eread.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast  = require(\x27recast\x27)\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function({node}) {\n        console.log(node)\n        return false\n      }\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast  = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27recast\x27\x3c\/span\x3e)\n\nrecast.run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3east, printSource\x3c\/span\x3e) \x3c\/span\x3e{\n  recast.visit(ast, {\n      \x3cspan class=\x22hljs-attr\x22\x3evisitExpressionStatement\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e{node}\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(node)\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      }\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3erecast.visit将AST对象内的节点进行逐个遍历。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e你想操作函数声明，就使用visitFunctionDelaration遍历，想操作赋值表达式，就使用visitExpressionStatement。 只要在 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Mozilla\/Projects\/SpiderMonkey\/Parser_API#Node_objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAST对象文档\x3c\/a\x3e中定义的对象，在前面加visit，即可遍历。\x3c\/li\x3e\n\x3cli\x3e通过node可以取到AST对象\x3c\/li\x3e\n\x3cli\x3e每个遍历函数后必须加上return false，或者选择以下写法，否则报错：\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast  = require(\x27recast\x27)\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.node\n        printSource(node)\n        this.traverse(path)\n      }\n    })\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast  = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27recast\x27\x3c\/span\x3e)\n\nrecast.run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3east, printSource\x3c\/span\x3e) \x3c\/span\x3e{\n  recast.visit(ast, {\n      \x3cspan class=\x22hljs-attr\x22\x3evisitExpressionStatement\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = path.node\n        printSource(node)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.traverse(path)\n      }\n    })\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e调试时，如果你想输出AST对象，可以\x3ccode\x3econsole.log(node)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果你想输出AST对象对应的源码，可以\x3ccode\x3eprintSource(node)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e命令行输入`\x3cbr\x3enode read demo.js`进行测试。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3e#!\/usr\/bin\/env node\x3c\/code\x3e 在所有使用\x3ccode\x3erecast.run()\x3c\/code\x3e的文件顶部都需要加入这一行，它的意义我们最后再讨论。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eTNT —— 判断AST对象类型\x3c\/h3\x3e\n\x3cp\x3eTNT，即recast.types.namedTypes，就像它的名字一样火爆，它用来判断AST对象是否为指定的类型。\x3c\/p\x3e\n\x3cp\x3eTNT.Node.assert()，就像在机器里埋好的炸药，当机器不能完好运转时（类型不匹配），就炸毁机器(报错退出)\x3c\/p\x3e\n\x3cp\x3eTNT.Node.check()，则可以判断类型是否一致，并输出False和True\x3c\/p\x3e\n\x3cp\x3e上述Node可以替换成任意AST对象，例如TNT.ExpressionStatement.check(),TNT.FunctionDeclaration.assert()\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eread.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast = require(\x26quot;recast\x26quot;);\nconst TNT = recast.types.namedTypes\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.value\n        \/\/ 判断是否为ExpressionStatement，正确则输出一行字。\n        if(TNT.ExpressionStatement.check(node)){\n          console.log(\x27这是一个ExpressionStatement\x27)\n        }\n        this.traverse(path);\n      }\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e TNT = recast.types.namedTypes\n\nrecast.run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3east, printSource\x3c\/span\x3e) \x3c\/span\x3e{\n  recast.visit(ast, {\n      \x3cspan class=\x22hljs-attr\x22\x3evisitExpressionStatement\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = path.value\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断是否为ExpressionStatement，正确则输出一行字。\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(TNT.ExpressionStatement.check(node)){\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27这是一个ExpressionStatement\x27\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.traverse(path);\n      }\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eread.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast = require(\x26quot;recast\x26quot;);\nconst TNT = recast.types.namedTypes\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.node\n        \/\/ 判断是否为ExpressionStatement，正确不输出，错误则全局报错\n        TNT.ExpressionStatement.assert(node)\n        this.traverse(path);\n      }\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs d\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast = require(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e TNT = recast.types.namedTypes\n\nrecast.run(\x3cspan class=\x22hljs-built_in\x22\x3efunction\x3c\/span\x3e(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: \x3cspan class=\x22hljs-built_in\x22\x3efunction\x3c\/span\x3e(path) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = path.node\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断是否为ExpressionStatement，正确不输出，错误则全局报错\x3c\/span\x3e\n        TNT.ExpressionStatement.\x3cspan class=\x22hljs-keyword\x22\x3eassert\x3c\/span\x3e(node)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.traverse(path);\n      }\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e命令行输入`\x3cbr\x3enode read demo.js`进行测试。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e实战：用AST修改源码，导出全部方法\x3c\/h3\x3e\n\x3cp\x3eexportific.js\x3c\/p\x3e\n\x3cp\x3e现在，我们希望将demo中的function全部\x3c\/p\x3e\n\x3cp\x3e我们想让这个文件中的函数改写成能够全部导出的形式，例如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add (a, b) {\n    return a \x2b b\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3efunction add (\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n    return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e想改变为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22exports.add = (a, b) =\x3e {\n  return a \x2b b\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eexports\x3cspan class=\x22hljs-selector-class\x22\x3e.add\x3c\/span\x3e = (\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) =\x26gt; {\n  return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了使用fs.read读取文件、正则匹配替换文本、fs.write写入文件这种笨拙的方式外，我们可以==用AST优雅地解决问题==。\x3c\/p\x3e\n\x3cp\x3e查询\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Mozilla\/Projects\/SpiderMonkey\/Parser_API#Node_objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAST对象文档\x3c\/a\x3e\x3c\/p\x3e\n\x3ch4\x3e首先，我们先用builders凭空实现一个键头函数\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3eexportific.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast = require(\x26quot;recast\x26quot;);\nconst {\n  identifier:id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression,\n  blockStatement\n} = recast.types.builders\n\nrecast.run(function(ast, printSource) {\n  \/\/ 一个块级域 {}\n  console.log(\x27\\n\\nstep1:\x27)\n  printSource(blockStatement([]))\n\n  \/\/ 一个键头函数 ()=\x3e{}\n  console.log(\x27\\n\\nstep2:\x27)\n  printSource(arrowFunctionExpression([],blockStatement([])))\n\n  \/\/ add赋值为键头函数  add = ()=\x3e{}\n  console.log(\x27\\n\\nstep3:\x27)\n  printSource(assignmentExpression(\x27=\x27,id(\x27add\x27),arrowFunctionExpression([],blockStatement([]))))\n\n  \/\/ exports.add赋值为键头函数  exports.add = ()=\x3e{}\n  console.log(\x27\\n\\nstep4:\x27)\n  printSource(expressionStatement(assignmentExpression(\x27=\x27,memberExpression(id(\x27exports\x27),id(\x27add\x27)),\n    arrowFunctionExpression([],blockStatement([])))))\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attr\x22\x3eidentifier\x3c\/span\x3e:id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression,\n  blockStatement\n} = recast.types.builders\n\nrecast.run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3east, printSource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个块级域 {}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\nstep1:\x27\x3c\/span\x3e)\n  printSource(blockStatement([]))\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个键头函数 ()=\x26gt;{}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\nstep2:\x27\x3c\/span\x3e)\n  printSource(arrowFunctionExpression([],blockStatement([])))\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ add赋值为键头函数  add = ()=\x26gt;{}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\nstep3:\x27\x3c\/span\x3e)\n  printSource(assignmentExpression(\x3cspan class=\x22hljs-string\x22\x3e\x27=\x27\x3c\/span\x3e,id(\x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e),arrowFunctionExpression([],blockStatement([]))))\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ exports.add赋值为键头函数  exports.add = ()=\x26gt;{}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\nstep4:\x27\x3c\/span\x3e)\n  printSource(expressionStatement(assignmentExpression(\x3cspan class=\x22hljs-string\x22\x3e\x27=\x27\x3c\/span\x3e,memberExpression(id(\x3cspan class=\x22hljs-string\x22\x3e\x27exports\x27\x3c\/span\x3e),id(\x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e)),\n    arrowFunctionExpression([],blockStatement([])))))\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面写了我们一步一步推断出\x3ccode\x3eexports.add = ()=\x26gt;{}\x3c\/code\x3e的过程，从而得到具体的AST结构体。\x3c\/p\x3e\n\x3cp\x3e使用\x3ccode\x3enode exportific demo.js\x3c\/code\x3e运行可查看结果。\x3c\/p\x3e\n\x3cp\x3e接下来，只需要在获得的最终的表达式中，把id(\x27add\x27)替换成遍历得到的函数名，把参数替换成遍历得到的函数参数，把blockStatement([])替换为遍历得到的函数块级作用域，就成功地改写了所有函数！\x3c\/p\x3e\n\x3cp\x3e另外，我们需要注意，在commonDivision函数内，引用了sub函数，应改写成exports.sub\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eexportific.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast = require(\x26quot;recast\x26quot;);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nrecast.run(function (ast, printSource) {\n  \/\/ 用来保存遍历到的全部函数名\n  let funcIds = []\n  recast.types.visit(ast, {\n    \/\/ 遍历所有的函数定义\n    visitFunctionDeclaration(path) {\n      \/\/获取遍历到的函数名、参数、块级域\n      const node = path.node\n      const funcName = node.id\n      const params = node.params\n      const body = node.body\n\n      \/\/ 保存函数名\n      funcIds.push(funcName.name)\n      \/\/ 这是上一步推导出来的ast结构体\n      const rep = expressionStatement(assignmentExpression(\x27=\x27, memberExpression(id(\x27exports\x27), funcName),\n        arrowFunctionExpression(params, body)))\n      \/\/ 将原来函数的ast结构体，替换成推导ast结构体\n      path.replace(rep)\n      \/\/ 停止遍历\n      return false\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    \/\/ 遍历所有的函数调用\n    visitCallExpression(path){\n      const node = path.node;\n      \/\/ 如果函数调用出现在函数定义中，则修改ast结构\n      if (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(\x27exports\x27), node.callee)\n      }\n      \/\/ 停止遍历\n      return false\n    }\n  })\n  \/\/ 打印修改后的ast源码\n  printSource(ast)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\nconst recast = require(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nrecast.run(function (ast, printSource) {\n  \/\/ 用来保存遍历到的全部函数名\n  let funcIds = []\n  recast.types.visit(ast, {\n    \/\/ 遍历所有的函数定义\n    visitFunctionDeclaration(path) {\n      \/\/获取遍历到的函数名、参数、块级域\n      const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= path\x3c\/span\x3e.node\n      const funcName = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eid\x3c\/span\x3e\n      const \x3cspan class=\x22hljs-keyword\x22\x3eparams\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eparams\x3c\/span\x3e\n      const body = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebody\x3c\/span\x3e\n\n      \/\/ 保存函数名\n      funcIds.push(funcName.name)\n      \/\/ 这是上一步推导出来的ast结构体\n      const rep = expressionStatement(assignmentExpression(\x27=\x27, memberExpression(id(\x27exports\x27), funcName),\n        arrowFunctionExpression(\x3cspan class=\x22hljs-keyword\x22\x3eparams\x3c\/span\x3e, body)))\n      \/\/ 将原来函数的ast结构体，替换成推导ast结构体\n      path.replace(rep)\n      \/\/ 停止遍历\n      return \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    \/\/ 遍历所有的函数调用\n    visitCallExpression(path){\n      const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= path\x3c\/span\x3e.node;\n      \/\/ 如果函数调用出现在函数定义中，则修改ast结构\n      if (funcIds.includes(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecallee\x3c\/span\x3e.name)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecallee\x3c\/span\x3e = memberExpression(id(\x27exports\x27), \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecallee\x3c\/span\x3e)\n      }\n      \/\/ 停止遍历\n      return \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  })\n  \/\/ 打印修改后的ast源码\n  printSource(ast)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e一步到位，发一个最简单的exportific前端工具\x3c\/h3\x3e\n\x3cp\x3e上面讲了那么多，仍然只体现在理论阶段。\x3c\/p\x3e\n\x3cp\x3e但通过简单的改写，就能通过recast制作成一个名为exportific的源码编辑工具。\x3c\/p\x3e\n\x3cp\x3e以下代码添加作了两个小改动\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e添加说明书--help，以及添加了--rewrite模式，可以直接覆盖文件或默认为导出*.export.js文件。\x3c\/li\x3e\n\x3cli\x3e将之前代码最后的 printSource(ast)替换成  writeASTFile(ast,filename,rewriteMode)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3eexportific.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\nconst recast = require(\x26quot;recast\x26quot;);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nconst fs = require(\x27fs\x27)\nconst path = require(\x27path\x27)\n\/\/ 截取参数\nconst options = process.argv.slice(2)\n\n\/\/如果没有参数，或提供了-h 或--help选项，则打印帮助\nif(options.length===0 || options.includes(\x27-h\x27) || options.includes(\x27--help\x27)){\n  console.log(`\n    采用commonjs规则，将.js文件内所有函数修改为导出形式。\n\n    选项： -r  或 --rewrite 可直接覆盖原有文件\n    `)\n  process.exit(0)\n}\n\n\/\/ 只要有-r 或--rewrite参数，则rewriteMode为true\nlet rewriteMode = options.includes(\x27-r\x27) || options.includes(\x27--rewrite\x27)\n\n\/\/ 获取文件名\nconst clearFileArg = options.filter((item)=\x3e{\n  return ![\x27-r\x27,\x27--rewrite\x27,\x27-h\x27,\x27--help\x27].includes(item)\n})\n\n\/\/ 只处理一个文件\nlet filename = clearFileArg[0]\n\nconst writeASTFile = function(ast, filename, rewriteMode){\n  const newCode = recast.print(ast).code\n  if(!rewriteMode){\n    \/\/ 非覆盖模式下，将新文件写入*.export.js下\n    filename = filename.split(\x27.\x27).slice(0,-1).concat([\x27export\x27,\x27js\x27]).join(\x27.\x27)\n  }\n  \/\/ 将新代码写入文件\n  fs.writeFileSync(path.join(process.cwd(),filename),newCode)\n}\n\n\nrecast.run(function (ast, printSource) {\n  let funcIds = []\n  recast.types.visit(ast, {\n    visitFunctionDeclaration(path) {\n      \/\/获取遍历到的函数名、参数、块级域\n      const node = path.node\n      const funcName = node.id\n      const params = node.params\n      const body = node.body\n\n      funcIds.push(funcName.name)\n      const rep = expressionStatement(assignmentExpression(\x27=\x27, memberExpression(id(\x27exports\x27), funcName),\n        arrowFunctionExpression(params, body)))\n      path.replace(rep)\n      return false\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    visitCallExpression(path){\n      const node = path.node;\n      if (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(\x27exports\x27), node.callee)\n      }\n      return false\n    }\n  })\n\n  writeASTFile(ast,filename,rewriteMode)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recast = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22recast\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attr\x22\x3eidentifier\x3c\/span\x3e: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 截取参数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = process.argv.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有参数，或提供了-h 或--help选项，则打印帮助\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(options.length===\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e || options.includes(\x3cspan class=\x22hljs-string\x22\x3e\x27-h\x27\x3c\/span\x3e) || options.includes(\x3cspan class=\x22hljs-string\x22\x3e\x27--help\x27\x3c\/span\x3e)){\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\n    采用commonjs规则，将.js文件内所有函数修改为导出形式。\n\n    选项： -r  或 --rewrite 可直接覆盖原有文件\n    `\x3c\/span\x3e)\n  process.exit(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只要有-r 或--rewrite参数，则rewriteMode为true\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rewriteMode = options.includes(\x3cspan class=\x22hljs-string\x22\x3e\x27-r\x27\x3c\/span\x3e) || options.includes(\x3cspan class=\x22hljs-string\x22\x3e\x27--rewrite\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取文件名\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clearFileArg = options.filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ![\x3cspan class=\x22hljs-string\x22\x3e\x27-r\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27--rewrite\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27-h\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27--help\x27\x3c\/span\x3e].includes(item)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只处理一个文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e filename = clearFileArg[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e writeASTFile = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3east, filename, rewriteMode\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newCode = recast.print(ast).code\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!rewriteMode){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非覆盖模式下，将新文件写入*.export.js下\x3c\/span\x3e\n    filename = filename.split(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e).slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e).concat([\x3cspan class=\x22hljs-string\x22\x3e\x27export\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27js\x27\x3c\/span\x3e]).join(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将新代码写入文件\x3c\/span\x3e\n  fs.writeFileSync(path.join(process.cwd(),filename),newCode)\n}\n\n\nrecast.run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3east, printSource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e funcIds = []\n  recast.types.visit(ast, {\n    visitFunctionDeclaration(path) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取遍历到的函数名、参数、块级域\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = path.node\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e funcName = node.id\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e params = node.params\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e body = node.body\n\n      funcIds.push(funcName.name)\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rep = expressionStatement(assignmentExpression(\x3cspan class=\x22hljs-string\x22\x3e\x27=\x27\x3c\/span\x3e, memberExpression(id(\x3cspan class=\x22hljs-string\x22\x3e\x27exports\x27\x3c\/span\x3e), funcName),\n        arrowFunctionExpression(params, body)))\n      path.replace(rep)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    visitCallExpression(path){\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = path.node;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(\x3cspan class=\x22hljs-string\x22\x3e\x27exports\x27\x3c\/span\x3e), node.callee)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  })\n\n  writeASTFile(ast,filename,rewriteMode)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在尝试一下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22node exportific demo.js\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eexportific\x3c\/span\x3e demo.js\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e已经可以在当前目录下找到源码变更后的\x3ccode\x3edemo.export.js\x3c\/code\x3e文件了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3enpm发包\x3c\/h3\x3e\n\x3cp\x3e编辑一下package.json文件\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;name\x26quot;: \x26quot;exportific\x26quot;,\n  \x26quot;version\x26quot;: \x26quot;0.0.1\x26quot;,\n  \x26quot;description\x26quot;: \x26quot;改写源码中的函数为可exports.XXX形式\x26quot;,\n  \x26quot;main\x26quot;: \x26quot;exportific.js\x26quot;,\n  \x26quot;bin\x26quot;: {\n    \x26quot;exportific\x26quot;: \x26quot;.\/exportific.js\x26quot;\n  },\n  \x26quot;keywords\x26quot;: [],\n  \x26quot;author\x26quot;: \x26quot;wanthering\x26quot;,\n  \x26quot;license\x26quot;: \x26quot;ISC\x26quot;,\n  \x26quot;dependencies\x26quot;: {\n    \x26quot;recast\x26quot;: \x26quot;^0.15.3\x26quot;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22name\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22exportific\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x220.0.1\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22description\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22改写源码中的函数为可exports.XXX形式\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22exportific.js\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22bin\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22exportific\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22.\/exportific.js\x22\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22keywords\x22\x3c\/span\x3e: [],\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22author\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22wanthering\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22license\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22ISC\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22dependencies\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22recast\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22^0.15.3\x22\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意bin选项，它的意思是将全局命令\x3ccode\x3eexportific\x3c\/code\x3e指向当前目录下的\x3ccode\x3eexportific.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这时，输入\x3ccode\x3enpm link\x3c\/code\x3e 就在本地生成了一个\x3ccode\x3eexportific\x3c\/code\x3e命令。\x3c\/p\x3e\n\x3cp\x3e之后，只要哪个js文件想导出来使用，就\x3ccode\x3eexportific XXX.js\x3c\/code\x3e一下。\x3c\/p\x3e\n\x3cp\x3e这是在本地的玩法，想和大家一起分享这个前端小工具，只需要发布npm包就行了。\x3c\/p\x3e\n\x3cp\x3e同时，一定要注意exportific.js文件头有\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#!\/usr\/bin\/env node\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs d\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/usr\/bin\/env node\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e否则在使用时将报错。\x3c\/p\x3e\n\x3ch4\x3e接下来，正式发布npm包！\x3c\/h4\x3e\n\x3cp\x3e如果你已经有了npm 帐号，请使用\x3ccode\x3enpm login\x3c\/code\x3e登录\x3c\/p\x3e\n\x3cp\x3e如果你还没有npm帐号 \x3ca href=\x22https:\/\/www.npmjs.com\/signup\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.npmjs.com\/signup\x3c\/a\x3e 非常简单就可以注册npm\x3c\/p\x3e\n\x3cp\x3e然后，输入\x3cbr\x3e\x3ccode\x3enpm publish\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e没有任何繁琐步骤，丝毫审核都没有，你就发布了一个实用的前端小工具exportific 。任何人都可以通过\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i exportific -g\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e exportific -g\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e全局安装这一个插件。\x3c\/p\x3e\n\x3cp\x3e提示：==在试验教程时，请不要和我的包重名，修改一下发包名称。==\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e结语\x3c\/h3\x3e\n\x3cp\x3e我们对javascript再熟悉不过，但透过AST的视角，最普通的js语句，却焕发出精心动魄的美感。你可以通过它批量构建任何javascript代码！\x3c\/p\x3e\n\x3cp\x3e童年时，这个世界充满了新奇的玩具，再普通的东西在你眼中都如同至宝。如今，计算机语言就是你手中的大玩具，一段段AST对象的拆分组装，构建出我们所生活的网络世界。\x3c\/p\x3e\n\x3cp\x3e所以不得不说软件工程师是一个幸福的工作，你心中住的仍然是那个午后的少年，永远有无数新奇等你发现，永远有无数梦想等你构建。\x3c\/p\x3e\n\x3cp\x3egithub地址：\x3ca href=\x22https:\/\/github.com\/wanthering\/exportific\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/wanthering...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231517?w=658\x26amp;h=893\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231517?w=658\x26amp;h=893\x22 alt=\x22image\x22 title=\x22image\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016231512">https://segmentfault.com/a/1190000016231512</a></p><h2 id="原文标题">原文标题</h2><p>AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解</p><h2>本文链接：</h2><a href="https://alili.tech/archive/78fc0aba/" target="_blank">https://alili.tech/archive/78fc0aba/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>