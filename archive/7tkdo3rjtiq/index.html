<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] 别再对 Angular 表单的 ControlValueAccessor 感到迷惑"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] 别再对 Angular 表单的 ControlValueAccessor 感到迷惑 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7tkdo3rjtiq/",
				"appid": "1613049289050283", 
				"title": "[译] 别再对 Angular 表单的 ControlValueAccessor 感到迷惑 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qfewhxi9h8/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zirvcnkl83/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&text=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&text=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&title=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&is_video=false&description=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&title=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&title=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&title=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7tkdo3rjtiq%2f&title=%5b%e8%af%91%5d%20%e5%88%ab%e5%86%8d%e5%af%b9%20Angular%20%e8%a1%a8%e5%8d%95%e7%9a%84%20ControlValueAccessor%20%e6%84%9f%e5%88%b0%e8%bf%b7%e6%83%91"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] 别再对 Angular 表单的 ControlValueAccessor 感到迷惑</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e原文链接：\x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angularindepth.com\/never-again-be-confused-when-implementing-controlvalueaccessor-in-angular-forms-93b9eee9ee83\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNever again be confused when implementing ControlValueAccessor in Angular\x26nbsp;forms\x3c\/a\x3e\x3c\/strong\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV7rR7?w=400\x26amp;h=391\x22 src=\x22https:\/\/static.alili.tech\/img\/bV7rR7?w=400\x26amp;h=391\x22 alt=\x22ceasy-control-value-accessor\x22 title=\x22ceasy-control-value-accessor\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果你正在做一个复杂项目，必然会需要自定义表单控件，这个控件主要需要实现 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口（译者注：该接口定义方法可参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/forms\/ControlValueAccessor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAPI 文档说明\x3c\/a\x3e\x3c\/strong\x3e，也可参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/control_value_accessor.ts\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular 源码定义\x3c\/a\x3e\x3c\/strong\x3e）。网上有大量文章描述如何实现这个接口，但很少说到它在 Angular 表单架构里扮演什么角色，如果你不仅仅想知道如何实现，还想知道为什么这样实现，那本文正合你的胃口。\x3c\/p\x3e\n\x3cp\x3e首先我解释下为啥需要 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口以及它在 Angular 中是如何使用的。然后我将展示如何封装第三方组件作为 Angular 组件，以及如何使用输入输出机制实现组件间通信（译者注：Angular 组件间通信输入输出机制可参考\x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/guide\/component-interaction\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官网文档\x3c\/a\x3e\x3c\/strong\x3e），最后将展示如何使用 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 来实现一种\x3cstrong\x3e针对 Angular 表单\x3c\/strong\x3e新的数据通信机制。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eFormControl 和 ControlValueAccessor\x3c\/h2\x3e\n\x3cp\x3e如果你之前使用过 Angular 表单，你可能会熟悉 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/forms\/FormControl\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFormControl\x3c\/a\x3e\x3c\/strong\x3e ，Angular 官方文档将它描述为追踪单个表单控件\x3cstrong\x3e值和有效性\x3c\/strong\x3e的实体对象。需要明白，不管你使用模板驱动还是响应式表单（译者注：即模型驱动），\x3ccode\x3eFormControl\x3c\/code\x3e 都总会被创建。如果你使用响应式表单，你需要显式创建 \x3ccode\x3eFormControl\x3c\/code\x3e 对象，并使用 \x3ccode\x3eformControl\x3c\/code\x3e 或 \x3ccode\x3eformControlName\x3c\/code\x3e 指令来绑定原生控件；如果你使用模板驱动方法，\x3ccode\x3eFormControl\x3c\/code\x3e 对象会被 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/forms\/NgModel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eNgModel\x3c\/code\x3e\x3c\/a\x3e\x3c\/strong\x3e 指令隐式创建（译者注：可查看 Angular 源码\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/ng_model.ts#L113\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这一行\x3c\/a\x3e\x3c\/strong\x3e）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Directive({\n  selector: \x27[ngModel]...\x27,\n  ...\n})\nexport class NgModel ... {\n  _control = new FormControl();   \x3c---------------- here\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Directive\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27[ngModel]...\x27\x3c\/span\x3e,\n  ...\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e NgModel ... {\n  _control = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormControl();   \x26lt;---------------- here\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不管 \x3ccode\x3eformControl\x3c\/code\x3e 是隐式还是显式创建，都必须和原生 DOM 表单控件如 \x3ccode\x3einput,textarea\x3c\/code\x3e 进行交互，并且很有可能需要自定义一个表单控件作为 Angular 组件而不是使用原生表单控件，而通常自定义表单控件会封装一个使用纯 JS 写的控件如 \x3cstrong\x3e\x3ca href=\x22https:\/\/jqueryui.com\/slider\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3ejQuery UI\x27s Slider\x3c\/code\x3e\x3c\/a\x3e\x3c\/strong\x3e。本文我将使用\x3cstrong\x3e原生表单控件\x3c\/strong\x3e术语来区分 Angular 特定的 \x3ccode\x3eformControl\x3c\/code\x3e 和你在 \x3ccode\x3ehtml\x3c\/code\x3e 使用的表单控件，但你需要知道任何一个自定义表单控件都可以和 \x3ccode\x3eformControl\x3c\/code\x3e 指令进行交互，而不是原生表单控件如 \x3ccode\x3einput\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e原生表单控件数量是有限的，但是自定义表单控件是无限的，所以 Angular 需要一种通用机制来\x3cstrong\x3e桥接\x3c\/strong\x3e原生\/自定义表单控件和 \x3ccode\x3eformControl\x3c\/code\x3e 指令，而这正是 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/forms\/ControlValueAccessor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eControlValueAccessor\x3c\/code\x3e\x3c\/a\x3e\x3c\/strong\x3e 干的事情。这个对象桥接原生表单控件和 \x3ccode\x3eformControl\x3c\/code\x3e 指令，并同步两者的值。官方文档是这么描述的（译者注：为清晰理解，该描述不翻译）：\x3c\/p\x3e\n\x3cblockquote\x3e\x26nbsp;ControlValueAccessor\x26nbsp;acts as a bridge between the Angular forms API and a native element in the DOM.\x3c\/blockquote\x3e\n\x3cp\x3e任何一个组件或指令都可以通过实现 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口并注册为 \x3ccode\x3eNG_VALUE_ACCESSOR\x3c\/code\x3e，从而转变成 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 类型的对象，稍后我们将一起看看如何做。另外，这个接口还定义两个重要方法——\x3ccode\x3ewriteValue\x3c\/code\x3e 和 \x3ccode\x3eregisterOnChange\x3c\/code\x3e （译者注：可查看 Angular 源码\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/control_value_accessor.ts\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这一行\x3c\/a\x3e\x3c\/strong\x3e）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface ControlValueAccessor {\n  writeValue(obj: any): void\n  registerOnChange(fn: any): void\n  registerOnTouched(fn: any): void\n  ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eControlValueAccessor\x3c\/span\x3e {\x3c\/span\x3e\n  writeValue(\x3cspan class=\x22hljs-string\x22\x3eobj:\x3c\/span\x3e any): \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n  registerOnChange(\x3cspan class=\x22hljs-string\x22\x3efn:\x3c\/span\x3e any): \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n  registerOnTouched(\x3cspan class=\x22hljs-string\x22\x3efn:\x3c\/span\x3e any): \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n  ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eformControl\x3c\/code\x3e 指令使用 \x3ccode\x3ewriteValue\x3c\/code\x3e 方法设置原生表单控件的值（译者注：你可能会参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/reactive_directives\/form_control_directive.ts#L186\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL186\x3c\/a\x3e\x3c\/strong\x3e 和 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L41\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL41\x3c\/a\x3e\x3c\/strong\x3e）；使用 \x3ccode\x3eregisterOnChange\x3c\/code\x3e 方法来注册由每次原生表单控件值更新时触发的回调函数（译者注：你可能会参考这三行，\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/reactive_directives\/form_control_directive.ts#L186\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL186\x3c\/a\x3e\x3c\/strong\x3e 和 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L43\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL43\x3c\/a\x3e\x3c\/strong\x3e，以及 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L85\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL85\x3c\/a\x3e\x3c\/strong\x3e），\x3cstrong\x3e你需要把更新的值传给这个回调函数，这样对应的 Angular 表单控件值也会更新\x3c\/strong\x3e（译者注：这一点可以参考 Angular 它自己写的 \x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 的写法是如何把 input 控件每次更新值传给回调函数的，\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/default_value_accessor.ts#L52\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL52\x3c\/a\x3e\x3c\/strong\x3e 和 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/default_value_accessor.ts#L89\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL89\x3c\/a\x3e\x3c\/strong\x3e）；使用 \x3ccode\x3eregisterOnTouched\x3c\/code\x3e 方法来注册用户和控件交互时触发的回调（译者注：你可能会参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L95\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL95\x3c\/a\x3e\x3c\/strong\x3e）。\x3c\/p\x3e\n\x3cp\x3e下图是 \x3ccode\x3eAngular 表单控件\x3c\/code\x3e 如何通过 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 来和\x3ccode\x3e原生表单控件\x3c\/code\x3e交互的（译者注：\x3ccode\x3eformControl\x3c\/code\x3e 和\x3cstrong\x3e你写的或者 Angular 提供的 \x3ccode\x3eCustomControlValueAccessor\x3c\/code\x3e\x3c\/strong\x3e 两个都是要绑定到 native DOM element 的指令，而 \x3ccode\x3eformControl\x3c\/code\x3e 指令需要借助 \x3ccode\x3eCustomControlValueAccessor\x3c\/code\x3e 指令\/组件，来和 native DOM element 交换数据。）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV7rSH?w=684\x26amp;h=188\x22 src=\x22https:\/\/static.alili.tech\/img\/bV7rSH?w=684\x26amp;h=188\x22 alt=\x22angular_form_control-controlValueAccessor-native_form_control\x22 title=\x22angular_form_control-controlValueAccessor-native_form_control\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e再次强调，不管是使用响应式表单显式创建还是使用模板驱动表单隐式创建，\x3ccode\x3eControlValueAccessor\x3c\/code\x3e 都总是和 Angular 表单控件进行交互。\x3c\/p\x3e\n\x3cp\x3eAngular 也为所有原生 DOM 表单元素创建了 \x3ccode\x3eAngular\x3c\/code\x3e 表单控件（译者注：Angular 内置的 ControlValueAccessor）：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eAccessor\x3c\/th\x3e\n\x3cth\x3eForm Element\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/default_value_accessor.ts#L47\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDefaultValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3einput,textarea\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/checkbox_value_accessor.ts#L31\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCheckboxControlValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3einput[type=checkbox]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/number_value_accessor.ts#L30\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNumberValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3einput[type=number]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/radio_control_value_accessor.ts#L88\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRadioControlValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3einput[type=radio]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/range_value_accessor.ts\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRangeValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3einput[type=range]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/select_control_value_accessor.ts#L94\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSelectControlValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3eselect\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/select_multiple_control_value_accessor.ts#L74\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSelectMultipleControlValueAccessor\x3c\/a\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3eselect[multiple]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e从上表中可看到，当 Angular 在组件模板中中遇到 \x3ccode\x3einput\x3c\/code\x3e 或 \x3ccode\x3etextarea\x3c\/code\x3e DOM 原生控件时，会使用\x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 指令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27my-app\x27,\n  template: `\n      \x3cinput [formControl]=\x26quot;ctrl\x26quot;\x3e\n  `\n})\nexport class AppComponent {\n  ctrl = new FormControl(3);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27my-app\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n      \x26lt;input [formControl]=\x22ctrl\x22\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent {\n  ctrl = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormControl(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有表单指令，包括上面代码中的 \x3ccode\x3eformControl\x3c\/code\x3e 指令，都会调用 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L35\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esetUpControl\x3c\/a\x3e\x3c\/strong\x3e 函数来让表单控件和\x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 实现交互（译者注：意思就是上面代码中绑定的 \x3ccode\x3eformControl\x3c\/code\x3e 指令，在其自身实例化时，会调用 \x3ccode\x3esetUpControl()\x3c\/code\x3e 函数给同样绑定到 \x3ccode\x3einput \x3c\/code\x3e 的 \x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 指令做好安装工作，如  \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L85\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL85\x3c\/a\x3e\x3c\/strong\x3e，这样 \x3ccode\x3eformControl\x3c\/code\x3e 指令就可以借助 \x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 来和 \x3ccode\x3einput\x3c\/code\x3e 元素交换数据了）。细节可参考 \x3ccode\x3eformControl\x3c\/code\x3e 指令的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class FormControlDirective ... {\n  ...\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._isControlChanged(changes)) {\n      setUpControl(this.form, this);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e FormControlDirective ... {\n  ...\n  ngOnChanges(changes: SimpleChanges): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._isControlChanged(changes)) {\n      setUpControl(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.form, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还有 \x3ccode\x3esetUpControl\x3c\/code\x3e 函数源码也指出了原生表单控件和 Angular 表单控件是如何数据同步的（译者注：作者贴的可能是 Angular v4.x 的代码，v5 有了点小小变动，但基本相似）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function setUpControl(control: FormControl, dir: NgControl) {\n  \n  \/\/ initialize a form control\n  \/\/ 调用 writeValue() 初始化表单控件值\n  dir.valueAccessor.writeValue(control.value);\n  \n  \/\/ setup a listener for changes on the native control\n  \/\/ and set this value to form control\n  \/\/ 设置原生控件值更新时监听器，每当原生控件值更新，Angular 表单控件值也更新\n  valueAccessor.registerOnChange((newValue: any) =\x3e {\n    control.setValue(newValue, {emitModelToViewChange: false});\n  });\n\n  \/\/ setup a listener for changes on the Angular formControl\n  \/\/ and set this value to the native control\n  \/\/ 设置 Angular 表单控件值更新监听器，每当 Angular 表单控件值更新，原生控件值也更新\n  control.registerOnChange((newValue: any, ...) =\x3e {\n    dir.valueAccessor.writeValue(newValue);\n  });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetUpControl\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtrol: FormControl, dir: NgControl\x3c\/span\x3e) \x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize a form control\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 writeValue() 初始化表单控件值\x3c\/span\x3e\n  dir.valueAccessor.writeValue(control.value);\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ setup a listener for changes on the native control\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ and set this value to form control\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置原生控件值更新时监听器，每当原生控件值更新，Angular 表单控件值也更新\x3c\/span\x3e\n  valueAccessor.registerOnChange(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    control.setValue(newValue, {emitModelToViewChange: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e});\n  });\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ setup a listener for changes on the Angular formControl\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ and set this value to the native control\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置 Angular 表单控件值更新监听器，每当 Angular 表单控件值更新，原生控件值也更新\x3c\/span\x3e\n  control.registerOnChange(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, ...\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    dir.valueAccessor.writeValue(newValue);\n  });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e只要我们理解了内部机制，就可以实现我们自定义的 Angular 表单控件了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e组件封装器\x3c\/h2\x3e\n\x3cp\x3e由于 Angular 为所有默认原生控件提供了控件值访问器，所以在封装第三方插件或组件时，需要写一个新的控件值访问器。我们将使用上文提到的 jQuery UI 库的 \x3cstrong\x3e\x3ca href=\x22https:\/\/jqueryui.com\/slider\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eslider\x3c\/a\x3e\x3c\/strong\x3e 插件，来实现一个自定义表单控件吧。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e简单的封装器\x3c\/h3\x3e\n\x3cp\x3e最基础实现是通过简单封装使其能在屏幕上显示出来，所以我们需要一个 \x3ccode\x3eNgxJquerySliderComponent\x3c\/code\x3e 组件，并在其模板里渲染出 \x3ccode\x3eslider\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27ngx-jquery-slider\x27,\n  template: `\n      \x3cdiv #location\x3e\x3c\/div\x3e\n  `,\n  styles: [\x27div {width: 100px}\x27]\n})\nexport class NgxJquerySliderComponent {\n  @ViewChild(\x27location\x27) location;\n  widget;\n  ngOnInit() {\n    this.widget = $(this.location.nativeElement).slider();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27ngx-jquery-slider\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n      \x26lt;div #location\x26gt;\x26lt;\/div\x26gt;\n  `\x3c\/span\x3e,\n  styles: [\x3cspan class=\x22hljs-string\x22\x3e\x27div {width: 100px}\x27\x3c\/span\x3e]\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e NgxJquerySliderComponent {\n  \x3cspan class=\x22hljs-meta\x22\x3e@ViewChild\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27location\x27\x3c\/span\x3e) location;\n  widget;\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget = $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.location.nativeElement).slider();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们使用标准的 \x3ccode\x3ejQuery\x3c\/code\x3e 方法在原生 DOM 元素上创建一个 \x3ccode\x3eslider\x3c\/code\x3e 控件，然后使用 \x3ccode\x3ewidget\x3c\/code\x3e 属性引用这个控件。\x3c\/p\x3e\n\x3cp\x3e一旦简单封装好了 \x3ccode\x3eslider\x3c\/code\x3e 组件，我们就可以在父组件模板里使用它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27my-app\x27,\n  template: `\n      \x3ch1\x3eHello \x22{{\x22name\x22}}\x22\x3c\/h1\x3e\n      \x3cngx-jquery-slider\x3e\x3c\/ngx-jquery-slider\x3e\n  `\n})\nexport class AppComponent { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27my-app\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n      \x26lt;h1\x26gt;Hello \x22{{\x22name\x22}}\x22\x26lt;\/h1\x26gt;\n      \x26lt;ngx-jquery-slider\x26gt;\x26lt;\/ngx-jquery-slider\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent { ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了运行程序我们需要加入 \x3ccode\x3ejQuery\x3c\/code\x3e 相关依赖，简化起见，在 \x3ccode\x3eindex.html\x3c\/code\x3e 中添加全局依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;https:\/\/code.jquery.com\/jquery-3.2.1.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript src=\x26quot;https:\/\/code.jquery.com\/ui\/1.12.1\/jquery-ui.js\x26quot;\x3e\x3c\/script\x3e\n\x3clink rel=\x26quot;stylesheet\x26quot; href=\x26quot;\/\/code.jquery.com\/ui\/1.12.1\/themes\/smoothness\/jquery-ui.css\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/code.jquery.com\/jquery-3.2.1.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/code.jquery.com\/ui\/1.12.1\/jquery-ui.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3elink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22stylesheet\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\/code.jquery.com\/ui\/1.12.1\/themes\/smoothness\/jquery-ui.css\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里是安装依赖的\x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/OyCXMLwVcWQelO1en9tR?p=preview\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e交互式表单控件\x3c\/h3\x3e\n\x3cp\x3e上面的实现还不能让我们自定义的 \x3ccode\x3eslider\x3c\/code\x3e 控件与父组件交互，所以还得使用输入\/输出绑定来是实现组件间数据通信：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class NgxJquerySliderComponent {\n  @ViewChild(\x27location\x27) location;\n  @Input() value;\n  @Output() private valueChange = new EventEmitter();\n  widget;\n\n  ngOnInit() {\n    this.widget = $(this.location.nativeElement).slider();   \n    this.widget.slider(\x27value\x27, this.value);\n    this.widget.on(\x27slidestop\x27, (event, ui) =\x3e {\n      this.valueChange.emit(ui.value);\n    });\n  }\n\n  ngOnChanges() {\n    if (this.widget \x26amp;\x26amp; this.widget.slider(\x27value\x27) !== this.value) {\n      this.widget.slider(\x27value\x27, this.value);\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e NgxJquerySliderComponent {\n  \x3cspan class=\x22hljs-meta\x22\x3e@ViewChild\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27location\x27\x3c\/span\x3e) location;\n  \x3cspan class=\x22hljs-meta\x22\x3e@Input\x3c\/span\x3e() value;\n  \x3cspan class=\x22hljs-meta\x22\x3e@Output\x3c\/span\x3e() \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e valueChange = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EventEmitter();\n  widget;\n\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget = $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.location.nativeElement).slider();   \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.slider(\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.on(\x3cspan class=\x22hljs-string\x22\x3e\x27slidestop\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent, ui\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.valueChange.emit(ui.value);\n    });\n  }\n\n  ngOnChanges() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.slider(\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e) !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.slider(\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value);\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一旦 \x3ccode\x3eslider\x3c\/code\x3e 组件创建，就可以订阅 \x3ccode\x3eslidestop\x3c\/code\x3e 事件获取变化的值，一旦 \x3ccode\x3eslidestop\x3c\/code\x3e 事件被触发了，就可以使用输出事件发射器 \x3ccode\x3evalueChanges\x3c\/code\x3e 通知父组件。当然我们也可以使用 \x3ccode\x3engOnChanges\x3c\/code\x3e 生命周期钩子来追踪输入属性 \x3ccode\x3evalue\x3c\/code\x3e 值的变化，一旦其值变化，我们就将该值设置为 \x3ccode\x3eslider\x3c\/code\x3e 控件的值。\x3c\/p\x3e\n\x3cp\x3e然后就是父组件中如何使用 \x3ccode\x3eslider\x3c\/code\x3e 组件的代码实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cngx-jquery-slider\n    [value]=\x26quot;sliderValue\x26quot;\n    (valueChange)=\x26quot;onSliderValueChange($event)\x26quot;\x3e\n\x3c\/ngx-jquery-slider\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x26lt;ngx-jquery-slider\n    [value]=\x3cspan class=\x22hljs-string\x22\x3e\x22sliderValue\x22\x3c\/span\x3e\n    (valueChange)=\x3cspan class=\x22hljs-string\x22\x3e\x22onSliderValueChange($event)\x22\x3c\/span\x3e\x26gt;\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/ngx-jquery-slider\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/bCrkvABQkRZXrnVvTW7D?p=preview\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e\x3c\/strong\x3e在这里。\x3c\/p\x3e\n\x3cp\x3e但是，我们想要的是，使用 \x3ccode\x3eslider\x3c\/code\x3e 组件作为表单的一部分，并使用模板驱动表单或响应式表单的指令与其数据通信，那就需要让其实现 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口了。由于我们将实现的是新的组件通信方式，所以不需要标准的输入输出属性绑定方式，那就移除相关代码吧。（译者注：作者先实现标准的输入输出属性绑定的通信方式，又要删除，主要是为了引入\x3cstrong\x3e新的表单组件交互方式\x3c\/strong\x3e，即 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e。）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e实现自定义控件值访问器\x3c\/h2\x3e\n\x3cp\x3e实现自定义控件值访问器并不难，只需要两步：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e注册 \x3ccode\x3eNG_VALUE_ACCESSOR\x3c\/code\x3e 提供者\x3c\/li\x3e\n\x3cli\x3e实现 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3eNG_VALUE_ACCESSOR\x3c\/code\x3e 提供者用来指定实现了 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口的类，并且被 Angular 用来和 \x3ccode\x3eformControl\x3c\/code\x3e 同步，通常是使用组件类或指令来注册。所有表单指令都是使用\x3ccode\x3eNG_VALUE_ACCESSOR\x3c\/code\x3e 标识来注入控件值访问器，然后选择合适的访问器（译者注：这句话可参考这两行代码，\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/reactive_directives\/form_control_directive.ts#L175\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL175\x3c\/a\x3e\x3c\/strong\x3e 和 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/reactive_directives\/form_control_directive.ts#L181\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL181\x3c\/a\x3e\x3c\/strong\x3e）。要么选择\x3ccode\x3eDefaultValueAccessor\x3c\/code\x3e 或者内置的数据访问器，否则 Angular 将会选择自定义的数据访问器，并且有且只有一个自定义的数据访问器（译者注：这句话参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L186\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eselectValueAccessor\x3c\/code\x3e 源码实现\x3c\/a\x3e\x3c\/strong\x3e）。\x3c\/p\x3e\n\x3cp\x3e让我们首先定义提供者：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27ngx-jquery-slider\x27,\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: NgxJquerySliderComponent,\n    multi: true\n  }]\n  ...\n})\nclass NgxJquerySliderComponent implements ControlValueAccessor {...}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e@\x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e({\n  selector: \x27ngx-jquery-slider\x27,\n  providers: [{\n    provide: \x3cspan class=\x22hljs-type\x22\x3eNG_VALUE_ACCESSOR\x3c\/span\x3e,\n    useExisting: \x3cspan class=\x22hljs-type\x22\x3eNgxJquerySliderComponent\x3c\/span\x3e,\n    multi: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }]\n  ...\n})\nclass \x3cspan class=\x22hljs-type\x22\x3eNgxJquerySliderComponent\x3c\/span\x3e implements \x3cspan class=\x22hljs-type\x22\x3eControlValueAccessor\x3c\/span\x3e \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们直接在组件装饰器里直接指定类名，然而 Angular 源码默认实现是放在类装饰器外面：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const DEFAULT_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() =\x3e DefaultValueAccessor),\n  multi: true\n};\n@Directive({\n  selector:\x27input\x27,\n  providers: [DEFAULT_VALUE_ACCESSOR]\n  ...\n})\nexport class DefaultValueAccessor implements ControlValueAccessor {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e DEFAULT_VALUE_ACCESSOR: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e DefaultValueAccessor),\n  multi: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-meta\x22\x3e@Directive\x3c\/span\x3e({\n  selector:\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e,\n  providers: [DEFAULT_VALUE_ACCESSOR]\n  ...\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e DefaultValueAccessor \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e ControlValueAccessor {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e放在外面就需要使用 \x3ccode\x3eforwardRef\x3c\/code\x3e，关于原因可以参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angularindepth.com\/what-is-forwardref-in-angular-and-why-we-need-it-6ecefb417d48\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWhat is forwardRef in Angular and why we need it\x3c\/a\x3e\x3c\/strong\x3e 。当实现自定义 \x3ccode\x3econtrolValueAccessor\x3c\/code\x3e，我建议还是放在类装饰器里吧（译者注：个人建议还是学习 Angular 源码那样放在外面）。\x3c\/p\x3e\n\x3cp\x3e一旦定义了提供者后，就让我们实现 \x3ccode\x3econtrolValueAccessor\x3c\/code\x3e 接口：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class NgxJquerySliderComponent implements ControlValueAccessor {\n  @ViewChild(\x27location\x27) location;\n  widget;\n  onChange;\n  value;\n  \nngOnInit() {\n    this.widget = $(this.location.nativeElement).slider(this.value);\n   this.widget.on(\x27slidestop\x27, (event, ui) =\x3e {\n      this.onChange(ui.value);\n    });\n}\n  \nwriteValue(value) {\n    this.value = value;\n    if (this.widget \x26amp;\x26amp; value) {\n      this.widget.slider(\x27value\x27, value);\n    }\n  }\n  \nregisterOnChange(fn) { this.onChange = fn;  }\n\nregisterOnTouched(fn) {  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e NgxJquerySliderComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e ControlValueAccessor {\n  \x3cspan class=\x22hljs-meta\x22\x3e@ViewChild\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27location\x27\x3c\/span\x3e) location;\n  widget;\n  onChange;\n  value;\n  \nngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget = $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.location.nativeElement).slider(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value);\n   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.on(\x3cspan class=\x22hljs-string\x22\x3e\x27slidestop\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent, ui\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onChange(ui.value);\n    });\n}\n  \nwriteValue(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget \x26amp;\x26amp; value) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.widget.slider(\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e, value);\n    }\n  }\n  \nregisterOnChange(fn) { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onChange = fn;  }\n\nregisterOnTouched(fn) {  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于我们对用户是否与组件交互不感兴趣，所以先把 \x3ccode\x3eregisterOnTouched\x3c\/code\x3e 置空吧。在\x3ccode\x3eregisterOnChange\x3c\/code\x3e 里我们简单保存了对回调函数 \x3ccode\x3efn\x3c\/code\x3e 的引用，回调函数是由 \x3ccode\x3eformControl\x3c\/code\x3e 指令传入的（译者注：参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/forms\/src\/directives\/shared.ts#L85\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eL85\x3c\/a\x3e\x3c\/strong\x3e），只要每次 \x3ccode\x3eslider\x3c\/code\x3e 组件值发生改变，就会触发这个回调函数。在 \x3ccode\x3ewriteValue\x3c\/code\x3e 方法内我们把得到的值传给 \x3ccode\x3eslider\x3c\/code\x3e 组件。\x3c\/p\x3e\n\x3cp\x3e现在我们把上面描述的功能做成一张交互式图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV7rTf?w=762\x26amp;h=257\x22 src=\x22https:\/\/static.alili.tech\/img\/bV7rTf?w=762\x26amp;h=257\x22 alt=\x22jQuery_slider-slider_component-form_control\x22 title=\x22jQuery_slider-slider_component-form_control\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果你把简单封装和 \x3ccode\x3econtrolValueAccessor\x3c\/code\x3e 封装进行比较，你会发现父子组件交互方式是不一样的，尽管封装的组件与 \x3ccode\x3eslider\x3c\/code\x3e 组件的交互是一样的。你可能注意到 \x3ccode\x3eformControl\x3c\/code\x3e 指令实际上简化了与父组件交互的方式。这里我们使用 \x3ccode\x3ewriteValue\x3c\/code\x3e 来向子组件写入数据，而在简单封装方法中使用 \x3ccode\x3engOnChanges\x3c\/code\x3e；调用 \x3ccode\x3ethis.onChange\x3c\/code\x3e 方法输出数据，而在简单封装方法中使用 \x3ccode\x3ethis.valueChange.emit(ui.value)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e现在，实现了 \x3ccode\x3eControlValueAccessor\x3c\/code\x3e 接口的自定义 \x3ccode\x3eslider\x3c\/code\x3e 表单控件完整代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27my-app\x27,\n  template: `\n      \x3ch1\x3eHello \x22{{\x22name\x22}}\x22\x3c\/h1\x3e\n      \x3cspan\x3eCurrent slider value: \x22{{\x22ctrl.value\x22}}\x22\x3c\/span\x3e\n      \x3cngx-jquery-slider [formControl]=\x26quot;ctrl\x26quot;\x3e\x3c\/ngx-jquery-slider\x3e\n      \x3cinput [value]=\x26quot;ctrl.value\x26quot; (change)=\x26quot;updateSlider($event)\x26quot;\x3e\n  `\n})\nexport class AppComponent {\n  ctrl = new FormControl(11);\n\n  updateSlider($event) {\n    this.ctrl.setValue($event.currentTarget.value, {emitModelToViewChange: true});\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e@Component({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27my-app\x27\x3c\/span\x3e,\n  template: `\n      \x26lt;h1\x26gt;Hello \x22{{\x22name\x22}}\x22\x26lt;\/h1\x26gt;\n      \x26lt;span\x26gt;Current slider \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: \x22{{\x22ctrl.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x22}}\x22\x26lt;\/span\x26gt;\n      \x26lt;ngx-jquery-slider [formControl]=\x3cspan class=\x22hljs-string\x22\x3e\x22ctrl\x22\x3c\/span\x3e\x26gt;\x26lt;\/ngx-jquery-slider\x26gt;\n      \x26lt;input [\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e]=\x3cspan class=\x22hljs-string\x22\x3e\x22ctrl.value\x22\x3c\/span\x3e (change)=\x3cspan class=\x22hljs-string\x22\x3e\x22updateSlider($event)\x22\x3c\/span\x3e\x26gt;\n  `\n})\nexport \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppComponent\x3c\/span\x3e {\n  ctrl = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormControl(\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e);\n\n  updateSlider($\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctrl.setValue($\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.currentTarget.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, {emitModelToViewChange: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e});\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可以查看程序的\x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/c3tUH819er2gA9ertQS6?p=preview\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e最终实现\x3c\/a\x3e\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eGithub\x3c\/h2\x3e\n\x3cp\x3e项目的 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/maximusk\/custom-form-control-that-implements-control-value-accessor-and-wraps-jquery-slider\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub 仓库\x3c\/a\x3e\x3c\/strong\x3e。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] 别再对 Angular 表单的 ControlValueAccessor 感到迷惑</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014129567">https://segmentfault.com/a/1190000014129567</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7tkdo3rjtiq/" target="_blank">https://alili.tech/archive/7tkdo3rjtiq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>