<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端知识点总结——ReactNative"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端知识点总结——ReactNative | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/8chgtjyddxr/",
				"appid": "1613049289050283", 
				"title": "前端知识点总结——ReactNative | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/j95hq2a5mla/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/g8zdxs4e5o/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&text=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&text=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8chgtjyddxr%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94ReactNative"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端知识点总结——ReactNative</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2\x3e一、ReactNative概述\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e移动端开发的3种常见模式：\n    1、WebApp\n        理解1：\n            通过前端技术 编写的可以运行在手机浏览器端的网页，\n            提供的用户体验 类似于app用户体验\n            --》WebApp\n        理解2：\n            结合着前端技术 加上原生开发时WebView组件，\n            生成的应用程序 --》WebApp\n        \n        优势：跨平台\n    2、NativeApp\n            调用官方所提供的SDK（software develop kit）\n            中的控件来编程，\n            而生成的可以直接安装在手机操作系统的app --》NativeApp\n        优势：良好的性能\n\n    3、HybridApp\n        混合编程 结合着前端代码和原生开发技术混合编程而生成的，\n      可以直接安装在手机操作系统的app\n        ---》 HybridApp\n        \n\n1、what？\n    ReactNative是为了实现原生移动端开发的，基于React的框架\n    \n    ReactNative的工作原理：\n        ReactNative封装了很多的组件，\n     而这些组件在调用时是通过js和react的语法调用，调用之后，\n     编译成真正的SDK的控件\n\n    RN最大的特点：\n        将各种各样的SDK中提供的原生控件，封装成一些可以通过js去调用的React中组件\n        View都会直接对应一个平台的原生视图，无论它是UIView、\n       \x26lt;div\x26gt;还是android.view.View\n\n2、why？\n        free\n        开发成本很低\n        开发的移动端的原生应用程序，性能很好\n\n3、where？\n    前端开发人员可以使用RN来实现原生移动端App的开发\n\n开发理念：\n    learn once, write anywhere\n\n4、how？\n    环境的搭建：\n        方案1：\n                \/\/安装一个叫做create-react-native-app的包\n             npm install -g create-react-native-app\n             \/\/创建一个有reactNative模板的项目\n             create-react-native-app my-app\n             \/\/进入到工程\n             cd my-app\/\n             \/\/启动开发服务器\n             npm start\n        方案2：（课堂）\n            npm install react-native-cli\n            react-native init my-app\n            cd my-app\n            npm install\n            npm start\n\n\n    ①pc端 \n    执行reactNative官方所提供的代码，启动开发服务器（npm start）\n    ②mobile端\n        安装蓝叠模拟器\n        启动模拟器\n        安装了app-debug.apk 可以去配置要连接的服务器的地址和端口号\n\n        预览\n\n    具体步骤：\n        ①将myapp_no_install.rar拷贝到 \n         C:\\xampp\\htdocs\\13_FRAMEWORK\\react\\rn文件夹\n        ②将压缩包解压缩到当前文件夹\n        ③将node_modules.rar\n        拷贝到C:\\xampp\\htdocs\\13_FRAMEWORK\\react\\rn文件夹\n        ④将node_modules.rar压缩包解压缩到当前文件夹\n        ⑤打开vscode,点击左上角的文件，选择打开文件夹，找到\n        C:\\xampp\\htdocs\\13_FRAMEWORK\\react\\rn，打开\n        ⑥打开集成终端(ctr\x2b`),npm start,启动一个服务器，\n         占用的端口号默认是8081\n\n        \n        移动端：\n            ①打开蓝叠模拟器\n            ②安装myapp到 \n    C:\\xampp\\htdocs\\13_FRAMEWORK\\react\\rn\\android\n     \\app\\build\\outputs\\apk文件夹中，\n            找到app-debug.apk，将这个文件拖拽到蓝叠中进行安装\n            ③在蓝叠中打开myapp，设置要连接的pc端的host和port\n            \n            windows\x2bR -\x26gt; cmd -\x26gt;ipconfig -》ipv4的地址\n            172.173.100.97\n            8081\n\n            按下shake（摇一摇），在弹出菜单中，找到最下边dev settings并点击，\n            在新的弹出菜单中，选中debug server host \x26amp; port并点击，\n            输入当前pc端的ip地址和8081，点击确定，返回，reload\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e二、ReactNative组件的创建和使用\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e\n组件统一放在RN项目中app\/components\/\n\n1、创建组件\n    import React,{Component} from \x27react\x27;\n    import {Text} from \x27react-native\x27;\n    \n    export default class Demo01Component extends Component{\n\n        render:function(){\n            return \x26lt;Text\x26gt;Hello\x26lt;\/Text\x26gt;\n        }\n    }\n2、其它组件中使用组件\n    import Demo01Component from\x27.\/app\/components\/demo01\/demo01\x27\n\n    \x26lt;Demo01Component\x26gt;\x26lt;\/Demo01Component\x26gt;\n\n在ReactNative中的开发过程中，使用ReactJS学习到的各种概念（React）,\n符合官方的slogen: learn once,write anywhere(学习一次React，就可以在各个平台编写)\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e三、ReactNative提供的组件\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3eText\n    作为一个文本段落使用\nStyleSheet\n    ①先引入StyleSheet\n    ②创建样式类\n        const myStyles = StyleSheet.create({\n            myText:{},\n            myView:{}\n        })\n    ③使用\n        \x26lt;Text style={myStyles.myText}\x26gt;\x26lt;\/Text\x26gt;\n\nView\n    作为一个容器去使用\n\nImage\n    ① 引入组件类\n        import {Image} from \x27react-native\x27\n    ②调用\n        加载本地的图片\n        \x26lt;Image source={require(\x27..\/*.png\x27)}\x26gt;\x26lt;\/Image\x26gt;\n        加载服务器端的图片\n        \x26lt;Image source=\x22{{\x22uri:\x27imgUrl\x27\x22}}\x22\x26gt;\x26lt;\/Image\x26gt;\n\n\n    注意事项：在引入本地资源图片时，不允许在require方法中出现任何的运算\n\nButton    \n    ①引入\n        import {Button} from \x27react-native\x27\n    ②调用\n        \x26lt;Button title=\x22\x22 onPress={this.handlePress}\x26gt;\x26lt;\/Button\x26gt;\n\nstate\n    三个基本操作\n        ①初始化\n            constructor(){\n                super();\n                this.state = {\n                    count:1,\n                    value:2\n                }\n            }\n        ②读操作\n            this.state.count\n        ③写操作\n            this.setState({count:2})\n\nlifecycle\n    处理函数依然可以正常使用\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e补充：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e1、如何查看在控制台的输出\n    shake 按下菜单键--》弹出菜单--》Debug JS Remotely\n    默认打开浏览器的标签页 f12\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e四、ReactNative封装的组件\x3c\/h2\x3e\n\x3cp\x3e1、FlatList、\x3c\/p\x3e\n\x3cp\x3e高性能的列表组件\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e要将一个数组 渲染到列表的话：①渲染什么数据 ②列表显示什么内容\n\n具体步骤：\n    ①import {FlatList} from \x27react-native\x27\n\n    ②\x26lt;FlatList \x26gt;\x26lt;\/FlatList\x26gt;\n\n    ③准备FlatList要用到的数据，并通过data属性 指定要渲染的数据\n    \x26lt;FlatList data={[\x22zhangsan\x22,\x22lisi\x22,\x22wanger\x22]}\x26gt;\x26lt;\/FlatList\x26gt;\n\n    ④通过renderItem去指定 要将数据渲染在什么样的组件中\n\n    \x26lt;FlatList \n    renderItem={(info)=\x26gt;{return \x26lt;Text\x26gt;{info.item}\x26lt;\/Text\x26gt;\x22}}\x22\n    data={[\x22zhangsan\x22,\x22lisi\x22,\x22wanger\x22]}\x26gt;\x26lt;\/FlatList\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、TextInput\x3cbr\x3e表单的输入框的组件\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e基本步骤\n    ①import {TextInput} from \x27react-native\x27\n    ②\x26lt;TextInput\x26gt;\x26lt;\/TextInput\x26gt;\n    ③onChangeText={(text)=\x26gt;{\/\/text就是当前输入框中的值\x22}}\x22\n    TextInput的onChangeText的事件处理函数是有参数！\n    ④TextInput是支持常用的属性\n        secureTextEntry={true}\n        keyboardType=\x22numeric\x22\n        placeholder=\x22\x22\n        placeholderTextColor=\x22green\x22\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、TouchableOpacity\x3cbr\x3e将需要添加上点按,透明度渐变效果的组件放在TouchableOpacity中\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e具体步骤\n    ①import {TouchableOpacity} from \x27react-native\x27\n    ② \x26lt;TouchableOpacity onPress={this.handlePress}\x26gt;\n        \x26lt;Text\x26gt;\x26lt;\/Text\x26gt;\n    \x26lt;\/TouchableOpacity\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4、fetch\x3cbr\x3eAngular中发起网络请求：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e①创建一个服务\n②Http Response\n    sendRequest(myUrl:string){\n        return this.http.get(myUrl, \n      {withCredentials:true}).map((response:Response)=\x26gt;{\n            return response.json()\n        })\n    }\n\n③服务要指定提供商 providers\n④调用\n    import \n    实例化\n    this.myHS.sendRequest().subscribe(()=\x26gt;{})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue中发起网络请求：\x3cbr\x3e vue-resource\x3cbr\x3e this.$http.get().then()\x3c\/p\x3e\n\x3cp\x3eReactNative\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3efetch可以实现与远程服务器端的交互\n\n    fetch(\x27\x27)\n        .then((response)=\x26gt;{return response.json()})\n        .then((result)=\x26gt;{\/\/result就是服务器端返回的真正的数据})\n\n    \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5、ScrollView\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e当前的视图中，如果要渲染的组件，放在一起，高度假设超过了屏幕的高度，\n可以指定scrollView添加上下滚动的效果\n     基本步骤：\n        ①引入\n            import {ScrollView} from \x27react-native\x27\n        ②将ScrollView作为一个容器去调用\n            \x26lt;ScrollView\x26gt;                \n            \x26lt;\/ScrollView\x26gt;\n\n对于表单受控元素：\n    ①初始化状态\n    ②将状态绑定value属性\n    ③在onValueChange事件处理函数中 修改状态\n\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e6、Switch\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\n    这是一个受控的表单元素\n     基本步骤：\n        ①import {Switch} from \x27react-native\x27\n        ②\x26lt;Switch\x26gt;\x26lt;\/Switch\x26gt;\n        ③指定value属性 onValueChange绑定事件处理函数\n        搞定受控表单元素\n  Text\/View\/Button\/TextInput\/Switch\/StyleSheet\n  FlatList\/TouchableOpacity\/ScrollView\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e7、Flexbox\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e在ReactNative的开发中，使用Flexbox 弹性盒子进行布局。\n    flexDirectiion 指定主轴的方向 row\/column\n    justifyContent 指定子元素沿着主轴的对齐方式\n    alignItems     指定子元素沿着次轴的对齐方式\n    \n    注意事项：在ReactNative中，主轴沿着纵向（column）\n\n\n目标：使用ReactNative所封装的各种组件，来实现原生的app：ToDoBox\n\n实现：\n    1.在app\/components\/todobox的文件夹\n    在这个文件夹中，去创建\n    todobox.js ToDoBoxComponent\n    todoinput.js ToDoInputComponent\n    todolist.js ToDoListComponent\n    todoitem.js ToDoItemComponent\n\n    2.完成各个组件的模板内容的指定\n\n    3.添加\n    4.删除\n\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在实现ToDoBox的过程中，将数据发给了ToDoList，\x3cbr\x3e在渲染FlatList的过程中遇到了两个问题：\x3c\/p\x3e\n\x3cp\x3e①ToDoList接收到通过属性传来的值，将值设置为最新的状态\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e选择是componentWillReceiveProps指定接收最新的属性的值 并更新状态\n\n不要使用和update相关的处理函数，否则会stackSize\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e②FlatList的data属性对应的状态 发生变化时，视图却没有更新\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e指定了extraData={this.state}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e③FlatList在渲染列表项，指定key，解决警告问题\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e将一个字符串数组 改造成一个对象数组，在对象中只需要指定key的属性就可以\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e删除功能：（10\x2250 -11\x2205）\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e当点击todoitem中的删除button时，实现从todobox中删除一个指定位置的元素 \n    ①在todobox中定义一个带有参数的方法\n    ②将方法先传递给todolist\n    ③将方法通过todolist传递给todoitem\n    ④todoitem在点击delete按钮时，调用传递来的方法把当前下标通过方法的参 \n     数传递给todobox\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e五、在ReactNative实现导航(ReactNavigation)\x3c\/h2\x3e\n\x3cp\x3eVue\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evue-router    \n    \n    ①引入要用到的插件\n        \x26lt;script src=\x22js\/vue-router.js\x22\x26gt;\x26lt;\/script\x26gt;\n    \n    ②指定容器\n        router-view\n\n    ③配置路由词典\n        new Vue({\n            router:new VueRouter({\n                routes:[\n                 {path:\x27\x27,component:Login},\n                ]\n            })\n        })\n\n    ④测试\n    url和组件的映射关系\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eAngular\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eRouterModule\n0 router-outlet\n①创建一个文件app.router.ts\n②在app.router.ts中创建一个自定义模块\n    \n    import {RouterModule} from \x27@angular\/router\x27\n    \n    const Routes = [\n        {path:\x27\x27,component:***}\n    ]\n\n    @NgModule({\n        imports:[RouterModule.forRoot(Routes)],\n        exports:[RouterModule]\n    })\n\n    export default class AppRoutingModule{}\n③在app.module.ts，根模块中指定依赖于创建模块\n    import {AppRoutingModule} from \x27.\/app.router\x27\n\n    @NgModule({\n        imports: \n    [BrowserModule,HttpModule,FormsModule,AppRoutingModule]\n    })\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReactNative:\x3cbr\x3e1、基本步骤\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eReactNavigation的使用步骤：\n    ①安装\n        npm install --save react-navigation\n    ②创建要用到的组件\n\n    ③配置路由\n        import {StackNavigator} from \x27react-navigation\x27\n        import CartComponent from \x27***\x27\n        import OrderConfirmComponent from \x27***\x27\n\n        const RootNavigator = StackNavigator({\n            cart:{\n                screen:CartComponent\n            },\n            oc:{\n                screen:OrderConfirmComponent\n            }\n        })\n\n        AppRegistry.registerComponent(\x27myapp\x27, () =\x26gt; RootNavigator);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、跳转\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3ethis.props.navigation.navigate(\x27routeName\x27);\nthis.props.navigation.goBack()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、跳转完成参数的传递\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e传\n    this.props.navigation\n    .navigate(\x27routeName\x27，{price:100});\n收\n    this.props.navigation.state.params.price\n\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e补充：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e①参数的传递\n    jump=(myId)=\x26gt;{\n        this.props.navigation.navigate(\x27detail\x27,{id:myId})\n    }\n\n    showItem=(info)=\x26gt;{\n        return \x26lt;TouchableOpacity onPress={()=\x26gt;{\n            this.jump(info.item.lid)\n        \x22}}\x22\x26gt;\n        \x26lt;\/TouchableOpacity\x26gt;\n    }\n\n②自定义header\n\n    StackNavigator({\n        list:{\n            screen:ListComponent,\n            navigationOptions:()=\x26gt;{\n                return {\n                    headerTitle:\x27\x27,\n                    headerTitleStyle:{}\n                }\n            }\n        }\n    })\n\n③如何来实现一个选择功能？\n    {\n        this.props.isLoading \x26amp;\x26amp; \x26lt;ActivityIndicator\x26gt; \n       \x26lt;\/ActivityIndicator\x26gt;\n    }\n\n④如何来实现一个循环功能\n        {\n            this.props.list.map(function(child){\n                return {Child}\n            })\n        }\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e六、移动的应用程序\x3c\/h2\x3e\n\x3cp\x3e①WebApp 基于网页的，基于浏览器的\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e比如网页版的淘宝，京东\n优势在于强大的跨平台\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e②NativeApp （使用原生开发）\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e原生开发：调用 Google\/Apple所提供的SDK中提供的原生的接口或者服务，\n构建用户的可以安装在手机上执行的安装包，称作为Android\/iOS的原生开发\n直接可以安装在手机的操作系统的app称之为原生的app\n比如安装在手机中的微信\n优势在于良好的性能\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e③HybridApp （使用前端技能）--\x26gt;下周会有详细课程\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e混合编程：混合使用前端开发技能和原生开发技能进行开发而生成的\n可以安装在手机上的安装包\nhtml\/css\/js \x2b 原生Android Webview\/iOS uiWebView\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总结：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e    ①RN中的组件\n        Text\/View\/Button\/TextInput\/FlatList\n        StyleSheet fetch touchableOpacity\n    ②父---\x26gt;子\n        props down\n            步骤1：调用子组件时 通过属性去传值\n            \x26lt;ToDoItem content={info.item}\/\x26gt;\n            步骤2：在子组件中，接收通过属性传来的值\n            render(){\n                return \x26lt;View\x26gt;\n                    \x26lt;Text\x26gt;{this.props.content}\x26lt;\/Text\x26gt;\n                \x26lt;\/View\x26gt;\n            }\n    ③子---\x26gt;父\n        ToDoInput想要给ToDoBox传值\n        步骤1：\n            在ToDoBox中 定义一个带有参数的方法\n            saveMsg(msg){\n                \/\/msg就是父组件希望得到的值\n            }\n        步骤2：\n            在ToDoBox中 调用ToDoInput时 通过属性传递方法\n            \x26lt;ToDoInput funcSave={this.saveMsg}\/\x26gt;\n        步骤3：\n            在ToDoInput中调用传递来的方法并传值\n            this.props.funcSave(123);\n    ④flatList所指定的data发生了变化，但是视图却没有更新\n        \x26lt;FlatList extraData={this.state}\/\x26gt;\n    ⑤当通过属性传递给组件的数据，发生变化时，\n    子组件如何接受这个变化并更新内部的状态？\n        componentWillUpdate\n        componentDidUpdate\n\n        componentWillReceiveProps(允许在内部修改状态的)\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e七、RN的组件\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e1、ActivityIndicator\n    指定一个加载中的图标\n    步骤1：\n        import {ActivityIndicator} from \x27react-native\x27\n    步骤2：\n        \x26lt;ActivityIndictator\/\x26gt;\n\n2、KeyboardAvoidingView\n    作为一个容器去使用，用来解决出现视图被弹出的键盘遮住的问题\n    \n    步骤1：\n    引入\n    步骤2：\n        \x26lt;KeyboardAvoidingView\x26gt;\n            \x26lt;TextInput\/\x26gt;\n            \x26lt;Text\x26gt;\x26lt;\/Text\x26gt;\n        \x26lt;\/KeyboardAvoidingView\x26gt;\n3、switch\n    switch是一个受控组件\n        步骤1：引入\n        步骤2：\n            初始化状态，并将状态中的值 绑定到Switch的value属性上边\n            \x26lt;Switch value={this.state.myValue}\x26gt;\n        步骤3：\n            指定当操作Switch时，设置状态\n            handleChange=(msg)=\x26gt;{\n                this.setState({myValue:msg})\n            }\n            \x26lt;Switch \n            onValueChange={this.handleChange}\n            value={this.state.myValue}\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e八、RN中组件之间的跳转和传参\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e\n复习Vue\/Angular的路由模块的使用方式：\n1、Vue的SPA的实现方式\n    基本步骤：\n        ①引入vue-router.js\n        ②指定容器\n            \x26lt;router-view\x26gt;\x26lt;\/router-view\x26gt;\n        ③创建要用到的组件\n        ④配置路由词典\n            new Vue({\n                router:new VueRouter({\n                    routes:[\n                        {path:\x27\/login\x27,component:LoginComponent},\n                        {path:\x27*\x27,component:NotFound}\n                    ]\n                })\n            })\n    传递参数：\n        ①明确发送方 接收方\n        ②配置接收方的路由地址\n        [\n            {\n                path:\x27\/detail\/:id\x27,\n                component:DetailComponent\n            }\n        ]\n        ③准备接收\n            this.$route.params\n        ④准备发送\n            this.$router.push(\x27\/detail\/10\x27)\n2、Angular实现SPA的基本步骤：\n        ①让AppModule依赖于RouterModule\n        ②指定容器\n            \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n        ③创建要用到的组件\n        ④配置路由词典\n            const myRoutes = [\n                {path:\x27\x27,component:Index},\n                {path:\x27login\x27,component:Login},\n                {path:\x27**\x27,component:NotFound}\n            ]\n\n在ReactNative的开发过程中，会使用React Navigation来实现组件之间的\n跳转和传参\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e九. 基本步骤\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e    步骤1：先去安装\n        npm install --save  react-navigation\n        在安装的同时，会自动的将当前安装的包名称和版本号 \n         写入到当前工程的package.json文件的dependencies\n    步骤2：引入\n        import {StackNavigator} from \x27react-navigation\x27\n\n    步骤3：创建要用到的组件\n\n    步骤4：配置路由词典\n        const RootNavigator = StackNavigator({\n            myList:{screen:ListComponent},\n            myDetail:{Screen:DetailComponent}\n        })\n    步骤5：让路由词典生效\n        AppRegistry.registerComponent(\x27myApp\x27,()=\x26gt;RootNavigator)\n\n2.2 跳转\n    this.props.navigation.navigate(\x27路由地址\x27);\n    举例：\n    this.props.navigation.navigate(\x27myDetail\x27);\n\n\n\n2.3 参数的传递\n    ①明确发送 接收\n        cart--hello world--\x26gt;order\n    ②准备接收\n        this.props.navigation.state.params.id\n    ③准备发送    \n        this.props.navigation\n        .navigate(\x27myDetail\x27,{id:10})\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e十.应用程序：\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3e基本的页面结构\n服务器端的通信\n框架的基本语法\n框架的路由模块\n框架的网络请求模块\n应用内部之间的通信，比如组件间通信、本地数据的处理\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e十一.总结：\x3c\/h2\x3e\n\x3cpre\x3e\x3ccode\x3eReactJS\n    五大核心概念\n        jsx 是允许在js中编写标签的语法，遇到{会用js去解析，遇到\x26lt;会有html或者react去解析\n        component 组件类就是封装好的，带有特定功能，\n        可被反复使用的视图（组件类 要指定模板、指定方法）\n        ref   得到组件的实例\/DOM元素\n        state 管理数据、数据绑定\n        props 组件间通信\n\n    综合练习（todobox、三连棋）\nReactNative\n    (定位是为了实现原生的app，实现原理是所通过js编写或者调用组件类，\n     都会在对应的平台中变成真实的和原生开发一样的SDK中提供的服务或者组件，\n     比如所写View，会变成ios下真实的uiVIew，会变成Android下的Android.View)\n\n    组件的使用\n         Text\/View\/TextInput\/FlatList\/Image\/Button\/AcitivtyIndicator\/\n        TouchableOpacity\/Switch\/KeyboardAvoidingView\/...\n    样式添加\n        StyleSheet.create({\n            myH1:{\n                color:\x27\x27\n            }\n        })\n        FlexBox 弹性盒子\n            flexDirection 指定主轴的方向 row\/column\n            justifyContent 指定沿着主轴方向的对齐方式\n            alignItems  指定沿着次轴方向的对齐方式\n            RN默认的主轴是column\n    与服务器端的通信\n        fetch(myUrl)\n            .then((response)=\x26gt;{response.json()})\n            .then((response)=\x26gt;{\n            \n            })\n    \n    页面跳转传参\n        reactNavigation (StackNavigator)\n\n        步骤：\n            ①安装\n                npm install --save react-navigation\n            ②引入\n                import {StackNavigator} from \x27react-navigation\x27\n            ③创建要用到的组件\n                PayComponent SendComponent\n            ④配置路由词典\n                const RootNavigator = StackNavigator(\n                    myPay:{\n                        screen:PayComponent,\n                        navigationOptions:()=\x26gt;({\n                            headerTitle:\x27\x27,\n                            headerTitleStyle:{},\n                            headerLeft:,\n                            headerRight:.\n                        })\n                    }\n                )\n        跳转：\n            this.props.navigation.navigate(\x27mySend\x27)\n        传递：\n            ①发送、接收\n            ②发送\n    this.props.navigation.navigate(\x27mySend\x27,{id:10})\n            ③接收\n    this.props.navigation.state.params.id\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端知识点总结——ReactNative</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014491274">https://segmentfault.com/a/1190000014491274</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/8chgtjyddxr/" target="_blank">https://alili.tech/archive/8chgtjyddxr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>