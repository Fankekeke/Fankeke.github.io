<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】Redux 还是 Mobx，让我来解决你的困惑！"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】Redux 还是 Mobx，让我来解决你的困惑！ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/8ec99stqhga/",
				"appid": "1613049289050283", 
				"title": "【译】Redux 还是 Mobx，让我来解决你的困惑！ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/74l5m91h0f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/y18wkfg5crg/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&text=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&text=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&title=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&title=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&title=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&title=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ec99stqhga%2f&title=%e3%80%90%e8%af%91%e3%80%91Redux%20%e8%bf%98%e6%98%af%20Mobx%ef%bc%8c%e8%ae%a9%e6%88%91%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bd%a0%e7%9a%84%e5%9b%b0%e6%83%91%ef%bc%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】Redux 还是 Mobx，让我来解决你的困惑！</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\n\x3cp\x3e原文地址：\x3ca href=\x22https:\/\/www.robinwieruch.de\/redux-mobx-confusion\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux or MobX: An attempt to dissolve the Confusion\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e原文作者：\x3ca href=\x22https:\/\/www.robinwieruch.de\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erwieruch\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e我在去年大量的使用了 \x3ca href=\x22https:\/\/github.com\/reactjs\/redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux\x3c\/a\x3e，但我最近都在使用 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMobx\x3c\/a\x3e 来做状态（state）管理。\x3ca href=\x22https:\/\/www.reddit.com\/r\/reactjs\/comments\/4npzq5\/confused_redux_or_mobx\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e似乎现在社区里关于该选什么来替代 Redux 很自然地成为了一件困惑的事\x3c\/a\x3e。开发者不确定该选择哪种解决方案。这个问题并不只是出现在 Redux 与 Mobx 上。无论何时，只要存在选择，人们就会好奇最好的解决问题的方式是什么。我现在写的这些是为了解决 Redux 和 Mobx 这两个状态管理库之间的困惑。\x3c\/p\x3e\n\x3cp\x3e大部分的文章都用 React 来介绍 Mobx 和 Redux 的用法。但是在大部分情况下你都可以将 React 替换成 Angular 、 Vue 或其他。\x3c\/p\x3e\n\x3cp\x3e在 2016 年年初的时候我用 \x3ca href=\x22https:\/\/github.com\/rwieruch\/favesound-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact \x2b Redux\x3c\/a\x3e 写了一个相当大的应用。在我发现可以使用 Mobx 替代 Redux 时，我花时间将应用从 Redux 重构成了 Mobx 。现在我可以非常自在的使用它俩并且解释它俩的用法。\x3c\/p\x3e\n\x3cp\x3e这篇文章将要讲什么呢？如果你不打算看这么长的文章（TLDR：\x3ca href=\x22https:\/\/en.wiktionary.org\/wiki\/TLDR\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etoo long, didn\x27t read（查看此链接请自备梯子）\x3c\/a\x3e），你可以看下目录。但我想给你更多细节：第一，我想简单地回顾状态管理库为我们解决了什么问题。毕竟我们写 React 时只用 \x3ccode\x3esetState()\x3c\/code\x3e 或写其他 SPA 框架时用 \x3ccode\x3esetState()\x3c\/code\x3e 类似的方法一样也可以做的不错。第二，我会大致的说下它们之间的相同之处和不同之处。第三，我会给 React 生态初学者指明怎样学习 React 的状态管理。友情提醒：在你深入 Mobx 和 Redux 之前，请先使用 \x3ccode\x3esetState()\x3c\/code\x3e 。最后，如果你已经有一个使用了 Mobx 或 Redux 的应用，我将会就如何从其中一个状态管理库重构到另一个给你更多我的理解。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e我们要解决的是什么问题？\x3c\/li\x3e\n\x3cli\x3eMobx 和 Redux 的不同？\x3c\/li\x3e\n\x3cli\x3eReact 状态管理的学习曲线\x3c\/li\x3e\n\x3cli\x3e尝试另一个状态管理方案？\x3c\/li\x3e\n\x3cli\x3e最后思考\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e我们要解决的是什么问题？\x3c\/h3\x3e\n\x3cp\x3e所有人都想在应用中使用状态管理。但它为我们解决了什么问题？很多人开始一个小应用时就已经引入一个状态管理库。所有人都在谈论 Mobx 和 Redux ，不是吗？但大部分应用在一开始的时候\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/you-might-not-need-redux-be46360cf367\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e并不需要大型的状态管理\x3c\/a\x3e。这甚至是危险的，因为这部分人将无法体验  Mobx 和 Redux 这些库所要解决的问题。\x3c\/p\x3e\n\x3cp\x3e如今的现状是要用组件（components）来构建一个前端应用。组件有自己的内部状态。举个栗子，在 React 中上述的本地状态是用\x3ccode\x3ethis.state\x3c\/code\x3e和\x3ccode\x3esetState()\x3c\/code\x3e来处理。但本地状态的状态管理在膨胀的应用中很快会变得混乱，因为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e一个组件需要和另一个组件共享状态\x3c\/li\x3e\n\x3cli\x3e一个组件需要改变另一个组件的状态\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e到一定程度时，推算应用的状态将会变得越来越困难。它就会变成一个有很多状态对象并且在组件层级上互相修改状态的混乱应用。在大部分情况下，状态对象和状态的修改并没有必要绑定在一些组件上。\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/lifting-state-up.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e当你把状态提升时，它们可以通过组件树得到\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e所以，解决方案是引入状态管理库，比如：Mobx 或 Redux。它提供工具在某个地方保存状态、修改状态和更新状态。你可以从一个地方获得状态，一个地方修改它，一个地方得到它的更新。它遵循单一数据源的原则。这让我们更容易推断状态的值和状态的修改，因为它们与我们的组件是解耦的。\x3c\/p\x3e\n\x3cp\x3e像 Redux 和 Mobx 这类状态管理库一般都有附带的工具，例如在 React 中使用的有 \x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx-react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emobx-react\x3c\/a\x3e，它们使你的组件能够获得状态。一般情况下，这些组件被叫做容器组件（container components），或者说的更加确切的话，就是连接组件( connected components )。只要你将组件升级成连接组件，你就可以在组件层级的任何地方得到和更改状态。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eMobx 和 Redux 的不同？\x3c\/h3\x3e\n\x3cp\x3e在我们深入了解 Redux 和 Mobx 的不同之前，我想先谈谈它们之间的相同之处。\x3c\/p\x3e\n\x3cp\x3e这两个库都是用来管理 JavaScript 应用的状态。它们并不一定要跟 React 绑定在一起，它们也可以在 AngularJs 和 VueJs 这些其他库里使用。但它们与\x3ca href=\x22https:\/\/www.robinwieruch.de\/reasons-why-i-moved-from-angular-to-react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e React 的理念\x3c\/a\x3e结合得非常好。\x3c\/p\x3e\n\x3cp\x3e如果你选择了其中一个状态管理方案，你不会感到被它锁定了。因为你可以在任何时候切换到另一个解决方案。你可以从 Mobx 换成 Redux 或从 Redux 换成 Mobx。我下面会展示如何能够做到。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/twitter.com\/dan_abramov\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDan Abramov\x3c\/a\x3e 的 Redux 是从 \x3ca href=\x22https:\/\/facebook.github.io\/flux\/docs\/in-depth-overview.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eflux 架构\x3c\/a\x3e派生出来的。和 flux 不同的是，Redux 用单一 store 而不是多个 store 来保存 state，另外，它用纯函数替代 dispatcher 来修改 state，如果你对 flux 不熟并且没接触过状态管理，不要被这段内容所烦恼。\x3c\/p\x3e\n\x3cp\x3eRedux 被 FP（函数式编程）原则所影响。FP 可以在 JavaScript 中使用，但很多人有面向对象语言的背景，比如 Java。他们在刚开始的时候很难适应函数式编程的原则。这就是为什么对于初学者来说 Mobx 可能更加简单。\x3c\/p\x3e\n\x3cp\x3e既然 Redux 拥抱 FP，那它使用的就是纯函数。一个接受输入并返回输出并且没有其他依赖的纯函数。一个纯函数在相同的输入下输出总是相同而且没有任何副作用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(state, action) =\x3e newState\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) =\x26gt; newState\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你的 Redux state 是不可变的，你应该总是返回一个新的 state 而不是修改原 state。你不应该执行 state 的修改或依据对象引用的更改。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ don\x27t do this in Redux, because it mutates the array\nfunction addAuthor(state, action) {\n  return state.authors.push(action.author);\n}\n\n\/\/ stay immutable and always return a new object\nfunction addAuthor(state, action) {\n  return [ ...state.authors, action.author ];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ don\x27t do this \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e Redux, because it mutates the array\nfunction addAuthor(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) {\n  return \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.authors.push(action.author);\n}\n\n\/\/ stay immutable and always return a new object\nfunction addAuthor(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) {\n  return [ ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.authors, action.author ];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后，在 Redux 的习惯用法里，state 的格式是像数据库一样标准化的。实体之间只靠 id 互相引用，这是最佳实践。虽然不是每个人都这样做，你也可以使用 \x3ca href=\x22https:\/\/github.com\/paularmstrong\/normalizr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enormalizr\x3c\/a\x3e 来使 state 标准化。标准化的 state 让你能够保持一个扁平的 state 和保持实体为单一数据源。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  post: {\n    id: \x27a\x27,\n    authorId: \x27b\x27,\n    ...\n  },\n  author: {\n    id: \x27b\x27,\n    postIds: [\x27a\x27, ...],\n    ...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attribute\x22\x3epost\x3c\/span\x3e: {\n    id: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n    authorId: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e,\n    ...\n  },\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eauthor\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e,\n    postIds: [\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, ...],\n    ...\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/twitter.com\/mweststrate\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMichel Weststrate\x3c\/a\x3e 的 Mobx 则是受到面向对象编程和响应式编程的影响。它将 state 包装成可观察的对象，因此你的 state 就有了 Observable 的所有能力。state 数据可以只有普通的 setter 和 getter，但 observable 让我们能在数据改变的时候得到更新的值。\x3c\/p\x3e\n\x3cp\x3eMobx 的 state 是可变的，所以你直接的修改 state ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function addAuthor(author) {\n  this.authors.push(author);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddAuthor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(author)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.authors.push(author);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外，state 实体保持嵌套的数据结构来互相关联。你不必标准化 state，而是让它们保持嵌套。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  post: {\n    id: \x27a\x27,\n    ...\n    author: {\n      id: \x27b\x27,\n      ...\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attribute\x22\x3epost\x3c\/span\x3e: {\n    id: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n    ...\n    author: {\n      id: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e,\n      ...\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e单 store 与多 stores\x3c\/h4\x3e\n\x3cp\x3e在 Redux 中，你将所有的 state 都放在一个全局的 store。这个 store 对象就是你的单一数据源。另一方面，多个 reducers 允许你修改不可变的 state。\x3c\/p\x3e\n\x3cp\x3eMobx 则相反，它使用多 stores。和 Redux 的 reducers 类似，你可以在技术层面或领域进行分治。也许你想在不同的 stores 里保存你的领域实体，但仍然保持对视图中 state 的控制。毕竟你配置 state 是为了让应用看起来更合理。\x3c\/p\x3e\n\x3cp\x3e从技术层面来说，你一样可以在 Redux 中使用多个 stores。没有人强迫你只能只用一个 store。 但那不是 Redux 建议的用法。因为那违反了最佳实践。在 Redux 中，你的单 store 通过 reducers 的全局事件来响应更新。\x3c\/p\x3e\n\x3ch4\x3e如何使用？\x3c\/h4\x3e\n\x3cp\x3e你需要跟随下面的代码学习使用 Redux，首先在全局 state 上新增一个 user 数组。你可以看到我通过\x3ca href=\x22https:\/\/github.com\/sebmarkbage\/ecmascript-rest-spread\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对象扩展运算符\x3c\/a\x3e来返回一个新对象。你同样可以在 ES6（原文为 ES5，实际是应该是 ES6）中使用 \x3ccode\x3eObject.assign()\x3c\/code\x3e 来操作不可变对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const initialState = {\n  users: [\n    {\n      name: \x27Dan\x27\n    },\n    {\n      name: \x27Michel\x27\n    }\n  ]\n};\n\n\/\/ reducer\nfunction users(state = initialState, action) {\n  switch (action.type) {\n  case \x27USER_ADD\x27:\n    return { ...state, users: [ ...state.users, action.user ] };\n  default:\n    return state;\n  }\n}\n\n\/\/ action\n{ type: \x27USER_ADD\x27, user: user };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3econst initialState = {\n  users: [\n    {\n      name: \x27Dan\x27\n    },\n    {\n      name: \x27Michel\x27\n    }\n  ]\n};\n\n\/\/ reducer\nfunction users(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = initialState, action) {\n  switch (action.type) {\n  case \x27USER_ADD\x27:\n    return { ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, users: [ ...\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.users, action.\x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e ] };\n  \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n    return \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e;\n  }\n}\n\n\/\/ action\n{ type: \x27USER_ADD\x27, \x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你必须使用 \x3ccode\x3edispatch({ type: \x27USER_ADD\x27, user: user });\x3c\/code\x3e来为全局 state 添加一个新 user 。\x3c\/p\x3e\n\x3cp\x3e在 Mobx 中，一个 store 只管理一个子 state（就像 Redux 中管理子 state 的 reducer），但你可以直接修改 state 。\x3ccode\x3e@observable\x3c\/code\x3e 让我们可以观察到 state 的变化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UserStore {\n  @observable users = [\n    {\n      name: \x27Dan\x27\n    },\n    {\n      name: \x27Michel\x27\n    }\n  ];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eUserStore\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-variable\x22\x3e@observable\x3c\/span\x3e users = [\n    {\n      \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Dan\x27\x3c\/span\x3e\n    },\n    {\n      \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Michel\x27\x3c\/span\x3e\n    }\n  ];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们就可以调用 store 实例的方法：\x3ccode\x3euserStore.users.push(user);\x3c\/code\x3e。这是一种最佳实践，虽然使用 actions 去操作 state 的修改更加清楚明确。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UserStore {\n  @observable users = [\n    {\n      name: \x27Dan\x27\n    },\n    {\n      name: \x27Michel\x27\n    }\n  ];\n\n  @action addUser = (user) =\x3e {\n    this.users.push(user);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUserStore\x3c\/span\x3e {\x3c\/span\x3e\n  @observable users = [\n    {\n      name: \x3cspan class=\x22hljs-string\x22\x3e\x27Dan\x27\x3c\/span\x3e\n    },\n    {\n      name: \x3cspan class=\x22hljs-string\x22\x3e\x27Michel\x27\x3c\/span\x3e\n    }\n  ];\n\n  @action addUser = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(user)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.users.push(user);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 Mobx 中你可以加上 \x3ccode\x3euseStrict()\x3c\/code\x3e 来强制使用 action。现在你可以调用 store 实例上的方法：\x3ccode\x3euserStore.addUser(user);\x3c\/code\x3e 来修改你的 state 。\x3c\/p\x3e\n\x3cp\x3e你已经看到如何在 Redux 和 Mobx 中更新 state 。它们是不同的，Redux 中 state 是只读的，你只能使用明确的 actions 来修改 state ，Mobx 则相反，state 是可读和写的，你可以不使用 actions 直接修改 state，但你可以 \x3ccode\x3euseStrict()\x3c\/code\x3e 来使用明确的 actions 。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eReact 状态管理的学习曲线\x3c\/h3\x3e\n\x3cp\x3eReact 应用广泛使用 Redux 和 Mobx 。但它们是独立的状态管理库，可以运用在除 React 的任何地方。它们的互操作库让我们能简单的连接React 组件。Redux \x2b React 的 \x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux\x3c\/a\x3e 和 MobX \x2b React 的 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx-react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emobx-react\x3c\/a\x3e 。稍后我会说明它俩如何在 React 组件树中使用。\x3c\/p\x3e\n\x3cp\x3e在最近的讨论中，人们在争论 Redux 的学习曲线。这通常发生在下面的情境中：想使用 Redux 做状态管理的 React 初学者。大部分人认为 React 和 Redux 本身都有颇高的学习曲线，两者结合的话会失控。一个替代的选择就是 Mobx ，因为它更适合初学者。\x3c\/p\x3e\n\x3cp\x3e然而，我会建议 React 的初学者一个学习状态管理的新方法。先学习\x3cbr\x3e React 组件内部的状态管理功能。在 React 应用，你首先会学到生命周期方法，而且你会用 \x3ccode\x3esetState()\x3c\/code\x3e 和 \x3ccode\x3ethis.state\x3c\/code\x3e 解决本地的状态管理。我非常推荐上面的学习路径。不然你会在 React 的生态中迷失。在这条学习路径的最后，你会认识到组件内部管理状态难度越来越大。毕竟那是 \x3ca href=\x22https:\/\/www.robinwieruch.de\/the-road-to-learn-react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThe Road to learn React\x3c\/a\x3e 书里如何教授 React 状态管理的方法。\x3c\/p\x3e\n\x3cp\x3e现在我们重点讨论 Redux 和 Mobx 为我们解决了什么问题？它俩都提供了在组件外部管理应用状态的方法。state 与组件相互解耦，组件可以读取 state ，修改 state ，有新 state 时更新。这个 state 是单一数据源。\x3c\/p\x3e\n\x3cp\x3e现在你需要选择其中一个状态管理库。这肯定是要第一时间解决的问题。此外，在开发过相当大的应用之后，你应该能很自如使用 React 。\x3c\/p\x3e\n\x3ch4\x3e初学者用 Redux 还是 Mobx ?\x3c\/h4\x3e\n\x3cp\x3e一旦你对 React 组件和它内部的状态管理熟悉了，你就能选择出一个状态管理库来解决你的问题。在我两个库都用过后，我想说 Mobx 更适合初学者。我们刚才已经看到 Mobx 只要更少的代码，甚至它可以用一些我们现在还不知道的魔法注解。\x3c\/p\x3e\n\x3cp\x3e用 Mobx 你不需要熟悉函数式编程。像“不可变”之类的术语对你可能依然陌生。函数式编程是不断上升的范式，但对于大部分 JavaScript 开发者来说是新奇的。虽然它有清晰的趋势，但并非所有人都有函数式编程的背景，有面向对象背景的开发者可能会更加容易适应 Mobx 的原则。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注：\x3ca href=\x22https:\/\/medium.com\/@mweststrate\/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMobx 可以很好的在 React 内部组件状态管理中代替 setState\x3c\/a\x3e，我还是建议继续使用 \x3ccode\x3esetState()\x3c\/code\x3e 管理内部状态。但链接文章很清楚的说明了在 React 中用 Mobx 完成内部状态管理是很容易的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e规模持续增长的应用\x3c\/h4\x3e\n\x3cp\x3e在 Mobx 中你改变注解过的对象，组件就会更新。Mobx 比 Redux 使用了更多的内部魔法实现，因此在刚开始的时候只要更少的代码。有 Angular 背景的会觉得跟双向绑定很像。你在一个地方保存 state ，通过注解观察 state ，一旦 state 修改组件会自动的更新。\x3c\/p\x3e\n\x3cp\x3eMobx 允许直接在组件树上直接修改 state 。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ component\n\x3cbutton onClick={() =\x3e store.users.push(user)} \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ component\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ebutton\x3c\/span\x3e onClick={() =\x26gt; store\x3cspan class=\x22hljs-selector-class\x22\x3e.users\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.push\x3c\/span\x3e(user)} \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更好的方式是用 store 的 \x3ccode\x3e@action\x3c\/code\x3e 。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ component\n\x3cbutton onClick={() =\x3e store.addUser(user)} \/\x3e\n\n\/\/ store\n@action addUser = (user) =\x3e {\n  this.users.push(user);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ component\x3c\/span\x3e\n\x26lt;button onClick={\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e store.addUser(user)} \/\x26gt;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ store\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e@action\x3c\/span\x3e addUser = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3euser\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.users.push(user);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用 actions 修改 state 更加明确。上面也提到过，有个小功能可以强制的使用 actions 修改 state 。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ root file\nimport { useStrict } from \x27mobx\x27;\n\nuseStrict(true);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ root file\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useStrict } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\nuseStrict(\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的话第一个例子中直接修改 store 中的 state 就不再起作用了。前面的例子展示了怎样拥抱 Mobx 的最佳实践。此外，一旦你只用 actions ，你就已经使用了 Redux 的约束。\x3c\/p\x3e\n\x3cp\x3e在快速启动一个项目时，我会推荐使用 Mobx ，一旦应用开始变得越来越大，越来越多的人开发时，遵循最佳实践就很有意义，如使用明确的 actions 。这是拥抱 Redux 的约束：你永远不能直接修改 state ，只能使用 actions 。\x3c\/p\x3e\n\x3ch4\x3e迁移到 Redux\x3c\/h4\x3e\n\x3cp\x3e一旦应用开始变得越来越大，越来越多的人开发时，你应该考虑使用 Redux 。它本身强制使用明确的 actions 修改 state 。action 有 type 和 payload 参数，reducer 可以用来修改 state 。这样的话，一个团队里的开发人员可以很简单的推断 state 的修改。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ reducer\n(state, action) =\x3e newState\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ reducer\n(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, action) =\x26gt; newState\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eRedux 提供状态管理的整个架构，并有清晰的约束规则。这是\x3ca href=\x22https:\/\/www.youtube.com\/watch?v=uvAXVMwHJXU\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e Redux 的成功故事\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e另一个 Redux 的优势是在服务端使用。因为我们使用的是纯 JavaScript ，它可以在网络上传输 state 。序列化和反序列化一个 state 对象是直接可用的。当然 Mobx 也是一样可以的。\x3c\/p\x3e\n\x3cp\x3eMobx 是无主张的，但你可以通过 \x3ccode\x3euseStrict()\x3c\/code\x3e 像 Redux 一样使用清晰的约束规则。这就是我为什么没说你不能在扩张的应用中使用 Mobx ，但 Redux 是有明确的使用方式的。而 Mobx 甚至在文档中说：“ Mobx 不会告诉你如何组织代码，哪里该存储 state 或 怎么处理事件。”所以开发团队首先要确定 state 的管理架构。\x3c\/p\x3e\n\x3cp\x3e状态管理的学习曲线并不是很陡峭。我们总结下建议：React 初学者首先学习恰当的使用 \x3ccode\x3esetState()\x3c\/code\x3e 和 \x3ccode\x3ethis.state\x3c\/code\x3e 。一段时间之后你将会意识到在 React 应用中仅仅使用 \x3ccode\x3esetState()\x3c\/code\x3e 管理状态的问题。当你寻找解决方案时，你会在状态管理库 Mobx 或 Redux 的选择上犹豫。应该选哪个呢？由于 Mobx 是无主张的，使用上可以和 \x3ccode\x3esetState()\x3c\/code\x3e 类似，我建议在小项目中尝试。一旦应用开始变得越来越大，越来越多的人开发时，你应该考虑在 Mobx 上实行更多的限制条件或尝试使用 Redux 。我使用两个库都很享受。即使你最后两个都没使用，了解到状态管理的另一种方式也是有意义的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e尝试另一个状态管理方案？\x3c\/h3\x3e\n\x3cp\x3e你可能已经使用了其中一个状态管理方案，但是想考虑另一个？你可以比较现实中的 \x3ca href=\x22https:\/\/github.com\/rwieruch\/favesound-mobx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMobx\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/rwieruch\/favesound-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux\x3c\/a\x3e 应用。我把所有的文件修改都提交到了一个 \x3ca href=\x22https:\/\/github.com\/rwieruch\/favesound-mobx\/pull\/1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePull Request\x3c\/a\x3e 。在这个 PR 里，项目从 Redux 重构成了 Mobx ，反之亦然，你可以自己实现。我不认为有必要和 Redux 或 Mobx 耦合，因为大部分的改变是和其他任何东西解耦的。\x3c\/p\x3e\n\x3cp\x3e你主要需要将 Redux 的 Actions、Action Creator、 Action Types、Reducer、Global Store 替换成 Mobx 的 Stores 。另外将和 React 组件连接的接口 \x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux\x3c\/a\x3e 换成 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx-react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emobx-react\x3c\/a\x3e 。\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/smart-and-dumb-components-7ca2f9a7c7d0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epresenter \x2b container pattern\x3c\/a\x3e 依然可以执行。你仅仅还要重构容器组件。在 Mobx 中可以使用 \x3ccode\x3einject\x3c\/code\x3e 获得 store 依赖。然后 store 可以传递 substate 和 actions 给组件。Mobx 的 \x3ccode\x3eobserver\x3c\/code\x3e 确保组件在 store 中  \x3ccode\x3eobservable\x3c\/code\x3e 的属性变化时更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { observer, inject } from \x27mobx-react\x27;\n\n...\n\nconst UserProfileContainer = inject(\n  \x27userStore\x27\n)(observer(({\n  id,\n  userStore,\n}) =\x3e {\n  return (\n    \x3cUserProfile\n      user={userStore.getUser(id)}\n      onUpdateUser={userStore.updateUser}\n    \/\x3e\n  );\n}));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { observer, inject } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx-react\x27\x3c\/span\x3e;\n\n...\n\nconst UserProfileContainer = inject(\n  \x3cspan class=\x22hljs-string\x22\x3e\x27userStore\x27\x3c\/span\x3e\n)(observer(({\n  id,\n  userStore,\n}) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eUserProfile\x3c\/span\x3e\n      \x3cspan class=\x22hljs-attr\x22\x3euser\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{userStore.getUser(id)}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-attr\x22\x3eonUpdateUser\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{userStore.updateUser}\x3c\/span\x3e\n    \/\x26gt;\x3c\/span\x3e\n  );\n}));\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eRedux 的话，你使用 \x3ccode\x3emapStateToProps\x3c\/code\x3e 和 \x3ccode\x3emapDispatchToProps\x3c\/code\x3e 传递 substate 和 actions 给组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { connect } from \x27react-redux\x27;\nimport { bindActionCreators } from \x27redux\x27;\n\n...\n\nfunction mapStateToProps(state, props) {\n  const { id } = props;\n  const user = state.users[id];\n\n  return {\n    user,\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    onUpdateUser: bindActionCreators(actions.updateUser, dispatch),\n  };\n}\n\nconst UserProfileContainer = connect(mapStateToProps, mapDispatchToProps)(UserProfile);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eimport { connect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x27react-redux\x27;\nimport { bindActionCreators } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x27redux\x27;\n\n...\n\nfunction mapStateToProps(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, props) {\n  const { id } = props;\n  const \x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.users[id];\n\n  return {\n    \x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e,\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3eUpdateUser: bindActionCreators(actions.updateUser, dispatch),\n  };\n}\n\nconst UserProfileContainer = connect(mapStateToProps, mapDispatchToProps)(UserProfile);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这有一篇\x3ca href=\x22https:\/\/www.robinwieruch.de\/mobx-react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e怎样将 Redux 重构为 Mobx\x3c\/a\x3e指南。但就像我上面说过的，反过来一样也是可以的。一旦你选择了一个状态管理库，你会知道那并没有什么限制。它们基本上是和你的应用解耦的，所以是可以替换的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e最后思考\x3c\/h3\x3e\n\x3cp\x3e每当我看 Redux vs Mobx 争论下的评论时，总会有下面这条：“Redux 有太多的样板代码，你应该使用 Mobx，可以减少 xxx 行代码”。这条评论也许是对的，但没人考虑得失，\x3cstrong\x3eRedux 比 Mobx 更多的样板代码，是因为特定的设计约束\x3c\/strong\x3e。它允许你推断应用状态即使应用规模很大。所以围绕 state 的仪式都是有原因的。\x3c\/p\x3e\n\x3cp\x3eRedux 库非常小，大部分时间你都是在处理纯 JavaScript 对象和数组。它比 Mobx 更接近 vanilla JavaScript 。Mobx 通过包装对象和数组为可观察对象，从而隐藏了大部分的样板代码。它是建立在隐藏抽象之上的。感觉像是出现了魔法，但却很难理解其内在的机制。Redux 则可以简单通过纯 JavaScript 来推断。它使你的应用更简单的测试和调试。\x3c\/p\x3e\n\x3cp\x3e另外，我们重新回到单页应用的最开始来考虑，一系列的单页应用框架和库面临着相同的状态管理问题，它最终被 flux 模式解决了。Redux 是这个模式的成功者。\x3c\/p\x3e\n\x3cp\x3eMobx 则又处在相反的方向。我们直接修改 state 而没有拥抱函数式编程的好处。对一些开发者来说，这让他们觉得像双向绑定。一段时间之后，由于没有引入类似 Redux 的状态管理库，他们可能又会陷入同样的问题。状态管理分散在各个组件，导致最后一团糟。\x3c\/p\x3e\n\x3cp\x3e使用 Redux，你有一个既定的模式组织代码，而 Mobx 则无主张。但拥抱 Mobx 最佳实践会是明智的。 开发者需要知道如何组织状态管理从而更好的推断它。不然他们就会想要直接在组件中修改它。\x3c\/p\x3e\n\x3cp\x3e两个库都非常棒。Redux 已经非常完善，Mobx 则逐渐成为一个有效的替代。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】Redux 还是 Mobx，让我来解决你的困惑！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011148981">https://segmentfault.com/a/1190000011148981</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/8ec99stqhga/" target="_blank">https://alili.tech/archive/8ec99stqhga/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>