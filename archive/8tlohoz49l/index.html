<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 是怎样炼成的"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 是怎样炼成的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/8tlohoz49l/",
				"appid": "1613049289050283", 
				"title": "React 是怎样炼成的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qauxg5uovts/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bm6ubyv4i0b/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&text=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&text=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&title=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&is_video=false&description=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&title=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&title=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&title=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8tlohoz49l%2f&title=React%20%e6%98%af%e6%80%8e%e6%a0%b7%e7%82%bc%e6%88%90%e7%9a%84"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 是怎样炼成的</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e本文主要讲述 React 的诞生过程和优化思路。\x3c\/p\x3e\n\x3cp\x3e内容整理自 2014 年的 \x3ca href=\x22https:\/\/speakerdeck.com\/vjeux\/oscon-react-architecture\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eOSCON - React Architecture by vjeux\x3c\/a\x3e，虽然从今天（2018）来看可能会有点历史感，但仍然值得学习了解。以史为鉴，从中也可以管窥 Facebook 优秀的工程管理文化。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e字符拼接时代 - 2004\x3c\/h2\x3e\n\x3cp\x3e时间回到 2004 年，Mark Zuckerberg 当时还在宿舍捣鼓最初版的 Facebook 。\x3cbr\x3e这一年，大家都在用 PHP 的字符串拼接（String Concatenation）功能来开发网站。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$str = \x27\x3cul\x3e\x27;\nforeach ($talks as $talk) {\n  $str \x2b= \x27\x3cli\x3e\x27 . $talk-\x3ename . \x27\x3c\/li\x3e\x27;\n}\n$str \x2b= \x27\x3c\/ul\x3e\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22php hljs\x22\x3e\x3ccode class=\x22php\x22\x3e$str = \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;ul\x26gt;\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eforeach\x3c\/span\x3e ($talks \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e $talk) {\n  $str \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;li\x26gt;\x27\x3c\/span\x3e . $talk-\x26gt;name . \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/li\x26gt;\x27\x3c\/span\x3e;\n}\n$str \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/ul\x26gt;\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种网站开发方式在当时看来是非常正确的，因为不管是后端开发还是前端开发，甚至根本没有开发经验，都可以使用这种方式搭建一个大型网站。\x3c\/p\x3e\n\x3cp\x3e唯一不足的是，这种开发方式容易造成 XSS 注入等\x3cstrong\x3e安全问题\x3c\/strong\x3e。如果 \x3ccode\x3e$talk-\x26gt;name\x3c\/code\x3e 中包含恶意代码，而又没有做任何防护措施的话，那么攻击者就可以注入任意 JS 代码。于是就催生了“永远不要相信用户的输入”的安全守则。\x3c\/p\x3e\n\x3cp\x3e最简单的应对方法是对用户的任何输入都进行\x3cstrong\x3e转义\x3c\/strong\x3e（Escape）。然而这也带来了其他麻烦，如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eXHP 时代 - 2010\x3c\/h2\x3e\n\x3cp\x3e到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的\x3cstrong\x3e语法拓展\x3c\/strong\x3e，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$content = \x3cul \/\x3e;\nforeach ($talks as $talk) {\n  $content-\x3eappendChild(\x3cli\x3e{$talk-\x3ename}\x3c\/li\x3e);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22php hljs\x22\x3e\x3ccode class=\x22php\x22\x3e$content = \x26lt;ul \/\x26gt;;\n\x3cspan class=\x22hljs-keyword\x22\x3eforeach\x3c\/span\x3e ($talks \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e $talk) {\n  $content-\x26gt;appendChild(\x26lt;li\x26gt;{$talk-\x26gt;name}\x26lt;\/li\x26gt;);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的话，所有的 HTML 标签都使用不同于 PHP 的语法，我们可以轻易的分辨哪些需要转义哪些不需要转义。\x3c\/p\x3e\n\x3cp\x3e不久的后来，Facebook 的工程师又发现他们还可以创建\x3cstrong\x3e自定义标签\x3c\/strong\x3e，而且通过组合自定义标签有助于构建大型应用。\x3cbr\x3e而这恰恰是 Semantic Web 和 Web Components 概念的一种实现方式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$content = \x3ctalk:list \/\x3e;\nforeach ($talks as $talk) {\n  $content-\x3eappendChild(\x3ctalk talk={$talk} \/\x3e);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22php hljs\x22\x3e\x3ccode class=\x22php\x22\x3e$content = \x26lt;talk:\x3cspan class=\x22hljs-keyword\x22\x3elist\x3c\/span\x3e \/\x26gt;;\n\x3cspan class=\x22hljs-keyword\x22\x3eforeach\x3c\/span\x3e ($talks \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e $talk) {\n  $content-\x26gt;appendChild(\x26lt;talk talk={$talk} \/\x26gt;);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之后，Facebook 在 JS 中尝试了更多的新技术方式以减小客户端和服务端之间的延时。比如跨浏览器 DOM 库和数据绑定，但是都不是很理想。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eJSX - 2013\x3c\/h2\x3e\n\x3cp\x3e等到 2013 年，突然有一天，前端工程师 Jordan Walke 向他的经理提出了一个大胆的想法：把 XHP 的拓展功能迁移到 JS 中。最开始大家都以为他疯了，因为这与当时大家都看好的 JS 框架格格不入。不过他最终还是执着地说服了经理，允许他用 6 个月的时间来验证这个想法。这里不得不说 Facebook 良好的工程师管理哲学让人敬佩，值得借鉴。\x3c\/p\x3e\n\x3cblockquote\x3e附：Lee Byron 谈 Facebook 工程师文化：\x3ca href=\x22https:\/\/medium.com\/@leeb\/why-invest-in-tools-3240ce289930\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWhy Invest in Tools\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e要想把 XHP 的拓展功能迁移到 JS ，首要任务是需要一个拓展来让 JS 支持 XML 语法，该拓展称为 JSX 。当时，随着 Node.js 的兴起，Facebook 内部对于转换 JS 已经有相当多的工程实践了。所以实现 JSX 简直轻而易举，仅仅花费了大概一周的时间。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const content = (\n  \x3cTalkList\x3e\n    { talks.map(talk =\x3e \x3cTalk talk={talk} \/\x3e)}\n  \x3c\/TalkList\x3e\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e content = (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTalkList\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    { talks.map(talk =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTalk\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etalk\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{talk}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e)}\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eTalkList\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eReact\x3c\/h2\x3e\n\x3cp\x3e自此，开始了 React 的万里长征，更大的困难还在后头。其中，最棘手的是如何再现 PHP 中的更新机制。\x3c\/p\x3e\n\x3cp\x3e在 PHP 中，每当有数据改变时，只需要跳到一个由 PHP 全新渲染的新页面即可。\x3cbr\x3e从开发者的角度来看的话，这种方式开发应用是非常简单的，因为它不需要担心变更，且界面上用户数据改变时所有内容都是同步的。\x3cbr\x3e只要有数据变更，就重新渲染整个页面。\x3c\/p\x3e\n\x3cp\x3e虽然简单粗暴，但是这种方式的缺点也尤为突出，那就是它\x3cstrong\x3e非常慢\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e“You need to be right before being good”，意思是说，为了验证迁移方案的可行性，开发者必须快速实现一个可用版本，暂时不考虑性能问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eDOM\x3c\/h3\x3e\n\x3cp\x3e取自于 PHP 的灵感，在 JS 中实现重新渲染的最简单办法是：当任何内容改变时，都\x3cstrong\x3e重新构建\x3c\/strong\x3e整个 DOM，然后用新 DOM 取代旧 DOM 。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6k?w=739\x26amp;h=337\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6k?w=739\x26amp;h=337\x22 alt=\x22Naive Render\x22 title=\x22Naive Render\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这种方式是可以工作的，但在有些场景下不适用。\x3cbr\x3e比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。\x3cbr\x3e换句话来说，\x3cstrong\x3eDOM 节点是包含状态的\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6t?w=547\x26amp;h=220\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6t?w=547\x26amp;h=220\x22 alt=\x22DOM is stateful\x22 title=\x22DOM is stateful\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e既然包含状态，那么记下旧 DOM 的状态然后在新 DOM 上还原不就行了么？\x3cbr\x3e但是非常不幸，这种方式不仅实现起来复杂而且也无法覆盖所有情况。\x3c\/p\x3e\n\x3cp\x3e在 OSX 电脑上滚动页面时，会伴随着一定的滚动惯性。但是 JS 并没有提供相应的 API 来读取或者写入滚动惯性。\x3cbr\x3e对包含 \x3ccode\x3eiframe\x3c\/code\x3e 的页面来说，情况则更复杂。如果它来自其他域，那么浏览器安全策略限制根本不会允许我们查看其内部的内容，更不用说还原了。\x3cbr\x3e因此可以看出，DOM 不仅仅有状态，它还包含\x3cstrong\x3e隐藏的、无法触达的状态\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e既然还原状态行不通，那就换一种方式绕过去。\x3cbr\x3e对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。\x3cbr\x3e这种方式实现了 DOM 节点\x3cstrong\x3e复用\x3c\/strong\x3e（Reuse）。\x3c\/p\x3e\n\x3cp\x3e至此，只要能够\x3cstrong\x3e识别\x3c\/strong\x3e出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为\x3cstrong\x3e如何比对两个 DOM 的差异\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eDiff\x3c\/h3\x3e\n\x3cp\x3e说到对比差异，相信大家马上就能联想到\x3cstrong\x3e版本控制\x3c\/strong\x3e（Version Control）。它的原理很简单，记录多个代码快照，然后使用 diff 算法比对前后两个快照，从而生成一系列诸如“删除 5 行”、“新增 3 行”、“替换单词”等的改动；通过把这一系列的改动应用到先前的代码快照就可以得到之后的代码快照。\x3c\/p\x3e\n\x3cp\x3e而这正是 React 所需要的，只不过它的处理对象是 DOM 而不是文本文件。\x3cbr\x3e难怪有人说：“I tend to think of React as \x3cstrong\x3eVersion Control for the DOM\x3c\/strong\x3e” 。\x3c\/p\x3e\n\x3cp\x3eDOM 是树形结构，所以 diff 算法必须是针对树形结构的。目前已知的完整树形结构 diff 算法复杂度为 O(n^3) 。\x3c\/p\x3e\n\x3cp\x3e假如页面中有 10,000 个 DOM 节点，这个数字看起来很庞大，但其实并不是不可想象。为了计算该复杂度的数量级大小，我们还假设在一个 CPU 周期我们可以完成单次对比操作（虽然不可能完成），且 CPU 主频为 1 GHz 。这种情况下，diff 要花费的时间如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6H?w=377\x26amp;h=135\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6H?w=377\x26amp;h=135\x22 alt=\x22Optimal Diff\x22 title=\x22Optimal Diff\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e整整有 17 分钟之长，简直无法想象！\x3c\/p\x3e\n\x3cp\x3e虽然说验证阶段暂不考虑性能问题，但是我们还是可以简单了解下该算法是如何实现的。\x3c\/p\x3e\n\x3cblockquote\x3e附：\x3ca href=\x22https:\/\/grfia.dlsi.ua.es\/ml\/algorithms\/references\/editsurvey_bille.pdf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整的 Tree diff 实现算法\x3c\/a\x3e。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6K?w=1395\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6K?w=1395\x26amp;h=328\x22 alt=\x22Tree Diff\x22 title=\x22Tree Diff\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e新树上的每个节点与旧树上的每个节点对比\x3c\/li\x3e\n\x3cli\x3e如果父节点相同，继续循环对比子树\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在上图的树中，依据最小操作原则，可以找到三个嵌套的循环对比。\x3c\/p\x3e\n\x3cp\x3e但如果认真思考下，其实在 Web 应用中，很少有移动一个元素到另一个地方的场景。一个例子可能的是拖拽（Drag）并放置（Drop）元素到另一个地方，但它并不常见。\x3c\/p\x3e\n\x3cp\x3e唯一的常用场景是在子元素之间移动元素，例如在列表中新增、删除和移动元素。既然如此，那可以仅仅对比\x3cstrong\x3e同层级\x3c\/strong\x3e的节点。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6N?w=544\x26amp;h=174\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6N?w=544\x26amp;h=174\x22 alt=\x22Diff children by children\x22 title=\x22Diff children by children\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如上图所示，仅对相同颜色的节点做 diff ，这样能把时间复杂度降到了 O(n^2) 。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ekey\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6Q?w=258\x26amp;h=154\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6Q?w=258\x26amp;h=154\x22 alt=\x22DOM identity\x22 title=\x22DOM identity\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e针对同级元素的比较，又引入了另一个问题。\x3cbr\x3e同层级元素名称不同时，可以直接识别为不匹配；相同时，却没那么简单了。\x3cbr\x3e假如在某个节点下，上一次渲染了三个 \x3ccode\x3e\x26lt;input \/\x26gt;\x3c\/code\x3e，然后下一次渲染变成了两个。此时 diff 的结果会是什么呢？\x3c\/p\x3e\n\x3cp\x3e最直观的结果是前面两个保持不变，删除第三个。\x3cbr\x3e当然，也可以删除第一个同时保持最后两个。\x3cbr\x3e如果不嫌麻烦，还可以把旧的三个都删除，然后新增两个新元素。\x3cbr\x3e这说明，对于\x3cstrong\x3e相同标签名称的节点\x3c\/strong\x3e，我们\x3cstrong\x3e没有足够信息\x3c\/strong\x3e来对比前后差异。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6S?w=404\x26amp;h=99\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6S?w=404\x26amp;h=99\x22 alt=\x22DOM identity with attribute\x22 title=\x22DOM identity with attribute\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果再加上元素的属性呢？比如 \x3ccode\x3evalue\x3c\/code\x3e ，如果前后两次标签名称和 \x3ccode\x3evalue\x3c\/code\x3e 属性都相同，那么就认为元素匹配中，无须改动。但现实是这行不通，因为用户输入时值总是在变，会导致元素一直被替换，导致失去焦点；；更糟糕的是，并不是所有 HTML 元素都有这个属性。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6X?w=371\x26amp;h=145\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6X?w=371\x26amp;h=145\x22 alt=\x22DOM identity with id\x22 title=\x22DOM identity with id\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那使用所有元素都有的 \x3ccode\x3eid\x3c\/code\x3e 属性呢？这是可以的，如上图，我们可以容易的识别出前后 DOM 的差异。考虑表单情况，表单模型的输入通常跟 \x3ccode\x3eid\x3c\/code\x3e 关联，但如果使用 AJAX 来提交表单的话，我们通常不会给 \x3ccode\x3einput\x3c\/code\x3e 设置 \x3ccode\x3eid\x3c\/code\x3e 属性。因此，更好的办法是引入一个新的属性名称，专门用来辅助 diff 算法。这个属性最终确定为 \x3ccode\x3ekey\x3c\/code\x3e 。这也是为什么在 React 中使用列表时会要求给子元素设置 \x3ccode\x3ekey\x3c\/code\x3e 属性的原因。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e6Z?w=570\x26amp;h=223\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e6Z?w=570\x26amp;h=223\x22 alt=\x22Diff with key\x22 title=\x22Diff with key\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e结合 \x3ccode\x3ekey\x3c\/code\x3e ，再加上哈希表，diff 算法最终实现了 O(n) 的最优复杂度。\x3cbr\x3e至此，可以看到从 XHP 迁移到 JS 的方案可行的。接下来就可以针对各个环节进行逐步优化。\x3c\/p\x3e\n\x3cblockquote\x3e附：详细的 diff 理解：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20346379\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不可思议的 react diff\x3c\/a\x3e 。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e持续优化\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eVirtual DOM\x3c\/h3\x3e\n\x3cp\x3e前面说到，React 其实实现了对 DOM 节点的版本控制。\x3cbr\x3e做过 JS 应用优化的人可能都知道，DOM 是复杂的，对它的操作（尤其是查询和创建）是非常慢非常耗费资源的。看下面的例子，仅创建一个空白的 \x3ccode\x3ediv\x3c\/code\x3e，其实例属性就达到 231 个。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Chrome v63\nconst div = document.createElement(\x27div\x27);\nlet m = 0;\nfor (let k in div) {\n  m\x2b\x2b;\n}\nconsole.log(m); \/\/ 231\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chrome v63\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e div = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e m = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e k \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e div) {\n  m\x2b\x2b;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(m); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 231\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之所以有这么多属性，是因为 DOM 节点被用于浏览器渲染管道的很多过程中。\x3cbr\x3e浏览器首先根据 CSS 规则查找匹配的节点，这个过程会缓存很多元信息，例如它维护着一个对应 DOM 节点的 \x3ccode\x3eid\x3c\/code\x3e 映射表。\x3cbr\x3e然后，根据样式计算节点布局，这里又会缓存位置和屏幕定位信息，以及其他很多的元信息，浏览器会尽量避免重新计算布局，所以这些数据都会被缓存。\x3cbr\x3e可以看出，整个渲染过程会耗费大量的内存和 CPU 资源。\x3c\/p\x3e\n\x3cp\x3e现在回过头来想想 React ，其实它只在 diff 算法中用到了 DOM 节点，而且只用到了标签名称和部分属性。\x3cbr\x3e如果用更\x3cstrong\x3e轻量级\x3c\/strong\x3e的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这种方式称为 Virtual DOM 。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e66?w=725\x26amp;h=503\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e66?w=725\x26amp;h=503\x22 alt=\x22Virtual DOM Mutations\x22 title=\x22Virtual DOM Mutations\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其过程如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应\x3c\/li\x3e\n\x3cli\x3e对前后两个 Virtual DOM 做 diff ，生成\x3cstrong\x3e变更\x3c\/strong\x3e（Mutation）\x3c\/li\x3e\n\x3cli\x3e把变更应用于真实 DOM，生成最新的真实 DOM\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可以看出，因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。\x3c\/p\x3e\n\x3cp\x3e至此，React 的两大优化：diff 算法和 Virtual DOM ，均已完成。再加上 XHP 时代尝试的数据绑定，已经算是一个可用版本了。\x3cbr\x3e这个时候 Facebook 做了个重大的决定，那就是把 React 开源！\x3c\/p\x3e\n\x3cp\x3eReact 的开源可谓是一石激起千层浪，社区开发者都被这种全新的 Web 开发方式所吸引，React 因此迅速占领了 JS 开源库的榜首。\x3cbr\x3e很多大公司也把 React 应用到生产环境，同时也有大批社区开发者为 React 贡献了代码。\x3c\/p\x3e\n\x3cp\x3e接下来要说的两大优化就是来自于开源社区。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e批处理（Batching）\x3c\/h3\x3e\n\x3cp\x3e著名浏览器厂商 Opera 把\x3cstrong\x3e重排和重绘\x3c\/strong\x3e（Reflow and Repaint）列为影响页面性能的三大原因之一。\x3c\/p\x3e\n\x3cp\x3e我们说 DOM 是很慢的，除了前面说到的它的复杂和庞大，还有另一个原因就是重排和重绘。\x3c\/p\x3e\n\x3cp\x3e当 DOM 被修改后，浏览器必须更新元素的位置和真实像素；\x3cbr\x3e当尝试从 DOM 读取属性时，为了保证读取的值是正确的，浏览器也会触发重排和重绘。\x3cbr\x3e因此，反复的“读取、修改、读取、修改...”操作，将会触发大量的重排和重绘。\x3c\/p\x3e\n\x3cp\x3e另外，由于浏览器本身对 DOM 操作进行了优化，比如把两次很近的“修改”操作合并成一个“修改”操作。\x3cbr\x3e所以如果把“读取、修改、读取、修改...”重新排列为“读取、读取...”和“修改、修改...”，会有助于减小重排和重绘的次数。但是这种刻意的、手动的级联写法是不安全的。\x3c\/p\x3e\n\x3cp\x3e与此同时，常规的 JS 写法又很容易触发重排和重绘。\x3cbr\x3e在减小重排和重绘的道路上，React 陷入了尴尬的处境。\x3c\/p\x3e\n\x3cp\x3e最终，社区贡献者 Ben Alpert 使用\x3cstrong\x3e批处理\x3c\/strong\x3e的方式拯救了这个尴尬的处境。\x3c\/p\x3e\n\x3cp\x3e在 React 中，开发者通过调用组件的 \x3ccode\x3esetState\x3c\/code\x3e 方法告诉 React 当前组件要变更了。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e7a?w=1111\x26amp;h=248\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e7a?w=1111\x26amp;h=248\x22 alt=\x22Batching\x22 title=\x22Batching\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eBen Alpert 的做法是，调用 \x3ccode\x3esetState\x3c\/code\x3e 时不立即把变更同步到 Virtual DOM，而是仅仅把对应元素打上“待更新”的标记。如果组件内调用多次 \x3ccode\x3esetState\x3c\/code\x3e ，那么都会进行相同的打标操作。\x3c\/p\x3e\n\x3cp\x3e等到初始化事件被完全广播开以后，就开始进行从顶部到底部的重新渲染（Re-Render）过程。这就确保了 React 只对元素进行了一次渲染。\x3c\/p\x3e\n\x3cp\x3e这里要注意两点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e此处的重新渲染是指把 \x3ccode\x3esetState\x3c\/code\x3e 变更同步到 Virtual DOM ；在这之后才进行 diff 操作生成真实的 DOM 变更。\x3c\/li\x3e\n\x3cli\x3e与前文提到的“重新渲染整个 DOM ”不同的是，真实的重新渲染仅渲染被标记的元素及其子元素，也就是说上图中仅蓝色圆圈代表的元素会被重新渲染\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这也提醒开发者，\x3cstrong\x3e应该让拥有状态的组件尽量靠近叶子节点\x3c\/strong\x3e，这样可以缩小重新渲染的范围。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e裁剪（Pruning）\x3c\/h3\x3e\n\x3cp\x3e随着应用越来越大，React 管理的组件状态也会越来越多，这就意味着重新渲染的范围也会越来越大。\x3c\/p\x3e\n\x3cp\x3e认真观察上面批处理的过程可以发现，该 Virtual DOM 右下角的三个元素其实是没有变更的，但是因为其父节点的变更也导致了它们的重新渲染，多做了无用操作。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e7c?w=451\x26amp;h=226\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e7c?w=451\x26amp;h=226\x22 alt=\x22Pruning\x22 title=\x22Pruning\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e对于这种情况，React 本身已经考虑到了，为此它提供了 \x3ccode\x3ebool shouldComponentUpdate(nextProps, nextState)\x3c\/code\x3e 接口。开发者可以手动实现该接口来对比前后状态和属性，以判断是否需要重新渲染。这样的话，重新渲染就变成如下图所示过程。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4e7p?w=658\x26amp;h=239\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4e7p?w=658\x26amp;h=239\x22 alt=\x22Pruning Render\x22 title=\x22Pruning Render\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当时，React 虽然提供了 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 接口，但是并没有提供一个默认的实现方案（总是渲染），开发者必须自己手动实现才能达到预期效果。\x3c\/p\x3e\n\x3cp\x3e其原因是，在 JS 中，我们通常使用对象来保存状态，修改状态时是直接修改该状态对象的。也就是说，修改前后的两个不同状态指向了同一个对象，所以当直接比较两个对象是否变更时，它们是相同的，即使状态已经改变。\x3c\/p\x3e\n\x3cp\x3e对此，David Nolen 提出了基于不可变数据结构（Immutable Data Structure）的解决方案。\x3cbr\x3e该方案的灵感来自于 ClojureScript ，在 ClojureScript 中，大部分的值都是不可变的。换句话说就是，当需要更新一个值时，程序不是去修改原来的值，而是基于原来的值创建一个新值，然后使用新值进行赋值。\x3c\/p\x3e\n\x3cp\x3eDavid 使用 ClojureScript 写了一个针对 React 的不可变数据结构方案：\x3ca href=\x22https:\/\/github.com\/omcljs\/om\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eOm\x3c\/a\x3e ，为 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 提供了默认实现。\x3c\/p\x3e\n\x3cp\x3e不过，由于不可变数据结构并未被 Web 工程师广为接受，所以当时并未把这项功能合并进 React 。\x3cbr\x3e遗憾的是，截止到目前，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 也仍然未提供默认实现。\x3cbr\x3e但是 David 却为广大开发者开启了一个很好的研究方向。\x3c\/p\x3e\n\x3cp\x3e如果真想利用不可变数据结构来提高 React 性能，可以参考与 React 师出同门的 \x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFacebook Immutable.js\x3c\/a\x3e，它是 React 好搭档！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3eReact 的优化仍在继续，比如 React 16 中新引入 \x3ca href=\x22https:\/\/github.com\/acdlite\/react-fiber-architecture\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFiber\x3c\/a\x3e，它是对核心算法的一次重构，即重新设计了检测变更的方法和时机，允许渲染过程可以分段完成，而不必一次性完成。\x3cbr\x3e受篇幅限制，本文不会深入介绍 Fiber ，有兴趣的可以参考 \x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/26027085\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Fiber是什么\x3c\/a\x3e 。\x3c\/p\x3e\n\x3cp\x3e最后，感谢 Facebook 给开源社区带来了如此优秀的项目！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 是怎样炼成的</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013365426">https://segmentfault.com/a/1190000013365426</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/8tlohoz49l/" target="_blank">https://alili.tech/archive/8tlohoz49l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>