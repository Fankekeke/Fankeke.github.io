<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="系列３｜走进Node.js之多进程模型"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>系列３｜走进Node.js之多进程模型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/8ybwecsg7b3/",
				"appid": "1613049289050283", 
				"title": "系列３｜走进Node.js之多进程模型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-16T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/5jg8r81vpqp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7a1w8m11fnp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&text=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&text=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&title=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&is_video=false&description=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&title=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&title=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&title=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f8ybwecsg7b3%2f&title=%e7%b3%bb%e5%88%97%ef%bc%93%ef%bd%9c%e8%b5%b0%e8%bf%9bNode.js%e4%b9%8b%e5%a4%9a%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">系列３｜走进Node.js之多进程模型</h1><div class="meta"><div class="postdate"><time datetime="2018-12-16" itemprop="datePublished">2018-12-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e文：正龙（沪江网校Web前端工程师）\x3cp\x3e本文原创，转载请注明作者及出处\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e之前的文章“\x3ca href=\x22http:\/\/mp.weixin.qq.com\/s?__biz=MzI1MTE2NTE1Ng==\x26amp;mid=2649516579\x26amp;idx=1\x26amp;sn=cb3ef197a637429774d3eb297e01828f\x26amp;chksm=f1efeaa8c69863bedfd102bca2abb67de44b92cfee99feb4825a73386617517856a2b64a8a87\x26amp;scene=21#wechat_redirect\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e走进Node.js之HTTP实现分析\x3c\/a\x3e”中，大家已经了解 Node.js 是如何处理 HTTP 请求的，在整个处理过程，它仅仅用到单进程模型。那么如何让 Web 应用扩展到多进程模型，以便充分利用CPU资源呢？答案就是 Cluster。本篇文章将带着大家一起分析Node.js的多进程模型。\x3c\/p\x3e\n\x3cp\x3e首先，来一段经典的 Node.js 主从服务模型代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const cluster = require(\x27cluster\x27);\nconst numCPUs = require(\x27os\x27).cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i \x3c numCPUs; i\x2b\x2b) {\n    cluster.fork();\n  }\n} else {\n  require(\x27http\x27).createServer((req, res) =\x3e {\n    res.end(\x27hello world\x27);\n  }).listen(3333);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cluster = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cluster\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e numCPUs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27os\x27\x3c\/span\x3e).cpus().length;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cluster.isMaster) {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; numCPUs; i\x2b\x2b) {\n    cluster.fork();\n  }\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e).createServer(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27hello world\x27\x3c\/span\x3e);\n  }).listen(\x3cspan class=\x22hljs-number\x22\x3e3333\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通常，主从模型包含一个主进程（master）和多个从进程（worker），主进程负责接收连接请求，以及把单个的请求任务分发给从进程处理；从进程的职责就是不断响应客户端请求，直至进入等待状态。如图 3-1 所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030639?w=1090\x26amp;h=360\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030639?w=1090\x26amp;h=360\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e围绕这段代码，本文希望讲述清楚几个关键问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从进程的创建过程；\x3c\/li\x3e\n\x3cli\x3e在使用同一主机地址的前提下，如果指定端口已经被监听，其它进程尝试监听同一端口时本应该会报错（EADDRINUSE，即端口已被占用）；那么，Node.js 如何能够在主从进程上对同一端口执行 listen 方法？\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e进程 fork 是如何完成的？\x3c\/h1\x3e\n\x3cp\x3e在 Node.js 中，\x3ca href=\x22https:\/\/nodejs.org\/dist\/latest-v8.x\/docs\/api\/cluster.html#cluster_cluster_fork_env\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecluster.fork\x3c\/a\x3e 与 POSIX 的 \x3ca href=\x22https:\/\/linux.die.net\/man\/3\/fork\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efork\x3c\/a\x3e 略有不同：虽然从进程仍旧是 fork 创建，但是并不会直接使用主进程的进程映像，而是调用系统函数 \x3ca href=\x22https:\/\/linux.die.net\/man\/3\/execvp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eexecvp\x3c\/a\x3e 让从进程使用新的进程映像。另外，每个从进程对应一个 Worker 对象，它有如下状态：none、online、listening、dead和disconnected。\x3c\/p\x3e\n\x3cp\x3eChildProcess 对象主要提供进程的创建（spawn）、销毁（kill）以及进程句柄引用计数管理（ref 与 unref）。在对Process对象（process_wrap.cc）进行封装之外，它自身也处理了一些细节问题。例如，在方法 spawn 中，如果需要主从进程之间建立 IPC 管道，则通过环境变量 NODE_CHANNEL_FD 来告知从进程应该绑定的 IPC 相关的文件描述符（fd），这个特殊的环境变量后面会被再次涉及到。\x3c\/p\x3e\n\x3cp\x3e以上提到的三个对象引用关系如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030640?w=950\x26amp;h=371\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030640?w=950\x26amp;h=371\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ecluster.fork 的主要执行流程：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e调用 child_process.spawn；\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e创建 ChildProcess 对象，并初始化其 _handle 属性为 Process 对象；Process 是 process_wrap.cc 中公布给 JavaScript 的对象，它封装了 libuv 的进程操纵功能。附上 Process 对象的 C\x2b\x2b 定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface Process {\n  construtor(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void close(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void spawn(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void kill(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void ref(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void unref(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n  void hasRef(const FunctionCallbackInfo\x3cValue\x3e\x26amp; args);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e {\n  construtor(\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args);\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eclose\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espawn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ekill\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eref\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunref\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehasRef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FunctionCallbackInfo\x26lt;Value\x26gt;\x26amp; args\x3c\/span\x3e)\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e调用 ChildProcess._handle 的方法 spawn，并会最终调用 libuv 库中 \x3ca href=\x22http:\/\/docs.libuv.org\/en\/v1.x\/process.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3euv_spawn\x3c\/a\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e主进程在执行 cluster.fork 时，会指定两个特殊的环境变量 NODE_CHANNEL_FD 和 NODE_UNIQUE_ID，所以从进程的初始化过程跟一般 Node.js 进程略有不同：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ebootstrap_node.js 是运行时包含的 JavaScript 入口文件，其中调用 internal\\process.setupChannel；\x3c\/li\x3e\n\x3cli\x3e如果环境变量包含 NODE_CHANNEL_FD，则调用 child_process._forkChild，然后移除该值；\x3c\/li\x3e\n\x3cli\x3e调用 internal\\child_process.setupChannel，在子进程的全局 process 对象上监听消息 internalMessage，并且添加方法 send 和 _send。其中 send 只是对 _send 的封装；通常，_send 只是把消息 JSON 序列化之后写入管道，并最终投递到接收端。\x3c\/li\x3e\n\x3cli\x3e如果环境变量包含 NODE_UNIQUE_ID，则当前进程是 worker 模式，加载 cluster 模块时会执行 workerInit；另外，它也会影响到 net.Server 的 listen 方法，worker 模式下 listen 方法会调用 cluster._getServer，该方法实质上向主进程发起消息 {\x22act\x22 : \x22queryServer\x22}，而不是真正监听端口。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3eIPC实现细节\x3c\/h1\x3e\n\x3cp\x3e上文提到了 Node.js 主从进程仅仅通过 IPC 维持联络，那这一节就来深入分析下 IPC 的实现细节。首先，让我们看一段示例代码:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1-master.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {spawn} = require(\x27child_process\x27);\nlet child = spawn(process.execPath, [`${__dirname}\/1-slave.js`], {\n  stdio: [0, 1, 2, \x27ipc\x27]\n});\n\nchild.on(\x27message\x27, function(data) {\n  console.log(\x27received in master:\x27);\n  console.log(data);\n});\n\nchild.send({\n  msg: \x27msg from master\x27\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {spawn} = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e child = spawn(process.execPath, [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${__dirname}\x3c\/span\x3e\/1-slave.js`\x3c\/span\x3e], {\n  \x3cspan class=\x22hljs-attr\x22\x3estdio\x3c\/span\x3e: [\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27ipc\x27\x3c\/span\x3e]\n});\n\nchild.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27received in master:\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n});\n\nchild.send({\n  \x3cspan class=\x22hljs-attr\x22\x3emsg\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27msg from master\x27\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e1-slave.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.on(\x27message\x27, function(data) {\n  console.log(\x27received in slave:\x27);\n  console.log(data);\n});\nprocess.send({\n  \x27msg\x27: \x27message from slave\x27\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27received in slave:\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n});\nprocess.send({\n  \x3cspan class=\x22hljs-string\x22\x3e\x27msg\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27message from slave\x27\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22node 1-master.js\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e1-master\x3c\/span\x3e.js\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行结果如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030641?w=633\x26amp;h=146\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030641?w=633\x26amp;h=146\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e细心的同学可能发现控制台输出并不是连续的，master和slave的日志交错打印，这是由于并行进程执行顺序不可预知造成的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3esocketpair\x3c\/h2\x3e\n\x3cp\x3e前文提到从进程实际上通过系统调用 execvp 启动新的 Node.js 实例；也就是说默认情况下，Node.js 主从进程不会共享文件描述符表，那它们到底是如何互发消息的呢？\x3c\/p\x3e\n\x3cp\x3e原来，可以利用 \x3ca href=\x22https:\/\/linux.die.net\/man\/2\/socketpair\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esocketpair\x3c\/a\x3e 创建一对全双工匿名 socket，用于在进程间互发消息；其函数签名如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22int socketpair(int domain, int type, int protocol, int sv[2]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs q\x22\x3e\x3ccode class=\x22c\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-type\x22\x3eint\x3c\/span\x3e socketpair(\x3cspan class=\x22hljs-type\x22\x3eint\x3c\/span\x3e domain, \x3cspan class=\x22hljs-type\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3eint\x3c\/span\x3e protocol, \x3cspan class=\x22hljs-type\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esv\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通常情况下，我们是无法通过 socket 来传递文件描述符的；当主进程与客户端建立了连接，需要把连接描述符告知从进程处理，怎么办？其实，通过指定 socketpair 的第一个参数为 AF_UNIX，表示创建匿名 UNIX 域套接字（UNIX domain socket），这样就可以使用系统函数 \x3ca href=\x22https:\/\/linux.die.net\/man\/2\/sendmsg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esendmsg\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/linux.die.net\/man\/2\/recvmsg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erecvmsg\x3c\/a\x3e 来传递\/接收文件描述符了。\x3c\/p\x3e\n\x3cp\x3e主进程在调用 cluster.fork 时，相关流程如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建 Pipe（pipe_wrap.cc）对象，并且指定参数 ipc 为 true；\x3c\/li\x3e\n\x3cli\x3e调用 uv_spawn，options 参数为 uv_process_options_s 结构体，把 Pipe 对象存储在结构体的属性 stdio 中；\x3c\/li\x3e\n\x3cli\x3e调用 uv__process_init_stdio，通过 socketpair 创建全双工 socket；\x3c\/li\x3e\n\x3cli\x3e调用 uv__process_open_stream，设置 Pipe 对象的 iowatcher.fd 值为全双工 socket 之一。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e至此，主从进程就可以进行双向通信了。流程图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030642?w=1201\x26amp;h=899\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030642?w=1201\x26amp;h=899\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们再回看一下环境变量 NODE_CHANNEL_FD，令人疑惑的是，它的值始终为3。进程级文件描述符表中，0-2分别是标准输入stdin、标准输出stdout和标准错误输出stderr，那么可用的第一个文件描述符就是3，socketpair 显然会占用从进程的第一个可用文件描述符。这样，当从进程往 fd=3 的流中写入数据时，主进程就可以收到消息；反之，亦类似。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030643?w=805\x26amp;h=602\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030643?w=805\x26amp;h=602\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从 IPC 读取消息主要是流操作，以后有机会详解，下面列出主要流程：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eStreamBase::EditData 回调 onread；\x3c\/li\x3e\n\x3cli\x3eStreamWrap::OnReadImpl 调用 StreamWrap::EditData；\x3c\/li\x3e\n\x3cli\x3eStreamWrap 的构造函数会调用 set_read_cb 设置 OnReadImpl；\x3c\/li\x3e\n\x3cli\x3eStreamWrap::set_read_cb 设置属性 StreamWrap::read_cb_；\x3c\/li\x3e\n\x3cli\x3eStreamWrap::OnRead 中引用属性 read_cb_；\x3c\/li\x3e\n\x3cli\x3eStreamWrap::ReadStart 调用 uv_read_start 时传递 Streamwrap::OnRead 作为第3个参数：\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode class=\x22c\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3euv_read_start\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e涉及到的类图关系如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030644?w=505\x26amp;h=570\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030644?w=505\x26amp;h=570\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e服务器主从模型\x3c\/h1\x3e\n\x3cp\x3e以上大概分析了从进程的创建过程及其特殊性；如果要实现主从服务模型的话，还需要解决一个基本问题：从进程怎么获取到与客户端间的连接描述符？我们打算从 process.send（只有在从进程的全局 process 对象上才有 send 方法，主进程可以通过 worker.process 或 worker 访问该方法）的函数签名着手：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void send(message, sendHandle, callback)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e send(message, sendHandle, callback)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其参数 message 和 callback 含义也许显而易见，分别指待发送的消息对象和操作结束之后的回调函数。那它的第二个参数 sendHandle 用途是什么？\x3c\/p\x3e\n\x3cp\x3e前文提到系统函数 socketpair 可以创建一对双向 socket，能够用来发送 JSON 消息，这一块主要涉及到流操作；另外，当 sendHandle 有值时，它们还可以用于传递文件描述符，其过程要相对复杂一些，但是最终会调用系统函数 sendmsg 以及 recvmsg。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e传递与客户端的连接描述符\x3c\/h2\x3e\n\x3cp\x3e在主从服务模型下，主进程负责跟客户端建立连接，然后把连接描述符通过 \x3ca href=\x22https:\/\/linux.die.net\/man\/2\/sendmsg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esendmsg\x3c\/a\x3e 传递给从进程。我们来看看这一过程：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e从进程\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e调用 http.Server.listen 方法（继承至 net.Server）；\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e调用 cluster._getServer，向主进程发起消息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;cmd\x26quot;: \x26quot;NODE_HANDLE\x26quot;,\n  \x26quot;msg\x26quot;: {\n    \x26quot;act\x26quot;: \x26quot;queryServer\x26quot;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22cmd\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22NODE_HANDLE\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22msg\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22act\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22queryServer\x22\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e主进程\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e接收处理这个消息时，会新建一个 RoundRobinHandle 对象，为变量 handle。每个 handle 与一个连接端点对应，并且对应多个从进程实例；同时，它会开启与连接端点相应的 TCP 服务 socket。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class RoundRobinHandle {\n  construtor(key, address, port, addressType, fd) {\n    \/\/ 监听同一端点的从进程集合\n    this.all = [];\n\n    \/\/ 可用的从进程集合\n    this.free = [];\n\n    \/\/ 当前等待处理的客户端连接描述符集合\n    this.handles = [];\n\n    \/\/ 指定端点的TCP服务socket\n    this.server = null;\n  }\n  add(worker, send) {\n    \/\/ 把从进程实例加入this.all\n  }\n  remove(worker) {\n    \/\/ 移除指定从进程\n  }\n  distribute(err, handle) {\n    \/\/ 把连接描述符handle存入this.handles，并指派一个可用的从进程实例开始处理连接请求\n  }\n  handoff(worker) {\n    \/\/ 从this.handles中取出一个待处理的连接描述符，并向从进程发起消息\n    \/\/ {\n    \/\/  \x26quot;type\x26quot;: \x26quot;NODE_HANDLE\x26quot;,\n    \/\/  \x26quot;msg\x26quot;: {\n    \/\/    \x26quot;act\x26quot;: \x26quot;newconn\x26quot;,\n    \/\/  }\n    \/\/ }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRoundRobinHandle\x3c\/span\x3e \x3c\/span\x3e{\n  construtor(key, address, port, addressType, fd) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听同一端点的从进程集合\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.all = [];\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可用的从进程集合\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.free = [];\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前等待处理的客户端连接描述符集合\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handles = [];\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定端点的TCP服务socket\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.server = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  add(worker, send) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把从进程实例加入this.all\x3c\/span\x3e\n  }\n  remove(worker) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除指定从进程\x3c\/span\x3e\n  }\n  distribute(err, handle) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把连接描述符handle存入this.handles，并指派一个可用的从进程实例开始处理连接请求\x3c\/span\x3e\n  }\n  handoff(worker) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从this.handles中取出一个待处理的连接描述符，并向从进程发起消息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  \x22type\x22: \x22NODE_HANDLE\x22,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  \x22msg\x22: {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/    \x22act\x22: \x22newconn\x22,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  }\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ }\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e调用 handle.add 方法，把 worker 对象添加到 handle.all 集合中；\x3c\/li\x3e\n\x3cli\x3e当 handle.server 开始监听客户端请求之后，重置其 onconnection 回调函数为 RoundRobinHandle.distribute，这样的话主进程就不用实际处理客户端连接，只要分发连接给从进程处理即可。它会把连接描述符存入 handle.handles 集合，当有可用 worker 时，则向其发送消息 { \x22act\x22: \x22newconn\x22 }。如果被指派的 worker 没有回复确认消息 { \x22ack\x22: message.seq, accepted: true }，则会尝试把该连接分配给其他 worker。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e流程图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e从进程上调用listen\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030645?w=987\x26amp;h=705\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030645?w=987\x26amp;h=705\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e客户端连接处理\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030646?w=981\x26amp;h=392\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030646?w=981\x26amp;h=392\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e从进程如何与主进程监听同一端口？\x3c\/h2\x3e\n\x3cp\x3e原因主要有两点：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e I. 从进程中 Node.js 运行时的初始化略有不同\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e因为从进程存在环境变量 NODE_UNIQUE_ID，所以在 bootstrap_node.js 中，加载 cluster 模块时执行 workerInit 方法。这个地方与主进程执行的 masterInit 方法不同点在于：其一，从进程上没有 cluster.fork 方法，所以不能在从进程继续创建子孙进程；其二，Worker 对象上的方法 disconnect 和  destroy 实现也有所差异：我们以调用 worker.destroy 为例，在主进程上时，不能直接把从进程杀掉，而是通知从进程退出，然后再把它从集合里删除；当在从进程上时，从进程通知完主进程然后退出就可以了；其三，从进程上 cluster 模块新增了方法 _getServer，用于向主进程发起消息 {\x22act\x22: \x22queryServer\x22}，通知主进程创建 RoundRobinHandle 对象，并实际监听指定端口地址；然后自身用一个模拟的 TCP 描述符继续执行；\x3c\/li\x3e\n\x3cli\x3e调用 cluster._setupWorker 方法，主要是初始化 cluster.worker 属性，并监听消息 \x3cstrong\x3einternalMessage\x3c\/strong\x3e，处理两种消息类型：newconn 和 disconnect；\x3c\/li\x3e\n\x3cli\x3e向主进程发起消息 { \x22act\x22: \x22online\x22 }；\x3c\/li\x3e\n\x3cli\x3e因为从进程额环境变量中有 NODE_CHANNEL_FD，调用 internal\\process.setupChannel时，会连接到系统函数 socketpair 创建的双向 socket ，并监听 \x3cstrong\x3einternalMessage\x3c\/strong\x3e ，处理消息类型：NODE_HANDLE_ACK和NODE_HANDLE。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e II. listen 方法在主从进程中执行的代码略有不同。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在 net.Server（net.js）的方法 listen 中，如果是主进程，则执行标准的端口绑定流程；如果是从进程，则会调用 cluster._getServer，参见上面对该方法的描述。\x3c\/p\x3e\n\x3cp\x3e最后，附上基于libuv实现的一个 C 版 Master-Slave 服务模型，\x3ca href=\x22https:\/\/github.com\/Hujiang-FE\/simple-http-server\/tree\/master\/v2\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub地址\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e启动服务器之后，访问 \x3ca href=\x22http:\/\/localhost\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/localhost\x3c\/a\x3e:3333 的运行结果如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013030647?w=825\x26amp;h=363\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013030647?w=825\x26amp;h=363\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e相信通过本篇文章的介绍，大家已经对Node.js的Cluster有了一个全面的了解。下一次作者会跟大家一起深入分析Node.js进程管理在生产环境下的可用性问题，敬请期待。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e相关文章\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/58d4f5f144d90400692d1064\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e系列１｜走进Node.js之启动过程剖析\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5965bb26f265da6c204195b3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e系列２｜走进Node.js 之 HTTP实现分析\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012423305?w=1426\x26amp;h=778\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012423305?w=1426\x26amp;h=778\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e推荐： 翻译项目Master的自述：\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e1. \x3ca href=\x22https:\/\/juejin.im\/post\/59e87bef5188255ea95b1077\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e干货｜人人都是翻译项目的Master\x3c\/a\x3e\n\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2. \x3ca\x3eiKcamp出品微信小程序教学共5章16小节汇总(含视频)\x3c\/a\x3e\n\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e3. \x3ca href=\x22https:\/\/juejin.im\/post\/5a31eb2f6fb9a04528468046\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e开始免费连载啦～每周２更共11堂iKcamp课｜基于Koa2搭建Node.js实战项目教学（含视频）| 课程大纲介绍\x3c\/a\x3e\n\x3c\/h3\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>系列３｜走进Node.js之多进程模型</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013030634">https://segmentfault.com/a/1190000013030634</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/8ybwecsg7b3/" target="_blank">https://alili.tech/archive/8ybwecsg7b3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>