<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="聊聊V8引擎的垃圾回收"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>聊聊V8引擎的垃圾回收 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9150dq89z85/",
				"appid": "1613049289050283", 
				"title": "聊聊V8引擎的垃圾回收 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bh8z2czslce/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/nmvo50as20o/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&text=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&text=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&title=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&is_video=false&description=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&title=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&title=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&title=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9150dq89z85%2f&title=%e8%81%8a%e8%81%8aV8%e5%bc%95%e6%93%8e%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">聊聊V8引擎的垃圾回收</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。\x3c\/p\x3e\n\x3cp\x3e在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~\x3c\/p\x3e\n\x3cp\x3e希望这篇文章能帮到你，同时本文也会收录到我自己的\x3ca href=\x22http:\/\/blog.liuxuan.site\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e个人网站\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e为什么要有垃圾回收\x3c\/h1\x3e\n\x3cp\x3e在C语言和C\x2b\x2b语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过\x3cstrong\x3emalloc\x3c\/strong\x3e函数去手动分配，在用完之后，还要时刻记得用\x3cstrong\x3efree\x3c\/strong\x3e函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。\x3c\/p\x3e\n\x3cp\x3e但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。\x3c\/p\x3e\n\x3cp\x3e不需要我们去手动管理内存了，所以自然要有\x3cstrong\x3e垃圾回收\x3c\/strong\x3e，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。\x3c\/p\x3e\n\x3cp\x3e垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e内存结构分配\x3c\/h1\x3e\n\x3cp\x3e由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。\x3c\/p\x3e\n\x3cp\x3e在NodeJS环境中，我们可以通过\x3cstrong\x3eprocess.memoryUsage()\x3c\/strong\x3e来查看内存分配。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180413\/node_heap.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180413\/node_heap.png?imageView2\/1\/w\/800\x22 alt=\x22node环境v8内存\x22 title=\x22node环境v8内存\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eprocess.memoryUsage\x3c\/strong\x3e返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180413\/node_memory.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180413\/node_memory.png?imageView2\/1\/w\/800\x22 alt=\x22node环境v8内存\x22 title=\x22node环境v8内存\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22rss（resident set size）：所有内存占用，包括指令区和堆栈\n\nheapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsed\n\nheapUsed：V8引擎已经分配使用的堆内存\n\nexternal： V8管理C\x2b\x2b对象绑定到JavaScript对象上的内存\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3erss\x3c\/span\x3e（resident set size）：所有内存占用，包括指令区和堆栈\n\n\x3cspan class=\x22hljs-symbol\x22\x3eheapTotal\x3c\/span\x3e：\x3cspan class=\x22hljs-built_in\x22\x3eV8\x3c\/span\x3e引擎可以分配的最大堆内存，包含下面的 heapUsed\n\n\x3cspan class=\x22hljs-symbol\x22\x3eheapUsed\x3c\/span\x3e：\x3cspan class=\x22hljs-built_in\x22\x3eV8\x3c\/span\x3e引擎已经分配使用的堆内存\n\n\x3cspan class=\x22hljs-symbol\x22\x3eexternal\x3c\/span\x3e： \x3cspan class=\x22hljs-built_in\x22\x3eV8\x3c\/span\x3e管理C\x2b\x2b对象绑定到JavaScript对象上的内存\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上所有内存单位均为字节（Byte）。\x3c\/p\x3e\n\x3cp\x3e如果说想要扩大Node可用的内存空间，可以使用\x3cstrong\x3eBuffer\x3c\/strong\x3e等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。\x3c\/p\x3e\n\x3cp\x3e下面是Node的整体架构图，有助于大家理解上面的内容：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180413\/node_architecture.jpeg?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180413\/node_architecture.jpeg?imageView2\/1\/w\/800\x22 alt=\x22node环境v8内存\x22 title=\x22node环境v8内存\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块\n\nNode Bindings: 是沟通JS 和 C\x2b\x2b的桥梁，封装V8和Libuv的细节，向上层提供基础API服务\n\n第三层是支撑 Node.js 运行的关键，由 C\/C\x2b\x2b 实现：\n1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机\n2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I\/O能力\n3. C-ares：提供了异步处理 DNS 相关的能力\n4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStandard\x3c\/span\x3e Library: 是我们每天都在用的标准库，如Http, Buffer 模块\n\n\x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e Bindings:\x3cspan class=\x22hljs-title\x22\x3e 是沟通JS\x3c\/span\x3e 和 C\x2b\x2b的桥梁，封装V8和Libuv的细节，向上层提供基础API服务\n\n第三层是支撑 \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ejs\x3c\/span\x3e 运行的关键，由 C\/C\x2b\x2b 实现：\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ejs\x3c\/span\x3e 的发动机\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. Libuv 是专门为\x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ejs\x3c\/span\x3e开发的一个封装库，提供跨平台的异步I\/O能力\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. C-ares：提供了异步处理 DNS 相关的能力\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e垃圾回收机制\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e如何判断是否可以回收\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e1.1 标记清除\x3c\/h3\x3e\n\x3cp\x3e当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。\x3c\/p\x3e\n\x3cp\x3e可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e（1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。\x3c\/li\x3e\n\x3cli\x3e（2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记\x3c\/li\x3e\n\x3cli\x3e（3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。\x3c\/li\x3e\n\x3cli\x3e（4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180413\/gc_object.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180413\/gc_object.png?imageView2\/1\/w\/800\x22 alt=\x22标记清除\x22 title=\x22标记清除\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e活动对象\x3c\/strong\x3e就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e1.2 引用计数\x3c\/h3\x3e\n\x3cp\x3e引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。\x3c\/p\x3e\n\x3cp\x3e如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。\x3c\/p\x3e\n\x3cp\x3e当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。\x3c\/p\x3e\n\x3cp\x3e这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。\x3c\/p\x3e\n\x3cp\x3eNetscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：\x3cstrong\x3e循环引用\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo () {\n    var objA = new Object();\n    var objB = new Object();\n    \n    objA.otherObj = objB;\n    objB.anotherObj = objA;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objA = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objB = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\n    \n    objA.otherObj = objB;\n    objB.anotherObj = objA;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。\x3c\/p\x3e\n\x3cp\x3e在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。\x3c\/p\x3e\n\x3cp\x3e但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。\x3c\/p\x3e\n\x3cp\x3e加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。\x3c\/p\x3e\n\x3cp\x3e还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var el = document.getElementById(\x27#el\x27);\nel.onclick = function (event) {\n    console.log(\x27element was clicked\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e el = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27#el\x27\x3c\/span\x3e);\nel.onclick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27element was clicked\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们为一个元素的点击事件绑定了一个匿名函数，我们通过\x3cstrong\x3eevent\x3c\/strong\x3e参数是可以拿到相应元素\x3cstrong\x3eel\x3c\/strong\x3e的信息的。\x3c\/p\x3e\n\x3cp\x3e大家想想，这是不是就是一个循环引用呢？\x3cbr\x3e\x3cstrong\x3eel\x3c\/strong\x3e有一个属性\x3cstrong\x3eonclick\x3c\/strong\x3e引用了一个函数（其实也是个对象），函数里面的参数又引用了\x3cstrong\x3eel\x3c\/strong\x3e，这样\x3cstrong\x3eel\x3c\/strong\x3e的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。\x3c\/p\x3e\n\x3cp\x3e如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var el = document.getElementById(\x27#el\x27);\nel.onclick = function (event) {\n    console.log(\x27element was clicked\x27);\n}\n\n\/\/ ...\n\/\/ ...\n\n\/\/ 页面卸载时将绑定的事件清空\nwindow.onbeforeunload = function(){\n    el.onclick = null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e el = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27#el\x27\x3c\/span\x3e);\nel.onclick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27element was clicked\x27\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面卸载时将绑定的事件清空\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onbeforeunload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    el.onclick = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3eV8垃圾回收策略\x3c\/h1\x3e\n\x3cp\x3e自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。\x3c\/p\x3e\n\x3cp\x3e所以，V8采用了一种代回收的策略，将内存分为两个生代：\x3cstrong\x3e新生代（new generation）\x3c\/strong\x3e和\x3cstrong\x3e老生代（old generation）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升，后面我会详细说明。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e分代内存\x3c\/h1\x3e\n\x3cp\x3e默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。\x3c\/p\x3e\n\x3cp\x3e新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e新生代\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e1. 分配方式\x3c\/h2\x3e\n\x3cp\x3e新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e2. 算法\x3c\/h2\x3e\n\x3cp\x3e新生代采用\x3cstrong\x3eScavenge\x3c\/strong\x3e垃圾回收算法，在算法实现时主要采用\x3cstrong\x3eCheney\x3c\/strong\x3e算法。\x3c\/p\x3e\n\x3cp\x3eCheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180413\/new_old_generation.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180413\/new_old_generation.png?imageView2\/1\/w\/800\x22 alt=\x22新老生代\x22 title=\x22新老生代\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e处于使用状态的semispace称为\x3cstrong\x3eFrom空间\x3c\/strong\x3e，处于闲置状态的semispace称为\x3cstrong\x3eTo空间\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e我画了一套详细的流程图，接下来我会结合流程图来详细说明Cheney算法是怎么工作的。\x3cbr\x3e垃圾回收在下面我统称为 \x3cstrong\x3eGC（Garbage Collection）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep1\x3c\/strong\x3e. 在From空间中分配了3个对象A、B、C\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step1.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step1.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep2\x3c\/strong\x3e. GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step2.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step2.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep3\x3c\/strong\x3e. 将活跃对象A、C从From空间复制到To空间\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step3.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step3.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep4\x3c\/strong\x3e. 清空From空间的全部内存\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step4.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step4.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep5\x3c\/strong\x3e. 交换From空间和To空间\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step5.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step5.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep6\x3c\/strong\x3e. 在From空间中又新增了2个对象D、E\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step6.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step6.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep7\x3c\/strong\x3e. 下一轮GC进来发现对象D没有引用了，做标记\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step7.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step7.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep8\x3c\/strong\x3e. 将活跃对象A、C、E从From空间复制到To空间\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step8.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step8.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep9\x3c\/strong\x3e. 清空From空间全部内存\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step9.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step9.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep10\x3c\/strong\x3e. 继续交换From空间和To空间，开始下一轮\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/cheney_step10.png?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/cheney_step10.png?imageView2\/1\/w\/800\x22 alt=\x22cheney-step1\x22 title=\x22cheney-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。\x3c\/p\x3e\n\x3cp\x3eScavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。\x3c\/p\x3e\n\x3cp\x3e由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e3. 晋升\x3c\/h2\x3e\n\x3cp\x3e当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e对象从新生代移动到老生代的过程叫作晋升\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e对象晋升的条件主要有两个：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。\x3cstrong\x3e总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader13\x22\x3e老生代\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e1. 介绍\x3c\/h2\x3e\n\x3cp\x3e在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e由于存活对象较多，复制存活对象的效率会很低。\x3c\/li\x3e\n\x3cli\x3e采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以，V8在老生代中主要采用了\x3cstrong\x3eMark-Sweep\x3c\/strong\x3e和\x3cstrong\x3eMark-Sweep\x3c\/strong\x3e相结合的方式进行垃圾回收。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e2. Mark-Sweep\x3c\/h2\x3e\n\x3cp\x3eMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。\x3c\/p\x3e\n\x3cp\x3e与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。\x3c\/p\x3e\n\x3cp\x3e也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。\x3c\/p\x3e\n\x3cp\x3e我们还是通过流程图来看一下：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep1\x3c\/strong\x3e. 老生代中有对象A、B、C、D、E、F\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step1?imageView2\/1\/w\/800\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step1?imageView2\/1\/w\/800\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep2\x3c\/strong\x3e. GC进入标记阶段，将A、C、E标记为存活对象\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step2?imageView2\/1\/w\/801\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step2?imageView2\/1\/w\/801\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep3\x3c\/strong\x3e. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step3?imageView2\/1\/w\/801\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step3?imageView2\/1\/w\/801\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。\x3c\/p\x3e\n\x3cp\x3e如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e2. Mark-Compact\x3c\/h2\x3e\n\x3cp\x3e为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eMark-Compact是标记整理的意思，\x3c\/strong\x3e是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep1\x3c\/strong\x3e. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step1?imageView2\/1\/w\/801\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step1?imageView2\/1\/w\/801\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep2\x3c\/strong\x3e. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step2?imageView2\/1\/w\/801\x22 src=\x22https:\/\/static.alili.techhttp:\/\/image.liuxuan.site\/blog\/20180414\/mark_sweep_step2?imageView2\/1\/w\/801\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep3\x3c\/strong\x3e. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180414\/mark_compact_step3?imageView2\/1\/w\/850\x22 src=\x22https:\/\/static.alili.techhttp:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180414\/mark_compact_step3?imageView2\/1\/w\/850\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estep4\x3c\/strong\x3e. GC进入清除阶段，将边界另一侧的内存一次性全部回收\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180414\/mark_compact_step4?imageView2\/1\/w\/850\x22 src=\x22https:\/\/static.alili.techhttp:\/\/p54fus2hp.bkt.clouddn.com\/blog\/20180414\/mark_compact_step4?imageView2\/1\/w\/850\x22 alt=\x22mark-sweep-step1\x22 title=\x22mark-sweep-step1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e3. 两者结合\x3c\/h2\x3e\n\x3cp\x3e在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。\x3c\/p\x3e\n\x3cp\x3e由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader18\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3eV8的垃圾回收机制分为新生代和老生代。\x3c\/p\x3e\n\x3cp\x3e新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。\x3c\/p\x3e\n\x3cp\x3e老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。\x3c\/p\x3e\n\x3cp\x3e以上就是本文的全部内容，书写过程中参考了很多中外文章，参考书籍包括朴大大的《深入浅出NodeJS》以及《JavaScript高级程序设计》等。我们这里并没有对具体的算法实现进行探讨，感兴趣的朋友可以继续深入研究一下。\x3c\/p\x3e\n\x3cp\x3e最后，谢谢大家能够读到这里，如果文中有任何不明确或错误的地方，欢迎给我留言~~\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader19\x22\x3e参考链接\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/medium.com\/@_lrlna\/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/medium.com\/@_lrlna\/ga...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/alinode.aliyun.com\/blog\/14\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/alinode.aliyun.com\/blo...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2017\/04\/memory-leak.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ruanyifeng.com\/blo...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000000440270\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>聊聊V8引擎的垃圾回收</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014383214">https://segmentfault.com/a/1190000014383214</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9150dq89z85/" target="_blank">https://alili.tech/archive/9150dq89z85/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>