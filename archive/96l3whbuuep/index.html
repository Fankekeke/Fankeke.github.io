<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="教你编写 Node.js 中间件，实现服务端缓存（附demo源码）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>教你编写 Node.js 中间件，实现服务端缓存（附demo源码） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/96l3whbuuep/",
				"appid": "1613049289050283", 
				"title": "教你编写 Node.js 中间件，实现服务端缓存（附demo源码） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/63bxkm96q05/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/i36bljl4qkn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&text=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&text=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&title=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&is_video=false&description=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&title=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&title=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&title=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f96l3whbuuep%2f&title=%e6%95%99%e4%bd%a0%e7%bc%96%e5%86%99%20Node.js%20%e4%b8%ad%e9%97%b4%e4%bb%b6%ef%bc%8c%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bc%93%e5%ad%98%ef%bc%88%e9%99%84demo%e6%ba%90%e7%a0%81%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">教你编写 Node.js 中间件，实现服务端缓存（附demo源码）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011043576\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011043576\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eExpress 作为 Node.js 的框架，如今发展可谓如日中天。我很喜欢其灵活、易扩展的设计理念。尤其是该框架的中间件架构设计：使得在应用中加入新特性更加标准化、成本最小化。\x3cstrong\x3e这篇文章，我会尝试编写一个非常简单、小巧的中间件，完成服务端缓存功能，进而优化性能。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e关于中间件\x3c\/h2\x3e\n\x3cp\x3e说到中间件，Express 官网对它的阐述是这样的：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e“Express 是一个自身功能极简，完全是路由和中间件构成一个web开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。”\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e也许你使用过各种各样的中间件进行开发，但是可能并不理解中间件原理，也没有深入过 Express 源码，探究其实现。这里并不打算长篇大论帮您分析，但是使用层面上大致可以参考下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011043577\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011043577\x22 alt=\x22中间件原理\x22 title=\x22中间件原理\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e建议有兴趣、想深入的读者自己分析，有任何问题欢迎与我讨论。即便您不打算深入，也不会影响对下文中间件编写的理解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e关于服务端缓存\x3c\/h2\x3e\n\x3cp\x3e缓存已经被广泛应用，来提高页面性能。一说到缓存，可能读者脑海里马上冒出来：“客户端缓存，CDN 缓存，服务器端缓存......”。另一维度上，也会想到：“200（from cache），expire，eTag......”等概念。\x3c\/p\x3e\n\x3cp\x3e当然作为前端开发者，我们一定要明白这些缓存概念，这些缓存理念是相对于某个具体用户访问来说的，性能优化体现在单个用户上。比如说，我第一次打开页面 A，耗时超长，下一次打开页面由于缓存的作用，时间缩短了。\x3c\/p\x3e\n\x3cp\x3e但是在服务器端，还存在另外一个维度，思考一下这样的场景：\x3c\/p\x3e\n\x3cp\x3e我们有一个\x3cstrong\x3e静态\x3c\/strong\x3e页面 B，这个页面服务端需要从数据库获取部分数据 b1，根据 b1 又要计算得到部分数据 b2，还得做各种高复杂度操作，最终才能“东拼西凑”出需要返回的完整页面 B，整个过程耗时2s。\x3c\/p\x3e\n\x3cp\x3e那么面临的灾难就是，user1 打开页面耗时2s，user2同样打开页面耗时2s......而这些页面都是静态页面 B，内容是完全一样的。为了解决这个灾难，这时候我们也需要缓存，这种缓存就叫先做服务端缓存（server-side cache）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结一下，服务端缓存的目的其实就是对于同一个页面请求，而返回（缓存的）同样的页面内容。这个过程完全独立于不同的用户。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e上面的话有些拗口，可以参考英文表达更清晰：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eThe goal of server side cache is responding to the same content for the same request independently of the client’s request.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e因此，下面展示的 demo 在第一次请求到达时，服务端耗费5秒来返回 HTML；而接下来再次请求该页面，将会命中缓存，不过是哪个用户访问，只需要几毫秒便可得到完整页面。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eShow me the code \x26amp; Demo\x3c\/h2\x3e\n\x3cp\x3e其实上文提到的缓存概念非常简单，稍微有些后端经验的同学都能很好理解。但是这篇文章除去科普基本概念外，更重要的就是介绍 Express  中间件思想，并自己来实现一个服务端缓存中间件。\x3c\/p\x3e\n\x3cp\x3e让我们开工吧！\x3cbr\x3e最终 Demo 代码，欢迎访问\x3ca href=\x22https:\/\/github.com\/HOUCe\/server-side-cache-with-express\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e它的Github地址\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e我将会使用 npm 上 memory-cache 这个包，以方便进行缓存的读写。最终的中间件代码很简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nvar mcache = require(\x27memory-cache\x27);\n\nvar cache = (duration) =\x3e {\n  return (req, res, next) =\x3e {\n    let key = \x27__express__\x27 \x2b req.originalUrl || req.url\n    let cachedBody = mcache.get(key)\n    if (cachedBody) {\n      res.send(cachedBody)\n      return\n    } else {\n      res.sendResponse = res.send\n      res.send = (body) =\x3e {\n        mcache.put(key, body, duration * 1000);\n        res.sendResponse(body)\n      }\n      next()\n    }\n  }\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mcache = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27memory-cache\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cache = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eduration\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res, next\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key = \x3cspan class=\x22hljs-string\x22\x3e\x27__express__\x27\x3c\/span\x3e \x2b req.originalUrl || req.url\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cachedBody = mcache.get(key)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cachedBody) {\n      res.send(cachedBody)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      res.sendResponse = res.send\n      res.send = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ebody\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        mcache.put(key, body, duration * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n        res.sendResponse(body)\n      }\n      next()\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了简单，我使用了请求 URL 作为 cache 的 key：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e当它（cache key）及其对应的 value 值存在时，便直接返回其 value 值；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当它（cache key）及其对应的 value 值不存在时，我们将对 Express send 方法做一层拦截：在最终返回前，存入这对 key-value。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e缓存的有效时间是10秒。\x3c\/p\x3e\n\x3cp\x3e最终在判断之外，\x3cstrong\x3e我们的中间件把控制权交给下一个中间件。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e最终使用和测试如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22app.get(\x27\/\x27, cache(10), (req, res) =\x3e {\n  setTimeout(() =\x3e {\n    res.render(\x27index\x27, { title: \x27Hey\x27, message: \x27Hello there\x27, date: new Date()})\n  }, 5000) \/\/setTimeout was used to simulate a slow processing request\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3eapp.get(\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e, cache(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.render(\x3cspan class=\x22hljs-string\x22\x3e\x27index\x27\x3c\/span\x3e, { title: \x3cspan class=\x22hljs-string\x22\x3e\x27Hey\x27\x3c\/span\x3e, message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello there\x27\x3c\/span\x3e, date: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e()})\n  }, \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/setTimeout was used to simulate a slow processing request\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我使用了 setTimeout 来模拟一个超长（5s）的操作。\x3c\/p\x3e\n\x3cp\x3e打开浏览器控制面板，发现在10秒缓存到期以内：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011043578\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011043578\x22 alt=\x22加载信息\x22 title=\x22加载信息\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e至于为什么 cache 中间件要那样子写、next() 为什么是中间件把控制权传递，我并不打算展开去讲。有兴趣的读者可以看一下 Express 源码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e还有几个小问题\x3c\/h2\x3e\n\x3cp\x3e仔细看我们的页面，再去体会一下实现代码。也许细心的读者能发现一个问题：刚才的实现我们\x3cstrong\x3e缓存了整个页面\x3c\/strong\x3e，并将 date: new Date() 传入了 jade 模版 index.jade 里。那么，在命中缓存的条件下，10秒内，页面无法动态刷新来同步，直到10秒缓存到期。\x3c\/p\x3e\n\x3cp\x3e同时，我们什么时候可以使用上述中间件，进行服务端缓存呢？当然是静态内容才可以使用。同时，PUT, DELETE 和 POST 操作都不应该进行类似的缓存处理。\x3c\/p\x3e\n\x3cp\x3e同样，我们使用了 npm 模块：memory-cache，它存在优缺点如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e读写迅速而简单，不需要其他依赖；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当服务器或者这个进程挂掉的时候，缓存中的内容将会全部丢失。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ememcache 是将缓存内容存放在了自己进程的内存中，所以这部分内容是无法在多个 Node.js 进程之间共享的。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果这些弊端 really matter，在实际开发中我们可以选择分布式的 cache 服务，比如 Redis。同样你可以在 npm 上找到：express-redis-cache 模块使用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e在真实的开发场景中，服务端缓存已经成为 common sense，但是在 Node.js 的世界里，体会其中间件思想，自己手动编写服务，同样乐趣无穷。\x3c\/p\x3e\n\x3cp\x3e与实践相结合，我认为真正缓存整个页面（如同 demo 那样）并不是一个推荐的做法（当时实际场景实际分析），同样使用请求 url 作为缓存的 key 也有待考虑。比如，页面中的一些静态内容可能会在其他页面中重复使用到，复用就成了问题。\x3c\/p\x3e\n\x3cp\x3e真实场景下，\x3cstrong\x3e一切设计和逻辑都要为自己业务情况所负责。脱离需求谈实现，都是耍流氓。\x3c\/strong\x3e这个 demo 简易轻巧，有需要的读者可以访问\x3ca href=\x22https:\/\/github.com\/HOUCe\/server-side-cache-with-express\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e它的Github地址\x3c\/a\x3e，欢迎玩出各种花样。\x3c\/p\x3e\n\x3cp\x3eHappy Coding!\x3c\/p\x3e\n\x3cp\x3ePS: \x3cbr\x3e作者\x3ca href=\x22https:\/\/github.com\/HOUCe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub仓库\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/www.zhihu.com\/people\/lucas-hc\/answers\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e知乎问答链接\x3c\/a\x3e\x3cbr\x3e欢迎各种形式交流。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>教你编写 Node.js 中间件，实现服务端缓存（附demo源码）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011043573">https://segmentfault.com/a/1190000011043573</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/96l3whbuuep/" target="_blank">https://alili.tech/archive/96l3whbuuep/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>