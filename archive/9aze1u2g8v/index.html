<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="网页中文本朗读功能开发实现分享"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>网页中文本朗读功能开发实现分享 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9aze1u2g8v/",
				"appid": "1613049289050283", 
				"title": "网页中文本朗读功能开发实现分享 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-22T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ko3hbu2eeqc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bkgnt44mx2/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&text=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&text=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&title=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&is_video=false&description=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&title=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&title=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&title=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9aze1u2g8v%2f&title=%e7%bd%91%e9%a1%b5%e4%b8%ad%e6%96%87%e6%9c%ac%e6%9c%97%e8%af%bb%e5%8a%9f%e8%83%bd%e5%bc%80%e5%8f%91%e5%ae%9e%e7%8e%b0%e5%88%86%e4%ba%ab"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">网页中文本朗读功能开发实现分享</h1><div class="meta"><div class="postdate"><time datetime="2018-12-22" itemprop="datePublished">2018-12-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e网页中文本朗读功能开发实现分享\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/blog.cdswyda.com\/post\/2017120914\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文本首发我的博客 - https:\/\/blog.cdswyda.com\/post\/2017120914\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e前几天完成了一个需求，在网页中完成鼠标指向哪里，就用语音读出所指的文本。如果是按钮、链接、文本输入框，则还还要给出是什么的提醒。同时针对大段的文本，不能整段的去读，要按照标点符号进行断句处理。\x3c\/p\x3e\n\x3cp\x3e重点当然就是先获取到当前标签上的文本，再把文本转化成语音即可。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e标签朗读\x3c\/h2\x3e\n\x3cp\x3e这个很简单了，只用根据当前是什么标签，给出提示即可。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 标签朗读文本\nvar tagTextConfig = {\n    \x27a\x27: \x27链接\x27,\n    \x27input[text]\x27: \x27文本输入框\x27,\n    \x27input[password]\x27: \x27密码输入框\x27,\n    \x27button\x27: \x27按钮\x27,\n    \x27img\x27: \x27图片\x27\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标签朗读文本\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tagTextConfig = {\n    \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27链接\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27input[text]\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27文本输入框\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27input[password]\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27密码输入框\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27button\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27按钮\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27img\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27图片\x27\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还有需要朗读的标签，继续再添加即可。\x3c\/p\x3e\n\x3cp\x3e然后根据标签，返回前缀文本即可。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 获取标签朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n *\/\nfunction getTagText(el) {\n    if (!el) return \x27\x27;\n\n    var tagName = el.tagName.toLowerCase();\n\n    \/\/ 处理input等多属性元素\n    switch (tagName) {\n        case \x27input\x27:\n            tagName \x2b= \x27[\x27 \x2b el.type \x2b \x27]\x27;\n            break;\n        default:\n            break;\n    }\n\n    \/\/ 标签的功能提醒和作用应该有间隔，因此在最后加入一个空格\n    return (tagTextConfig[tagName] || \x27\x27) \x2b \x27 \x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 获取标签朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetTagText\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!el) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tagName = el.tagName.toLowerCase();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理input等多属性元素\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (tagName) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e:\n            tagName \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e \x2b el.type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27]\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标签的功能提醒和作用应该有间隔，因此在最后加入一个空格\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (tagTextConfig[tagName] || \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e获取完整的朗读文本就更简单了，先取标签的功能提醒，再取标签的文本即可。\x3c\/p\x3e\n\x3cp\x3e文本内容优先取 \x3ccode\x3etitle\x3c\/code\x3e 其次 \x3ccode\x3ealt\x3c\/code\x3e 最后 \x3ccode\x3einnerText\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 获取完整朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n *\/\nfunction getText(el) {\n    if (!el) return \x27\x27;\n\n    return getTagText(el) \x2b (el.title || el.alt || el.innerText || \x27\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 获取完整朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetText\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!el) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e getTagText(el) \x2b (el.title || el.alt || el.innerText || \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样就可以获取到一个标签的功能提醒和内容的全部带朗读文本了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e正文分隔\x3c\/h2\x3e\n\x3cp\x3e接下来要处理的就是正文分隔了，在这个过程中，踩了不少坑，走了不少弯路，好好记录一下。\x3c\/p\x3e\n\x3cp\x3e首先准备了正文分隔的配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正文拆分配置\nvar splitConfig = {\n    \/\/ 内容分段标签名称\n    unitTag: \x27p\x27,\n    \/\/ 正文中分隔正则表达式\n    splitReg: \/[,;，；。]\/g,\n    \/\/ 包裹标签名\n    wrapTag: \x27label\x27,\n    \/\/ 包裹标签类名\n    wrapCls: \x27speak-lable\x27,\n    \/\/ 高亮样式名和样式\n    hightlightCls: \x27speak-help-hightlight\x27,\n    hightStyle: \x27background: #000!important; color: #fff!important\x27\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正文拆分配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e splitConfig = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 内容分段标签名称\x3c\/span\x3e\n    unitTag: \x3cspan class=\x22hljs-string\x22\x3e\x27p\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正文中分隔正则表达式\x3c\/span\x3e\n    splitReg: \x3cspan class=\x22hljs-regexp\x22\x3e\/[,;，；。]\/g\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 包裹标签名\x3c\/span\x3e\n    wrapTag: \x3cspan class=\x22hljs-string\x22\x3e\x27label\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 包裹标签类名\x3c\/span\x3e\n    wrapCls: \x3cspan class=\x22hljs-string\x22\x3e\x27speak-lable\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 高亮样式名和样式\x3c\/span\x3e\n    hightlightCls: \x3cspan class=\x22hljs-string\x22\x3e\x27speak-help-hightlight\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ehightStyle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27background: #000!important; color: #fff!important\x27\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最开始想的就是直接按照正文中的分隔标点符号进行分隔就好了呀。\x3c\/p\x3e\n\x3cp\x3e想法如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e获取段落全部文本\x3c\/li\x3e\n\x3cli\x3e使用 \x3ccode\x3esplit(分隔正则表达式)\x3c\/code\x3e 方法将正文按照标点符号分隔成小段\x3c\/li\x3e\n\x3cli\x3e每个小段用标签包裹放回去即可\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e然而理想很丰满，现实很骨感。\x3c\/p\x3e\n\x3cp\x3e两个大坑如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3esplit\x3c\/code\x3e 方法进行分隔，分隔后分隔字符就丢了，也就是说把原文的一些标点符号给弄丢了。\x3c\/li\x3e\n\x3cli\x3e如果段落内还存在其他标签，而这个标签内部也正好存在待分隔的标点符号，那包裹分段标签时直接破换了原标签的完整性。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e关于第一个问题，丢失标点的符号，考虑过逐个标点来进行和替换 \x3ccode\x3esplit\x3c\/code\x3e 分隔方法为逐个字符循环来做。\x3c\/p\x3e\n\x3cp\x3e前者问题是原本一次完成的工作分成了多次，效率太低。第二种感觉效率更低了，分隔本来是很稀疏的，但是却要变成逐个字符出判断处理，更关键的是，分隔标点的位置要插入包裹标签，会导致字符串长度变化，还要处理下标索引。代码是机器跑的，或许不会觉得烦，但是我真的觉得好烦。如果这么干，或许以后哪个AI或者同事看到这样的代码，说不定会说“这真是个傻xxxx”。\x3c\/p\x3e\n\x3cp\x3e第二个问题想过很多办法来补救，如先使用正则匹配捕获内容中成对的标签，对标签内部的分隔先处理一遍，然后再处理整个的。\x3c\/p\x3e\n\x3cp\x3e想不明白问题二的，可参考一下待分隔的段落:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3e这是一段测试文本，这里有个链接。\x3ca\x3e您好，可以点击此处进行跳转\x3c\/a\x3e还有其他内容其他内容容其他内容容其他内容，容其他内容。\x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22 rel=\x22n\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e这是一段测试文本，这里有个链接。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e您好，可以点击此处进行跳转\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e还有其他内容其他内容容其他内容容其他内容，容其他内容。\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如先使用\x3ccode\x3e\/\x26lt;((\\w\x2b?)\x26gt;)(.\x2b?)\x26lt;\\\/\\2(?=\x26gt;)\/g\x3c\/code\x3e 正则，依次捕获段落内被标签包裹的内容，对标签内部的内容先处理。\x3c\/p\x3e\n\x3cp\x3e但是问题又来了，这么处理的都是字符串，在js中都是基本类型，这些操作进行的时候都是在复制的基础上进行的，要修改到原字符串里去，还得记录下原本的开始结束位置，再将新的插进去。繁，还是繁，但是已经比之前逐个字符去遍历的好，正则捕获中本来就有了匹配的索引，直接用即可，还能接受。\x3c\/p\x3e\n\x3cp\x3e但是这只是处理了段落内部标签的问题，段落内肯定还有很多文本是没有处理呢，怎么办？\x3c\/p\x3e\n\x3cp\x3e正则匹配到了只是段落内标签的结果啊，外面的没有啊。哦，对，有匹配到的索引，上次匹配到的位置加上上次处理的长度，就是一段直接文本的开始。下一次匹配到的索引-1就是这段直接文本的结束。这只是匹配过程中的，还有首尾要单独处理。又回到烦的老路上去了。。。\x3c\/p\x3e\n\x3cp\x3e这么烦，一个段落分隔能这么繁琐，我不信！\x3c\/p\x3e\n\x3cp\x3e突然想到了，有文本节点这么个东西，删繁就简嘛，正则先到边上去，直接处理段落的所有节点不就行了。\x3c\/p\x3e\n\x3cp\x3e文本节点则分隔直接包裹，标签节点则对内容进行包裹，这种情况下处理的直接是dom，更省事。\x3c\/p\x3e\n\x3cp\x3e文本节点里放标签？这是在开玩笑么，是也不是。文本节点里确实只能放文本，但是我把标签直接放进去，它会自动转义，那最后再替换出来不就行了。\x3c\/p\x3e\n\x3cp\x3e好了，方案终于有了，而且这个方案逻辑多简单，代码逻辑自然也不会烦。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 正文内容分段处理\n * @param {jQueryObject\/HTMLElement\/String}  $content 要处理的正文jQ对象或HTMLElement或其对应选择器\n *\/\nfunction splitConent($content) {\n    $content = $($content);\n\n    $content.find(splitConfig.unitTag).each(function (index, item) {\n        var $item = $(item),\n            text = $.trim($item.text());\n        if (!text) return;\n\n        var nodes = $item[0].childNodes;\n\n        $.each(nodes, function (i, node) {\n            switch (node.nodeType) {\n                case 3:\n                    \/\/ text 节点\n                    \/\/ 由于是文本节点，标签被转义了，后续再转回来\n                    node.data = \x27\x3c\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27 \x2b\n                        node.data.replace(splitConfig.splitReg, \x27\x3c\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e$\x26amp;\x3c\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27) \x2b\n                        \x27\x3c\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27;\n                    break;\n                case 1:\n                    \/\/ 元素节点\n                    var innerHtml = node.innerHTML,\n                        start = \x27\x27,\n                        end = \x27\x27;\n                    \/\/ 如果内部还有直接标签，先去掉\n                    var startResult = \/^\x3c\\w\x2b?\x3e\/.exec(innerHtml);\n                    if (startResult) {\n                        start = startResult[0];\n                        innerHtml = innerHtml.substr(start.length);\n                    }\n                    var endResult = \/\x3c\\\/\\w\x2b?\x3e$\/.exec(innerHtml);\n                    if (endResult) {\n                        end = endResult[0];\n                        innerHtml = innerHtml.substring(0, endResult.index);\n                    }\n                    \/\/ 更新内部内容\n                    node.innerHTML = start \x2b\n                        \x27\x3c\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27 \x2b\n                        innerHtml.replace(splitConfig.splitReg, \x27\x3c\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e$\x26amp;\x3c\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27) \x2b\n                        \x27\x3c\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27 \x2b\n                        end;\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        \/\/ 处理文本节点中被转义的html标签\n        $item[0].innerHTML = $item[0].innerHTML\n            .replace(new RegExp(\x27\x26amp;lt;\x27 \x2b splitConfig.wrapTag \x2b \x27\x26amp;gt;\x27, \x27g\x27), \x27\x3c\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27)\n            .replace(new RegExp(\x27\x26amp;lt;\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x26amp;gt;\x27, \x27g\x27), \x27\x3c\/\x27 \x2b splitConfig.wrapTag \x2b \x27\x3e\x27);\n        $item.find(splitConfig.wrapTag).addClass(splitConfig.wrapCls);\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 正文内容分段处理\n * @param {jQueryObject\/HTMLElement\/String}  $content 要处理的正文jQ对象或HTMLElement或其对应选择器\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esplitConent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e$content\x3c\/span\x3e) \x3c\/span\x3e{\n    $content = $($content);\n\n    $content.find(splitConfig.unitTag).each(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eindex, item\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e $item = $(item),\n            text = $.trim($item.text());\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!text) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nodes = $item[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].childNodes;\n\n        $.each(nodes, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ei, node\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (node.nodeType) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e:\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ text 节点\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于是文本节点，标签被转义了，后续再转回来\x3c\/span\x3e\n                    node.data = \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e \x2b\n                        node.data.replace(splitConfig.splitReg, \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;$\x26amp;\x26lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e) \x2b\n                        \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e;\n                    \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素节点\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e innerHtml = node.innerHTML,\n                        start = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n                        end = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果内部还有直接标签，先去掉\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startResult = \x3cspan class=\x22hljs-regexp\x22\x3e\/^\x26lt;\\w\x2b?\x26gt;\/\x3c\/span\x3e.exec(innerHtml);\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (startResult) {\n                        start = startResult[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n                        innerHtml = innerHtml.substr(start.length);\n                    }\n                    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e endResult = \x3cspan class=\x22hljs-regexp\x22\x3e\/\x26lt;\\\/\\w\x2b?\x26gt;$\/\x3c\/span\x3e.exec(innerHtml);\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (endResult) {\n                        end = endResult[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n                        innerHtml = innerHtml.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, endResult.index);\n                    }\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新内部内容\x3c\/span\x3e\n                    node.innerHTML = start \x2b\n                        \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e \x2b\n                        innerHtml.replace(splitConfig.splitReg, \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;$\x26amp;\x26lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e) \x2b\n                        \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e \x2b\n                        end;\n                    \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n                    \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n            }\n        });\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理文本节点中被转义的html标签\x3c\/span\x3e\n        $item[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].innerHTML = $item[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].innerHTML\n            .replace(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x26amp;lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26amp;gt;\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e)\n            .replace(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x26amp;lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26amp;gt;\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/\x27\x3c\/span\x3e \x2b splitConfig.wrapTag \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt;\x27\x3c\/span\x3e);\n        $item.find(splitConfig.wrapTag).addClass(splitConfig.wrapCls);\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中最后对文本节点中被转义的包裹标签替换似乎有点麻烦，但是没办法，ES5之前JavaScript并不支持正则的后行断言（也就是正则表达式中“后顾”）。所以没办法对包裹标签前后的 \x3ccode\x3e\x26amp;lt;\x3c\/code\x3e 和 \x3ccode\x3e\x26amp;gt;\x3c\/code\x3e 进行精准替换，只能连同标签名一起替换。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e事件处理\x3c\/h2\x3e\n\x3cp\x3e在上面完成了文本获取和段落分隔，下面要做的就是鼠标移动上去时获取文本触发朗读即可，移开时停止朗读即可。\x3c\/p\x3e\n\x3cp\x3e鼠标移动，只读一次，基于这两点原因，使用 \x3ccode\x3emouseenter\x3c\/code\x3e 和 \x3ccode\x3emouseleave\x3c\/code\x3e 事件来完成。\x3c\/p\x3e\n\x3cp\x3e原因：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e不冒泡，不会触发父元素的再次朗读\x3c\/li\x3e\n\x3cli\x3e不重复触发，一个元素内移动时不会重复触发。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 在页面上写入高亮样式\n *\/\nfunction createStyle() {\n    if (document.getElementById(\x27speak-light-style\x27)) return;\n\n    var style = document.createElement(\x27style\x27);\n    style.id = \x27speak-light-style\x27;\n    style.innerText = \x27.\x27 \x2b splitConfig.hightlightCls \x2b \x27{\x27 \x2b splitConfig.hightStyle \x2b \x27}\x27;\n    document.getElementsByTagName(\x27head\x27)[0].appendChild(style);\n}\n\/\/ 非正文需要朗读的标签 逗号分隔\nvar speakTags = \x27a, p, span, h1, h2, h3, h4, h5, h6, img, input, button\x27;\n\n$(document).on(\x27mouseenter.speak-help\x27, speakTags, function (e) {\n    var $target = $(e.target);\n\n    \/\/ 排除段落内的\n    if ($target.parents(\x27.\x27 \x2b splitConfig.wrapCls).length || $target.find(\x27.\x27 \x2b splitConfig.wrapCls).length) {\n        return;\n    }\n\n    \/\/ 图片样式单独处理 其他样式统一处理\n    if (e.target.nodeName.toLowerCase() === \x27img\x27) {\n        $target.css({\n            border: \x272px solid #000\x27\n        });\n    } else {\n        $target.addClass(splitConfig.hightlightCls);\n    }\n\n    \/\/ 开始朗读\n    speakText(getText(e.target));\n\n}).on(\x27mouseleave.speak-help\x27, speakTags, function (e) {\n    var $target = $(e.target);\n    if ($target.find(\x27.\x27 \x2b splitConfig.wrapCls).length) {\n        return;\n    }\n\n    \/\/ 图片样式\n    if (e.target.nodeName.toLowerCase() === \x27img\x27) {\n        $target.css({\n            border: \x27none\x27\n        });\n    } else {\n        $target.removeClass(splitConfig.hightlightCls);\n    }\n\n    \/\/ 停止语音\n    stopSpeak();\n});\n\n\/\/ 段落内文本朗读\n$(document).on(\x27mouseenter.speak-help\x27, \x27.\x27 \x2b splitConfig.wrapCls, function (e) {\n    $(this).addClass(splitConfig.hightlightCls);\n\n    \/\/ 开始朗读\n    speakText(getText(this));\n}).on(\x27mouseleave.speak-help\x27, \x27.\x27 \x2b splitConfig.wrapCls, function (e) {\n    $(this).removeClass(splitConfig.hightlightCls);\n\n    \/\/ 停止语音\n    stopSpeak();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 在页面上写入高亮样式\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateStyle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27speak-light-style\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e style = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27style\x27\x3c\/span\x3e);\n    style.id = \x3cspan class=\x22hljs-string\x22\x3e\x27speak-light-style\x27\x3c\/span\x3e;\n    style.innerText = \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.hightlightCls \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27{\x27\x3c\/span\x3e \x2b splitConfig.hightStyle \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27}\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x27head\x27\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].appendChild(style);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非正文需要朗读的标签 逗号分隔\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e speakTags = \x3cspan class=\x22hljs-string\x22\x3e\x27a, p, span, h1, h2, h3, h4, h5, h6, img, input, button\x27\x3c\/span\x3e;\n\n$(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e).on(\x3cspan class=\x22hljs-string\x22\x3e\x27mouseenter.speak-help\x27\x3c\/span\x3e, speakTags, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e $target = $(e.target);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除段落内的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ($target.parents(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.wrapCls).length || $target.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.wrapCls).length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片样式单独处理 其他样式统一处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target.nodeName.toLowerCase() === \x3cspan class=\x22hljs-string\x22\x3e\x27img\x27\x3c\/span\x3e) {\n        $target.css({\n            \x3cspan class=\x22hljs-attr\x22\x3eborder\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x272px solid #000\x27\x3c\/span\x3e\n        });\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        $target.addClass(splitConfig.hightlightCls);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始朗读\x3c\/span\x3e\n    speakText(getText(e.target));\n\n}).on(\x3cspan class=\x22hljs-string\x22\x3e\x27mouseleave.speak-help\x27\x3c\/span\x3e, speakTags, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e $target = $(e.target);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ($target.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.wrapCls).length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片样式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target.nodeName.toLowerCase() === \x3cspan class=\x22hljs-string\x22\x3e\x27img\x27\x3c\/span\x3e) {\n        $target.css({\n            \x3cspan class=\x22hljs-attr\x22\x3eborder\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e\n        });\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        $target.removeClass(splitConfig.hightlightCls);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止语音\x3c\/span\x3e\n    stopSpeak();\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 段落内文本朗读\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e).on(\x3cspan class=\x22hljs-string\x22\x3e\x27mouseenter.speak-help\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.wrapCls, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).addClass(splitConfig.hightlightCls);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始朗读\x3c\/span\x3e\n    speakText(getText(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}).on(\x3cspan class=\x22hljs-string\x22\x3e\x27mouseleave.speak-help\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b splitConfig.wrapCls, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).removeClass(splitConfig.hightlightCls);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止语音\x3c\/span\x3e\n    stopSpeak();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意要把针对段落的语音处理和其他地方的分开。为什么？ 因为段落是个块级元素，鼠标移入段落中的空白时，如：段落前后空白、首行缩进、末行剩余空白等，是不应该触发朗读的，如果不阻止掉，进行这些区域将直接触发整段文字的朗读，失去了我们对段落文本内分隔的意义，而且，无论什么方式转化语音都是要时间的，大段内容可能需要较长时间，影响语音输出的体验。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e文本合成语音\x3c\/h2\x3e\n\x3cp\x3e上面我们是直接使用了 \x3ccode\x3espeakText(text)\x3c\/code\x3e 和 \x3ccode\x3estopSpeak()\x3c\/code\x3e 两个方法来触发语音的朗读和停止。\x3c\/p\x3e\n\x3cp\x3e我们来看下如何实现这个两个功能。\x3c\/p\x3e\n\x3cp\x3e其实现代浏览器默认已经提供了上面功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var speechSU = new window.SpeechSynthesisUtterance();\nspeechSU.text = \x27你好，世界！\x27;\nwindow.speechSynthesis.speak(speechSU);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e speechSU = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.SpeechSynthesisUtterance();\nspeechSU.text = \x3cspan class=\x22hljs-string\x22\x3e\x27你好，世界！\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.speechSynthesis.speak(speechSU);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e复制到浏览器控制台看看能不能听到声音呢？(需要Chrome 33\x2b、Firefox 49\x2b 或 IE-Edge)\x3c\/p\x3e\n\x3cp\x3e利用一下两个API即可：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eSpeechSynthesisUtterance\x3c\/code\x3e 用于语音合成\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3elang\x3c\/code\x3e : 语言 Gets and sets the language of the utterance.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epitch\x3c\/code\x3e : 音高 Gets and sets the pitch at which the utterance will be spoken at.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3erate\x3c\/code\x3e : 语速 Gets and sets the speed at which the utterance will be spoken at.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3etext\x3c\/code\x3e : 文本 Gets and sets the text that will be synthesised when the utterance is spoken.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3evoice\x3c\/code\x3e : 声音 Gets and sets the voice that will be used to speak the utterance.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3evolume\x3c\/code\x3e : 音量 Gets and sets the volume that the utterance will be spoken at.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonboundary\x3c\/code\x3e : 单词或句子边界触发，即分隔处触发 Fired when the spoken utterance reaches a word or sentence boundary.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonend\x3c\/code\x3e : 结束时触发 Fired when the utterance has finished being spoken.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonerror\x3c\/code\x3e : 错误时触发 Fired when an error occurs that prevents the utterance from being succesfully spoken.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonmark\x3c\/code\x3e : Fired when the spoken utterance reaches a named SSML \x22mark\x22 tag.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonpause\x3c\/code\x3e : 暂停时触发 Fired when the utterance is paused part way through.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonresume\x3c\/code\x3e : 重新播放时触发 Fired when a paused utterance is resumed.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonstart\x3c\/code\x3e : 开始时触发 Fired when the utterance has begun to be spoken.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eSpeechSynthesis\x3c\/code\x3e : 用于朗读\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3epaused\x3c\/code\x3e : \x3cstrong\x3eRead only\x3c\/strong\x3e 是否暂停 A Boolean that returns true if the SpeechSynthesis object is in a paused state.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epending\x3c\/code\x3e : \x3cstrong\x3eRead only\x3c\/strong\x3e 是否处理中 A Boolean that returns true if the utterance queue contains as-yet-unspoken utterances.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3espeaking\x3c\/code\x3e : \x3cstrong\x3eRead only\x3c\/strong\x3e 是否朗读中 A Boolean that returns true if an utterance is currently in the process of being spoken — even if SpeechSynthesis is in a paused state.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonvoiceschanged\x3c\/code\x3e : 声音变化时触发\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecancel()\x3c\/code\x3e : 情况待朗读队列 Removes all utterances from the utterance queue.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3egetVoices()\x3c\/code\x3e : 获取浏览器支持的语音包列表 Returns a list of SpeechSynthesisVoice objects representing all the available voices on the current device.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epause()\x3c\/code\x3e : 暂停 Puts the SpeechSynthesis object into a paused state.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eresume()\x3c\/code\x3e : 重新开始 Puts the SpeechSynthesis object into a non-paused state: resumes it if it was already paused.\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3espeak()\x3c\/code\x3e : 读合成的语音，参数必须为\x3ccode\x3eSpeechSynthesisUtterance\x3c\/code\x3e的实例 Adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e详细api和说明可参考:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/SpeechSynthesisUtterance\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN - SpeechSynthesisUtterance\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/SpeechSynthesis\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN - SpeechSynthesis\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那么上面的两个方法可以写为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var speaker = new window.SpeechSynthesisUtterance();\nvar speakTimer,\n    stopTimer;\n\n\/\/ 开始朗读\nfunction speakText(text) {\n    clearTimeout(speakTimer);\n    window.speechSynthesis.cancel();\n    speakTimer = setTimeout(function () {\n        speaker.text = text;\n        window.speechSynthesis.speak(speaker);\n    }, 200);\n}\n\n\/\/ 停止朗读\nfunction stopSpeak() {\n    clearTimeout(stopTimer);\n    clearTimeout(speakTimer);\n    stopTimer = setTimeout(function () {\n        window.speechSynthesis.cancel();\n    }, 20);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 rel=\x22n\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e speaker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.SpeechSynthesisUtterance();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e speakTimer,\n    stopTimer;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始朗读\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espeakText\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) \x3c\/span\x3e{\n    clearTimeout(speakTimer);\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.speechSynthesis.cancel();\n    speakTimer = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        speaker.text = text;\n        \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.speechSynthesis.speak(speaker);\n    }, \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止朗读\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estopSpeak\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    clearTimeout(stopTimer);\n    clearTimeout(speakTimer);\n    stopTimer = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.speechSynthesis.cancel();\n    }, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为语音合成本来是个异步的操作，因此在过程中进行以上处理。\x3c\/p\x3e\n\x3cp\x3e现代浏览器已经内置了这个功能，两个API接口兼容性如下：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eFeature\x3c\/th\x3e\n\x3cth\x3eChrome\x3c\/th\x3e\n\x3cth\x3eEdge\x3c\/th\x3e\n\x3cth\x3eFirefox (Gecko)\x3c\/th\x3e\n\x3cth\x3eInternet Explorer\x3c\/th\x3e\n\x3cth\x3eOpera\x3c\/th\x3e\n\x3cth\x3eSafari\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3ctd\x3e(WebKit) Basic\x3c\/td\x3e\n\x3ctd\x3esupport 33\x3c\/td\x3e\n\x3ctd\x3e(Yes)\x3c\/td\x3e\n\x3ctd\x3e49 (49)\x3c\/td\x3e\n\x3ctd\x3eNo support\x3c\/td\x3e\n\x3ctd\x3e?\x3c\/td\x3e\n\x3ctd\x3e7\x3c\/td\x3e\n\x3c\/tr\x3e\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e如果要兼容其他浏览器或者需要一种完美兼容的解决方案，可能就需要服务端完成了，根据给定文本，返回相应语音即可，\x3ca href=\x22http:\/\/yuyin.baidu.com\/docs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e百度语音 http:\/\/yuyin.baidu.com\/docs\x3c\/a\x3e就提供这样的服务。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/cdswyda\/show\/tree\/master\/demo\/speaker\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecdswyda - 网页文本朗读实现 - github\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/cdswyda.github.io\/show\/demo\/speaker\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e cdswyda - 网页文本朗读实现 - demo\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>网页中文本朗读功能开发实现分享</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012370016">https://segmentfault.com/a/1190000012370016</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9aze1u2g8v/" target="_blank">https://alili.tech/archive/9aze1u2g8v/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>