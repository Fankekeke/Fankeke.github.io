<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从源码全面剖析 React 组件更新机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从源码全面剖析 React 组件更新机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9b854awzdxv/",
				"appid": "1613049289050283", 
				"title": "从源码全面剖析 React 组件更新机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/b11qugbj8jk/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ocn3waj3cqe/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&text=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&text=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&is_video=false&description=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9b854awzdxv%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e5%85%a8%e9%9d%a2%e5%89%96%e6%9e%90%20React%20%e7%bb%84%e4%bb%b6%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从源码全面剖析 React 组件更新机制</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact 把组件看作状态机(有限状态机), 使用state来控制本地状态, 使用props来传递状态.  前面我们探讨了 React 如何映射状态到 UI 上(初始渲染), 那么接下来我们谈谈 React 时如何同步状态到 UI 上的, 也就是:\x3c\/p\x3e\n\x3cp\x3eReact 是如何更新组件的? \x3c\/p\x3e\n\x3cp\x3eReact 是如何对比出页面变化最小的部分?\x3c\/p\x3e\n\x3cp\x3e这篇文章会为你解答这些问题.\x3c\/p\x3e\n\x3ch3\x3e在这之前\x3c\/h3\x3e\n\x3cp\x3e你已经了解了React (15-stable版本)内部的一些基本概念, 包括不同类型的组件实例、mount过程、事务、批量更新的大致过程(还没有? 不用担心, 为你准备好了\x3ca href=\x22http:\/\/realtcg.com\/2018\/02\/11\/%E7%AA%A5%E6%8E%A2React-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/\x22 rel=\x22nofollow noreferrer\x22\x3e从源码看组件初始渲染\x3c\/a\x3e、\x3ca href=\x22http:\/\/realtcg.com\/2018\/03\/17\/%E7%AA%A5%E6%8E%A2React-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C\/\x22 rel=\x22nofollow noreferrer\x22\x3e接着从源码看组件初始渲染\x3c\/a\x3e);\x3c\/p\x3e\n\x3cp\x3e准备一个\x3ca href=\x22https:\/\/github.com\/MrStronger\/react-experiment\x22 rel=\x22nofollow noreferrer\x22\x3edemo\x3c\/a\x3e, 调试源码, 以便更好理解;\x3c\/p\x3e\n\x3cp\x3eKeep calm and make a big deal !\x3c\/p\x3e\n\x3ch2\x3eReact 是如何更新组件的?\x3c\/h2\x3e\n\x3ch5\x3eTL;DR\x3c\/h5\x3e\n\x3cul\x3e\n\x3cli\x3e依靠事务进行批量更新;\x3c\/li\x3e\n\x3cli\x3e一次batch(批量)的生命周期就是从\x3ccode\x3eReactDefaultBatchingStrategy\x3c\/code\x3e事务perform之前(调用ReactUpdates.batchUpdates)到这个事务的最后一个close方法调用后结束;\x3c\/li\x3e\n\x3cli\x3e事务启动后, 遇到 setState 则将 partial state 存到组件实例的_pendingStateQueue上, 然后将这个组件存到dirtyComponents 数组中, 等到 \x3ccode\x3eReactDefaultBatchingStrategy\x3c\/code\x3e事务结束时调用\x3ccode\x3erunBatchedUpdates\x3c\/code\x3e批量更新所有组件;\x3c\/li\x3e\n\x3cli\x3e组件的更新是递归的, 三种不同类型的组件都有自己的\x3ccode\x3eupdateComponent\x3c\/code\x3e方法来决定自己的组件如何更新, 其中 ReactDOMComponent 会采用diff算法对比子元素中最小的变化, 再批量处理.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这个更新过程像是一套流程, 无论你通过setState(或者replaceState)还是新的props去更新一个组件, 都会起作用.\x3c\/p\x3e\n\x3ch3\x3e那么具体是什么?\x3c\/h3\x3e\n\x3cp\x3e让我们从这套更新流程的开始部分讲起...\x3c\/p\x3e\n\x3ch4\x3e调用 setState 之前\x3c\/h4\x3e\n\x3cp\x3e首先, 开始一次batch的入口是在\x3ccode\x3eReactDefaultBatchingStrategy\x3c\/code\x3e里, 调用里面的\x3ccode\x3ebatchedUpdates\x3c\/code\x3e便可以开启一次batch:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ 批处理策略\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false, \n  batchedUpdates: function(callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true; \/\/ 开启一次batch\n\n    if (alreadyBatchingUpdates) {\n      return callback(a, b, c, d, e);\n    } else {\n      \/\/ 启动事务, 将callback放进事务里执行\n      return transaction.perform(callback, null, a, b, c, d, e);  \n    }\n  },\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 React 中, 调用\x3ccode\x3ebatchedUpdates\x3c\/code\x3e有很多地方, 与更新流程相关的如下\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactMount.js\nReactUpdates.batchedUpdates(\n      batchedMountComponentIntoNode,  \/\/ 负责初始渲染\n      componentInstance,\n      container,\n      shouldReuseMarkup,\n      context,\n);\n\n\/\/ ReactEventListener.js\ndispatchEvent: function(topLevelType, nativeEvent) {\n    ...\n    try {\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);  \/\/ 处理事件\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第一种情况, React 在首次渲染组件的时候会调用\x3ccode\x3ebatchedUpdates\x3c\/code\x3e, 然后开始渲染组件. 那么为什么要在这个时候启动一次batch呢? 不是因为要批量插入, 因为插入过程是递归的, 而是因为组件在渲染的过程中, 会依顺序调用各种生命周期函数, 开发者很可能在生命周期函数中(如\x3ccode\x3ecomponentWillMount\x3c\/code\x3e或者\x3ccode\x3ecomponentDidMount\x3c\/code\x3e)调用\x3ccode\x3esetState\x3c\/code\x3e. 因此, 开启一次batch就是要存储更新(放入dirtyComponents), 然后在事务结束时批量更新. 这样以来, 在初始渲染流程中, 任何\x3ccode\x3esetState\x3c\/code\x3e都会生效, 用户看到的始终是最新的状态.\x3c\/p\x3e\n\x3cp\x3e第二种情况, 如果你在HTML元素上或者组件上绑定了事件, 那么你有可能在事件的监听函数中调用\x3ccode\x3esetState\x3c\/code\x3e, 因此, 同样为了存储更新(放入dirtyComponents), 需要启动批量更新策略. 在回调函数被调用之前, React事件系统中的\x3ccode\x3edispatchEvent\x3c\/code\x3e函数负责事件的分发, 在\x3ccode\x3edispatchEvent\x3c\/code\x3e中启动了事务, 开启了一次batch, 随后调用了回调函数. 这样一来, 在事件的监听函数中调用的\x3ccode\x3esetState\x3c\/code\x3e就会生效.\x3c\/p\x3e\n\x3cp\x3e也就是说, 任何可能调用 setState 的地方, 在调用之前, React 都会启动批量更新策略以提前应对可能的setState\x3c\/p\x3e\n\x3ch4\x3e那么调用 batchedUpdates 后发生了什么?\x3c\/h4\x3e\n\x3cp\x3eReact 调用\x3ccode\x3ebatchedUpdates\x3c\/code\x3e时会传进去一个函数, \x3ccode\x3ebatchedUpdates\x3c\/code\x3e会启动\x3ccode\x3eReactDefaultBatchingStrategyTransaction\x3c\/code\x3e事务, 这个函数就会被放在事务里执行:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactDefaultBatchingStrategy.js\nvar transaction = new ReactDefaultBatchingStrategyTransaction(); \/\/ 实例化事务\nvar ReactDefaultBatchingStrategy = {\n  ...\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    ...\n      return transaction.perform(callback, null, a, b, c, d, e);  \/\/ 将callback放进事务里执行\n       ...\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eReactDefaultBatchingStrategyTransaction\x3c\/code\x3e这个事务控制了批量策略的生命周期:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactDefaultBatchingStrategy.js\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),  \/\/ 批量更新\n};\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;  \/\/ 结束本次batch\n  },\n};\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e无论你传进去的函数是什么, 无论这个函数后续会做什么, 都会在执行完后调用上面事务的close方法, 先调用\x3ccode\x3eflushBatchedUpdates\x3c\/code\x3e批量更新, 再结束本次batch.\x3c\/p\x3e\n\x3ch4\x3e调用 setState 后发生了什么\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactBaseClasses.js :\nReactComponent.prototype.setState = function(partialState, callback) {\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, \x27setState\x27);\n  }\n};\n\n\/\/ =\x26gt; ReactUpdateQueue.js:\nenqueueSetState: function(publicInstance, partialState) {\n    \/\/ 根据 this.setState 中的 this 拿到内部实例, 也就是组件实例\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, \x27setState\x27);\n    \/\/ 取得组件实例的_pendingStateQueue\n    var queue =\n      internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    \/\/ 将partial state存到_pendingStateQueue\n    queue.push(partialState);\n    \/\/ 调用enqueueUpdate\n    enqueueUpdate(internalInstance);\n }\n\n\/\/ =\x26gt; ReactUpdate.js:\nfunction enqueueUpdate(component) {\n  ensureInjected(); \/\/ 注入默认策略\n    \n    \/\/ 如果没有开启batch(或当前batch已结束)就开启一次batch再执行, 这通常发生在异步回调中调用 setState      \/\/ 的情况\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n    \/\/ 如果batch已经开启就存储更新\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber \x2b 1;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说, 调用 setState 会首先拿到内部组件实例, 然后把要更新的partial state存到其_pendingStateQueue中, 然后标记当前组件为\x3ccode\x3edirtyComponent\x3c\/code\x3e, 存到\x3ccode\x3edirtyComponents\x3c\/code\x3e数组中. 然后就接着继续做下面的事情了, 并没有立即更新, 这是因为接下来要执行的代码里有可能还会调用 setState, 因此只做存储处理.\x3c\/p\x3e\n\x3ch4\x3e什么时候批量更新?\x3c\/h4\x3e\n\x3cp\x3e首先, 一个事务在执行的时候(包括initialize、perform、close阶段), 任何一阶段都有可能调用一系列函数, 并且开启了另一些事务. 那么只有等后续开启的事务执行完, 之前开启的事务才继续执行. 下图是我们刚才所说的第一种情况, 在初始渲染组件期间 setState 后, React 启动的各种事务和执行的顺序:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442213?w=465\x26amp;h=620\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442213?w=465\x26amp;h=620\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从图中可以看到, \x3cstrong\x3e批量更新是在\x3ccode\x3eReactDefaultBatchingStrategyTransaction\x3c\/code\x3e事务的close阶段, 在\x3ccode\x3eflushBatchedUpdates\x3c\/code\x3e函数中启动了\x3ccode\x3eReactUpdatesFlushTransaction\x3c\/code\x3e事务负责批量更新.\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e怎么批量更新的?\x3c\/h4\x3e\n\x3ch5\x3e开启批量更新事务、批量处理callback\x3c\/h5\x3e\n\x3cp\x3e我们接着看\x3ccode\x3eflushBatchedUpdates\x3c\/code\x3e函数, 在ReactUpdates.js中\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3evar flushBatchedUpdates = function () {\n  \/\/ 启动批量更新事务\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\/\/ 批量处理callback\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e遍历dirtyComponents\x3c\/h5\x3e\n\x3cp\x3e\x3ccode\x3eflushBatchedUpdates\x3c\/code\x3e启动了一个更新事务, 这个事务执行了\x3ccode\x3erunBatchedUpdates\x3c\/code\x3e进行批量更新:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactUpdates.js\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  \/\/ 排序保证父组件优先于子组件更新\n  dirtyComponents.sort(mountOrderComparator);\n\n  \/\/ 代表批量更新的次数, 保证每个组件只更新一次\n  updateBatchNumber\x2b\x2b;\n  \/\/ 遍历 dirtyComponents\n  for (var i = 0; i \x26lt; len; i\x2b\x2b) {\n    var component = dirtyComponents[i];\n      \n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n    ...\n    \/\/ 执行更新\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction,\n      updateBatchNumber,\n    );\n    ...\n    \/\/ 存储 callback以便后续按顺序调用\n    if (callbacks) {\n      for (var j = 0; j \x26lt; callbacks.length; j\x2b\x2b) {\n        transaction.callbackQueue.enqueue(\n          callbacks[j],\n          component.getPublicInstance(),\n        );\n      }\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e前面 setState 后将组件推入了\x3ccode\x3edirtyComponents\x3c\/code\x3e, 现在就是要遍历\x3ccode\x3edirtyComponents\x3c\/code\x3e数组进行更新了.\x3c\/p\x3e\n\x3ch5\x3e根据不同情况执行更新\x3c\/h5\x3e\n\x3cp\x3e\x3ccode\x3eReactReconciler\x3c\/code\x3e会调用组件实例的\x3ccode\x3eperformUpdateIfNecessary\x3c\/code\x3e.  如果接收了props, 就会调用此组件的\x3ccode\x3ereceiveComponent\x3c\/code\x3e, 再在里面调用\x3ccode\x3eupdateComponent\x3c\/code\x3e更新组件; 如果没有接受props, 但是有新的要更新的状态(_pendingStateQueue不为空)就会直接调用\x3ccode\x3eupdateComponent\x3c\/code\x3e来更新:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactCompositeComponent.js\nperformUpdateIfNecessary: function (transaction) {\n    if (this._pendingElement != null) {\n        ReactReconciler.receiveComponent(this, this._pendingElement, transaction,                 this._context);\n    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n        this.updateComponent(transaction, this._currentElement, this._currentElement,             this._context, this._context);\n    } else {\n        this._updateBatchNumber = null;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e调用组件实例的updateComponent\x3c\/h5\x3e\n\x3cp\x3e接下里就是重头戏\x3ccode\x3eupdateComponent\x3c\/code\x3e了, 它决定了组件如果更新自己和它的后代们. \x3cstrong\x3e需要特别注意的是, React 内部三种不同的组件类型, 每种组件都有自己的\x3ccode\x3eupdateComponent\x3c\/code\x3e, 有不同的行为.\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e对于 ReactCompositeComponent (\x3ca href=\x22https:\/\/www.processon.com\/view\/link\/5acb3adfe4b0899654a18c4d\x22 rel=\x22nofollow noreferrer\x22\x3e矢量图\x3c\/a\x3e):\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442214?w=1261\x26amp;h=523\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442214?w=1261\x26amp;h=523\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eupdateComponent\x3c\/code\x3e所做的事情 :\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e调用此层级组件的一系列生命周期函数, 并且在合适的时机更新props、state、context;\x3c\/li\x3e\n\x3cli\x3ere-render, 与之前 render 的 element 比较, 如果两者key \x26amp;\x26amp; element.type 相等, 则进入下一层进行更新; 如果不等, 直接移除重新mount\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于 ReactDOMComponent:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442215?w=1304\x26amp;h=583\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442215?w=1304\x26amp;h=583\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eupdateComponent\x3c\/code\x3e所做的事情 :\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e更新这一层级DOM元素属性;\x3c\/li\x3e\n\x3cli\x3e更新子元素, 调用 ReactMultiChild 的 \x3ccode\x3eupdateChildren\x3c\/code\x3e, 对比前后变化、标记变化类型、存到updates中(diff算法主要部分);\x3c\/li\x3e\n\x3cli\x3e批量处理updates\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于 ReactDOMTextComponent :\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442216\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442216\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面只是每个组件自己更新的过程, 那么 React 是如何一次性更新所有组件的 ? 答案是递归.\x3c\/p\x3e\n\x3ch5\x3e递归调用组件的updateComponent\x3c\/h5\x3e\n\x3cp\x3e观察 ReactCompositeComponent 和 ReactDOMComponent 的更新流程, 我们发现 React 每次走到一个组件更新过程的最后部分, 都会有一个判断 : 如果 nextELement 和 prevElement key 和 type 相等, 就会调用\x3ccode\x3ereceiveComponent\x3c\/code\x3e. \x3ccode\x3ereceiveComponent\x3c\/code\x3e和\x3ccode\x3eupdateComponent\x3c\/code\x3e一样, 每种组件都有一个, 作用就相当于updateComponent 接受了新 props 的版本. 而这里调用的就是子元素的\x3ccode\x3ereceiveComponent\x3c\/code\x3e, 进而进行子元素的更新, 于是就形成了递归更新、递归diff. 因此, 整个流程就像这样(\x3ca href=\x22https:\/\/www.processon.com\/view\/link\/5acb3adfe4b0899654a18c4d\x22 rel=\x22nofollow noreferrer\x22\x3e矢量图\x3c\/a\x3e) :\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442217?w=1113\x26amp;h=760\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442217?w=1113\x26amp;h=760\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这种更新完一级、diff完一级再进入下一级的过程保证 React 只遍历一次组件树就能完成更新, 但代价就是只要前后 render 出元素的 type 和 key 有一个不同就删除重造, 因此, React 建议页面要尽量保持稳定的结构.\x3c\/p\x3e\n\x3ch2\x3eReact 是如何对比出页面变化最小的部分?\x3c\/h2\x3e\n\x3cp\x3e你可能会说 React 用 virtual DOM 表示了页面结构, 每次更新, React 都会re-render出新的 virtual DOM, 再通过 diff 算法对比出前后变化, 最后批量更新. 没错, 很好, 这就是大致过程, 但这里存在着一些隐藏的深层问题值得探讨 :\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eReact 是如何用 virtual DOM 表示了页面结构, 从而使任何页面变化都能被 diff 出来?\x3c\/li\x3e\n\x3cli\x3eReact 是如何 diff 出页面变化最小的部分?\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eReact 如何表示页面结构\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3eclass C extends React.Component {\n    render () {\n        return (\n            \x26lt;div className=\x27container\x27\x26gt;\n                  \x22dscsdcsd\x22\n                  \x26lt;i onClick={(e) =\x26gt; console.log(e)}\x26gt;{this.state.val}\x26lt;\/i\x26gt;\n                  \x26lt;Children val={this.state.val}\/\x26gt;\n            \x26lt;\/div\x26gt;\n        )\n    }\n}\n\/\/ virtual DOM(React element)\n{\n  $$typeof: Symbol(react.element)\n  key: null\n  props: {  \/\/ props 代表元素上的所有属性, 有children属性, 描述子组件, 同样是元素\n    children: [\n      \x22\x22dscsdcsd\x22\x22,\n      {$$typeof: Symbol(react.element), type: \x22i\x22, key: null, ref: null, props: {…}, …},\n      {$$typeof: Symbol(react.element), type: class Children, props: {…}, …}\n    ]\n    className: \x27container\x27\n  }  \n  ref: null\n  type: \x22div\x22\n  _owner: ReactCompositeComponentWrapper {...} \/\/ class C 实例化后的对象\n  _store: {validated: false}\n  _self: null\n  _source: null\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每个标签, 无论是DOM元素还是自定义组件, 都会有 key、type、props、ref 等属性.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ekey 代表元素唯一id值, 意味着只要id改变, 就算前后元素种类相同, 元素也肯定不一样了;\x3c\/li\x3e\n\x3cli\x3etype 代表元素种类,  有 function(空的wrapper)、class(自定义类)、string(具体的DOM元素名称)类型, 与key一样, 只要改变, 元素肯定不一样;\x3c\/li\x3e\n\x3cli\x3eprops 是元素的属性, 任何写在标签上的属性(如className=\x27container\x27)都会被存在这里, 如果这个元素有子元素(包括文本内容), props就会有children属性, 存储子元素; children属性是递归插入、递归更新的依据;\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e也就是说, 如果元素唯一标识符或者类别或者属性有变化, 那么它们re-render后对应的 key、type 和props里面的属性也会改变, 前后一对比即可找出变化. 综上来看, React 这么表示页面结构确实能够反映前后所有变化.\x3c\/p\x3e\n\x3ch4\x3e那么 React 是如何 diff 的?\x3c\/h4\x3e\n\x3cp\x3eReact diff 每次只对同一层级的节点进行比对 :\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014442218?w=708\x26amp;h=322\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014442218?w=708\x26amp;h=322\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图的数字表示遍历更新的次序.\x3c\/p\x3e\n\x3cp\x3e从父节点开始, 每一层 diff 包括两个地方\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eelement diff—— 前后 render 出来的 element 的对比, 这个对比是为了找出前后节点是不是同一节点, 会对比前后render出来的元素它们的 key 和 type. element diff 包括两个地方, 组件顶层DOM元素对比和子元素的对比:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e组件顶层DOM元素对比 :\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactCompositeComponent.js\/updateComponent =\x26gt; _updateRenderedComponent\n_updateRenderedComponent: function(transaction, context) {\n    \/\/ re-render 出element\n    var nextRenderedElement = this._renderValidatedComponent();\n    \/\/ 对比前后变化\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      \/\/ 如果 key \x26amp;\x26amp; type 没变进行下一级更新\n      ReactReconciler.receiveComponent(...);\n    } else {\n      \/\/ 如果变了移除重造\n      ReactReconciler.unmountComponent(prevComponentInstance, false);\n      ...\n      var child = this._instantiateReactComponent(...);\n  \n      var nextMarkup = ReactReconciler.mountComponent(...);\n      this._replaceNodeWithMarkup(...);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e子元素的对比:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactChildReconciler.js\nupdateChildren: function(...) {\n    ...\n    for (name in nextChildren) {  \/\/ 遍历 re-render 出的elements\n      ...\n      if (\n        prevChild != null \x26amp;\x26amp;\n        shouldUpdateReactComponent(prevElement, nextElement)\n      ) {\n        \/\/ 如果key \x26amp;\x26amp; type 没变进行下一级更新\n        ReactReconciler.receiveComponent(...);  \n        nextChildren[name] = prevChild;  \/\/ 更新完放入 nextChildren, 注意放入的是组件实例\n      } else {\n        \/\/ 如果变了则移除重建                               \n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(prevChild, false);\n        }\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance;\n          \n        var nextChildMountImage = ReactReconciler.mountComponent(...);\n        mountImages.push(nextChildMountImage);\n      }\n    }\n    \/\/ 再除掉 prevChildren 里有, nextChildren 里没有的组件\n    for (name in prevChildren) {\n      if (\n        prevChildren.hasOwnProperty(name) \x26amp;\x26amp;\n        !(nextChildren \x26amp;\x26amp; nextChildren.hasOwnProperty(name))\n      ) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(prevChild, false);\n      }\n    }\n  },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eshouldComponentUpdate 函数:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efunction shouldUpdateReactComponent(prevElement, nextElement) {\n  \n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  var prevType = typeof prevElement;\n  var nextType = typeof nextElement;\n  \/\/ 如果前后变化都是字符串、数字类型的则允许更新\n  if (prevType === \x27string\x27 || prevType === \x27number\x27) {\n    return nextType === \x27string\x27 || nextType === \x27number\x27;\n  } else {\n    \/\/ 否则检查 type \x26amp;\x26amp; key\n    return (\n      nextType === \x27object\x27 \x26amp;\x26amp;\n      prevElement.type === nextElement.type \x26amp;\x26amp;\n      prevElement.key === nextElement.key\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eelement diff 检测 type \x26amp;\x26amp; key 都没变时会进入下一级更新, 如果变化则直接移除重造新元素, 然后遍历同级的下一个.\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3esubtree diff ——组件顶层DOM元素包裹的所有子元素(也就是props.children里的元素)与之前版本的对比, 这个对比是为了找出同级所有子节点的变化, 包括移除、新建、同级范围的移动;\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\/\/ ReactMultiChild.js\n_updateChildren: function(...) {\n      var prevChildren = this._renderedChildren;\n      var removedNodes = {};\n      var mountImages = [];\n      \/\/ 拿到更新后子组件实例\n      var nextChildren = this._reconcilerUpdateChildren();\n      ...\n      \/\/ 遍历子组件实例\n      for (name in nextChildren) {\n           ...\n        var prevChild = prevChildren \x26amp;\x26amp; prevChildren[name];\n        var nextChild = nextChildren[name];\n        \/\/ 因为子组件的更新是在原组件实例上更改的, 因此与之前的组件作引用比较即可判断\n        if (prevChild === nextChild) {\n            \/\/ 发生了移动\n          updates = enqueue(\n            updates,\n            this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),\n          );\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          ...\n          \/\/ 有新的组件\n          updates = enqueue(\n            updates,\n            this._mountChildAtIndex(\n              nextChild,\n              mountImages[nextMountIndex],\n              lastPlacedNode,\n              nextIndex,\n              transaction,\n              context,\n            ),\n          );\n          nextMountIndex\x2b\x2b;\n        }\n        nextIndex\x2b\x2b;\n        lastPlacedNode = ReactReconciler.getHostNode(nextChild);\n      }\n      \/\/ Remove children that are no longer present.\n      for (name in removedNodes) {\n          \/\/ removedNodes 记录了所有的移除节点\n        if (removedNodes.hasOwnProperty(name)) {\n          updates = enqueue(\n            updates,\n            this._unmountChild(prevChildren[name], removedNodes[name]),\n          );\n        }\n      }\n      if (updates) {\n        processQueue(this, updates); \/\/ 批量处理\n      }\n      this._renderedChildren = nextChildren;\n    },\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact 会将同一层级的变化标记, 如 MOVE_EXISTING、REMOVE_NODE、TEXT_CONTENT、INSERT_MARKUP 等, 统一放到 updates 数组中然后批量处理.\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3eAnd that‘s it !\x3c\/h2\x3e\n\x3cp\x3eReact 是一个激动人心的库, 它给我们带来了前所未有的开发体验, 但当我们沉浸在使用 React 快速实现需求的喜悦中时, 有必要去探究两个问题 : Why and How?\x3c\/p\x3e\n\x3cp\x3e为什么 React 会如此流行, 原因是什么?  组件化、快速、足够简单、all in js、容易扩展、生态丰富、社区强大...\x3c\/p\x3e\n\x3cp\x3eReact 反映了哪些思想\/理念\/思路 ?  状态机、webComponents、virtual DOM、virtual stack、异步渲染、多端渲染、单向数据流、反应式更新、函数式编程...\x3c\/p\x3e\n\x3cp\x3eReact 这些理念\/思路受什么启发 ? 怎么想到的 ? 又怎么实现的? ...\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从源码全面剖析 React 组件更新机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014442208">https://segmentfault.com/a/1190000014442208</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9b854awzdxv/" target="_blank">https://alili.tech/archive/9b854awzdxv/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>