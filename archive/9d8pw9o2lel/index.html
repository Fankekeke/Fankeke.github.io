<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="使用Postman做API自动化测试"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>使用Postman做API自动化测试 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9d8pw9o2lel/",
				"appid": "1613049289050283", 
				"title": "使用Postman做API自动化测试 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-22T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/04oleledamte/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/w9bvad632q/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&text=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&text=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&title=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&is_video=false&description=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&title=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&title=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&title=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9d8pw9o2lel%2f&title=%e4%bd%bf%e7%94%a8Postman%e5%81%9aAPI%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">使用Postman做API自动化测试</h1><div class="meta"><div class="postdate"><time datetime="2018-12-22" itemprop="datePublished">2018-12-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ePostman API 自动化测试\x3c\/h1\x3e\n\x3cp\x3ePostman 最基本的功能用来重放请求，并且配合良好的 \x3ccode\x3eresponse\x3c\/code\x3e 格式化工具。\x3c\/p\x3e\n\x3cp\x3e高级点的用法可以使用 Postman 生成各个语言的脚本，还可以抓包，认证，传输文件。\x3c\/p\x3e\n\x3cp\x3e仅仅做到这些还不能够满足一个系统的开发，或者说过于琐碎，你仍需要频繁地在开发环境，测试环境，生产环境中来回切换。单一的请求也不够，你需要维护系统所有 API 的请求，并且每个请求还带有不同的 \x3ccode\x3equerystring\x3c\/code\x3e 和 \x3ccode\x3ebody\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/shfshanyue\/blog\/tree\/master\/Articles\/Postman-for-API-Automated-Testing\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub地址\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eCollection\x3c\/h2\x3e\n\x3cp\x3e对服务器端的所有请求按功能或者业务模块进行组织，使用 markdown 对所有请求和示例添加适当的描述，这时候就用到了 Collection。以下是 postman 的一些术语以及组织请求的建议。\x3c\/p\x3e\n\x3cp\x3e详细参考 \x3ca href=\x22http:\/\/www.postmanlabs.com\/postman-collection\/tutorial-concepts.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePostman SDK Concepts\x3c\/a\x3e 以及 \x3ca href=\x22https:\/\/www.getpostman.com\/docs\/postman\/collections\/creating_collections\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecreating collections\x3c\/a\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCollection\x3cbr\x3e对应一个Application，组内各个成员(server, client, QA)共享一个 Collection。可以对整个 Collection 添加测试，文档。\x3cbr\x3e对于一开始未在 postman 组织请求的应用，可以设置 Proxy，跑一遍应用，对应用的所有请求进行抓包。\x3c\/li\x3e\n\x3cli\x3eFolder (ItemGroup)\x3cbr\x3e对应一个模块，或者各层级子路由。如 \x3ccode\x3erouter.use(\x27\/users\x27)\x3c\/code\x3e 所有的请求都在一个 Folder，可以根据路由互相嵌套 Folder。\x3c\/li\x3e\n\x3cli\x3eRequest (Item)\x3cbr\x3e对应一个请求，可以添加认证信息。也可以设置代理，进行抓包。详见 \x3ca href=\x22https:\/\/www.getpostman.com\/docs\/postman\/sending_api_requests\/capturing_http_requests\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecapturing http requests\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3eExample\x3cbr\x3e对应一个请求不同的参数以及响应，用于Mock Server 以及文档。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3epostman 可以根据 Collection 的结构生成文档与Mock Server。不过都是付费功能，免费版有次数限制。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e文档\x3c\/h3\x3e\n\x3cp\x3epostman 自动生成文档有助于团队协作，解决了手动写文档，以及更新不及时的重大bug。\x3c\/p\x3e\n\x3cp\x3e对于 GET 请求，Postman 上可以添加对该字段的描述，生成文档。\x3c\/p\x3e\n\x3cp\x3e对于 POST 以及 PUT 请求，如果 Content-Type 是 \x3ccode\x3eform-data\x3c\/code\x3e 或者 \x3ccode\x3ex-www-form-urlencoded\x3c\/code\x3e 可以添加描述生成文档。不过如今传递 json 更方便灵活，所以 \x3ccode\x3eapplication\/json\x3c\/code\x3e 也会有很多，而且 json 又是不能添加注释的。如果需要对 json 添加文档说明的话，可以添加冗余字段 \x3ccode\x3e_{key}.comment\x3c\/code\x3e 标明注释\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;id\x26quot;: 128,\n  \x26quot;_id.comment\x26quot;: \x26quot;id\x26quot;,\n  \x26quot;page\x26quot;: 10,\n  \x26quot;_page.comment\x26quot;: \x26quot;页数\x26quot;\n  \x26quot;pageSize\x26quot;: 15,\n  \x26quot;_pageSize.comment\x26quot;: \x26quot;每页条数\x26quot;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e128\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22_id.comment\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22page\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22_page.comment\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22页数\x22\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x22pageSize\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22_pageSize.comment\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22每页条数\x22\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过这样冗余字段过多，更好的解决方案是在测试中对请求进行 json 校验，同时充当了一部分文档的功能。毕竟 json-schema 就是用来描述数据使数据更加可读。\x3c\/p\x3e\n\x3cp\x3e以上说到请求，对于响应的文档，可以 json-schema 校验或者每个字段的描述，以及更多的测试用例代表更多的细节。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eMock\x3c\/h3\x3e\n\x3cp\x3e当服务器端还没有写好 API 时，客户端可以根据 Examples 来生成 Mock Server。\x3c\/p\x3e\n\x3cp\x3e建议客户端端自己做 Mock，与项目集成在一起，纳入版本控制，方便灵活。强烈推荐 \x3ca href=\x22https:\/\/github.com\/typicode\/json-server\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejson-server\x3c\/a\x3e，简单好用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e测试\x3c\/h2\x3e\n\x3cp\x3e对于每一个 Request 都需要有测试用例。验证响应是否成功，响应时间是否过长或者响应 json 的数据类型是否正确。\x3c\/p\x3e\n\x3cp\x3e测试可以使用 \x3ccode\x3epm.expect\x3c\/code\x3e 进行 \x3ccode\x3eBDD\x3c\/code\x3e 测试，风格和 \x3ccode\x3echai\x3c\/code\x3e 很像，如果熟悉 \x3ccode\x3echai\x3c\/code\x3e 就很容易上手。\x3c\/p\x3e\n\x3cp\x3epostman 内置了一些\x3ca href=\x22https:\/\/www.getpostman.com\/docs\/postman\/scripts\/postman_sandbox_api_reference\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第三方库\x3c\/a\x3e，如果你更喜欢 \x3ccode\x3echai\x3c\/code\x3e ，可以直接使用，也可以使用 \x3ccode\x3epm.expect\x3c\/code\x3e 底层使用 chai 实现，与 chai BDD API 一致。\x3c\/p\x3e\n\x3cp\x3epostman 也有一些 http 相关的测试 API，如 status code，header, body，并且也提供了一些 snippets。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 响应成功\npm.test(\x27Status code is 200\x27, () =\x3e {\n  pm.response.to.have.status(200)\n})\n\n\/\/ 响应成功 chai.expect\npm.test(\x27Status code is 200\x27, () =\x3e {\n  chai.expect(pm.response).to.have.property(\x27code\x27, 200)\n})\n\n\/\/ 校验响应数据\npm.test(\x27Page is 100\x27, () =\x3e {\n  const jsonData = pm.response.json()\n  chai.expect(jsonData.page).to.eql(100)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 响应成功\x3c\/span\x3e\npm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Status code is 200\x27\x3c\/span\x3e, () =\x26gt; {\n  pm.response.to.have.status(\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 响应成功 chai.expect\x3c\/span\x3e\npm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Status code is 200\x27\x3c\/span\x3e, () =\x26gt; {\n  chai.expect(pm.response).to.have.property(\x3cspan class=\x22hljs-string\x22\x3e\x27code\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 校验响应数据\x3c\/span\x3e\npm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Page is 100\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jsonData = pm.response.json()\n  chai.expect(jsonData.page).to.eql(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eJson Schema\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/json-schema.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejson-schema\x3c\/a\x3e 可以用来描述 json 信息，使 json 更加易读，同时也可以用来校验 json 的合法性。主流语言都有实现 json-schema 的库。\x3c\/p\x3e\n\x3cp\x3e建议对所有 GET 响应进行 json-schema 校验，一来校验数据，二来也可以作为文档使用，使用 \x3ca href=\x22https:\/\/github.com\/geraintluff\/tv4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etv4\x3c\/a\x3e 校验 json\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pm.test(\x26quot;User info\x26quot;, () =\x3e {\n  const jsonData = pm.response.json()\n  const schema = {\n    title: \x27UserInfo\x27,\n    discription: \x27用户信息\x27,\n    type: \x27object\x27,\n    required: [\x27age\x27, \x27email\x27, \x27name\x27],\n    properties: {\n      age: {\n        description: \x27年龄\x27,\n        type: \x27number\x27,\n        mininum: 0,\n      },\n      email: {\n        description: \x27邮箱\x27,\n        type: \x27string\x27 \n      },\n      name: {\n        description: \x27姓名\x27,\n        type: \x27string\x27 \n      }\n    }\n  }\n  pm.expect(tv4.validate(jsonData, schema)).to.eql(true)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3epm.test(\x3cspan class=\x22hljs-string\x22\x3e\x22User info\x22\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jsonData = pm.response.json()\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e schema = {\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27UserInfo\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ediscription\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27用户信息\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3erequired\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27email\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-attr\x22\x3eproperties\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3edescription\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27年龄\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3emininum\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      },\n      \x3cspan class=\x22hljs-attr\x22\x3eemail\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3edescription\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27邮箱\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e \n      },\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3edescription\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27姓名\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e \n      }\n    }\n  }\n  pm.expect(tv4.validate(jsonData, schema)).to.eql(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样对于请求也可以添加 json 校验，不过更复杂一些，因为 postman 没有直接给出获取全部请求参数的api，需要自己解析和计算\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取 application\/json 中的数据\nconst json = JSON.stringify(pm.request.body.raw)\n\n\/\/ 获取 GET query string 的数据\nconst qs = pm.request.url.query.toObject()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取 application\/json 中的数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e json = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(pm.request.body.raw)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取 GET query string 的数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e qs = pm.request.url.query.toObject()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e如果 postman 可以根据请求参数的 json-schema 自动生成数据就好了...\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e参考\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/json-schema.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejson-schema.org\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/geraintluff\/tv4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etv4 Documentaion\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/chaijs.com\/api\/bdd\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echai bdd - API\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.getpostman.com\/docs\/postman\/scripts\/postman_sandbox_api_reference\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epostman sandbox api reference\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e测试请求参数\x3c\/h3\x3e\n\x3cp\x3e一个请求带有若干参数，如 \x3ccode\x3eGET\x3c\/code\x3e 的 \x3ccode\x3equerystring(search)\x3c\/code\x3e 以及 \x3ccode\x3ePOST\x3c\/code\x3e 的 \x3ccode\x3ebody\x3c\/code\x3e，不同的参数会有不同的响应。\x3c\/p\x3e\n\x3cp\x3e假设一个请求不同参数返回的 json schema 完全不同，则可以写成两个 Request 分开测试。如果返回的 json schema 相同，只是值不同，则需要考虑传递了哪些参数，参数是多少。\x3c\/p\x3e\n\x3cp\x3e一个经典的场景，根据 filter 来筛选符合条件的列表。拿用户列表举例，伪代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const url = \x27\/api\/users\x27\nconst query = {\n  name: \x27san\x27,\n  age: 12,\n  sex: \x27MALE\x27\n}\n\/\/ 注意query数据需要校验，防止 SQL 注入\nconst sql = `select * from users where name = ${query.name} and age = ${query.age} and sex = ${query.sex}`\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x27\/api\/users\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e query = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27san\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esex\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27MALE\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意query数据需要校验，防止 SQL 注入\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sql = \x3cspan class=\x22hljs-string\x22\x3e`select * from users where name = \x3cspan class=\x22hljs-subst\x22\x3e${query.name}\x3c\/span\x3e and age = \x3cspan class=\x22hljs-subst\x22\x3e${query.age}\x3c\/span\x3e and sex = \x3cspan class=\x22hljs-subst\x22\x3e${query.sex}\x3c\/span\x3e`\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个思路是根据请求的参数进行测试，一段重要的 snipet 是在 postman 中获取 querystring，query 是一种 \x3ccode\x3ePropertyList\x3c\/code\x3e 的数据，定义在 \x3ca href=\x22http:\/\/www.postmanlabs.com\/postman-collection\/PropertyList.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epostman-collection - PropertyList\x3c\/a\x3e。如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const name = pm.request.url.query.get(\x27name\x27)\nconst age = pm.request.url.query.get(\x27age\x27)\n\nif (name) {\n  pm.test(\x27Items should match the name\x27, () =\x3e {\n    const jsonData = pm.response.json()\n    expect(_.uniq(jsonData.rows.map(row =\x3e row.name))).to.eql([name])\n  })\n}\n\n\/\/ 冗余代码有些多，postman不知道支不支持自建 snipets\nif (age) {\n  pm.test(\x27Items should match the age\x27, () =\x3e {\n    const jsonData = pm.response.json()\n    expect(_.uniq(jsonData.rows.map(row =\x3e row.age))).to.eql([age])\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e name = pm.request.url.query.get(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e age = pm.request.url.query.get(\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (name) {\n  pm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Items should match the name\x27\x3c\/span\x3e, () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jsonData = pm.response.json()\n    expect(_.uniq(jsonData.rows.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3erow\x3c\/span\x3e =\x26gt;\x3c\/span\x3e row.name))).to.eql([name])\n  })\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 冗余代码有些多，postman不知道支不支持自建 snipets\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (age) {\n  pm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Items should match the age\x27\x3c\/span\x3e, () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jsonData = pm.response.json()\n    expect(_.uniq(jsonData.rows.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3erow\x3c\/span\x3e =\x26gt;\x3c\/span\x3e row.age))).to.eql([age])\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然以上 filter 只包含了最简单的场景，其中只涉及到了相等测试。但是有不等以及包含关系呢。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const query = {\n  name: \x27san\x27,\n  age: 12,\n  sex: \x27MALE\x27\n}\nconst sql = `select * from users where name like ${query.name} and age \x3c ${query.age} and sex = ${query.sex}`\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e query = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27san\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esex\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27MALE\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sql = \x3cspan class=\x22hljs-string\x22\x3e`select * from users where name like \x3cspan class=\x22hljs-subst\x22\x3e${query.name}\x3c\/span\x3e and age \x26lt; \x3cspan class=\x22hljs-subst\x22\x3e${query.age}\x3c\/span\x3e and sex = \x3cspan class=\x22hljs-subst\x22\x3e${query.sex}\x3c\/span\x3e`\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种请求参数依赖于前后端的协商交流，当然对测试或者一个不知情的开发来说很不友好的。\x3c\/p\x3e\n\x3cp\x3e当然对于后端也是不友好的，因为需要对你传入的每个 query 来进行处理，而且以后每添加一个筛选字段，都需要手动改一下。\x3c\/p\x3e\n\x3cp\x3e可以由前端自行决定需要筛选的数据，比如使用类似于 mongo 的检索语法。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ca href=\x22http:\/\/graphql.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egraphql\x3c\/a\x3e 是相当酷的，值得尝试一下\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const query = {\n  name: {\n    $like: \x27san\x27 \n  },\n  age: {\n    $lt: 12 \n  },\n  sex: \x27MALE\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e query = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e$like\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27san\x27\x3c\/span\x3e \n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e$lt\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e \n  },\n  \x3cspan class=\x22hljs-attr\x22\x3esex\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27MALE\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过这对于测试的开发能力要求也比较高了，测试人员需要解析参数并且测试接口。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e测试多次请求\x3c\/h3\x3e\n\x3cp\x3e当对一个函数进行单元测试时，需要大量的输入以及期望输出，在postman中，可以使用 \x3ccode\x3edata\x3c\/code\x3e 来模拟多次输入\x3c\/p\x3e\n\x3cp\x3edata 是一种变量，只能在 Runner 中使用，有必要对每个 Folder 建立相关的 data file，并且加入版本控制\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3ca href=\x22http:\/\/blog.getpostman.com\/2014\/10\/28\/using-csv-and-json-files-in-the-postman-collection-runner\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eusing csv and json files in the postman collection runner\x3c\/a\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e集成测试\x3c\/h2\x3e\n\x3cp\x3e单个API测试通过后，需要把所有请求集成在一起进行测试。这时候出现了两个问题\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如何确保API依赖\x3c\/li\x3e\n\x3cli\x3eAPI之间如何传递数据\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e请求在 Collection 的顺序就是他们的发起请求的顺序，如果需要强制更改顺序，可以使用 \x3ca href=\x22https:\/\/www.getpostman.com\/docs\/postman\/collection_runs\/building_workflows\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3esetNextRuest()\x3c\/code\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e在 postman 中有三种作用域的数据，\x3ccode\x3edata\x3c\/code\x3e，\x3ccode\x3eenvironment\x3c\/code\x3e，\x3ccode\x3eglobal\x3c\/code\x3e。在请求中用 \x3ccode\x3e\x22{{\x22\x22}}\x22\x3c\/code\x3e 占位符替代。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eenvironment\x3c\/code\x3e 可以用来更改 \x3ccode\x3eHOST\x3c\/code\x3e，避免在 url 中频繁手动切换本地环境，开发环境和生产环境。另外也可以用来传递数据。\x3c\/p\x3e\n\x3cp\x3e一个常见的场景是项目使用 token 来保存登录信息，每次请求都需要携带token。可以在登录的测试代码中设置 token 的环境变量\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const url = \x27http:\/\/\x22{{\x22HOST\x22}}\x22\/api\/login\x27\n\npm.test(\x27There is a token\x27, () =\x3e {\n  const jsonData = pm.response.json()\n  pm.expect(jsonData.token).to.a(\x27string\x27)\n  pm.environment.set(\x27token\x27, jsonData.token)\n})\n\nconst urlNext = \x27http:\/\/\x22{{\x22HOST\x22}}\x22\/api\/profile?token=\x22{{\x22token\x22}}\x22\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/\x22{{\x22HOST\x22}}\x22\/api\/login\x27\x3c\/span\x3e\n\npm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27There is a token\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jsonData = pm.response.json()\n  pm.expect(jsonData.token).to.a(\x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e)\n  pm.environment.set(\x3cspan class=\x22hljs-string\x22\x3e\x27token\x27\x3c\/span\x3e, jsonData.token)\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e urlNext = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/\x22{{\x22HOST\x22}}\x22\/api\/profile?token=\x22{{\x22token\x22}}\x22\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e测试Collection\x3c\/h3\x3e\n\x3cp\x3e确保依赖后，可以对 Collection 新建一个 Runner，并且引入一个 data 文件来测试所有的请求。对局部的 Folder 也可以使用 Runner 以及 data 进行测试。\x3c\/p\x3e\n\x3cblockquote\x3e最新版本的 postman 已经可以支持，为每个 Postman 新建变量以及 Test\x3c\/blockquote\x3e\n\x3cp\x3e所有的请求都会有一些共同测试，比如测试接口是否响应成功以及以上提到的测试 filter\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pm.test(\x27Response is right\x27, () =\x3e {\n  \/\/ status code: 2XX\n  pm.response.to.be.success\n})\n\npm.test(\x27Filter is matching\x27, () =\x3e {\n  \/\/ ...\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3epm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Response is right\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ status code: 2XX\x3c\/span\x3e\n  pm.response.to.be.success\n})\n\npm.test(\x3cspan class=\x22hljs-string\x22\x3e\x27Filter is matching\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e持续集成\x3c\/h2\x3e\n\x3cp\x3e当可以测试 Collection 后，需要对测试加入版本控制，与项目集成在一起，保留测试记录，以便准时定位 bug。可以与 postman 的官方工具 \x3ccode\x3enewman\x3c\/code\x3e 集成在一起，但是有一点不方便的是，持续集成仅仅可以保存记录，并不能还原记录。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22newman run https:\/\/api.getpostman.com\/collections\/\x22{{\x22collection_uid\x22}}\x22?apikey=\x22{{\x22postman-api-key-here\x22}}\x22 --environment https:\/\/api.getpostman.com\/environments\/\x22{{\x22environment_uid\x22}}\x22?apikey=\x22{{\x22postman-api-key-here\x22}}\x22\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode class=\x22shell\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3enewman run https:\/\/api.getpostman.com\/collections\/\x22{{\x22collection_uid\x22}}\x22?apikey=\x22{{\x22postman-api-key-here\x22}}\x22 --environment https:\/\/api.getpostman.com\/environments\/\x22{{\x22environment_uid\x22}}\x22?apikey=\x22{{\x22postman-api-key-here\x22}}\x22\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e对比UI自动化测试\x3c\/h2\x3e\n\x3cp\x3e按照我的理解，UI 自动化测试目的是用来测试流程是否通畅，比如登陆，注册，退出，如果用例没通过则截屏。但是前端需求的不断变化，加上现在各种前端框架，导致 selector 不是特别容易获取到且流程容易更改。\x3c\/p\x3e\n\x3cp\x3e而API 自动化测试用来测试数据是否正确。而且大部分问题是出在数据问题上，所以 API 自动化测试性价比比较高一些。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e总结\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e如何编写测试用例\x3c\/p\x3e\n\x3cblockquote\x3epostman 底层使用 \x3ccode\x3e[chai.js](http:\/\/chaijs.com\/api\/bdd\/)\x3c\/code\x3e 的 bdd 语法作为断言库，另外加了一些特有的语法。\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如何debug\x3c\/p\x3e\n\x3cblockquote\x3e点击菜单栏 View -\x26gt; Show Devtools (Show Postman Console) 可以查看响应，检查输出，不过不能打断点。对于系统的单个请求，可以使用 Proxy 监听请求进行调试。\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如何使用js第三方库对请求就行预处理以及后处理\x3c\/p\x3e\n\x3cp\x3e比如:\x3cbr\x3e发送请求时，服务器端要求时间为 \x3ccode\x3etimestmap(unix)\x3c\/code\x3e 的格式，但接口调试时可读性过弱，是否可以使用 \x3ccode\x3emoment\x3c\/code\x3e 转化时间。\x3cbr\x3e收到响应时，也需要 \x3ccode\x3emoment\x3c\/code\x3e 对时间进行解析，获得更好的展现形式。或者使用 \x3ccode\x3elodash\x3c\/code\x3e 一些函数进行数据的处理。\x3c\/p\x3e\n\x3cblockquote\x3e可以在 Tests 和 Pre-request Script 中编写脚本对请求以及响应做一些处理。但是不能对数据格式化，比如日期。\x3cbr\x3e建议前后端交流日期时使用 ISO 格式的字符串，前后端都容易解析，并且可读性强。\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如何管理请求依赖\x3c\/p\x3e\n\x3cp\x3e比如:\x3cbr\x3e两个API需要有依赖关系，比如当创建完一个用户后（注册），获取他的个人信息。获取个人信息就需要依赖创建用户这个API。\x3c\/p\x3e\n\x3cblockquote\x3e使用 Environment Variables 可以管理依赖\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如何设置统一的请求参数\x3c\/p\x3e\n\x3cp\x3e比如:\x3cbr\x3e大部分接口都需要统一的 \x3ccode\x3etoken\x3c\/code\x3e 参数。\x3c\/p\x3e\n\x3cblockquote\x3e目前好像没什么办法\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如何集成到服务器端项目中\x3c\/p\x3e\n\x3cp\x3e如果系统后续版本没有通过API测试，则保留测试记录是很重要的，版本控制可以得知该时间段内的代码变更。以git为例，需要每次提交后运行测试，并保留测试结果。\x3c\/p\x3e\n\x3cblockquote\x3e可以使用 npm 包 newman 来集成到项目中\x3c\/blockquote\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.getpostman.com\/2014\/02\/20\/using-variables-inside-postman-and-collection-runner\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eusing variables inside postman and collection runner\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.getpostman.com\/2017\/10\/25\/writing-tests-in-postman\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewriting tests in postman\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/docs.postman-echo.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epostman-echo\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.getpostman.com\/2016\/11\/09\/generate-spotify-playlists-using-a-postman-collection\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egenerate spoitify playlists using a postman collection\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>使用Postman做API自动化测试</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012433650">https://segmentfault.com/a/1190000012433650</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9d8pw9o2lel/" target="_blank">https://alili.tech/archive/9d8pw9o2lel/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>