<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="实践是检验程序员的唯一标准01：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【思路篇】"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>实践是检验程序员的唯一标准01：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【思路篇】 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9ucm99xx3bm/",
				"appid": "1613049289050283", 
				"title": "实践是检验程序员的唯一标准01：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【思路篇】 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-15T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/417vgg93ot4/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6evszfrp1g/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&text=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&text=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&title=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&is_video=false&description=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&title=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&title=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&title=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9ucm99xx3bm%2f&title=%e5%ae%9e%e8%b7%b5%e6%98%af%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e5%87%8601%ef%bc%9a%e7%94%a8%e6%88%b7%e4%b8%8d%e6%83%b3%e8%b7%9f%e4%bd%a0%e8%af%b4%e8%af%9d%e5%b9%b6%e5%90%91%e4%bd%a0%e6%89%94%e5%87%ba%e4%b8%80%e5%bc%a0%e5%9b%be%e7%89%87%20-%20%e5%9b%be%e7%89%87%e4%b8%8a%e4%bc%a0%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e3%80%90%e6%80%9d%e8%b7%af%e7%af%87%e3%80%91"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">实践是检验程序员的唯一标准01：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【思路篇】</h1><div class="meta"><div class="postdate"><time datetime="2018-12-15" itemprop="datePublished">2018-12-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e温馨提示：这里除了一些幼稚的小组件啥也没有\x3c\/strong\x3e\x3cbr\x3e\x3cstrong\x3e温馨提示-续：这是一个新的系列，写一些实际开发中遇到的一些常用的功能，想法笨拙，代码乱套\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h1\x3e\n\x3cp\x3e图片上传，作为web端一个常用的功能，在不同的项目中有不同的需求，在这里实现一个比价基本的上传图片插件，主要能实现图片的浏览，剪裁，上传这三个功能，同时也是为了让自己对图片／文件上传和HTML5中名声在外的\x3ccode\x3ecanvas\x3c\/code\x3e相关能够有一些了解\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e我就要自行车 - 需求整理\x3c\/h1\x3e\n\x3cp\x3e放眼WWW，一般的图片上传模块，主要就是实现了三个功能，图片的预览，图片的剪裁及预览，图片的上传，那我也就整这么一个吧，再细化一下需求\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e图片的预览\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e用户使用：\x3c\/strong\x3e用户点击“选择图片”，弹出文件浏览器，可以选择本地的图片，点击确认后，所选图片会按照原始比例出现在页面的浏览区域中\x3cbr\x3e\x3cstrong\x3e组件调用：\x3c\/strong\x3e开发者可以自己定义图片预览区域的大小，并限定所传图片的文件大小和尺寸大小\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e图片的剪裁\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e用户使用：\x3c\/strong\x3e用户根据提示，在预览区域的图片上拖动鼠标框出想要上传的图片区域，并且能在结果预览区域看到自己的剪裁结果\x3cbr\x3e\x3cstrong\x3e组件调用：\x3c\/strong\x3e开发者可以自定义是否剪裁图片，并可以定义是否限定剪裁图片的大小及比例，并且设定具体大小及比例\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e图片的上传\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e用户使用：\x3c\/strong\x3e用户点击“图片上传”，图片开始上传，现实“上传中…”，完成后显示“上传完成”\x3cbr\x3e\x3cstrong\x3e组件调用：\x3c\/strong\x3e开发者得到base64格式的urlData图片，自己编写调用Ajax的函数及其回调函数\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e扔出原型图\x3c\/h2\x3e\n\x3cp\x3e作为设计师，扔图是我的最爱，画了一套全功能，包含剪裁及剪裁浏览的原型图\x3c\/p\x3e\n\x3cp\x3estate-1:初始状态\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2p4X?w=632\x26amp;h=341\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2p4X?w=632\x26amp;h=341\x22 alt=\x22插件原型-1\x22 title=\x22插件原型-1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3estate-2:点击\x22选择图片\x22，浏览本地后载入图片\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2p45?w=632\x26amp;h=341\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2p45?w=632\x26amp;h=341\x22 alt=\x22插件原型-2\x22 title=\x22插件原型-2\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3estate-3:剪裁，在图片区域上拖动鼠标选择要剪裁的部分，确认要上传的部分\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2p5d?w=632\x26amp;h=341\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2p5d?w=632\x26amp;h=341\x22 alt=\x22插件原型-3\x22 title=\x22插件原型-3\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e一次历史性的对话 - 本地图片读取\x3c\/h1\x3e\n\x3cp\x3e自打干上web开发这活，就都是在捣鼓浏览器内部这点事，从没想过跟浏览器之外计算机本地的一些文件能发生什么关系。但是该来的总要来，既然要上传图片，就肯定要从计算机本地来选择文件并在浏览器内打开，这历史性的对话就要这么开启了…\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e图片的选择\x3c\/h2\x3e\n\x3cp\x3e其实在HTML中的\x3ccode\x3e\x26lt;input\x26gt;\x3c\/code\x3e标签就提供了浏览本地文件的功能，前提是\x3ccode\x3etype=\x22file\x22\x3c\/code\x3e，真是很讲道理… 试过就知道一点击就会打开文件浏览器\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput id=\x26quot;inputArea\x26quot; type=\x26quot;file\x26quot; \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fsharp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;input id=\x3cspan class=\x22hljs-string\x22\x3e\x22inputArea\x22\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22file\x22\x3c\/span\x3e \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但这么做有两个经典的问题：\x3cbr\x3e第一，会有一个输入框傻乎乎的在那里…\x3cbr\x3e第二，我用的是Ajax，怎么才能get到表单当中的文件呢\x3c\/p\x3e\n\x3cp\x3e对于问题一，很好解决直接各种方式hide这个input标签即可，再主动触发\x3ccode\x3eclick()\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var imgFrom = document.getElementById(\x26quot;inputArea\x26quot;);\nfunction loadImg(){\n    imgFrom.click(); \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e imgFrom = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22inputArea\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eloadImg\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    imgFrom.click(); \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于问题二，这就要介绍一下\x3ccode\x3eFormData\x3c\/code\x3e对象了\x3c\/p\x3e\n\x3cblockquote\x3eXMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个\x22表单\x22.\x3cstrong\x3e比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件.\x3c\/strong\x3e\x3cbr\x3e\x3cem\x3e摘自\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/FormData\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API 接口／FormData\x3c\/a\x3e\x3c\/em\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e正如上面的文档所说\x3ccode\x3eFormData\x3c\/code\x3e对象可以干的事无非就是用javascript模拟表单控件，也正因为如此所以可以在模拟的表单中放入一个文件\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var myFrom = new FormData();\nvar imageData = imgFrom.files[0];\/\/获取表单中第一个文件\nmyFrom.append(\x26quot;image\x26quot;,imageDate);\/\/向表单中添加一个键值对\nconsole.log(myFrom.getAll(\x26quot;image\x26quot;));\/\/获取表单中image字段对应的值，结果见下图\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs go\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e myFrom = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e FormData();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e imageData = imgFrom.files[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取表单中第一个文件\x3c\/span\x3e\nmyFrom.\x3cspan class=\x22hljs-built_in\x22\x3eappend\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22image\x22\x3c\/span\x3e,imageDate);\x3cspan class=\x22hljs-comment\x22\x3e\/\/向表单中添加一个键值对\x3c\/span\x3e\nconsole.log(myFrom.getAll(\x3cspan class=\x22hljs-string\x22\x3e\x22image\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取表单中image字段对应的值，结果见下图\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2twt?w=1304\x26amp;h=364\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2twt?w=1304\x26amp;h=364\x22 alt=\x22获取本地文件结果\x22 title=\x22获取本地文件结果\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e正如我们所见，文件我们已经通过Web拿到手了\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e图片的展现\x3c\/h2\x3e\n\x3cp\x3e既然是要上传图片，我们肯定得知道自己传的是啥图片啊，所以下一步就是如何把读取的图片展现在页面上了，正如上图中的显示，我的得到的图片是一个\x3ccode\x3eFile\x3c\/code\x3e对象，而\x3ccode\x3eFile\x3c\/code\x3e对象是特殊的\x3ccode\x3eBlob\x3c\/code\x3e对象，那\x3ccode\x3eBlob\x3c\/code\x3e对象又是个啥呢…\x3c\/p\x3e\n\x3cblockquote\x3eBlob 对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。File 接口基于Blob，继承了 blob的功能并将其扩展使其支持用户系统上的文件。\x3cbr\x3e\x3cem\x3e摘自\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Blob\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API 接口／Blob\x3c\/a\x3e\x3c\/em\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e说实话，真是懵逼\x3cbr\x3e但仔细理解下大概意思就是\x3ccode\x3eBlob\x3c\/code\x3e对象是用来表示／承载文件对象的原始数据（二进制）的，借助一些博文会有助于理解\x3cbr\x3e\x3ca href=\x22https:\/\/www.cnblogs.com\/wangfajing\/p\/7202139.html?utm_source=itdadao\x26amp;utm_medium=referral\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejs中关于Blob对象的介绍与使用 - 可乐Script\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/zdy0_2004\/article\/details\/52727250\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 Blob对象 - zdy0_2004\x3c\/a\x3e\x3cbr\x3e\x3cstrong\x3e说到底，重点不在这，了解一下有个概念即可，重点在于我们怎么展示这个\x3ccode\x3eFile\x3c\/code\x3e对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这就要请出\x3ccode\x3eFileReader\x3c\/code\x3e对象了\x3c\/p\x3e\n\x3cblockquote\x3eFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。\x3cbr\x3e\x3cem\x3e摘自\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/FileReader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API 接口／FileReader\x3c\/a\x3e\x3c\/em\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e不难看出，\x3ccode\x3eFileReader\x3c\/code\x3e对象就是用来读取本地文件的，而这其方法\x3ccode\x3ereadAsDataURL()\x3c\/code\x3e就是我们要用的东西啦\x3c\/p\x3e\n\x3cblockquote\x3e该方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成（DONE），并触发 loadend 事件，同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容。\x3cbr\x3e\x3cem\x3e摘自\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/FileReader\/readAsDataURL\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API 接口／FileReader／FileReader.readAsDataURL()\x3c\/a\x3e\x3c\/em\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这里面又提到一个新名词\x3cstrong\x3edata:URL\x3c\/strong\x3e，也就是说\x3ccode\x3ereadAsDataURL()\x3c\/code\x3e的作用就是能把文件转换为data:URL，不过这个data:URL又是什么呢，执行来看看\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reader = new FileReader(); \/\/调用FileReader对象\nreader.readAsDataURL(imgData); \/\/通过DataURL的方式返回图像\nreader.onload = function(e) {                \n    console.log(e.target.result);\/\/看看你是个啥\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reader = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FileReader(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用FileReader对象\x3c\/span\x3e\nreader.readAsDataURL(imgData); \x3cspan class=\x22hljs-comment\x22\x3e\/\/通过DataURL的方式返回图像\x3c\/span\x3e\nreader.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{                \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e.target.result);\x3cspan class=\x22hljs-comment\x22\x3e\/\/看看你是个啥\x3c\/span\x3e\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台的结果全脸懵逼\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xer?w=1750\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xer?w=1750\x26amp;h=400\x22 alt=\x22Data:URL\x22 title=\x22Data:URL\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e可以通过这篇文章去大概了解一下\x3ca href=\x22https:\/\/www.cnblogs.com\/xuechenlei\/p\/5940371.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDATA URL简介及DATA URL的利弊 - 薛陈磊\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e说到底这dataURL我就粗略的理解它为\x3cstrong\x3eURL形式的data\x3c\/strong\x3e，也就是说这段URL并不是与普通的URL一样指向某个地址，而是它本身就是数据，我们试着把这一堆字符粘到一个\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e的\x3ccode\x3esrc\x3c\/code\x3e属性中\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xdc?w=620\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xdc?w=620\x26amp;h=567\x22 alt=\x22Data:URL结果\x22 title=\x22Data:URL结果\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e终于看到了，结果正如所料，将这段包含了数据的URL赋给一个\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e确实可以让数据被展现为图片\x3cbr\x3e至此，我们实现了本地文件的\x3cstrong\x3e读取\x3c\/strong\x3e及\x3cstrong\x3e展现\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e指哪儿截哪儿 - 利用canvas的图片截取\x3c\/h1\x3e\n\x3cp\x3e\x3cstrong\x3e温馨提示-乱入：看明白这里需要对canvas有基本的了解\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Canvas_API\/Tutorial\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API接口／Canvas／Canvas教程\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在Web上对图像进行操作，没有比canvas相关技术更合适的了，所以本文用canvas技术来实现对图片的截取\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3ecanvas中的图片展现\x3c\/h2\x3e\n\x3cp\x3e在上文中，我们利用\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e展现出了我们选择的图片，但是我们的图片截取功能可是要利用\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e来实现的，所以怎么在\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e中展现我们刚才获取的图片就是下一步要干的事情了\x3c\/p\x3e\n\x3cp\x3ecanvas的API中自带\x3ccode\x3edrawImage()\x3c\/code\x3e函数，其作用就是在\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e中渲染一张图片出来，其可以支持多种图片来源见\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/CanvasRenderingContext2D\/drawImage\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN Web docs - Web技术文档／Web API接口／CanvasRenderingContext2D／CanvasRenderingContext2D.drawImage()\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e最简单的，我们直接把刚刚显示图片的那个\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e传入是不是就可以呢\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var theCanvas = document.getElementById(\x26quot;imgCanvas\x26quot;);\nvar canvasImg = theCanvas.getContext(\x26quot;2d\x26quot;);\/\/获取2D渲染背景\nvar img = document.getElementById(\x26quot;image\x26quot;);\nimg.onload = function(){\/\/确认图片已载入    \n    canvasImg.drawImage(img,0,0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e theCanvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22imgCanvas\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e canvasImg = theCanvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x222d\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取2D渲染背景\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e img = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22image\x22\x3c\/span\x3e);\nimg.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/确认图片已载入    \x3c\/span\x3e\n    canvasImg.drawImage(img,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果如下\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xqP?w=917\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xqP?w=917\x26amp;h=350\x22 alt=\x22CanvasImg结果-1\x22 title=\x22CanvasImg结果-1\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e从图中看，左侧是之前的\x27\x26lt;img\x26gt;\x27，右侧是渲染了图片信息的\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e\x3cbr\x3e这么看来虽然成功？在\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e中渲染出了图片但是有两个明显的问题\x3c\/p\x3e\n\x3cp\x3e1.左边的\x27\x26lt;img\x26gt;\x27留着干啥？\x3cbr\x3e2.右边看上去是不是有点不一样？\x3c\/p\x3e\n\x3cp\x3e这俩问题其实都好办，针对第一个问题，我们其实可以根本不用实体的\x27\x26lt;img\x26gt;\x27直接利用\x27Image\x27对象即可，第二个问题明显是因为\x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e的大小与获取到的图片大小不一致所产生的，综合这两点，对代码进行进化！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var theCanvas = document.getElementById(\x26quot;imgCanvas\x26quot;);\nvar canvasImg = theCanvas.getContext(\x26quot;2d\x26quot;);\nvar img = new Image();\/\/创建img对象\n\nreader.onload = function(e) {                \n    img.src = e.target.result;\n}\n \nimg.onload = function(){\n    theCanvas.Width = img.width;\/\/将img对象的长款赋给canvas标签\n    theCanvas.height = img.height;    \n    canvasImg.drawImage(img,0,0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e theCanvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22imgCanvas\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e canvasImg = theCanvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x222d\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e img = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image();\x3cspan class=\x22hljs-comment\x22\x3e\/\/创建img对象\x3c\/span\x3e\n\nreader.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{                \n    img.src = e.target.result;\n}\n \nimg.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    theCanvas.Width = img.width;\x3cspan class=\x22hljs-comment\x22\x3e\/\/将img对象的长款赋给canvas标签\x3c\/span\x3e\n    theCanvas.height = img.height;    \n    canvasImg.drawImage(img,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2xto?w=615\x26amp;h=561\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2xto?w=615\x26amp;h=561\x22 alt=\x22CanvasImg结果-2\x22 title=\x22CanvasImg结果-2\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e结果与我们所期待的一样，至此我们成功的在\x27\x26lt;canvas\x26gt;\x27中展现了从本地获取的图片\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3ecanvas中图片的截取\x3c\/h2\x3e\n\x3cp\x3e其实截图，说白了就是在一个图像上，获取某个区域中的图像信息\x3cbr\x3ecanvas作为专门用来处理图像及像素相关的一套API，获取区域中的相关图像信息可以说是再简单不过的事情，利用\x3ccode\x3egetImageData()\x3c\/code\x3e函数即可 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CanvasRenderingContext2D\/getImageData\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/\/详情\x3c\/a\x3e，当然我们不光要把图像信息获取到，最好还能展现出来我们的截图结果，这里就要用到与之相对的\x3ccode\x3eputImageData()\x3c\/code\x3e函数 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CanvasRenderingContext2D\/putImageData\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/\/详情\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var resultCanvas = document.getElementById(\x26quot;resultCanvas\x26quot;);\nvar resultImg = resultCanvas.getContext(\x26quot;2d\x26quot;);\nvar cutData = canvasImg.getImageData(100,100,200,200);\nresultImg.putImageData(cutData,0,0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3evar resultCanvas = document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22resultCanvas\x22\x3c\/span\x3e);\nvar resultImg = resultCanvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x222d\x22\x3c\/span\x3e);\nvar cutData = canvasImg.getImageData(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e);\nresultImg.putImageData(cutData,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果如图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2PIF?w=818\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2PIF?w=818\x26amp;h=350\x22 alt=\x22截图结果\x22 title=\x22截图结果\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e我也要画一个圈／框\x3c\/h2\x3e\n\x3cp\x3e既然这个工具是面向用户的，截图的过程肯定是要所见即所得的，在函数\x3ccode\x3egetImageData()\x3c\/code\x3e中有4个参数，分别是截图起点的两个坐标和区域的宽度及高度，所以问题就变成了如何更合理的让用户输入这4个值。\x3cbr\x3e其实现存的主流解决方案就做的非常好了：\x3cstrong\x3e在图上拖动鼠标，拉出一个框，这个框内就是用户希望截取的区域。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在画布上画出一个框很简单，只需用到\x3ccode\x3estrokeRect()\x3c\/code\x3e函数 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CanvasRenderingContext2D\/strokeRect\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/\/详情\x3c\/a\x3e\x3cbr\x3e但是让用户自己拖出一个框就比较复杂了，先分析一下用户的一套动作都有什么\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用户选定起始点，点下鼠标左键\x3c\/li\x3e\n\x3cli\x3e用户选定截图区域的大小，保持鼠标左键不抬起，同时移动鼠标选择\x3c\/li\x3e\n\x3cli\x3e用户完成选择，抬起鼠标左键\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e回过头再来看程序需要干什么\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e获取起始点的坐标，并记录为已点击状态\x3c\/li\x3e\n\x3cli\x3e判断一下如果为已点击状态那么，获取每一次移动／帧的鼠标坐标，并计算出与起始点之间的横纵坐标距离，而这距离就是所画框的长度和宽度，清除上一帧的\x3cstrong\x3e整个画面\x3c\/strong\x3e，再绘制一个新的图片再画一个新的框，同时按照框的起始坐标及宽高，截取图像信息，再清除预览区域的上一帧的画布，再将这一帧的图像信息载入\x3c\/li\x3e\n\x3cli\x3e鼠标抬起后，停止记录及绘制，保持最终一帧的框停留在画面上\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在这里，要说明一下，为什么非要清除整个画面不可，其实可以把通过\x3ccode\x3ecanvas.getContext(\x222d\x22)\x3c\/code\x3e获取到的\x3cstrong\x3e2D 画布的渲染上下文\x3c\/strong\x3e \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/HTMLCanvasElement\/getContext\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/\/详情\x3c\/a\x3e 就当作一块画布，已经渲染出来的东西就已经留在了上面，无法再修改，如果想要更改画面上已经存在的元素的大小位置形状等等属性，那么在程序层面，就\x3cstrong\x3e只能\x3c\/strong\x3e（个人理解，不一定对，如果有问题请一定跟我唠唠）把之前的画布清空再重新渲染。\x3c\/p\x3e\n\x3cp\x3e这个思路与我们之前端开发中动画相关的开发思路不同，并不是像之前那样直接操作现有元素属性就可以改变该元素在画面上的呈现结果的，而在这里其实更像是在现实生活中的动画制作原理就是\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e每一帧都需要重新绘制整张画面\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e而其实这是任何动画渲染方式的最底层思路与行为\x3c\/p\x3e\n\x3cp\x3e话说回来按照上文相关的开发思路，实现这个功能的代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var flag = false;\/\/记录是否为点击状态的标记\nvar W = img.width;\nvar H = img.height;\nvar startX = 0;\nvar startY = 0;\n\n\/\/当鼠标被按下\ntheCanvas.addEventListener(\x26quot;mousedown\x26quot;, e =\x3e {\n    flag = true;\/\/改变标记状态，置为点击状态\n    \/\/startX = e.clientX;\/\/获得起始点横坐标\n    \/\/startY = e.clientY;\/\/获得起始点纵坐标\n    \/\/添加于2018.3.6:\n    \/\/这里有些问题，在本文的条件下e.clientX是对的，可是其实是应该为相对对象的坐标而不是浏览器，所以应该为e.offsetX 感谢 @高远 同学提醒\n    startX = e.offsetX;\/\/获得起始点横坐标\n    startY = e.offsetY;\/\/获得起始点纵坐标\n})\n\n\/\/当鼠标在移动\ntheCanvas.addEventListener(\x26quot;mousemove\x26quot;, e =\x3e {\n    if(flag){\/\/判断鼠标是否被拖动\n        canvasImg.clearRect(0,0,W,H);\/\/清空整个画面\n        canvasImg.drawImage(img,0,0);\/\/重新绘制图片\n        canvasImg.strokeRect(startX, startY, e.clientX - startX, e.clientY - startY);\/\/绘制黑框\n        resultImg.clearRect(0,0,cutData.width,cutData.height);\/\/清空预览区域\n        cutData = canvasImg.getImageData(startX, startY, e.clientX - startX, e.clientY - startY);\/\/截取黑框区域图片信息\n        resultImg.putImageData(cutData,0,0);\/\/将图片信息赋给预览区域\n    }\n})\n\n\/\/当鼠标左键抬起\ntheCanvas.addEventListener(\x26quot;mouseup\x26quot;, e =\x3e {\n    flag = false;\/\/将标志置为已抬起状态\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e flag = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/记录是否为点击状态的标记\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e W = img.width;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e H = img.height;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startX = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startY = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/当鼠标被按下\x3c\/span\x3e\ntheCanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22mousedown\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    flag = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/改变标记状态，置为点击状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/startX = e.clientX;\/\/获得起始点横坐标\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/startY = e.clientY;\/\/获得起始点纵坐标\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加于2018.3.6:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里有些问题，在本文的条件下e.clientX是对的，可是其实是应该为相对对象的坐标而不是浏览器，所以应该为e.offsetX 感谢 @高远 同学提醒\x3c\/span\x3e\n    startX = e.offsetX;\x3cspan class=\x22hljs-comment\x22\x3e\/\/获得起始点横坐标\x3c\/span\x3e\n    startY = e.offsetY;\x3cspan class=\x22hljs-comment\x22\x3e\/\/获得起始点纵坐标\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/当鼠标在移动\x3c\/span\x3e\ntheCanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22mousemove\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(flag){\x3cspan class=\x22hljs-comment\x22\x3e\/\/判断鼠标是否被拖动\x3c\/span\x3e\n        canvasImg.clearRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,W,H);\x3cspan class=\x22hljs-comment\x22\x3e\/\/清空整个画面\x3c\/span\x3e\n        canvasImg.drawImage(img,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/重新绘制图片\x3c\/span\x3e\n        canvasImg.strokeRect(startX, startY, e.clientX - startX, e.clientY - startY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/绘制黑框\x3c\/span\x3e\n        resultImg.clearRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,cutData.width,cutData.height);\x3cspan class=\x22hljs-comment\x22\x3e\/\/清空预览区域\x3c\/span\x3e\n        cutData = canvasImg.getImageData(startX, startY, e.clientX - startX, e.clientY - startY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/截取黑框区域图片信息\x3c\/span\x3e\n        resultImg.putImageData(cutData,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/将图片信息赋给预览区域\x3c\/span\x3e\n    }\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/当鼠标左键抬起\x3c\/span\x3e\ntheCanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22mouseup\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    flag = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/将标志置为已抬起状态\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果如图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QE3?w=800\x26amp;h=338\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QE3?w=800\x26amp;h=338\x22 alt=\x22画框截图\x22 title=\x22画框截图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e能不能弄的高大上一点啊\x3c\/h2\x3e\n\x3cp\x3e主要吧，这个黑框太丑了，透露着一种原始和狂野，以及来自工科男审美的粗糙感…\x3cbr\x3e能不能弄的好看点，起码让它看上去是一个工具不是一个实验\x3c\/p\x3e\n\x3cp\x3e我的想法是这样的，待被截取的图片上应该蒙上一层半透明白色遮罩，用户框选出的部分是没有遮罩的，这样效果可以为功能增加视觉上的材质感及舒适感，同时显得高端\x3c\/p\x3e\n\x3cp\x3e具体效果是这样的-下图来自ps\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QKA?w=797\x26amp;h=351\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QKA?w=797\x26amp;h=351\x22 alt=\x22蒙板效果图\x22 title=\x22蒙板效果图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e是不是稍微好些了\x3c\/p\x3e\n\x3cp\x3e可是，怎么实现？\x3cbr\x3e简单来说，就是在原有的画布上再蒙半透明的一层画布，然后让这一层有一部分是没有的就可以实现了，总的来说就是蒙版和遮罩的思路，在canvas中也有相关的api，但是我愣是没看明白\x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Canvas_API\/Tutorial\/Compositing\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e负责任的贴一个链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e不过开发就是这样，条条大路出bug\x3cbr\x3e我想到这个功能的瞬间脑子像抽了一样，出现了这么一种实现方法\x3c\/p\x3e\n\x3cp\x3e见下图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Rpe?w=613\x26amp;h=351\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Rpe?w=613\x26amp;h=351\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3emask层可以分为A，B，C，D四个矩形区域，在图中两个蓝色的点是已知的（用户自己画出来的），在下层图片大小已知的前提下，这四个矩形区域的四个点都是可以计算出来的，从而其高度和宽度也可以计算出来，这样就可以利用这些数据画出一个半透明的矩形，将四个半透明矩形都画出来后，就能够实现之前设计出的效果了，具体代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22theCanvas.addEventListener(\x26quot;mousemove\x26quot;, e =\x3e {\n    if(flag){\n        canvasImg.clearRect(0,0,W,H);\n        resultImg.clearRect(0,0,cutData.width,cutData.height);\n        canvasImg.drawImage(img,0,0);\n        canvasImg.fillStyle = \x27rgba(255,255,255,0.6)\x27;\/\/设定为半透明的白色\n        canvasImg.fillRect(0, 0, e.clientX, startY);\/\/矩形A\n        canvasImg.fillRect(e.clientX, 0, W, e.clientY);\/\/矩形B\ncanvasImg.fillRect(startX, e.clientY, W-startX, H-e.clientY);\/\/矩形C\n        canvasImg.fillRect(0, startY, startX, H-startY);\/\/矩形D\n        cutData = canvasImg.getImageData(startX, startY, e.clientX - startX, e.clientY - startY);\n        resultImg.putImageData(cutData,0,0);\n    }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3etheCanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22mousemove\x22\x3c\/span\x3e, e =\x26gt; {\n    if(flag){\n        canvasImg.clearRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,W,H);\n        resultImg.clearRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,cutData.width,cutData.height);\n        canvasImg.drawImage(img,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        canvasImg.fillStyle = \x27rgba(\x3cspan class=\x22hljs-number\x22\x3e255\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e255\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e255\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0.6\x3c\/span\x3e)\x27;\x3cspan class=\x22hljs-comment\x22\x3e\/\/设定为半透明的白色\x3c\/span\x3e\n        canvasImg.fillRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, e.clientX, startY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/矩形A\x3c\/span\x3e\n        canvasImg.fillRect(e.clientX, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, W, e.clientY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/矩形B\x3c\/span\x3e\ncanvasImg.fillRect(startX, e.clientY, W-startX, H-e.clientY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/矩形C\x3c\/span\x3e\n        canvasImg.fillRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, startY, startX, H-startY);\x3cspan class=\x22hljs-comment\x22\x3e\/\/矩形D\x3c\/span\x3e\n        cutData = canvasImg.getImageData(startX, startY, e.clientX - startX, e.clientY - startY);\n        resultImg.putImageData(cutData,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e效果如图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2Rxg?w=785\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2Rxg?w=785\x26amp;h=350\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e没有什么把自己的脑残想法实现更爽的了\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e至此，截图的基本功能都实现了，但还差最后一步\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader14\x22\x3e另一次历史性的对话 - 图片上传\x3c\/h1\x3e\n\x3cp\x3e图片已经截出来了，下一步就是怎么上传了，通过Ajax上传，需要将图像数据转化为\x3ccode\x3eFile\x3c\/code\x3e，而在canvas的API中自带\x3ccode\x3etoBlob()\x3c\/code\x3e函数 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/HTMLCanvasElement\/toBlob\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/\/详情\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var resultFile = {}\ntheCanvas.addEventListener(\x26quot;mouseup\x26quot;, e =\x3e {\n    resultCanvas.toBlob(blob =\x3e {\n            resultFile = blob;\n            console.log(blob);\/\/Blob(1797) {size: 1797, type: \x26quot;image\/png\x26quot;}\n        }\n    })\n    flag = false;\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e resultFile = {}\ntheCanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22mouseup\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    resultCanvas.toBlob(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eblob\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            resultFile = blob;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(blob);\x3cspan class=\x22hljs-comment\x22\x3e\/\/Blob(1797) {size: 1797, type: \x22image\/png\x22}\x3c\/span\x3e\n        }\n    })\n    flag = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后就可以用Ajax上传拉，具体怎么上传就需要具体问题具体分析了\x3c\/p\x3e\n\x3cp\x3e至此，整个插件的思路及需要用到相关技术都捋清楚了，接下来就可以开始按照上文的需求进行开发了，而这是下一篇文章要讲的事情了\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e能看到这的绝对很闲\x3c\/strong\x3e\x3cbr\x3e\x3cstrong\x3e这篇文章的长度让我想起读研时被毕业论文统治的恐惧\x3c\/strong\x3e\x3cbr\x3e\x3cstrong\x3e本来想着连同组件开发一起在一篇内写完呢，但是实在太长还是放弃了\x3c\/strong\x3e\x3cbr\x3e\x3cstrong\x3e身体和家人都是最重要的，今年还没过一个月就被上了很多课\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>实践是检验程序员的唯一标准01：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【思路篇】</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013038300">https://segmentfault.com/a/1190000013038300</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9ucm99xx3bm/" target="_blank">https://alili.tech/archive/9ucm99xx3bm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>