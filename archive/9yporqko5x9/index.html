<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一字一句的搞懂vue-cli之vue webpack template配置"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一字一句的搞懂vue-cli之vue webpack template配置 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9yporqko5x9/",
				"appid": "1613049289050283", 
				"title": "一字一句的搞懂vue-cli之vue webpack template配置 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-21T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/l81zwngb0r/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/17fv931w1mci/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&text=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&text=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&title=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&is_video=false&description=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&title=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&title=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&title=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9yporqko5x9%2f&title=%e4%b8%80%e5%ad%97%e4%b8%80%e5%8f%a5%e7%9a%84%e6%90%9e%e6%87%82vue-cli%e4%b9%8bvue%20webpack%20template%e9%85%8d%e7%bd%ae"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一字一句的搞懂vue-cli之vue webpack template配置</h1><div class="meta"><div class="postdate"><time datetime="2018-12-21" itemprop="datePublished">2018-12-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3ewebpack--神一样的存在。无论写了多少次，再次相见，仍是初见。有的时候开发vue项目，对尤大的vue-cli感激涕零。但是，但是，但是。。。不是自己的东西，真的很不想折腾。所以，我们就得深入内部，\x3ccode\x3ecp them us\x3c\/code\x3e。所以呢，就利用两天时间，参考了一些他人的文章，查阅了一些官方的配置，就在此先稍微记录一下。\x3c\/p\x3e\n\x3cblockquote\x3e这份配置解析是基于最新版本的\x3ca href=\x22https:\/\/github.com\/vuejs-templates\/webpack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue webpack template\x3c\/a\x3e。不过，我非常建议，先别看我的文章，自己一句一句的通读一遍。然后再来瞅瞅，毕竟，碰撞的思维才能创造新的发现。\x3c\/blockquote\x3e\n\x3cp\x3evue webpack的配置文件还是挺多的，下面是关于此配置的基本目录结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22config\n├── dev.env.js \/\/dev环境变量配置\n├── index.js \/\/ dev和prod环境的一些基本配置\n└── prod.env.js \/\/ prod环境变量配置\nbuild\n├── build.js \/\/ npm run build所执行的脚本\n├── check-versions.js \/\/ 检查npm和node的版本\n├── logo.png\n├── utils.js \/\/ 一些工具方法，主要用于生成cssLoader和styleLoader配置\n├── vue-loader.conf.js \/\/ vueloader的配置信息\n├── webpack.base.conf.js \/\/ dev和prod的公共配置\n├── webpack.dev.conf.js \/\/ dev环境的配置\n└── webpack.prod.conf.js \/\/ prod环境的配置\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3econfig\n├── dev.env.js \/\/dev环境变量配置\n├── index.js \/\/ dev和prod环境的一些基本配置\n└── prod.env.js \/\/ prod环境变量配置\nbuild\n├── build.js \/\/ npm run build所执行的脚本\n├── check-versions.js \/\/ 检查npm和node的版本\n├── logo.png\n├── utils.js \/\/ 一些工具方法，主要用于生成cssLoader和styleLoader配置\n├── vue-loader.conf.js \/\/ vueloader的配置信息\n├── webpack.base.conf.js \/\/ dev和prod的公共配置\n├── webpack.dev.conf.js \/\/ dev环境的配置\n└── webpack.prod.conf.js \/\/ prod环境的配置\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面我们就按照如下的顺序分析源码：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3econfig\/index.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/utils.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/vue-loader.conf.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/webpack.base.conf.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/webpack.dev.conf.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/webpack.prod.conf.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/check-versions.js\x3c\/code\x3e -\x26gt; \x3ccode\x3ebuild\/build.js\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e\n\x3ccode\x3econfig\/index.js\x3c\/code\x3e: 一些基本属性的配置(我们可以根据自己的需要来更改这些配置)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 这个文件主要是对开发环境和生产环境的一个基本的配置\nconst path = require(\x27path\x27)\n\nmodule.exports = {\n  \/\/ 开发环境的一个基本配置\n  dev: {\n    \/\/ 编译输出的二级目录\n    assetsSubDirectory: \x27static\x27,\n    \/\/ 编译发布的根目录，可配置为资源服务器域名或者cdn域名\n    assetsPublicPath: \x27\/\x27,\n    \/\/ 需要使用proxyTable代理的接口(可以跨域)\n    proxyTable: {},\n\n    \/\/ 开发时候的访问域名。可以通过环境变量自己设置。\n    host: \x27localhost\x27, \/\/ can be overwritten by process.env.HOST\n    \/\/ 开发时候的端口。可以通过环境变量PORT设定。如果端口被占用了，会随机分配一个未被使用的端口\n    port: 8080, \n    \/\/ 是否自动打开浏览器\n    autoOpenBrowser: false,\n    \/\/ 下面两个都是浏览器展示错误的方式\n    \/\/  在浏览器是否展示错误蒙层\n    errorOverlay: true,\n    \/\/ 是否展示错误的通知\n    notifyOnErrors: true,\n\n    \/\/ 这个是webpack-dev-servr的watchOptions的一个选项，指定webpack检查文件的方式\n    \/\/ 因为webpack使用文件系统去获取文件改变的通知。在有些情况下，这个可能不起作用。例如，当使用NFC的时候，\n    \/\/ vagrant也会在这方面存在很多问题，在这些情况下，使用poll选项（以轮询的方式去检查文件是否改变）可以设定为true\n    \/\/ 或者具体的数值，指定文件查询的具体周期。\n    poll: false, \n    \/\/ 是否使用eslint loader去检查代码\n    useEslint: true,\n    \n    \/\/ 如果设置为true，在浏览器中，eslint的错误和警告会以蒙层的方式展现。\n    showEslintErrorsInOverlay: false,\n\n    \/**\n     * Source Maps\n     *\/\n\n    \/\/ source maps的格式\n    devtool: \x27eval-source-map\x27,\n\n    \/\/ 指定是否通过在文件名称后面添加一个查询字符串来创建source map的缓存\n    cacheBusting: true,\n    \/\/ 关闭css的source map\n    cssSourceMap: false,\n  },\n\n  build: {\n    \/\/ html文件的生成的地方\n    index: path.resolve(__dirname, \x27..\/dist\/index.html\x27),\n\n    \/\/ 编译生成的文件的目录\n    assetsRoot: path.resolve(__dirname, \x27..\/dist\x27),\n    \/\/ 编译生成的静态文件的目录\n    assetsSubDirectory: \x27static\x27,\n    \/\/ 编译发布的根目录，可配置为资源服务器域名或者cdn域名\n    assetsPublicPath: \x27\/\x27,\n\n    \/**\n     * Source Maps\n     *\/\n\n    productionSourceMap: true,\n    \n    devtool: \x27#source-map\x27,\n    \n    \/\/ 是否开启生产环境的gzip压缩\n    productionGzip: false,\n    \/\/ 开启gzip压缩的文件的后缀名称\n    productionGzipExtensions: [\x27js\x27, \x27css\x27],\n\n    \/\/ 如果这个选项是true的话，那么则会在build后，会在浏览器中生成一份bundler报告\n    bundleAnalyzerReport: process.env.npm_config_report\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个文件主要是对开发环境和生产环境的一个基本的配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开发环境的一个基本配置\x3c\/span\x3e\n  dev: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译输出的二级目录\x3c\/span\x3e\n    assetsSubDirectory: \x3cspan class=\x22hljs-string\x22\x3e\x27static\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译发布的根目录，可配置为资源服务器域名或者cdn域名\x3c\/span\x3e\n    assetsPublicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要使用proxyTable代理的接口(可以跨域)\x3c\/span\x3e\n    proxyTable: {},\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开发时候的访问域名。可以通过环境变量自己设置。\x3c\/span\x3e\n    host: \x3cspan class=\x22hljs-string\x22\x3e\x27localhost\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ can be overwritten by process.env.HOST\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开发时候的端口。可以通过环境变量PORT设定。如果端口被占用了，会随机分配一个未被使用的端口\x3c\/span\x3e\n    port: \x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e, \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否自动打开浏览器\x3c\/span\x3e\n    autoOpenBrowser: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面两个都是浏览器展示错误的方式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  在浏览器是否展示错误蒙层\x3c\/span\x3e\n    errorOverlay: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否展示错误的通知\x3c\/span\x3e\n    notifyOnErrors: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个是webpack-dev-servr的watchOptions的一个选项，指定webpack检查文件的方式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为webpack使用文件系统去获取文件改变的通知。在有些情况下，这个可能不起作用。例如，当使用NFC的时候，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vagrant也会在这方面存在很多问题，在这些情况下，使用poll选项（以轮询的方式去检查文件是否改变）可以设定为true\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者具体的数值，指定文件查询的具体周期。\x3c\/span\x3e\n    poll: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否使用eslint loader去检查代码\x3c\/span\x3e\n    useEslint: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果设置为true，在浏览器中，eslint的错误和警告会以蒙层的方式展现。\x3c\/span\x3e\n    showEslintErrorsInOverlay: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * Source Maps\n     *\/\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ source maps的格式\x3c\/span\x3e\n    devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27eval-source-map\x27\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定是否通过在文件名称后面添加一个查询字符串来创建source map的缓存\x3c\/span\x3e\n    cacheBusting: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 关闭css的source map\x3c\/span\x3e\n    cssSourceMap: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3ebuild\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ html文件的生成的地方\x3c\/span\x3e\n    index: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\/dist\/index.html\x27\x3c\/span\x3e),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译生成的文件的目录\x3c\/span\x3e\n    assetsRoot: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\/dist\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译生成的静态文件的目录\x3c\/span\x3e\n    assetsSubDirectory: \x3cspan class=\x22hljs-string\x22\x3e\x27static\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译发布的根目录，可配置为资源服务器域名或者cdn域名\x3c\/span\x3e\n    assetsPublicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * Source Maps\n     *\/\x3c\/span\x3e\n\n    productionSourceMap: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \n    \x3cspan class=\x22hljs-attr\x22\x3edevtool\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#source-map\x27\x3c\/span\x3e,\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开启生产环境的gzip压缩\x3c\/span\x3e\n    productionGzip: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开启gzip压缩的文件的后缀名称\x3c\/span\x3e\n    productionGzipExtensions: [\x3cspan class=\x22hljs-string\x22\x3e\x27js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27css\x27\x3c\/span\x3e],\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果这个选项是true的话，那么则会在build后，会在浏览器中生成一份bundler报告\x3c\/span\x3e\n    bundleAnalyzerReport: process.env.npm_config_report\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e\n\x3ccode\x3ebuild\/utils.js\x3c\/code\x3e: 主要用于生成css loader和style loader的一些方法\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 引入nodejs的path模块，用于操作路径\nconst path = require(\x27path\x27)\n\/\/ 引入模板的配置文件，下面就需要去这个文件中看看有什么基本的配置\nconst config = require(\x27..\/config\x27)\n\/\/ 提取特定文件的插件，比如把css文件提取到一个文件中去\nconst ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27)\n\/\/ 加载package.json文件\nconst packageConfig = require(\x27..\/package.json\x27)\n\n\/\/ 生成编译输出的二级目录\nexports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === \x27production\x27\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  \/\/ path.posix是path模块跨平台的实现（不同平台的路径表示是不一样的）\n  return path.posix.join(assetsSubDirectory, _path)\n}\n\n\/\/ 为不同的css预处理器提供一个统一的生成方式，也就是统一处理各种css类型的打包问题。\n\/\/ 这个是为在vue文件中的style中使用的css类型\nexports.cssLoaders = function (options) {\n  options = options || {}\n\n  \/\/ 打包css模块\n  const cssLoader = {\n    loader: \x27css-loader\x27,\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  \/\/ 编译postcss模块\n  const postcssLoader = {\n    \/\/ 使用postcss-loader来打包postcss模块\n    loader: \x27postcss-loader\x27,\n    \/\/ 配置source map\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  \/\/ 创建loader加载器字符串，结合extract text插件使用\n  \/**\n   * \n   * @param {loader的名称} loader \n   * @param {loader对应的options配置对象} loaderOptions \n   *\/\n  function generateLoaders (loader, loaderOptions) {\n    \/\/ 通过usePostCSS 来标明是否使用了postcss\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    \/\/ 如果指定了具体的loader的名称\n    if (loader) {\n      \/\/ 向loaders的数组中添加该loader对应的加载器\n      \/\/ 一个很重要的地方就是，一个数组中的loader加载器，是从右向左执行的。\n      loaders.push({\n        \/\/ loader加载器的名称\n        loader: loader \x2b \x27-loader\x27,\n        \/\/ 对应的加载器的配置对象\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    \/\/ 如果明确指定了需要提取静态文件，则使用\n    \/\/ ExtractTextPlugin.extract({})来包裹我们的各种css处理器。\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        \/\/ fallback这个选项我们可以这样理解\n        \/\/ webpack默认会按照loaders中的加载器从右向左调用编译各种css类型文件。如果一切顺利，在loaders中的\n        \/\/ 各个加载器运行结束之后就会把css文件导入到规定的文件中去，如果不顺利，则继续使用vue-style-loader来处理\n        \/\/ css文件\n        fallback: \x27vue-style-loader\x27\n      })\n    } else {\n      \/\/ 如果没有提取行为，则最后再使用vue-style-loader处理css\n      return [\x27vue-style-loader\x27].concat(loaders)\n    }\n  }\n\n  return {\n    \/\/ css-loader\n    css: generateLoaders(),\n    \/\/ postcss-loader\n    postcss: generateLoaders(),\n    \/\/ less-loader\n    less: generateLoaders(\x27less\x27),\n    \/\/ sass-loader 后面的选项表明sass使用的是缩进的愈发\n    sass: generateLoaders(\x27sass\x27, { indentedSyntax: true }),\n    \/\/ scss-loader\n    scss: generateLoaders(\x27sass\x27),\n    \/\/ stylus-loader stylus文件有两种后缀名.stylus和styl\n    stylus: generateLoaders(\x27stylus\x27),\n    \/\/ stylus-loader\n    styl: generateLoaders(\x27stylus\x27)\n  }\n}\n\n\/\/ 使用这个函数，为那些独立的style文件创建加载器配置。\nexports.styleLoaders = function (options) {\n  \/\/ 保存加载器配置的变量\n  const output = []\n  \/\/ 获取所有css文件类型的loaders\n  const loaders = exports.cssLoaders(options)\n\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    \/\/ 生成对应的loader配置\n    output.push({\n      test: new RegExp(\x27\\\\.\x27 \x2b extension \x2b \x27$\x27),\n      use: loader\n    })\n  }\n\n  return output\n}\n\nexports.createNotifierCallback = () =\x3e {\n  \/\/ node-notifier是一个跨平台的包，以类似浏览器的通知的形式展示信息。\n  const notifier = require(\x27node-notifier\x27)\n\n  return (severity, errors) =\x3e {\n    \/\/ 只展示错误的信息\n    if (severity !== \x27error\x27) return\n\n    const error = errors[0]\n    const filename = error.file \x26amp;\x26amp; error.file.split(\x27!\x27).pop()\n\n    \/\/ 需要展示的错误信息的内容 \n    notifier.notify({\n      \/\/ 通知的标题\n      title: packageConfig.name,\n      \/\/ 通知的主体内容\n      message: severity \x2b \x27: \x27 \x2b error.name,\n      \/\/ 副标题\n      subtitle: filename || \x27\x27,\n      \/\/ 通知展示的icon\n      icon: path.join(__dirname, \x27logo.png\x27)\n    })\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入nodejs的path模块，用于操作路径\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入模板的配置文件，下面就需要去这个文件中看看有什么基本的配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取特定文件的插件，比如把css文件提取到一个文件中去\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27extract-text-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载package.json文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e packageConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/package.json\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成编译输出的二级目录\x3c\/span\x3e\nexports.assetsPath = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e_path\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e assetsSubDirectory = process.env.NODE_ENV === \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ path.posix是path模块跨平台的实现（不同平台的路径表示是不一样的）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path.posix.join(assetsSubDirectory, _path)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为不同的css预处理器提供一个统一的生成方式，也就是统一处理各种css类型的打包问题。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个是为在vue文件中的style中使用的css类型\x3c\/span\x3e\nexports.cssLoaders = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  options = options || {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打包css模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cssLoader = {\n    \x3cspan class=\x22hljs-attr\x22\x3eloader\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eoptions\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: options.sourceMap\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译postcss模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e postcssLoader = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用postcss-loader来打包postcss模块\x3c\/span\x3e\n    loader: \x3cspan class=\x22hljs-string\x22\x3e\x27postcss-loader\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置source map\x3c\/span\x3e\n    options: {\n      \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: options.sourceMap\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建loader加载器字符串，结合extract text插件使用\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * \n   * @param {loader的名称} loader \n   * @param {loader对应的options配置对象} loaderOptions \n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egenerateLoaders\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eloader, loaderOptions\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过usePostCSS 来标明是否使用了postcss\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果指定了具体的loader的名称\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (loader) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 向loaders的数组中添加该loader对应的加载器\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个很重要的地方就是，一个数组中的loader加载器，是从右向左执行的。\x3c\/span\x3e\n      loaders.push({\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ loader加载器的名称\x3c\/span\x3e\n        loader: loader \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对应的加载器的配置对象\x3c\/span\x3e\n        options: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, loaderOptions, {\n          \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: options.sourceMap\n        })\n      })\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果明确指定了需要提取静态文件，则使用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ExtractTextPlugin.extract({})来包裹我们的各种css处理器。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.extract) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ExtractTextPlugin.extract({\n        \x3cspan class=\x22hljs-attr\x22\x3euse\x3c\/span\x3e: loaders,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fallback这个选项我们可以这样理解\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack默认会按照loaders中的加载器从右向左调用编译各种css类型文件。如果一切顺利，在loaders中的\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 各个加载器运行结束之后就会把css文件导入到规定的文件中去，如果不顺利，则继续使用vue-style-loader来处理\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ css文件\x3c\/span\x3e\n        fallback: \x3cspan class=\x22hljs-string\x22\x3e\x27vue-style-loader\x27\x3c\/span\x3e\n      })\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有提取行为，则最后再使用vue-style-loader处理css\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [\x3cspan class=\x22hljs-string\x22\x3e\x27vue-style-loader\x27\x3c\/span\x3e].concat(loaders)\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ css-loader\x3c\/span\x3e\n    css: generateLoaders(),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ postcss-loader\x3c\/span\x3e\n    postcss: generateLoaders(),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ less-loader\x3c\/span\x3e\n    less: generateLoaders(\x3cspan class=\x22hljs-string\x22\x3e\x27less\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sass-loader 后面的选项表明sass使用的是缩进的愈发\x3c\/span\x3e\n    sass: generateLoaders(\x3cspan class=\x22hljs-string\x22\x3e\x27sass\x27\x3c\/span\x3e, { \x3cspan class=\x22hljs-attr\x22\x3eindentedSyntax\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ scss-loader\x3c\/span\x3e\n    scss: generateLoaders(\x3cspan class=\x22hljs-string\x22\x3e\x27sass\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stylus-loader stylus文件有两种后缀名.stylus和styl\x3c\/span\x3e\n    stylus: generateLoaders(\x3cspan class=\x22hljs-string\x22\x3e\x27stylus\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stylus-loader\x3c\/span\x3e\n    styl: generateLoaders(\x3cspan class=\x22hljs-string\x22\x3e\x27stylus\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用这个函数，为那些独立的style文件创建加载器配置。\x3c\/span\x3e\nexports.styleLoaders = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存加载器配置的变量\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e output = []\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取所有css文件类型的loaders\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e loaders = exports.cssLoaders(options)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e extension \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e loaders) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e loader = loaders[extension]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成对应的loader配置\x3c\/span\x3e\n    output.push({\n      \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\\\\.\x27\x3c\/span\x3e \x2b extension \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27$\x27\x3c\/span\x3e),\n      \x3cspan class=\x22hljs-attr\x22\x3euse\x3c\/span\x3e: loader\n    })\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e output\n}\n\nexports.createNotifierCallback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node-notifier是一个跨平台的包，以类似浏览器的通知的形式展示信息。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e notifier = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27node-notifier\x27\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseverity, errors\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只展示错误的信息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (severity !== \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e error = errors[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filename = error.file \x26amp;\x26amp; error.file.split(\x3cspan class=\x22hljs-string\x22\x3e\x27!\x27\x3c\/span\x3e).pop()\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要展示的错误信息的内容 \x3c\/span\x3e\n    notifier.notify({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知的标题\x3c\/span\x3e\n      title: packageConfig.name,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知的主体内容\x3c\/span\x3e\n      message: severity \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: \x27\x3c\/span\x3e \x2b error.name,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 副标题\x3c\/span\x3e\n      subtitle: filename || \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知展示的icon\x3c\/span\x3e\n      icon: path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27logo.png\x27\x3c\/span\x3e)\n    })\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\n\x3ccode\x3ebuild\/vue-loader.conf.js\x3c\/code\x3e:vue-loader的一些基本配置\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\nconst utils = require(\x27.\/utils\x27)\nconst config = require(\x27..\/config\x27)\n\/\/ 设置是不是生产环境\nconst isProduction = process.env.NODE_ENV === \x27production\x27\n\/\/ 根据不同的环境，引入不同的source map配置文件\nconst sourceMapEnabled = isProduction\n  ? config.build.productionSourceMap\n  : config.dev.cssSourceMap\n\nmodule.exports = {\n  \/\/ vue文件中的css loader配置\n  loaders: utils.cssLoaders({\n    sourceMap: sourceMapEnabled,\n    \/\/ 生产环境下就会把css文件抽取到一个独立的文件中\n    extract: isProduction\n  }),\n  \/\/ css source map文件的配置\n  cssSourceMap: sourceMapEnabled,\n  \/\/ css source map文件缓存控制变量\n  cacheBusting: config.dev.cacheBusting,\n  transformToRequire: {\n    video: [\x27src\x27, \x27poster\x27],\n    source: \x27src\x27,\n    img: \x27src\x27,\n    image: \x27xlink:href\x27\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e utils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/utils\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置是不是生产环境\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isProduction = process.env.NODE_ENV === \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据不同的环境，引入不同的source map配置文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sourceMapEnabled = isProduction\n  ? config.build.productionSourceMap\n  : config.dev.cssSourceMap\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vue文件中的css loader配置\x3c\/span\x3e\n  loaders: utils.cssLoaders({\n    \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: sourceMapEnabled,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生产环境下就会把css文件抽取到一个独立的文件中\x3c\/span\x3e\n    extract: isProduction\n  }),\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ css source map文件的配置\x3c\/span\x3e\n  cssSourceMap: sourceMapEnabled,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ css source map文件缓存控制变量\x3c\/span\x3e\n  cacheBusting: config.dev.cacheBusting,\n  \x3cspan class=\x22hljs-attr\x22\x3etransformToRequire\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evideo\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27poster\x27\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-attr\x22\x3esource\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eimg\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eimage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27xlink:href\x27\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\n\x3ccode\x3ebuild\/weback.base.conf.js\x3c\/code\x3e:dev和prod环境下的公共配置\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\nconst path = require(\x27path\x27)\nconst utils = require(\x27.\/utils\x27)\nconst config = require(\x27..\/config\x27)\nconst vueLoaderConfig = require(\x27.\/vue-loader.conf\x27)\n\/\/ 生成相对于根目录的绝对路径\nfunction resolve (dir) {\n  return path.join(__dirname, \x27..\x27, dir)\n}\n\n\/\/ eslint的规则\nconst createLintingRule = () =\x3e ({\n  \/\/ 对.js和.vue结尾的文件进行eslint检查\n  test: \/\\.(js|vue)$\/,\n  \/\/ 使用eslint-loader\n  loader: \x27eslint-loader\x27,\n  \/\/ enforce的值可能是pre和post。其中pre有点和webpack@1中的preLoader配置含义相似。\n  \/\/ post和v1中的postLoader配置含义相似。表示loader的调用时机\n  \/\/ 这里表示在调用其他loader之前需要先调用这个规则进行代码风格的检查\n  enforce: \x27pre\x27,\n  \/\/ 需要进行eslint检查的文件的目录存在的地方\n  include: [resolve(\x27src\x27), resolve(\x27test\x27)],\n  \/\/ eslint-loader配置过程中需要指定的选项\n  options: {\n    \/\/ 文件风格的检查的格式化程序，这里使用的是第三方的eslint-friendly-formatter\n    formatter: require(\x27eslint-friendly-formatter\x27),\n    \/\/ 是否需要eslint输出警告信息\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})\n\n\/\/ 下面就是webpack基本的配置信息（可以立即成是开发环境和生产环境公共的配置）\nmodule.exports = {\n  \/\/ webpack解析文件时候的根目录(如果把webpack.config.js)放在了项目的根目录下面，这个配置可以省略\n  context: path.resolve(__dirname, \x27..\/\x27),\n  \/\/ 指定项目的入口文件\n  entry: {\n    app: \x27.\/src\/main.js\x27\n  },\n  \/\/ 项目的输出配置\n  output: {\n    \/\/ 项目build的时候，生成的文件的存放路径(这里的路径是..\/dist)\n    path: config.build.assetsRoot,\n    \/\/ 生成文件的名称\n    filename: \x27[name].js\x27,\n    \/\/ 输出解析文件的目录，url 相对于 HTML 页面(生成的html文件中，css和js等静态文件的url前缀)\n    publicPath: process.env.NODE_ENV === \x27production\x27\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  \/\/ 配置模块解析时候的一些选项\n  resolve: {\n    \/\/ 指定哪些类型的文件可以引用的时候省略后缀名\n    extensions: [\x27.js\x27, \x27.vue\x27, \x27.json\x27],\n    \/\/ 别名，在引入文件的时候可以使用\n    alias: {\n      \x27vue$\x27: \x27vue\/dist\/vue.esm.js\x27,\n      \/\/ 可以在引入文件的时候使用@符号引入src文件夹中的文件\n      \x27@\x27: resolve(\x27src\x27),\n    }\n  },\n  \/\/ 下面是针对具体的模块进行的具体的配置\n  \/\/ 下面的配置语法采用的是version \x3e= @2的版本\n  module: {\n    \/\/ rules是一个数组，其中的每一个元素都是一个对象，这个对象是针对具体类型的文件进行的配置。\n    rules: [\n      \/\/ .vue文件的配置\n      {\n        \/\/ 这个属性是一个正则表达式，用于匹配文件。这里匹配的是.vue文件\n        test: \/\\.vue$\/,\n        \/\/ 指定该种类型文件的加载器名称\n        loader: \x27vue-loader\x27,\n        \/\/ 针对此加载器的具体配置\n        \/\/ 针对前面的分析，这个配置对象中包含了各种css类型文件的配置，css source map的配置 以及一些transform的配置\n        options: vueLoaderConfig\n      },\n      {\n        \/\/ .js文件的配置\n        test: \/\\.js$\/,\n        \/\/ js文件的处理主要使用的是babel-loader。在这里没有指定具体的编译规则，babel-loader会自动\n        \/\/ 读取根目录下面的.babelrc中的babel配置用于编译js文件\n        \/**\n         * {\n         * \/\/ 使用的预设\n            \x26quot;presets\x26quot;: [\n              \/\/ babel-preset-env: 根据你所支持的环境自动决定具体类型的babel插件\n              [\x26quot;env\x26quot;, {\n                \/\/ modules设置为false，不会转换module\n                \x26quot;modules\x26quot;: false\n              }],\n              \/\/ babel-preset-stage-2: 可以使用所有\x3e=stage2语法\n              \x26quot;stage-2\x26quot;\n            ],\n            \/\/ 使用的插件\n            \/\/ babel-plugin-transform-runtime: 只会对es6的语法进行转换而不会对新的api进行转换\n            \/\/ 如果需要支持新的api，请引入babel-polyfill\n            \x26quot;plugins\x26quot;: [\x26quot;transform-runtime\x26quot;]\n          }\n\n         *\/\n        loader: \x27babel-loader\x27,\n        \/\/ 指定需要进行编译的文件的路径\n        \/\/ 这里表示只对src和test文件夹中的文件进行编译\n        include: [resolve(\x27src\x27), resolve(\x27test\x27)]\n      },\n      {\n        \/\/ 对图片资源进行编译的配置\n        \/\/ 指定文件的类型\n        test: \/\\.(png|jpe?g|gif|svg)(\\?.*)?$\/,\n        \/\/ 使用url-loader进行文件资源的编译\n        loader: \x27url-loader\x27,\n        \/\/ url-loader的配置选项\n        options: {\n          \/\/ 文件的大小小于10000字节(10kb)的时候会返回一个dataUrl\n          limit: 10000,\n          \/\/ 生成的文件的保存路径和后缀名称\n          name: utils.assetsPath(\x27img\/[name].[hash:7].[ext]\x27)\n        }\n      },\n      {\n        \/\/ 对视频文件进行打包编译\n        test: \/\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$\/,\n        loader: \x27url-loader\x27,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(\x27media\/[name].[hash:7].[ext]\x27)\n        }\n      },\n      {\n        \/\/ 对字体文件进行打包编译\n        test: \/\\.(woff2?|eot|ttf|otf)(\\?.*)?$\/,\n        loader: \x27url-loader\x27,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(\x27fonts\/[name].[hash:7].[ext]\x27)\n        }\n      }\n    ]\n  },\n  \/\/ 这些选项用于配置polyfill或mock某些node.js全局变量和模块。\n  \/\/ 这可以使最初为nodejs编写的代码可以在浏览器端运行\n  node: {\n    \/\/ 这个配置是一个对象，其中的每个属性都是nodejs全局变量或模块的名称\n    \/\/ prevent webpack from injecting useless setImmediate polyfill because Vue\n    \/\/ source contains it (although only uses it if it\x27s native).\n    \/\/ false表示什么都不提供。如果获取此对象的代码，可能会因为获取不到此对象而触发ReferenceError错误\n    setImmediate: false,\n    \/\/ prevent webpack from injecting mocks to Node native modules\n    \/\/ that does not make sense for the client\n    \/\/ 设置成empty则表示提供一个空对象\n    dgram: \x27empty\x27,\n    fs: \x27empty\x27,\n    net: \x27empty\x27,\n    tls: \x27empty\x27,\n    child_process: \x27empty\x27\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e utils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/utils\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vueLoaderConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/vue-loader.conf\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成相对于根目录的绝对路径\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edir\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\x27\x3c\/span\x3e, dir)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ eslint的规则\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e createLintingRule = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对.js和.vue结尾的文件进行eslint检查\x3c\/span\x3e\n  test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.(js|vue)$\/\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用eslint-loader\x3c\/span\x3e\n  loader: \x3cspan class=\x22hljs-string\x22\x3e\x27eslint-loader\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ enforce的值可能是pre和post。其中pre有点和webpack@1中的preLoader配置含义相似。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ post和v1中的postLoader配置含义相似。表示loader的调用时机\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里表示在调用其他loader之前需要先调用这个规则进行代码风格的检查\x3c\/span\x3e\n  enforce: \x3cspan class=\x22hljs-string\x22\x3e\x27pre\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要进行eslint检查的文件的目录存在的地方\x3c\/span\x3e\n  include: [resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e), resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e)],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ eslint-loader配置过程中需要指定的选项\x3c\/span\x3e\n  options: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件风格的检查的格式化程序，这里使用的是第三方的eslint-friendly-formatter\x3c\/span\x3e\n    formatter: \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27eslint-friendly-formatter\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否需要eslint输出警告信息\x3c\/span\x3e\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面就是webpack基本的配置信息（可以立即成是开发环境和生产环境公共的配置）\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack解析文件时候的根目录(如果把webpack.config.js)放在了项目的根目录下面，这个配置可以省略\x3c\/span\x3e\n  context: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\/\x27\x3c\/span\x3e),\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定项目的入口文件\x3c\/span\x3e\n  entry: {\n    \x3cspan class=\x22hljs-attr\x22\x3eapp\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/main.js\x27\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 项目的输出配置\x3c\/span\x3e\n  output: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 项目build的时候，生成的文件的存放路径(这里的路径是..\/dist)\x3c\/span\x3e\n    path: config.build.assetsRoot,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成文件的名称\x3c\/span\x3e\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27[name].js\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出解析文件的目录，url 相对于 HTML 页面(生成的html文件中，css和js等静态文件的url前缀)\x3c\/span\x3e\n    publicPath: process.env.NODE_ENV === \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置模块解析时候的一些选项\x3c\/span\x3e\n  resolve: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定哪些类型的文件可以引用的时候省略后缀名\x3c\/span\x3e\n    extensions: [\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.vue\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.json\x27\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 别名，在引入文件的时候可以使用\x3c\/span\x3e\n    alias: {\n      \x3cspan class=\x22hljs-string\x22\x3e\x27vue$\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27vue\/dist\/vue.esm.js\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以在引入文件的时候使用@符号引入src文件夹中的文件\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e\x27@\x27\x3c\/span\x3e: resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e),\n    }\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面是针对具体的模块进行的具体的配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面的配置语法采用的是version \x26gt;= @2的版本\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ rules是一个数组，其中的每一个元素都是一个对象，这个对象是针对具体类型的文件进行的配置。\x3c\/span\x3e\n    rules: [\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .vue文件的配置\x3c\/span\x3e\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个属性是一个正则表达式，用于匹配文件。这里匹配的是.vue文件\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.vue$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定该种类型文件的加载器名称\x3c\/span\x3e\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27vue-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 针对此加载器的具体配置\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 针对前面的分析，这个配置对象中包含了各种css类型文件的配置，css source map的配置 以及一些transform的配置\x3c\/span\x3e\n        options: vueLoaderConfig\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .js文件的配置\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ js文件的处理主要使用的是babel-loader。在这里没有指定具体的编译规则，babel-loader会自动\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取根目录下面的.babelrc中的babel配置用于编译js文件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/**\n         * {\n         * \/\/ 使用的预设\n            \x22presets\x22: [\n              \/\/ babel-preset-env: 根据你所支持的环境自动决定具体类型的babel插件\n              [\x22env\x22, {\n                \/\/ modules设置为false，不会转换module\n                \x22modules\x22: false\n              }],\n              \/\/ babel-preset-stage-2: 可以使用所有\x26gt;=stage2语法\n              \x22stage-2\x22\n            ],\n            \/\/ 使用的插件\n            \/\/ babel-plugin-transform-runtime: 只会对es6的语法进行转换而不会对新的api进行转换\n            \/\/ 如果需要支持新的api，请引入babel-polyfill\n            \x22plugins\x22: [\x22transform-runtime\x22]\n          }\n\n         *\/\x3c\/span\x3e\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定需要进行编译的文件的路径\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里表示只对src和test文件夹中的文件进行编译\x3c\/span\x3e\n        include: [resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e), resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e)]\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对图片资源进行编译的配置\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定文件的类型\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.(png|jpe?g|gif|svg)(\\?.*)?$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用url-loader进行文件资源的编译\x3c\/span\x3e\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27url-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ url-loader的配置选项\x3c\/span\x3e\n        options: {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件的大小小于10000字节(10kb)的时候会返回一个dataUrl\x3c\/span\x3e\n          limit: \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成的文件的保存路径和后缀名称\x3c\/span\x3e\n          name: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27img\/[name].[hash:7].[ext]\x27\x3c\/span\x3e)\n        }\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对视频文件进行打包编译\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eloader\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27url-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eoptions\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-attr\x22\x3elimit\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27media\/[name].[hash:7].[ext]\x27\x3c\/span\x3e)\n        }\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对字体文件进行打包编译\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.(woff2?|eot|ttf|otf)(\\?.*)?$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eloader\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27url-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eoptions\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-attr\x22\x3elimit\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27fonts\/[name].[hash:7].[ext]\x27\x3c\/span\x3e)\n        }\n      }\n    ]\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这些选项用于配置polyfill或mock某些node.js全局变量和模块。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这可以使最初为nodejs编写的代码可以在浏览器端运行\x3c\/span\x3e\n  node: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个配置是一个对象，其中的每个属性都是nodejs全局变量或模块的名称\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ prevent webpack from injecting useless setImmediate polyfill because Vue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ source contains it (although only uses it if it\x27s native).\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false表示什么都不提供。如果获取此对象的代码，可能会因为获取不到此对象而触发ReferenceError错误\x3c\/span\x3e\n    setImmediate: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ prevent webpack from injecting mocks to Node native modules\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ that does not make sense for the client\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置成empty则表示提供一个空对象\x3c\/span\x3e\n    dgram: \x3cspan class=\x22hljs-string\x22\x3e\x27empty\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efs\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27empty\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3enet\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27empty\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etls\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27empty\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3echild_process\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27empty\x27\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\n\x3ccode\x3ebuild\/weboack.dev.conf.js\x3c\/code\x3e:dev环境的配置\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 首先引入的是一些工具方法，下面我们就需要去util文件种看一下有哪些对应的工具方法\nconst utils = require(\x27.\/utils\x27)\n\/\/ 引入webpack模块\nconst webpack = require(\x27webpack\x27)\n\/\/ 引入配置文件\n\/\/ 这个配置文件中包含了一些dev和production环境的基本配置\nconst config = require(\x27..\/config\x27)\n\/\/ 引入webpack-merge模块。这个模块用于把多个webpack配置合并成一个配置，后面的配置会覆盖前面的配置。\nconst merge = require(\x27webpack-merge\x27)\n\/\/ 引入webpack的基本设置，这个设置文件包含了开发环境和生产环境的一些公共配置\nconst baseWebpackConfig = require(\x27.\/webpack.base.conf\x27)\n\/\/ 用于生成html文件的插件\nconst HtmlWebpackPlugin = require(\x27html-webpack-plugin\x27)\n\/\/ 这个插件能够更好的在终端看到webpack运行时的错误和警告等信息。可以提升开发体验。\nconst FriendlyErrorsPlugin = require(\x27friendly-errors-webpack-plugin\x27)\n\/\/ 查找一个未使用的端口\nconst portfinder = require(\x27portfinder\x27)\n\n\/\/ 获取host环境变量，用于配置开发环境域名\nconst HOST = process.env.HOST\n\/\/ 获取post环境变量，用于配置开发环境时候的端口号\nconst PORT = process.env.PORT \x26amp;\x26amp; Number(process.env.PORT)\n\n\/\/ 开发环境的完整的配置文件，\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    \/\/ 为那些独立的css类型文件添加loader配置（没有写在vue文件的style标签中的样式）\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  \/\/ 开发环境使用\x27eval-source-map\x27模式的source map\n  \/\/ 因为速度快\n  devtool: config.dev.devtool,\n\n  \/\/ these devServer options should be customized in \/config\/index.js\n  \/\/ 下面是对webpack-dev-server选项的基本配置，这些配置信息，我们可以在\/config\/index.js\n  \/\/ 文件中进行自定义配置。\n  devServer: {\n    \/\/ 用于配置在开发工具的控制台中显示的日志级别\n    \/\/ 注意这个不是对bundle的错误和警告的配置，而是对它生成之前的消息的配置\n    clientLogLevel: \x27warning\x27,\n    \/\/ 表示当使用html5的history api的时候，任意的404响应都需要被替代为index.html\n    historyApiFallback: true,\n    \/\/ 启用webpack的热替换特性\n    hot: true,\n    \/\/ 一切服务都需要使用gzip压缩\n    \/\/ 可以在js，css等文件的response header中发现有Content-Encoding:gzip响应头\n    compress: true,\n    \/\/ 指定使用一个 host。默认是 localhost\n    \/\/ 如果希望服务器外部可以访问(通过我们电脑的ip地址和端口号访问我们的应用)\n    \/\/ 可以指定0.0.0.0\n    host: HOST || config.dev.host,\n    \/\/ 指定要监听请求的端口号\n    port: PORT || config.dev.port,\n    \/\/ 是否自动打开浏览器\n    open: config.dev.autoOpenBrowser,\n    \/\/ 当编译出现错误的时候，是否希望在浏览器中展示一个全屏的蒙层来展示错误信息\n    overlay: config.dev.errorOverlay\n    \/\/ 表示只显示错误信息而不显示警告信息\n    \/\/ 如果两者都希望显示，则把这两项都设置为true\n      ? { warnings: false, errors: true }\n      \/\/ 设置为false则表示啥都不显示\n      : false,\n      \/\/ 指定webpack-dev-server的根目录，这个目录下的所有的文件都是能直接通过浏览器访问的\n      \/\/ 推荐和output.publicPath设置为一致\n    publicPath: config.dev.assetsPublicPath,\n    \/\/ 配置代理，这样我们就可以跨域访问某些接口\n    \/\/ 我们访问的接口，如果符合这个选项的配置，就会通过代理服务器转发我们的请求\n    proxy: config.dev.proxyTable,\n    \/\/ 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。\n    quiet: true, \/\/ necessary for FriendlyErrorsPlugin\n    \/\/ 与监视文件相关的控制选项。\n    watchOptions: {\n      \/\/ 如果这个选项为true，会以轮询的方式检查我们的文件的变动，效率不好\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    \/\/ 创建一个在编译时可以配置的全局变量\n    new webpack.DefinePlugin({\n      \x27process.env\x27: require(\x27..\/config\/dev.env\x27)\n    }),\n    \/\/ 启用热替换模块\n    \/\/ 记住，我们永远不要再生产环境中使用hmr\n    new webpack.HotModuleReplacementPlugin(),\n    \/\/ 这个插件的主要作用就是在热加载的时候直接返回更新文件的名称，而不是文件的id\n    new webpack.NamedModulesPlugin(),\n    \/\/ 使用这个插件可以在编译出错的时候来跳过输出阶段，这样可以确保输出资源不会包含错误。\n    new webpack.NoEmitOnErrorsPlugin(),\n\n    \/\/ 这个插件主要是生成一个html文件\n    new HtmlWebpackPlugin({\n      \/\/ 生成的html文件的名称\n      filename: \x27index.html\x27,\n      \/\/ 使用的模板的名称\n      template: \x27index.html\x27,\n      \/\/ 将所有的静态文件都插入到body文件的末尾\n      inject: true\n    }),\n  ]\n})\n\nmodule.exports = new Promise((resolve, reject) =\x3e {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  \/\/ 这种获取port的方式会返回一个promise\n  portfinder.getPort((err, port) =\x3e {\n    if (err) {\n      reject(err)\n    } else {\n      \/\/ 把获取到的端口号设置为环境变量PORT的值\n      process.env.PORT = port\n      \/\/ 重新设置webpack-dev-server的端口的值\n      devWebpackConfig.devServer.port = port\n\n      \/\/ 将FriendlyErrorsPlugin添加到webpack的配置文件中\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        \/\/ 编译成功时候的输出信息\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http:\/\/${devWebpackConfig.devServer.host}:${port}`],\n        },\n        \/\/ 当编译出错的时候，根据config.dev.notifyOnErrors来确定是否需要在桌面右上角显示错误通知框\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n      \/\/ resolve我们的配置文件\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先引入的是一些工具方法，下面我们就需要去util文件种看一下有哪些对应的工具方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e utils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/utils\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入配置文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个配置文件中包含了一些dev和production环境的基本配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack-merge模块。这个模块用于把多个webpack配置合并成一个配置，后面的配置会覆盖前面的配置。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e merge = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-merge\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack的基本设置，这个设置文件包含了开发环境和生产环境的一些公共配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e baseWebpackConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.base.conf\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于生成html文件的插件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HtmlWebpackPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27html-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件能够更好的在终端看到webpack运行时的错误和警告等信息。可以提升开发体验。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FriendlyErrorsPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27friendly-errors-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 查找一个未使用的端口\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e portfinder = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27portfinder\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取host环境变量，用于配置开发环境域名\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOST = process.env.HOST\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取post环境变量，用于配置开发环境时候的端口号\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PORT = process.env.PORT \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(process.env.PORT)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开发环境的完整的配置文件，\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e devWebpackConfig = merge(baseWebpackConfig, {\n  \x3cspan class=\x22hljs-attr\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为那些独立的css类型文件添加loader配置（没有写在vue文件的style标签中的样式）\x3c\/span\x3e\n    rules: utils.styleLoaders({ \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: config.dev.cssSourceMap, \x3cspan class=\x22hljs-attr\x22\x3eusePostCSS\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e })\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开发环境使用\x27eval-source-map\x27模式的source map\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为速度快\x3c\/span\x3e\n  devtool: config.dev.devtool,\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ these devServer options should be customized in \/config\/index.js\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面是对webpack-dev-server选项的基本配置，这些配置信息，我们可以在\/config\/index.js\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件中进行自定义配置。\x3c\/span\x3e\n  devServer: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于配置在开发工具的控制台中显示的日志级别\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意这个不是对bundle的错误和警告的配置，而是对它生成之前的消息的配置\x3c\/span\x3e\n    clientLogLevel: \x3cspan class=\x22hljs-string\x22\x3e\x27warning\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 表示当使用html5的history api的时候，任意的404响应都需要被替代为index.html\x3c\/span\x3e\n    historyApiFallback: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启用webpack的热替换特性\x3c\/span\x3e\n    hot: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一切服务都需要使用gzip压缩\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以在js，css等文件的response header中发现有Content-Encoding:gzip响应头\x3c\/span\x3e\n    compress: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定使用一个 host。默认是 localhost\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果希望服务器外部可以访问(通过我们电脑的ip地址和端口号访问我们的应用)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以指定0.0.0.0\x3c\/span\x3e\n    host: HOST || config.dev.host,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定要监听请求的端口号\x3c\/span\x3e\n    port: PORT || config.dev.port,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否自动打开浏览器\x3c\/span\x3e\n    open: config.dev.autoOpenBrowser,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当编译出现错误的时候，是否希望在浏览器中展示一个全屏的蒙层来展示错误信息\x3c\/span\x3e\n    overlay: config.dev.errorOverlay\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 表示只显示错误信息而不显示警告信息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果两者都希望显示，则把这两项都设置为true\x3c\/span\x3e\n      ? { \x3cspan class=\x22hljs-attr\x22\x3ewarnings\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eerrors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置为false则表示啥都不显示\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定webpack-dev-server的根目录，这个目录下的所有的文件都是能直接通过浏览器访问的\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 推荐和output.publicPath设置为一致\x3c\/span\x3e\n    publicPath: config.dev.assetsPublicPath,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置代理，这样我们就可以跨域访问某些接口\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们访问的接口，如果符合这个选项的配置，就会通过代理服务器转发我们的请求\x3c\/span\x3e\n    proxy: config.dev.proxyTable,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。\x3c\/span\x3e\n    quiet: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ necessary for FriendlyErrorsPlugin\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 与监视文件相关的控制选项。\x3c\/span\x3e\n    watchOptions: {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果这个选项为true，会以轮询的方式检查我们的文件的变动，效率不好\x3c\/span\x3e\n      poll: config.dev.poll,\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个在编译时可以配置的全局变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.DefinePlugin({\n      \x3cspan class=\x22hljs-string\x22\x3e\x27process.env\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\/dev.env\x27\x3c\/span\x3e)\n    }),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启用热替换模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记住，我们永远不要再生产环境中使用hmr\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.HotModuleReplacementPlugin(),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件的主要作用就是在热加载的时候直接返回更新文件的名称，而不是文件的id\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.NamedModulesPlugin(),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用这个插件可以在编译出错的时候来跳过输出阶段，这样可以确保输出资源不会包含错误。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.NoEmitOnErrorsPlugin(),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件主要是生成一个html文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HtmlWebpackPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成的html文件的名称\x3c\/span\x3e\n      filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用的模板的名称\x3c\/span\x3e\n      template: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将所有的静态文件都插入到body文件的末尾\x3c\/span\x3e\n      inject: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }),\n  ]\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这种获取port的方式会返回一个promise\x3c\/span\x3e\n  portfinder.getPort(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, port\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n      reject(err)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把获取到的端口号设置为环境变量PORT的值\x3c\/span\x3e\n      process.env.PORT = port\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新设置webpack-dev-server的端口的值\x3c\/span\x3e\n      devWebpackConfig.devServer.port = port\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将FriendlyErrorsPlugin添加到webpack的配置文件中\x3c\/span\x3e\n      devWebpackConfig.plugins.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FriendlyErrorsPlugin({\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译成功时候的输出信息\x3c\/span\x3e\n        compilationSuccessInfo: {\n          \x3cspan class=\x22hljs-attr\x22\x3emessages\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e`Your application is running here: http:\/\/\x3cspan class=\x22hljs-subst\x22\x3e${devWebpackConfig.devServer.host}\x3c\/span\x3e:\x3cspan class=\x22hljs-subst\x22\x3e${port}\x3c\/span\x3e`\x3c\/span\x3e],\n        },\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当编译出错的时候，根据config.dev.notifyOnErrors来确定是否需要在桌面右上角显示错误通知框\x3c\/span\x3e\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      }))\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve我们的配置文件\x3c\/span\x3e\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\n\x3ccode\x3ebuild\/webpack.prod.conf.js\x3c\/code\x3e:prod环境的基本配置\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 引入path模块\nconst path = require(\x27path\x27)\n\/\/ 引入工具方法\nconst utils = require(\x27.\/utils\x27)\n\/\/ 引入webpack模块\nconst webpack = require(\x27webpack\x27)\n\/\/ 引入基本的配置\nconst config = require(\x27..\/config\x27)\n\/\/ 引入webpack-merge模块\nconst merge = require(\x27webpack-merge\x27)\n\/\/ 引入开发环境和生产环境公共的配置\nconst baseWebpackConfig = require(\x27.\/webpack.base.conf\x27)\n\/\/ 引入copy-webpack-plugin模块\n\/\/ 这个模块主要用于在webpack中拷贝文件和文件夹\nconst CopyWebpackPlugin = require(\x27copy-webpack-plugin\x27)\n\/\/ 引入html-webpack-plugin插件\n\/\/ 这个插件主要是用于基于模版生成html文件的\nconst HtmlWebpackPlugin = require(\x27html-webpack-plugin\x27)\n\/\/ 引入extract-text-webpack-plugin插件\n\/\/ 这个插件主要是用于将入口中所有的chunk，移到独立的分离的css文件中\nconst ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27)\n\/\/ 引入optimize-css-assets-webpack-plugin插件\n\/\/ 这个插件主要是用于压缩css模块的\nconst OptimizeCSSPlugin = require(\x27optimize-css-assets-webpack-plugin\x27)\n\/\/ 引入uglifyjs-webpack-plugin插件\n\/\/ 这个插件主要是用于压缩js文件的\nconst UglifyJsPlugin = require(\x27uglifyjs-webpack-plugin\x27)\n\/\/ 引入用于生产环境的一些基本变量\nconst env = require(\x27..\/config\/prod.env\x27)\n\n\/\/ 合并公共配置和生产环境独有的配置并返回一个用于生产环境的webpack配置文件\nconst webpackConfig = merge(baseWebpackConfig, {\n  \/\/ 用于生产环境的一些loader配置\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      \/\/ 在生产环境中使用extract选项，这样就会把thunk中的css代码抽离到一份独立的css文件中去\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  \/\/ 配置生产环境中使用的source map的形式。在这里，生产环境使用的是#source map的形式\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    \/\/ build所产生的文件的存放的文件夹地址\n    path: config.build.assetsRoot,\n    \/\/ build之后的文件的名称\n    \/\/ 这里[name]和[chunkhash]都是占位符\n    \/\/ 其中[name]指的就是模块的名称\n    \/\/ [chunkhash]chunk内容的hash字符串，长度为20\n    filename: utils.assetsPath(\x27js\/[name].[chunkhash].js\x27),\n    \/\/ [id]也是一个占位符，表示的是模块标识符(module identifier)\n    chunkFilename: utils.assetsPath(\x27js\/[id].[chunkhash].js\x27)\n  },\n  plugins: [\n    \/\/ http:\/\/vuejs.github.io\/vue-loader\/en\/workflow\/production.html\n    new webpack.DefinePlugin({\n      \x27process.env\x27: env\n    }),\n    \/\/ 压缩javascript的插件\n    new UglifyJsPlugin({\n      \/\/ 压缩js的时候的一些基本配置\n      uglifyOptions: {\n        \/\/ 配置压缩的行为\n        compress: {\n          \/\/ 在删除未使用的变量等时，显示警告信息，默认就是false\n          warnings: false\n        }\n      },\n      \/\/ 使用 source map 将错误信息的位置映射到模块（这会减慢编译的速度）\n      \/\/ 而且这里不能使用cheap-source-map\n      sourceMap: config.build.productionSourceMap,\n      \/\/ 使用多进程并行运行和文件缓存来提高构建速度\n      parallel: true\n    }),\n\n    \/\/ 提取css文件到一个独立的文件中去\n    new ExtractTextPlugin({\n      \/\/ 提取之后css文件存放的地方\n      \/\/ 其中[name]和[contenthash]都是占位符\n      \/\/ [name]就是指模块的名称\n      \/\/ [contenthash]根据提取文件的内容生成的 hash\n      filename: utils.assetsPath(\x27css\/[name].[contenthash].css\x27),\n      \n      \/\/ 从所有额外的 chunk(additional chunk) 提取css内容\n      \/\/ （默认情况下，它仅从初始chunk(initial chunk) 中提取）\n      \/\/ 当使用 CommonsChunkPlugin 并且在公共 chunk 中有提取的 chunk（来自ExtractTextPlugin.extract）时\n      \/\/ 这个选项需要设置为true\n      allChunks: false,\n    }),\n    \/\/ duplicated CSS from different components can be deduped.\n    \/\/ 使用这个插件压缩css，主要是因为，对于不同组件中相同的css可以剔除一部分\n    new OptimizeCSSPlugin({\n      \/\/ 这个选项的所有配置都会传递给cssProcessor\n      \/\/ cssProcessor使用这些选项决定压缩的行为\n      cssProcessorOptions: config.build.productionSourceMap\n      \/\/ safe我不是很明白是什么意思？？？求留言告知。。。\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    \n    \/\/ 创建一个html文件\n    new HtmlWebpackPlugin({\n      \/\/ 生成的文件的名称\n      filename: config.build.index,\n      \/\/ 使用的模板的名称\n      template: \x27index.html\x27,\n      \/\/ 把script和link标签放在body底部\n      inject: true,\n      \/\/ 配置html的压缩行为\n      minify: {\n        \/\/ 移除注释\n        removeComments: true,\n        \/\/ 去除空格和换行\n        collapseWhitespace: true,\n        \/\/ 尽可能移除属性中的引号和空属性\n        removeAttributeQuotes: true\n        \/\/ more options:\n        \/\/ https:\/\/github.com\/kangax\/html-minifier#options-quick-reference\n      },\n      \/\/ 控制chunks的顺序，这里表示按照依赖关系进行排序\n      \/\/ 也可以是一个函数，自己定义排序规则\n      chunksSortMode: \x27dependency\x27\n    }),\n    \/\/ keep module.id stable when vender modules does not change\n    \/\/ 根据模块的相对路径生成一个四位数的hash作为模块id\n    new webpack.HashedModuleIdsPlugin(),\n\n    \/\/ webpack2处理过的每一个模块都会使用一个函数进行包裹\n    \/\/ 这样会带来一个问题：降低浏览器中JS执行效率，这主要是闭包函数降低了JS引擎解析速度。\n    \/\/ webpack3中，通过下面这个插件就能够将一些有联系的模块，\n    \/\/ 放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度。\n    new webpack.optimize.ModuleConcatenationPlugin(),\n\n    \/\/ 这个插件用于提取多入口chunk的公共模块\n    \/\/ 通过将公共模块提取出来之后，最终合成的文件能够在最开始的时候加载一次\n    \/\/ 然后缓存起来供后续使用，这会带来速度上的提升。\n    new webpack.optimize.CommonsChunkPlugin({\n      \/\/ 这是 common chunk 的名称\n      name: \x27vendor\x27,\n      \/\/ 把所有从mnode_modules中引入的文件提取到vendor中\n      minChunks (module) {\n      \n        return (\n          module.resource \x26amp;\x26amp;\n          \/\\.js$\/.test(module.resource) \x26amp;\x26amp;\n          module.resource.indexOf(\n            path.join(__dirname, \x27..\/node_modules\x27)\n          ) === 0\n        )\n      }\n    }),\n\n    \/\/ 为了将项目中的第三方依赖代码抽离出来，官方文档上推荐使用这个插件，当我们在项目里实际使用之后，\n    \/\/ 发现一旦更改了 app.js 内的代码，vendor.js 的 hash 也会改变，那么下次上线时，\n    \/\/ 用户仍然需要重新下载 vendor.js 与 app.js——这样就失去了缓存的意义了。所以第二次new就是解决这个问题的\n    \/\/ 参考：https:\/\/github.com\/DDFE\/DDFE-blog\/issues\/10\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \x27manifest\x27,\n      minChunks: Infinity\n    }),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \x27app\x27,\n      async: \x27vendor-async\x27,\n      children: true,\n      minChunks: 3\n    }),\n\n    \/\/ copy custom static assets\n    \/\/ 拷贝静态资源到build文件夹中\n    new CopyWebpackPlugin([\n      {\n        \/\/ 定义要拷贝的资源的源目录\n        from: path.resolve(__dirname, \x27..\/static\x27),\n        \/\/ 定义要拷贝的资源的目标目录\n        to: config.build.assetsSubDirectory,\n        \/\/ 忽略拷贝指定的文件，可以使用模糊匹配\n        ignore: [\x27.*\x27]\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  \/\/ 如果开启了生产环境的gzip\n  const CompressionWebpackPlugin = require(\x27compression-webpack-plugin\x27)\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      \/\/ 目标资源的名称\n      \/\/ [path]会被替换成原资源路径\n      \/\/ [query]会被替换成原查询字符串\n      asset: \x27[path].gz[query]\x27,\n      \/\/ gzip算法\n      \/\/ 这个选项可以配置成zlib模块中的各个算法\n      \/\/ 也可以是(buffer, cb) =\x3e cb(buffer)\n      algorithm: \x27gzip\x27,\n      \/\/ 处理所有匹配此正则表达式的资源\n      test: new RegExp(\n        \x27\\\\.(\x27 \x2b\n        config.build.productionGzipExtensions.join(\x27|\x27) \x2b\n        \x27)$\x27\n      ),\n      \/\/ 只处理比这个值大的资源\n      threshold: 10240,\n      \/\/ 只有压缩率比这个值小的资源才会被处理\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  \/\/ 如果需要生成一分bundle报告，则需要使用下面的这个插件\n  const BundleAnalyzerPlugin = require(\x27webpack-bundle-analyzer\x27).BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入path模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入工具方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e utils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/utils\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入基本的配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack-merge模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e merge = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-merge\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入开发环境和生产环境公共的配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e baseWebpackConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.base.conf\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入copy-webpack-plugin模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个模块主要用于在webpack中拷贝文件和文件夹\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e CopyWebpackPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27copy-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入html-webpack-plugin插件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件主要是用于基于模版生成html文件的\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HtmlWebpackPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27html-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入extract-text-webpack-plugin插件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件主要是用于将入口中所有的chunk，移到独立的分离的css文件中\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27extract-text-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入optimize-css-assets-webpack-plugin插件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件主要是用于压缩css模块的\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e OptimizeCSSPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27optimize-css-assets-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入uglifyjs-webpack-plugin插件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件主要是用于压缩js文件的\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e UglifyJsPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27uglifyjs-webpack-plugin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入用于生产环境的一些基本变量\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e env = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\/prod.env\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 合并公共配置和生产环境独有的配置并返回一个用于生产环境的webpack配置文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpackConfig = merge(baseWebpackConfig, {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于生产环境的一些loader配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3erules\x3c\/span\x3e: utils.styleLoaders({\n      \x3cspan class=\x22hljs-attr\x22\x3esourceMap\x3c\/span\x3e: config.build.productionSourceMap,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在生产环境中使用extract选项，这样就会把thunk中的css代码抽离到一份独立的css文件中去\x3c\/span\x3e\n      extract: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eusePostCSS\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    })\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置生产环境中使用的source map的形式。在这里，生产环境使用的是#source map的形式\x3c\/span\x3e\n  devtool: config.build.productionSourceMap ? config.build.devtool : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eoutput\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ build所产生的文件的存放的文件夹地址\x3c\/span\x3e\n    path: config.build.assetsRoot,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ build之后的文件的名称\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里[name]和[chunkhash]都是占位符\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其中[name]指的就是模块的名称\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [chunkhash]chunk内容的hash字符串，长度为20\x3c\/span\x3e\n    filename: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27js\/[name].[chunkhash].js\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [id]也是一个占位符，表示的是模块标识符(module identifier)\x3c\/span\x3e\n    chunkFilename: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27js\/[id].[chunkhash].js\x27\x3c\/span\x3e)\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/vuejs.github.io\/vue-loader\/en\/workflow\/production.html\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.DefinePlugin({\n      \x3cspan class=\x22hljs-string\x22\x3e\x27process.env\x27\x3c\/span\x3e: env\n    }),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩javascript的插件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e UglifyJsPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩js的时候的一些基本配置\x3c\/span\x3e\n      uglifyOptions: {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置压缩的行为\x3c\/span\x3e\n        compress: {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在删除未使用的变量等时，显示警告信息，默认就是false\x3c\/span\x3e\n          warnings: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n        }\n      },\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用 source map 将错误信息的位置映射到模块（这会减慢编译的速度）\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而且这里不能使用cheap-source-map\x3c\/span\x3e\n      sourceMap: config.build.productionSourceMap,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用多进程并行运行和文件缓存来提高构建速度\x3c\/span\x3e\n      parallel: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取css文件到一个独立的文件中去\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取之后css文件存放的地方\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其中[name]和[contenthash]都是占位符\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [name]就是指模块的名称\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [contenthash]根据提取文件的内容生成的 hash\x3c\/span\x3e\n      filename: utils.assetsPath(\x3cspan class=\x22hljs-string\x22\x3e\x27css\/[name].[contenthash].css\x27\x3c\/span\x3e),\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从所有额外的 chunk(additional chunk) 提取css内容\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ （默认情况下，它仅从初始chunk(initial chunk) 中提取）\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当使用 CommonsChunkPlugin 并且在公共 chunk 中有提取的 chunk（来自ExtractTextPlugin.extract）时\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个选项需要设置为true\x3c\/span\x3e\n      allChunks: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    }),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ duplicated CSS from different components can be deduped.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用这个插件压缩css，主要是因为，对于不同组件中相同的css可以剔除一部分\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e OptimizeCSSPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个选项的所有配置都会传递给cssProcessor\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cssProcessor使用这些选项决定压缩的行为\x3c\/span\x3e\n      cssProcessorOptions: config.build.productionSourceMap\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ safe我不是很明白是什么意思？？？求留言告知。。。\x3c\/span\x3e\n        ? { \x3cspan class=\x22hljs-attr\x22\x3esafe\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3emap\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3einline\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e } }\n        : { \x3cspan class=\x22hljs-attr\x22\x3esafe\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }\n    }),\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个html文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HtmlWebpackPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成的文件的名称\x3c\/span\x3e\n      filename: config.build.index,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用的模板的名称\x3c\/span\x3e\n      template: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把script和link标签放在body底部\x3c\/span\x3e\n      inject: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置html的压缩行为\x3c\/span\x3e\n      minify: {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除注释\x3c\/span\x3e\n        removeComments: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去除空格和换行\x3c\/span\x3e\n        collapseWhitespace: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 尽可能移除属性中的引号和空属性\x3c\/span\x3e\n        removeAttributeQuotes: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ more options:\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/github.com\/kangax\/html-minifier#options-quick-reference\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 控制chunks的顺序，这里表示按照依赖关系进行排序\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 也可以是一个函数，自己定义排序规则\x3c\/span\x3e\n      chunksSortMode: \x3cspan class=\x22hljs-string\x22\x3e\x27dependency\x27\x3c\/span\x3e\n    }),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep module.id stable when vender modules does not change\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据模块的相对路径生成一个四位数的hash作为模块id\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.HashedModuleIdsPlugin(),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack2处理过的每一个模块都会使用一个函数进行包裹\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这样会带来一个问题：降低浏览器中JS执行效率，这主要是闭包函数降低了JS引擎解析速度。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack3中，通过下面这个插件就能够将一些有联系的模块，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.ModuleConcatenationPlugin(),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个插件用于提取多入口chunk的公共模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过将公共模块提取出来之后，最终合成的文件能够在最开始的时候加载一次\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后缓存起来供后续使用，这会带来速度上的提升。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.CommonsChunkPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这是 common chunk 的名称\x3c\/span\x3e\n      name: \x3cspan class=\x22hljs-string\x22\x3e\x27vendor\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把所有从mnode_modules中引入的文件提取到vendor中\x3c\/span\x3e\n      minChunks (\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e) {\n      \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.resource \x26amp;\x26amp;\n          \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e.test(\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.resource) \x26amp;\x26amp;\n          \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.resource.indexOf(\n            path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\/node_modules\x27\x3c\/span\x3e)\n          ) === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        )\n      }\n    }),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了将项目中的第三方依赖代码抽离出来，官方文档上推荐使用这个插件，当我们在项目里实际使用之后，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发现一旦更改了 app.js 内的代码，vendor.js 的 hash 也会改变，那么下次上线时，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用户仍然需要重新下载 vendor.js 与 app.js——这样就失去了缓存的意义了。所以第二次new就是解决这个问题的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参考：https:\/\/github.com\/DDFE\/DDFE-blog\/issues\/10\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.CommonsChunkPlugin({\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27manifest\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eminChunks\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e\n    }),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.CommonsChunkPlugin({\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3easync\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27vendor-async\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eminChunks\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n    }),\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ copy custom static assets\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 拷贝静态资源到build文件夹中\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e CopyWebpackPlugin([\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义要拷贝的资源的源目录\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27..\/static\x27\x3c\/span\x3e),\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义要拷贝的资源的目标目录\x3c\/span\x3e\n        to: config.build.assetsSubDirectory,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 忽略拷贝指定的文件，可以使用模糊匹配\x3c\/span\x3e\n        ignore: [\x3cspan class=\x22hljs-string\x22\x3e\x27.*\x27\x3c\/span\x3e]\n      }\n    ])\n  ]\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (config.build.productionGzip) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果开启了生产环境的gzip\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e CompressionWebpackPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27compression-webpack-plugin\x27\x3c\/span\x3e)\n\n  webpackConfig.plugins.push(\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e CompressionWebpackPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 目标资源的名称\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [path]会被替换成原资源路径\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [query]会被替换成原查询字符串\x3c\/span\x3e\n      asset: \x3cspan class=\x22hljs-string\x22\x3e\x27[path].gz[query]\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ gzip算法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个选项可以配置成zlib模块中的各个算法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 也可以是(buffer, cb) =\x26gt; cb(buffer)\x3c\/span\x3e\n      algorithm: \x3cspan class=\x22hljs-string\x22\x3e\x27gzip\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理所有匹配此正则表达式的资源\x3c\/span\x3e\n      test: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27\\\\.(\x27\x3c\/span\x3e \x2b\n        config.build.productionGzipExtensions.join(\x3cspan class=\x22hljs-string\x22\x3e\x27|\x27\x3c\/span\x3e) \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27)$\x27\x3c\/span\x3e\n      ),\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只处理比这个值大的资源\x3c\/span\x3e\n      threshold: \x3cspan class=\x22hljs-number\x22\x3e10240\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有压缩率比这个值小的资源才会被处理\x3c\/span\x3e\n      minRatio: \x3cspan class=\x22hljs-number\x22\x3e0.8\x3c\/span\x3e\n    })\n  )\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (config.build.bundleAnalyzerReport) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果需要生成一分bundle报告，则需要使用下面的这个插件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e BundleAnalyzerPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-bundle-analyzer\x27\x3c\/span\x3e).BundleAnalyzerPlugin\n  webpackConfig.plugins.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e BundleAnalyzerPlugin())\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = webpackConfig\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\n\x3ccode\x3ebuild\/check-versions.js\x3c\/code\x3e：检查npm和node的版本\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 在终端为不同字体显示不同的风格\nconst chalk = require(\x27chalk\x27)\n\/\/ 解析npm包的version\nconst semver = require(\x27semver\x27)\n\/\/ 引入package.json文件\nconst packageConfig = require(\x27..\/package.json\x27)\n\/\/ node版本的uninx shell命令\nconst shell = require(\x27shelljs\x27)\n\n\/\/ 执行命令的函数\nfunction exec (cmd) {\n  return require(\x27child_process\x27).execSync(cmd).toString().trim()\n}\n\nconst versionRequirements = [\n  {\n    name: \x27node\x27,\n    \/\/ node的版本\n    \/\/ process.version就是node的版本\n    \/\/ semver.clean(\x27v8.8.0\x27) =\x3e 8.8.0\n    currentVersion: semver.clean(process.version),\n    \/\/ package.json中定义的node版本的范围 \n    versionRequirement: packageConfig.engines.node\n  }\n]\n\n\/\/ 相当于 which npm\nif (shell.which(\x27npm\x27)) {\n  \/\/ 如果npm命令存在的话\n  versionRequirements.push({\n    name: \x27npm\x27,\n    \/\/ 检查npm的版本 =\x3e 5.4.2\n    currentVersion: exec(\x27npm --version\x27),\n    \/\/ package.json中定义的npm版本\n    versionRequirement: packageConfig.engines.npm\n  })\n}\n\nmodule.exports = function () {\n  const warnings = []\n\n  for (let i = 0; i \x3c versionRequirements.length; i\x2b\x2b) {\n    const mod = versionRequirements[i]\n\n    \/\/ semver.satisfies()进行版本之间的比较\n    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {\n      \/\/ 如果现有的npm或者node的版本比定义的版本低，则生成一段警告\n      warnings.push(mod.name \x2b \x27: \x27 \x2b\n        chalk.red(mod.currentVersion) \x2b \x27 should be \x27 \x2b\n        chalk.green(mod.versionRequirement)\n      )\n    }\n  }\n\n  if (warnings.length) {\n    console.log(\x27\x27)\n    console.log(chalk.yellow(\x27To use this template, you must update following to modules:\x27))\n    console.log()\n\n    for (let i = 0; i \x3c warnings.length; i\x2b\x2b) {\n      const warning = warnings[i]\n      console.log(\x27  \x27 \x2b warning)\n    }\n\n    console.log()\n    \/\/ 退出程序\n    process.exit(1)\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在终端为不同字体显示不同的风格\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chalk = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27chalk\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析npm包的version\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e semver = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27semver\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入package.json文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e packageConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/package.json\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ node版本的uninx shell命令\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e shell = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27shelljs\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行命令的函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eexec\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecmd\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e).execSync(cmd).toString().trim()\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e versionRequirements = [\n  {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27node\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node的版本\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ process.version就是node的版本\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ semver.clean(\x27v8.8.0\x27) =\x26gt; 8.8.0\x3c\/span\x3e\n    currentVersion: semver.clean(process.version),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ package.json中定义的node版本的范围 \x3c\/span\x3e\n    versionRequirement: packageConfig.engines.node\n  }\n]\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于 which npm\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (shell.which(\x3cspan class=\x22hljs-string\x22\x3e\x27npm\x27\x3c\/span\x3e)) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果npm命令存在的话\x3c\/span\x3e\n  versionRequirements.push({\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27npm\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查npm的版本 =\x26gt; 5.4.2\x3c\/span\x3e\n    currentVersion: exec(\x3cspan class=\x22hljs-string\x22\x3e\x27npm --version\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ package.json中定义的npm版本\x3c\/span\x3e\n    versionRequirement: packageConfig.engines.npm\n  })\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e warnings = []\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; versionRequirements.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mod = versionRequirements[i]\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ semver.satisfies()进行版本之间的比较\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果现有的npm或者node的版本比定义的版本低，则生成一段警告\x3c\/span\x3e\n      warnings.push(mod.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: \x27\x3c\/span\x3e \x2b\n        chalk.red(mod.currentVersion) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 should be \x27\x3c\/span\x3e \x2b\n        chalk.green(mod.versionRequirement)\n      )\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (warnings.length) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(chalk.yellow(\x3cspan class=\x22hljs-string\x22\x3e\x27To use this template, you must update following to modules:\x27\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log()\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; warnings.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e warning = warnings[i]\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27  \x27\x3c\/span\x3e \x2b warning)\n    }\n\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 退出程序\x3c\/span\x3e\n    process.exit(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\n\x3ccode\x3ebuild\/build.js\x3c\/code\x3e: build项目\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\/\/ 检查npm和node的版本\nrequire(\x27.\/check-versions\x27)()\n\n\/\/ 设置环境变量NODE_ENV的值是production\nprocess.env.NODE_ENV = \x27production\x27\n\n\/\/ 终端的spinner\nconst ora = require(\x27ora\x27)\n\/\/ node.js版本的rm -rf\nconst rm = require(\x27rimraf\x27)\n\/\/ 引入path模块\nconst path = require(\x27path\x27)\n\/\/ 引入显示终端颜色模块\nconst chalk = require(\x27chalk\x27)\n\/\/ 引入webpack模块\nconst webpack = require(\x27webpack\x27)\n\/\/ 引入基本的配置文件\nconst config = require(\x27..\/config\x27)\n\/\/ 引入webpack在production环境下的配置文件\nconst webpackConfig = require(\x27.\/webpack.prod.conf\x27)\n\n\/\/ \nconst spinner = ora(\x27building for production...\x27)\nspinner.start()\n\n\/\/ 删除打包目标目录下的文件\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =\x3e {\n  if (err) throw err\n  \/\/ 进行打包\n  webpack(webpackConfig, (err, stats) =\x3e {\n    \/\/ 打包完成\n    spinner.stop()\n    if (err) throw err\n    \/\/ 输出打包的状态\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false,\n      chunks: false,\n      chunkModules: false\n    }) \x2b \x27\\n\\n\x27)\n\n    \/\/ 如果打包出现错误\n    if (stats.hasErrors()) {\n      console.log(chalk.red(\x27  Build failed with errors.\\n\x27))\n      process.exit(1)\n    }\n\n    \/\/ 打包完成\n    console.log(chalk.cyan(\x27  Build complete.\\n\x27))\n    console.log(chalk.yellow(\n      \x27  Tip: built files are meant to be served over an HTTP server.\\n\x27 \x2b\n      \x27  Opening index.html over file:\/\/ won\\\x27t work.\\n\x27\n    ))\n  })\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查npm和node的版本\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/check-versions\x27\x3c\/span\x3e)()\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置环境变量NODE_ENV的值是production\x3c\/span\x3e\nprocess.env.NODE_ENV = \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 终端的spinner\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ora = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27ora\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ node.js版本的rm -rf\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rm = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rimraf\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入path模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入显示终端颜色模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chalk = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27chalk\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入基本的配置文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/config\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入webpack在production环境下的配置文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpackConfig = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.prod.conf\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e spinner = ora(\x3cspan class=\x22hljs-string\x22\x3e\x27building for production...\x27\x3c\/span\x3e)\nspinner.start()\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除打包目标目录下的文件\x3c\/span\x3e\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 进行打包\x3c\/span\x3e\n  webpack(webpackConfig, (err, stats) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打包完成\x3c\/span\x3e\n    spinner.stop()\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出打包的状态\x3c\/span\x3e\n    process.stdout.write(stats.toString({\n      \x3cspan class=\x22hljs-attr\x22\x3ecolors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3emodules\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3echunks\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3echunkModules\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\n\x27\x3c\/span\x3e)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果打包出现错误\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (stats.hasErrors()) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(chalk.red(\x3cspan class=\x22hljs-string\x22\x3e\x27  Build failed with errors.\\n\x27\x3c\/span\x3e))\n      process.exit(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打包完成\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(chalk.cyan(\x3cspan class=\x22hljs-string\x22\x3e\x27  Build complete.\\n\x27\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(chalk.yellow(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27  Tip: built files are meant to be served over an HTTP server.\\n\x27\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e\x27  Opening index.html over file:\/\/ won\\\x27t work.\\n\x27\x3c\/span\x3e\n    ))\n  })\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e拍砖，bingo?\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一字一句的搞懂vue-cli之vue webpack template配置</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012472099">https://segmentfault.com/a/1190000012472099</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9yporqko5x9/" target="_blank">https://alili.tech/archive/9yporqko5x9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>