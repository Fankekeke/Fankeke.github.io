<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="GraphQL vs. REST"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>GraphQL vs. REST | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ac44b38/",
				"appid": "1613049289050283", 
				"title": "GraphQL vs. REST | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/31cd5561/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c72de942/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&text=GraphQL%20vs.%20REST"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&text=GraphQL%20vs.%20REST"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&title=GraphQL%20vs.%20REST"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&is_video=false&description=GraphQL%20vs.%20REST"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=GraphQL%20vs.%20REST&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fac44b38%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&title=GraphQL%20vs.%20REST"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&title=GraphQL%20vs.%20REST"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&title=GraphQL%20vs.%20REST"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fac44b38%2f&title=GraphQL%20vs.%20REST"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">GraphQL vs. REST</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch3\x3e两种通过HTTP发送数据的方式：有什么区别？\x3c\/h3\x3e\n\x3cp\x3e通常情况下，GraphQL被视作一种革命性的对于API查询方式的思考，您可以发送查询，以便在一个请求中准确获取要查找的数据，而无需使用严格的服务器端定义。事实确实如此 - 当组织采用GraphQL时，它可以具有变革性，使前端和后端团队能够比以前更顺利地进行协作。 但实际上，这两种技术都涉及发送HTTP请求并接收一些结果，并且GraphQL包含许多内置的REST模型元素。\x3c\/p\x3e\n\x3cp\x3e那么技术层面上真正发生了什么？ 这两个API范例有什么相似之处和不同之处？ 本文末尾的声明是，GraphQL和REST其实没有太大的不同，但是GraphQL有一些小的改变，这对开发者构建和使用API的体验产生了很大的影响。\x3c\/p\x3e\n\x3cp\x3e因此，让我们直接进入。我们将定义一些API属性，然后讨论GraphQL和REST如何处理它们。\x3c\/p\x3e\n\x3ch3\x3e资源\x3c\/h3\x3e\n\x3cp\x3eREST的核心思想是资源。 每个资源都由一个URL标识，并通过向该URL发送GET请求来检索该资源。 你可能会得到一个JSON响应，因为这是大多数API现在使用的。 所以它看起来像这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e\x3cspan class=\x22hljs-builtin-name\x22\x3eGET\x3c\/span\x3e \/books\/1\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs json\x22\x3e{  \x3cspan class=\x22hljs-attr\x22\x3e\x22title\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Black Hole Blues\x22\x3c\/span\x3e,  \x3cspan class=\x22hljs-attr\x22\x3e\x22author\x22\x3c\/span\x3e: {     \x3cspan class=\x22hljs-attr\x22\x3e\x22firstName\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Janna\x22\x3c\/span\x3e,    \x3cspan class=\x22hljs-attr\x22\x3e\x22lastName\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Levin\x22\x3c\/span\x3e  }  \/\/ ... more fields here}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eNote: 在上面的示例中，一些REST API会将“author”作为单独的资源返回.\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e在REST中需要注意的一点是，资源的类型或形状以及您获取资源的方式是耦合的。 当您在REST文档中讨论上述内容时，您可能会将其称为“book endpoint”.\x3c\/p\x3e\n\x3cp\x3eGraphQL在这方面完全不同，因为在GraphQL中，这两个概念是完全分离的。 在您的模式中，您可能有Book和Author类型：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eBook\x3c\/span\x3e {  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e  title: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e  published: \x3cspan class=\x22hljs-type\x22\x3eDate\x3c\/span\x3e  price: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e  author: \x3cspan class=\x22hljs-type\x22\x3eAuthor\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eAuthor\x3c\/span\x3e {  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e  firstName: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e  lastName: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e  books: [\x3cspan class=\x22hljs-type\x22\x3eBook\x3c\/span\x3e]}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e请注意，我们所描述的各种数据可用，但这种描述不会告诉你任何关于如何在客户端获取这些对象。 这是REST和GraphQL的核心区别 - 特定资源的描述与您检索它的方式不相关。\x3c\/p\x3e\n\x3cp\x3e为了能够实际访问特定的book或author，我们需要在我们的模式中创建一个Query类型：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eQuery\x3c\/span\x3e {  book(id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eBook\x3c\/span\x3e  author(id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eAuthor\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，我们可以发送类似于上面的REST请求的请求，但是这次使用GraphQL：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3eGET \/graphql?query={ book(id: \x3cspan class=\x22hljs-string\x22\x3e\x221\x22\x3c\/span\x3e) { title, author { firstName } } }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs json\x22\x3e{  \x3cspan class=\x22hljs-attr\x22\x3e\x22title\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Black Hole Blues\x22\x3c\/span\x3e,  \x3cspan class=\x22hljs-attr\x22\x3e\x22author\x22\x3c\/span\x3e: {    \x3cspan class=\x22hljs-attr\x22\x3e\x22firstName\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Janna\x22\x3c\/span\x3e,  }}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e很好，现在我们到了某一步！ 我们可以立即看到有关GraphQL的一些与REST完全不同的内容，即使两者都可以通过URL请求，并且两者都可以返回相同形式的JSON响应。\x3c\/p\x3e\n\x3cp\x3e首先，我们可以看到带有GraphQL查询的URL指定了我们要求的资源以及我们关心的是哪些字段。 另外，API的使用者决定，而不是服务器作者为我们决定需要包含相关author资源。\x3c\/p\x3e\n\x3cp\x3e但最重要的是，资源的标识，book和author的概念，并没有与它们被获取的方式相联系。 我们可以通过许多不同类型的查询以及不同的字段来检索相同的Book。\x3c\/p\x3e\n\x3ch4\x3e结论\x3c\/h4\x3e\n\x3cp\x3e我们已经确定了一些相似之处和差异：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e相同点:\x3c\/strong\x3e 两者都有资源的概念，并可以为这些资源指定ID。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e相同点:\x3c\/strong\x3e 两者都可以通过HTTP GET请求获取URL。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e相同点:\x3c\/strong\x3e 两者都可以在请求中返回JSON数据。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在REST中，您调用的端点是该对象的标识。 在GraphQL中，标识与获取它的方式是分开的.\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在REST中，资源的形状和大小由服务器决定。 在GraphQL中，服务器声明哪些资源可用，客户端询问它需要什么。。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e好的，如果你已经使用了非常基础的GraphQL和\/或REST， 如果你之前没有使用过GraphQL，你可以在Launchpad里面玩一玩 \x3ca href=\x22https:\/\/launchpad.graphql.com\/1jzxrj179\x22\x3ean example similar to the above\x3c\/a\x3e ，Launchpad是一款用于在您的浏览器中构建和探索GraphQL示例的工具。\x3c\/p\x3e\n\x3ch3\x3eURL路由与GraphQL架构\x3c\/h3\x3e\n\x3cp\x3e如果API不可预测，则该API无用。 当你使用一个API时，你通常将它作为某个程序的一部分来执行，并且该程序需要知道它可以调用的内容以及它应该期望得到的结果，以便它可以运行得出结果。\x3c\/p\x3e\n\x3cp\x3e因此，API中最重要的部分之一是对可访问内容的描述。 这是您在阅读API文档时学习的内容，以及使用Graphql自检和Rag API架构系统（如Swagger）时，可以通过编程方式检查此信息。\x3c\/p\x3e\n\x3cp\x3e在当今的REST API中，API通常被描述为一个端点列表：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elixir\x22\x3eGET \/books\/\x3cspan class=\x22hljs-symbol\x22\x3e:idGET\x3c\/span\x3e \/authors\/\x3cspan class=\x22hljs-symbol\x22\x3e:idGET\x3c\/span\x3e \/books\/\x3cspan class=\x22hljs-symbol\x22\x3e:id\/commentsPOST\x3c\/span\x3e \/books\/\x3cspan class=\x22hljs-symbol\x22\x3e:id\/comments\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e所以你可以说API的“形状”是线性的 - 有一系列你可以访问的东西。 当您检索数据或保存某些内容时，首先要问的问题是“我应该调用哪个端”？\x3c\/p\x3e\n\x3cp\x3e在GraphQL中，如上所述，您不使用URL来标识API中可用的内容。 相反，您使用GraphQL模式：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eQuery\x3c\/span\x3e {  book(id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eBook\x3c\/span\x3e  author(id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eAuthor\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMutation\x3c\/span\x3e {  addComment(input: \x3cspan class=\x22hljs-type\x22\x3eAddCommentInput\x3c\/span\x3e): \x3cspan class=\x22hljs-type\x22\x3eComment\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eBook\x3c\/span\x3e { ... }\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eAuthor\x3c\/span\x3e { ... }\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eComment\x3c\/span\x3e { ... }input \x3cspan class=\x22hljs-type\x22\x3eAddCommentInput\x3c\/span\x3e { ... }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e与类似数据集的REST路由相比，这里有一些有趣的地方。 首先，不是将一个不同的HTTP动词发送到相同的URL来区分读取和写入，而是使用不同的 \x3cem\x3einitial type\x3c\/em\x3e --- Mutation vs. Query。 在GraphQL文档中，您可以选择使用关键字发送哪种类型的操作：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3equery { ... }mutation { ... }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3e有关查询语言的所有细节，请阅读我之前的文章,\x3c\/em\x3e \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/the-anatomy-of-a-graphql-query-6dffa9e9e747\x22\x3e\x3cem\x3e“GraphQL查询的解析”\x3c\/em\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e你可以看到Query类型的字段与我们上面的REST路由很好地匹配。 这是因为这种特殊类型是我们数据的入口点，所以这是GraphQL中与端点URL最相同的概念。\x3c\/p\x3e\n\x3cp\x3e您从GraphQL API获取初始资源的方式与REST非常相似 - 您传递了一个名称和一些参数 - 但主要区别在于您可以从那里开始。 在GraphQL中，您可以发送一个复杂查询，根据模式中定义的关系获取其他数据，但在REST中，您必须通过多个请求来完成此操作，将相关数据构建到初始响应中，或者在 修改响应的URL。\x3c\/p\x3e\n\x3ch4\x3e结论\x3c\/h4\x3e\n\x3cp\x3e在REST中，可访问数据的空间被描述为一个线性的端点列表，在GraphQL中它是一个包含关系的模式。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e相同点:\x3c\/strong\x3e REST API中的端点列表与GraphQL API中Query和Mutation类型的字段列表类似。 它们都是数据的入口点。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e相同点:\x3c\/strong\x3e 这两种方法都可以区分API请求是要读取数据还是写入数据。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在GraphQL中，您可以在单个请求中，按照模式中定义的关系从入口点遍历相关数据。 在REST中，您必须调用多个端点才能获取相关资源。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e在GraphQL中，Query类型的字段和任何其他类型的字段之间没有区别，只是查询的根目录只能访问查询类型。 例如，您可以在查询的任何字段中拥有参数。 在REST中，没有嵌套URL之类的概念。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在REST中，通过将HTTP动词从GET更改为POST等其他内容来指定写入。 在GraphQL中，您可以更改查询中的关键字。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e由于上述相似性列表中的第一点，人们经常开始将Query类型的字段称为GraphQL“端点”或“查询”。 尽管这是一个合理的比较，但它可能会导致误导性的观点，即查询类型与其他类型显着不同，而事实并非如此。\x3c\/p\x3e\n\x3ch3\x3e路由处理程序与解析程序\x3c\/h3\x3e\n\x3cp\x3e那么当你实际调用API时会发生什么？ 那么，通常它会在接收请求的服务器上执行一些代码。 该代码可以执行计算，从数据库加载数据，调用不同的API，或者真的做任何事情。 整个想法是你不需要从外面知道它在做什么。 但是REST和GraphQL都有相当标准的方法来实现该API的内部，并且将它们进行比较以了解这些技术是如何不同的。\x3c\/p\x3e\n\x3cp\x3e在这个比较中，我将使用JavaScript代码，因为这是我最熟悉的，但是当然，您可以在几乎任何编程语言中实现REST和GraphQL API。 我也会跳过设置服务器所需的任何样板文件，因为这对概念并不重要。\x3c\/p\x3e\n\x3cp\x3e让我们来看一下hello world中的一个快速示例，一个用于Node的流行API库：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs livecodeserver\x22\x3eapp.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\/hello\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eres\x3c\/span\x3e) {\x3c\/span\x3e\n  res.\x3cspan class=\x22hljs-built_in\x22\x3esend\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这里你看到我们已经创建了一个返回字符串\x27Hello World！\x27的\/hello端点。 从这个例子中，我们可以看到REST API服务器中HTTP请求的生命周期：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e服务器收到请求并检索HTTP动词（本例中为GET）和URL路径\x3c\/li\x3e\n\x3cli\x3eAPI库将动词和路径与由服务器代码注册的函数进行匹配\x3c\/li\x3e\n\x3cli\x3e该函数执行一次，并返回一个结果\x3c\/li\x3e\n\x3cli\x3eAPI库序列化结果，添加适当的响应代码和标题，并将其发送回客户端\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eGraphQL的工作方式非常类似，也是相同的\x3ca href=\x22https:\/\/launchpad.graphql.com\/new\x22\x3ehello world example\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst resolvers = {  Query: {    hello: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Hello world!\x27\x3c\/span\x3e;\n},  },};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如你所看到的，我们不是为某个特定的URL提供一个函数，而是提供了一个匹配某个类型的特定字段的函数，在这种情况下，这个函数是Query类型的hello字段。 在GraphQL中，实现字段的这个函数被称为 \x3cstrong\x3e解析器\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e为了发出请求，我们需要一个查询：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3e\x3cspan class=\x22hljs-class\x22\x3equery \x3c\/span\x3e{  hello}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e因此，当我们的服务器收到一个GraphQL请求时会发生什么情况：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e服务器接收请求并检索GraphQL查询 \x3c\/li\x3e\n\x3cli\x3e遍历查询，并为每个字段调用适当的解析器。 在这种情况下，只有一个字段，你好，它在查询类型\x3c\/li\x3e\n\x3cli\x3e函数被调用，并返回一个结果\x3c\/li\x3e\n\x3cli\x3eGraphQL库和服务器将结果附加到与查询形状相匹配的响应\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以你会接收到：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs json\x22\x3e{ \x3cspan class=\x22hljs-attr\x22\x3e\x22hello\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Hello, world!\x22\x3c\/span\x3e }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e但是这里有一个技巧，我们实际上可以调用两次这个Query！\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\x3cspan class=\x22hljs-section\x22\x3equery\x3c\/span\x3e {  \x3cspan class=\x22hljs-attribute\x22\x3ehello\x3c\/span\x3e  secondHello: hello}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这种情况下，同样的生命周期发生在上面，但由于我们使用别名请求了两次相同的字段，所以hello解析器实际上称为\x3cem\x3etwice\x3c\/em\x3e。 这显然是一个人为的例子，但重点是可以在一个请求中执行多个字段，并且可以在查询中的不同点处多次调用同一个字段。\x3c\/p\x3e\n\x3cp\x3e没有“嵌套”解析器的例子，这将是不完整的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clojure\x22\x3e{  Query: {    author: (\x3cspan class=\x22hljs-name\x22\x3eroot\x3c\/span\x3e, { id }) =\x26gt; find(\x3cspan class=\x22hljs-name\x22\x3eauthors\x3c\/span\x3e, { id: id }),  },  Author: {    posts: (\x3cspan class=\x22hljs-name\x22\x3eauthor\x3c\/span\x3e) =\x26gt; filter(\x3cspan class=\x22hljs-name\x22\x3eposts\x3c\/span\x3e, { authorId: author.id }),  },}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这些解析器将能够完成如下查询：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3equery {  author(id: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {    firstName    posts {      title    }  }}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e所以即使解析器的集合实际上是平坦的，因为它们被附加到各种类型，您可以将它们构建为嵌套查询。在帖子中阅读更多关于GraphQL执行如何工作的信息 \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/graphql-explained-5844742f195e\x22\x3e“GraphQL 解释”\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/launchpad.graphql.com\/1jzxrj179\x22\x3e\x3cem\x3e查看完整的示例并运行不同的查询来测试！\x3c\/em\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01eb01da6d812f51e8.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e结论\x3c\/h4\x3e\n\x3cp\x3e在这一天结束时，REST和GraphQL API都是通过网络调用功能的奇特方式。 如果您熟悉构建REST API，那么实施GraphQL API不会有太大的不同。 但是GraphQL有很大的优势，因为它可以让你调用几个相关的函数而不需要多次往返。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e相同:\x3c\/strong\x3e REST中的端点和GraphQL中的字段最终都会调用服务器上的函数。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e相同:\x3c\/strong\x3e REST和GraphQL通常都依赖于框架和库来处理基本的联网样板。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在REST中，每个请求通常只调用一个路由处理函数。 在GraphQL中，一个查询可以调用许多解析器来构造具有多个资源的嵌套响应。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e不同:\x3c\/strong\x3e 在REST中，您自己构建响应的形状。 在GraphQL中，响应的形状由GraphQL执行库构建，以匹配查询的形状。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e从本质上讲，您可以将GraphQL想象成一个在一个请求中调用多个嵌套端点的系统。 几乎就像一个多路复用的REST。\x3c\/p\x3e\n\x3ch3\x3e所有的这些都意味着什么呢？\x3c\/h3\x3e\n\x3cp\x3e在这篇特别的文章中，我们没有太多空间可以参与。 例如，对象标识，超媒体或高速缓存。 也许这将是以后的一个话题。 但是我希望你们同意，当你看一看基本的知识时，REST和GraphQL正在使用基本相似的概念。\x3c\/p\x3e\n\x3cp\x3e我认为GraphQL有一些差异。 特别是，我认为能够将您的API作为一组小的解析器函数实现是非常酷的，然后有能力发送一个复杂的查询，以可预测的方式一次检索多个资源。 这节省了API实现者不必创建具有特定形状的多个端点，并且使得API消费者能够避免获取他们不需要的额外数据。\x3c\/p\x3e\n\x3cp\x3e另一方面，GraphQL没有REST那么多的工具和集成。 例如，您无法像使用REST结果一样轻松地缓存使用HTTP缓存的GraphQL结果。 但社区正在努力改善工具和基础设施。 例如，您可以使用\x3ca href=\x22http:\/\/www.apollographql.com\/client\x22\x3eApollo Client\x3c\/a\x3e和\x3ca href=\x22https:\/\/facebook.github.io\/relay\/\x22\x3eRelay\x3c\/a\x3e在您的前端缓存GraphQL结果，最近也可以在服务器上使用\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/introducing-apollo-engine-insights-error-reporting-and-caching-for-graphql-6a55147f63fc\x22\x3eApollo Engine\x3c\/a\x3e.缓存GraphQL结果。\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/graphql-vs-rest">https://www.zcfy.cc/article/graphql-vs-rest</a> 原文标题: GraphQL vs. REST 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/ac44b38/" target="_blank">https://alili.tech/archive/ac44b38/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>