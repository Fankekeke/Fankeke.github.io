<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="精读《async/await 是把双刃剑》"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>精读《async/await 是把双刃剑》 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/arpkyjshflo/",
				"appid": "1613049289050283", 
				"title": "精读《async/await 是把双刃剑》 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-01T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9k7wsc6yswa/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/x4smeyuppo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&text=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&text=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&title=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&is_video=false&description=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&title=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&title=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&title=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2farpkyjshflo%2f&title=%e7%b2%be%e8%af%bb%e3%80%8aasync%2fawait%20%e6%98%af%e6%8a%8a%e5%8f%8c%e5%88%83%e5%89%91%e3%80%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">精读《async/await 是把双刃剑》</h1><div class="meta"><div class="postdate"><time datetime="2018-12-01" itemprop="datePublished">2018-12-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e本周精读内容是 \x3ca href=\x22https:\/\/medium.freecodecamp.org\/avoiding-the-async-await-hell-c77a0fb71c4c\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《逃离 async\/await 地狱》\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1 引言\x3c\/h2\x3e\n\x3cp\x3e终于，async\/await 也被吐槽了。Aditya Agarwal 认为 async\/await 语法让我们陷入了新的麻烦之中。\x3c\/p\x3e\n\x3cp\x3e其实，笔者也早就觉得哪儿不对劲了，终于有个人把实话说了出来，async\/await 可能会带来麻烦。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2 概述\x3c\/h2\x3e\n\x3cp\x3e下面是随处可见的现代化前端代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async () =\x3e {\n  const pizzaData = await getPizzaData(); \/\/ async call\n  const drinkData = await getDrinkData(); \/\/ async call\n  const chosenPizza = choosePizza(); \/\/ sync call\n  const chosenDrink = chooseDrink(); \/\/ sync call\n  await addPizzaToCart(chosenPizza); \/\/ async call\n  await addDrinkToCart(chosenDrink); \/\/ async call\n  orderItems(); \/\/ async call\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pizzaData = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getPizzaData(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e drinkData = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getDrinkData(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chosenPizza = choosePizza(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sync call\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chosenDrink = chooseDrink(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sync call\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e addPizzaToCart(chosenPizza); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e addDrinkToCart(chosenDrink); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n  orderItems(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eawait 语法本身没有问题，有时候可能是使用者用错了。当 \x3ccode\x3epizzaData\x3c\/code\x3e 与 \x3ccode\x3edrinkData\x3c\/code\x3e 之间没有依赖时，顺序的 await 会最多让执行时间增加一倍的 \x3ccode\x3egetPizzaData\x3c\/code\x3e 函数时间，因为 \x3ccode\x3egetPizzaData\x3c\/code\x3e 与 \x3ccode\x3egetDrinkData\x3c\/code\x3e 应该并行执行。\x3c\/p\x3e\n\x3cp\x3e回到我们吐槽的回调地狱，虽然代码比较丑，带起码两行回调代码并不会带来阻塞。\x3c\/p\x3e\n\x3cp\x3e看来语法的简化，带来了性能问题，而且直接影响到用户体验，是不是值得我们反思一下？\x3c\/p\x3e\n\x3cp\x3e正确的做法应该是先同时执行函数，再 await 返回值，这样可以并行执行异步函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async () =\x3e {\n  const pizzaPromise = selectPizza();\n  const drinkPromise = selectDrink();\n  await pizzaPromise;\n  await drinkPromise;\n  orderItems(); \/\/ async call\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pizzaPromise = selectPizza();\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e drinkPromise = selectDrink();\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e pizzaPromise;\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e drinkPromise;\n  orderItems(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者使用 \x3ccode\x3ePromise.all\x3c\/code\x3e 可以让代码更可读：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async () =\x3e {\n  Promise.all([selectPizza(), selectDrink()]).then(orderItems); \/\/ async call\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([selectPizza(), selectDrink()]).then(orderItems); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async call\x3c\/span\x3e\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看来不要随意的 await，它很可能让你代码性能降低。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3 精读\x3c\/h2\x3e\n\x3cp\x3e仔细思考为什么 async\/await 会被滥用，笔者认为是它的功能比较反直觉导致的。\x3c\/p\x3e\n\x3cp\x3e首先 async\/await 真的是语法糖，功能也仅是让代码写的舒服一些。先不看它的语法或者特性，仅从语法糖三个字，就能看出它一定是局限了某些能力。\x3c\/p\x3e\n\x3cp\x3e举个例子，我们利用 html 标签封装了一个组件，带来了便利性的同时，其功能一定是 html 的子集。又比如，某个轮子哥觉得某个组件 api 太复杂，于是基于它封装了一个语法糖，我们多半可以认为这个便捷性是牺牲了部分功能换来的。\x3c\/p\x3e\n\x3cp\x3e功能完整度与使用便利度一直是相互博弈的，很多框架思想的不同开源版本，几乎都是把功能完整度与便利度按照不同比例混合的结果。\x3c\/p\x3e\n\x3cp\x3e那么回到 async\/await 它的解决的问题是回调地狱带来的灾难：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a(() =\x3e {\n  b(() =\x3e {\n    c();\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3ea(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  b(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    c();\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了减少嵌套结构太多对大脑造成的冲击，async\/await 决定这么写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22await a();\nawait b();\nawait c();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e a();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e b();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e c();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然层级上一致了，但逻辑上还是嵌套关系，这不是另一个程度上增加了大脑负担吗？而且这个转换还是隐形的，所以许多时候，我们倾向于忽略它，所以造成了语法糖的滥用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e理解语法糖\x3c\/h3\x3e\n\x3cp\x3e虽然要正确理解 async\/await 的真实效果比较反人类，但为了清爽的代码结构，以及防止写出低性能的代码，还是挺有必要认真理解 async\/await 带来的改变。\x3c\/p\x3e\n\x3cp\x3e首先 async\/await 只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了。\x3c\/p\x3e\n\x3cp\x3e比如两对回调：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a(() =\x3e {\n  b();\n});\n\nc(() =\x3e {\n  d();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3ea(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  b();\n});\n\nc(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  d();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果写成下面的方式，虽然一定能保证功能一致，但变成了最低效的执行方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22await a();\nawait b();\nawait c();\nawait d();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e a();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e b();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e c();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e d();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为翻译成回调，就变成了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a(() =\x3e {\n  b(() =\x3e {\n    c(() =\x3e {\n      d();\n    });\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3ea(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  b(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    c(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      d();\n    });\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而我们发现，原始代码中，函数 \x3ccode\x3ec\x3c\/code\x3e 可以与 \x3ccode\x3ea\x3c\/code\x3e 同时执行，但 async\/await 语法会让我们倾向于在 \x3ccode\x3eb\x3c\/code\x3e 执行完后，再执行 \x3ccode\x3ec\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e所以当我们意识到这一点，可以优化一下性能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const resA = a();\nconst resC = c();\n\nawait resA;\nb();\nawait resC;\nd();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resA = a();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resC = c();\n\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e resA;\nb();\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e resC;\nd();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但其实这个逻辑也无法达到回调的效果，虽然 \x3ccode\x3ea\x3c\/code\x3e 与 \x3ccode\x3ec\x3c\/code\x3e 同时执行了，但 \x3ccode\x3ed\x3c\/code\x3e 原本只要等待 \x3ccode\x3ec\x3c\/code\x3e 执行完，现在如果 \x3ccode\x3ea\x3c\/code\x3e 执行时间比 \x3ccode\x3ec\x3c\/code\x3e 长，就变成了:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a(() =\x3e {\n  d();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3ea(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  d();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看来只有完全隔离成两个函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async () =\x3e {\n  await a();\n  b();\n})();\n\n(async () =\x3e {\n  await c();\n  d();\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e a();\n  b();\n})();\n\n\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e c(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e);\n  d(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e);\n}\x3c\/span\x3e)\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者利用 \x3ccode\x3ePromise.all\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function ab() {\n  await a();\n  b();\n}\n\nasync function cd() {\n  await c();\n  d();\n}\n\nPromise.all([ab(), cd()]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eab\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e a();\n  b();\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e c();\n  d();\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([ab(), cd()]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这就是我想表达的可怕之处。回调方式这么简单的过程式代码，换成 async\/await 居然写完还要反思一下，再反推着去优化性能，这简直比回调地狱还要可怕。\x3c\/p\x3e\n\x3cp\x3e而且大部分场景代码是非常复杂的，同步与 await 混杂在一起，想捋清楚其中的脉络，并正确优化性能往往是很困难的。但是我们为什么要自己挖坑再填坑呢？很多时候还会导致忘了填。\x3c\/p\x3e\n\x3cp\x3e原文作者给出了 \x3ccode\x3ePromise.all\x3c\/code\x3e 的方式简化逻辑，但笔者认为，不要一昧追求 async\/await 语法，在必要情况下适当使用回调，是可以增加代码可读性的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e4 总结\x3c\/h2\x3e\n\x3cp\x3easync\/await 回调地狱提醒着我们，不要过渡依赖新特性，否则可能带来的代码执行效率的下降，进而影响到用户体验。同时，笔者认为，也不要过渡利用新特性修复新特性带来的问题，这样反而导致代码可读性下降。\x3c\/p\x3e\n\x3cp\x3e当我翻开 redux 刚火起来那段时期的老代码，看到了许多过渡抽象、为了用而用的代码，硬是把两行代码能写完的逻辑，拆到了 3 个文件，分散在 6 行不同位置，我只好用字符串搜索的方式查找线索，最后发现这个抽象代码整个项目仅用了一次。\x3c\/p\x3e\n\x3cp\x3e写出这种代码的可能性只有一个，就是在精神麻木的情况下，一口气喝完了 redux 提供的全部鸡汤。\x3c\/p\x3e\n\x3cp\x3e就像 async\/await 地狱一样，看到这种 redux 代码，我觉得远不如所谓没跟上时代的老前端写出的 jquery 代码。\x3c\/p\x3e\n\x3cp\x3e决定代码质量的是思维，而非框架或语法，async\/await 虽好，但也要适度哦。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e5 更多讨论\x3c\/h2\x3e\n\x3cblockquote\x3e讨论地址是：\x3ca href=\x22https:\/\/github.com\/dt-fe\/weekly\/issues\/82\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e精读《逃离 async\/await 地狱》 · Issue #82 · dt-fe\/weekly\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e如果你想参与讨论，请\x3ca href=\x22https:\/\/github.com\/dt-fe\/weekly\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击这里\x3c\/a\x3e，每周都有新的主题，周末或周一发布。\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>精读《async/await 是把双刃剑》</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014753495">https://segmentfault.com/a/1190000014753495</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/arpkyjshflo/" target="_blank">https://alili.tech/archive/arpkyjshflo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>