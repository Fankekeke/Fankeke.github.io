<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="由React Router引起的组件重复渲染谈Route的使用姿势"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>由React Router引起的组件重复渲染谈Route的使用姿势 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/b6rib2ef08p/",
				"appid": "1613049289050283", 
				"title": "由React Router引起的组件重复渲染谈Route的使用姿势 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-25T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4mfu8fkswc9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/r9pa4rwmbu9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&text=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&text=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&title=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&is_video=false&description=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&title=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&title=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&title=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb6rib2ef08p%2f&title=%e7%94%b1React%20Router%e5%bc%95%e8%b5%b7%e7%9a%84%e7%bb%84%e4%bb%b6%e9%87%8d%e5%a4%8d%e6%b8%b2%e6%9f%93%e8%b0%88Route%e7%9a%84%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">由React Router引起的组件重复渲染谈Route的使用姿势</h1><div class="meta"><div class="postdate"><time datetime="2018-12-25" itemprop="datePublished">2018-12-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact Router 4 把\x3ccode\x3eRoute\x3c\/code\x3e当作普通的React组件，可以在任意组件内使用\x3ccode\x3eRoute\x3c\/code\x3e，而不再像之前的版本那样，必须在一个地方集中定义所有的\x3ccode\x3eRoute\x3c\/code\x3e。因此，使用React Router 4 的项目中，经常会有\x3ccode\x3eRoute\x3c\/code\x3e和其他组件出现在同一个组件内的情况。例如下面这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  render() {\n    const { isRequesting } = this.props;\n    return (\n      \x3cdiv\x3e\n        \x3cRouter\x3e\n          \x3cSwitch\x3e\n            \x3cRoute exact path=\x26quot;\/\x26quot; component={Home} \/\x3e\n            \x3cRoute path=\x26quot;\/login\x26quot; component={Login} \/\x3e\n            \x3cRoute path=\x26quot;\/home\x26quot; component={Home} \/\x3e\n          \x3c\/Switch\x3e\n        \x3c\/Router\x3e\n        {isRequesting  \x26amp;\x26amp; \x3cLoading \/\x3e}\n      \x3c\/div\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    const { isRequesting } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e exact path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHome\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/login\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eLogin\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/home\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHome\x3c\/span\x3e} \/\x26gt;\n          \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n        \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n        {isRequesting  \x26amp;\x26amp; \x26lt;\x3cspan class=\x22hljs-type\x22\x3eLoading\x3c\/span\x3e \/\x26gt;}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e页面加载效果组件\x3ccode\x3eLoading\x3c\/code\x3e和\x3ccode\x3eRoute\x3c\/code\x3e处于同一层级，这样，\x3ccode\x3eHome\x3c\/code\x3e、\x3ccode\x3eLogin\x3c\/code\x3e等页面组件都共用外层的Loading组件。当和Redux一起使用时，isRequesting会存储到Redux的store中，\x3ccode\x3eApp\x3c\/code\x3e会作为Redux中的容器组件（container components），从store中获取isRequesting。\x3ccode\x3eHome\x3c\/code\x3e、\x3ccode\x3eLogin\x3c\/code\x3e等页面根组件一般也会作为容器组件，从store中获取所需的state，进行组件的渲染。代码演化成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  render() {\n    const { isRequesting } = this.props;\n    return (\n      \x3cdiv\x3e\n        \x3cRouter\x3e\n          \x3cSwitch\x3e\n            \x3cRoute exact path=\x26quot;\/\x26quot; component={Home} \/\x3e\n            \x3cRoute path=\x26quot;\/login\x26quot; component={Login} \/\x3e\n            \x3cRoute path=\x26quot;\/home\x26quot; component={Home} \/\x3e\n          \x3c\/Switch\x3e\n        \x3c\/Router\x3e\n        {isRequesting  \x26amp;\x26amp; \x3cLoading \/\x3e}\n      \x3c\/div\x3e\n    );\n  }\n}\n\nconst mapStateToProps = (state, props) =\x3e {\n  return {\n    isRequesting: getRequestingState(state)\n  };\n};\n\nexport default connect(mapStateToProps)(App);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    const { isRequesting } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e exact path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHome\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/login\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eLogin\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/home\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHome\x3c\/span\x3e} \/\x26gt;\n          \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n        \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n        {isRequesting  \x26amp;\x26amp; \x26lt;\x3cspan class=\x22hljs-type\x22\x3eLoading\x3c\/span\x3e \/\x26gt;}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\nconst mapStateToProps = (state, props) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    isRequesting: getRequestingState(state)\n  };\n};\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e connect(mapStateToProps)(\x3cspan class=\x22hljs-type\x22\x3eApp\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Home extends Component {\n  componentDidMount() {\n    this.props.fetchHomeDataFromServer();\n  }\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n       {homeData}\n      \x3c\/div\x3e\n    );\n  }\n}\n\nconst mapStateToProps = (state, props) =\x3e {\n  return {\n    homeData: getHomeData(state)\n  };\n};\n\nconst mapDispatchToProps = dispatch =\x3e {\n  return {\n    ...bindActionCreators(homeActions, dispatch)\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Home);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.fetchHomeDataFromServer();\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n       {homeData}\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    );\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate, props\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3ehomeData\x3c\/span\x3e: getHomeData(state)\n  };\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapDispatchToProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edispatch\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    ...bindActionCreators(homeActions, dispatch)\n  };\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e connect(mapStateToProps, mapDispatchToProps)(Home);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eHome\x3c\/code\x3e组件挂载后，调用\x3ccode\x3ethis.props.fetchHomeDataFromServer()\x3c\/code\x3e这个异步action从服务器中获取页面所需数据。\x3ccode\x3efetchHomeDataFromServer\x3c\/code\x3e一般的结构会是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fetchHomeDataFromServer = () =\x3e {\n  return (dispatch, getState) =\x3e {  \n    dispatch(REQUEST_BEGIN);\n    return fetchHomeData().then(data =\x3e {\n      dispatch(REQUEST_END);   \n      dispatch(setHomeData(data));\n    });    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fetchHomeDataFromServer = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edispatch, getState\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {  \n    dispatch(REQUEST_BEGIN);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetchHomeData().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      dispatch(REQUEST_END);   \n      dispatch(setHomeData(data));\n    });    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，在\x3ccode\x3edispatch\x3c\/code\x3e \x3ccode\x3esetHomeData(data)\x3c\/code\x3e前，会\x3ccode\x3edispatch\x3c\/code\x3e另外两个action改变isRequesting，进而控制\x3ccode\x3eApp\x3c\/code\x3e中\x3ccode\x3eLoading\x3c\/code\x3e的显示和隐藏。正常来说，isRequesting的改变应该只会导致\x3ccode\x3eApp\x3c\/code\x3e组件重新render，而不会影响\x3ccode\x3eHome\x3c\/code\x3e组件。因为经过Redux connect后的\x3ccode\x3eHome\x3c\/code\x3e组件，在更新阶段，会使用浅比较（shallow comparison）判断接收到的props是否发生改变，如果没有改变，组件是不会重新render的。\x3ccode\x3eHome\x3c\/code\x3e组件并不依赖isRequesting，render方法理应不被触发。\x3c\/p\x3e\n\x3cp\x3e但实际的结果是，每一次\x3ccode\x3eApp\x3c\/code\x3e的重新render，都伴随着\x3ccode\x3eHome\x3c\/code\x3e的重新render。Redux浅比较做的优化都被浪费掉了!\x3c\/p\x3e\n\x3cp\x3e究竟是什么原因导致的呢？最后，我在React Router \x3ccode\x3eRoute\x3c\/code\x3e的源码中找到了罪魁祸首：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentWillReceiveProps(nextProps, nextContext) {\n    warning(\n      !(nextProps.location \x26amp;\x26amp; !this.props.location),\n      \x27\x3cRoute\x3e elements should not change from uncontrolled to controlled (or vice versa). You initially used no \x26quot;location\x26quot; prop and then provided one on a subsequent render.\x27\n    )\n\n    warning(\n      !(!nextProps.location \x26amp;\x26amp; this.props.location),\n      \x27\x3cRoute\x3e elements should not change from controlled to uncontrolled (or vice versa). You provided a \x26quot;location\x26quot; prop initially but omitted it on a subsequent render.\x27\n    )\n\n    \/\/ 注意这里，computeMatch每次返回的都是一个新对象，如此一来，每次Route更新，setState都会重新设置一个新的match对象\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    })\n  }\n\n  render() {\n    const { match } = this.state\n    const { children, component, render } = this.props\n    const { history, route, staticContext } = this.context.router\n    const location = this.props.location || route.location\n    \/\/ 注意这里，这是传递给Route中的组件的属性\n    const props = { match, location, history, staticContext }\n\n    if (component)\n      return match ? React.createElement(component, props) : null\n\n    if (render)\n      return match ? render(props) : null\n\n    if (typeof children === \x27function\x27)\n      return children(props)\n\n    if (children \x26amp;\x26amp; !isEmptyChildren(children))\n      return React.Children.only(children)\n\n    return null\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3ecomponentWillReceiveProps(nextProps, nextContext) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewarning\x3c\/span\x3e(\n      !(nextProps.location \x26amp;\x26amp; !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location),\n      \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;Route\x26gt; elements should not change from uncontrolled to controlled (or vice versa). You initially used no \x22location\x22 prop and then provided one on a subsequent render.\x27\x3c\/span\x3e\n    )\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewarning\x3c\/span\x3e(\n      !(!nextProps.location \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location),\n      \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;Route\x26gt; elements should not change from controlled to uncontrolled (or vice versa). You provided a \x22location\x22 prop initially but omitted it on a subsequent render.\x27\x3c\/span\x3e\n    )\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意这里，computeMatch每次返回的都是一个新对象，如此一来，每次Route更新，setState都会重新设置一个新的match对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      match: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.computeMatch(nextProps, nextContext.router)\n    })\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { match } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { children, component, render } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { history, route, staticContext } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e location = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location || route.location\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意这里，这是传递给Route中的组件的属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e props = { match, location, history, staticContext }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e match ? React.createElement(component, props) : \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (render)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e match ? render(props) : \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof children === \x27function\x27)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e children(props)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (children \x26amp;\x26amp; !isEmptyChildren(children))\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e React.Children.only(children)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eRoute\x3c\/code\x3e的\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e中，会调用\x3ccode\x3esetState\x3c\/code\x3e设置match，match由\x3ccode\x3ecomputeMatch\x3c\/code\x3e计算而来，\x3ccode\x3ecomputeMatch\x3c\/code\x3e每次都会返回一个新的对象。这样，每次\x3ccode\x3eRoute\x3c\/code\x3e更新（componentWillReceiveProps被调用），都将创建一个新的match，而这个match由会作为props传递给\x3ccode\x3eRoute\x3c\/code\x3e中定义的组件（这个例子中，也就是\x3ccode\x3eHome\x3c\/code\x3e）。于是，\x3ccode\x3eHome\x3c\/code\x3e组件在更新阶段，总会收到一个新的\x3ccode\x3ematch\x3c\/code\x3e属性，导致Redux的浅比较失败，进而触发组件的重新渲染。事实上，上面的情况中，\x3ccode\x3eRoute\x3c\/code\x3e传递给\x3ccode\x3eHome\x3c\/code\x3e的其他属性location、history、staticContext都没有改变，match虽然是一个新对象，但对象的内容并没有改变（一直处在同一页面，URL并没有发生变化，match的计算结果自然也没有变）。\x3c\/p\x3e\n\x3cp\x3e如果你认为这个问题只是和Redux一起使用时才会遇到，那就大错特错了。再举两个不使用Redux的场景：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eApp\x3c\/code\x3e结构基本不变，只是不再通过Redux获取isRequesting，而是作为组件自身的state维护。\x3ccode\x3eHome\x3c\/code\x3e继承自\x3ccode\x3eReact.PureComponent\x3c\/code\x3e，\x3ccode\x3eHome\x3c\/code\x3e通过\x3ccode\x3eApp\x3c\/code\x3e传递的回调函数，改变isRequesting，\x3ccode\x3eApp\x3c\/code\x3e重新render，由于同样的原因，\x3ccode\x3eHome\x3c\/code\x3e也会重新render。\x3ccode\x3eReact.PureComponent\x3c\/code\x3e的功效也浪费了。\x3c\/li\x3e\n\x3cli\x3e与Mobx结合使用，\x3ccode\x3eApp\x3c\/code\x3e和\x3ccode\x3eHome\x3c\/code\x3e组件通过\x3ccode\x3e@observer\x3c\/code\x3e修饰，\x3ccode\x3eApp\x3c\/code\x3e监听到isRequesting改变重新render，由于同样的原因，\x3ccode\x3eHome\x3c\/code\x3e组件也会重新render。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e一个\x3ccode\x3eRoute\x3c\/code\x3e的问题，竟然导致所有的状态管理库的优化工作都大打折扣！痛心！\x3c\/p\x3e\n\x3cp\x3e我已经在github上向React Router官方提了这个\x3ca href=\x22https:\/\/github.com\/ReactTraining\/react-router\/issues\/5738\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eissue\x3c\/a\x3e，希望能在\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e中先做一些简单的判断，再决定是否要重新\x3ccode\x3esetState\x3c\/code\x3e。但令人失望的是，这个issue很快就被一个Collaborator给close掉了。\x3c\/p\x3e\n\x3cp\x3e好吧，求人不如求己，自己找解决方案。\x3c\/p\x3e\n\x3cp\x3e几个思路：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e既然\x3ccode\x3eLoading\x3c\/code\x3e放在和\x3ccode\x3eRoute\x3c\/code\x3e同一层级的组件中会有这个问题，那么就把\x3ccode\x3eLoading\x3c\/code\x3e放到更低层级的组件内，\x3ccode\x3eHome\x3c\/code\x3e、\x3ccode\x3eLogin\x3c\/code\x3e中，大不了多引几次\x3ccode\x3eLoading\x3c\/code\x3e组件。但这个方法治标不治本，\x3ccode\x3eHome\x3c\/code\x3e组件内依然可能会定义其他\x3ccode\x3eRoute\x3c\/code\x3e，\x3ccode\x3eHome\x3c\/code\x3e依赖状态的更新，同样又会导致这些\x3ccode\x3eRoute\x3c\/code\x3e内组件的重新渲染。也就是说，只要在container components中使用了\x3ccode\x3eRoute\x3c\/code\x3e，这个问题就绕不开。但在React Router 4 \x3ccode\x3eRoute\x3c\/code\x3e的分布式使用方式下，container components中是不可能完全避免使用\x3ccode\x3eRoute\x3c\/code\x3e的。\x3c\/li\x3e\n\x3cli\x3e重写container components的\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e方法，方法可行，但每个组件重写一遍，心累。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e接着2的思路，通过创建一个高阶组件，在高阶组件内重写\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，如果\x3ccode\x3eRoute\x3c\/code\x3e传递的location属性没有发生变化（表示处于同一页面），那么就返回false。然后使用这个高阶组件包裹每一个要在\x3ccode\x3eRoute\x3c\/code\x3e中使用的组件。\x3c\/p\x3e\n\x3cp\x3e新建一个高阶组件\x3ccode\x3econnectRoute\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x26quot;react\x26quot;;\n\nexport default function connectRoute(WrappedComponent) {\n  return class extends React.Component {\n    shouldComponentUpdate(nextProps) {\n      return nextProps.location !== this.props.location;\n    }\n\n    render() {\n      return \x3cWrappedComponent {...this.props} \/\x3e;\n    }\n  };\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e from \x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e;\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e function connectRoute(\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    shouldComponentUpdate(nextProps) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nextProps.location !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location;\n    }\n\n    render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props} \/\x26gt;;\n    }\n  };\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用\x3ccode\x3econnectRoute\x3c\/code\x3e包裹\x3ccode\x3eHome\x3c\/code\x3e、\x3ccode\x3eLogin\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HomeWrapper = connectRoute(Home);\nconst LoginWrapper = connectRoute(Login);\n\nclass App extends Component {\n  render() {\n    const { isRequesting } = this.props;\n    return (\n      \x3cdiv\x3e\n        \x3cRouter\x3e\n          \x3cSwitch\x3e\n            \x3cRoute exact path=\x26quot;\/\x26quot; component={HomeWrapper} \/\x3e\n            \x3cRoute path=\x26quot;\/login\x26quot; component={LoginWrapper} \/\x3e\n            \x3cRoute path=\x26quot;\/home\x26quot; component={HomeWrapper} \/\x3e\n          \x3c\/Switch\x3e\n        \x3c\/Router\x3e\n        {isRequesting  \x26amp;\x26amp; \x3cLoading \/\x3e}\n      \x3c\/div\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3econst \x3cspan class=\x22hljs-type\x22\x3eHomeWrapper\x3c\/span\x3e = connectRoute(\x3cspan class=\x22hljs-type\x22\x3eHome\x3c\/span\x3e);\nconst \x3cspan class=\x22hljs-type\x22\x3eLoginWrapper\x3c\/span\x3e = connectRoute(\x3cspan class=\x22hljs-type\x22\x3eLogin\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    const { isRequesting } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e exact path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHomeWrapper\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/login\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eLoginWrapper\x3c\/span\x3e} \/\x26gt;\n            \x26lt;\x3cspan class=\x22hljs-type\x22\x3eRoute\x3c\/span\x3e path=\x3cspan class=\x22hljs-string\x22\x3e\x22\/home\x22\x3c\/span\x3e component={\x3cspan class=\x22hljs-type\x22\x3eHomeWrapper\x3c\/span\x3e} \/\x26gt;\n          \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eSwitch\x3c\/span\x3e\x26gt;\n        \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eRouter\x3c\/span\x3e\x26gt;\n        {isRequesting  \x26amp;\x26amp; \x26lt;\x3cspan class=\x22hljs-type\x22\x3eLoading\x3c\/span\x3e \/\x26gt;}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这样就一劳永逸的解决问题了。\x3c\/p\x3e\n\x3cp\x3e我们再来思考一种场景，如果\x3ccode\x3eApp\x3c\/code\x3e使用的状态同样会影响到\x3ccode\x3eRoute\x3c\/code\x3e的属性，比如\x3ccode\x3eisRequesting\x3c\/code\x3e为true时，第三个\x3ccode\x3eRoute\x3c\/code\x3e的path也会改变，假设变成\x3ccode\x3e\x26lt;Route path=\x22\/home\/fetching\x22 component={HomeWrapper} \/\x26gt;\x3c\/code\x3e，而\x3ccode\x3eHome\x3c\/code\x3e内部会用到\x3ccode\x3eRoute\x3c\/code\x3e传递的path（实际上是通过\x3ccode\x3ematch.path\x3c\/code\x3e获取）, 这时候就需要\x3ccode\x3eHome\x3c\/code\x3e组件重新render。 但因为高阶组件的\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e中我们只是根据location做判断，此时的location依然没有发生变化，导致\x3ccode\x3eHome\x3c\/code\x3e并不会重新渲染。这是一种很特殊的场景，但是想通过这种场景告诉大家，高阶组件\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e的判断条件需要根据实际业务场景做决策。绝大部分场景下，上面的高阶组件是足够使用。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eRoute\x3c\/code\x3e的使用姿势并不简单，且行且珍惜吧！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e欢迎关注我的公众号：老干部的大前端，领取21本大前端精选书籍！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4lGT?w=540\x26amp;h=193\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4lGT?w=540\x26amp;h=193\x22 alt=\x223808299627-5a93ba468b59a\x22 title=\x223808299627-5a93ba468b59a\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e​\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>由React Router引起的组件重复渲染谈Route的使用姿势</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012078328">https://segmentfault.com/a/1190000012078328</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/b6rib2ef08p/" target="_blank">https://alili.tech/archive/b6rib2ef08p/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>