<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Node.js 前端开发指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Node.js 前端开发指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/b821ddf1/",
				"appid": "1613049289050283", 
				"title": "Node.js 前端开发指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/b8f53d6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/f2555a/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&text=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&text=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&title=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&is_video=false&description=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&title=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&title=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&title=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb821ddf1%2f&title=Node.js%20%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Node.js 前端开发指南</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/\/\x22\x3e原文链接\x3c\/a\x3e \x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/about\x22\x3e关于作者\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e2018年6月21日出版\n​\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e本指南面向了解Javascript但尚未十分熟悉Node.js的前端开发人员。我这里不专注于语言本身 -- Node.js 使用 V8 引擎，所以和Google Chrome的解释器是一样的，这点您或许已经了解（但是，它也可以在不同的VM上运行，请参阅 \x3ca href=\x22https:\/\/github.com\/nodejs\/node-chakracore\x22\x3enode-chakracore\x3c\/a\x3e）\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#node-version\x22\x3eNode 版本\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#no-babel-is-needed\x22\x3e不需要Babel\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#callback-style\x22\x3e回调风格\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#event-loop\x22\x3e事件循环\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#event-emitters\x22\x3e事件发射器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#streams\x22\x3e流\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#module-system\x22\x3e模块系统\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#environment-variables\x22\x3e环境变量\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#putting-everything-together\x22\x3e综合运用\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blog.bloomca.me\/2018\/06\/21\/nodejs-guide-for-frontend-developers.html\/#conclusion\x22\x3e总结\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e​我们经常跟Node.js打交道，即使你是一名前端开发人员 -- \x3ca href=\x22https:\/\/docs.npmjs.com\/misc\/scripts\x22\x3enpm脚本\x3c\/a\x3e，webpack配置，gulp任务，\x3ca href=\x22https:\/\/webpack.js.org\/api\/node\/\x22\x3e程序打包\x3c\/a\x3e 或 \x3ca href=\x22https:\/\/karma-runner.github.io\/2.0\/dev\/public-api.html\x22\x3e运行测试\x3c\/a\x3e等。即使你真的不需要深入理解这些任务，但有时候你会感到困惑，会因为缺少Node.js的一些核心概念而以非常奇怪的方式来编码。熟悉Node.js之后，您还可以让某些原本需要手动操作的东西自动执行，让您可以更自信地查看服务器端代码，并​​编写更复杂的脚本。\n​\x3c\/p\x3e\n\x3ch3\x3eNode 版本\x3c\/h3\x3e\n\x3cp\x3eNode.js与客户端代码最大的区别在于您可以根据运行环境来决定，并且可以完全清楚它支持哪些特性 -- 您可以根据具体的需求和可用的服务器来选择使用哪个版本。\x3c\/p\x3e\n\x3cp\x3eNode.js有一个公开发布时间表，告诉我们奇数版本没有被长期支持。当前的LTS（long-term support）版本将被积极开发到2019年4月，然后2019年12月31日之前，通过更新关键代码进行维护。Node.js新版本正在积极开发，它们带来了许多新功能，以及安全性和性能方面的提升。这也许是使用当前活跃版本的一个好理由。然而，没有人真正强迫你，如果你不想这样做，使用旧版本也可以，等到您觉得时机合适再更新就行。\x3c\/p\x3e\n\x3cp\x3eNode.js被广泛应用于现代前端工具链 - 我们很难想象一个现代项目没有使用Node工具进行任何处理。因此，您可能已经熟悉nvm（node版本管理器），它允许你同时安装几个Node版本，为每个项目选择正确的版本。使用这种工具的原因在于，不同项目经常使用不同的Node版本，并且你不想永远保持它们同步，您只想保留编写和测试它们的环境。其它语言也有很多这样的工具，例如用于Python的virtualenv，用于Ruby的rbenv等等。\x3c\/p\x3e\n\x3ch3\x3e不需要Babel\x3c\/h3\x3e\n\x3cp\x3e由于您可以自由选择任何Node.js版本，所以您很有可能使用LTS版本。该版本在本文撰写时为8.11.3，几乎支持所有ECMAScript 2015的规范，除了尾递归。\x3c\/p\x3e\n\x3cp\x3e这意味着我们不需要Babel，除非您遇到一个非常旧的Node.js版本，需要转换JSX，或者需要其它前沿的转换器。在实践中，Babel并不是那么重要，所以您运行的代码可以和编写的代码相同，不需要任何编译器 -- 这个我们已经遗忘的客户端天才。\x3c\/p\x3e\n\x3cp\x3e我们也不需要webpack或browserify，那么我们就没有工具来重新加载我们的代码 -- 如果您在开发类似Web服务器的东西，您可以使用nodemon，在文件更改后来重新加载您的应用程序。\x3c\/p\x3e\n\x3cp\x3e而且因为我们不在任何地方传送代码，所以不需要缩小它 -- 省了一步：您只需原封不动地使用代码，真的很神奇！\x3c\/p\x3e\n\x3ch3\x3e回调风格\x3c\/h3\x3e\n\x3cp\x3e以前，Node.js中的异步函数接受带有签名\x3ccode\x3e（err，data）\x3c\/code\x3e的回调，其中第一个参数代表错误信息 - 如果它为null，则全部正确，否则您必须处理错误。这些处理程序会在操作完成，我们得到响应后调用。例如，让我们读取一个文件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3econst fs = require(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27myFile.js\x27\x3c\/span\x3e, (err, file) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n    console.error(\x3cspan class=\x22hljs-string\x22\x3e\x27There was an error reading file :(\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e process is a global object \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e Node\n   \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e https:\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3enodejs.org\x3cspan class=\x22hljs-regexp\x22\x3e\/api\/\x3c\/span\x3eprocess.html\x3cspan class=\x22hljs-comment\x22\x3e#process_process_exit_code\x3c\/span\x3e\n   process.\x3cspan class=\x22hljs-keyword\x22\x3eexit\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  }\n\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e something with file content\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们很快就发现，这种风格很难编写可读和可维护的代码，甚至造成回调地狱。后来，一种新的原生的异步处理方式 \x3ccode\x3ePromise\x3c\/code\x3e被引入了。它在ECMAScript 2015上标准化（是浏览器和Node.js运行时的全局对象）。近来，\x3ccode\x3easync \/ await\x3c\/code\x3e 在ECMAScript 2017中标准化了，Node.js 7.6\x2b 都支持这个规范，所以您可以在LTS版本中使用它。\x3c\/p\x3e\n\x3cp\x3e有了 \x3ccode\x3ePromise\x3c\/code\x3e，我们避免了“回调地狱”。但是，现在我们遇到的问题是旧代码和许多内置模块仍然使用回调的方式。将它们转换为 \x3ccode\x3ePromise\x3c\/code\x3e 并不是很难 -- 为了阐释清楚，我们将fs.readFile转成\x3ccode\x3ePromise\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = require(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereadFile\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...arguments\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise((resolve, reject) =\x26gt; {\n    fs.readFile(...arguments, (err, data) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n         reject(err);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          resolve(data);\n        }\n    });\n  });\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种模式可以很容易地扩展到任何函数，并且内置的utils模块中有一个特殊的函数 - \x3ccode\x3eutils.promisify\x3c\/code\x3e。官方文档中的示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stat = util.promisify(fs.stat);\n\nstat(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estats\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do something with stats\x3c\/span\x3e\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Handle the error.\x3c\/span\x3e\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eNode.js核心团队明白我们需要从旧风格中迁移出来，他们尝试引入一个内置模块的\x3ccode\x3epromisified\x3c\/code\x3e版本 - 已经有\x3ccode\x3epromisified\x3c\/code\x3e文件系统模块了，虽然写这篇文章时它还在处于试验阶段。\x3c\/p\x3e\n\x3cp\x3e你仍然会遇到很多旧式的、带回调的Node.js代码，为了保持一致性，建议使用 \x3ccode\x3eutils.promisify\x3c\/code\x3e 把它们包装一下。\x3c\/p\x3e\n\x3ch3\x3e事件循环\x3c\/h3\x3e\n\x3cp\x3e事件循环几乎与在浏览器环境下一样，只是有一些扩展。然而，由于这个主题比较高深，我将全面讲解下，不仅仅是差异（我会重点强调这部分，让您知道哪些是Node.js特有的）。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22http:\/\/ww1.sinaimg.cn\/large\/9c29ca1cgy1fu27ve3w7fj20j80bl74z.jpg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3eNode.js中的事件循环\x3c\/h4\x3e\n\x3cp\x3eJavaScript在构建时考虑了异步行为，因此我们通常不会马上执行所有操作。以下列举的方法，事件不会直接按顺序执行:\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3emicrotasks\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e例如，立即处理Promises，如Promise.resolve。它意味着这段代码会在同一个的事件循环中被执行，但得等到所有同步代码执行完后。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eprocess.nextTick\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这是Node.js特有的方法，它不存在于任何浏览器（以及进程对象）中。它的行为类似于微任务(microtask)，但具有优先级。这意味着它将在所有同步代码之后立即执行，即使之前引入了其他微任务 - 这是很危险的，可能导致无限循环。从命名上讲是不对的，因为它是在同一个事件循环中执行的，而不是在它的\x3ccode\x3enext tick\x3c\/code\x3e中执行。但是由于兼容性原因，它可能保持不变。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3esetImmediate\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e虽然它确实存在于某些浏览器中，但并未在所有浏览器中达到一致的行为，因此在浏览器中使用时，您需要非常小心。它类似于 \x3ccode\x3esetTimeout（0）\x3c\/code\x3e代码，但有时会优先于它。这里的命名也不是最好的 - 我们在谈论下一个事件循环迭代，它并不是真正的\x3ccode\x3eimmidiate\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3esetTimeout\/setInterval\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e定时器在Node和浏览器中的表现形式是相同的。关于定时器的一个重要的事情是，我们提供的延迟不代表在这个时间之后回调就会被执行。它的真正含义是，一旦主线程完成所有操作（包括微任务）并且没有其它具有更高优先级的定时器，Node.js将在此时间之后执行回调。\x3c\/p\x3e\n\x3cp\x3e让我们看看这个例子：\x3c\/p\x3e\n\x3cp\x3e往下看我会给出脚本执行后正确的输出，但是如果你愿意，请尝试自己完成它（当一回“JavaScript解释器”）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27beginning of the program\x27\x3c\/span\x3e);\nconst promise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(resolve =\x26gt; {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e function, passed to the Promise constructor\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e executed synchronously!\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the promise function!\x27\x3c\/span\x3e);\nresolve(\x3cspan class=\x22hljs-string\x22\x3e\x27resolved message\x27\x3c\/span\x3e);\n});\npromise.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the first resolved promise\x27\x3c\/span\x3e);\n}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the second resolved promise\x27\x3c\/span\x3e);\n});\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the process next tick now\x27\x3c\/span\x3e);\n});\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27==================\x27\x3c\/span\x3e);\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the callback from setTimeout with 0ms delay\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am from setImmediate callback\x27\x3c\/span\x3e);\n});\n});\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am in the callback from setTimeout with 0ms delay\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am from setImmediate callback\x27\x3c\/span\x3e);\n});\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正确的执行顺序如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3enode event-loop.js\n\x3cspan class=\x22hljs-keyword\x22\x3ebeginning\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e program\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e promise function!\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e process next tick now\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efirst\x3c\/span\x3e resolved promise\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esecond\x3c\/span\x3e resolved promise\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e callback \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e setTimeout \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ems \x3cspan class=\x22hljs-built_in\x22\x3edelay\x3c\/span\x3e\nI am \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e setImmediate callback\n==================\nI am \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e setImmediate callback\nI am \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e callback \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e setTimeout \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ems \x3cspan class=\x22hljs-built_in\x22\x3edelay\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e您可以在Node.js官方文档中获取更多有关事件循环和process.nextTick的信息。\x3c\/p\x3e\n\x3ch3\x3e事件发射器\x3c\/h3\x3e\n\x3cp\x3eNode.js中的许多核心模块派发或接收不同的事件。它有一个EventEmitter的实现，是一个发布 - 订阅模式。这与浏览器DOM事件非常相似，语法略有不同，理解它最好的方式就是亲自来实现一下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e {\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events = {};\n}\n  checkExistence(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e] = [];\n    }\n  }\n  once(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, cb) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.checkExistence(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cbWithRemove = (...args) =\x26gt; {\n          cb(...args);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.off(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, cbWithRemove);\n      };\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e].push(cbWithRemove);\n     }\n  \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, cb) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.checkExistence(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e].push(cb);\n  }\n  off(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, cb) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.checkExistence(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e].filter(\n      registeredCallback =\x26gt; registeredCallback !== cb\n    );\n  }\n  emit(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, ...args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.checkExistence(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e].forEach(cb =\x26gt; cb(...args));\n    }\n  }\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e以上代码只显示模式本身，并没有针对确切的功能 - 请不要在您的代码中使用它！\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这是我们需要的所有基础代码！它允许您订阅事件，稍后取消订阅，并派发不同的事件。例如，响应体，请求体，流 - 它们实际上都扩展或实现了EventEmitter！\x3c\/p\x3e\n\x3cp\x3e正因为它是一个如此简单的概念，所以被用于许多的NPM包。所以，如果你想在浏览器中使用相同的事件发射器，可以随时使用它们。\x3c\/p\x3e\n\x3ch3\x3e流\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e“Streams是Node.js最好用、最容易被误解的概念。”\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e多米尼克塔尔(Dominic Tarr)\x3c\/p\x3e\n\x3cp\x3eStreams允许您以块的形式来处理数据，而不仅仅是完整操作（如读取文件）。为了理解它们的作用，让我们来看个简单的例子：假设我们想要向用户返回任意大小的请求文件。我们的代码可能如下所示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ada\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\x3c\/span\x3e(req, res) {\n  const filename = req.url.slice(1);\n  fs.readFile(filename, (err, data) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n        res.\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Something\x3c\/span\x3e went wrong\x27);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n       res.\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e(data);\n    }\n  });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码可以使用，特别是在本地开发的机器上，但它可也能会失败 - 您看出问题了吗？如果文件太大，我们读取文件时就会遇到问题，我们将所有内容放入内存中，如果没有足够的内存空间，这将无法正常工作。如果我们有很多并发请求，这段代码也不会生效 - 我们必须将数据对象保留在内存中，直到我们发送了所有内容。\x3c\/p\x3e\n\x3cp\x3e然而，我们根本不需要这个文件 - 我们只需要从文件系统返回它，我们自己不会查看内容，所以我们可以读取它的一部分，立即返回给客户端来释放我们的内存，重复这样一个过程，直到我们完成了整个文件的发送。这是对 \x3ccode\x3eStreams\x3c\/code\x3e 的简短介绍 - 我们有一种以块的形式来接收数据的机制，并且 _我们_ 决定如何处理这些数据。例如，我们同样可以这样处理：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filename = req.url.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filestream = fs.createReadStream(filename, { encoding: \x3cspan class=\x22hljs-string\x22\x3e\x27utf-8\x27\x3c\/span\x3e });\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3echunk\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    result \x2b= chunk;\n  });\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.end(result);\n  });\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if file does not exist, error callback will be called\x3c\/span\x3e\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n  res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27Something went wrong\x27\x3c\/span\x3e);\n  });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们创建一个 \x3ccode\x3e流\x3c\/code\x3e 来读取文件 - 这个流执行EventEmitter这个类，在\x3ccode\x3edata\x3c\/code\x3e事件上我们接收下一个块，在\x3ccode\x3eend\x3c\/code\x3e事件中，我们得到一个信号，表示流已结束，然后读取完整文件。这样的实现跟前面的一样 - 我们等待整个文件被读取，然后在响应中返回它。此外，它也有同样的问题：我们将整个文件保留在内存中，然后再发送回来。如果我们知道响应对象本身实现了可写流，我们可以解决这个问题，我们可以将信息写入该流而不将其保留在内存中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filename = req.uårl.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filestream = fs.createReadStream(filename, { encoding: \x3cspan class=\x22hljs-string\x22\x3e\x27utf-8\x27\x3c\/span\x3e });\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3echunk\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.write(chunk);\n  });\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.end();\n  });\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if file does not exist, error callback will be called\x3c\/span\x3e\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n    res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27Something went wrong\x27\x3c\/span\x3e);\n  });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e响应体实现可写流，\x3ccode\x3efs.createReadStream\x3c\/code\x3e 创建可读流，还有双向和转换流。它们之间的区别以及工作原理，不在本教程的范围内，但是了解它们的存在还是大有裨益的。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这样我们不再需要结果变量了，只需要把已读的 \x3ccode\x3e块\x3c\/code\x3e 立即写入响应体，不将它保留在内存中！这意味着我们甚至可以读取大文件，而不必担心高并发请求 - 因为文件没有被保存在内存中，所以不会超出内存所能承载的数量。但是，存在一个问题。在我们的解决方案中，我们从一个流（文件系统读取文件）中读取文件，并将其写入另一个（网络请求），这两个事物具有不同的延迟。这里强调是真的不同，经过一段时间后，我们的响应流将不堪重负，因为它要慢得多。这个问题是对背压的描述，Node有一个解决方案：每个可读流都有一个管道方法，它将所有数据重定向到与其负载相关的给定流中：如果它正忙，它将暂停原始流并恢复它。使用此方法，我们可以将代码简化为：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs php\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(req, res)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filename = req.url.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filestream = fs.createReadStream(filename, { encoding: \x3cspan class=\x22hljs-string\x22\x3e\x27utf-8\x27\x3c\/span\x3e });\n  filestream.pipe(res);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if file does not exist, error callback will be called\x3c\/span\x3e\n  filestream.on(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, () =\x26gt; {\n    res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n    res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27Something went wrong\x27\x3c\/span\x3e);\n  });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在Node的历史进程中，Streams改变了几次，所以在阅读旧手册时要格外小心，并经常查看官方文档！\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch4\x3e模块系统\x3c\/h4\x3e\n\x3cp\x3eNode.js使用commonjs模块。您或许使用过 - 每次使用require来获取webpack配置中的某个模块时，您实际上就使用了commonjs模块; 每次声明 \x3ccode\x3emodule.exports\x3c\/code\x3e 时也在使用它。然而，您可能还会看到像 \x3ccode\x3eexports.some = {}\x3c\/code\x3e 这样的写法，没有 \x3ccode\x3emodule\x3c\/code\x3e，在这一节中我们将看下它究竟是如何工作的。\x3c\/p\x3e\n\x3cp\x3e首先，我们来讨论commonjs模块，它们通常都有 \x3ccode\x3e.js\x3c\/code\x3e 的扩展，而不是 \x3ccode\x3e.esm \/ .mjs\x3c\/code\x3e 文件（ECMAScript模块），它们允许您使用 \x3ccode\x3eimport\/export\x3c\/code\x3e 的语法。另外，重要的是要明白，webpack和browserify（以及其它打包工具）使用自己的\x3ccode\x3erequire\x3c\/code\x3e函数，所以请不要混淆 - 这里不讲解它们，只要明白它们是不同的东西就行（即使它们表现得非常相似）。\x3c\/p\x3e\n\x3cp\x3e那么，我们实际上是在哪里获得这些“全局”对象，如 \x3ccode\x3emodule\x3c\/code\x3e，\x3ccode\x3erequier\x3c\/code\x3e 和 \x3ccode\x3eexports\x3c\/code\x3e ？实际上，是Node.js在运行时添加的 - 它不是仅执行给定的javascript文件，实际上是将它包含在具有所有这些变量的函数中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eexports, \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e, __filename, __dirname\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ your module\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e您可以在命令行中执行以下代码段来查看这个包：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e1node -e \x22console.log(require(\x27module\x27).wrapper)\x22\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这些是注入到模块中的变量，可以作为“全局”变量使用，即使它们不是真正的全局变量。我强烈建议你研究它们，尤其是模块变量。你可以在javascript文件中调用 \x3ccode\x3econsole.log（module）\x3c\/code\x3e，对比从 \x3ccode\x3emain\x3c\/code\x3e 文件打印和从 \x3ccode\x3erequired\x3c\/code\x3e 的文件打印出来的结果。\x3c\/p\x3e\n\x3cp\x3e接下来，让我们看一下 \x3ccode\x3eexports\x3c\/code\x3e 对象 - 这里有一个小例子，显示一些与之相关的警告：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs java\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27our name\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this works\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = { name: \x3cspan class=\x22hljs-string\x22\x3e\x27our name\x27\x3c\/span\x3e };\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this doesn\x27t work\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = { name: \x3cspan class=\x22hljs-string\x22\x3e\x27our name\x27\x3c\/span\x3e };\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this works!\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子可能会让你感到困惑 为什么会这样？答案是\x3ccode\x3eexports\x3c\/code\x3e对象的本质 - 它只是一个传递给函数的参数，所以在我们给它指定一个新对象的情况时，我们只是重写这个变量，旧的引用就不存在了。尽管它没有完全消失 - \x3ccode\x3emodule.exports\x3c\/code\x3e是同一个对象 - 所以它们实际上是对单个对象的相同引用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs java\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e === \x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一部分是 \x3ccode\x3erequire\x3c\/code\x3e - 它是一个获取模块名称并返回该模块的 \x3ccode\x3eexports对象\x3c\/code\x3e 的函数。它究竟是如何解析模块的？有一个非常简单的规则：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e根据名称检索核心模块\x3c\/li\x3e\n\x3cli\x3e如果路径以 \x3ccode\x3e.\/\x3c\/code\x3e 或 \x3ccode\x3e..\/\x3c\/code\x3e开头，则尝试解析文件\x3c\/li\x3e\n\x3cli\x3e如果找不到文件，尝试在其中找到包含\x3ccode\x3eindex.js\x3c\/code\x3e文件的目录\x3c\/li\x3e\n\x3cli\x3e如果\x3ccode\x3epath\x3c\/code\x3e 不以 \x3ccode\x3e.\/\x3c\/code\x3e 或 \x3ccode\x3e..\/\x3c\/code\x3e 开头，请转到\x3ccode\x3enode_modules \/\x3c\/code\x3e并检查文件夹\/文件：\x3cul\x3e\n\x3cli\x3e在我们运行脚本的文件夹中\x3c\/li\x3e\n\x3cli\x3e上面一级，直到我们到达\x3ccode\x3e\/ node_modules\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e还有其它一些位置，主要是为了兼容性，您还可以通过指定变量 \x3ccode\x3eNODE_PATH\x3c\/code\x3e 来提供查找路径，这也许很有用。如果您要查看解析\x3ccode\x3enode_modules\x3c\/code\x3e的确切顺序，只需在脚本中打印模块对象并查找\x3ccode\x3epaths\x3c\/code\x3e属性。我操作后，打印了如下内容：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs less\x22\x3e➜ \x3cspan class=\x22hljs-selector-tag\x22\x3etmp\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3etest\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3eModule\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3eexports\x3c\/span\x3e: {},\n  \x3cspan class=\x22hljs-attribute\x22\x3eparent\x3c\/span\x3e: null,\n  \x3cspan class=\x22hljs-attribute\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/Users\/seva.zaikov\/tmp\/test.js\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3eloaded\x3c\/span\x3e: false,\n  \x3cspan class=\x22hljs-attribute\x22\x3echildren\x3c\/span\x3e: [],\n  \x3cspan class=\x22hljs-attribute\x22\x3epaths\x3c\/span\x3e:\n   [ \x3cspan class=\x22hljs-string\x22\x3e\x27\/Users\/seva.zaikov\/tmp\/node_modules\x27\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-string\x22\x3e\x27\/Users\/seva.zaikov\/node_modules\x27\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-string\x22\x3e\x27\/Users\/node_modules\x27\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-string\x22\x3e\x27\/node_modules\x27\x3c\/span\x3e ] }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于 \x3ccode\x3erequire\x3c\/code\x3e 的另一个有趣的事情是，在第一个require调用模块被缓存后，将不会再次执行，我们将只返回缓存的export对象 - 这意味着你可以做一些逻辑并确保它会在第一次require调用之后只执行一次（这不完全正确 - 如果再次需要，你可以从\x3ccode\x3erequire.cache\x3c\/code\x3e中删除模块id ，然后重新加载模块）\x3c\/p\x3e\n\x3ch3\x3e环境变量\x3c\/h3\x3e\n\x3cp\x3e正如在\x3ccode\x3e十二因素应用程序\x3c\/code\x3e所述，将配置存储在环境变量中是一种很好的做法。您可以为shell会话设置变量：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eexport MY_VARIABLE=\x22some variable value\x22\x3c\/code\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eNode是一个跨平台引擎，理想情况下，您的应用程序应该可以在任何平台上运行（例如，开发环境。您选择生产环境来运行您的代码，通常它是一些Linux分发版）。我的示例仅涵盖MacOS \/ Linux，不适用于Windows。Windows中环境变量的语法跟这里的不同，你可以使用像cross-env这样的东西，但在其它情况下，你也应该记住这点。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e您可以把下面这行代码添加到 \x3ccode\x3ebash \/ zsh\x3c\/code\x3e 配置文件中，以便在任何新的终端会话中进行设置。然而，您通常只在运行应用程序时，为这些实例提供特有的变量：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eAPP_DB_URI=\x22.....\x22 SECRET_KEY=\x22secret key value\x22 node server.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e您可以使用 \x3ccode\x3eprocess.env\x3c\/code\x3e 对象来访问 Node.js 应用程序中的这些变量：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst\x3cspan class=\x22hljs-built_in\x22\x3e CONFIG \x3c\/span\x3e= {\n  db: process.env.APP_DB_URI,\n  secret: process.env.SECRET_KEY\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e综合运用\x3c\/h3\x3e\n\x3cp\x3e在下面的例子中，我们将创建一个简单的http服务，它将返回一个文件，以url\x3ccode\x3e\/\x3c\/code\x3e后面的字符串来命名。如果文件不存在，我们将返回 \x3ccode\x3e404 Not Found\x3c\/code\x3e 的错误信息，如果用户试图投机取巧，使用相对路径或嵌套路径，我们则返回403错误。我们之前使用过其中的一些函数，但没有真正记录它们 - 这次它将包含大量的信息：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ we require only built-in modules, so Node.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ does not traverse our node_modules folders\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/http.html#http_http_createserver_options_requestlistener\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { createServer } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22http\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fs\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e url = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22url\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22path\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ we pass the folder name with files as an environment variable\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ so we can use a different folder locally\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FOLDER_NAME = process.env.FOLDER_NAME;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PORT = process.env.PORT || \x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e server = createServer(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ req.url contains full url, with querystring\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we ignored it before, but here we want to ensure\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ that we only get pathname, without querystring\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/http.html#http_message_url\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e parsedURL = url.parse(req.url);\n\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we don\x27t need the first \/ symbol\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pathname = parsedURL.pathname.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in order to return a response, we have to call res.end()\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/http.html#http_response_end_data_encoding_callback\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26gt; The method, response.end(), MUST be called on each response.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if we don\x27t call it, the connection won\x27t close and a requester\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ will wait for it until the timeout\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ by default, we return a response with [code 200](https:\/\/en.wikipedia.org\/wiki\/List_of_HTTP_status_codes)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in case something went wrong, we are supposed to return\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a correct status code, using the res.statusCode = ... property:\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/http.html#http_response_statuscode\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (pathname.startsWith(\x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e)) {\n    res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e403\x3c\/span\x3e;\n     res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Relative paths are not allowed\x22\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (pathname.includes(\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e)) {\n    res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e403\x3c\/span\x3e;\n    res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Nested paths are not allowed\x22\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/en\/docs\/guides\/working-with-different-filesystems\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in order to stay cross-platform, we can\x27t just create a path on our own\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we have to use the platform-specific separator as a delimiter\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ path.join() does exactly that for us:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/path.html#path_path_join_paths\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filePath = path.join(__dirname, FOLDER_NAME, pathname);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n  fileStream.on(\x3cspan class=\x22hljs-string\x22\x3e\x22error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we handle only non-existant files, but there are plenty\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ of possible error codes. you can get all common codes from the docs:\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/nodejs.org\/api\/errors.html#errors_common_system_errors\x3c\/span\x3e\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.code === \x3cspan class=\x22hljs-string\x22\x3e\x22ENOENT\x22\x3c\/span\x3e) {\n       res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e;\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22This file does not exist.\x22\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        res.statusCode = \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Internal server error\x22\x3c\/span\x3e);\n    }\n  });}\n });\nserver.listen(PORT, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(application is listening at the port ${PORT});\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e总结\x3c\/h3\x3e\n\x3cp\x3e在本指南中，我们介绍了许多基本的Node.js原则。我们没有深入研究特定的API，我们确实错过了一些东西。但是，本指南应该是一个很好的起点，让您在阅读API，编辑现有的代码，或者创建新脚本时有信心。您现在能够理解错误，清楚内置模块使用的接口，以及从典型的Node.js对象和接口中能获取到哪些东西。    \x3c\/p\x3e\n\x3cp\x3e下一次，我们将深入介绍使用Node.js的Web服务，Node.js REPL，如何编写CLI应用程序，以及如何使用Node.js编写小脚本。您可以订阅以获取有关这些新文章的通知。\x3c\/p\x3e\n\x3ch2\x3e相关文章\x3c\/h2\x3e\n\x3cblockquote\x3e\n\x3cp\x3e2017年7月9日» Node.js REPL深度\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cblockquote\x3e\n\x3cp\x3e2018年6月5日» 不要使用缩略词\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cblockquote\x3e\n\x3cp\x3e2018 年 6月3日» 单元测试\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/node-js-guide-for-frontend-developers">https://www.zcfy.cc/article/node-js-guide-for-frontend-developers</a> 原文标题: Node.js 前端开发指南 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/b821ddf1/" target="_blank">https://alili.tech/archive/b821ddf1/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>