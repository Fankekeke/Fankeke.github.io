<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="带你彻底弄懂Event Loop"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>带你彻底弄懂Event Loop | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bc9bb1af/",
				"appid": "1613049289050283", 
				"title": "带你彻底弄懂Event Loop | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-22T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/71e9065a/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c59e1898/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&text=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&text=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&title=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&is_video=false&description=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&title=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&title=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&title=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbc9bb1af%2f&title=%e5%b8%a6%e4%bd%a0%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82Event%20Loop"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">带你彻底弄懂Event Loop</h1><div class="meta"><div class="postdate"><time datetime="2018-10-22" itemprop="datePublished">2018-10-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。\x3c\/p\x3e\n\x3cp\x3e于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。\x3c\/p\x3e\n\x3cp\x3e（PS：说到Event Loop肯定会提到Promise，我根据Promise A\x2b规范自己实现了一个简易Promise库，\x3ca href=\x22https:\/\/github.com\/leocoder351\/my-promise\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~）\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e正文\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eEvent Loop是什么\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3eevent loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e浏览器的Event Loop是在\x3ca href=\x22https:\/\/www.w3.org\/TR\/html5\/webappapis.html#event-loops\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehtml5的规范\x3c\/a\x3e中明确定义。\x3c\/li\x3e\n\x3cli\x3eNodeJS的Event Loop是基于libuv实现的。可以参考Node的\x3ca href=\x22https:\/\/nodejs.org\/en\/docs\/guides\/event-loop-timers-and-nexttick\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e以及libuv的\x3ca href=\x22http:\/\/docs.libuv.org\/en\/v1.x\/design.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3elibuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e宏队列和微队列\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列，macrotask，也叫tasks。\x3c\/strong\x3e 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3esetTimeout\x3c\/li\x3e\n\x3cli\x3esetInterval\x3c\/li\x3e\n\x3cli\x3esetImmediate (Node独有)\x3c\/li\x3e\n\x3cli\x3erequestAnimationFrame (浏览器独有)\x3c\/li\x3e\n\x3cli\x3eI\/O\x3c\/li\x3e\n\x3cli\x3eUI rendering (浏览器独有)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e微队列，microtask，也叫jobs。\x3c\/strong\x3e 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eprocess.nextTick (Node独有)\x3c\/li\x3e\n\x3cli\x3ePromise\x3c\/li\x3e\n\x3cli\x3eObject.observe\x3c\/li\x3e\n\x3cli\x3eMutationObserver\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e（注：这里只针对浏览器和NodeJS）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e浏览器的Event Loop\x3c\/h2\x3e\n\x3cp\x3e我们先来看一张图，再看完这篇文章后，请返回来再仔细看一下这张图，相信你会有更深的理解。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278118?w=710\x26amp;h=749\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22browser-eventloop\x22 title=\x22browser-eventloop\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\x3c\/li\x3e\n\x3cli\x3e全局Script代码执行完毕后，调用栈Stack会清空；\x3c\/li\x3e\n\x3cli\x3e从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\x3c\/li\x3e\n\x3cli\x3e继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。\x3cstrong\x3e注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行\x3c\/strong\x3e；\x3c\/li\x3e\n\x3cli\x3emicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\x3c\/li\x3e\n\x3cli\x3e取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\x3c\/li\x3e\n\x3cli\x3e执行完毕后，调用栈Stack为空；\x3c\/li\x3e\n\x3cli\x3e重复第3-7个步骤；\x3c\/li\x3e\n\x3cli\x3e重复第3-7个步骤；\x3c\/li\x3e\n\x3cli\x3e......\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e可以看到，这就是浏览器的事件循环Event Loop\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这里归纳3个重点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；\x3c\/li\x3e\n\x3cli\x3e微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；\x3c\/li\x3e\n\x3cli\x3e图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e好了，概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(1);\n\nsetTimeout(() =\x3e {\n  console.log(2);\n  Promise.resolve().then(() =\x3e {\n    console.log(3)\n  });\n});\n\nnew Promise((resolve, reject) =\x3e {\n  console.log(4)\n  resolve(5)\n}).then((data) =\x3e {\n  console.log(data);\n})\n\nsetTimeout(() =\x3e {\n  console.log(6);\n})\n\nconsole.log(7);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n  Promise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n  });\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve, reject)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\n  resolve(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\n}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n})\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e);\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里结果会是什么呢？运用上面了解到的知识，先自己做一下试试看。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确答案\n1\n4\n7\n5\n2\n3\n6\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正确答案\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你答对了吗？\x3c\/p\x3e\n\x3cp\x3e我们来分析一下整个流程：\x3c\/p\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e执行全局Script代码\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eStep 1\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(1)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [console]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: []\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 2\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(() =\x3e {\n  \/\/ 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中\n  console.log(2);\n  Promise.resolve().then(() =\x3e {\n    console.log(3)\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n  Promise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [setTimeout]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback1]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 3\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Promise((resolve, reject) =\x3e {\n  \/\/ 注意，这里是同步执行的，如果不太清楚，可以去看一下我开头自己实现的promise啦~~\n  console.log(4)\n  resolve(5)\n}).then((data) =\x3e {\n  \/\/ 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中\n  console.log(data);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve, reject)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 注意，这里是同步执行的，如果不太清楚，可以去看一下我开头自己实现的promise啦~~\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\n  resolve(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\n}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [promise]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback1]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: [callback2]\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 5\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(() =\x3e {\n  \/\/ 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中\n  console.log(6);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [setTimeout]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback1, callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: [callback2]\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 6\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(7)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [console]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback1, callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: [callback2]\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e好啦，全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eStep 7\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(data)       \/\/ 这里data是Promise的决议值5\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)       \/\/ 这里\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e是Promise的决议值\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [callback2]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback1, callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e这里microtask queue中只有一个任务，执行完后开始从宏任务队列macrotask queue中取位于队首的任务执行\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eStep 8\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(2)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [callback1]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5    \x3cbr\x3e2\x3c\/blockquote\x3e\n\x3cp\x3e但是，执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 9\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.resolve().then(() =\x3e {\n  \/\/ 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中\n  console.log(3)\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3ePromise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [promise]\x3c\/p\x3e\n\x3cp\x3eMacrotask v: [callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: [callback4]\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5    \x3cbr\x3e2\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e取出一个宏任务macrotask执行完毕，然后再去微任务队列microtask queue中依次取出执行\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eStep 10\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(3)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [callback4]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: [callback3]\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5    \x3cbr\x3e2    \x3cbr\x3e3\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e微任务队列全部执行完，再去宏任务队列中取第一个任务执行\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eStep 11\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(6)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStack Queue: [callback3]\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: []\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5    \x3cbr\x3e2    \x3cbr\x3e3    \x3cbr\x3e6\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e以上，全部执行完后，Stack Queue为空，Macrotask Queue为空，Micro Queue为空\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3eStack Queue: []\x3c\/p\x3e\n\x3cp\x3eMacrotask Queue: []\x3c\/p\x3e\n\x3cp\x3eMicrotask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e最终打印结果：     \x3cbr\x3e1      \x3cbr\x3e4    \x3cbr\x3e7    \x3cbr\x3e5    \x3cbr\x3e2    \x3cbr\x3e3    \x3cbr\x3e6\x3c\/blockquote\x3e\n\x3cp\x3e因为是第一个例子，所以这里分析的比较详细，大家仔细看一下，接下来我们再来一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(1);\n\nsetTimeout(() =\x3e {\n  console.log(2);\n  Promise.resolve().then(() =\x3e {\n    console.log(3)\n  });\n});\n\nnew Promise((resolve, reject) =\x3e {\n  console.log(4)\n  resolve(5)\n}).then((data) =\x3e {\n  console.log(data);\n  \n  Promise.resolve().then(() =\x3e {\n    console.log(6)\n  }).then(() =\x3e {\n    console.log(7)\n    \n    setTimeout(() =\x3e {\n      console.log(8)\n    }, 0);\n  });\n})\n\nsetTimeout(() =\x3e {\n  console.log(9);\n})\n\nconsole.log(10);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n  Promise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n  });\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve, reject)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\n  resolve(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\n}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n  \n  Promise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e)\n  }).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e)\n    \n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  });\n})\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e);\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终输出结果是什么呢？参考前面的例子，好好想一想......\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确答案\n1\n4\n10\n5\n6\n7\n2\n3\n9\n8\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正确答案\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相信大家都答对了，这里的关键在前面已经提过：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个，后面我们会讲到。\x3c\/p\x3e\n\x3cp\x3e浏览器的Event Loop就说到这里，下面我们看一下NodeJS中的Event Loop，它更复杂一些，机制也不太一样。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eNodeJS中的Event Loop\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3elibuv\x3c\/h3\x3e\n\x3cp\x3e先来看一张libuv的结构图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278119?w=800\x26amp;h=316\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22node-libuv\x22 title=\x22node-libuv\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eNodeJS中的宏队列和微队列\x3c\/h3\x3e\n\x3cp\x3eNodeJS的Event Loop中，执行宏队列的回调任务有\x3cstrong\x3e6个阶段\x3c\/strong\x3e，如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278120?w=670\x26amp;h=339\x22 del-src=\x22https:\/\/static.alili.tech\/v-5bbf1b3b\/global\/img\/squares.svg\x22 alt=\x22node-eventloop-6phase\x22 title=\x22node-eventloop-6phase\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e各个阶段执行的任务如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3etimers阶段\x3c\/strong\x3e：这个阶段执行setTimeout和setInterval预定的callback\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eI\/O callback阶段\x3c\/strong\x3e：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eidle, prepare阶段\x3c\/strong\x3e：仅node内部使用\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3epoll阶段：获取新的I\/O事件\x3c\/strong\x3e，适当的条件下node将阻塞在这里\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3echeck阶段\x3c\/strong\x3e：执行setImmediate()设定的callbacks\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eclose callbacks阶段\x3c\/strong\x3e：执行socket.on(\x27close\x27, ....)这些callbacks\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eNodeJS中宏队列主要有4个\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e由上面的介绍可以看到，回调事件主要位于4个macrotask queue中：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eTimers Queue\x3c\/li\x3e\n\x3cli\x3eIO Callbacks Queue\x3c\/li\x3e\n\x3cli\x3eCheck Queue\x3c\/li\x3e\n\x3cli\x3eClose Callbacks Queue\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eNodeJS中微队列主要有2个\x3c\/strong\x3e：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eNext Tick Queue：是放置process.nextTick(callback)的回调任务的\x3c\/li\x3e\n\x3cli\x3eOther Micro Queue：放置其他microtask，比如Promise等\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。\x3c\/p\x3e\n\x3cp\x3e具体可以通过下图加深一下理解：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278121?w=951\x26amp;h=526\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278121?w=951\x26amp;h=526\x22 alt=\x22node-eventloop\x22 title=\x22node-eventloop\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e大体解释一下NodeJS的Event Loop过程：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e执行全局Script的同步代码\x3c\/li\x3e\n\x3cli\x3e执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务\x3c\/li\x3e\n\x3cli\x3e开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2\x3c\/li\x3e\n\x3cli\x3eTimers Queue -\x26gt; 步骤2 -\x26gt; I\/O Queue -\x26gt; 步骤2 -\x26gt; Check Queue -\x26gt; 步骤2 -\x26gt; Close Callback Queue -\x26gt; 步骤2 -\x26gt; Timers Queue ......\x3c\/li\x3e\n\x3cli\x3e这就是Node的Event Loop\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e关于NodeJS的macrotask queue和microtask queue，我画了两张图，大家作为参考：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278122?w=420\x26amp;h=433\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278122?w=420\x26amp;h=433\x22 alt=\x22node-microtaskqueue\x22 title=\x22node-microtaskqueue\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278123?w=676\x26amp;h=449\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016278123?w=676\x26amp;h=449\x22 alt=\x22node-macrotaskqueue\x22 title=\x22node-macrotaskqueue\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e好啦，概念理解了我们通过几个例子来实战一下：\x3c\/p\x3e\n\x3cp\x3e第一个例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x27start\x27);\n\nsetTimeout(() =\x3e {          \/\/ callback1\n  console.log(111);\n  setTimeout(() =\x3e {        \/\/ callback2\n    console.log(222);\n  }, 0);\n  setImmediate(() =\x3e {      \/\/ callback3\n    console.log(333);\n  })\n  process.nextTick(() =\x3e {  \/\/ callback4\n    console.log(444);  \n  })\n}, 0);\n\nsetImmediate(() =\x3e {        \/\/ callback5\n  console.log(555);\n  process.nextTick(() =\x3e {  \/\/ callback6\n    console.log(666);  \n  })\n})\n\nsetTimeout(() =\x3e {          \/\/ callback7              \n  console.log(777);\n  process.nextTick(() =\x3e {  \/\/ callback8\n    console.log(888);   \n  })\n}, 0);\n\nprocess.nextTick(() =\x3e {    \/\/ callback9\n  console.log(999);  \n})\n\nconsole.log(\x27end\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27start\x27\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {          \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback1\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e111\x3c\/span\x3e);\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback2\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e222\x3c\/span\x3e);\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {      \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback3\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e333\x3c\/span\x3e);\n  })\n  process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback4\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e444\x3c\/span\x3e);  \n  })\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback5\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e555\x3c\/span\x3e);\n  process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback6\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e666\x3c\/span\x3e);  \n  })\n})\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {          \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback7              \n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e777\x3c\/span\x3e);\n  process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback8\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e888\x3c\/span\x3e);   \n  })\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e callback9\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e999\x3c\/span\x3e);  \n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请运用前面学到的知识，仔细分析一下......\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确答案\nstart\nend\n999\n111\n777\n444\n888\n555\n333\n666\n222\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正确答案\x3c\/span\x3e\nstart\nend\n\x3cspan class=\x22hljs-number\x22\x3e999\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e111\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e777\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e444\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e888\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e555\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e333\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e666\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e222\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\x3cstrong\x3e跟新 2018.9.20\x3c\/strong\x3e\x3c\/blockquote\x3e\n\x3cp\x3e上面这段代码你执行的结果可能会有多种情况，原因解释如下。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3esetTimeout(fn, 0)不是严格的0，一般是setTimeout(fn, 3)或什么，会有一定的延迟时间，当setTimeout(fn, 0)和setImmediate(fn)出现在同一段同步代码中时，就会存在两种情况。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e第1种情况\x3c\/strong\x3e：同步代码执行完了，Timer还没到期，setImmediate回调先注册到Check Queue中，开始执行微队列，然后是宏队列，先从Timers Queue中开始，发现没回调，往下走直到Check Queue中有回调，执行，然后timer到期（只要在执行完Timer Queue后到期效果就都一样），timer回调注册到Timers Queue中，下一轮循环执行到Timers Queue中才能执行那个timer 回调；\x3cstrong\x3e所以，这种情况下，setImmediate(fn)回调先于setTimeout(fn, 0)回调执行\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e第2种情况\x3c\/strong\x3e：同步代码还没执行完，timer先到期，timer回调先注册到Timers Queue中，执行到setImmediate了，它的回调再注册到Check Queue中。 然后，同步代码执行完了，执行微队列，然后开始先执行Timers Queue，先执行Timer 回调，再到Check Queue，执行setImmediate回调；\x3cstrong\x3e所以，这种情况下，setTimeout(fn, 0)回调先于setImmediate(fn)回调执行\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e所以，在同步代码中同时调setTimeout(fn, 0)和setImmediate情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile(\x27xx\x27, function () {\/\/ ....})回调中，那么IO回调是在IO Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，IO Queue执行完到Check Queue，timer Queue得到下个周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e综上，这个例子是不太好的，setTimeout(fn, 0)和setImmediate(fn)如果想要保证结果唯一，就放在一个IO Callback中吧，上面那段代码可以把所有它俩同步执行的代码都放在一个IO Callback中，结果就唯一了。\x3c\/p\x3e\n\x3cp\x3e更新结束\x3c\/p\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3cp\x3e你答对了吗？我们来一起分析一下：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e执行全局Script代码，先打印\x3cstrong\x3estart\x3c\/strong\x3e，向下执行，将setTimeout的回调callback1注册到Timers Queue中，再向下执行，将setImmediate的回调callback5注册到Check Queue中，接着向下执行，将setTimeout的回调callback7注册到Timers Queue中，继续向下，将process.nextTick的回调callback9注册到微队列Next Tick Queue中,最后一步打印\x3cstrong\x3eend\x3c\/strong\x3e。此时，各个队列的回调情况如下：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback1, callback7]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: [callback5]\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: [callback9]\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e全局Script执行完了，开始依次执行微任务Next Tick Queue中的全部回调任务。此时Next Tick Queue中只有一个callback9，将其取出放入调用栈中执行，打印\x3cstrong\x3e999\x3c\/strong\x3e。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback1, callback7]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: [callback5]\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: []\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e开始依次执行6个阶段各自宏队列中的所有任务，先执行第1个阶段Timers Queue中的所有任务，先取出callback1执行，打印\x3cstrong\x3e111\x3c\/strong\x3e，callback1函数继续向下，依次把callback2放入Timers Queue中，把callback3放入Check Queue中，把callback4放入Next Tick Queue中，然后callback1执行完毕。再取出Timers Queue中此时排在首位的callback7执行，打印\x3cstrong\x3e777\x3c\/strong\x3e，把callback8放入Next Tick Queue中，执行完毕。此时，各队列情况如下：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback2]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: [callback5, callback3]\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: [callback4, callback8]\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999    \x3cbr\x3e111    \x3cbr\x3e777\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e6个阶段每阶段的宏任务队列执行完毕后，都会开始执行微任务，此时，先取出Next Tick Queue中的所有任务执行，callback4开始执行，打印\x3cstrong\x3e444\x3c\/strong\x3e，然后callback8开始执行，打印\x3cstrong\x3e888\x3c\/strong\x3e，Next Tick Queue执行完毕，开始执行Other Microtask Queue中的任务，因为里面为空，所以继续向下。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback2]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: [callback5, callback3]\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: []\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999    \x3cbr\x3e111    \x3cbr\x3e777    \x3cbr\x3e444    \x3cbr\x3e888\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e第2个阶段IO Callback Queue队列为空，跳过，第3和第4个阶段一般是Node内部使用，跳过，进入第5个阶段Check Queue。取出callback5执行，打印\x3cstrong\x3e555\x3c\/strong\x3e，把callback6放入Next Tick Queue中，执行callback3，打印\x3cstrong\x3e333\x3c\/strong\x3e。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback2]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: []\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: [callback6]\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999    \x3cbr\x3e111    \x3cbr\x3e777    \x3cbr\x3e444    \x3cbr\x3e888   \x3cbr\x3e555    \x3cbr\x3e333\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e执行微任务队列，先执行Next Tick Queue，取出callback6执行，打印\x3cstrong\x3e666\x3c\/strong\x3e，执行完毕，因为Other Microtask Queue为空，跳过。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: [callback2]\x3c\/p\x3e\n\x3cp\x3eCheck Queue: []\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: [callback6]\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e打印结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999    \x3cbr\x3e111    \x3cbr\x3e777    \x3cbr\x3e444    \x3cbr\x3e888   \x3cbr\x3e555    \x3cbr\x3e333\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e执行第6个阶段Close Callback Queue中的任务，为空，跳过，好了，此时一个循环已经结束。进入下一个循环，执行第1个阶段Timers Queue中的所有任务，取出callback2执行，打印\x3cstrong\x3e222\x3c\/strong\x3e，完毕。此时，所有队列包括宏任务队列和微任务队列都为空，不再打印任何东西。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e宏队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eTimers Queue: []\x3c\/p\x3e\n\x3cp\x3eCheck Queue: []\x3c\/p\x3e\n\x3cp\x3eIO Callback Queue： []\x3c\/p\x3e\n\x3cp\x3eClose Callback Queue: []\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e微队列\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eNext Tick Queue: [callback6]\x3c\/p\x3e\n\x3cp\x3eOther Microtask Queue: []\x3c\/p\x3e\n\x3cblockquote\x3e最终结果    \x3cbr\x3estart    \x3cbr\x3eend   \x3cbr\x3e999    \x3cbr\x3e111   \x3cbr\x3e777    \x3cbr\x3e444    \x3cbr\x3e888   \x3cbr\x3e555    \x3cbr\x3e333       \x3cbr\x3e666    \x3cbr\x3e222\x3c\/blockquote\x3e\n\x3cp\x3e以上就是这道题目的详细分析，如果没有明白，一定要多看几次。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e下面引入Promise再来看一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x271\x27);\n\nsetTimeout(function() {\n    console.log(\x272\x27);\n    process.nextTick(function() {\n        console.log(\x273\x27);\n    })\n    new Promise(function(resolve) {\n        console.log(\x274\x27);\n        resolve();\n    }).then(function() {\n        console.log(\x275\x27)\n    })\n})\n\nnew Promise(function(resolve) {\n    console.log(\x277\x27);\n    resolve();\n}).then(function() {\n    console.log(\x278\x27)\n})\nprocess.nextTick(function() {\n  console.log(\x276\x27);\n})\n\nsetTimeout(function() {\n    console.log(\x279\x27);\n    process.nextTick(function() {\n        console.log(\x2710\x27);\n    })\n    new Promise(function(resolve) {\n        console.log(\x2711\x27);\n        resolve();\n    }).then(function() {\n        console.log(\x2712\x27)\n    })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e);\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e);\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x274\x27\x3c\/span\x3e);\n        resolve();\n    }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x275\x27\x3c\/span\x3e)\n    })\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x277\x27\x3c\/span\x3e);\n    resolve();\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x278\x27\x3c\/span\x3e)\n})\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x276\x27\x3c\/span\x3e);\n})\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x279\x27\x3c\/span\x3e);\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x2710\x27\x3c\/span\x3e);\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x2711\x27\x3c\/span\x3e);\n        resolve();\n    }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x2712\x27\x3c\/span\x3e)\n    })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大家仔细分析，相比于上一个例子，这里由于存在Promise，所以Other Microtask Queue中也会有回调任务的存在，执行到微任务阶段时，先执行Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务，然后才会进入下一个阶段的宏任务。明白了这一点，相信大家都可以分析出来，下面直接给出正确答案，如有疑问，欢迎留言和我讨论。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确答案\n1\n7\n6\n8\n2\n4\n9\n11\n3\n10\n5\n12\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正确答案\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3esetTimeout 对比 setImmediate\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3esetTimeout(fn, 0)在Timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行\x3c\/li\x3e\n\x3cli\x3esetImmediate(fn)在Check阶段执行\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e两者的执行顺序要根据当前的执行环境才能确定：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机\x3c\/li\x3e\n\x3cli\x3e如果两者都不在主模块调用，即在一个I\/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3esetImmediate 对比 process.nextTick\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3esetImmediate(fn)的回调任务会插入到宏队列Check Queue中\x3c\/li\x3e\n\x3cli\x3eprocess.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中\x3c\/li\x3e\n\x3cli\x3eprocess.nextTick(fn)调用深度有限制，上限是1000，而setImmedaite则没有\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e总结\x3c\/h1\x3e\n\x3col\x3e\n\x3cli\x3e浏览器的Event Loop和NodeJS的Event Loop是不同的，实现机制也不一样，不要混为一谈。\x3c\/li\x3e\n\x3cli\x3e浏览器可以理解成只有1个宏任务队列和1个微任务队列，先执行全局Script代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和Node的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环。\x3c\/li\x3e\n\x3cli\x3eNodeJS可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中依次取出所有的任务放入调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈中执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行（注意，这里和浏览器不一样，浏览器只取一个），6个阶段执行完毕后，再开始执行微任务，以此构成事件循环。\x3c\/li\x3e\n\x3cli\x3eMacroTask包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering\x3c\/li\x3e\n\x3cli\x3eMicrotask包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e参考链接\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/cnodejs.org\/topic\/5a9108d78d6e16e56bb80882\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不要混淆nodejs和浏览器中的event loop\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/SunShinewyf\/issue-blog\/issues\/34#issuecomment-371106502\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode中的Event模块\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/jsblog.insiderattack.net\/promises-next-ticks-and-immediates-nodejs-event-loop-part-3-9226cbe7a6aa\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromises, process.nextTick And setImmediate\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000013660033\x22\x3e浏览器和Node不同的事件循环\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTasks, microtasks, queues and schedules\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/ccforward\/cc\/issues\/47\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e理解事件循环浅析\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016278115">https://segmentfault.com/a/1190000016278115</a></p><h2 id="原文标题">原文标题</h2><p>带你彻底弄懂Event Loop</p><h2>本文链接：</h2><a href="https://alili.tech/archive/bc9bb1af/" target="_blank">https://alili.tech/archive/bc9bb1af/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>