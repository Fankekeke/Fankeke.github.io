<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Flutter中的布局绘制流程简析（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Flutter中的布局绘制流程简析（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bdr5zu2oax4/",
				"appid": "1613049289050283", 
				"title": "Flutter中的布局绘制流程简析（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/kycatxlgoj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lq46mp061w/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&text=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&text=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&title=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&is_video=false&description=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&title=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&title=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&title=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdr5zu2oax4%2f&title=Flutter%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e7%ae%80%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Flutter中的布局绘制流程简析（一）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e开始\x3c\/h1\x3e\n\x3cp\x3eFlutter对比前端流行的框架，除了构建控件树和控件状态管理等，还多了布局和绘制的流程，布局和绘制以往都是前端开发可望而不可及的都被封锁在浏览器渲染引擎的实现里面，而我们只能通过文档或者做一些demo去深入，就像盲人摸象，很多时候都是只知其一不知其二。相对而言，Flutter把这个黑盒打开了，意味着我们可以做更加深入的优化，开发效率也能成倍提高。\x3cbr\x3e接下来就去深入去了解，尽可能把这个过程完整展现给大家。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e入口\x3c\/h1\x3e\n\x3cp\x3e界面的布局和绘制在每一帧都在发生着，甚至界面没有变化，它也会存在；可以想象每一帧里面，引擎都像流水线的一样重复着几个过程：build（构建控件树），layout（布局）, paint（绘制）和 composite（合成），周而复始。那么驱动整个流水线的入口在哪里呢？\x3cbr\x3e直接来到WidgetBinding.drawFrame方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 void drawFrame() {\n    ...\n    try {\n      if (renderViewElement != null)\n        buildOwner.buildScope(renderViewElement);\n      super.drawFrame();\n      buildOwner.finalizeTree();\n    } finally {\n     ...\n    }\n    ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edrawFrame\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (renderViewElement != \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e)\n        buildOwner.buildScope(renderViewElement);\n      \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.drawFrame();\n      buildOwner.finalizeTree();\n    } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n     ...\n    }\n    ...\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里renderViewElement就是Root了，在第一帧的时候，控件树还没有构建，当然也不存在renderViewElement了；而接下来buildOwner这个对象是干嘛的呢？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eBuilderOwner\x3c\/h2\x3e\n\x3cp\x3e先看一下从哪里开始会用到builderOwner的方法：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXQ5e?w=674\x26amp;h=295\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXQ5e?w=674\x26amp;h=295\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到我们经常使用setState方法就与BuilderOwner紧密关联了，接着再看BuilderOwner.scheduleBuildFor方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void scheduleBuildFor(Element element) {\n    ...\n    if (element._inDirtyList) {\n      ...\n      _dirtyElementsNeedsResorting = true;\n      return;\n    }\n    if (!_scheduledFlushDirtyElements \x26amp;\x26amp; onBuildScheduled != null) {\n      _scheduledFlushDirtyElements = true;\n      onBuildScheduled();\n    }\n    _dirtyElements.add(element);\n    element._inDirtyList = true;\n   ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e scheduleBuildFor(Element element) {\n    \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (element._inDirtyList) {\n      \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n      _dirtyElementsNeedsResorting = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_scheduledFlushDirtyElements \x26amp;\x26amp; onBuildScheduled != \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n      _scheduledFlushDirtyElements = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      onBuildScheduled();\n    }\n    _dirtyElements.add(element);\n    element._inDirtyList = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n   \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的处理过程：如果_scheduledFlushDirtyElements不为true，就调起onBuildScheduled方法，并把Elment都加入到_dirtyElements中，那么onBuildScheduled又会干些啥尼？\x3cbr\x3e回到WidgetBinding.initInstances方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 void initInstances() {\n    super.initInstances();\n    ...\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\n    ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitInstances\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.initInstances();\n    ...\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\n    ...\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看到真实调用的是WidgetBinding._handleBuildScheduled方法，我们继续完善刚才的调用过程：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXQ7w?w=921\x26amp;h=562\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXQ7w?w=921\x26amp;h=562\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e所以这里就可以看到我们调用setState方法最终会触发界面新的一帧绘制。\x3c\/p\x3e\n\x3cp\x3e当触发新的一帧时，我们又回到最初的WidgetBinding.drawFrame方法中，那么builderOwner.buildScope方法究竟会干些工作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void buildScope(Element context, [VoidCallback callback]) {\n    if (callback == null \x26amp;\x26amp; _dirtyElements.isEmpty)\n      return;\n    ..l\n    Timeline.startSync(\x27Build\x27, arguments: timelineWhitelistArguments);\n    try {\n      _scheduledFlushDirtyElements = true;\n      if (callback != null) {\n        \n        _dirtyElementsNeedsResorting = false;\n        try {\n          callback();\n        } finally {\n         ...\n        }\n      }\n      _dirtyElements.sort(Element._sort);\n      _dirtyElementsNeedsResorting = false;\n      int dirtyCount = _dirtyElements.length;\n      int index = 0;\n      while (index \x3c dirtyCount) {\n        ...\n        try {\n          _dirtyElements[index].rebuild();\n        } catch (e, stack) {\n          ...\n        }\n        index \x2b= 1;\n        if (dirtyCount \x3c _dirtyElements.length || _dirtyElementsNeedsResorting) {\n          _dirtyElements.sort(Element._sort);\n          _dirtyElementsNeedsResorting = false;\n          dirtyCount = _dirtyElements.length;\n          while (index \x3e 0 \x26amp;\x26amp; _dirtyElements[index - 1].dirty) {\n            index -= 1;\n          }\n        }\n      }\n        ...\n        return true;\n      }());\n    } finally {\n      for (Element element in _dirtyElements) {\n        assert(element._inDirtyList);\n        element._inDirtyList = false;\n      }\n      _dirtyElements.clear();\n      _scheduledFlushDirtyElements = false;\n      _dirtyElementsNeedsResorting = null;\n      Timeline.finishSync();\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3evoid buildScope(Element context, [VoidCallback callback]) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (callback == null \x26amp;\x26amp; \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.isEmpty)\n      return;\n    ..l\n    Timeline.startSync(\x3cspan class=\x22hljs-string\x22\x3e\x27Build\x27\x3c\/span\x3e, arguments: timelineWhitelistArguments);\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-variable\x22\x3e_scheduledFlushDirtyElements\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (callback != null) {\n        \n        \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElementsNeedsResorting\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n          callback();\n        } finally {\n         ...\n        }\n      }\n      \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esort\x3c\/span\x3e(Element.\x3cspan class=\x22hljs-variable\x22\x3e_sort\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElementsNeedsResorting\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      int dirtyCount = \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.length;\n      int index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (index \x26lt; dirtyCount) {\n        ...\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e[index].rebuild();\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e, stack) {\n          ...\n        }\n        index \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dirtyCount \x26lt; \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.length || \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElementsNeedsResorting\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esort\x3c\/span\x3e(Element.\x3cspan class=\x22hljs-variable\x22\x3e_sort\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElementsNeedsResorting\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n          dirtyCount = \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.length;\n          \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (index \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e[index - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].dirty) {\n            index -= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n          }\n        }\n      }\n        ...\n        return \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      }());\n    } finally {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (Element element \x3cspan class=\x22hljs-built_in\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eassert\x3c\/span\x3e(element.\x3cspan class=\x22hljs-variable\x22\x3e_inDirtyList\x3c\/span\x3e);\n        element.\x3cspan class=\x22hljs-variable\x22\x3e_inDirtyList\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      }\n      \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElements\x3c\/span\x3e.clear();\n      \x3cspan class=\x22hljs-variable\x22\x3e_scheduledFlushDirtyElements\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-variable\x22\x3e_dirtyElementsNeedsResorting\x3c\/span\x3e = null;\n      Timeline.finishSync();\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先把_scheduledFlushDirtyElements标记设为true，表示正在从新构建新的控件树，然后_dirtyElements会做一轮排序，看一下Element._sort的方法如何实现的:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22static int _sort(Element a, Element b) {\n    if (a.depth \x3c b.depth)\n      return -1;\n    if (b.depth \x3c a.depth)\n      return 1;\n    if (b.dirty \x26amp;\x26amp; !a.dirty)\n      return -1;\n    if (a.dirty \x26amp;\x26amp; !b.dirty)\n      return 1;\n    return 0;\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3estatic int _sort(Element a, Element b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a.depth \x26lt; b.depth)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (b.depth \x26lt; a.depth)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (b.dirty \x26amp;\x26amp; !a.dirty)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a.dirty \x26amp;\x26amp; !b.dirty)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e嗯，因为在这里最初排序都是标记为dirty的Element，所以最后的结果是，depth小的Element会排最前，depth大的排最后；也就是说父Element会比子Element更早被rebuild，这样可以防止子Element会重复rebuild。\x3cbr\x3e当在rebuild过程中有可能会加入新的Dirty Element，所以每次rebuild的时候都会重新检查_dirtyElements是否有增加或者检查_dirtyElementsNeedsResorting标记位，接着从新排序一遍，这个时候我们的_dirtyElements列表中就有可能存在之前已经rebuild完，dirty为false的Element了，重新排序后，depth小的和dirty不为true的会排最前，重新把index定位到第一个Dirty Element继续rebuild。\x3cbr\x3e如果在这个过程我们想把已经rebuild过一次的Element想重复加入到_dirtyElements中，形成死循环，会怎样的尼，这个时候Element._inDirtyList还是为true，表明Element已经在_dirtyElements列表中，在开发模式下引擎会报错，给出相应提示；一般情况下是不应该出现的，万一出现就需要思考一下代码是否合理了。\x3c\/p\x3e\n\x3cp\x3e接着先跳过super.drawFrame方法，来到builderOwner.finalizeTree方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void finalizeTree() {\n    Timeline.startSync(\x27Finalize tree\x27, arguments: timelineWhitelistArguments);\n    try {\n      lockState(() {\n        _inactiveElements._unmountAll(); \/\/ this unregisters the GlobalKeys\n      });\n     ...\n    } catch (e, stack) {\n      _debugReportException(\x27while finalizing the widget tree\x27, e, stack);\n    } finally {\n      Timeline.finishSync();\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3efinalizeTree\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3eTimeline\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.startSync\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Finalize tree\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3earguments\x3c\/span\x3e: timelineWhitelistArguments);\n    \x3cspan class=\x22hljs-selector-tag\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-selector-tag\x22\x3elockState\x3c\/span\x3e(() {\n        \x3cspan class=\x22hljs-selector-tag\x22\x3e_inactiveElements\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e._unmountAll\x3c\/span\x3e(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this unregisters the GlobalKeys\x3c\/span\x3e\n      });\n     ...\n    } \x3cspan class=\x22hljs-selector-tag\x22\x3ecatch\x3c\/span\x3e (e, stack) {\n      \x3cspan class=\x22hljs-selector-tag\x22\x3e_debugReportException\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27while finalizing the widget tree\x27\x3c\/span\x3e, e, stack);\n    } \x3cspan class=\x22hljs-selector-tag\x22\x3efinally\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-selector-tag\x22\x3eTimeline\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.finishSync\x3c\/span\x3e();\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e主要把_inactiveElements都进行一次清理，所以使用GlobalKey的控件，如果想起到重用控件的效果，必须在同一帧里面完成“借用”，否则就会被清理了。\x3c\/p\x3e\n\x3cp\x3e简单总结一下BuilderOwner的功能就是：管理控件rebuild过程，让控件有序的进行rebuild。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3ePipelineOwner\x3c\/h2\x3e\n\x3cp\x3e终于来到super.drawFrame方法，这个方法实际上调起的是RenderBinding.drawFrame方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void drawFrame() {\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); \/\/ this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); \/\/ this also sends the semantics to the OS.\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3edrawFrame\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3epipelineOwner\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.flushLayout\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-selector-tag\x22\x3epipelineOwner\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.flushCompositingBits\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-selector-tag\x22\x3epipelineOwner\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.flushPaint\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-selector-tag\x22\x3erenderView\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.compositeFrame\x3c\/span\x3e(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this sends the bits to the GPU\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3epipelineOwner\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.flushSemantics\x3c\/span\x3e(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this also sends the semantics to the OS.\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们又见到一个跟BuilderOwner名称很相似的PipelineOwner，那PipelineOwner又起到什么样的功能尼？直接深入\x3cbr\x3epipelineOwner.flushLayout方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void flushLayout() {\n    Timeline.startSync(\x27Layout\x27, arguments: timelineWhitelistArguments);\n    _debugDoingLayout = true;\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List\x3cRenderObject\x3e dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = \x3cRenderObject\x3e[];\n        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =\x3e a.depth - b.depth)) {\n          if (node._needsLayout \x26amp;\x26amp; node.owner == this)\n            node._layoutWithoutResize();\n        }\n      }\n    } finally {\n      _debugDoingLayout = false;\n      Timeline.finishSync();\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3evoid flushLayout() {\n    Timeline.startSync(\x27Layout\x27, arguments: timelineWhitelistArguments);\n    _debugDoingLayout = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;RenderObject\x26gt;\x3c\/span\x3e dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;RenderObject\x26gt;\x3c\/span\x3e[];\n        for (RenderObject \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ein\x3c\/span\x3e dirtyNodes..sort((RenderObject a, RenderObject b) =\x26gt; a.depth - b.depth)) {\n          if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3e_needsLayout\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eowner\x3c\/span\x3e == this)\n            \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3e_layoutWithoutResize\x3c\/span\x3e();\n        }\n      }\n    } finally {\n      _debugDoingLayout = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      Timeline.finishSync();\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e跟builderOwner处理相似，先进行一次排序，depth小的排最前优先处理，然后调起RenderObject._layoutWithoutResize方法。\x3c\/p\x3e\n\x3cp\x3e暂时先整理一下，这个时候我们出现三个名词：Widget，Element，RenderObject；它们的关系究竟是咋样的尼，假设你熟悉前端的Vue或者React框架，它们的关系等同于下面这张图:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXR9T?w=790\x26amp;h=329\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXR9T?w=790\x26amp;h=329\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e也就是说RenderObject负责着界面的布局绘制和事件处理等；而Element则是进行virtual dom diff，并且负责创建RenderObject；Widget则是我们控件业务逻辑组织的地方， 负责创建Element。\x3c\/p\x3e\n\x3cp\x3e大概可以想到PipelineOwner的主要功能：负责管理那些dirty render object，让它们进行布局和绘制。\x3c\/p\x3e\n\x3cp\x3e接着RenderObject._layoutWithoutResize方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void _layoutWithoutResize() {\n    ...\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException(\x27performLayout\x27, e, stack);\n    }\n    ...\n    _needsLayout = false;\n    markNeedsPaint();\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e _layoutWithoutResize() {\n    \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, \x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e) {\n      _debugReportException(\x3cspan class=\x22hljs-string\x22\x3e\x27performLayout\x27\x3c\/span\x3e, e, \x3cspan class=\x22hljs-built_in\x22\x3estack\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n    _needsLayout = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    markNeedsPaint();\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到其实直接调用了RenderObject.performLayout方法，而这个方法则是应由开发者自己实现的布局逻辑，接着会调起RenderObject.markNeedsPaint方法，也就是说每次重新layout都会触发一次paint。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void markNeedsPaint() {\n    if (_needsPaint)\n      return;\n    _needsPaint = true;\n    if (isRepaintBoundary) {\n      if (owner != null) {\n        owner._nodesNeedingPaint.add(this);\n        owner.requestVisualUpdate();\n      }\n    } else if (parent is RenderObject) {\n      final RenderObject parent = this.parent;\n      parent.markNeedsPaint();\n    } else {\n      if (owner != null)\n        owner.requestVisualUpdate();\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3evoid markNeedsPaint() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_needsPaint)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    _needsPaint = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isRepaintBoundary) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (owner != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        owner._nodesNeedingPaint.add(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        owner.requestVisualUpdate();\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e RenderObject) {\n      \x3cspan class=\x22hljs-keyword\x22\x3efinal\x3c\/span\x3e RenderObject parent = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent;\n      parent.markNeedsPaint();\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (owner != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n        owner.requestVisualUpdate();\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的逻辑，主要判断当前的RenderObject.isRepaintBoundary是否为true，如果是则把当前RenderObject加入到PipelineOwner对应的列表中等待接下来的flushPaint处理，并触发下一帧的绘制；当isRepaintBoundary不为true的时候，则会一直往上查找直到找到isRepaintBoundary为true的RenderObject，也就是有可能会找到根节点RenderView，然后加入到_nodesNeedingPaint列表中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class RenderView extends RenderObject with RenderObjectWithChildMixin\x3cRenderBox\x3e {\n    ...\n    bool get isRepaintBoundary =\x3e true;\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRenderView\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRenderObject\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRenderObjectWithChildMixin\x26lt;RenderBox\x26gt;\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n    bool get isRepaintBoundary =\x26gt; \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的话我们就得注意了，如果经常需要重绘区域，最好把isRepaintBoundary标记true，这样就尽量避免触发全局重绘，提高性能，对应的flutter就已经提供了一个RepaintBoundary控件，自动把isRepaintBoundary标记为true，非常方便我们去做优化。\x3c\/p\x3e\n\x3cp\x3e既然有markNeedsPaint方法，当然也有markNeedsLayout方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void markNeedsLayout() {\n    if (_needsLayout) {\n      return;\n    }\n    if (_relayoutBoundary != this) {\n      markParentNeedsLayout();\n    } else {\n      _needsLayout = true;\n      if (owner != null) {\n        ...\n        owner._nodesNeedingLayout.add(this);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emarkNeedsLayout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_needsLayout) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_relayoutBoundary != \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) {\n      markParentNeedsLayout();\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      _needsLayout = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (owner != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        ...\n        owner._nodesNeedingLayout.\x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e处理逻辑基本上跟markNeedsPaint差不多，_relayoutBoundary也可以减少全局重新布局，可以把布局范围缩小，提高性能，但是_relayoutBoundary的设置是有点不一样的，等会再去讨论。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e简单整理一下\x3c\/h2\x3e\n\x3cp\x3e当我们用调起setState改变某些状态，例如：控件的高度；先回到BuilderOwner.buildScope，继续dirty element的rebuild方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void rebuild() {\n    if (!_active || !_dirty)\n      return;\n    performRebuild();\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erebuild\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_active || !_dirty)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    performRebuild();\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着执行performRebuild方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  void performRebuild() {\n    Widget built;\n    try {\n      built = build();\n      debugWidgetBuilderValue(widget, built);\n    } catch (e, stack) {\n      _debugReportException(\x27building $this\x27, e, stack);\n      built = new ErrorWidget(e);\n    } finally {\n      \/\/ We delay marking the element as clean until after calling build() so\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\n      _dirty = false;\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\n    }\n    try {\n      _child = updateChild(_child, built, slot);\n      assert(_child != null);\n    } catch (e, stack) {\n      _debugReportException(\x27building $this\x27, e, stack);\n      built = new ErrorWidget(e);\n      _child = updateChild(null, built, slot);\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3e  void performRebuild() {\n    Widget built;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      built = build();\n      debugWidgetBuilderValue(widget, built);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e, stack) {\n      \x3cspan class=\x22hljs-variable\x22\x3e_debugReportException\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27building $this\x27\x3c\/span\x3e, e, stack);\n      built = new ErrorWidget(e);\n    } finally {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We delay marking the element as clean until after calling build() so\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ that attempts to markNeedsBuild() during build() will be ignored.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-variable\x22\x3e_dirty\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-built_in\x22\x3eassert\x3c\/span\x3e(\x3cspan class=\x22hljs-variable\x22\x3e_debugSetAllowIgnoredCallsToMarkNeedsBuild\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e));\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-variable\x22\x3e_child\x3c\/span\x3e = updateChild(\x3cspan class=\x22hljs-variable\x22\x3e_child\x3c\/span\x3e, built, slot);\n      \x3cspan class=\x22hljs-built_in\x22\x3eassert\x3c\/span\x3e(\x3cspan class=\x22hljs-variable\x22\x3e_child\x3c\/span\x3e != null);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e, stack) {\n      \x3cspan class=\x22hljs-variable\x22\x3e_debugReportException\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27building $this\x27\x3c\/span\x3e, e, stack);\n      built = new ErrorWidget(e);\n      \x3cspan class=\x22hljs-variable\x22\x3e_child\x3c\/span\x3e = updateChild(null, built, slot);\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控件会重新build出子控件树，然后调起updateChild方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 Element updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    if (newWidget == null) {\n      if (child != null)\n        deactivateChild(child);\n      return null;\n    }\n    if (child != null) {\n      if (child.widget == newWidget) {\n        if (child.slot != newSlot)\n          updateSlotForChild(child, newSlot);\n        return child;\n      }\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        if (child.slot != newSlot)\n          updateSlotForChild(child, newSlot);\n        child.update(newWidget);\n        return child;\n      }\n      deactivateChild(child);\n    }\n    return inflateWidget(newWidget, newSlot);\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e Element updateChild(Element child, Widget \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3edynamic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n        deactivateChild(child);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child.widget == \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child.slot != \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e)\n          updateSlotForChild(child, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e child;\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Widget.canUpdate(child.widget, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child.slot != \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e)\n          updateSlotForChild(child, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e);\n        child.update(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e child;\n      }\n      deactivateChild(child);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e inflateWidget(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e);\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e如果newWidget为null但是child不为null，也就是删除原来的控件，就会调起deactivateChild方法，会把当前的Element加入到BuilderOwner._inactiveElements列表中（最后可能会被清除也可能会被重用）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果newWidget和child都不为null，也就是更新原来的控件，先调起Widget.canUpdate方法判断是否能够更新（一般都是根据Widget运行时类型是否相同来判断），如果相同调起update方法，继续更新的逻辑，如果不一样，就要deactivate原来的控件，并且创建新的控件。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果child为null而Widegt不为null，也就是要创建新的控件。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e接下来会分别分析更新的逻辑和创建的逻辑：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e更新\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e直接来到StatefulElement.update方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void update(StatefulWidget newWidget) {\n    super.update(newWidget);\n    final StatefulWidget oldWidget = _state._widget;\n    _dirty = true;\n    _state._widget = widget;\n    try {\n      _state.didUpdateWidget(oldWidget);\n    } finally {\n    }\n    rebuild();\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3evoid update(StatefulWidget newWidget) {\n    super.update(newWidget);\n    final StatefulWidget oldWidget = \x3cspan class=\x22hljs-variable\x22\x3e_state\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_widget\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-variable\x22\x3e_dirty\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-variable\x22\x3e_state\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_widget\x3c\/span\x3e = widget;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-variable\x22\x3e_state\x3c\/span\x3e.didUpdateWidget(oldWidget);\n    } finally {\n    }\n    rebuild();\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里首先会调起一个控件很重要的生命回调didUpdateWidget，综合上述可以知道，这里是当新的子控件和旧的子控件类型一致时才会调起；接着就是子控件的rebuild过程，然后不停重复下去。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e创建\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e直接来到Element.inflateWidget方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Element inflateWidget(Widget newWidget, dynamic newSlot) {\n    final Key key = newWidget.key;\n    if (key is GlobalKey) {\n      final Element newChild = _retakeInactiveElement(key, newWidget);\n      if (newChild != null) {\n        newChild._activateWithParent(this, newSlot);\n        final Element updatedChild = updateChild(newChild, newWidget, newSlot)\n        return updatedChild;\n      }\n    }\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3eElement inflateWidget(Widget \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3edynamic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e) {\n    final Key key = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e.key;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key is GlobalKey) {\n      final Element \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e = _retakeInactiveElement(key, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e._activateWithParent(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e);\n        final Element updatedChild = updateChild(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e updatedChild;\n      }\n    }\n    final Element \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e.createElement();\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e.mount(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eChild\x3c\/span\x3e;\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里判断key是否为GlobalKey，如果是会调起_retakeInactiveElement方法，目的是从Globalkey上重用控件，并把控件从BuilderOwner._inactiveElements列表上移除，防止它被unmount，接着就是从新跑一次updateChild流程；如果不是就在新的子控件上创建新的Element,并且mount上去。\x3c\/p\x3e\n\x3cp\x3e但是如果多个child的时候是怎么更新的尼？\x3cbr\x3e来到MultiChildRenderObjectElement.update方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void update(MultiChildRenderObjectWidget newWidget) {\n    super.update(newWidget);\n    _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);\n    _forgottenChildren.clear();\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3evoid update(MultiChildRenderObjectWidget \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.update(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e);\n    _children = updateChildren(_children, widget.children, forgottenChildren: \x3cspan class=\x22hljs-type\x22\x3e_forgottenChildren\x3c\/span\x3e);\n    _forgottenChildren.clear();\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e框架里面好像只规定跟RenderObject相关的控件才可以支持多个child，而updateChildren就是一个flutter版本的virtual dom diff算法的实现。\x3c\/p\x3e\n\x3cp\x3e刚才假设我们需要修改控件的高度，既然跟显示有关，必然跟RenderObejct相关，直接来到RenderObjectElement.update方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void update(covariant RenderObjectWidget newWidget) {\n    super.update(newWidget);\n    widget.updateRenderObject(this, renderObject);\n    _dirty = false;\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3evoid update(covariant RenderObjectWidget \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.update(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eWidget\x3c\/span\x3e);\n    widget.updateRenderObject(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, renderObject);\n    _dirty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后调起的是RenderObjectWidget.updateRenderObject方法，在这里我们可以得到新创建的RenderObject，我们在这里把新的RenderObject的属性赋值给旧的RenderObject，而在RenderObject相关属性的setter方法中会调起markNeedsLayout方法，这样在下一帧布局绘制的时候就会生效。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Flutter中的布局绘制流程简析（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011912538">https://segmentfault.com/a/1190000011912538</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bdr5zu2oax4/" target="_blank">https://alili.tech/archive/bdr5zu2oax4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>