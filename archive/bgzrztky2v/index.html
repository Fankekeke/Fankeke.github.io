<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Express 实战（二）：Node.js 基础"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Express 实战（二）：Node.js 基础 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bgzrztky2v/",
				"appid": "1613049289050283", 
				"title": "Express 实战（二）：Node.js 基础 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-03T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bv67m1nmtoq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/89u6woy7q88/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&text=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&text=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&title=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&is_video=false&description=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&title=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&title=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&title=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbgzrztky2v%2f&title=Express%20%e5%ae%9e%e6%88%98%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aNode.js%20%e5%9f%ba%e7%a1%80"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Express 实战（二）：Node.js 基础</h1><div class="meta"><div class="postdate"><time datetime="2019-01-03" itemprop="datePublished">2019-01-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在上一篇\x3ca href=\x22https:\/\/bignerdcoding.com\/archives\/Express-shi-zhan-yi-gai-lan.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文章\x3c\/a\x3e中，我们简单的介绍了 Node.js 。了解到它基于 JavaScript、天生异步、拥有大量的第三方类库。本文将会在之前的基础上，对 Node.js 进行更深入的介绍。其中主要内容包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eNode 的安装\x3c\/li\x3e\n\x3cli\x3e如何使用第三方模块生态\x3c\/li\x3e\n\x3cli\x3e第三方模块的安装\x3c\/li\x3e\n\x3cli\x3e一些简单的使用示例\x3c\/li\x3e\n\x3cli\x3e开发过程中的一些建议和技巧\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在此之前，我假设你已经掌握了 JavaScript 基础知识并且熟悉一些基本的命令行操作。另外，不要臆想通过这一章就全面掌握 Node。但是如果你有心的话，可以去阅读 \x3cstrong\x3eNode.js 实战\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x26lt;!--more--\x26gt;\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e安装Node\x3c\/h2\x3e\n\x3cp\x3eJavaScript 世界的一大特点就是它选择性非常多，Node 的安装也不例外。\x3c\/p\x3e\n\x3cp\x3e可以在官方下载\x3ca href=\x22https:\/\/nodejs.org\/download\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e页面\x3c\/a\x3e找到各种版本的源代码和安装包文件。建议你使用与自己操作系统对应的安装包进行安装。当然，你也可用使用 apt-get、Homebrew  等包管理器进行安装，如果你系统有的话。具体详见官方的包管理工具的安装\x3ca href=\x22https:\/\/nodejs.org\/en\/download\/package-manager\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e指南\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e如果你使用的是 Mac 或者 Linux 的话，那么我极力推荐你使用 \x3ca href=\x22https:\/\/github.com\/creationix\/nvm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNVM\x3c\/a\x3e 来安装。Window 系统上的对应程序是 \x3ca href=\x22https:\/\/github.com\/hakobera\/nvmw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNVMW\x3c\/a\x3e。这些版本管理工具，让你可以在不同版本间进行自由切换。例如，你可以在尝试新版本的特性时，同时在系统中保留一份稳定版。另外，NVM 无需系统管理权限同时卸载也非常容易。而安装过程也只需在终端执行一行命令。\x3c\/p\x3e\n\x3cp\x3e现在，请在你系统中安装好 Node。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e运行你的第一个Node脚本\x3c\/h3\x3e\n\x3cp\x3e安装完成后，先动手写个 \x22Hello World\x22 来检验一些。在新建的 \x3cem\x3ehelloworld.js\x3c\/em\x3e 中加入一下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x26quot;Hello, World!\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, World!\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码中主要就是使用 \x3cem\x3econsole.log\x3c\/em\x3e 来打印字符串 \x22Hello,world!\x22，相信对于前端程序员来说并不会感到陌生。下面我们使用 \x3cem\x3enode helloworld.js\x3c\/em\x3e 运行代码。如果一切正常的话，会出现如下输出：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010819186\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010819186\x22 alt=\x2202_01\x22 title=\x2202_01\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e模块的使用\x3c\/h2\x3e\n\x3cp\x3e在大多数编程语言中，我们都会对代码进行拆分，然后在使用的时候将这些文件引入其中。例如，C 和 C\x2b\x2b 中的 include，Python 的 import ，Ruby 和 PHP 中的 require。而另外一些语言，如 C# 是在编译时完成跨文件引用的。\x3c\/p\x3e\n\x3cp\x3e很长一段时间内，JavaScript 官方并不支持模块机制。所以社区中有人就编写了 RequireJS 这种工具来解决依赖项导入的问题。但是，大多数时候还是通过 \x3cem\x3e\x26lt;script\x26gt;\x3c\/em\x3e 标签来进行文件导入。而Node 通过实现名为 CommonJS 的标准模块，完美的解决了模块导入问题。\x3c\/p\x3e\n\x3cp\x3e模块系统部分主要有三大主要内容：内置模块的引入，第三方模块引入，个人私有模块引入。下面，将会对这些内容逐一介绍。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e引入内置模块\x3c\/h3\x3e\n\x3cp\x3eNode 已经内置了很多实用模块，例如，文件系统模块 \x3cem\x3efs\x3c\/em\x3e，工具函数模块 \x3cem\x3eutil\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e在 Node 编写的 Web 应用中，最常见的任务当属 URL 解析了。浏览器通过特定的 URL 来请求服务器上对应的资源。例如，访问主页、访问关于页面 的网络请求。这些 URL 都以字符串的形式存在，我们需要对其进行解析然后获取更多的信息。这里我们通过对 URL 进行解析来介绍如何引入内置模块。\x3c\/p\x3e\n\x3cp\x3e内置的 \x3cem\x3eurl\x3c\/em\x3e 模块中暴露的方法不多，不过其中有一个 \x3cem\x3eparse\x3c\/em\x3e 函数非常有用。它能从 URL 字符串中提取到类似域名和路径等有益信息。\x3c\/p\x3e\n\x3cp\x3e这里我们使用 \x3cem\x3erequire\x3c\/em\x3e 来实现模块导入，该命令与之前提到的 Include、Import 的作用一致。通过将模块名作为参数，该命令就能成功的返回对应的模块。大多数情况下，该返回的对象是一个 \x3cem\x3eobject\x3c\/em\x3e 对象，但有时也可能会是字符串、数字、或者函数。下面是引入改模块的示例代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var url = require(\x26quot;url\x26quot;);\x26nbsp;\x26nbsp; \nvar parsedURL = url.parse(\x26quot;http:\/\/www.example.com\/profile?name=barry\x26quot;);\x26nbsp; \n\x26nbsp;\nconsole.log(parsedURL.protocol);\x26nbsp; \/\/ \x26quot;http:\x26quot;\nconsole.log(parsedURL.host);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;  \/\/ \x26quot;www.example.com\x26quot;\nconsole.log(parsedURL.query);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \/\/ \x26quot;name=barry\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e url = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22url\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp; \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parsedURL = url.parse(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.example.com\/profile?name=barry\x22\x3c\/span\x3e);\x26nbsp; \n\x26nbsp;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(parsedURL.protocol);\x26nbsp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22http:\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(parsedURL.host);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22www.example.com\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(parsedURL.query);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22name=barry\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的代码中，通过 \x3cem\x3erequire(\x22url\x22)\x3c\/em\x3e 返回一个模块对象，然后就可以像使用其他对象一样调用对象的方法。将这段代码保存到 \x3cem\x3eurl-test.js\x3c\/em\x3e 中并使运行 \x3cem\x3enode url-test.js\x3c\/em\x3e 命令，你就会看到协议名，域名、查询条件。\x3c\/p\x3e\n\x3cp\x3e另外，绝大多数时候我们在引入模块的时候会用一个同名的变量来接受返回的模块对象。例如，上面就使用 \x3cem\x3eurl\x3c\/em\x3e 来介绍 \x3cem\x3erequire(\x22url\x22)\x3c\/em\x3e 的返回值。当然，你完全可以不遵循上面的规则。如果你想的话，你也可以这么干：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var theURLModule = require(\x26quot;url\x26quot;);\x26nbsp;\x26nbsp; \nvar parsedURL = theURLModule.parse(\x26quot;http:\/\/www.example.com\/profile?name=barry\x26quot;);\x26nbsp; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e theURLModule = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22url\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp; \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parsedURL = theURLModule.parse(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.example.com\/profile?name=barry\x22\x3c\/span\x3e);\x26nbsp; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e保存变量名和模块名一致只是一个统一风格增加可读性的宽松约定，而不是什么强制规范。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e使用 npm 和 package.json 引入第三方模块\x3c\/h3\x3e\n\x3cp\x3eNode 的内置模块远远不能满足日常开发需要，所以引入第三方模块是一个必须要掌握的技能。\x3c\/p\x3e\n\x3cp\x3e首先，我们需要了解 package.json 文件。所有的 Node 项目都单独存放在一个文件夹中，而项目如果使用了第三方模块，那么其中必定存在一个名为 package.json 的文件。package.json 中的内容非常的简单，一般其中定义了项目名称、版本号、作者，已经项目的外部依赖项。\x3c\/p\x3e\n\x3cp\x3e在新建的 Node 工程文件夹中，将下面的内容复制到 package.json 中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n\x26nbsp; \x26quot;name\x26quot;: \x26quot;my-fun-project\x26quot;,\x26nbsp;\x26nbsp; \n\x26nbsp; \x26quot;author\x26quot;: \x26quot;Evan Hahn\x26quot;,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x26quot;private\x26quot;: true,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x26quot;version\x26quot;: \x26quot;0.2.0\x26quot;,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x26quot;dependencies\x26quot;: {}\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22JSON\x22\x3e{\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22name\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22my-fun-project\x22\x3c\/span\x3e,\x26nbsp;\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22author\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Evan Hahn\x22\x3c\/span\x3e,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22private\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x220.2.0\x22\x3c\/span\x3e,\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22dependencies\x22\x3c\/span\x3e: {}\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实，在进行 Node 安装时实际上还安装了另一个程序：npm 。通常 npm 都被称为 Node 包管理器，而这也是它最大的特色。假设，现在需要在应用中导入一个小型的标准模版系统 \x3ca href=\x22https:\/\/mustache.github.io\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMustache\x3c\/a\x3e。它能将模版字符串转化为真正的字符串，请看代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Returns \x26quot;Hello, Nicholas Cage!\x26quot;\nMustache.render(\x26quot;Hello, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x26quot;, {\n\x26nbsp; first: \x26quot;Nicholas\x26quot;,\n\x26nbsp; last: \x26quot;Cage\x26quot;\n});\n\x26nbsp;\n\/\/ Returns \x26quot;Hello, Sheryl Sandberg!\x26quot;\nMustache.render(\x26quot;Hello, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x26quot;, {\n\x26nbsp; first: \x26quot;Sheryl\x26quot;,\n\x26nbsp; last: \x26quot;Sandberg\x26quot;\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Returns \x22Hello, Nicholas Cage!\x22\x3c\/span\x3e\nMustache.render(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x22\x3c\/span\x3e, {\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Nicholas\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Cage\x22\x3c\/span\x3e\n});\n\x26nbsp;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Returns \x22Hello, Sheryl Sandberg!\x22\x3c\/span\x3e\nMustache.render(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x22\x3c\/span\x3e, {\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Sheryl\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Sandberg\x22\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，假设你想通过 Mustache 模块来编写一个简单的 Node 应用来欢迎 Nicolas Cage。\x3c\/p\x3e\n\x3cp\x3e首先，在工程文件夹的根目录里运行 \x3cem\x3enpm install mustache --save\x3c\/em\x3e 。该命令会新建一个 \x3cem\x3enode_modules\x3c\/em\x3e 文件夹并将 Mustache 保存到文件夹下。 \x3cem\x3e--save\x3c\/em\x3e 参数将会把该模块添加到 pakage.json 文件中。此时 pakage.json 文件夹大致如下，其中 Mustache 会使用最新的版本。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n\x26nbsp; \x26quot;name\x26quot;: \x26quot;my-fun-project\x26quot;,\n\x26nbsp; \x26quot;author\x26quot;: \x26quot;Evan Hahn\x26quot;,\n\x26nbsp; \x26quot;private\x26quot;: true,\n\x26nbsp; \x26quot;version\x26quot;: \x26quot;0.2.0\x26quot;,\n\x26nbsp; \x26quot;dependencies\x26quot;: {\n\x26nbsp;\x26nbsp;\x26nbsp; \x26quot;mustache\x26quot;: \x26quot;^2.0.0\x26quot;\x26nbsp; #A\n\x26nbsp; }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22JSON\x22\x3e{\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22name\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22my-fun-project\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22author\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Evan Hahn\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22private\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x220.2.0\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22dependencies\x22\x3c\/span\x3e: {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3e\x22mustache\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22^2.0.0\x22\x3c\/span\x3e\x26nbsp; #A\n\x26nbsp; }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你没有使用 \x3cem\x3e--save\x3c\/em\x3e 选项的话，虽然也会创建 \x3cem\x3enode_modules\x3c\/em\x3e 文件夹将把 Mustache 模块保存到同名子目录下，但是 pakage.json 将不会发生任何变化。这里之所以将这些依赖关系保存到 package.json 是为了方便其他开发者在得到工程后直接使用 \x3cem\x3enpm install\x3c\/em\x3e 完成所有依赖项的安装。另一个原因是 Node 项目在进行代码管理时通常都会忽略 node_modules 文件夹而只保留 package.json。\x3c\/p\x3e\n\x3cp\x3e安装完成后接下来就是使用了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Mustache = require(\x26quot;mustache\x26quot;);\x26nbsp; \nvar result = Mustache.render(\x26quot;Hi, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x26quot;, {\n\x26nbsp; first: \x26quot;Nicolas\x26quot;,\n\x26nbsp; last: \x26quot;Cage\x26quot;\n});\nconsole.log(result);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Mustache = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mustache\x22\x3c\/span\x3e);\x26nbsp; \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = Mustache.render(\x3cspan class=\x22hljs-string\x22\x3e\x22Hi, \x22{{\x22first\x22}}\x22 \x22{{\x22last\x22}}\x22!\x22\x3c\/span\x3e, {\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Nicolas\x22\x3c\/span\x3e,\n\x26nbsp; \x3cspan class=\x22hljs-attr\x22\x3elast\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Cage\x22\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e保存代码到 mustache-test.js 中并执行 \x3cem\x3enode mustache-test.js\x3c\/em\x3e 命令。然后你将会看见 Hi,Nicolas Cage! 。\x3c\/p\x3e\n\x3cp\x3e就是这样简单，这些依赖项安装完成后，你可以像使用内置模块一样进行调用。\x3cem\x3enode_modules\x3c\/em\x3e 中模块引入的工作直接交给 Node 就行了，你无需担心。\x3c\/p\x3e\n\x3cp\x3e当然你可以手动添加工程依赖项，并且你还可以指定依赖项的版本。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3enpm init\x3cbr\x3e除了安装依赖项之外，npm 还能完成其他任务。例如，自动生成 package.json 而不是通过手动编辑的方式。在一个新工程的文件夹中可以通过 \x3cem\x3enpm init\x3c\/em\x3e 来配置工程名、作者、版本等信息，然后 npm 就会自定生成对应的 package.json 文件。这种自动化过程可以节约开发者的时间。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e实现私有模块\x3c\/h3\x3e\n\x3cp\x3e前面都是介绍如何使用他人开发好的模块，接下来你将会学到如何去开发一个私有模块。假设现在需要随机返回 0 ~ 100 之间的整数。在不引入其他模块的情况下，代码大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MAX = 100;\nfunction randomInteger()  {\n    return Math.floor( (Math.random() * MAX) );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MAX = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erandomInteger\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)  \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor( (\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * MAX) );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这可能与你在浏览器环境下代码差不多，并没有什么特别之处。但是在 Node 中，我们还需要暴露一个变量给外部使用。这样当其他程序在通过 \x3cem\x3erequire\x3c\/em\x3e 进行引入的时候就能获得该变量。此例中，我们暴露函数 \x3cem\x3erandomInteger\x3c\/em\x3e 并将代码保存到 \x3cem\x3erandom-integer.js\x3c\/em\x3e 文件中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MAX = 100;\nfunction randomInteger()  {\n    return Math.floor( (Math.random() * MAX) );\n}\n\nmodule.exports = randomInteger;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MAX = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erandomInteger\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)  \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor( (\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * MAX) );\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = randomInteger;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一行代码对于 Node 初学者来说可能感觉有点陌生。每个模块只能暴露一个变量，而且必须通过 module.exports 设置。本例中只暴露了一个函数变量，所以 MAX 就作为模块私有变量无法被其他文件所访问。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3emodule.exports 可以暴露任何变量，虽然本例中是一个函数，但是通常都会是一个对象。当然，你可以暴露字符串或者数组。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e接下来我们就来使用一下这个新模块。在 \x3cem\x3erandom-integer.js\x3c\/em\x3e 同一目录下，新建一个 \x3cem\x3eprint-three-random-integers.js\x3c\/em\x3e 并复制下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var randomInt = require(\x26quot;.\/random-integer\x26quot;);\x26nbsp; #A\nconsole.log(randomInt());\x26nbsp; \/\/ 12\nconsole.log(randomInt());\x26nbsp; \/\/ 77\nconsole.log(randomInt());\x26nbsp; \/\/ 8\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e randomInt = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/random-integer\x22\x3c\/span\x3e);\x26nbsp; #A\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(randomInt());\x26nbsp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 12\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(randomInt());\x26nbsp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 77\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(randomInt());\x26nbsp; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 8\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了需要通过点语法指定相对路径之外，其余部分与前面几乎一摸一样。通过 \x3cem\x3enode print-three-random-integers.js\x3c\/em\x3e 命令，我们可以检查程序的运行效果。不出意外的话，将会有三个 0 ～ 100 之间的随机数会被打印出来。\x3c\/p\x3e\n\x3cp\x3e如果你尝试运行 \x3cem\x3enode random-integer.js\x3c\/em\x3e 的话，你还发现并没有任何事情发生。虽然，我们暴露了模块中的函数，但是改函数并不会执行更不会打印任何输出。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注意，这里只涉及了私有模块在工程中的使用。如果你希望将自己的模块发布出去供其他人使用的话，可以去我的个人\x3ca href=\x22http:\/\/evanhahn.com\/make-an-npm-baby\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e站点\x3c\/a\x3e查看相关内容。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e以上部分就是 Node 模块系统的简单入门。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eNode：异步的世界\x3c\/h2\x3e\n\x3cp\x3e在第一章中，我用 “烤松饼” 的例子简单的介绍了 Node 中的异步特性。其中的关键点就是，你无法同时做两件事哪怕它们是同时发生的。虽然，在烘焙过程中我可以健身，但是，烤箱毕竟只是个外部事物。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010819187\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010819187\x22 alt=\x2202_02\x22 title=\x2202_02\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eNode 的异步工作原理与此类似，例如，你通过浏览器请求 Node 服务器上的一张小猫图片。因为该图片资源太大，所以在进行磁盘读写的时候你可以抽身去处理其他事情。此时，这个磁盘就相当于一个外部资源，我们可以直接处理第二个请求而无需挂起等待费时操作结束。\x3c\/p\x3e\n\x3cp\x3eExpress 中主要有两个外部资源：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e涉及文件系统。例如，磁盘文件的读写。\x3c\/li\x3e\n\x3cli\x3e涉及网络处理。例如，接受请求、发送响应。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在 Node 代码中，这些异步都是通过回调进行处理的。其工作原理和在 Web 页面发送 AJAX 请求一样。在发送请求时你会附带一个回调函数，当请求处理完成后你的回调将会被执行。\x3c\/p\x3e\n\x3cp\x3e例如，现在你正在硬盘上读取文件 \x3cem\x3emyfile.txt\x3c\/em\x3e 。当读取结束后，你希望能够打印出其中字母 X 出现的次数，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fs = require(\x26quot;fs\x26quot;);\x26nbsp; \n\x26nbsp;\nvar options = { encoding: \x26quot;utf-8\x26quot; };\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \nfs.readFile(\x26quot;myfile.txt\x26quot;, options, function(err, data) {\x26nbsp; \n\x26nbsp; if (err) {\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\x26nbsp;\x26nbsp; console.error(\x26quot;Error reading file!\x26quot;);\x26nbsp;\x26nbsp; \n\x26nbsp;\x26nbsp;\x26nbsp; return;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; }\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\n\x26nbsp; console.log(data.match(\/x\/gi).length \x2b \x26quot; letter X\x27s\x26quot;);\x26nbsp;\x26nbsp;\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fs\x22\x3c\/span\x3e);\x26nbsp; \n\x26nbsp;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e options = { \x3cspan class=\x22hljs-attr\x22\x3eencoding\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22utf-8\x22\x3c\/span\x3e };\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x22myfile.txt\x22\x3c\/span\x3e, options, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x22Error reading file!\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp; \n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; }\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\n\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data.match(\x3cspan class=\x22hljs-regexp\x22\x3e\/x\/gi\x3c\/span\x3e).length \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 letter X\x27s\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp;\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面我们一步步解释这些代码：\x3c\/p\x3e\n\x3cp\x3e首先，我们导入 Node 自带的文件系统模块。该模块主要处理文件相关内容，其中大多数都是文件读写功能。本例使用的其中的 \x3cem\x3ereadFile\x3c\/em\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e接下来，我们需要设置 \x3cem\x3efs.readFile\x3c\/em\x3e 方法中的参数，第一个是文件名，第二个就是会回调函数。并且在读取结束后执行回调函数。\x3c\/p\x3e\n\x3cp\x3e在 Node 中大多数回调函数都会设置错误信息 \x3cem\x3eerror\x3c\/em\x3e 作为第一个参数。正常情况下该参数等于 null ，如果出现错误则该参数会保存错误信息。虽然有时候这些错误信息并不会导致程序终止执行，但是多数情形下我们都需要对错误做出响应，例如，抛出异常并跳出回调函数。这也是 Node 中最常见的回调实践。\x3c\/p\x3e\n\x3cp\x3e最后，当一切正常时我们使用正则表达式匹配字母 X 并打印其数量。\x3c\/p\x3e\n\x3cp\x3e下面我们就来做个测试。这里，我们在上面代码的结束加上一段，那么会发生什么事情呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fs = require(\x26quot;fs\x26quot;);\x26nbsp; \n\x26nbsp;\nvar options = { encoding: \x26quot;utf-8\x26quot; };\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \nfs.readFile(\x26quot;myfile.txt\x26quot;, options, function(err, data) {\x26nbsp; \n\x26nbsp; if (err) {\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\x26nbsp;\x26nbsp; console.error(\x26quot;Error reading file!\x26quot;);\x26nbsp;\x26nbsp; \n\x26nbsp;\x26nbsp;\x26nbsp; return;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; }\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\n\x26nbsp; console.log(data.match(\/x\/gi).length \x2b \x26quot; letter X\x27s\x26quot;);\x26nbsp;\x26nbsp;\n});\n\nconsole.log(\x26quot;Hello World!\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fs\x22\x3c\/span\x3e);\x26nbsp; \n\x26nbsp;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e options = { \x3cspan class=\x22hljs-attr\x22\x3eencoding\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22utf-8\x22\x3c\/span\x3e };\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x22myfile.txt\x22\x3c\/span\x3e, options, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x22Error reading file!\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp; \n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; }\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\n\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data.match(\x3cspan class=\x22hljs-regexp\x22\x3e\/x\/gi\x3c\/span\x3e).length \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 letter X\x27s\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp;\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello World!\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e异步文件读取时异步操作，所以这里先打印出来的是 \x22 Hello world! \x22，然后才是异步函数中的打印操作。\x3c\/p\x3e\n\x3cp\x3e这就是异步模式强大的地方。当一个外部设备在处理费时操作时，你可以继续运行其他代码。在 Web  应用中这意味着相同的时间可以处理更多的请求。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：如果你想了解更多 JavaScript 异步的内容的话，你可以去油管上查看这个\x3ca href=\x22https:\/\/www.youtube.com\/watch?v=8aGhZQkoFbQ\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e视频\x3c\/a\x3e。视频中的讲解同时适用于 Node 和浏览器环境。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e用 Node 构建 Web 服务：http 模块\x3c\/h2\x3e\n\x3cp\x3e只有理解了上面那些概念，你才能更好的掌握 Node 内置的 HTTP 模块。而该模块对 Express 框架来说又是最重要的模块之一。Node 和 Express 能够构建 Web 服务正是依赖于这个模块中的功能。\x3c\/p\x3e\n\x3cp\x3eNode 的 HTTP 模块有很多特性（比如，向其他服务器发送网络请求），不过我们将要使用的是其中一个名为 \x3cem\x3ehttp.createServer\x3c\/em\x3e 的方法。该方法通过其回调函数来处理每一次的网络请求，并且进行响应。下面代码中我们将所有的响应都设置为了 \x22hello world\x22 （可以保存到 \x3cem\x3emyserver.js\x3c\/em\x3e 中）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var http = require(\x26quot;http\x26quot;);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp;\nfunction requestHandler(request, response) {\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; console.log(\x26quot;In comes a request to: \x26quot; \x2b request.url);\x26nbsp; \n\x26nbsp; response.end(\x26quot;Hello, world!\x26quot;);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n}\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\nvar server = http.createServer(requestHandler);\x26nbsp; \nserver.listen(3000);\x26nbsp; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e http = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22http\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erequestHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequest, response\x3c\/span\x3e) \x3c\/span\x3e{\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22In comes a request to: \x22\x3c\/span\x3e \x2b request.url);\x26nbsp; \n\x26nbsp; response.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, world!\x22\x3c\/span\x3e);\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \n}\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\n\x26nbsp;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e server = http.createServer(requestHandler);\x26nbsp; \nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\x26nbsp; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码由 4 个部分构成。\x3c\/p\x3e\n\x3cp\x3e首先，我们引入 HTTP 模块并将其保存到变量 http 中。这与之前 URL  模块的操作一致。\x3c\/p\x3e\n\x3cp\x3e接着，定义了一个请求处理函数 \x3cem\x3erequestHandler\x3c\/em\x3e 。教程中的几乎所有的代码要么是请求处理函数要么是调用处理函数。该函数有两个参数，\x3cem\x3erequest\x3c\/em\x3e 表示请求对象，而 \x3cem\x3eresponse\x3c\/em\x3e 则表示响应对象。\x3cem\x3erequest\x3c\/em\x3e 中包含 URL 路径、\x3cem\x3euser-agent\x3c\/em\x3e 等信息。而通过调用 \x3cem\x3eresponse\x3c\/em\x3e 对象方法 Node 会将响应信息打包好并发送给请求者。\x3c\/p\x3e\n\x3cp\x3e余下的代码则是指定内置的 HTTP 服务在请求是执行的处理函数以及服务监听的端口号。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e对于 HTTPS 来说，我们则可以使用自带的 HTTPS 模块。除了需要配置 SSL 证书，其余的过程都一样。如果你了解 HTTPS 的话那么后期从 HTTP 切换到 HTTPS 两分钟就能搞定。即使你不了解，也不必太过担心。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如果你将代码保存到 \x3cem\x3emyserver.js\x3c\/em\x3e 并执行 \x3cem\x3enode myserver.js\x3c\/em\x3e 拉起服务。那么，此时你在浏览器中访问 \x3cem\x3e\x3ca href=\x22http:\/\/localhost:3000\/em\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/localhost:3000\x3c\/a\x3e\x3c\/em\x3e ，你就会看到：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010819188\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010819188\x22 alt=\x2202_03\x22 title=\x2202_03\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e你可能也注意到了，每当你发起请求的时候终端控制台都会打印一些信息。当你尝试访问不同 URL 时，虽然控制台打印的信息不同但是得到的响应却都是 “Hello, world!”。控制台打印的信息类似于：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010819189\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010819189\x22 alt=\x2202_04\x22 title=\x2202_04\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e请注意上面打印的 URL 信息中并不包含 \x3cem\x3elocalhost:3000\x3c\/em\x3e。虽然看起来显得不那么直观，但是反过来这也是对的。毕竟使用相对路径，我们无需修改就能在任何电脑上部署 Node 应用。\x3c\/p\x3e\n\x3cp\x3e而 URL 解析的代码大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function requestHandler(req, res) {\n    if (req.url === \x26quot;\/\x26quot;) {\n        res.end(\x26quot;Welcome to the homepage!\x26quot;);\n    } else if (req.url === \x26quot;\/about\x26quot;) {\n        res.end(\x26quot;Welcome to the about page!\x26quot;);\n    } else {\n        res.end(\x26quot;Error! File not found.\x26quot;);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erequestHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (req.url === \x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e) {\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Welcome to the homepage!\x22\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (req.url === \x3cspan class=\x22hljs-string\x22\x3e\x22\/about\x22\x3c\/span\x3e) {\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Welcome to the about page!\x22\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x22Error! File not found.\x22\x3c\/span\x3e);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有的请求 URL 都可以在这个函数里面完成处理。这样做对于简单的应用来说确实非常简单，但是当应用规模变大之后该函数就会变的臃肿不利于维护。这也是 Express 框架出现的重要原因。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e本文主要内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eNode 的安装\x3c\/li\x3e\n\x3cli\x3e模块系统的使用\x3c\/li\x3e\n\x3cli\x3epackage.json 文件的介绍\x3c\/li\x3e\n\x3cli\x3e通过 package.json 安装第三放模块依赖项\x3c\/li\x3e\n\x3cli\x3eNode 中的异步编程概念。\x3c\/li\x3e\n\x3cli\x3e简单 HTTP 服务应用的创建。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e原文\x3ca href=\x22https:\/\/bignerdcoding.com\/archives\/42.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Express 实战（二）：Node.js 基础</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010819181">https://segmentfault.com/a/1190000010819181</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bgzrztky2v/" target="_blank">https://alili.tech/archive/bgzrztky2v/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>