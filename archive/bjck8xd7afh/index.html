<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入浅出 - vue变化侦测原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入浅出 - vue变化侦测原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bjck8xd7afh/",
				"appid": "1613049289050283", 
				"title": "深入浅出 - vue变化侦测原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ir9ybkpx5y/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2qa4smbj1to/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&text=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&text=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbjck8xd7afh%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20-%20vue%e5%8f%98%e5%8c%96%e4%be%a6%e6%b5%8b%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入浅出 - vue变化侦测原理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22http:\/\/www.codedata.cn\/hacknews\/152110789455628115\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文链接\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e深入浅出 - vue变化侦测原理\x3c\/h1\x3e\n\x3cp\x3e其实在一年前我已经写过一篇关于 \x3ca href=\x22https:\/\/github.com\/berwin\/Blog\/issues\/11\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue响应式原理的文章\x3c\/a\x3e，但是最近我翻开看看发现讲的内容和我现在心里想的有些不太一样，所以我打算重新写一篇更通俗易懂的文章。\x3c\/p\x3e\n\x3cp\x3e我的目标是能让读者读完我写的文章能学到知识，有一部分文章标题都以深入浅出开头，目的是把一个复杂的东西排除掉干扰学习的因素后剩下的核心原理通过很简单的描述来让读者学习到知识。\x3c\/p\x3e\n\x3cp\x3e关于vue的内部原理其实有很多个重要的部分，变化侦测，模板编译，virtualDOM，整体运行流程等。\x3c\/p\x3e\n\x3cp\x3e今天主要把变化侦测这部分单独拿出来讲一讲。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e如何侦测变化？\x3c\/h2\x3e\n\x3cp\x3e关于变化侦测首先要问一个问题，在 js 中，如何侦测一个对象的变化，其实这个问题还是比较简单的，学过js的都能知道，js中有两种方法可以侦测到变化，\x3ccode\x3eObject.defineProperty\x3c\/code\x3e 和 ES6 的\x3ccode\x3eproxy\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e到目前为止vue还是用的 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e，所以我们拿 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e来举例子说明这个原理。\x3c\/p\x3e\n\x3cp\x3e这里我想说的是，不管以后vue是否会用 \x3ccode\x3eproxy\x3c\/code\x3e 重写这部分，我讲的是原理，并不是api，所以不论以后vue会怎样改，这个原理是不会变的，哪怕vue用了其他完全不同的原理实现了变化侦测，但是本篇文章讲的原理一样可以实现变化侦测，原理这个东西是不会过时的。\x3c\/p\x3e\n\x3cp\x3e之前我写文章有一个毛病就是喜欢对着源码翻译，结果过了半年一年人家源码改了，我写的文章就一毛钱都不值了，而且对着源码翻译还有一个缺点是对读者的要求有点偏高，读者如果没看过源码或者看的和我不是一个版本，那根本就不知道我在说什么。\x3c\/p\x3e\n\x3cp\x3e好了不说废话了，继续讲刚才的内容。\x3c\/p\x3e\n\x3cp\x3e知道 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 可以侦测到对象的变化，那么我们瞬间可以写出这样的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function defineReactive (data, key, val) {\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            val = newVal\n        }\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction defineReactive (data, key, val) {\n    \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(data, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: function () {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: function (newVal) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(val === newVal){\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n            }\n            val = newVal\n        }\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e写一个函数封装一下 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e，毕竟 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 的用法这么复杂，封装一下我只需要传递一个 data，和 key，val 就行了。\x3c\/p\x3e\n\x3cp\x3e现在封装好了之后每当 \x3ccode\x3edata\x3c\/code\x3e 的 \x3ccode\x3ekey\x3c\/code\x3e 读取数据 \x3ccode\x3eget\x3c\/code\x3e 这个函数可以被触发，设置数据的时候 \x3ccode\x3eset\x3c\/code\x3e 这个函数可以被触发，但是，，，，，，，，，，，，，，，，，，发现好像并没什么鸟用？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e怎么观察？\x3c\/h2\x3e\n\x3cp\x3e现在我要问第二个问题，“怎么观察？”\x3c\/p\x3e\n\x3cp\x3e思考一下，我们之所以要观察一个数据，目的是为了当数据的属性发生变化时，可以通知那些使用了这个 \x3ccode\x3ekey\x3c\/code\x3e 的地方。\x3c\/p\x3e\n\x3cp\x3e举个?：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ctemplate\x3e\n  \x3cdiv\x3e\x22{{\x22 key \x22}}\x22\x3c\/div\x3e\n  \x3cp\x3e\x22{{\x22 key \x22}}\x22\x3c\/p\x3e\n\x3c\/template\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\x22{{\x22 key \x22}}\x22\x26lt;\/div\x26gt;\n  \x26lt;p\x26gt;\x22{{\x22 key \x22}}\x22\x26lt;\/p\x26gt;\n\x26lt;\/template\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e模板中有两处使用了 \x3ccode\x3ekey\x3c\/code\x3e，所以当数据发生变化时，要把这两处都通知到。\x3c\/p\x3e\n\x3cp\x3e所以上面的问题，我的回答是，先收集依赖，把这些使用到 \x3ccode\x3ekey\x3c\/code\x3e 的地方先收集起来，然后等属性发生变化时，把收集好的依赖循环触发一遍就好了~\x3c\/p\x3e\n\x3cp\x3e总结起来其实就一句话，\x3cstrong\x3egetter中，收集依赖，setter中，触发依赖\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e依赖收集在哪？\x3c\/h2\x3e\n\x3cp\x3e现在我们已经有了很明确的目标，就是要在getter中收集依赖，那么我们的依赖收集到哪里去呢？？\x3c\/p\x3e\n\x3cp\x3e思考一下，首先想到的是每个 \x3ccode\x3ekey\x3c\/code\x3e 都有一个数组，用来存储当前 \x3ccode\x3ekey\x3c\/code\x3e 的依赖，假设依赖是一个函数存在 \x3ccode\x3ewindow.target\x3c\/code\x3e 上，先把 \x3ccode\x3edefineReactive\x3c\/code\x3e 稍微改造一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function defineReactive (data, key, val) {\n    let dep = [] \/\/ 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.push(window.target) \/\/ 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            \n            \/\/ 新增\n            for (let i = 0; i \x3c dep.length; i\x2b\x2b) {\n                 dep[i](newVal, val)\n            }\n            val = newVal\n        }\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction defineReactive (data, key, val) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dep = [] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n    \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(data, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: function () {\n            dep.push(window.target) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: function (newVal) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(val === newVal){\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n            }\n            \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; dep.length; i\x2b\x2b) {\n                 dep[i](newVal, val)\n            }\n            val = newVal\n        }\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3edefineReactive\x3c\/code\x3e 中新增了数组 dep，用来存储被收集的依赖。\x3c\/p\x3e\n\x3cp\x3e然后在触发 set 触发时，循环dep把收集到的依赖触发。\x3c\/p\x3e\n\x3cp\x3e但是这样写有点耦合，我们把依赖收集这部分代码封装起来，写成下面的样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array\x3cWatcher\x3e;\n\n  constructor () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      this.addSub(Dep.target)\n    }\n  }\n\n  notify () {\n    \/\/ stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i \x3c l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e target: ?\x3cspan class=\x22hljs-type\x22\x3eWatcher\x3c\/span\x3e;\n  id: number;\n  subs: \x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-type\x22\x3eWatcher\x3c\/span\x3e\x26gt;;\n\n  constructor () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\n\n  addSub (sub: \x3cspan class=\x22hljs-type\x22\x3eWatcher\x3c\/span\x3e) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: \x3cspan class=\x22hljs-type\x22\x3eWatcher\x3c\/span\x3e) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e.target) {\n      this.addSub(\x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e.target)\n    }\n  }\n\n  notify () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stabilize the subscriber list first\x3c\/span\x3e\n    const subs = this.subs.slice()\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = subs.length; i \x26lt; l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在改造一下 \x3ccode\x3edefineReactive\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function defineReactive (data, key, val) {\n    let dep = new Dep() \/\/ 修改\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.depend() \/\/ 修改\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n\n            dep.notify() \/\/ 新增\n            val = newVal\n        }\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3efunction defineReactive (data, key, val) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dep = new \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改\x3c\/span\x3e\n    \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(data, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: function () {\n            dep.depend() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: function (newVal) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(val === newVal){\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n            }\n\n            dep.notify() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n            val = newVal\n        }\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一次代码看起来清晰多了，顺便回答一下上面问的问题，依赖收集到哪？收集到Dep中，Dep是专门用来存储依赖的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e收集谁？\x3c\/h2\x3e\n\x3cp\x3e上面我们假装 \x3ccode\x3ewindow.target\x3c\/code\x3e 是需要被收集的依赖，细心的同学可能已经看到，上面的代码 \x3ccode\x3ewindow.target\x3c\/code\x3e 已经改成了 \x3ccode\x3eDep.target\x3c\/code\x3e，那 \x3ccode\x3eDep.target\x3c\/code\x3e是什么？我们究竟要收集谁呢？？\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013821437\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013821437\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e收集谁，换句话说是当属性发生变化后，通知谁。\x3c\/p\x3e\n\x3cp\x3e我们要通知那个使用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，有可能是模板，有可能是用户写的一个 watch，所以这个时候我们需要抽象出一个能集中处理这些不同情况的类，然后我们在依赖收集的阶段只收集这个封装好的类的实例进来，通知也只通知它一个，然后它在负责通知其他地方，所以我们要抽象的这个东西需要先起一个好听的名字，嗯，就叫它watcher吧~\x3c\/p\x3e\n\x3cp\x3e所以现在可以回答上面的问题，收集谁？？收集 Watcher。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e什么是Watcher？\x3c\/h2\x3e\n\x3cp\x3ewatcher 是一个中介的角色，数据发生变化通知给 watcher，然后watcher在通知给其他地方。\x3c\/p\x3e\n\x3cp\x3e关于watcher我们先看一个经典的使用方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ keypath\nvm.$watch(\x27a.b.c\x27, function (newVal, oldVal) {\n  \/\/ do something\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ keypath\x3c\/span\x3e\nvm.$watch(\x27a.b.\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e\x27, function (newVal, oldVal) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码表示当 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 这个属性发生变化时，触发第二个参数这个函数。\x3c\/p\x3e\n\x3cp\x3e思考一下怎么实现这个功能呢？\x3c\/p\x3e\n\x3cp\x3e好像只要把这个 watcher 实例添加到 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 这个属性的 Dep 中去就行了，然后 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 触发时，会通知到watcher，然后watcher在执行参数中的这个回调函数。\x3c\/p\x3e\n\x3cp\x3e好，思考完毕，开工，写出如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Watch {\n    constructor (expOrFn, cb) {\n        \/\/ 执行 this.getter() 就可以拿到 data.a.b.c\n        this.getter = parsePath(expOrFn)\n        this.cb = cb\n        this.value = this.get()\n    }\n\n    get () {\n        Dep.target = this\n        value = this.getter.call(vm, vm)\n        Dep.target = undefined\n    }\n\n    update () {\n        const oldValue = this.value\n        this.value = this.get()\n        this.cb.call(this.vm, this.value, oldValue)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatch\x3c\/span\x3e \x3c\/span\x3e{\n    constructor (expOrFn, cb) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行 this.getter() 就可以拿到 data.a.b.c\x3c\/span\x3e\n        this.getter = parsePath(expOrFn)\n        this.cb = cb\n        this.value = this.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e()\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e () {\n        \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e.target = this\n        value = this.getter.call(vm, vm)\n        \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e.target = undefined\n    }\n\n    update () {\n        const oldValue = this.value\n        this.value = this.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e()\n        this.cb.call(this.vm, this.value, oldValue)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码可以把自己主动 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 的 Dep 中去。\x3c\/p\x3e\n\x3cp\x3e因为我在 \x3ccode\x3eget\x3c\/code\x3e 这个方法中，先把 Dep.traget 设置成了 \x3ccode\x3ethis\x3c\/code\x3e，也就是当前watcher实例，然后在读一下 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 的值。\x3c\/p\x3e\n\x3cp\x3e因为读了 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 的值，所以肯定会触发 \x3ccode\x3egetter\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e触发了 \x3ccode\x3egetter\x3c\/code\x3e 上面我们封装的 \x3ccode\x3edefineReactive\x3c\/code\x3e 函数中有一段逻辑就会从 \x3ccode\x3eDep.target\x3c\/code\x3e 里读一个依赖 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3eDep\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e所以就导致，我只要先在 Dep.target 赋一个 \x3ccode\x3ethis\x3c\/code\x3e，然后我在读一下值，去触发一下 \x3ccode\x3egetter\x3c\/code\x3e，就可以把 \x3ccode\x3ethis\x3c\/code\x3e 主动 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3ekeypath\x3c\/code\x3e 的依赖中，有没有很神奇~\x3c\/p\x3e\n\x3cp\x3e依赖注入到 \x3ccode\x3eDep\x3c\/code\x3e 中去之后，当这个 \x3ccode\x3edata.a.b.c\x3c\/code\x3e 的值发生变化，就把所有的依赖循环触发 update 方法，也就是上面代码中 update 那个方法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eupdate\x3c\/code\x3e 方法会触发参数中的回调函数，将value 和 oldValue 传到参数中。\x3c\/p\x3e\n\x3cp\x3e所以其实不管是用户执行的 \x3ccode\x3evm.$watch(\x27a.b.c\x27, (value, oldValue) =\x26gt; {})\x3c\/code\x3e 还是模板中用到的data，都是通过 watcher 来通知自己是否需要发生变化的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e递归侦测所有key\x3c\/h2\x3e\n\x3cp\x3e现在其实已经可以实现变化侦测的功能了，但是我们之前写的代码只能侦测数据中的一个 key，所以我们要加工一下 \x3ccode\x3edefineReactive\x3c\/code\x3e 这个函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 新增\nfunction walk (obj: Object) {\n  const keys = Object.keys(obj)\n  for (let i = 0; i \x3c keys.length; i\x2b\x2b) {\n    defineReactive(obj, keys[i], obj[keys[i]])\n  }\n}\n\nfunction defineReactive (data, key, val) {\n    walk(val) \/\/ 新增\n    let dep = new Dep()\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.depend()\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n\n            dep.notify()\n            val = newVal\n        }\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\nfunction walk (obj: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e) {\n  const keys = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.keys(obj)\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n    defineReactive(obj, keys[i], obj[keys[i]])\n  }\n}\n\nfunction defineReactive (data, key, val) {\n    walk(val) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dep = new \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(data, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: function () {\n            dep.depend()\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: function (newVal) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(val === newVal){\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n            }\n\n            dep.notify()\n            val = newVal\n        }\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们就可以通过执行 \x3ccode\x3ewalk(data)\x3c\/code\x3e，把 \x3ccode\x3edata\x3c\/code\x3e 中的所有 \x3ccode\x3ekey\x3c\/code\x3e 都加工成可以被侦测的，因为是一个递归的过程，所以 \x3ccode\x3ekey\x3c\/code\x3e 中的 \x3ccode\x3evalue\x3c\/code\x3e 如果是一个对象，那这个对象的所有key也会被侦测。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eArray怎么进行变化侦测？\x3c\/h2\x3e\n\x3cp\x3e现在又发现了新的问题，\x3ccode\x3edata\x3c\/code\x3e 中不是所有的 \x3ccode\x3evalue\x3c\/code\x3e 都是对象和基本类型，如果是一个数组怎么办？？数组是没有办法通过 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 来侦测到行为的。\x3c\/p\x3e\n\x3cp\x3evue 中对这个数组问题的解决方案非常的简单粗暴，我说说vue是如何实现的，大体上分三步：\x3c\/p\x3e\n\x3cp\x3e第一步：先把原生 \x3ccode\x3eArray\x3c\/code\x3e 的原型方法继承下来。\x3c\/p\x3e\n\x3cp\x3e第二步：对继承后的对象使用 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 做一些拦截操作。\x3c\/p\x3e\n\x3cp\x3e第三步：把加工后可以被拦截的原型，赋值到需要被拦截的 \x3ccode\x3eArray\x3c\/code\x3e 类型的数据的原型上。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3evue的实现\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e第一步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3econst arrayProto = \x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e.prototype\nexport const arrayMethods = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.create(arrayProto)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27sort\x27,\n  \x27reverse\x27\n]\n.forEach(function (method) {\n  \/\/ cache original method\n  const original = arrayProto[method]\n\n  Object.defineProperty(arrayMethods, method, {\n    value: function mutator (...args) {\n      console.log(methods) \/\/ 打印数组方法\n      return original.apply(this, args)\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true\n  })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27\x3cspan class=\x22hljs-built_in\x22\x3esort\x3c\/span\x3e\x27,\n  \x27\x3cspan class=\x22hljs-built_in\x22\x3ereverse\x3c\/span\x3e\x27\n]\n.forEach(function (method) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n  const original = arrayProto[method]\n\n  \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(arrayMethods, method, {\n    value: function mutator (...args) {\n      console.log(methods) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打印数组方法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e original.apply(this, args)\n    },\n    enumerable: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    writable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在可以看到，每当被侦测的 \x3ccode\x3earray\x3c\/code\x3e 执行方法操作数组时，我都可以知道他执行的方法是什么，并且打印到 \x3ccode\x3econsole\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e现在我要对这个数组方法类型进行判断，如果操作数组的方法是 push unshift splice （这种可以新增数组元素的方法），需要把新增的元素用上面封装的 \x3ccode\x3ewalk\x3c\/code\x3e 来进行变化检测。\x3c\/p\x3e\n\x3cp\x3e并且不论操作数组的是什么方法，我都要触发消息，通知依赖列表中的依赖数据发生了变化。\x3c\/p\x3e\n\x3cp\x3e那现在怎么访问依赖列表呢，可能我们需要把上面封装的 \x3ccode\x3ewalk\x3c\/code\x3e 加工一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 工具函数\nfunction def (obj: Object, key: string, val: any, enumerable?: boolean) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; \/\/ number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep() \/\/ 新增\n    this.vmCount = 0\n    def(value, \x27__ob__\x27, this) \/\/ 新增\n\n    \/\/ 新增\n    if (Array.isArray(value)) {\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  \/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i \x3c keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \/**\n   * Observe a list of Array items.\n   *\/\n  observeArray (items: Array\x3cany\x3e) {\n    for (let i = 0, l = items.length; i \x3c l; i\x2b\x2b) {\n      new Observer(items[i])\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 工具函数\x3c\/span\x3e\nfunction def (obj: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e, key: string, val: any, enumerable?: boolean) {\n  \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  })\n}\n\nexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  value: any;\n  dep: \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e;\n  vmCount: number; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ number of vms that has this object as root $data\x3c\/span\x3e\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n    this.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    def(value, \x27__ob__\x27, this) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      this.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      this.walk(value)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\x3c\/span\x3e\n  walk (obj: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e) {\n    const keys = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.keys(obj)\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Observe a list of Array items.\n   *\/\x3c\/span\x3e\n  observeArray (items: \x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e\x26lt;any\x26gt;) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = items.length; i \x26lt; l; i\x2b\x2b) {\n      new \x3cspan class=\x22hljs-type\x22\x3eObserver\x3c\/span\x3e(items[i])\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们定义了一个 \x3ccode\x3eObserver\x3c\/code\x3espace######space类，他的职责是将 \x3ccode\x3edata\x3c\/code\x3e 转换成可以被侦测到变化的 \x3ccode\x3edata\x3c\/code\x3e，并且新增了对类型的判断，如果是 \x3ccode\x3evalue\x3c\/code\x3e 的类型是 \x3ccode\x3eArray\x3c\/code\x3e 循环 Array将每一个元素丢到 Observer 中。\x3c\/p\x3e\n\x3cp\x3e并且在 value 上做了一个标记 \x3ccode\x3e__ob__\x3c\/code\x3e，这样我们就可以通过 \x3ccode\x3evalue\x3c\/code\x3e 的 \x3ccode\x3e__ob__\x3c\/code\x3e 拿到Observer实例，然后使用 \x3ccode\x3e__ob__\x3c\/code\x3e 上的 \x3ccode\x3edep.notify()\x3c\/code\x3e 就可以发送通知啦。\x3c\/p\x3e\n\x3cp\x3e然后我们在改进一下Array原型的拦截器：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27sort\x27,\n  \x27reverse\x27\n]\n.forEach(function (method) {\n  \/\/ cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case \x27push\x27:\n      case \x27unshift\x27:\n        inserted = args\n        break\n      case \x27splice\x27:\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    \/\/ notify change\n    ob.dep.notify()\n    return result\n  })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27\x3cspan class=\x22hljs-built_in\x22\x3esort\x3c\/span\x3e\x27,\n  \x27\x3cspan class=\x22hljs-built_in\x22\x3ereverse\x3c\/span\x3e\x27\n]\n.forEach(function (method) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e inserted\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (method) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x27push\x27:\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x27unshift\x27:\n        inserted = args\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x27splice\x27:\n        inserted = args.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inserted) ob.observeArray(inserted)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ notify change\x3c\/span\x3e\n    ob.dep.notify()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n  })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到写了一个 \x3ccode\x3eswitch\x3c\/code\x3e 对 \x3ccode\x3emethod\x3c\/code\x3e 进行判断，如果是 \x3ccode\x3epush\x3c\/code\x3e，\x3ccode\x3eunshift\x3c\/code\x3e，\x3ccode\x3esplice\x3c\/code\x3e 这种可以新增数组元素的方法就使用 \x3ccode\x3eob.observeArray(inserted)\x3c\/code\x3e 把新增的元素也丢到 \x3ccode\x3eObserver\x3c\/code\x3e 中去转换成可以被侦测到变化的数据。\x3c\/p\x3e\n\x3cp\x3e在最后不论操作数组的方法是什么，都会调用 \x3ccode\x3eob.dep.notify()\x3c\/code\x3e 去通知 \x3ccode\x3ewatcher\x3c\/code\x3e 数据发生了改变。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3earrayMethods 是怎么生效的？\x3c\/h2\x3e\n\x3cp\x3e现在我们有一个 \x3ccode\x3earrayMenthods\x3c\/code\x3e 是被加工后的 \x3ccode\x3eArray.prototype\x3c\/code\x3e，那么怎么让这个对象应用到\x3ccode\x3eArray\x3c\/code\x3e 上面呢？\x3c\/p\x3e\n\x3cp\x3e思考一下，我们不能直接修改 \x3ccode\x3eArray.prototype\x3c\/code\x3e因为这样会污染全局的Array，我们希望 \x3ccode\x3earrayMenthods\x3c\/code\x3e 只对 \x3ccode\x3edata\x3c\/code\x3e中的\x3ccode\x3eArray\x3c\/code\x3e 生效。\x3c\/p\x3e\n\x3cp\x3e所以我们只需要把 \x3ccode\x3earrayMenthods\x3c\/code\x3e 赋值给 \x3ccode\x3evalue\x3c\/code\x3e 的 \x3ccode\x3e__proto__\x3c\/code\x3e 上就好了。\x3c\/p\x3e\n\x3cp\x3e我们改造一下 \x3ccode\x3eObserver\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class Observer {\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, \x27__ob__\x27, this)\n\n    if (Array.isArray(value)) {\n      value.__proto__ = arrayMethods \/\/ 新增\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3eexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  constructor (value: any) {\n    this.value = value\n    this.dep = new \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e()\n    this.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    def(value, \x27__ob__\x27, this)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      value.__proto__ = arrayMethods \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\n      this.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      this.walk(value)\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果不能使用 \x3ccode\x3e__proto__\x3c\/code\x3e，就直接循环 \x3ccode\x3earrayMethods\x3c\/code\x3e 把它身上的这些方法直接装到 \x3ccode\x3evalue\x3c\/code\x3e 身上好了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e什么情况不能使用 \x3ccode\x3e__proto__\x3c\/code\x3e 我也不知道，各位大佬谁知道能否给我留个言？跪谢~\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e所以我们的代码又要改造一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ can we use __proto__?\nconst hasProto = \x27__proto__\x27 in {} \/\/ 新增\nexport class Observer {\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, \x27__ob__\x27, this)\n\n    if (Array.isArray(value)) {\n      \/\/ 修改\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n\nfunction protoAugment (target, src: Object, keys: any) {\n  target.__proto__ = src\n}\n\nfunction copyAugment (target: Object, src: Object, keys: Array\x3cstring\x3e) {\n  for (let i = 0, l = keys.length; i \x3c l; i\x2b\x2b) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ can we use __proto__?\x3c\/span\x3e\nconst hasProto = \x27__proto__\x27 \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e {} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  constructor (value: any) {\n    this.value = value\n    this.dep = new \x3cspan class=\x22hljs-type\x22\x3eDep\x3c\/span\x3e()\n    this.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    def(value, \x27__ob__\x27, this)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改\x3c\/span\x3e\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      this.walk(value)\n    }\n  }\n}\n\nfunction protoAugment (target, src: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e, keys: any) {\n  target.__proto__ = src\n}\n\nfunction copyAugment (target: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e, src: \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e, keys: \x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e\x26lt;string\x26gt;) {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = keys.length; i \x26lt; l; i\x2b\x2b) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e关于Array的问题\x3c\/h2\x3e\n\x3cp\x3e关于vue对Array的拦截实现上面刚说完，正因为这种实现方式，其实有些数组操作vue是拦截不到的，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.list[0] = 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ethis.list[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e修改数组第一个元素的值，无法侦测到数组的变化，所以并不会触发 \x3ccode\x3ere-render\x3c\/code\x3e 或 \x3ccode\x3ewatch\x3c\/code\x3e 等。\x3c\/p\x3e\n\x3cp\x3e在例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.list.length = 0\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22swift hljs\x22\x3e\x3ccode class=\x22swift\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ethis.list.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e清空数组操作，无法侦测到数组的变化，所以也不会触发 \x3ccode\x3ere-render\x3c\/code\x3e 或 \x3ccode\x3ewatch\x3c\/code\x3e 等。\x3c\/p\x3e\n\x3cp\x3e因为vue的实现方式就决定了无法对上面举得两个例子做拦截，也就没有办法做到响应，ES6是有能力做到的，在ES6之前是无法做到模拟数组的原生行为的，现在 ES6 的 Proxy 可以模拟数组的原生行为，也可以通过 ES6 的继承来继承数组原生行为，从而进行拦截。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013821438?w=1200\x26amp;h=750\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013821438?w=1200\x26amp;h=750\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e最后掏出vue官网上的一张图，这张图其实非常清晰，就是一个变化侦测的原理图。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetter\x3c\/code\x3e 到 \x3ccode\x3ewatcher\x3c\/code\x3e 有一条线，上面写着收集依赖，意思是说 \x3ccode\x3egetter\x3c\/code\x3e 里收集 \x3ccode\x3ewatcher\x3c\/code\x3e，也就是说当数据发生 \x3ccode\x3eget\x3c\/code\x3e 动作时开始收集 \x3ccode\x3ewatcher\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetter\x3c\/code\x3e 到 \x3ccode\x3ewatcher\x3c\/code\x3e 有一条线，写着 \x3ccode\x3eNotify\x3c\/code\x3e 意思是说在 \x3ccode\x3esetter\x3c\/code\x3e 中触发消息，也就是当数据发生 \x3ccode\x3eset\x3c\/code\x3e 动作时，通知 \x3ccode\x3ewatcher\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eWatcher\x3c\/code\x3e 到 ComponentRenderFunction 有一条线，写着 \x3ccode\x3eTrigger re-render\x3c\/code\x3e 意思很明显了。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013821439?w=1080\x26amp;h=1080\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013821439?w=1080\x26amp;h=1080\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入浅出 - vue变化侦测原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013821434">https://segmentfault.com/a/1190000013821434</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bjck8xd7afh/" target="_blank">https://alili.tech/archive/bjck8xd7afh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>