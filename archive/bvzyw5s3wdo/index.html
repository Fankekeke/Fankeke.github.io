<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Redux源码分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Redux源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bvzyw5s3wdo/",
				"appid": "1613049289050283", 
				"title": "Redux源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3tmjy8mnjax/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/3b71seoyvw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&text=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&text=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&title=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&is_video=false&description=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&title=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&title=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&title=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbvzyw5s3wdo%2f&title=Redux%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Redux源码分析</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eRedux使用中的几个点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eRedux三大设计原则\x3c\/li\x3e\n\x3cli\x3eCreate Store\x3c\/li\x3e\n\x3cli\x3eRedux middleware\x3c\/li\x3e\n\x3cli\x3ecombineReducer\x3c\/li\x3e\n\x3cli\x3eProvider与Connect\x3c\/li\x3e\n\x3cli\x3eRedux流程梳理\x3c\/li\x3e\n\x3cli\x3eRedux设计特点\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. Redux三大设计原则\x3c\/h2\x3e\n\x3ch4\x3e1. 单一数据源\x3c\/h4\x3e\n\x3cp\x3e在传统的 MVC 架构中，我们可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。因为在 Redux 的思想里，一个应用永远只有唯一的数据源。\x3cbr\x3e实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。\x3c\/p\x3e\n\x3ch4\x3e2. 状态是只读的\x3c\/h4\x3e\n\x3cp\x3e在 Redux 中，我们并不会自己用代码来定义一个 store。取而代之的是，我们定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里我们并没有直接修改应用的状态，而是返回了一份全新的状态。\x3c\/p\x3e\n\x3cp\x3eRedux 提供的 createStore 方法会根据 reducer 生成 store。最后，我们可以利用 store. dispatch\x3cbr\x3e方法来达到修改状态的目的。\x3c\/p\x3e\n\x3ch4\x3e3.状态修改均由纯函数完成\x3c\/h4\x3e\n\x3cp\x3e在 Redux 里，我们通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。\x3c\/p\x3e\n\x3cp\x3e这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2.Create Store\x3c\/h2\x3e\n\x3cp\x3e我们从store的诞生开始说起。create store函数API文档如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22createStore(reducer, [initialState], enhancer)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ecreateStore(reducer, [initialState], enhancer)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，它接受三个参数：reducer、initialState 和        enhancer 。Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。\x3c\/p\x3e\n\x3cp\x3e再来看看他的返回值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    dispatch: f (action),\n    getState: f (),\n    replaceReducer: f (nextReducer),\n    subscribe: f (listener),\n    Symbol(observable): f ()    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e: f (action),\n    \x3cspan class=\x22hljs-attr\x22\x3egetState\x3c\/span\x3e: f (),\n    \x3cspan class=\x22hljs-attr\x22\x3ereplaceReducer\x3c\/span\x3e: f (nextReducer),\n    \x3cspan class=\x22hljs-attr\x22\x3esubscribe\x3c\/span\x3e: f (listener),\n    \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(observable): f ()    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3estore的返回值就是一个普通对象，里面有几个常用的方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3edispatch：就是我们最常用的dispatch方法，派发action。\x3c\/li\x3e\n\x3cli\x3egetState：通过该方法，我们可以拿到当前状态树state。\x3c\/li\x3e\n\x3cli\x3ereplaceReducer：这个方法主要用于 reducer 的热替换，下面介绍该方法。\x3c\/li\x3e\n\x3cli\x3esubscribe：添加一个变化监听器。每当 dispatch（action）的时候就会执行，state 树中的一部分可能已经变化。\x3c\/li\x3e\n\x3cli\x3eobservable：观察者模式，用于处理订阅关系。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里挑几个方法介绍：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3egetState\x3c\/h3\x3e\n\x3cp\x3e在完成基本的参数校验之后，在 createStore 中声明如下变量及 getState 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var currentReducer = reducer\nvar currentState = initialState\nvar listeners = [] \/\/ 当前监听 store 变化的监听器\nvar isDispatching = false \/\/ 某个 action 是否处于分发的处理过程中\n\/**\n* Reads the state tree managed by the store.\n *\n* @returns {any} The current state tree of your application.\n *\/\nfunction getState() {\n return currentState\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentReducer = reducer\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentState = initialState\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e listeners = [] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前监听 store 变化的监听器\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isDispatching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 某个 action 是否处于分发的处理过程中\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n* Reads the state tree managed by the store.\n *\n* @returns {any} The current state tree of your application.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetState\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e currentState\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetState方法就是简单返回当前state，如果state没有被reducer处理过，他就是initialState。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3esubscribe\x3c\/h3\x3e\n\x3cp\x3e在 getState 之后，定义了 store 的另一个方法 subscribe：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function subscribe(listener) {\n listeners.push(listener)\n var isSubscribed = true\n return function unsubscribe() {\n if (!isSubscribed) {\n return\n }\n isSubscribed = false\n var index = listeners.indexOf(listener)\n listeners.splice(index, 1)\n }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esubscribe\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n listeners.push(listener)\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isSubscribed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunsubscribe\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isSubscribed) {\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n }\n isSubscribed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = listeners.indexOf(listener)\n listeners.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eStore 允许使用\x3ccode\x3estore.subscribe\x3c\/code\x3e方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。\x3c\/p\x3e\n\x3cp\x3e显然，只要把 View 的更新函数（对于 React 项目，就是组件的\x3ccode\x3erender\x3c\/code\x3e方法或\x3ccode\x3esetState\x3c\/code\x3e方法）放入\x3ccode\x3elisten\x3c\/code\x3e，就会实现 View 的自动渲染。你可能会感到奇怪，好像我们在 Redux 应用中并没有使用 store.subscribe 方法？事实上，\x3c\/p\x3e\n\x3cp\x3eReact Redux 中的 connect 方法隐式地帮我们完成了这个工作。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3estore.subscribe\x3c\/code\x3e方法返回一个函数，调用这个函数就可以解除监听。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3edispatch\x3c\/h3\x3e\n\x3cp\x3edispatch是redux的核心方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function dispatch(action) {\n    if (!isPlainObject(action)) {\n        throw new Error(\n            \x27Actions must be plain objects. \x27 \x2b\n            \x27Use custom middleware for async actions.\x27\n        )\n    }\n    if (typeof action.type === \x27undefined\x27) {\n        throw new Error(\n            \x27Actions may not have an undefined \x26quot;type\x26quot; property. \x27 \x2b\n            \x27Have you misspelled a constant?\x27\n            )\n        }\n    if (isDispatching) {\n        throw new Error(\x27Reducers may not dispatch actions.\x27)\n    }\n    try {\n        isDispatching = true\n        currentState = currentReducer(currentState, action)\n    } finally {\n        isDispatching = false\n    }\n    listeners.slice().forEach(listener =\x3e listener())\n    return action\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(action)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n            \x3cspan class=\x22hljs-string\x22\x3e\x27Actions must be plain objects. \x27\x3c\/span\x3e \x2b\n            \x3cspan class=\x22hljs-string\x22\x3e\x27Use custom middleware for async actions.\x27\x3c\/span\x3e\n        )\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e action.type === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n            \x3cspan class=\x22hljs-string\x22\x3e\x27Actions may not have an undefined \x22type\x22 property. \x27\x3c\/span\x3e \x2b\n            \x3cspan class=\x22hljs-string\x22\x3e\x27Have you misspelled a constant?\x27\x3c\/span\x3e\n            )\n        }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDispatching) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Reducers may not dispatch actions.\x27\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        isDispatching = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        currentState = currentReducer(currentState, action)\n    } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n        isDispatching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    listeners.slice().forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e =\x26gt;\x3c\/span\x3e listener())\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e action\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e判断当前是否处于某个 action 的分发过程中，这个检查主要是为了避免在 reducer 中分发 action 的情况，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度。\x3c\/p\x3e\n\x3cp\x3e确认当前不属于分发过程中后，先设定标志位，然后将当前的状态和 action 传给当前的reducer，用于生成最新的 state。这看起来一点都不复杂，这也是我们反复强调的 reducer 工作过程——纯函数、接受状态和 action 作为参数，返回一个新的状态。\x3c\/p\x3e\n\x3cp\x3e在得到新的状态后，依次调用所有的监听器，通知状态的变更。需要注意的是，我们在通知监听器变更发生时，并没有将最新的状态作为参数传递给这些监听器。这是因为在监听器中，我们可以直接调用 store.getState() 方法拿到最新的状态。\x3c\/p\x3e\n\x3cp\x3e最终，处理之后的 action 会被 dispatch 方法返回。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ereplaceReducer\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \x27function\x27) {\n      throw new Error(\x27Expected the nextReducer to be a function.\x27);\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereplaceReducer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextReducer\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e nextReducer !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected the nextReducer to be a function.\x27\x3c\/span\x3e);\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: ActionTypes.INIT });\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是为了拿到所有 reducer 中的初始状态（你是否还记得在定义 reducer 时，第一个参数为previousState，如果该参数为空，我们提供默认的 initialState）。只有所有的初始状态都成功获取后，Redux 应用才能有条不紊地开始运作。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e3.Redux middleware\x3c\/h2\x3e\n\x3cblockquote\x3eIt provides a third-party extension point between dispatching an action, and the moment it reaches\x3cbr\x3ethe reducer\x3c\/blockquote\x3e\n\x3cp\x3e它提供了一个分类处理 action 的机会。在middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的action 进行相应操作，给你一次改变 action 的机会。\x3c\/p\x3e\n\x3cp\x3e常规的同步数据流模式的流程图如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV5UL5?w=1146\x26amp;h=206\x22 src=\x22https:\/\/static.alili.tech\/img\/bV5UL5?w=1146\x26amp;h=206\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV5UMt?w=1162\x26amp;h=260\x22 src=\x22https:\/\/static.alili.tech\/img\/bV5UMt?w=1162\x26amp;h=260\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。比如上面的业务，我们把处理log的代码封装成一个middleware，处理异步的也是一个middleware，两者串联，却又相互独立。\x3c\/p\x3e\n\x3cp\x3e使用middleware之后，action触发的dispatch并不是原来的dispatch，而是经过封装的new dispatch，在这个new dispatch中，按照顺序依次执行每个middleware，最后调用原生的dispatch。\x3c\/p\x3e\n\x3cp\x3e我们来看下logger middleware如何实现的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default store =\x3e next =\x3e action =\x3e {\n    console.log(\x27dispatch:\x27, action); \n    next(action);\n    console.log(\x27finish:\x27, action);\n } \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e store =\x26gt; \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enext\x3c\/span\x3e =\x26gt;\x3c\/span\x3e action =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27dispatch:\x27\x3c\/span\x3e, action); \n    next(action);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27finish:\x27\x3c\/span\x3e, action);\n } \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里代码十分简洁，就是在next调用下一个middleware之前和之后，分别打印两次。\x3c\/p\x3e\n\x3cp\x3eRedux 提供了 applyMiddleware 方法来加载 middleware，该方法的源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import compose from \x27.\/compose\x27;\n\nexport default function applyMiddleware(...middlewares) {\n    return function (next) {\n        return function (reducer, initialState) {\n            let store = next(reducer, initialState);\n            let dispatch = store.dispatch;\n            let chain = [];\n            var middlewareAPI = {\n                getState: store.getState,\n                dispatch: (action) =\x3e dispatch(action),\n            };\n            chain = middlewares.map(middleware =\x3e middleware(middlewareAPI));\n            dispatch = compose(...chain)(store.dispatch);\n\n            return {\n                ...store,\n                dispatch,\n            };\n        }\n    }\n}\n \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e compose \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/compose\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyMiddleware\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e...middlewares\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enext\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereducer, initialState\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e store = next(reducer, initialState);\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dispatch = store.dispatch;\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e chain = [];\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e middlewareAPI = {\n                \x3cspan class=\x22hljs-attr\x22\x3egetState\x3c\/span\x3e: store.getState,\n                \x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e dispatch(action),\n            };\n            chain = middlewares.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3emiddleware\x3c\/span\x3e =\x26gt;\x3c\/span\x3e middleware(middlewareAPI));\n            dispatch = compose(...chain)(store.dispatch);\n\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n                ...store,\n                dispatch,\n            };\n        }\n    }\n}\n \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中compose源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function compose(...funcs) {\n    return arg =\x3e funcs.reduceRight((composed, f) =\x3e f(composed), arg);\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecompose\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e...funcs\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3earg\x3c\/span\x3e =\x26gt;\x3c\/span\x3e funcs.reduceRight(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ecomposed, f\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e f(composed), arg);\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用的时候，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eok，相关源码已就位，我们来详细解析一波。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e函数式编程思想设计 \x3c\/strong\x3e：middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的\x3cbr\x3ecurrying，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个middleware 进行层层调用，动态地将 store 和 next 参数赋值。currying 的 middleware 结构的好处主要有以下两点。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e易串联：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。\x3c\/li\x3e\n\x3cli\x3e 共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e给 middleware 分发 store\x3c\/strong\x3e：newStore创建完成之后，applyMiddleware 方法陆续获得了3个参数，第一个是 middlewares 数组[mid1, mid2, mid3, ...]，第二个是 Redux 原生的 createStore ，最后一个是 reducer。然后，我们可以看到 applyMiddleware 利用 createStore 和 reducer 创建了一个 store。而 store 的 getState方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量 store：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const middlewareAPI = {\n getState: store.getState,\n dispatch: (action) =\x3e dispatch(action),\n};\nchain = middlewares.map(middleware =\x3e middleware(middlewareAPI)); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e middlewareAPI = {\n \x3cspan class=\x22hljs-attr\x22\x3egetState\x3c\/span\x3e: store.getState,\n \x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e dispatch(action),\n};\nchain = middlewares.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3emiddleware\x3c\/span\x3e =\x26gt;\x3c\/span\x3e middleware(middlewareAPI)); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后，让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍。执行完后，获得 chain数组 [f1, f2, ... , fx, ..., fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 middlewareAPI。\x3c\/p\x3e\n\x3cblockquote\x3emiddlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？\x3cp\x3e我们用 applyMiddleware 是为了改造 dispatch，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e组合串联 middleware\x3c\/strong\x3e：这一层只有一行代码，却是 applyMiddleware 精华之所在\x3ccode\x3edispatch = compose(...chain)(store.dispatch); \x3c\/code\x3e，其中 compose 是函数式编程中的组合，它将 chain 中的所有匿名函数 [f1, f2, ... , fx, ..., fn]组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行。\x3c\/p\x3e\n\x3cp\x3ecompose(...funcs) 返回的是一个匿名函数，其中 funcs 就是 chain 数组。当调用 reduceRight时，依次从 funcs 数组的右端取一个函数 fx 拿来执行，fx 的参数 composed 就是前一次 fx\x2b1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch。所以，当 compose 执行完后，我们得到的 dispatch 是这样的，假设 n = 3：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22dispatch = f1(f2(f3(store.dispatch)))); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3edispatch = f1(f2(f3(store.dispatch)))); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时调用新 dispatch，每一个 middleware 就依次执行了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e在 middleware 中调用 dispatch 会发生什么\x3c\/strong\x3e：经过 compose 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，我们提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，也可以拿到 store 的dispatch 属性。那么，在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？现在我们来说明两者的不同：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const logger = store =\x3e next =\x3e action =\x3e {\n console.log(\x27dispatch:\x27, action);\n next(action);\n console.log(\x27finish:\x27, action);\n};\nconst logger = store =\x3e next =\x3e action =\x3e {\n console.log(\x27dispatch:\x27, action);\n store.dispatch(action);\n console.log(\x27finish:\x27, action);\n}; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e logger = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estore\x3c\/span\x3e =\x26gt;\x3c\/span\x3e next =\x26gt; \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27dispatch:\x27\x3c\/span\x3e, action);\n next(action);\n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27finish:\x27\x3c\/span\x3e, action);\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e logger = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estore\x3c\/span\x3e =\x26gt;\x3c\/span\x3e next =\x26gt; \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27dispatch:\x27\x3c\/span\x3e, action);\n store.dispatch(action);\n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27finish:\x27\x3c\/span\x3e, action);\n}; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在分发 store 时我们解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终compose 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 store.dispatch() 和在其他任何地方调用的效果一样。而在 middleware 中调用 next()，效果是进入下一个 middleware，下图就是redux middleware最著名的洋葱模型图。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV5UMJ?w=1340\x26amp;h=594\x22 src=\x22https:\/\/static.alili.tech\/img\/bV5UMJ?w=1340\x26amp;h=594\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e4.combineReducer\x3c\/h2\x3e\n\x3cp\x3e如果一个项目过大，我们通常按模块来写reducer，但是redux create store只接受一个reducer参数，所以我们需要合并reducer。这里就用到了redux提供的\x3ccode\x3ecombineReducer\x3c\/code\x3e辅助函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22combineReducers({\n      layout,\n      home,\n      ...asyncReducers\n  })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ecombineReducers({\n      layout,\n      home,\n      ...asyncReducers\n  })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数用起来很简单，就是传入一个对象，key是模块reducer对应的名字， 值是对应reducer。值是一个function，相当于是一个新的reducer，源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers)\n  var finalReducers = {}\n  for (var i = 0; i \x3c reducerKeys.length; i\x2b\x2b) {\n    var key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      if (typeof reducers[key] === \x27undefined\x27) {\n        warning(`No reducer provided for key \x26quot;${key}\x26quot;`)\n      }\n    }\n\n    if (typeof reducers[key] === \x27function\x27) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers)\n\n  if (process.env.NODE_ENV !== \x27production\x27) {\n    var unexpectedKeyCache = {}\n  }\n\n  var sanityError\n  try {\n    assertReducerSanity(finalReducers)\n  } catch (e) {\n    sanityError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (sanityError) {\n      throw sanityError\n    }\n\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    var hasChanged = false\n    var nextState = {}\n    for (var i = 0; i \x3c finalReducerKeys.length; i\x2b\x2b) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      var previousStateForKey = state[key]\n      var nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === \x27undefined\x27) {\n        var errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecombineReducers\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereducers\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reducerKeys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(reducers)\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e finalReducers = {}\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; reducerKeys.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = reducerKeys[i]\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e reducers[key] === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        warning(\x3cspan class=\x22hljs-string\x22\x3e`No reducer provided for key \x22\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e reducers[key] === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e finalReducerKeys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(finalReducers)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e unexpectedKeyCache = {}\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sanityError\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    assertReducerSanity(finalReducers)\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    sanityError = e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecombination\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = {}, action\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sanityError) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e sanityError\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hasChanged = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextState = {}\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; finalReducerKeys.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = finalReducerKeys[i]\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reducer = finalReducers[key]\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e previousStateForKey = state[key]\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextStateForKey = reducer(previousStateForKey, action)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e nextStateForKey === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e errorMessage = getUndefinedStateErrorMessage(key, action)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hasChanged ? nextState : state\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e源码不是很多，除去一些验证代码，剩下的就是说：return一个function，我们暂时称呼他combination，就相当于是与一个总的reducer，每次action都会走到combination中，combination会遍历输入的reducer，将action放到每个reducer中执行一下，计算出返回结果就是nextState，nextState于previousState如果!==说明改变了，返回nextState，否则返回执行之前的state。\x3c\/p\x3e\n\x3cp\x3e这也解释了不同模块actionType如果相同的话，两个模块的reducer都会走一遍的问题，在actionType名称前面加上模块前缀即可解决问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e5. Provider与Connect\x3c\/h2\x3e\n\x3cp\x3eProvider与Connet组件都是React-Redux提供的核心组件，两者看起来功能一样，都是帮助容器组件获取store中的数据，但是原理与功能却不同。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eProvider\x3c\/h3\x3e\n\x3cp\x3eProvider组件在所有组件的最外层，其接受store作为参数，将store里的state使用context属性向下传递。部分源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Provider extends Component {\n getChildContext() {\n return { store: this.store }\n }\n constructor(props, context) {\n super(props, context)\n this.store = props.store\n }\n render() {\n const { children } = this.props\n return Children.only(children)\n }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n getChildContext() {\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store }\n }\n \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context)\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store = props.store\n }\n render() {\n \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { children } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Children.only(children)\n }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e利用context这个属性，Provider所有子组件均可以拿到这个属性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eConnect\x3c\/h3\x3e\n\x3cp\x3econnect实现的功能是将需要关联store的组件和store的dispatch等数据混合到一块，这块就是一个高阶组件典型的应用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import hoistStatics from \x27hoist-non-react-statics\x27\nexport default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n \/\/ ...\n return function wrapWithConnect(WrappedComponent) {\n \/\/ ...\n class Connect extends Component {\n \/\/ ...\n render() {\n \/\/ ...\n if (withRef) {\n this.renderedElement = createElement(WrappedComponent, {\n ...this.mergedProps,\n ref: \x27wrappedInstance\x27\n })\n } else {\n this.renderedElement = createElement(WrappedComponent,\n this.mergedProps\n )\n }\n return this.renderedElement\n }\n }\n \/\/ ...\n return hoistStatcis(Connect, WrappedComponent);\n }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e hoistStatics \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hoist-non-react-statics\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emapStateToProps, mapDispatchToProps, mergeProps, options = {}\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrapWithConnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n render() {\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (withRef) {\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement = createElement(WrappedComponent, {\n ...this.mergedProps,\n \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27wrappedInstance\x27\x3c\/span\x3e\n })\n } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement = createElement(WrappedComponent,\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mergedProps\n )\n }\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement\n }\n }\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hoistStatcis(Connect, WrappedComponent);\n }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还是先从他的四个参数说起：\x3c\/p\x3e\n\x3ch4\x3e1.mapStateToProps\x3c\/h4\x3e\n\x3cp\x3econnect 的第一个参数定义了我们需要从 Redux 状态树中提取哪些部分当作 props 传给当前组件。一般来说，这也是我们使用 connect 时经常传入的参数。事实上，如果不传入这个参数，React 组件将永远不会和 Redux 的状态树产生任何关系。具体在源代码中的表现为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n const shouldSubscribe = Boolean(mapStateToProps)\n \/\/ ...\n class Connect extends Component {\n \/\/ ...\n trySubscribe() {\n if (shouldSubscribe \x26amp;\x26amp; !this.unsubscribe) {\n this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n this.handleChange()\n }\n }\n \/\/ ...\n }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emapStateToProps, mapDispatchToProps, mergeProps, options = {}\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e shouldSubscribe = \x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e(mapStateToProps)\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n trySubscribe() {\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (shouldSubscribe \x26amp;\x26amp; !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.unsubscribe) {\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.unsubscribe = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.subscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e))\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleChange()\n }\n }\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emapStateToProps\x3c\/code\x3e会订阅 Store，每当\x3ccode\x3estate\x3c\/code\x3e更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3emapStateToProps\x3c\/code\x3e的第一个参数总是\x3ccode\x3estate\x3c\/code\x3e对象，还可以使用第二个参数，代表容器组件的\x3ccode\x3eprops\x3c\/code\x3e对象。\x3c\/p\x3e\n\x3cp\x3e这块的源码相对较简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const mapState = mapStateToProps || defaultMapStateToProps \nclass Connect extends Component { \n    computeStateProps(store, props) {\n        if (!this.finalMapStateToProps) {\n          return this.configureFinalMapState(store, props)\n        }\n\n        const state = store.getState()\n        const stateProps = this.doStatePropsDependOnOwnProps ?\n          this.finalMapStateToProps(state, props) :\n          this.finalMapStateToProps(state)\n\n        if (process.env.NODE_ENV !== \x27production\x27) {\n          checkStateShape(stateProps, \x27mapStateToProps\x27)\n        }\n        return stateProps\n      }\n\n      configureFinalMapState(store, props) {\n        const mappedState = mapState(store.getState(), props)\n        const isFactory = typeof mappedState === \x27function\x27\n\n        this.finalMapStateToProps = isFactory ? mappedState : mapState\n        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1\n\n        if (isFactory) {\n          return this.computeStateProps(store, props)\n        }\n\n        if (process.env.NODE_ENV !== \x27production\x27) {\n          checkStateShape(mappedState, \x27mapStateToProps\x27)\n        }\n        return mappedState\n      }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapState = mapStateToProps || defaultMapStateToProps \n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{ \n    computeStateProps(store, props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.finalMapStateToProps) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.configureFinalMapState(store, props)\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e state = store.getState()\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stateProps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doStatePropsDependOnOwnProps ?\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.finalMapStateToProps(state, props) :\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.finalMapStateToProps(state)\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n          checkStateShape(stateProps, \x3cspan class=\x22hljs-string\x22\x3e\x27mapStateToProps\x27\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e stateProps\n      }\n\n      configureFinalMapState(store, props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mappedState = mapState(store.getState(), props)\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isFactory = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e mappedState === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.finalMapStateToProps = isFactory ? mappedState : mapState\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doStatePropsDependOnOwnProps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.finalMapStateToProps.length !== \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFactory) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.computeStateProps(store, props)\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n          checkStateShape(mappedState, \x3cspan class=\x22hljs-string\x22\x3e\x27mapStateToProps\x27\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mappedState\n      }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这块原理很简单，进行一些参数校验，判断第一个参数mapStateToProps返回值是否为function，如果是递归调用，不是的话算出返回值。如果没传这个参数，默认给{}。\x3c\/p\x3e\n\x3cblockquote\x3e我们可能会疑惑为什么传给 connect 的第一个参数本身是一个函数，react-redux 还允许这个函数的返回值也是一个函数呢？\x3cbr\x3e简单地说，这样设计可以允许我们在 connect 的第一个参数里利用函数闭包进行一些复杂计算的缓存，从而实现效率优化的目的\x3c\/blockquote\x3e\n\x3cp\x3e当我们使用的时候：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const mapStateToProps = (state, props) =\x3e ({\n    home: state.home,\n    layout: state.layout\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate, props\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e ({\n    \x3cspan class=\x22hljs-attr\x22\x3ehome\x3c\/span\x3e: state.home,\n    \x3cspan class=\x22hljs-attr\x22\x3elayout\x3c\/span\x3e: state.layout\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3ccode\x3eownProps\x3c\/code\x3e作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染\x3c\/p\x3e\n\x3ch4\x3e2.mapDispatchToProps\x3c\/h4\x3e\n\x3cp\x3e人如其名，它接受 store 的 dispatch 作为第一个参数，同时接受 this.props 作为可选的第二个参数。利用这个方法，我们可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起（利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件。这块的源码与mapStateToProps一样，就不贴了。\x3c\/p\x3e\n\x3cp\x3ebindActionCreator\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bindActionCreator(actionCreator, dispatch) {\n  return (...args) =\x3e dispatch(actionCreator(...args))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebindActionCreator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eactionCreator, dispatch\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e dispatch(actionCreator(...args))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e3.mergeProps\x3c\/h4\x3e\n\x3cp\x3e前两个参数返回的对象，都要跟组件自身的props merge一下，形成一个新的对象赋值给对应组件，我们可以在这一步做一些处理，这个参数就是干这个的，该参数签名：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mergeProps(stateProps, dispatchProps, ownProps): props\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3emergeProps(stateProps, dispatchProps, ownProps): props\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e默认情况如果没传该参数，返回\x3ccode\x3eObject.assign(ownProps, stateProps, dispatchProps)\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e4.options\x3c\/h4\x3e\n\x3cp\x3e如果指定这个参数，可以定制 connector 的行为。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e[\x3ccode\x3epure = true\x3c\/code\x3e] \x3cem\x3e(Boolean)\x3c\/em\x3e: 如果为 true，connector 将执行 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 并且浅对比 \x3ccode\x3emergeProps\x3c\/code\x3e 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。\x3cem\x3e默认值为 true。\x3c\/em\x3e\n\x3c\/li\x3e\n\x3cli\x3e[\x3ccode\x3ewithRef = false\x3c\/code\x3e] \x3cem\x3e(Boolean)\x3c\/em\x3e: 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 \x3ccode\x3egetWrappedInstance()\x3c\/code\x3e 方法获得。\x3cem\x3e默认值为 false。\x3c\/em\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这个connect组件还干了一件事，状态缓存判断。当store变了的时候，前后状态判断，如果状态不等，更新组件，并且完成事件分发。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e6. Redux流程梳理\x3c\/h2\x3e\n\x3cp\x3e上面讲了大量的函数源码，这么些函数之间的关系：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV5UM9?w=985\x26amp;h=1370\x22 src=\x22https:\/\/static.alili.tech\/img\/bV5UM9?w=985\x26amp;h=1370\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e初始化阶段：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ecreateStore创建一个store对象\x3c\/li\x3e\n\x3cli\x3e将store对象通过参数给Provider组件\x3c\/li\x3e\n\x3cli\x3eProvider组件将store通过context向子组件传递\x3c\/li\x3e\n\x3cli\x3eConnect组件通过context获取到store，存入自己的state\x3c\/li\x3e\n\x3cli\x3ecomponentDidMount里面订阅store.subscribe事件\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e更新数据阶段：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用户事件触发\x3c\/li\x3e\n\x3cli\x3eactionCreator生成action交给dispatch\x3c\/li\x3e\n\x3cli\x3e实际上交给了封装后的中间层（compose(applyMiddleware(...))）\x3c\/li\x3e\n\x3cli\x3e请求依次通过每个中间件，中间件通过next进行下一步\x3c\/li\x3e\n\x3cli\x3e最后一个中间件将action交给store.dispatch\x3c\/li\x3e\n\x3cli\x3edispatch内部将action交给reducer执行\x3c\/li\x3e\n\x3cli\x3ecombineReducer将每个子reducer执行一遍算出新的state\x3c\/li\x3e\n\x3cli\x3edispatch内部调用所有订阅事件\x3c\/li\x3e\n\x3cli\x3eConnect组件handleChange事件触发判断新state和旧state是否===\x3c\/li\x3e\n\x3cli\x3e并且判断新的state是否与mapStateToProps shallowEqual\x3c\/li\x3e\n\x3cli\x3e不等则setState触发更新\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e7.Redux设计技巧\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e匿名函数\x26amp;\x26amp;闭包使用\x3cp\x3eredux核心函数大量使用了匿名函数和闭包来实现数据共享和状态同步。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e函数柯里化使用\x3cp\x3e使用函数柯里化s实现参数复用，本质上是降低通用性，提高适用性。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e核心状态读取是拷贝而不是地址\x3cp\x3e对于state这种核心状态使用getState()计算出新的state，而不是直接返回一个state对象。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e观察者订阅者是核心实现\x3cp\x3e使用观察者订阅者模式实现数据响应。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3econtext这个api的使用\x3cp\x3e平时开发不常接触的api实现Provider与Connect通信。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Redux源码分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013763950">https://segmentfault.com/a/1190000013763950</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bvzyw5s3wdo/" target="_blank">https://alili.tech/archive/bvzyw5s3wdo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>