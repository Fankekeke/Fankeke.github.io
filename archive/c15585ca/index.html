<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="尾调用、优化和 ES6"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>尾调用、优化和 ES6 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c15585ca/",
				"appid": "1613049289050283", 
				"title": "尾调用、优化和 ES6 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9c0662f4/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7f16801f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&text=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&text=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&title=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&is_video=false&description=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&title=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&title=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&title=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc15585ca%2f&title=%e5%b0%be%e8%b0%83%e7%94%a8%e3%80%81%e4%bc%98%e5%8c%96%e5%92%8c%20ES6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">尾调用、优化和 ES6</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#尾调用优化和-es6\x22\x3e\x3c\/a\x3e尾调用、优化和 ES6\x3c\/h1\x3e\n\x3cp\x3e在探秘“栈”的倒数第二篇文章中，我们提到了尾调用tail call、编译优化、以及新发布的 JavaScript 上合理尾调用proper tail call。\x3c\/p\x3e\n\x3cp\x3e当一个函数 F 调用另一个函数作为它的结束动作时，就发生了一个\x3cstrong\x3e尾调用\x3c\/strong\x3e。在那个时间点，函数 F 绝对不会有多余的工作：函数 F 将“球”传给被它调用的任意函数之后，它自己就“消失”了。这就是关键点，因为它打开了尾调用优化的“可能之门”：我们可以简单地重用函数 F 的栈帧，而不是为函数调用 \x3ca href=\x22https:\/\/manybutfinite.com\/post\/journey-to-the-stack\x22\x3e创建一个新的栈帧\x3c\/a\x3e，因此节省了栈空间并且避免了新建一个栈帧所需要的工作量。下面是一个用 C 写的简单示例，然后使用 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/asm-tco.sh\x22\x3emild 优化\x3c\/a\x3e 来编译它的结果：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs aspectj\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd5\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e a)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd10\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e a)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e b = add5(a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd5\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(b)\x3c\/span\x3e\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd5AndTriple\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e a)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e b = add5(a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e * add5(a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail, doing work after the call\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efinicky\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e a)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a \x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e){\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd5AndTriple\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a)\x3c\/span\x3e\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a \x26gt; \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e){\n        \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e b = add5(a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efinicky\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(b)\x3c\/span\x3e\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd10\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a)\x3c\/span\x3e\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3e简单的尾调用 \x3ca href=\x22https:\/\/manybutfinite.com\/code\/x86-stack\/tail.c\x22\x3e下载\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e在编译器的输出中，在预期会有一个 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/tail.s#L37-L39\x22\x3e调用\x3c\/a\x3e 的地方，你可以看到一个 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/tail-tco.s#L27\x22\x3e跳转\x3c\/a\x3e 指令，一般情况下你可以发现尾调用优化（以下简称 TCO）。在运行时中，TCO 将会引起调用栈的减少。\x3c\/p\x3e\n\x3cp\x3e一个通常认为的错误观念是，尾调用必须要 \x3ca href=\x22https:\/\/manybutfinite.com\/post\/recursion\/\x22\x3e递归\x3c\/a\x3e。实际上并不是这样的：一个尾调用可以被递归，比如在上面的 \x3ccode\x3efinicky()\x3c\/code\x3e 中，但是，并不是必须要使用递归的。在调用点只要函数 F 完成它的调用，我们将得到一个单独的尾调用。是否能够进行优化这是一个另外的问题，它取决于你的编程环境。\x3c\/p\x3e\n\x3cp\x3e“是的，它总是可以！”，这是我们所希望的最佳答案，它是著名的 Scheme 中的方式，就像是在 \x3ca href=\x22https:\/\/mitpress.mit.edu\/sites\/default\/files\/sicp\/full-text\/book\/book-Z-H-11.html\x22\x3eSICP\x3c\/a\x3e上所讨论的那样（顺便说一声，如果你的程序不像“一个魔法师使用你的咒语召唤你的电脑精灵”那般有效，建议你读一下这本书）。它也是 \x3ca href=\x22http:\/\/www.lua.org\/pil\/6.3.html\x22\x3eLua\x3c\/a\x3e 的方式。而更重要的是，它是下一个版本的 JavaScript —— ES6 的方式，这个规范清晰地定义了\x3ca href=\x22https:\/\/people.mozilla.org\/%7Ejorendorff\/es6-draft.html#sec-tail-position-calls\x22\x3e尾的位置\x3c\/a\x3e，并且明确了优化所需要的几个条件，比如，\x3ca href=\x22https:\/\/people.mozilla.org\/%7Ejorendorff\/es6-draft.html#sec-strict-mode-code\x22\x3e严格模式\x3c\/a\x3e。当一个编程语言保证可用 TCO 时，它将支持合理尾调用proper tail call。\x3c\/p\x3e\n\x3cp\x3e现在，我们中的一些人不能抛开那些 C 的习惯，心脏出血，等等，而答案是一个更复杂的“有时候”，它将我们带进了编译优化的领域。我们看一下上面的那个 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/tail.c\x22\x3e简单示例\x3c\/a\x3e；把我们 \x3ca href=\x22https:\/\/linux.cn\/article-9609-1.html\x22\x3e上篇文章\x3c\/a\x3e 的阶乘程序重新拿出来：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e  \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;stdio.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efactorial\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e n)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e previous = \x3cspan class=\x22hljs-number\x22\x3e0xdeadbeef\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e || n == \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    }\n\n    previous = factorial(n\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n * previous;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e answer = factorial(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22%d\\n\x22\x3c\/span\x3e, answer);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3e递归阶乘 \x3ca href=\x22https:\/\/manybutfinite.com\/code\/x86-stack\/factorial.c\x22\x3e下载\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e像第 11 行那样的，是尾调用吗？答案是：“不是”，因为它被后面的 \x3ccode\x3en\x3c\/code\x3e 相乘了。但是，如果你不去优化它，GCC 使用 \x3ca href=\x22https:\/\/gcc.gnu.org\/onlinedocs\/gcc\/Optimize-Options.html\x22\x3eO2 优化\x3c\/a\x3e 的 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/factorial-o2.s\x22\x3e结果\x3c\/a\x3e 会让你震惊：它不仅将阶乘转换为一个 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/factorial-o2.s#L16-L19\x22\x3e无递归循环\x3c\/a\x3e，而且 \x3ccode\x3efactorial(5)\x3c\/code\x3e 调用被整个消除了，而以一个 120 (\x3ccode\x3e5! == 120\x3c\/code\x3e) 的 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/factorial-o2.s#L38\x22\x3e编译时常数\x3c\/a\x3e来替换。这就是调试优化代码有时会很难的原因。好的方面是，如果你调用这个函数，它将使用一个单个的栈帧，而不会去考虑 n 的初始值。编译算法是非常有趣的，如果你对它感兴趣，我建议你去阅读 \x3ca href=\x22http:\/\/www.amazon.com\/Building-Optimizing-Compiler-Bob-Morgan-ebook\/dp\/B008COCE9G\/\x22\x3e构建一个优化编译器\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/www.amazon.com\/Advanced-Compiler-Design-Implementation-Muchnick-ebook\/dp\/B003VM7GGK\/\x22\x3eACDI\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e但是，这里\x3cstrong\x3e没有\x3c\/strong\x3e做尾调用优化时到底发生了什么？通过分析函数的功能和无需优化的递归发现，GCC 比我们更聪明，因为一开始就没有使用尾调用。由于过于简单以及很确定的操作，这个任务变得很简单。我们给它增加一些可以引起混乱的东西（比如，\x3ccode\x3egetpid()\x3c\/code\x3e），我们给 GCC 增加难度：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;stdio.h\x26gt; \x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;sys\/types.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;unistd.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epidFactorial\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e n)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e == n) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e getpid(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n * pidFactorial(n\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) * getpid(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e answer = pidFactorial(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22%d\\n\x22\x3c\/span\x3e, answer);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3e递归 PID 阶乘 \x3ca href=\x22https:\/\/manybutfinite.com\/code\/x86-stack\/pidFactorial.c\x22\x3e下载\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e优化它，unix 精灵！现在，我们有了一个常规的 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/pidFactorial-o2.s#L20\x22\x3e递归调用\x3c\/a\x3e 并且这个函数分配 O(n) 栈帧来完成工作。GCC 在递归的基础上仍然 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/pidFactorial-o2.s#L43\x22\x3e为 getpid 使用了 TCO\x3c\/a\x3e。如果我们现在希望让这个函数尾调用递归，我需要稍微变一下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;stdio.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;sys\/types.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;unistd.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etailPidFactorial\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e n, \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e acc)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e == n) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e acc * getpid(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ not tail\x3c\/span\x3e\n    }\n\n    acc = (acc * getpid() * n);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e tailPidFactorial(n\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e, acc); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tail\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e answer = tailPidFactorial(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22%d\\n\x22\x3c\/span\x3e, answer);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3etailPidFactorial.c \x3ca href=\x22https:\/\/manybutfinite.com\/code\/x86-stack\/tailPidFactorial.c\x22\x3e下载\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e现在，结果的累加是 \x3ca href=\x22https:\/\/github.com\/gduarte\/blog\/blob\/master\/code\/x86-stack\/tailPidFactorial-o2.s#L22-L27\x22\x3e一个循环\x3c\/a\x3e，并且我们获得了真实的 TCO。但是，在你庆祝之前，我们能说一下关于在 C 中的一般情形吗？不幸的是，虽然优秀的 C 编译器在大多数情况下都可以实现 TCO，但是，在一些情况下它们仍然做不到。例如，正如我们在 \x3ca href=\x22https:\/\/manybutfinite.com\/post\/epilogues-canaries-buffer-overflows\/\x22\x3e函数序言\x3c\/a\x3e 中所看到的那样，函数调用者在使用一个标准的 C 调用规则调用一个函数之后，它要负责去清理栈。因此，如果函数 F 带了两个参数，它只能使 TCO 调用的函数使用两个或者更少的参数。这是 TCO 的众多限制之一。Mark Probst 写了一篇非常好的论文，他们讨论了 \x3ca href=\x22http:\/\/www.complang.tuwien.ac.at\/schani\/diplarb.ps\x22\x3e在 C 中的合理尾递归\x3c\/a\x3e，在这篇论文中他们讨论了这些属于 C 栈行为的问题。他也演示一些 \x3ca href=\x22http:\/\/www.complang.tuwien.ac.at\/schani\/jugglevids\/index.html\x22\x3e疯狂的、很酷的欺骗方法\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e“有时候” 对于任何一种关系来说都是不坚定的，因此，在 C 中你不能依赖 TCO。它是一个在某些地方可以或者某些地方不可以的离散型优化，而不是像合理尾调用一样的编程语言的特性，虽然在实践中可以使用编译器来优化绝大部分的情形。但是，如果你想必须要实现 TCO，比如将 Scheme 转译transpilation成 C，你将会 \x3ca href=\x22http:\/\/en.wikipedia.org\/wiki\/Tail_call#Through_trampolining\x22\x3e很痛苦\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e因为 JavaScript 现在是非常流行的转译对象，合理尾调用比以往更重要。因此，对 ES6 及其提供的许多其它的重大改进的赞誉并不为过。它就像 JS 程序员的圣诞节一样。\x3c\/p\x3e\n\x3cp\x3e这就是尾调用和编译优化的简短结论。感谢你的阅读，下次再见！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3evia:\x3ca href=\x22https:\/\/manybutfinite.com\/post\/tail-calls-optimization-es6\/\x22\x3ehttps:\/\/manybutfinite.com\/post\/tail-calls-optimization-es6\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22http:\/\/duartes.org\/gustavo\/blog\/about\/\x22\x3eGustavo Duarte\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/qhwdw\x22\x3eqhwdw\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/tail-calls-optimization-and-es6">https://www.zcfy.cc/article/tail-calls-optimization-and-es6</a> 原文标题: 尾调用、优化和 ES6 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/c15585ca/" target="_blank">https://alili.tech/archive/c15585ca/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>