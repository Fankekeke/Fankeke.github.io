<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="聊聊lodash的debounce实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>聊聊lodash的debounce实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c6tj1ctbhc/",
				"appid": "1613049289050283", 
				"title": "聊聊lodash的debounce实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-25T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4pef03rxyr6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/l7nuulsjwd/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&text=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&text=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&title=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&is_video=false&description=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&title=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&title=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&title=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc6tj1ctbhc%2f&title=%e8%81%8a%e8%81%8alodash%e7%9a%84debounce%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">聊聊lodash的debounce实现</h1><div class="meta"><div class="postdate"><time datetime="2018-12-25" itemprop="datePublished">2018-12-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本文同步自我的\x3ca href=\x22https:\/\/github.com\/ZhangFe\/Blog\/issues\/8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBlog\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e前段时间团队内部搞了一个代码训练营，大家组织在一起实现 \x3ccode\x3elodash\x3c\/code\x3e 的 \x3ccode\x3ethrottle\x3c\/code\x3e 和 \x3ccode\x3edebounce\x3c\/code\x3e，实现起来觉得并不麻烦，但是最后和官方的一对比，发现功能的实现上还是有差距的，为了寻找我的问题，把官方源码阅读了一遍，本文是我阅读完成后的一篇总结。\x3c\/p\x3e\n\x3cp\x3e本文只会列出比较核心部分的代码和注释，如果对全部的源码有兴趣的欢迎直接看我的\x3ca href=\x22https:\/\/github.com\/ZhangFe\/source-code-learning\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erepo\x3c\/a\x3e：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e什么是throttle和debounce\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ethrottle\x3c\/code\x3e(又称节流)和\x3ccode\x3edebounce\x3c\/code\x3e(又称防抖)其实都是函数调用频率的控制器，这里只做简单的介绍，如果想了解更多关于这两个定义的细节可以看下后文给出的一张图片，或者阅读一下\x3ca href=\x22https:\/\/lodash.com\/docs\/4.17.4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elodash的文档\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ethrottle\x3c\/code\x3e：将一个函数的调用频率限制在一定阈值内，例如 1s 内一个函数不能被调用两次。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edebounce\x3c\/code\x3e：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间，举个简单的例子，我们要根据用户输入做suggest，每当用户按下键盘的时候都可以取消前一次，并且只关心最后一次输入的时间就行了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3elodash\x3c\/code\x3e 对这两个函数又增加了一些参数，主要是以下三个：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eleading，函数在每个等待时延的开始被调用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etrailing，函数在每个等待时延的结束被调用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3emaxwait(debounce才有的配置)，最大的等待时间，因为如果 \x3ccode\x3edebounce\x3c\/code\x3e 的函数调用时间不满足条件，可能永远都无法触发，因此增加了这个配置，保证大于一段时间后一定能执行一次函数\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e这里直接剧透一下，其实 \x3ccode\x3ethrottle\x3c\/code\x3e 就是设置了 \x3ccode\x3emaxwait\x3c\/code\x3e 的 \x3ccode\x3edebounce\x3c\/code\x3e，所以我这里也只会介绍 \x3ccode\x3edebounce\x3c\/code\x3e 的代码，聪明的读者们可以自己思考一下为什么。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e我的实现与lodash的区别\x3c\/h2\x3e\n\x3cp\x3e我自己的代码实现放在我的\x3ca href=\x22https:\/\/github.com\/ZhangFe\/source-code-learning\/blob\/master\/debounce-throttle\/my-debounce.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erepo\x3c\/a\x3e里，大家有兴趣的可以看下。之前说过我的实现和 \x3ccode\x3elodash\x3c\/code\x3e 有些区别，下面就用两张图来展示一下。\x3c\/p\x3e\n\x3cp\x3e这是我的实现\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012102377?w=318\x26amp;h=435\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012102377?w=318\x26amp;h=435\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这是lodash的实现\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012106233?w=451\x26amp;h=443\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012106233?w=451\x26amp;h=443\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里看到，我的代码主要有两个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ethrottle\x3c\/code\x3e 的最后一次函数会执行两次，而且并非稳定复现。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ethrottle\x3c\/code\x3e 里函数执行的顺序不对，虽然我的功能实现了，但是对于每一次 \x3ccode\x3ewait\x3c\/code\x3e 来说，我都是执行的 \x3ccode\x3eleading\x3c\/code\x3e 那一次\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3elodash 的实现解读\x3c\/h2\x3e\n\x3cp\x3e下面，我就会带着这几个问题去看看 \x3ccode\x3elodasah\x3c\/code\x3e 的代码。\x3c\/p\x3e\n\x3cp\x3e官方代码的实现也不是很复杂，这里我贴出一些核心部分代码和我阅读后的注释，后面会讲一下 lodash 的大概流程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function debounce(func, wait, options) {\n    let lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime\n\n    \/\/ 参数初始化\n    let lastInvokeTime = 0 \/\/ func 上一次执行的时间\n    let leading = false\n    let maxing = false\n    let trailing = true\n\n    \/\/ 基本的类型判断和处理\n    if (typeof func != \x27function\x27) {\n        throw new TypeError(\x27Expected a function\x27)\n    }\n    wait = \x2bwait || 0\n    if (isObject(options)) {\n        \/\/ 对配置的一些初始化\n    }\n\n    function invokeFunc(time) {\n        const args = lastArgs\n        const thisArg = lastThis\n\n        lastArgs = lastThis = undefined\n        lastInvokeTime = time\n        result = func.apply(thisArg, args)\n        return result\n    }\n\n    function leadingEdge(time) {\n        \/\/ Reset any `maxWait` timer.\n        lastInvokeTime = time\n        \/\/ 为 trailing edge 触发函数调用设定定时器\n        timerId = setTimeout(timerExpired, wait)\n        \/\/ leading = true 执行函数\n        return leading ? invokeFunc(time) : result\n    }\n\n   function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime \/\/ 距离上次debounced函数被调用的时间\n        const timeSinceLastInvoke = time - lastInvokeTime \/\/ 距离上次函数被执行的时间\n        const timeWaiting = wait - timeSinceLastCall \/\/ 用 wait 减去 timeSinceLastCall 计算出下一次trailing的位置\n\n        \/\/ 两种情况\n        \/\/ 有maxing:比较出下一次maxing和下一次trailing的最小值，作为下一次函数要执行的时间\n        \/\/ 无maxing：在下一次trailing时执行 timerExpired\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting\n    }\n\n    \/\/ 根据时间判断 func 能否被执行\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime\n        const timeSinceLastInvoke = time - lastInvokeTime\n\n        \/\/ 几种满足条件的情况\n        return (lastCallTime === undefined \/\/首次\n            || (timeSinceLastCall \x3e= wait) \/\/ 距离上次被调用已经超过 wait\n            || (timeSinceLastCall \x3c 0) \/\/系统时间倒退\n            || (maxing \x26amp;\x26amp; timeSinceLastInvoke \x3e= maxWait)) \/\/超过最大等待时间\n    }\n\n    function timerExpired() {\n        const time = Date.now()\n        \/\/ 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器\n        if (shouldInvoke(time)) {\n            return trailingEdge(time)\n        }\n        \/\/ 重启定时器，保证下一次时延的末尾触发\n        timerId = setTimeout(timerExpired, remainingWait(time))\n    }\n\n    function trailingEdge(time) {\n        timerId = undefined\n\n        \/\/ 有lastArgs才执行，意味着只有 func 已经被 debounced 过一次以后才会在 trailing edge 执行\n        if (trailing \x26amp;\x26amp; lastArgs) {\n            return invokeFunc(time)\n        }\n        \/\/ 每次 trailingEdge 都会清除 lastArgs 和 lastThis，目的是避免最后一次函数被执行了两次\n        \/\/ 举个例子：最后一次函数执行的时候，可能恰巧是前一次的 trailing edge，函数被调用，而这个函数又需要在自己时延的 trailing edge 触发，导致触发多次\n        lastArgs = lastThis = undefined\n        return result\n    }\n\n    function cancel() {}\n\n    function flush() {}\n\n    function pending() {}\n\n    function debounced(...args) {\n        const time = Date.now()\n        const isInvoking = shouldInvoke(time) \/\/是否满足时间条件\n\n        lastArgs = args\n        lastThis = this\n        lastCallTime = time  \/\/函数被调用的时间\n\n        if (isInvoking) {\n            if (timerId === undefined) { \/\/ 无timerId的情况有两种：1.首次调用 2.trailingEdge执行过函数\n                return leadingEdge(lastCallTime)\n            }\n            if (maxing) {\n                \/\/ Handle invocations in a tight loop.\n                timerId = setTimeout(timerExpired, wait)\n                return invokeFunc(lastCallTime)\n            }\n        }\n        \/\/ 负责一种case：trailing 为 true 的情况下，在前一个 wait 的 trailingEdge 已经执行了函数；\n        \/\/ 而这次函数被调用时 shouldInvoke 不满足条件，因此要设置定时器，在本次的 trailingEdge 保证函数被执行\n        if (timerId === undefined) {\n            timerId = setTimeout(timerExpired, wait)\n        }\n        return result\n    }\n    debounced.cancel = cancel\n    debounced.flush = flush\n    debounced.pending = pending\n    return debounced\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edebounce\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, wait, options)\x3c\/span\x3e \x3c\/span\x3e{\n    let lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数初始化\x3c\/span\x3e\n    let lastInvokeTime = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ func 上一次执行的时间\x3c\/span\x3e\n    let leading = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    let maxing = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    let trailing = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 基本的类型判断和处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e func != \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TypeError(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected a function\x27\x3c\/span\x3e)\n    }\n    wait = \x2bwait || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isObject(options)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对配置的一些初始化\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einvokeFunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(time)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e args = lastArgs\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e thisArg = lastThis\n\n        lastArgs = lastThis = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n        lastInvokeTime = time\n        result = func.apply(thisArg, args)\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eleadingEdge\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(time)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Reset any `maxWait` timer.\x3c\/span\x3e\n        lastInvokeTime = time\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为 trailing edge 触发函数调用设定定时器\x3c\/span\x3e\n        timerId = setTimeout(timerExpired, wait)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ leading = true 执行函数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e leading ? invokeFunc(time) : result\n    }\n\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eremainingWait\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(time)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeSinceLastCall = time - lastCallTime \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 距离上次debounced函数被调用的时间\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeSinceLastInvoke = time - lastInvokeTime \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 距离上次函数被执行的时间\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeWaiting = wait - timeSinceLastCall \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用 wait 减去 timeSinceLastCall 计算出下一次trailing的位置\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 两种情况\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有maxing:比较出下一次maxing和下一次trailing的最小值，作为下一次函数要执行的时间\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 无maxing：在下一次trailing时执行 timerExpired\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据时间判断 func 能否被执行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshouldInvoke\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(time)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeSinceLastCall = time - lastCallTime\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeSinceLastInvoke = time - lastInvokeTime\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 几种满足条件的情况\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (lastCallTime === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/首次\x3c\/span\x3e\n            || (timeSinceLastCall \x26gt;= wait) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 距离上次被调用已经超过 wait\x3c\/span\x3e\n            || (timeSinceLastCall \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/系统时间倒退\x3c\/span\x3e\n            || (maxing \x26amp;\x26amp; timeSinceLastInvoke \x26gt;= maxWait)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/超过最大等待时间\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimerExpired\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time = Date.now()\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (shouldInvoke(time)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e trailingEdge(time)\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重启定时器，保证下一次时延的末尾触发\x3c\/span\x3e\n        timerId = setTimeout(timerExpired, remainingWait(time))\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etrailingEdge\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(time)\x3c\/span\x3e \x3c\/span\x3e{\n        timerId = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有lastArgs才执行，意味着只有 func 已经被 debounced 过一次以后才会在 trailing edge 执行\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (trailing \x26amp;\x26amp; lastArgs) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e invokeFunc(time)\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每次 trailingEdge 都会清除 lastArgs 和 lastThis，目的是避免最后一次函数被执行了两次\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 举个例子：最后一次函数执行的时候，可能恰巧是前一次的 trailing edge，函数被调用，而这个函数又需要在自己时延的 trailing edge 触发，导致触发多次\x3c\/span\x3e\n        lastArgs = lastThis = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecancel\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eflush\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epending\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edebounced\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...args\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time = Date.now()\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isInvoking = shouldInvoke(time) \x3cspan class=\x22hljs-comment\x22\x3e\/\/是否满足时间条件\x3c\/span\x3e\n\n        lastArgs = args\n        lastThis = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n        lastCallTime = time  \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数被调用的时间\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isInvoking) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (timerId === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 无timerId的情况有两种：1.首次调用 2.trailingEdge执行过函数\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e leadingEdge(lastCallTime)\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (maxing) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Handle invocations in a tight loop.\x3c\/span\x3e\n                timerId = setTimeout(timerExpired, wait)\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e invokeFunc(lastCallTime)\n            }\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 负责一种case：trailing 为 true 的情况下，在前一个 wait 的 trailingEdge 已经执行了函数；\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而这次函数被调用时 shouldInvoke 不满足条件，因此要设置定时器，在本次的 trailingEdge 保证函数被执行\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (timerId === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n            timerId = setTimeout(timerExpired, wait)\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n    }\n    debounced.cancel = cancel\n    debounced.flush = flush\n    debounced.pending = pending\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e debounced\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我用文字来简单描述一下流程：\x3c\/p\x3e\n\x3cp\x3e首次进入函数时因为 lastCallTime === undefined 并且 timerId === undefined，所以会执行 leadingEdge，如果此时 leading 为 true 的话，就会执行 func。同时，这里会设置一个定时器，在等待 wait(s) 后会执行 timerExpired，timerExpired 的主要作用就是触发 trailing。\x3c\/p\x3e\n\x3cp\x3e如果在还未到 wait 的时候就再次调用了函数的话,会更新 lastCallTime，并且因为此时 isInvoking 不满足条件，所以这次什么也不会执行。\x3c\/p\x3e\n\x3cp\x3e时间到达 wait 时，就会执行我们一开始设定的定时器timerExpired，此时因为time-lastCallTime \x26lt; wait，所以不会执行 trailingEdge。\x3c\/p\x3e\n\x3cp\x3e这时又会新增一个定时器，下一次执行的时间是 remainingWait，这里会根据是否有 maxwait 来作区分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果没有 maxwait，定时器的时间是 wait - timeSinceLastCall，保证下一次 trailing 的执行。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果有 maxing，会比较出下一次 maxing 和下一次 trailing 的最小值，作为下一次函数要执行的时间。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后，如果不再有函数调用，就会在定时器结束时执行 trailingEdge。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e我的问题出在哪？\x3c\/h2\x3e\n\x3cp\x3e那么，回到上面的两个问题，我的代码究竟是哪里出了问题呢？\x3c\/p\x3e\n\x3ch4\x3e为什么顺序图不对\x3c\/h4\x3e\n\x3cp\x3e研究了一下，lodash是比较稳定的在trailing时触发前一次函数调用的，而我的则是每次在 maxWait 时触发的下一次调用。问题就出在对于定时器的控制上。\x3c\/p\x3e\n\x3cp\x3e因为在编码时考虑到定时器和 maxwait 会冲突的问题，在函数每次被调用的时候都会 \x3ccode\x3eclearTimeout(timer)\x3c\/code\x3e，因此我的 \x3ccode\x3etrailing\x3c\/code\x3e 判断其实只对整个执行流的最后一次有效，而非 lodash 所说的 \x3ccode\x3etrailing\x3c\/code\x3e 控制的是函数在每个 \x3ccode\x3ewait\x3c\/code\x3e 的最后执行。\x3c\/p\x3e\n\x3cp\x3e而 lodash 并不会清除定时器，只是每次生成新的定时器的时候都会根据 lastCallTime 来计算下一次该执行的时间，不仅保证了定时器的准确性，也保证了对每次 \x3ccode\x3etrailing\x3c\/code\x3e 的控制。\x3c\/p\x3e\n\x3ch4\x3e为什么最后会触发两次\x3c\/h4\x3e\n\x3cp\x3e通过打 log 我发现这种触发两次的情况非常凑巧，最后一次函数执行的时候，正好满足前一个时延的 trailing，然后自己这个 wait 的定时器也触发了，所以最后又触发了一次本次时延的 trailing，所以触发了两次。\x3c\/p\x3e\n\x3cp\x3e理论上 lodash 也会出现这种情况，但是它在每次函数执行的时候都会删除 lastArgs 和 lastThis，而下次函数执行的时候都会判断这两个参数是否存在，因此避免了这种情况。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e其实之前就知道 \x3ccode\x3edebounce\x3c\/code\x3e 和 \x3ccode\x3ethrottle\x3c\/code\x3e 的用途和含义，但是每次用起来都得去看一眼文档，通过这次自己实现以及对源码的阅读，终于做到了了熟于心，也发现自己的代码设计能力还是有缺陷，一开始并没有想的很到位。\x3c\/p\x3e\n\x3cp\x3e写代码的，还是要多写，多看；慢慢做到会写，会看；与大家共勉。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>聊聊lodash的debounce实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012102372">https://segmentfault.com/a/1190000012102372</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/c6tj1ctbhc/" target="_blank">https://alili.tech/archive/c6tj1ctbhc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>