<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="ECMA-262-5详述 第一章. 属性和属性描述符"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>ECMA-262-5详述 第一章. 属性和属性描述符 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c7b3b162/",
				"appid": "1613049289050283", 
				"title": "ECMA-262-5详述 第一章. 属性和属性描述符 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-19T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/d1d5ae47/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9196ee0d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&text=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&text=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&is_video=false&description=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">ECMA-262-5详述 第一章. 属性和属性描述符</h1><div class="meta"><div class="postdate"><time datetime="2018-10-19" itemprop="datePublished">2018-10-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch2\x3e简介\x3c\/h2\x3e\n\x3cp\x3e这一章专门讨论了ECMA-262-5 规范的新概念之一 — 属性特性及其处理机制 — \x3cem\x3e属性描述符\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e当我们说“一个对象有一些属性”的时候，通常指的是\x3cem\x3e属性名\x3c\/em\x3e和\x3cem\x3e属性值\x3c\/em\x3e之间的关联关系。但是，正如在ES3系列文章中分析的那样，一个属性不仅仅是一个\x3cem\x3e字符串名\x3c\/em\x3e，它还包括一系列特性—比如我们在ES3系列文章中已经讨论过的\x3ccode\x3e{ReadOnly}\x3c\/code\x3e，\x3ccode\x3e{DontEnum}\x3c\/code\x3e等。因此从这个观点来看，一个属性本身就是一个对象。\x3c\/p\x3e\n\x3cp\x3e为了更充分地理解本章节的内容，我建议阅读ECMA-262-3系列文章中的 \x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-7-2-oop-ecmascript-implementation\/\x22\x3eChaper 7.2. OOP: ECMAScript implementation\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2\x3e新的API方法\x3c\/h2\x3e\n\x3cp\x3e为了处理属性及其特性，ES5标准化了一些新的API方法。稍后我们会详细讨论这些方法：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ better prototypal inheritance\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(parentProto, properties);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ getting the prototype\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(o);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ define properties with specific attributes\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(o, propertyName, descriptor);\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(o, properties);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ analyze properties\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(o, propertyName);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ static (or \x22frozen\x22) objects\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.freeze(o);\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isFrozen(o);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ non-extensible objects\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.preventExtensions(o);\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isExtensible(o);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22sealed\x22: non-extensible\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ and non-configurable objects\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.seal(o);\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isSealed(o);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ lists of properties\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(o);\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyNames(o);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们一个一个地讲。\x3c\/p\x3e\n\x3ch2\x3e属性类型\x3c\/h2\x3e\n\x3cp\x3e在ES3中，属性名和属性值是直接相关联的。虽然在一些ES3的实现版本中提供了扩展概念：\x3cem\x3egetters\x3c\/em\x3e（访问器函数）和\x3cem\x3esetters\x3c\/em\x3e（设置器函数），即与属性值间接相关的函数 。ECMA-262-5标准化了这个概念，现在总共有三种属性类型。\x3c\/p\x3e\n\x3cp\x3e并且你应该知道，属性可以是自己的，即直接由对象包含，也可以是继承的，即由原型链中的一个对象包含。\x3c\/p\x3e\n\x3cp\x3e属性包括命名属性和内部属性。命名属性是供ECMAScript代码使用的。内部属性则只能被实现层级的代码使用（虽然通过一些特殊的方法也能在ECMAScript代码中操作部分内部属性）。我们稍后会介绍。\x3c\/p\x3e\n\x3ch3\x3e属性特性\x3c\/h3\x3e\n\x3cp\x3e命名属性是通过一系列特性区分的。 在ES3系列文章中\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-7-2-oop-ecmascript-implementation\/#property-attributes\x22\x3e讨论\x3c\/a\x3e 过的\x3ccode\x3e{ReadOnly}\x3c\/code\x3e，\x3ccode\x3e{DontEnum}\x3c\/code\x3e等特性，在ES5中被重新命名了，表示ES3中相应特性的相反布尔状态。在ECMA-262-5中，数据属性和存取器属性有两个共同的特性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Enumerable]]\x3c\/code\x3e可枚举\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性（对应ES3中\x3ccode\x3e{DontEnum}\x3c\/code\x3e特性的相反布尔状态）的值如果是\x3ccode\x3etrue\x3c\/code\x3e，则可以被\x3ccode\x3efor-in\x3c\/code\x3e枚举。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Configurable]]\x3c\/code\x3e可配置\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性（对应ES3中\x3ccode\x3e{DontDelete}\x3c\/code\x3e特性的相反布尔状态）在\x3ccode\x3efalse\x3c\/code\x3e的状态下不允许删除属性，把属性设置成存取器属性或者改变\x3ccode\x3e[[Value]]\x3c\/code\x3e以外的特性。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，一旦\x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性被设置成\x3ccode\x3efalse\x3c\/code\x3e，就不能重新被设置成\x3ccode\x3etrue\x3c\/code\x3e。正如我们刚才说的，在 \x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性为\x3ccode\x3efalse\x3c\/code\x3e的情况下，不能改变\x3ccode\x3e[[Value]]\x3c\/code\x3e以外的特性，当然也包括这里的\x3ccode\x3e[[Configurable]]\x3c\/code\x3e。虽然可以改变\x3ccode\x3e[[Writable]]\x3c\/code\x3e的值，但是只能把它从\x3ccode\x3etrue\x3c\/code\x3e改为\x3ccode\x3efalse\x3c\/code\x3e，反过来不行。也就是说如果一个属性是不可配置的，那么\x3ccode\x3e[[Writable]]\x3c\/code\x3e不能从\x3ccode\x3efalse\x3c\/code\x3e变为\x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e稍后我们会讨论具体命名属性类型的其它特性。我们先详细介绍属性类型。\x3c\/p\x3e\n\x3ch3\x3e命名数据属性\x3c\/h3\x3e\n\x3cp\x3e这些属性我们已经在ES3中使用过了。这类属性包含一个名字（通常是字符串类型）以及名字和值之间的直接关联关系。\x3c\/p\x3e\n\x3cp\x3e比如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs fortran\x22\x3e\/\/ define \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e the declarative \x3cspan class=\x22hljs-keyword\x22\x3eform\x3c\/span\x3e\nvar foo = {\n  bar: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e \/\/ \x3cspan class=\x22hljs-keyword\x22\x3edirect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eNumber\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\n};\n\/\/ define \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e the imperative \x3cspan class=\x22hljs-keyword\x22\x3eform\x3c\/span\x3e,\n\/\/ also \x3cspan class=\x22hljs-keyword\x22\x3edirect\x3c\/span\x3e, but \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, a \x3cspan class=\x22hljs-string\x22\x3e\x22method\x22\x3c\/span\x3e\nfoo.baz = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e () {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e this.bar;\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e和ES3一样，如果一个属性的值是一个函数，那么这个属性叫做方法。但是，不要混淆直接的函数值和间接的特殊的存取器函数。存取器函数会在后面介绍。\x3c\/p\x3e\n\x3cp\x3e除了命名属性的通用特性之外，数据属性还有下列特性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Value]]\x3c\/code\x3e值\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性提供了一个值，这个值用于属性的读取操作。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Writable]]\x3c\/code\x3e可写\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性（对应ES3中\x3ccode\x3e{ReadOnly}\x3c\/code\x3e特性的反向布尔状态），如果是\x3ccode\x3efalse\x3c\/code\x3e，会阻止内部方法\x3ccode\x3e[[Put]]\x3c\/code\x3e修改属性的\x3ccode\x3e[[Value]]\x3c\/code\x3e特性。\x3c\/p\x3e\n\x3cp\x3e带有默认值的命名数据属性的完整特性如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3evar defaultDataPropertyAttributes = {\n  \x3cspan class=\x22hljs-string\x22\x3e[[Value]]\x3c\/span\x3e: undefined,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Writable]]\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Enumerable]]\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Configurable]]\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e所以，在特性的默认状态下，属性是常量：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3e\/\/ define a global constant\n\nObject.defineProperty(this, \x3cspan class=\x22hljs-string\x22\x3e\x22MAX_SIZE\x22\x3c\/span\x3e, {\n  value: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n});\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(MAX_SIZE);\n\/\/ \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n\nMAX_SIZE = \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e;\n\/\/ \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e strict mode, \x3cspan class=\x22hljs-string\x22\x3e[[Writable]]\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\ndelete MAX_SIZE;\n\/\/ \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e strict mode, \x3cspan class=\x22hljs-string\x22\x3e[[Configurable]]\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(MAX_SIZE);\n\/\/ still \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不幸的是，在ES3中我们无法控制属性特性，这也导致了著名的内置原型扩大问题。由于ECMAScript对象可以动态修改的本质，所以可以非常方便地在原型上添加新的功能，然后使用它，就像对象本身就有这个功能一样。但是，因为无法控制ES3中的属性特性，比如\x3ccode\x3e{DontEnum}\x3c\/code\x3e，在使用\x3ccode\x3efor-in\x3c\/code\x3e的时候就会出现问题。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES3\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.sum = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sum implementation\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = [\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ works fine\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.sum());\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 60\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ but because of for-in examines the \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ prototype chain as well, the new \x22sum\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ property is also enumerated, because has\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {DontEnum} == false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ iterate over properties\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e a) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0, 1, 2, sum\x3c\/span\x3e\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eES5提供了特殊的元方法来操作属性特性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x22sum\x22\x3c\/span\x3e, {\n\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3earraySum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  sum implementation\x3c\/span\x3e\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ now with using the same example this \x22sum\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ is no longer enumerable\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e a) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0, 1, 2\x3c\/span\x3e\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在上面的例子中，我们人为明确地设置了\x3ccode\x3eenumerable\x3c\/code\x3e特性。然而，正如我们上面说过的，所有特性的默认状态是\x3ccode\x3efalse\x3c\/code\x3e，所以我们可以省略明确的\x3ccode\x3efalse\x3c\/code\x3e设置：\x3c\/p\x3e\n\x3cp\x3e并且一个简单的赋值操作对应所有特性的\x3cem\x3e相反默认\x3c\/em\x3e状态（正如在ES3中的一样）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3esimple\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eassignment\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e(if\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewe\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ecreate\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eproperty)\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3efoo.bar\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3esame\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eas\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eObject.defineProperty(foo,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  value:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  writable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  configurable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e});\x3c\/span\x3e\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e可以发现，元方法\x3ccode\x3eObject.defineProperty\x3c\/code\x3e不仅可以用来新建对象属性，还可以用来修改对象属性。另外，这个方法返回更新后的对象，所以我们可以使用这个方法同时把新创建的对象绑定到想要的变量名上。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs sql\x22\x3e\/\/ \x3cspan class=\x22hljs-keyword\x22\x3ecreate\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22foo\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefine\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e\nproperty\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = Object.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n  enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n});\n\/\/ \x3cspan class=\x22hljs-keyword\x22\x3ealter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e enumerable \x3cspan class=\x22hljs-keyword\x22\x3eattribute\x3c\/span\x3e\nObject.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n  enumerable: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n});\nconsole.log(foo.bar);\n\/\/ 20\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e有两个获取对象自身属性数组的元方法： \x3ccode\x3eObject.keys\x3c\/code\x3e，只返回可枚举属性，和\x3ccode\x3eObject.getOwnPropertyNames\x3c\/code\x3e，可枚举和不可枚举属性都返回：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {\x3cspan class=\x22hljs-attr\x22\x3ebar\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ebaz\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e};\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22bar\x22, \x22baz\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyNames(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22bar\x22, \x22baz\x22, \x22x\x22]\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e命名存取器属性\x3c\/h3\x3e\n\x3cp\x3e命名存取器属性包括一个名字（同样只是一个字符串）和一到两个存取器函数：\x3ccode\x3egetter\x3c\/code\x3e（访问器函数）和\x3ccode\x3esetter\x3c\/code\x3e（设置器函数）。\x3c\/p\x3e\n\x3cp\x3e存取器函数用于间接地设置或访问与属性名相关的值。\x3c\/p\x3e\n\x3cp\x3e正如上面提到的，ES3的一些实现版本已经有了这个概念。但是ES5把这种属性类型的定义官方的具体化了并且提供了稍微不同的语法，比如和SpiderMonkey的相应扩展相比。\x3c\/p\x3e\n\x3cp\x3e除了通用特性，存取器属性还有下面和访问器函数以及设置器函数相关的特性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Get]]\x3c\/code\x3e访问器\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性是一个函数对象，当每次间接获取属性名对应的值的时候会被调用。不要把属性特性和对象的同名内部方法—通用获取属性值的方法—混淆。对于存取器属性来说，对象内部的\x3ccode\x3e[[Get]]\x3c\/code\x3e方法会调用对象属性的\x3ccode\x3e[[Get]]\x3c\/code\x3e特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3e[[Set]]\x3c\/code\x3e设置器\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e特性也是一个函数，它被用来给一个属性名对应的属性设置一个新值。这个特性会被对象的内部方法\x3ccode\x3e[[Put]]\x3c\/code\x3e调用。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，\x3ccode\x3e[[Set]]\x3c\/code\x3e可以，但不是必须的，影响后续属性\x3ccode\x3e[[Get]]\x3c\/code\x3e特性的返回值。换句话说，如果我们通过设置器函数把属性值设置为\x3ccode\x3e10\x3c\/code\x3e，访问器函数完全可以返回不同的值，比如\x3ccode\x3e20\x3c\/code\x3e，因为这种关联是间接的。\x3c\/p\x3e\n\x3cp\x3e带有默认值的命名存取器属性的完整特性如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3evar defaultAccessorPropertyAttributes = {\n  \x3cspan class=\x22hljs-string\x22\x3e[[Get]]\x3c\/span\x3e: undefined,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Set]]\x3c\/span\x3e: undefined,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Enumerable]]\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e[[Configurable]]\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果 \x3ccode\x3e[[Set]]\x3c\/code\x3e特性缺省，那么这个存取器属性是只读的，和数据属性中\x3ccode\x3e[[Writable]]\x3c\/code\x3e特性的状态为\x3ccode\x3efalse\x3c\/code\x3e一样。\x3c\/p\x3e\n\x3cp\x3e存取器属性既可以通过上面已经提到的元方法\x3ccode\x3eObject.defineProperty\x3c\/code\x3e定义：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs markdown\x22\x3evar foo = {};\nObject.defineProperty(foo, \x22bar\x22, {\n\n  get: function getBar() {\n\x3cspan class=\x22hljs-code\x22\x3e    return 20;\x3c\/span\x3e\n},\n\n  set: function setBar(value) {\n\x3cspan class=\x22hljs-code\x22\x3e    \/\/ setting implementation\x3c\/span\x3e\n  }\n\n});\nfoo.bar = 10;\n\/\/ calls foo.bar.[\x3cspan class=\x22hljs-string\x22\x3e[Set\x3c\/span\x3e]](10)\n\n\/\/ independently always 20\nconsole.log(foo.bar);\n\/\/ calls foo.bar.[\x3cspan class=\x22hljs-string\x22\x3e[Get\x3c\/span\x3e]]()\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e也可以在对象初始化时使用声明式的形式定义：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n},\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    console.log(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n}\n\n};\nfoo.bar = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\nconsole.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e同样需要注意和存取器属性的可配置特性相关的一个重要特点。正如在上面\x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性部分描述的那样，一旦\x3ccode\x3e[[Configurable]]\x3c\/code\x3e被设置成\x3ccode\x3efalse\x3c\/code\x3e，那么这个属性的特性就不能再修改了（除了数据属性的\x3ccode\x3e[[Value]]\x3c\/code\x3e特性）。下面的例子可能会让你很疑惑：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ configurable false by default\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e;\n}\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ trying to reconfigure the \x22bar\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ property =\x26gt;\x3c\/span\x3e\nexception is thrown\n\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e\n}\n  });\n} \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ still \x22bar\x22\x3c\/span\x3e\n}\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当设置属性特性的值和原先一样时，不会产生异常。虽然，这个知识点在实际中并不重要，甚至可以说毫无用处，因为我们不会给特性设置同样的值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetBar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: getBar\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ no exception even if configurable is false,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ but practically such \x22re\x22-configuration is useless\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: getBar\n});\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如我们上面提到的，即使\x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性是\x3ccode\x3efalse\x3c\/code\x3e的状态，数据属性的\x3ccode\x3e[[Value]]\x3c\/code\x3e特性也可以被修改，当然前提是\x3ccode\x3e[[Writable]]\x3c\/code\x3e特性是在为\x3ccode\x3etrue\x3c\/code\x3e的情况下。同样，对于不可配置属性来说，\x3ccode\x3e[[Writable]]\x3c\/code\x3e可以由\x3ccode\x3etrue\x3c\/code\x3e变为\x3ccode\x3efalse\x3c\/code\x3e，但是不能由\x3ccode\x3efalse\x3c\/code\x3e变为\x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22baz\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ change writable\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22qux\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ changed from true to false, OK\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22qux\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ try to change writable again - back to true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22qux\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ERROR\x3c\/span\x3e\n});\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当\x3ccode\x3e[[Configuragle]]\x3c\/code\x3e特性是\x3ccode\x3efalse\x3c\/code\x3e的时候，属性类型不能在数据属性和存取器属性间转换。当\x3ccode\x3e[[Configuragle]]\x3c\/code\x3e特性是\x3ccode\x3etrue\x3c\/code\x3e的时候，属性类型之间是可以相互转换的。因此，\x3ccode\x3e[[Writable]]\x3c\/code\x3e特性的状态并不是很重要并且可以是\x3ccode\x3efalse\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ writable false by default\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e;\n}\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ OK, \x22baz\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e很明显，一个属性不能同时既是数据类型又是存取器类型。这也就意味着一个属性如果同时具有互斥的特性，那么就会抛出异常：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3e\/\/ \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22writable\x22\x3c\/span\x3e\nat the same \x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e\nvar foo = Object.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  get: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e;\n},\n  writable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n});\n\/\/ also \x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e: mutually exclusive  \x3cspan class=\x22hljs-string\x22\x3e\x22value\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22set\x22\x3c\/span\x3e\nattributes\nvar baz = Object.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n  value: \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e,\n  set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e\x3c\/span\x3e {}\n})\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e让我们回忆一下，只有当我们需要封装使用了辅助数据的复杂计算时，为了简化属性的访问方式—就像一个简单的数据属性一样，使用访问器和设置器函数才更有意义。我们已经在专门的\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-7-1-oop-general-theory\/#encapsulation\x22\x3e封装\x3c\/a\x3e部分以属性\x3ccode\x3eelement.innerHTML\x3c\/code\x3e为例提到过：我们可以概括的说“现在html元素的内容如下”，但是在\x3ccode\x3einnerHTML\x3c\/code\x3e属性的设置器函数里面会进行大量的计算和校验，然后引起DOM树的重建和用户界面的更新。\x3c\/p\x3e\n\x3cp\x3e对于不抽象的，使用存取器特性就没有必要了。比如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {};\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetBar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.baz;\n},\n\n  \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetBar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.baz = value;\n}\n});\nfoo.bar = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.baz);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在上面的例子中，我们不仅给不抽象的属性定义了存取器函数，还在对象自身上创建了一个“baz”属性。在这个例子中一个简单的数据属性就足够了，同时也能提高性能。\x3c\/p\x3e\n\x3cp\x3e真正值得使用访问器函数的情况通常和用于封装辅助数据的抽象程度的增加有关。最简单的例子如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scilab\x22\x3evar foo = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ encapsulated context\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e {\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ some internal state\x3c\/span\x3e\n  var data = [];\nObject.defineProperty(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e, {\n\n    get: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetBar\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e {\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22We have \x22\x3c\/span\x3e\n\x2b data.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\nbars: \x22\x3c\/span\x3e\n\x2b data;\n},\n\n    set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetBar\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(value)\x3c\/span\x3e {\x3c\/span\x3e\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ call getter first\x3c\/span\x3e\n      console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Alert from \x22\x3c\/span\x3ebar\x3cspan class=\x22hljs-string\x22\x3e\x22\nsetter: \x27\x3c\/span\x3e\n\x2b this.bar);\ndata = Array(value).join(\x3cspan class=\x22hljs-string\x22\x3e\x22bar-\x22\x3c\/span\x3e).concat(\x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e).split(\x3cspan class=\x22hljs-string\x22\x3e\x22-\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ of course if needed we can update\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ also some public property\x3c\/span\x3e\n      this.baz = \x3cspan class=\x22hljs-string\x22\x3e\x27updated from \x22\x3c\/span\x3ebar\x3cspan class=\x22hljs-string\x22\x3e\x22\nsetter: \x27\x3c\/span\x3e\n\x2b value;\n},\n\n    configurable: true,\n    enumerable: true\n\n  });\n})();\nfoo.baz = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(foo.baz);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 100\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ first getter will be called inside the setter:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ We have 0 bars:\x3c\/span\x3e\nfoo.bar = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ getting\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ We have 3 bars: bar, bar, bar\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(foo.baz);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ updated from \x22bar\x22\x3c\/span\x3e\nsetter: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当然上面的例子并没有实际意义，但是它说明了存取器函数的主要目的—把内部辅助数据封装起来。\x3c\/p\x3e\n\x3cp\x3e和存取器属性相关的另一个特点是给继承的存取器属性赋值。正如从ES3系列文章中了解的那样，继承数据属性只可用于读取操作，给一个数据属性赋值总是会在对象自身上新建一个属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ read inherited property\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ but with assignment\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ create always own property\x3c\/span\x3e\nfoo.x = \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ read own property\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e和数据属性不同的是，继承的存取器属性也可用于对象属性的修改：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _x = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e proto = {\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e x() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _x;\n},\n  \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e x(x) {\n    _x = x;\n}\n};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(proto.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(proto.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\nproto.x = \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ set own property\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(proto.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(proto);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22a\x22\x3c\/span\x3e\ninherits \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22proto\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20, read inherited\x3c\/span\x3e\n\na.x = \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ set *inherited*, but not own\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 30\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(proto.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 30\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然而，如果我们在创建以\x3ccode\x3eproto\x3c\/code\x3e为原型的对象\x3ccode\x3ea\x3c\/code\x3e的时候，把\x3ccode\x3ex\x3c\/code\x3e 设置成了\x3ccode\x3ea\x3c\/code\x3e本身的属性，那么赋值当然也是设置的\x3ccode\x3ea\x3c\/code\x3e本身的属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(proto, {\n  \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 100, read own\x3c\/span\x3e\n\na.x = \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ set also own\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 30\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(proto.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过元方法而不是赋值操作设置自身属性同样也能得到和上面相同的结果：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(proto);\na.x = \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ set inherited\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(a, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e, {\n  value: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e,\n  writable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\n});\na.x = \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ set own\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e值得一提的是，当我们试图通过赋值操作覆盖不可写的继承属性时，无论数据属性还是存取器属性，严格模式下都会报错。然而，如果不是通过赋值操作，而是通过\x3ccode\x3eObject.defineProperty\x3c\/code\x3e方法，就不会报错：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x22use strict\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty({}, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22bar\x22\x3c\/span\x3e\ninherits \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22foo\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(foo);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10, inherited\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ try to shadow \x22x\x22\x3c\/span\x3e\nproperty\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ and get an error in strict\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ mode, or just silent failure\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ in non-strict ES5 or ES3\x3c\/span\x3e\n\nbar.x = \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ still 10, if non-strict mode\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ however shadowing works\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ if we use \x22Object.defineProperty\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(bar, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e, { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ OK\x3c\/span\x3e\n  value: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar.x);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ and now 20\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e想了解严格模式可以查看ES5系列文章的\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/es5-chapter-2-strict-mode\/\x22\x3eChapter 2. Strict Mode\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3\x3e内部属性\x3c\/h3\x3e\n\x3cp\x3e内部属性并不是ECMAScript语言的一部分。定义它们纯粹出于说明的目的。ES3系列文章中已经\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-7-2-oop-ecmascript-implementation\/#internal-properties-and-methods\x22\x3e讨论过\x3c\/a\x3e了。\x3c\/p\x3e\n\x3cp\x3eES5新增了一些新的内部属性。你可以在ECMA-262-5规范的8.6.2. 章节看到这些内部属性的详细定义。因为在ES3系列文章中已经讨论过一些内部属性了，所以在这里只讨论一些新增的内部属性。\x3c\/p\x3e\n\x3cp\x3e比如，ES5中的对象可以被设置成密封的，冻结的或者不可扩展的，也就是静态的。这三种状态都和对象内部的\x3ccode\x3e[[Extensible]]\x3c\/code\x3e属性相关。可以通过元方法进行操作：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {\x3cspan class=\x22hljs-attr\x22\x3ebar\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isExtensible(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.preventExtensions(foo);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isExtensible(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\nfoo.baz = \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error in \x22strict\x22\x3c\/span\x3e\nmode\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.baz);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意，一旦对象的内部属性\x3ccode\x3e[[Extensible]]\x3c\/code\x3e被设置成\x3ccode\x3efalse\x3c\/code\x3e，就不能重新变为\x3ccode\x3etrue\x3c\/code\x3e了。\x3c\/p\x3e\n\x3cp\x3e但是不可扩展对象的一些属性仍然可以被移除。为了防止这种情况的发生，可以使用元方法\x3ccode\x3eObject.seal\x3c\/code\x3e，该方法除了把\x3ccode\x3e[[Extensible]]\x3c\/code\x3e设置成\x3ccode\x3efalse\x3c\/code\x3e之外，还会把对象的所有属性的\x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性设置成\x3ccode\x3efalse\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = {\x3cspan class=\x22hljs-attr\x22\x3ebar\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isSealed(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.seal(foo);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isSealed(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e foo.bar;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error in strict mode\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果想要把对象完全变成静态的，也就是冻结对象，阻止已有属性的修改，可以使用相应的元方法\x3ccode\x3eObject.freeze\x3c\/code\x3e。这个方法除了会修改上面提到的\x3ccode\x3e[[Configurable]]\x3c\/code\x3e特性和内部属性\x3ccode\x3e[[Extensible]]\x3c\/code\x3e之外，还会把数据属性的\x3ccode\x3e[[Writable]]\x3c\/code\x3e特性改为\x3ccode\x3efalse\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs gauss\x22\x3evar foo = {\x3cspan class=\x22hljs-built_in\x22\x3ebar\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e(Object.isFrozen(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\nObject.freeze(foo);\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e(Object.isFrozen(foo));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e foo.\x3cspan class=\x22hljs-built_in\x22\x3ebar\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error in strict mode\x3c\/span\x3e\nfoo.\x3cspan class=\x22hljs-built_in\x22\x3ebar\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error in strict\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e(foo.\x3cspan class=\x22hljs-built_in\x22\x3ebar\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e对象一旦被设置成密封或者冻结状态，就不能回到原先的状态了。\x3c\/p\x3e\n\x3cp\x3e和在ES3中一样，我们仍然可以使用\x3ccode\x3eObject.prototype.toString\x3c\/code\x3e方法的默认返回值获取内部属性\x3ccode\x3e[[Class]]\x3c\/code\x3e的值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getClass = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\n  getClass.call(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [object Number]\x3c\/span\x3e\n  getClass.call({}), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [object Object]\x3c\/span\x3e\n  getClass.call([]), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [object Array]\x3c\/span\x3e\n  getClass.call(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [object Function]\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ etc.\x3c\/span\x3e\n);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e和ES3不同的是，ES5提供了获取内部属性\x3ccode\x3e[[Prototype]]\x3c\/code\x3e的元方法\x3ccode\x3eObject.getPrototypeOf\x3c\/code\x3e。在现行的规范版本中可以使用元方法\x3ccode\x3eObject.create\x3c\/code\x3e创建一个以指定对象为原型的对象：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ create \x22foo\x22\x3c\/span\x3e\nobject \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e two own\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ properties \x22sum\x22\x3c\/span\x3e\nand \x3cspan class=\x22hljs-string\x22\x3e\x22length\x22\x3c\/span\x3e\nand which has\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Array.prototype as its [[Prototype]] property\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype, {\n  \x3cspan class=\x22hljs-attr\x22\x3esum\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3earraySum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sum implementation\x3c\/span\x3e\n    }\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ non-enumerable but writable!\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ else array methods won\x27t work\x3c\/span\x3e\n  length: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n});\nfoo.push(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.length);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.join(\x3cspan class=\x22hljs-string\x22\x3e\x22-\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-string\x22\x3e\x221-2-3\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ neither \x22sum\x22, nor \x22length\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ are enumerable\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e foo) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0, 1, 2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ getting prototype of \x22foo\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fooPrototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(foo);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(fooPrototype === \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不幸的是，使用这种方式并不能创建一个以\x3ccode\x3eArray.prototype\x3c\/code\x3e为原型，具有所有普通数组功能的“类”，包括重载处理\x3ccode\x3elength\x3c\/code\x3e属性的内部方法\x3ccode\x3e[[DefineOwnProperty]]\x3c\/code\x3e（参考15.4.5.1）。如上例子所述。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs glsl\x22\x3efoo[\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(foo.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ still 3\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e继承\x3ccode\x3eArray.prototype\x3c\/code\x3e，同时具有所有相关重载内部方法的唯一方式仍然是使用普通数组（也就是内部属性\x3ccode\x3e[[Class]]\x3c\/code\x3e是\x3ccode\x3e\x22Array\x22\x3c\/code\x3e的对象），然后使用不标准的\x3ccode\x3e__proto__\x3c\/code\x3e属性。但是并不是所有的实现都提供了通过\x3ccode\x3e__proto__\x3c\/code\x3e属性设置原型的功能：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = [];\nfoo.__proto__= {\x3cspan class=\x22hljs-attr\x22\x3ebar\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e};\nfoo.__proto__.__proto__= \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.length);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0\x3c\/span\x3e\n\nfoo.push(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\nfoo[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.length);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/4\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 20,,,30\x3c\/span\x3e\n\nfoo.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ empty array\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不幸的是，和一些ES3实现版本中的非标准\x3ccode\x3e__proto__\x3c\/code\x3e扩展不同，ES5没有提供设置对象原型的方式。\x3c\/p\x3e\n\x3ch2\x3e属性描述符和属性标识符类型\x3c\/h2\x3e\n\x3cp\x3e正如上面描述的，ES5允许操作属性特性。属性特性以及它们的值在ES5中被叫做属性描述符。\x3c\/p\x3e\n\x3cp\x3e和命名属性类型一样，描述符要么是数据描述符要么是存取器描述符。\x3c\/p\x3e\n\x3cp\x3e规范也定义了一个通用属性描述符，这个描述符要么是数据描述符要么是存取器描述符。一个完全填充的属性描述符要么是属性描述符要么是数据描述符并且具有相应类型的所有特性。但是那主要和实现层级相关。\x3c\/p\x3e\n\x3cp\x3e因为特性都有默认值，如果描述符是一个空对象，则会创建一个数据属性。显然，当描述符对象包含\x3ccode\x3ewritable\x3c\/code\x3e或者\x3ccode\x3evalue\x3c\/code\x3e属性的时候，会创建一个数据属性。当描述符对象有\x3ccode\x3eget\x3c\/code\x3e或者\x3ccode\x3eset\x3c\/code\x3e属性的时候，会创建一个存取器属性。可以使用元方法\x3ccode\x3eObject.getOwnPropertyDescriptor\x3c\/code\x3e获取属性描述符：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs qml\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ define several properties at once\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(foo, {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebar\x3c\/span\x3e: {}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22empty\x22\x3c\/span\x3e\ndescriptor,\n  \x3cspan class=\x22hljs-attribute\x22\x3ebaz\x3c\/span\x3e: {\x3cspan class=\x22hljs-attribute\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}}\n});\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e barProperty = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hasOwn = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.hasOwnProperty;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\n  barProperty.value, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  hasOwn.call(barProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22value\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n  barProperty.get, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  hasOwn.call(barProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n  barProperty.set, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  hasOwn.call(barProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22set\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.bar);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined (correct), in Rhino 1.73 - null\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(foo.nonExisting);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined and in Rhino too\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ in contrast \x22baz\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e is an accessor property\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bazProperty = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(foo, \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\n  bazProperty.value, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  hasOwn.call(bazProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22value\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n  bazProperty.get, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ function\x3c\/span\x3e\n  hasOwn.call(bazProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n  bazProperty.set, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n  hasOwn.call(bazProperty, \x3cspan class=\x22hljs-string\x22\x3e\x22set\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e属性标识符类型用来关联属性名和属性描述符。所以，属性，也就是属性标识符类型的值，可以用形式\x3ccode\x3e(name, descriptor)\x3c\/code\x3e描述：\x3c\/p\x3e\n\x3cp\x3e也就是：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3efoo.bar\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eproperty\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ean\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eobject\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eof\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eProperty\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eIdentifier\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3etype\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-string\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ebarProperty\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  descriptor:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    value:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    writable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    configurable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e总结\x3c\/h2\x3e\n\x3cp\x3e在这一章中，我们深入了解了ECMA-262-5规范的一个新概念。接下来的章节会专门介绍执行上下文的新细节，比如词法环境、环境记录等。一如既往，如果你有问题或补充，我们可以在评论中讨论。\x3c\/p\x3e\n\x3ch2\x3e扩展阅读\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/es5.github.com\/#x4.3\x22\x3e4.3 定义\x3c\/a\x3e；\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/es5.github.com\/#x8.6\x22\x3e8.6 对象类型\x3c\/a\x3e；\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/es5.github.com\/#x8.10\x22\x3e8.10 属性描述符和属性标识符规范类型\x3c\/a\x3e；\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/es5.github.com\/#x8.12\x22\x3e8.12 对象内部方法的算法\x3c\/a\x3e；\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/es5.github.com\/#x15.2.3\x22\x3e15.2.3 对象构造器的属性\x3c\/a\x3e。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e作者：\x3c\/strong\x3e Dmitry A. Soshnikov \x3cstrong\x3e发布日期：\x3c\/strong\x3e 2010-04-28\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors">https://www.zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors</a> 原文标题: ECMA-262-5详述 第一章. 属性和属性描述符 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/c7b3b162/" target="_blank">https://alili.tech/archive/c7b3b162/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>