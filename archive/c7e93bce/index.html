<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="现代JS中的流控制：: Callbacks to Promises to Async/Await"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>现代JS中的流控制：: Callbacks to Promises to Async/Await | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c7e93bce/",
				"appid": "1613049289050283", 
				"title": "现代JS中的流控制：: Callbacks to Promises to Async/Await | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-19T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2e3f8879/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/18851f44/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&text=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&text=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&title=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&is_video=false&description=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&title=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&title=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&title=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7e93bce%2f&title=%e7%8e%b0%e4%bb%a3JS%e4%b8%ad%e7%9a%84%e6%b5%81%e6%8e%a7%e5%88%b6%ef%bc%9a%3a%20Callbacks%20to%20Promises%20to%20Async%2fAwait"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">现代JS中的流控制：: Callbacks to Promises to Async/Await</h1><div class="meta"><div class="postdate"><time datetime="2018-10-19" itemprop="datePublished">2018-10-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e\x3cstrong\x3eJavaScript经常声称是\x3cem\x3easynchronous\x3c\/em\x3e。那是什么意思？它如何影响发展？近年来这种方法有何变化？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e请思考以下代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs abnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3eresult1\x3c\/span\x3e = doSomething1()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eresult2\x3c\/span\x3e = doSomething2(result1)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e大多数语言都处理每一行\x3cem\x3esynchronously\x3c\/em\x3e。第一行运行并返回结果。第二行在第一行完成后运行\x3cem\x3e无论需要多长时间\x3c\/em\x3e。\x3c\/p\x3e\n\x3ch2\x3e单线程处理\x3c\/h2\x3e\n\x3cp\x3eJavaScript在单个处理线程上运行。在浏览器选项卡中执行时，其他所有内容都会停止，因为在并行线程上不会发生对页面DOM的更改;将一个线程重定向到另一个URL而另一个线程尝试追加子节点是危险的。\x3c\/p\x3e\n\x3cp\x3e这对用户来说是显而易见。例如，JavaScript检测到按钮单击，运行计算并更新DOM。完成后，浏览器可以自由处理队列中的下一个项目。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e（旁注：其他语言如PHP也使用单个线程，但可以由多线程服务器（如Apache）管理。同时对同一个PHP运行时页面的两个请求可以启动两个运行隔离的实例的线程。）\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2\x3e使用回调进行异步\x3c\/h2\x3e\n\x3cp\x3e单线程引发了一个问题。当JavaScript调用“慢”进程（例如浏览器中的Ajax请求或服务器上的数据库操作）时会发生什么？这个操作可能需要几秒钟 - 甚至几分钟。浏览器在等待响应时会被锁定。在服务器上，Node.js应用程序将无法进一步处理用户请求。\x3c\/p\x3e\n\x3cp\x3e解决方案是异步处理。而不是等待完成，一个进程被告知在结果准备好时调用另一个函数。这称为\x3cem\x3ecallback\x3c\/em\x3e，它作为参数传递给任何异步函数。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scilab\x22\x3edoSomethingAsync(callback1);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27finished\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ call when doSomethingAsync completes\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecallback1\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(error)\x3c\/span\x3e {\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e) console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27doSomethingAsync complete\x27\x3c\/span\x3e);\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3edoSomethingAsync（）接受一个回调函数作为参数（只传递对该函数的引用，因此几乎没有开销）。doSomethingAsync（）需要多长时间并不重要;我们所知道的是callback1（）将在未来的某个时刻执行。控制台将显示：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3efinished\ndoSomethingAsync complete\x3c\/span\x3e\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e回调地狱\x3c\/h3\x3e\n\x3cp\x3e通常，回调只能由一个异步函数调用。因此可以使用简洁的匿名内联函数：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3edoSomethingAsync(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!error) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27doSomethingAsync complete\x27\x3c\/span\x3e);\n});\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过嵌套回调函数，可以串行完成一系列两个或多个异步调用。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lisp\x22\x3easync1((\x3cspan class=\x22hljs-name\x22\x3eerr\x3c\/span\x3e, res) =\x26gt; {\n  if (!err) async2(\x3cspan class=\x22hljs-name\x22\x3eres\x3c\/span\x3e, (\x3cspan class=\x22hljs-name\x22\x3eerr\x3c\/span\x3e, res) =\x26gt; {\n    if (!err) async3(\x3cspan class=\x22hljs-name\x22\x3eres\x3c\/span\x3e, (\x3cspan class=\x22hljs-name\x22\x3eerr\x3c\/span\x3e, res) =\x26gt; {\n      console.log(\x27async1, async2, async3 complete.\x27)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n  })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不幸的是，这引入了\x3cstrong\x3e回调地狱\x3c\/strong\x3e - 一个臭名昭着的概念(\x3ca href=\x22http:\/\/callbackhell.com\/\x22\x3ehttp:\/\/callbackhell.com\/\x3c\/a\x3e) ！代码难以阅读，并且在添加错误处理逻辑时会变得更糟。\x3c\/p\x3e\n\x3cp\x3e回调地狱在客户端编码中相对较少。如果您正在进行Ajax调用，更新DOM并等待动画完成，它可以深入两到三个级别，但它通常仍然可以管理。\x3c\/p\x3e\n\x3cp\x3e操作系统或服务器进程的情况不同。Node.js API调用可以接收文件上载，更新多个数据库表，写入日志，并在发送响应之前进行进一步的API调用。\x3c\/p\x3e\n\x3ch2\x3ePromises\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/www.sitepoint.com\/overview-javascript-promises\/\x22\x3eES2015（ES6）推出了Promises\x3c\/a\x3e。回调仍然可以使用，但Promises提供了更清晰的语法\x3cem\x3echains\x3c\/em\x3e异步命令，因此它们可以串行运行（\x3ca href=\x22https:\/\/www.sitepoint.com\/flow-control-callbacks-promises-async-await\/#asynchronouschaining\x22\x3e更多相关内容\x3c\/a\x3e）。\x3c\/p\x3e\n\x3cp\x3e要启用基于Promise的执行，必须更改基于异步回调的函数，以便它们立即返回Promise对象。该\x3cem\x3epromises\x3c\/em\x3e对象在将来的某个时刻运行两个函数之一（作为参数传递）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eresolve\x3c\/strong\x3e ：处理成功完成时运行的回调函数\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3ereject\x3c\/strong\x3e ：发生故障时运行的可选回调函数。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在下面的示例中，数据库API提供了一个接受回调函数的connect（）方法。外部asyncDBconnect（）函数立即返回一个新的Promise，并在建立连接或失败后运行resolve（）或reject（）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e db = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27database\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ connect to database\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easyncDBconnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparam\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n\n    db.connect(param, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, connection\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) reject(err);\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e resolve(connection);\n    });\n\n  });\n\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eNode.js 8.0\x2b提供了\x3ca href=\x22https:\/\/nodejs.org\/api\/util.html#util_util_promisify_original\x22\x3eutil.promisify（）实用程序\x3c\/a\x3e，将基于回调的函数转换为基于Promise的替代方法。有几个条件：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e必须将回调作为最后一个参数传递给异步函数\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e回调函数必须指向一个错误，后跟一个值参数。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e例子:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Node.js: promisify fs.readFile\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e\n  util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e),\n  fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e),\n  readFileAsync = util.promisify(fs.readFile);\n\nreadFileAsync(\x3cspan class=\x22hljs-string\x22\x3e\x27file.txt\x27\x3c\/span\x3e);\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e各种客户端库也提供promisify选项，但您可以自己创建几个：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ promisify a callback function passed as the last parameter\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the callback function must accept (err, data) parameters\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epromisify\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e fn(\n          ...Array.from(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e),\n        (err, data) =\x26gt; err ? reject(err) : resolve(data)\n      )\n    );\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ example\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewait\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etime, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27done\x27\x3c\/span\x3e); }, time);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e asyncWait = promisify(wait);\n\nayscWait(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e异步链\x3c\/h3\x3e\n\x3cp\x3e任何返回Promise的东西都可以启动.then（）方法中定义的一系列异步函数调用。每个都传递了上一个解决方案的结果：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scilab\x22\x3easyncDBconnect(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:1234\x27\x3c\/span\x3e)\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(asyncGetSession)      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ passed result of asyncDBconnect\x3c\/span\x3e\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(asyncGetUser)         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ passed result of asyncGetSession\x3c\/span\x3e\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(asyncLogAccess)       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ passed result of asyncGetUser\x3c\/span\x3e\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(result =\x26gt; {           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ non-asynchronous function\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/   (passed result of asyncLogAccess)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/   (result passed to next .then())\x3c\/span\x3e\n  })\n  .\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err =\x26gt; {             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ called on any reject\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\n  });\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e同步函数也可以在.then（）块中执行。返回的值将传递给下一个.then（）（如果有）。\x3c\/p\x3e\n\x3cp\x3e.catch（）方法定义了在触发任何先前拒绝时调用的函数。此时，不会再运行.then（）方法。您可以在整个链中使用多个.catch（）方法来捕获不同的错误。\x3c\/p\x3e\n\x3cp\x3eES2018引入了一个.finally（）方法，无论结果如何都运行任何最终逻辑 - 例如，清理，关闭数据库连接等。目前仅支持Chrome和Firefox，但技术委员会39已发布了 \x3ca href=\x22https:\/\/github.com\/tc39\/proposal-promise-finally\/blob\/fd934c0b42d59bf8d9446e737ba14d50a9067216\/polyfill.js\x22\x3e.finally() polyfill.\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoSomething\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  doSomething1()\n  .then(doSomething2)\n  .then(doSomething3)\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n  })\n  .finally(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tidy-up here!\x3c\/span\x3e\n  });\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e使用Promise.all（）进行多个异步调用\x3c\/h3\x3e\n\x3cp\x3ePromise .then（）方法一个接一个地运行异步函数。如果顺序无关紧要 - 例如，初始化不相关的组件 - 同时启动所有异步函数并在最后（最慢）函数运行解析时结束更快。\x3c\/p\x3e\n\x3cp\x3e这可以通过Promise.all（）来实现。它接受一组函数并返回另一个Promise。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs maxima\x22\x3ePromise.all([ async1, async2, async3 ])\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e =\x26gt; {           \/\/ \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e of resolved \x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e);      \/\/ (\x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e same order as function \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evalues\x3c\/span\x3e;\n  })\n  .\x3cspan class=\x22hljs-built_in\x22\x3ecatch\x3c\/span\x3e(err =\x26gt; {             \/\/ called on any reject\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27\x3cspan class=\x22hljs-built_in\x22\x3eerror\x3c\/span\x3e\x27, err);\n  });\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果任何一个异步函数调用拒绝，则Promise.all（）立即终止。\x3c\/p\x3e\n\x3ch3\x3e使用Promise.race的多个异步调用（）\x3c\/h3\x3e\n\x3cp\x3ePromise.race（）与Promise.all（）类似，只是它会在\x3cem\x3efirst\x3c\/em\x3e Promise解析或拒绝后立即解析或拒绝。只有最快的基于Promise的异步函数才能完成：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.race([ async1, async2, async3 ])\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ single value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value;\n  })\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ called on any reject\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\n  });\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e但是有什么别的问题吗？\x3c\/h3\x3e\n\x3cp\x3ePromises 减少了回调地狱但引入了别的问题。\x3c\/p\x3e\n\x3cp\x3e教程经常没有提到_整个Promise链是异步的。使用一系列promise的任何函数都应返回自己的Promise或在最终的.then（）,. catch（）或.finally（）方法中运行回调函数。\x3c\/p\x3e\n\x3cp\x3e学习基础知识至关重要。\x3c\/p\x3e\n\x3cp\x3e更多的关于Promises的资源：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Promise\x22\x3eMDN Promise文档\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developers.google.com\/web\/fundamentals\/primers\/promises\x22\x3eJavaScript Promises: 简介\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.mattgreer.org\/articles\/promises-in-wicked-detail\/\x22\x3eJavaScript Promises …相关细节\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/exploringjs.com\/es6\/ch_promises.html\x22\x3ePromises异步编程\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3eAsync\/Await\x3c\/h2\x3e\n\x3cp\x3ePromises 可能令人生畏，因此\x3ca href=\x22https:\/\/www.sitepoint.com\/LINK-to-ES2017-article\x22\x3eES2017\x3c\/a\x3e引入了async and await。 虽然它可能只是语法糖，它使Promise更完善，你可以完全避免.then（）链。 考虑下面的基于Promise的示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n\n    asyncDBconnect(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:1234\x27\x3c\/span\x3e)\n      .then(asyncGetSession)\n      .then(asyncGetUser)\n      .then(asyncLogAccess)\n      .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(result))\n      .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e reject(err))\n\n  });\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ run connect (self-executing function)\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  connect();\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result))\n    .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err))\n})();\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e用这个重写一下async\/await:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e外部函数必须以async语句开头\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对异步的基于Promise的函数的调用必须在await之前，以确保在下一个命令执行之前完成处理。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e\n      connection = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncDBconnect(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:1234\x27\x3c\/span\x3e),\n      session = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncGetSession(connection),\n      user = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncGetUser(session),\n      log = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncLogAccess(user);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e log;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ run connect (self-executing async function)\x3c\/span\x3e\n(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; { \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e connect(); })();\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eawait有效地使每个调用看起来好像是同步的，而不是阻止JavaScript的单个处理线程。 此外，异步函数总是返回一个Promise，因此它们可以被其他异步函数调用。\x3c\/p\x3e\n\x3cp\x3easync\/await 代码可能不会更短，但有相当大的好处:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e语法更清晰。括号更少，错误更少。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调试更容易。可以在任何await语句上设置断点。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e错误处理更好。try \/ catch块可以与同步代码一样使用。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e支持很好。它在所有浏览器（IE和Opera Mini除外）和Node 7.6\x2b中都得到了支持。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e但是并非所有都是完美的......\x3c\/p\x3e\n\x3ch3\x3e切勿滥用async\/await\x3c\/h3\x3e\n\x3cp\x3easync \/ await仍然依赖于Promises，它最终依赖于回调。你需要了解Promises是如何工作的，并且没有Promise.all（）和Promise.race（）的直接等价物。并且不要忘记Promise.all（），它比使用一系列不相关的await命令更有效。\x3c\/p\x3e\n\x3ch3\x3e同步循环中的异步等待\x3c\/h3\x3e\n\x3cp\x3e在某些时候，您将尝试调用异步函数中的同步循环。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocess\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earray\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e array) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e doSomething(i);\n  }\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e它不会起作用。这也不会：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocess\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earray\x3c\/span\x3e) \x3c\/span\x3e{\n  array.forEach(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e i =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e doSomething(i);\n  });\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e循环本身保持同步，并且总是在它们的内部异步操作之前完成。\x3c\/p\x3e\n\x3cp\x3eES2018引入了异步迭代器，它与常规迭代器一样，但next（）方法返回Promise。因此，await关键字可以与for循环一起用于串行运行异步操作。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocess\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earray\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e array) {\n    doSomething(i);\n  }\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e但是，在实现异步迭代器之前，最好将数组项映射到异步函数并使用Promise.all（）运行它们。例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e\n  todo = [\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e],\n  alltodo = todo.map(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (v, i) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27iteration\x27\x3c\/span\x3e, i);\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e processSomething(v);\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(alltodo);\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这具有并行运行任务的好处，但是不可能将一次迭代的结果传递给另一次迭代，并且映射大型数组可能在性能消耗上是很昂贵。\x3c\/p\x3e\n\x3ch3\x3etry\/catch 有哪些问题了？\x3c\/h3\x3e\n\x3cp\x3e如果省略任何await失败的try \/ catch，async函数将以静默方式退出。如果您有一组很长的异步await命令，则可能需要多个try \/ catch块。\x3c\/p\x3e\n\x3cp\x3e一种替代方案是高阶函数，它捕获错误，因此try \/ catch块变得不必要(thanks to \x3ca href=\x22https:\/\/twitter.com\/wesbos\/status\/911309291545559041\x22\x3e@wesbos\x3c\/a\x3e for the suggestion):\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3easync \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e\n    connection = await asyncDBconnect(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:1234\x27\x3c\/span\x3e),\n    session = await asyncGetSession(connection),\n    user = await asyncGetUser(session),\n    log = await asyncLogAccess(user);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ higher-order function to catch errors\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecatchErrors\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fn)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...args\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn(...args).catch(err =\x26gt; {\n      console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27ERROR\x27\x3c\/span\x3e, err);\n    });\n  }\n}\n\n(async () =\x26gt; {\n  await catchErrors(connect)();\n})();\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e但是，在应用程序必须以与其他错误不同的方式对某些错误做出反应的情况下，此选项可能不实用。\x3c\/p\x3e\n\x3cp\x3e尽管有一些陷阱，async \/ await是JavaScript的一个优雅补充。更多资源：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eMDN \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Statements\/async_function\x22\x3easync\x3c\/a\x3e and \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/await\x22\x3eawait\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developers.google.com\/web\/fundamentals\/primers\/async-functions\x22\x3eAsync functions – 使 promises 更友好\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/tc39.github.io\/ecmascript-asyncawait\/\x22\x3eTC39 Async Functions 规范\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/www.sitepoint.com\/simplifying-asynchronous-coding-async-functions\/\x22\x3e使用异步函数简化异步编码\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3eJavaScript 旅程\x3c\/h2\x3e\n\x3cp\x3e异步编程是一项在JavaScript中无法避免的挑战。回调在大多数应用程序中都是必不可少的，但它很容易陷入深层嵌套的函数中。\x3c\/p\x3e\n\x3cp\x3ePromises 抽象回调，但有许多语法陷阱。 转换现有函数可能是一件苦差事，而.then（）链仍然看起来很混乱。\x3c\/p\x3e\n\x3cp\x3e幸运的是，async \/ await提供了清晰度。代码看起来是同步的，但它不能独占单个处理线程。它将改变你编写JavaScript的方式！\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/flow-control-in-modern-js-callbacks-to-promises-to-async-await">https://www.zcfy.cc/article/flow-control-in-modern-js-callbacks-to-promises-to-async-await</a> 原文标题: 现代JS中的流控制：: Callbacks to Promises to Async/Await 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/c7e93bce/" target="_blank">https://alili.tech/archive/c7e93bce/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>