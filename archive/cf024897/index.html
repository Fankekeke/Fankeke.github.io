<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="初学者应该了解的数据结构： Graph"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>初学者应该了解的数据结构： Graph | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cf024897/",
				"appid": "1613049289050283", 
				"title": "初学者应该了解的数据结构： Graph | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fcaaa7e6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2ef1009/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&is_video=false&description=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcf024897%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcf024897%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Graph"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">初学者应该了解的数据结构： Graph</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e在这篇文章中，我们将要探索非线性的数据结构：图，将涵盖它的基本概念及其典型的应用。\x3c\/p\x3e\n\x3cp\x3e你很可能在不同的应用中接触到图（或树）。比如你想知道从家出发怎么去公司最近，就可以利用图的（寻路）算法来得到答案！我们将探讨上述场景与其他有趣的情况。\x3c\/p\x3e\n\x3cp\x3e在上一篇文章中，我们探讨了线性的数据结构，如数组、链表、集合、栈等。本文将以此（译者注：即线性数据结构，没看过前文也没关系，其实也很好懂）为基础。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e本篇是以下教程的一部分（译者注：如果大家觉得还不错，我会翻译整个系列的文章）:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e初学者应该了解的数据结构与算法（DSA）\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/04\/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial\/\x22\x3e算法的时间复杂性与大 O 符号\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/05\/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course\/\x22\x3e每个程序员应该知道的八种时间复杂度\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/28\/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial\/\x22\x3e初学者应该了解的数据结构：Array、HashMap 与 List\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/05\/14\/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial\/\x22\x3e初学者应该了解的数据结构： Graph\x3c\/a\x3e     \x3cstrong\x3e👈 即本文\x3c\/strong\x3e\x3c\/li\x3e\n\x3cli\x3e初学者应该了解的数据结构：Tree (\x3cstrong\x3e敬请期待\x3c\/strong\x3e)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/24\/Analysis-of-Recursive-Algorithms\/\x22\x3e附录 I：递归算法分析\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3chr\x3e\n\x3cp\x3e以下是本文对图操作的小结：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e\x3c\/th\x3e\n\x3cth\x3e邻接表\x3c\/th\x3e\n\x3cth\x3e邻接矩阵\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e空间复杂度\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|\x2b |E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|²)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e添加\x3c\/strong\x3e顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|²)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V| \x2b |E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|)²\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e添加\x3c\/strong\x3e边\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e边 (基于 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e边 (基于 HashSet 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e获取\x3c\/strong\x3e相邻的顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e判断\x3c\/strong\x3e是否相邻 (基于 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e判断\x3c\/strong\x3e是否相邻  (基于 HashSet 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1\x3e图的基础\x3c\/h1\x3e\n\x3cp\x3e图是一种（包含若干个节点），每个\x3cstrong\x3e节点\x3c\/strong\x3e可以连接 0 个或多个元素\x3c\/p\x3e\n\x3cp\x3e两个节点相连的部分称为\x3cstrong\x3e边（edge）\x3c\/strong\x3e。节点也被称作\x3cstrong\x3e顶点（vertice）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f06793a319?w=459\x26amp;h=303\x26amp;f=jpeg\x26amp;s=28080\x22 alt=\x22\x22 title=\x22Graph is composed of vertices and edges\x22\x3e \x3c\/p\x3e\n\x3cp\x3e一个顶点的\x3cstrong\x3e度（degree）\x3c\/strong\x3e是指与该顶点相连的边的条数。比如上图中，紫色顶点的度是 3，蓝色顶点的度是 1。\x3c\/p\x3e\n\x3cp\x3e如果所有的边都是双向（译者注：或者理解为没有方向）的，那我们就有了一个\x3cstrong\x3e无向图（undirected graph）\x3c\/strong\x3e。反之如果边是有向的，我们得到的就是\x3cstrong\x3e有向图（directed graph）\x3c\/strong\x3e。你可以将有向图和无向图想象为单行道或双行道组成的交通网。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f0763f8910?w=704\x26amp;h=288\x26amp;f=jpeg\x26amp;s=29827\x22 alt=\x22\x22 title=\x22Directed vs Undirected graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e顶点的边可以是从自己出发再连接回自己（如蓝色的顶点），拥有这样的边的图被称为\x3cstrong\x3e自环\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e图可以有\x3cstrong\x3e环（cycle）\x3c\/strong\x3e，即如果遍历图的顶点，某个顶点可以被访问超过一次。而没有环的图被称为\x3cstrong\x3e无环图（acyclic graph）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f066352d46?w=667\x26amp;h=293\x26amp;f=jpeg\x26amp;s=28075\x22 alt=\x22\x22 title=\x22Cyclic vs Acyclic directed graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e此外，无环无向图也被称为\x3cstrong\x3e树（tree）\x3c\/strong\x3e。在下篇文章中，我们将深入套路这种数据结构。\x3c\/p\x3e\n\x3cp\x3e在图中，从一个顶点出发，并非所有顶点都是可到达的。可能会存在孤立的顶点或者是相分离的子图。如果一个图所有顶点都至少有一条边（译者注：原文表述有点奇怪，个人认为不应该是至少有一条边，而是从任一节点出发，沿着各条边可以访问图中任意节点），这样的图被称为\x3cstrong\x3e连通图（connected graph）\x3c\/strong\x3e。而当一个图中两两不同的顶点之间都恰有一条边相连，这样的图就是\x3cstrong\x3e完全图（complete graph）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f06428af90?w=987\x26amp;h=330\x26amp;f=jpeg\x26amp;s=60378\x22 alt=\x22\x22 title=\x22Complete vs Connected graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e对于完全图而言，每个顶点都有 图的顶点数 - 1 条边。在上面完全图的例子中，一共有7个顶点，因此每个顶点有6条边。\x3c\/p\x3e\n\x3ch1\x3e图的应用\x3c\/h1\x3e\n\x3cp\x3e当图的每条边都被分配了权重时，我们就有了一个\x3cstrong\x3e加权图（weighted graph）\x3c\/strong\x3e。如果边的权重被忽略，那么可以将（每条边的）权重都视为 1（译者注：权重都是一样，也就是无权重）。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f06abe1418?w=647\x26amp;h=210\x26amp;f=jpeg\x26amp;s=27730\x22 alt=\x22\x22 title=\x22Airports weighted graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e加权图应用的场景很多，根据待解决问题主体的不同，有不同的展现。一起来看一些具体的场景吧：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e航空线路图 (如上图所示)\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e顶点 = 机场\x3c\/li\x3e\n\x3cli\x3e边 = 两个机场间的飞行线路\x3c\/li\x3e\n\x3cli\x3e权重 = 两个机场间的距离\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eGPS 导航\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e顶点 = 交叉路口\x3c\/li\x3e\n\x3cli\x3e边 = 道路\x3c\/li\x3e\n\x3cli\x3e权重 = 从一个路口到另一个路口所花的时间\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e网络\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e顶点 = 服务器\x3c\/li\x3e\n\x3cli\x3e边 = 数据链路\x3c\/li\x3e\n\x3cli\x3e权重 = 连接速度\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一般而言， 图在现实世界中的应用有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e电子电路\x3c\/li\x3e\n\x3cli\x3e航空控制\x3c\/li\x3e\n\x3cli\x3e行车导航\x3c\/li\x3e\n\x3cli\x3e电信设施： 基站建设规划\x3c\/li\x3e\n\x3cli\x3e社交网络： Facebook 利用图来推荐（你可能认识的）朋友\x3c\/li\x3e\n\x3cli\x3e推荐系统： Amazon\/Netflix 利用图来推荐产品与电影\x3c\/li\x3e\n\x3cli\x3e利用图来规划物流线路\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f06606e8cf?w=644\x26amp;h=530\x26amp;f=jpeg\x26amp;s=124568\x22 alt=\x22\x22 title=\x22Graph applications: path finder\x22\x3e\x3c\/p\x3e\n\x3cp\x3e我们学习了图的基础以及它的一些应用场景。接下来一起学习怎么使用代码来表示图。\x3c\/p\x3e\n\x3ch1\x3e图的表示\x3c\/h1\x3e\n\x3cp\x3e图的表示有两种主要方式：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e邻接表\x3c\/li\x3e\n\x3cli\x3e邻接矩阵\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让我们以有向图为例子，阐述这两种表示方式：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f08eab7b13?w=310\x26amp;h=310\x26amp;f=png\x26amp;s=28122\x22 alt=\x22\x22 title=\x22digraph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e这是一个拥有四个顶点的图。当一个顶点有一条边指向它自身时（译者注：即闭合的路径），称之为\x3cstrong\x3e自环（self-loop）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2\x3e邻接矩阵\x3c\/h2\x3e\n\x3cp\x3e邻接矩阵使用二维数组（N x N）来表示图。如若不同顶点存在连接的边，就赋值两顶点交汇处为1（也可以是这条边的权重），反之赋值为 0 或者 -。\x3c\/p\x3e\n\x3cp\x3e我们可以通过建立以下的邻接矩阵，来表示上面的图：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e  \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e c d e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - - -\n\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e - - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - -\nc - - - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e -\nd - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - -\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如你所见，矩阵水平与垂直两个方向都列出了所有的顶点。如果图中只有很少顶点互相连接，那么这个图就是\x3cstrong\x3e稀疏图（sparse graph）\x3c\/strong\x3e。如果图相连的顶点很多（接近两两顶点都相连）的话，我们称这种图为\x3cstrong\x3e稠密图（dense graph）\x3c\/strong\x3e。而如果图的每个顶点都直接连接到除此之外的所有顶点，那就是一个\x3cstrong\x3e完全图（complete graph）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e注意，你必须意识到对于无向图而言，邻接矩阵\x3cstrong\x3e始终\x3c\/strong\x3e是对角线对称的。然而，对于有向图而言，并非总是如此（反例如上面的有向图）。\x3c\/p\x3e\n\x3cp\x3e那查询两个顶点是否相邻的时间复杂度是什么呢？\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接矩阵中，查询两个顶点是否相邻的时间复杂度是  \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e那空间复杂度呢？\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e利用邻接矩阵存储一个图，空间复杂度是 \x3cem\x3eO(n²)\x3c\/em\x3e，n 为顶点的数量，因此也可以表示为 \x3cem\x3eO(|V|²)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e添加一个顶点的时间复杂度呢？\x3c\/p\x3e\n\x3cp\x3e邻接矩阵根据顶点的数量存储为  \x3ccode\x3eV x V\x3c\/code\x3e 的矩阵。因此每增加一个顶点，矩阵需要重建为 \x3ccode\x3eV\x2b1 x V\x2b1\x3c\/code\x3e 的新矩阵。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e（因此，）在邻接矩阵中添加一个顶点的时间复杂度是 \x3cem\x3eO(|V|²)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e如何获取相邻的顶点？\x3c\/p\x3e\n\x3cp\x3e由于邻接矩阵是一个 \x3ccode\x3eV x V\x3c\/code\x3e 的矩阵，为了获取所有相邻的顶点，我们必须去到该顶点所在的行中，查询它与其他顶点是否有边。\x3c\/p\x3e\n\x3cp\x3e以上面的邻接矩阵为例，假设我们想知道与顶点 \x3ccode\x3eb\x3c\/code\x3e 相邻的顶点有哪些，就需要到达记录 \x3ccode\x3eb\x3c\/code\x3e 与其他节点关系的那一行中进行查询。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e  \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e c d e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e - - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - -\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e访问它与其他所有顶点的关系，因此：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接矩阵中，查询相邻顶点的时间复杂度是  \x3cem\x3eO(|V|)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e想象一下，如果你需要将 FaceBook 中人们的关系网表示为一个图。你必须建立一个 \x3ccode\x3e20亿 x 20亿\x3c\/code\x3e 的邻接矩阵，而该矩阵中很多位置都是空的。没有任何人可能认识其他所有人，最多也就认识几千个人。\x3c\/p\x3e\n\x3cp\x3e通常，我们使用邻接矩阵处理稀疏图时，会浪费很多空间。这就是大多时候使用邻接表而不是邻接矩阵去表示一个图的原因（译者注：邻接矩阵也有优势的，尤其是表示有向稠密图时，比邻接表要方便得多）。\x3c\/p\x3e\n\x3ch2\x3e邻接表\x3c\/h2\x3e\n\x3cp\x3e表示一个图，最常用的方式是邻接表。每个顶点都有一个记录着与它所相邻顶点的表。\x3c\/p\x3e\n\x3cp\x3e可以使用一个数组或者 HashMap 来建立一个邻接表，它存储这所有的顶点。每个顶点都有一个列表（可以是数组、链表、集合等数据结构），存放着与其相邻的顶点。\x3c\/p\x3e\n\x3cp\x3e例如上面的图，对于顶点 a，与之相邻的有顶点 b，同时也是自环；而顶点 b 则有指向顶点 c 的边，如此类推：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e -\x26gt; { \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e }\n\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e -\x26gt; { c }\nc -\x26gt; { d }\nd -\x26gt; { \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e c }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e和想象中的一样，如果想知道一个顶点是否连接着其他顶点，就必须遍历（顶点的）整个列表。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接表中查询两个顶点是否相连的时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e，n 为顶点的数量，因此也可以表示为  \x3cem\x3eO(|V|)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e那空间复杂度呢？\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e利用邻接表存储一个图的空间复杂度是  \x3cem\x3eO(n)\x3c\/em\x3e，n 为顶点数量与边数量之和，因此也可以表示为 \x3cem\x3eO(|V| \x2b |E|)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch1\x3e基于 HashMap 实现的邻接表\x3c\/h1\x3e\n\x3cp\x3e要表示一个图，最常见的方式是使用邻接表。有几种实现邻接表的方式：\x3c\/p\x3e\n\x3cp\x3e最简单的实现方式之一是使用 HashMap。HashMap 的键是顶点的值，HashMap 的值是一个邻接数组（即也该顶点相邻顶点的集合）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs prolog\x22\x3econst graph = {\n  a：[ \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e，\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e ]，\n  b：[ \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e ]，\n  c：[ \x3cspan class=\x22hljs-string\x22\x3e\x27d\x27\x3c\/span\x3e ]，\n  d：[ \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e，\x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e ]\n};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e图通常需要实现以下两种操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e添加或删除顶点。\x3c\/li\x3e\n\x3cli\x3e添加或删除边。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e添加或删除一个顶点需要更新邻接表。\x3c\/p\x3e\n\x3cp\x3e假设需要删除顶点 b。我们不但需要 \x3ccode\x3edelete graph[\x27b\x27]\x3c\/code\x3e，还需要删除顶点 a 与顶点 d 的邻接数组中的引用。\x3c\/p\x3e\n\x3cp\x3e每当移除一个顶点，都需要遍历整个邻接表，因此时间复杂度是 \x3cem\x3eO(|V| \x2b |E|)\x3c\/em\x3e。有更好的实现方式吗？稍后再回答这问题。首先让我们以更面向对象的方式实现邻接表，之后切换（邻接表的底层）实现将更容易。\x3c\/p\x3e\n\x3ch1\x3e基于邻接表，以面向对象风格实现图\x3c\/h1\x3e\n\x3cp\x3e先从顶点的类开始，在该类中，除了保存顶点自身以及它的相邻顶点集合之外，还会编写一些方法，用于在邻接表中增加或删除相邻的顶点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eclass \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e{\n  constructor\x3c\/span\x3e(value) {\n    this.value = value;\n    this.adjacents = []; \/\/ adjacency list\n  }\n\n  addAdjacent(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n    this\x3c\/span\x3e.adjacents.push(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n  }\n\n  removeAdjacent\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n    const\x3c\/span\x3e index = this.adjacents.indexOf(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n    if\x3c\/span\x3e (index \x26gt; -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n      this.adjacents.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      return \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    }\n  }\n\n  getAdjacents\x3c\/span\x3e() {\n    return this.adjacents;\n  }\n\n  isAdjacent(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n    return\x3c\/span\x3e this.adjacents.indexOf(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) \x26gt; -1\x3c\/span\x3e;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意，\x3ccode\x3eaddAdjacent\x3c\/code\x3e 方法的时间复杂度是  \x3cem\x3eO(1)\x3c\/em\x3e，但删除相邻顶点的函数时间复杂度是  \x3cem\x3eO(|E|)\x3c\/em\x3e。如果不使用数组而是用 HashSet 会怎样呢？（删除相邻顶点的）时间复杂度会下降到 \x3cem\x3eO(1)\x3c\/em\x3e。但现在先让代码能跑起来，之后再做优化。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eMake it work. Make it right. Make it faster.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e现在有了 \x3ccode\x3eNode\x3c\/code\x3e 类，是时候编写 \x3ccode\x3eGraph\x3c\/code\x3e 类，它可以执行添加或删除顶点和边。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eGraph.constructor\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGraph\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(edgeDirection = Graph.DIRECTED) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeDirection = edgeDirection;\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\nGraph.UNDIRECTED = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27directed graph\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ one-way edges\x3c\/span\x3e\nGraph.DIRECTED = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27undirected graph\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ two-ways edges\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e首先，我们需要确认图是有向还是无向的，当添加边时，这会有所不同。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eGraph.addEdge\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e添加一条新的边，需要知道两个顶点：边的起点与边的终点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3eaddEdge(source, destination) {\n  const sourceNode = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addVertex(source);\n  const destinationNode = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addVertex(destination);\n  sourceNode.addAdjacent(destinationNode);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeDirection === Graph.UNDIRECTED) {\n    destinationNode.addAdjacent(sourceNode);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [sourceNode, destinationNode];\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们往边的起点添加了一个相邻顶点（即边的终点）。如果该图是无向图，也需要往边的终点添加一个相邻顶点（即边的起点），因为（无向图中）边是双向的。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接表中新增一条边的时间复杂度是：\x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e如果新添加的边两端的顶点并不存在，就必需先创建（不存在的顶底），下面让我们来实现它！\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eGraph.addVertex\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e创建顶点的方式是往 \x3ccode\x3ethis.nodes\x3c\/code\x3e 中新增一个顶点。\x3ccode\x3ethis.nodes\x3c\/code\x3e 中存储着的是一组组键值对，键是顶点的值，值是 \x3ccode\x3eNode\x3c\/code\x3e 类的实例。注意看下面代码的 5-6 行（即 \x3ccode\x3econst vertex = new Node(value); this.nodes.set(value, vertex);\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3eaddVertex(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.has(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vertex = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, vertex);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vertex;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e没必要覆写已存在的顶点。因此先检查一下顶点是否存在，如果不存在才创造一个新节点。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接表中新增一个顶点的时间复杂度是： \x3cem\x3eO(1)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eGraph.removeVertex\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e从一个图中删除一个顶点会相对麻烦一点。我们必须检查待删除的顶点是否为其他顶点的相邻顶点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3eremoveVertex(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e current = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(current) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node of \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.values()) {\n      node.removeAdjacent(current);\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.delete(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e必须访问每个顶点及其它们的相邻顶点集合。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接表中删除一个顶点的时间复杂度是： \x3cem\x3eO(|V| \x2b |E|)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e最后，一起来实现删除一条边吧！\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eGraph.removeEdge\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e删除一条边是十分简单的，与新增一条边类似。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3eremoveEdge(source, destination) {\n  const sourceNode = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(source);\n  const destinationNode = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nodes.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(destination);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(sourceNode \x26amp;\x26amp; destinationNode) {\n    sourceNode.removeAdjacent(destinationNode);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeDirection === Graph.UNDIRECTED) {\n      destinationNode.removeAdjacent(sourceNode);\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [sourceNode, destinationNode];\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e删除与新增一条边主要的不同是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果边两端的顶点不存在，不再需要创建它。\x3c\/li\x3e\n\x3cli\x3e使用\x3ccode\x3eNode.removeAdjacent\x3c\/code\x3e 而不是 \x3ccode\x3eNode.addAdjacent\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e由于 \x3ccode\x3eremoveAdjacent\x3c\/code\x3e 需要遍历相邻节点的集合，因此它的运行时是：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在邻接表中删除一条边的时间复杂度是：  \x3cem\x3eO(|E|)\x3c\/em\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e接下来，我们将讨论如何从图中搜索。\x3c\/p\x3e\n\x3ch1\x3e广度优先搜索(BFS) - 图的搜索\x3c\/h1\x3e\n\x3cp\x3e广度优先搜索是一种从最初的顶点开始，优先访问所有相邻顶点的搜索方法。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f095c3bd34?w=500\x26amp;h=500\x26amp;f=gif\x26amp;s=13445\x22 alt=\x22\x22 title=\x22Breadth First Search in a graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3e接下来一起看看如何用代码来实现它：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e*bfs(first) {\n  const visited = new Map();\n  const visitList = new Queue();\n  visitList.add(first);\n  while(!visitList.isEmpty()) {\n    const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= visitList\x3c\/span\x3e.remove();\n    if(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\x26amp;\x26amp; !visited\x3c\/span\x3e.has(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e)) {\n      yield\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n      visited\x3c\/span\x3e.set(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n      node\x3c\/span\x3e.getAdjacents().forEach(adj =\x26gt; visitList.add(adj));\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如你所见的一样，我们使用了一个队列来暂存待访问的顶点，队列遵循先进先出（FIFO）的原则。\x3c\/p\x3e\n\x3cp\x3e同时也是用了 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Generator\x22\x3eJavaScript generators\x3c\/a\x3e，要注意函数名前面 \x3ccode\x3e*\x3c\/code\x3e（，那是生成器的标志）。通过生成器，可以一次迭代一个值（即顶点）。对于巨型（包含数以百万计的顶点）的图而言是很有用的，很多情况下不用访问图的每一个顶点。\x3c\/p\x3e\n\x3cp\x3e以下是如何使用上述 BFS 代码的示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3econst graph = new Graph(Graph.UNDIRECTED);\nconst [first] = graph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\ngraph.addEdge(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e);\nbfsFromFirst = graph.bfs(first);\nbfsFromFirst.next().value.value; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\nbfsFromFirst.next().value.value; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\nbfsFromFirst.next().value.value; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\nbfsFromFirst.next().value.value; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你可以在\x3ca href=\x22https:\/\/github.com\/amejiarosario\/algorithms.js\/blob\/master\/lib\/data-structures\/graphs\/graph.spec.js\x22\x3e这\x3c\/a\x3e找到更多的测试代码。\x3c\/p\x3e\n\x3cp\x3e接下来该讲述深度优先搜索了！\x3c\/p\x3e\n\x3ch1\x3e深度优先搜索 (DFS) -图的搜索\x3c\/h1\x3e\n\x3cp\x3e深度优先搜索是图的另一种搜索方法，通过递归搜索顶点的首个相邻顶点，再搜索其他相邻顶点，从而访问所有的顶点。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/user-gold-cdn.xitu.io\/2018\/7\/23\/164c76f0943a8a2b?w=500\x26amp;h=500\x26amp;f=gif\x26amp;s=13447\x22 alt=\x22\x22 title=\x22Depth First Search in a graph\x22\x3e\x3c\/p\x3e\n\x3cp\x3eDFS 的实现近似于 BFS，但使用的是栈而不是队列：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e*dfs(first) {\n  const visited = new Map();\n  const visitList = new Stack();\n  visitList.add(first);\n  while(!visitList.isEmpty()) {\n    const \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= visitList\x3c\/span\x3e.remove();\n    if(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\x26amp;\x26amp; !visited\x3c\/span\x3e.has(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e)) {\n      yield\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n      visited\x3c\/span\x3e.set(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n      node\x3c\/span\x3e.getAdjacents().forEach(adj =\x26gt; visitList.add(adj));\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e测试例子如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs mipsasm\x22\x3econst graph = new Graph(Graph.UNDIRECTED)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst [first] = graph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(1, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(1, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(1, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(5, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(6, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(7, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(8, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(9, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ngraph.\x3cspan class=\x22hljs-keyword\x22\x3eaddEdge(10, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ndfsFromFirst = graph.dfs(first)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nvisitedOrder = Array.from(dfsFromFirst)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst values = visitedOrder.map(node =\x26gt; node.value)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconsole.log(values)\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ [1, 4, 8, 3, 7, 6, 10, 2, 5, 9]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e 正如你所看到的，BFS 与 DFS 所用的图（的数据）是一样的，然而访问顶点的顺序却非常不一样。BFS 是从 1 到 10 按顺序输出，DFS 则是先进入最深处访问顶点（译者注：其实这个例子是先序遍历，看起来可能不太像先深入最深处）。\x3c\/p\x3e\n\x3ch1\x3e图的时间与空间复杂度\x3c\/h1\x3e\n\x3cp\x3e我们接触了图的一些基础操作，如何添加和删除一个顶点或一条边，以下是前文涵盖内容的小结：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\n\x3ctr\x3e\n\x3cth\x3e\x3c\/th\x3e\n\x3cth\x3e邻接表\x3c\/th\x3e\n\x3cth\x3e邻接矩阵\x3c\/th\x3e\n\x3c\/tr\x3e\n\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e空间复杂度\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|\x2b |E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|²)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e添加\x3c\/strong\x3e顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|²)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V| \x2b |E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|)²\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e添加\x3c\/strong\x3e边\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e边 (基于 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e移除\x3c\/strong\x3e边 (基于 HashSet 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e获取\x3c\/strong\x3e相邻的顶点\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|V|)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e判断\x3c\/strong\x3e是否相邻 (基于 Array 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(|E|)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3cstrong\x3e判断\x3c\/strong\x3e是否相邻  (基于 HashSet 实现)\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cem\x3eO(1)\x3c\/em\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e正如上表所示，邻接表中几乎所有的操作方法都是更快的。邻接矩阵比邻接表性能更高的方法只有一处：检查顶点是否与其他顶点相邻，然而使用 HashSet 而不是 Array 实现邻接表的话，也能在恒定时间内获取结果 :)\x3c\/p\x3e\n\x3ch1\x3e总结\x3c\/h1\x3e\n\x3cp\x3e图可以是很多现实场景的抽象，如机场，社交网络，互联网等。我们介绍了一些图的基础算法，如广度优先搜索（BFS）与深度优先搜索（DFS）等。同时权衡了图的不同实现方式：邻接矩阵和邻接表。我们将在另外一篇文章（更深入地）介绍图的其他应用，如查找图的两个顶点间的最短距离及其他有趣的算法（译者注：这篇文章介绍的比较基础，图的各种算法才是最有趣的，有兴趣的同学可以搜索相关的慕课)）。\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/graph-data-structures-for-beginners">https://www.zcfy.cc/article/graph-data-structures-for-beginners</a> 原文标题: 初学者应该了解的数据结构： Graph 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/cf024897/" target="_blank">https://alili.tech/archive/cf024897/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>