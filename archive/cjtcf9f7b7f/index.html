<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="再也不学AJAX了！（二）使用AJAX"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>再也不学AJAX了！（二）使用AJAX | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cjtcf9f7b7f/",
				"appid": "1613049289050283", 
				"title": "再也不学AJAX了！（二）使用AJAX | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-24T02:30:06"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/15xq8d0t9mo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t8p8w683km/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&text=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&text=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&title=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&is_video=false&description=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&title=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&title=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&title=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcjtcf9f7b7f%2f&title=%e5%86%8d%e4%b9%9f%e4%b8%8d%e5%ad%a6AJAX%e4%ba%86%ef%bc%81%ef%bc%88%e4%ba%8c%ef%bc%89%e4%bd%bf%e7%94%a8AJAX"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">再也不学AJAX了！（二）使用AJAX</h1><div class="meta"><div class="postdate"><time datetime="2018-12-24" itemprop="datePublished">2018-12-24</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在上一篇文章中我们知道，AJAX是一系列技术的统称。在本篇中我们将更进一步，详细解释如何使用Ajax技术在项目中获取数据。而为了解释清楚，我们首先要搞清楚我们是\x3cstrong\x3e从哪里获取数据\x3c\/strong\x3e的，其次我们关注的才是\x3cstrong\x3e获取数据的具体方式\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一、获取数据\x3c\/h2\x3e\n\x3cp\x3e我们知道AJAX用来在项目中以阻止页面刷新的方式获取数据，那么数据从哪里来呢？我们又怎么知道如何获取这些数据？答案是我们通常使用\x3cstrong\x3eAPI\x3c\/strong\x3e与各式各样的数据库交互。\x3c\/p\x3e\n\x3cp\x3e“API”是“Application Programming Interface”(即：应用程序接口)的缩写，你可以想象一些数据是开放的并且在等待被使用，而我们获取这些数据的方式便是使用API。API通常的形式是一个URL，并提供指定的参数名和参数值用来帮助你定位所要获取的数据。\x3c\/p\x3e\n\x3cp\x3e还记得我们提过AJAX需要服务器端的相应设置吗？我们之后会再来谈这一点。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e二、AJAX技术的核心 - XMLHttpRequest对象\x3c\/h2\x3e\n\x3cp\x3e让我们先把服务器端的设置抛在一边，聚焦AJAX技术的核心环节：\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象是浏览器提供的一个API，用来顺畅地向服务器发送请求并解析服务器响应，当然整个过程中，浏览器页面不会被刷新。它将是本文接下来的主角，让我们先站在较高的层次，对该对象有一个全局的概览：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e只是一个JavaScript对象，确切的说，是一个\x3cstrong\x3e构造函数\x3c\/strong\x3e。换句话说，它一点也不神秘，它的特殊之处只在于它是由客户端(即浏览器)提供的（而不是JavaScript原生的），除此之外，它有属性，有方法，需要通过\x3ccode\x3enew\x3c\/code\x3e关键字进行实例化，我们只需掌握它们就好；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象是不断被扩展的。随着XML对象被广泛的接收，W3C也开始着手制定相应的标准来规范其行为。目前，\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e有两个级别：1级提供了XML对象的实现细节，2级进一步发展了XML对象，额外添加了一些方法，属性和数据类型。但是，并不是所有浏览器都实现了XML对象2级的内容（并不意外，对吧？）；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让我们先从剖析\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e实例的属性和方法开始，先创建一个XML对象的实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该实例的属性，方法有：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e方法\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e.open()\x3c\/code\x3e：准备启动一个AJAX请求；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.setRequestHeader()\x3c\/code\x3e：设置请求头部信息；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.send()\x3c\/code\x3e：发送AJAX请求；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.getResponseHeader()\x3c\/code\x3e: 获得响应头部信息；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.getAllResponseHeader()\x3c\/code\x3e：获得一个包含所有头部信息的长字符串；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.abort()\x3c\/code\x3e：取消异步请求；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e属性\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e.responseText\x3c\/code\x3e：包含响应主体返回文本；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.responseXML\x3c\/code\x3e：如果响应的内容类型时\x3ccode\x3etext\/xml\x3c\/code\x3e或\x3ccode\x3eapplication\/xml\x3c\/code\x3e，该属性将保存包含着相应数据的XML DOM文档；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.status\x3c\/code\x3e：响应的HTTP状态；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.statusText\x3c\/code\x3e：HTTP状态的说明；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.readyState\x3c\/code\x3e：表示“请求”\/“响应”过程的当前活动阶段\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外，浏览器还为该对象提供了一个\x3ccode\x3eonreadystatechange\x3c\/code\x3e监听事件，每当XML实例的\x3ccode\x3ereadyState\x3c\/code\x3e属性变化时，就会触发该事件的发生。\x3c\/p\x3e\n\x3cp\x3e至此，关于XMLHttpRequest实例对象的属性方法就全部罗列完毕了，接下来，我们将更进一步的探究如何使用这些方法，属性完成发送AJAX请求的流程。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e三、准备AJAX请求\x3c\/h2\x3e\n\x3cp\x3e要想与服务器交互，我们首先需要回答以下问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e我们是要获取数据还是存储数据？  --表现为请求方式的不同：\x3ccode\x3eGET\x3c\/code\x3e或\x3ccode\x3ePOST\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e向哪里发出请求？  --即相应API地址；\x3c\/li\x3e\n\x3cli\x3e以何种方式等待响应？  --有“\x3cstrong\x3e同步\x3c\/strong\x3e”和“\x3cstrong\x3e异步\x3c\/strong\x3e”两种选择；（网络传输是一个过程，请求和响应不是同时发生的。）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e而XMLHttpRequest实例的\x3ccode\x3e.open()\x3c\/code\x3e方法的作用就是用来回答以上三个问题。\x3ccode\x3e.open()\x3c\/code\x3e方法接收三个参数：\x3cstrong\x3e请求方式\x3c\/strong\x3e，\x3cstrong\x3e请求URL地址\x3c\/strong\x3e和\x3cstrong\x3e是否为异步请求的布尔值\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e下面是一个\x3ccode\x3e.open()\x3c\/code\x3e方法调用的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 该段代码会启动一个针对“example.php”的GET同步请求。\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, false)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fsharp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该段代码会启动一个针对“example.php”的GET同步请求。\x3c\/span\x3e\nxhr.\x3cspan class=\x22hljs-keyword\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相当于开始做饭前，将工具准备齐备，将菜洗好，\x3ccode\x3e.open()\x3c\/code\x3e方法也同样出色地完成了发送AJAX请求的准备工作。\x3c\/p\x3e\n\x3cp\x3e现在，让我们再深入聊聊一些准备工作的细节：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e（一）GET请求 与 POST请求\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3eGET请求\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eGET请求用于\x3cstrong\x3e获取数据\x3c\/strong\x3e，有时候我们需要获取的数据需要通过“查询参数”进行定位，在这种情况下，我们会将查询参数追加到URL的末尾，令服务器解析。\x3c\/p\x3e\n\x3cp\x3e查询参数是指一个由\x3ccode\x3e?\x3c\/code\x3e号起始，由\x3ccode\x3e\x26amp;\x3c\/code\x3e符号分割的包含相应键值对的字符串。用来告知浏览器所要查询的特定资源。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const query = \x26quot;example.php?name=tom\x26amp;age=24\x26quot; \/\/ \x26quot;?name=tom\x26amp;age=24\x26quot;即是一个查询参数\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3equery\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22example.php?name=tom\x26amp;age=24\x22\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22?name=tom\x26amp;age=24\x22即是一个查询参数\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，查询字符串中每个参数的名和值都必须使用encodeURIComponent()进行编码（这是因为URL中有些字符会引起歧义，例如“\x26amp;”）。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3ePOST请求\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3ePOST请求用于\x3cstrong\x3e向服务器发送应该被保存的数据\x3c\/strong\x3e，因此POST请求天然比GET请求多需要一份\x3cstrong\x3e需要被保存的数据\x3c\/strong\x3e。那么这些数据应该放在何处呢？毕竟，我们的\x3ccode\x3e.open()\x3c\/code\x3e方法接收的三个参数都没有合适的位置。\x3c\/p\x3e\n\x3cp\x3e答案是需要发送的数据会作为\x3ccode\x3e.send()\x3c\/code\x3e方法的参数最终被发往服务器，该数据可以是任意大小，任意类型。\x3c\/p\x3e\n\x3cp\x3e这里需要注意以下两点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3e.send()\x3c\/code\x3e方法的参数是不可为空的，也就是说，对于不需要发送任何数据的GET请求，也需要在调用\x3ccode\x3e.send()\x3c\/code\x3e方法时，向其传入\x3ccode\x3enull\x3c\/code\x3e值；\x3c\/li\x3e\n\x3cli\x3e目前为止，我们知道了两种向服务器发送数据的方式：\x3cstrong\x3e表单提交\x3c\/strong\x3e以及\x3cstrong\x3e发送POST请求\x3c\/strong\x3e，要注意服务器对待这两种方式并不一视同仁，这意味着服务器需要有相应的代码专门处理POST请求发送来的原始数据。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e但好在我们可以通过POST请求模拟表单提交，只需要简单两步：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e设置请求头参数：\x3ccode\x3eContent-Type: application\/x-www-form-urlencoded\x3c\/code\x3e（表单提交时的内容类型）；\x3c\/li\x3e\n\x3cli\x3e将表单数据序列化为查询字符串形式，传入\x3ccode\x3e.send()\x3c\/code\x3e方法；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e（二）请求URL地址\x3c\/h3\x3e\n\x3cp\x3e这里需要注意若使用相对路径，请求URL是\x3cstrong\x3e相对于执行代码的当前页面\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e（三）同步请求与异步请求\x3c\/h3\x3e\n\x3cp\x3e人们通常认为AJAX是异步的，实际上并非如此，AJAX是避免页面在获取数据后刷新的一种技术，至于等待服务器响应的方式是同步还是异步，需要开发人员结合业务需求进行配置（虽然通常是异步的）。\x3c\/p\x3e\n\x3cp\x3e你可能会好奇，什么时候我们需要使用同步的AJAX？就我个人经验而言，似乎很难找到相应的场景。Stack Overflow上有一个类似的问题，有兴趣的不妨点击\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/4316488\/when-is-it-appropriate-to-use-synchronous-ajax\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e查看\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e最后我们再简单解释一下“同步”等待响应与“异步”等待响应的区别：“同步”意味着一旦请求发出，任何后续的JavaScript代码不会再执行，“异步”则是当请求发出后，后续的JavaScript代码会继续执行，当请求成功后，会调用相应的回调函数。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e四、设置请求头\x3c\/h2\x3e\n\x3cp\x3e每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的\x3ccode\x3e.setRequestHeader()\x3c\/code\x3e方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。\x3c\/p\x3e\n\x3cp\x3e默认情况下，当发送AJAX请求时，会附带以下头部信息：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eAccept\x3c\/code\x3e：浏览器能够处理的内容类型；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eAccept-Charset\x3c\/code\x3e: 浏览器能够显示的字符集；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eAccept-Encoding\x3c\/code\x3e：浏览器能够处理的压缩编码；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eAccept-Language\x3c\/code\x3e：浏览器当前设置的语言；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eConnection\x3c\/code\x3e：浏览器与服务器之间连接的类型；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eCookie\x3c\/code\x3e：当前页面设置的任何Cookie；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eHost\x3c\/code\x3e：发出请求的页面所在的域；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eReferer\x3c\/code\x3e：发出请求的页面URI；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eUser-Agent\x3c\/code\x3e：浏览器的用户代理字符串；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e，部分浏览器不允许使用\x3ccode\x3e.setRequestHeader()\x3c\/code\x3e方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 自定义请求头\nxhr.setRequestHeader(\x26quot;myHeader\x26quot;, \x26quot;MyValue\x26quot;)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义请求头\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3exhr\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setRequestHeader\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22myHeader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22MyValue\x22\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e五、发送请求\x3c\/h2\x3e\n\x3cp\x3e到此为止，我们已经完全做好了发送请求的所有准备：利用\x3ccode\x3e.open()\x3c\/code\x3e方法确定了请求方式，等待响应的方式和请求地址，甚至还通过\x3ccode\x3e.setRequestHeader()\x3c\/code\x3e自定义了响应头，接下来就到了最激动人心的时刻：使用\x3ccode\x3e.send()\x3c\/code\x3e方法，发送AJAX请求！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 发送AJAX请求！\nconst xhr = new XMLHttpRequest()\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, false)\nxhr.setRequestHeader(\x26quot;myHeader\x26quot;, \x26quot;goodHeader\x26quot;)\nxhr.send(null)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发送AJAX请求！\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e)\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22myHeader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22goodHeader\x22\x3c\/span\x3e)\nxhr.send(\x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e呃，简单的有些令人尴尬不是吗？换个POST请求试试看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/\/ 发送AJAX请求！\nconst xhr = new XMLHttpRequest()\nxhr.open(\x26quot;post\x26quot;, \x26quot;example.php\x26quot;, false)\nxhr.setRequestHeader(\x26quot;myHeader\x26quot;, \x26quot;bestHeader\x26quot;)\nxhr.send(some_data)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\n\/\/ 发送AJAX请求！\x3c\/span\x3e\nconst xhr = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22post\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22myHeader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22bestHeader\x22\x3c\/span\x3e)\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3esend\x3c\/span\x3e(some_data)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e额..，总觉得还是差点什么？放轻松伙计，因为我们只是发出了请求，还没有\x3cstrong\x3e处理响应\x3c\/strong\x3e，我们这就来看看它。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e六、处理响应\x3c\/h2\x3e\n\x3cp\x3e让我们直接看看如何处理一个同步的GET请求响应：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, false)\nxhr.setRequestHeader(\x26quot;myHeader\x26quot;, \x26quot;goodHeader\x26quot;)\nxhr.send(null)\n\/\/ 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码\n\/\/ 因此xhr.status的值一定不为默认值\nif ((xhr.status \x3e= 200 \x26amp;\x26amp; xhr.status \x3c 300) || xhr.status == 304) {\n    alert(xhr.responseText)\n} else {\n    alert(\x26quot;Request was unsuccessful: \x26quot; \x2b xhr.status)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lua\x22\x3e\x3ccode\x3econst xhr = new XMLHttpRequest()\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22myHeader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22goodHeader\x22\x3c\/span\x3e)\nxhr.send(null)\n\/\/ 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码\n\/\/ 因此xhr.\x3cspan class=\x22hljs-built_in\x22\x3estatus\x3c\/span\x3e的值一定不为默认值\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((xhr.\x3cspan class=\x22hljs-built_in\x22\x3estatus\x3c\/span\x3e \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; xhr.\x3cspan class=\x22hljs-built_in\x22\x3estatus\x3c\/span\x3e \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || xhr.\x3cspan class=\x22hljs-built_in\x22\x3estatus\x3c\/span\x3e == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n    alert(xhr.responseText)\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Request was unsuccessful: \x22\x3c\/span\x3e \x2b xhr.\x3cspan class=\x22hljs-built_in\x22\x3estatus\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码不难理解，我们通过之前提到的xhr\x3ccode\x3e.status\x3c\/code\x3e属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取xhr\x3ccode\x3e.responseText\x3c\/code\x3e属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在\x3ccode\x3exhr.send(null)\x3c\/code\x3e语句被执行后，JavaScript引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的xhr.status值，因此，我们永远都不可能获取请求的资源了。\x3c\/p\x3e\n\x3cp\x3e如何解决这个问题？答案是通过为XMLHTTPRequest实例添加\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件处理程序（当然你也可以直接使用DOM2级规范规定的\x3ccode\x3e.addEventListener()\x3c\/code\x3e方法，但是注意，IE8是不支持该方法的）。\x3c\/p\x3e\n\x3cp\x3exhr实例的\x3ccode\x3ereadystatechange\x3c\/code\x3e事件会监听xhr\x3ccode\x3e.readyState\x3c\/code\x3e属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e0\x3c\/strong\x3e：未初始化 -- 尚未调用\x3ccode\x3e.open()\x3c\/code\x3e方法；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e1\x3c\/strong\x3e：启动 -- 已经调用\x3ccode\x3e.open()\x3c\/code\x3e方法，但尚未调用\x3ccode\x3e.send()\x3c\/code\x3e方法；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2\x3c\/strong\x3e：发送 -- 已经调用\x3ccode\x3e.send()\x3c\/code\x3e方法，但尚未接收到响应；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e3\x3c\/strong\x3e：接收 -- 已经接收到部分响应数据；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e4\x3c\/strong\x3e：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个异步的GET请求代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\nxhr.onreadystatechange = () =\x3e {\n    if (xhr.readystate == 4) {\n        if ((xhr.status \x3e= 200 \x26amp;\x26amp; xhr.status \x3c 300) || xhr.status == 304) {\n            alert(xhr.responseText)\n        } else {\n            alert(\x26quot;Request was unsuccessful: \x26quot; \x2b xhr.status)\n        }\n    }\n}\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, true)\nxhr.send(null)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (xhr.readystate == \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((xhr.status \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; xhr.status \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || xhr.status == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n            alert(xhr.responseText)\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Request was unsuccessful: \x22\x3c\/span\x3e \x2b xhr.status)\n        }\n    }\n}\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\nxhr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e：为了确保跨浏览器的兼容性，必须要在调用\x3ccode\x3e.open()\x3c\/code\x3e方法之前指定事件处理程序，仔细想想也有道理，毕竟\x3ccode\x3e.open()\x3c\/code\x3e方法的执行也包含在该事件处理程序的监听范围之内对吧？\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e七、取消异步请求\x3c\/h2\x3e\n\x3cp\x3e有时候，你可能需要在接收到响应之前取消异步请求，这时候，你需要调用\x3ccode\x3e.abort()\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e该方法会令XHR对象实例停止触发事件，并且不再允许访问任何和响应有关的对象属性。没了监控器，我们再也没法判断响应了不是吗？\x3c\/p\x3e\n\x3cp\x3e但是需要注意的是，当终止AJAX请求后，你需要手动对XHR对象实例进行解绑以释放内存空间。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e?? 恭喜你！到这里你已经学会了所有的AJAX基础知识，你知道了AJAX是什么，存在的意义以及如何真正发起一个AJAX请求并接收响应，你已经是一个AJAX大师！祝贺你！太棒了！??\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3c\/p\x3e\n\x3cp\x3e? 真棒，尊敬的AJAX大师，你居然还没有离开，那么我将传授你最后一部分AJAX秘籍，帮助你成为一个真正的AJAX忍者，这是你的坚持赢得的！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e八、秘籍：XMLHttpRequest 2级\x3c\/h2\x3e\n\x3cp\x3e还记得我们一开始有提到，W3C提出了XMLHttpRequest 2级规范吗？虽然并非所有的浏览器都实现了该规范所规定的内容，但还是有一些内容被全部或大多数浏览器所实现。想成为AJAX忍者？往下看吧。\x3c\/p\x3e\n\x3cp\x3e提示：在这一部分，你将会看到很多有关浏览器兼容性的文字，希望你不要觉得枯燥，毕竟这可是忍者的修行，对吧？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e（一）FormData 类型\x3c\/h3\x3e\n\x3cp\x3eFormData是XMLHttpRequest 2级为我们提供的新的数据类型（构造函数），还记的我们之前是如何伪装一个POST请求为一个表单提交吗？FormData令这一过程变得更加轻松，因为XHR对象能够识别传入的数据类型是FormData的实例，并自动配置适当的头部信息。\x3c\/p\x3e\n\x3cp\x3eFormData的使用方式如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 添加数据\nlet data1 = new FormData()\ndata1.append(\x26quot;name\x26quot;, \x26quot;Tom\x26quot;)\nxhr.send(data1)\n\n\/\/ 提取表单数据\nlet data2 = new FormData(document.forms[0])\nxhr.send(data2)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData()\ndata1.append(\x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Tom\x22\x3c\/span\x3e)\nxhr.send(data1)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取表单数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.forms[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e])\nxhr.send(data2)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外，FormData的另一个好处是相较于传统的AJAX请求，它允许我们上传二进制数据（图片，视频，音频等），具体详情可查看该\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/FormData\/Using_FormData_Objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e链接\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3eFormData的浏览器兼容性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e桌面端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eIE 10\x2b 与其他浏览器均支持\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e移动端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eAndroid，Firefox Mobile，OperaMobile均支持，其余浏览器未知\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e（二）超时设定\x3c\/h3\x3e\n\x3cp\x3e当我们发送一个AJAX请求，却迟迟得不到服务器响应，这种感觉是很糟糕的。为了缓解这种糟糕的感觉，XMLHttpRequest 2级规范为我们提供了一个额外的属性和事件监听事件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3etimeout\x3c\/code\x3e属性：设置超时时间，单位为毫秒；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3etimeout\x3c\/code\x3e事件：当响应时间超出实例对象timeout属性时被触发；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e使用方式如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当响应时间超过1秒时，请求中止，弹出提示框\nxhr.timeout = 1000\nxhr.ontimeout = () =\x3e { alert(\x26quot;Request did not return in a second.\x26quot;) }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当响应时间超过1秒时，请求中止，弹出提示框\x3c\/span\x3e\nxhr\x3cspan class=\x22hljs-selector-class\x22\x3e.timeout\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e\nxhr\x3cspan class=\x22hljs-selector-class\x22\x3e.ontimeout\x3c\/span\x3e = () =\x26gt; { alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Request did not return in a second.\x22\x3c\/span\x3e) }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，当请求终止时，会调用\x3ccode\x3eontimeout\x3c\/code\x3e事件处理程序，此时xhr的\x3ccode\x3ereadyState\x3c\/code\x3e属性的值可能已变为4，这意味着会继续调用\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件处理程序，但是当超时中止请求后再访问xhr的\x3ccode\x3estatus\x3c\/code\x3e属性会使浏览器抛出一个错误，因此需要将检查\x3ccode\x3estatus\x3c\/code\x3e属性的语句放入\x3ccode\x3etry-catch\x3c\/code\x3e语句中。\x3c\/p\x3e\n\x3cp\x3e虽然带来了一些麻烦，但是我们却对XMLHttpRequest对象有了更多的控制。\x3c\/p\x3e\n\x3cp\x3e浏览器兼容性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e桌面端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eIE 10\x2b 与其他浏览器均支持\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e移动端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eIE Mobile 10\x2b 与其他浏览器均支持\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e（三）overrideMimeType()方法\x3c\/h3\x3e\n\x3cp\x3e响应返回的响应头里，描述了返回数据的MIME类型，浏览器通过识别该类型，告知XMLHttpRequest实例处理该数据的方式。然而有时候（例如将XML类型数据当做纯文本处理），我们想要以我们想要的方式处理响应的数据，在XMLHttpRequest 2级规范中，我们可以使用\x3ccode\x3e.overrideMimeType()\x3c\/code\x3e方法，从方法名也可以轻松猜出，该方法可以覆写响应头所描述数据的MIME类型。\x3c\/p\x3e\n\x3cp\x3e其写法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, true)\nxhr.overrideMimeType(\x26quot;text\/xml\x26quot;) \/\/ 强迫浏览器将响应数据以指定类型方式解读\nxhr.send(null)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3econst xhr = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\nxhr.overrideMimeType(\x3cspan class=\x22hljs-string\x22\x3e\x22text\/xml\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e \/\/ 强迫浏览器将响应数据以指定类型方式解读\x3c\/span\x3e\nxhr.\x3cspan class=\x22hljs-built_in\x22\x3esend\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，我们掌控了响应数据的处理方式。\x3c\/p\x3e\n\x3cp\x3e浏览器兼容性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e桌面端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eIE 7\x2b 与其他浏览器均支持\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e移动端\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eFirefox Mobile，Chrome for Android 均支持，其余浏览器未知\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e（四）进度事件\x3c\/h3\x3e\n\x3cp\x3eProgress Events规范是W3C制定的一个工作草案。该规范定义了与客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以更细的颗粒度掌控数据传输过程中的细节。目前共有6个进度事件，他们会随数据传输进展被顺序触发（除了error，abort事件），让我们看看他们的定义和浏览器兼容情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eloadstart\x3c\/code\x3e：在接收到响应数据的第一个字节时触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：除 Safari Mobile 未知外，其他浏览器均支持\x3c\/li\x3e\n\x3cli\x3e移动端：除 Safari Mobile 未知外，其他浏览器均支持\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eprogress\x3c\/code\x3e：在接收响应期间持续不断地触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：IE10\x2b 与其他浏览器均支持\x3c\/li\x3e\n\x3cli\x3e移动端：均支持\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eerror\x3c\/code\x3e：在请求发生错误时触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：所有浏览器均支持（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/ErrorEvent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e信息来源\x3c\/a\x3e）\x3c\/li\x3e\n\x3cli\x3e移动端：除IE Mobile不支持外，其他浏览器均支持（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/ErrorEvent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e信息来源\x3c\/a\x3e）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eabort\x3c\/code\x3e：再因为调用\x3ccode\x3eabort()\x3c\/code\x3e方法时触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：未知\x3c\/li\x3e\n\x3cli\x3e移动端：未知\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eload\x3c\/code\x3e：在接收到完整的响应数据时触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：IE7\x2b 与其他浏览器均支持\x3c\/li\x3e\n\x3cli\x3e移动端：Chrome for Android，Edge，Firefox Mobile支持，其余浏览器未知\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eloadend\x3c\/code\x3e：在通信完成或者触发\x3ccode\x3eerror\x3c\/code\x3e，\x3ccode\x3eabort\x3c\/code\x3e或\x3ccode\x3eload\x3c\/code\x3e事件后触发；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e桌面端：所有浏览器不支持\x3c\/li\x3e\n\x3cli\x3e移动端：所有浏览器不支持\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里我们将着重展开讲解以下两个事件：\x3c\/p\x3e\n\x3cp\x3e① load事件\x3c\/p\x3e\n\x3cp\x3e该事件帮助我们节省了\x3ccode\x3ereadstatechange\x3c\/code\x3e事件，我们不必在XHR对象实例上绑定该事件监听函数以追踪实例上\x3ccode\x3ereadState\x3c\/code\x3e属性的变化，而是可以直接使用以下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\nxhr.onload = () =\x3e {\n    if ((xhr.status \x3e= 200 \x26amp;\x26amp; xhr.status \x3c300) || xhr.status == 304) {\n        alert(xhr.responseText)\n    } else {\n        alert(\x26quot;Something wrong!\x26quot;)\n    }\n}\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, true)\nxhr.send(null)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((xhr.status \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; xhr.status \x26lt;\x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || xhr.status == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n        alert(xhr.responseText)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Something wrong!\x22\x3c\/span\x3e)\n    }\n}\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\nxhr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e② progress事件\x3c\/p\x3e\n\x3cp\x3e该事件令我们可以实现我们梦寐以求的加载进度条效果。因为\x3ccode\x3eonprogress\x3c\/code\x3e事件处理程序会接收到一个\x3ccode\x3eevent\x3c\/code\x3e对象，其\x3ccode\x3etarget\x3c\/code\x3e属性为XHR对象实例，但却额外包含着三个属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3elengthComputable\x3c\/code\x3e：表示进度信息是否可用的布尔值；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eposition\x3c\/code\x3e：表示目前接收的字节数；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3etotalSize\x3c\/code\x3e：表示根据Content-Length响应头部确定的预期字节数；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e很显然，我们的加载进度条所需的一切资源都准备就绪，我们只需写出下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const xhr = new XMLHttpRequest()\nxhr.onload = () =\x3e {\n    if ((xhr.status \x3e= 200 \x26amp;\x26amp; xhr.status \x3c300) || xhr.status == 304) {\n        alert(xhr.responseText)\n    } else {\n        alert(\x26quot;Something wrong!\x26quot;)\n    }\n}\n\/\/ 加载进度条\nxhr.onprogress = function(event) {\n    const divStatus = document.getElementById(\x26quot;status\x26quot;)\n    if (event.lengthComputable) {\n        divStatus.innerHTML = `Received ${event.postion} of ${event.totalSize} bytes`\n    }\n}\nxhr.open(\x26quot;get\x26quot;, \x26quot;example.php\x26quot;, true)\nxhr.send(null)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((xhr.status \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; xhr.status \x26lt;\x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || xhr.status == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n        alert(xhr.responseText)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Something wrong!\x22\x3c\/span\x3e)\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载进度条\x3c\/span\x3e\nxhr.onprogress = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e divStatus = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22status\x22\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (event.lengthComputable) {\n        divStatus.innerHTML = \x3cspan class=\x22hljs-string\x22\x3e`Received \x3cspan class=\x22hljs-subst\x22\x3e${event.postion}\x3c\/span\x3e of \x3cspan class=\x22hljs-subst\x22\x3e${event.totalSize}\x3c\/span\x3e bytes`\x3c\/span\x3e\n    }\n}\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x22get\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22example.php\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\nxhr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一切大功告成！不过还要记得\x3cstrong\x3e注意\x3c\/strong\x3e，需要在\x3ccode\x3e.open()\x3c\/code\x3e方法前调用\x3ccode\x3eonprogress\x3c\/code\x3e事件处理程序。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3c\/p\x3e\n\x3cp\x3e太棒了，关于AJAX，我已经没有什么可说的了，如果你已经掌握了以上所有概念，那么“AJAX忍者”的称号你当之无愧。\x3c\/p\x3e\n\x3cp\x3e我真的为你感到骄傲，Great Work！?\x3c\/p\x3e\n\x3cp\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e\x3cbr\x3e?  Hey！喜欢这篇文章吗？别忘了在下方? 点赞让我知道。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>再也不学AJAX了！（二）使用AJAX</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012237477">https://segmentfault.com/a/1190000012237477</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cjtcf9f7b7f/" target="_blank">https://alili.tech/archive/cjtcf9f7b7f/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>