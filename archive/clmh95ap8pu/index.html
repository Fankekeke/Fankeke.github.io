<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="重新认识JavaScript面向对象: 从ES5到ES6"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>重新认识JavaScript面向对象: 从ES5到ES6 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/clmh95ap8pu/",
				"appid": "1613049289050283", 
				"title": "重新认识JavaScript面向对象: 从ES5到ES6 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-14T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/o6768e6qej/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jtkxkesbj17/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&text=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&text=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&title=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&is_video=false&description=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&title=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&title=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&title=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fclmh95ap8pu%2f&title=%e9%87%8d%e6%96%b0%e8%ae%a4%e8%af%86JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%3a%20%e4%bb%8eES5%e5%88%b0ES6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">重新认识JavaScript面向对象: 从ES5到ES6</h1><div class="meta"><div class="postdate"><time datetime="2018-12-14" itemprop="datePublished">2018-12-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013229218\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013229218\x22 alt=\x22JavaScript\x22 title=\x22JavaScript\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e一. 重新认识面向对象\x3c\/strong\x3e\x3c\/h3\x3e\n\x3ch4\x3e\x3cstrong\x3e1. JavaScript是一门面向对象的语言\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e在说明JavaScript是一个面向对象的语言之前, 我们来探讨一下面向对象的三大基本特征:  \x3cstrong\x3e封装\x3c\/strong\x3e, \x3cstrong\x3e继承\x3c\/strong\x3e, \x3cstrong\x3e多态\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e封装\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e把抽象出来的属性和对方法组合在一起, 且属性值被保护在内部, 只有通过特定的方法进行改变和读取称为封装\x3c\/blockquote\x3e\n\x3cp\x3e我们以代码举例, 首先我们构造一个\x3ccode\x3ePerson\x3c\/code\x3e构造函数, 它有\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3eid\x3c\/code\x3e两个属性, 并有一个\x3ccode\x3esayHi\x3c\/code\x3e方法用于打招呼:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/定义Person构造函数\nfunction Person(name, id) {\n  this.name = name;\n  this.id = id;\n}\n\n\/\/在Person.prototype中加入方法\nPerson.prototype.sayHi = function() {\n  console.log(\x27你好, 我是\x27 \x2b  this.name);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义Person构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, id\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = id;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/在Person.prototype中加入方法\x3c\/span\x3e\nPerson.prototype.sayHi = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27你好, 我是\x27\x3c\/span\x3e \x2b  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们生成一个实例对象\x3ccode\x3ep1\x3c\/code\x3e, 并调用\x3ccode\x3esayHi()\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/实例化对象\nlet p1 = new Person(\x27阿辉\x27, 1234);\n\n\/\/调用sayHi方法\np1.sayHi();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1234\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/调用sayHi方法\x3c\/span\x3e\np1.sayHi();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上述的代码中, \x3ccode\x3ep1\x3c\/code\x3e这个对象并不知道\x3ccode\x3esayHi()\x3c\/code\x3e这个方法是如何实现的, 但是仍然可以使用这个方法. 这其实就是\x3cstrong\x3e封装\x3c\/strong\x3e. 你也可以实现对象属性的私有和公有, 我们在构造函数中声明一个\x3ccode\x3esalary\x3c\/code\x3e作为私有属性, 有且只有通过\x3ccode\x3egetSalary()\x3c\/code\x3e方法查询到薪资.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, id) {\n  this.name = name;\n  this.id = id;\n  let salary = 20000;\n  this.getSalary = function (pwd) {\n    pwd === 123456 ? console.log(salary) : console.log(\x27对不起, 你没有权限查看密码\x27);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, id\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = id;\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e salary = \x3cspan class=\x22hljs-number\x22\x3e20000\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getSalary = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epwd\x3c\/span\x3e) \x3c\/span\x3e{\n    pwd === \x3cspan class=\x22hljs-number\x22\x3e123456\x3c\/span\x3e ? \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(salary) : \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27对不起, 你没有权限查看密码\x27\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e继承\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e可以让某个类型的对象获得另一个类型的对象的属性和方法称为继承\x3c\/blockquote\x3e\n\x3cp\x3e以刚才的\x3ccode\x3ePerson\x3c\/code\x3e作为父类构造器, 我们来新建一个子类构造器\x3ccode\x3eStudent\x3c\/code\x3e, 这里我们使用\x3ccode\x3ecall()\x3c\/code\x3e方法实现继承\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name, id, subject) {\n  \/\/使用call实现父类继承\n  Person.call(this, name, id);\n  \/\/添加子类的属性\n  this.subject = subject;\n}\n\nlet s1 = new Student(\x27阿辉\x27, 1234, \x27前端开发\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, id, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用call实现父类继承\x3c\/span\x3e\n  Person.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name, id);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加子类的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e s1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1234\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e多态\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e同一操作作用于不同的对象产生不同的执行结果, 这称为多态\x3c\/blockquote\x3e\n\x3cp\x3eJavaScript中函数没有重载， 所以JavaScript中的多态是靠函数覆盖实现的。\x3c\/p\x3e\n\x3cp\x3e同样以刚才的\x3ccode\x3ePerson\x3c\/code\x3e构造函数为例, 我们为\x3ccode\x3ePerson\x3c\/code\x3e构造函数添加一个\x3ccode\x3estudy\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, id) {\n  this.name = name;\n  this.id = id;\n  this.study = function() {\n    console.log(name \x2b \x27在学习\x27);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, id\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = id;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27在学习\x27\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样, 我们新建一个\x3ccode\x3eStudent\x3c\/code\x3e和\x3ccode\x3eTeacher\x3c\/code\x3e构造函数, 该构造函数继承\x3ccode\x3ePerson\x3c\/code\x3e, 并也添加\x3ccode\x3estudy\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(subject) {\n  this.subject = subject;\n  this.study = function() {\n    console.log(this.name \x2b \x27在学习\x27 \x2b this.subject);\n  }\n}\nStudent.prototype = new Person(\x27阿辉\x27, 1234);\nStudent.prototype.constructor = Student;\n\nfunction Teacher(subject) {\n  this.subject = subject;\n  this.study = function() {\n    console.log(this.name \x2b \x27为了教学而学习\x27 \x2b this.subject);\n  }\n}\nTeacher.prototype = new Person(\x26quot;老夫子\x26quot;, 4567);\nTeacher.prototype.constructor = Teacher;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27在学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n  }\n}\nStudent.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1234\x3c\/span\x3e);\nStudent.prototype.constructor = Student;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTeacher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27为了教学而学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n  }\n}\nTeacher.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22老夫子\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4567\x3c\/span\x3e);\nTeacher.prototype.constructor = Teacher;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e测试我们新建一个函数\x3ccode\x3edoStudy\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function doStudy(role) {\n  if(role instanceof Person) {\n    role.study();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoStudy\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(role)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(role \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Person) {\n    role.study();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时我们分别实例化\x3ccode\x3eStudent\x3c\/code\x3e和\x3ccode\x3eTeacher\x3c\/code\x3e, 并调用\x3ccode\x3edoStudy\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let student = new Student(\x27前端开发\x27);\nlet teacher = new Teacher(\x27前端开发\x27);\n\ndoStudy(student); \/\/阿辉在学习前端开发\ndoStudy(teacher); \/\/老夫子为了教学在学习前端开发\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e teacher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Teacher(\x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\n\ndoStudy(student); \x3cspan class=\x22hljs-comment\x22\x3e\/\/阿辉在学习前端开发\x3c\/span\x3e\ndoStudy(teacher); \x3cspan class=\x22hljs-comment\x22\x3e\/\/老夫子为了教学在学习前端开发\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于同一函数\x3ccode\x3edoStudy\x3c\/code\x3e， 由于参数的不同， 导致不同的调用结果，这就实现了多态.\x3cbr\x3e\x3cstrong\x3eJavaScript的面向对象\x3c\/strong\x3e\x3cbr\x3e从上面的分析可以论证出, JavaScript是一门面向对象的语言, 因为它实现了面向对象的所有特性. 其实, 面向对象仅仅是一个概念或者一个编程思想而已, 它不应该依赖于某个语言存在, 比如Java采用面向对象思想构造其语言, 它实现了类, 继承, 派生, 多态, 接口等机制. 但是这些机制，只是实现面向对象的一种手段， 而非必须。换言之， 一门语言可以根据自身特性选择合适的方式来实现面向对象。 由于大多数程序员首先学习的是Java, C\x2b\x2b等高级编程语言， 因而先入为主的接受了“类”这个面向对象实际方式，所以习惯性的用类式面向对象语言中的概念来判断该语言是否是面向对象的语言。这也是很多有其他编程语言经验的人在学习JavaScript对象时，感觉到很困难的地方。\x3c\/p\x3e\n\x3cp\x3e实际上， JavaScript是通过一种叫\x3cstrong\x3e原型(prototype)\x3c\/strong\x3e的方式来实现面向对象编程的。下面我们就来讨论一下\x3cstrong\x3e基于类(class-basesd)的面向对象\x3c\/strong\x3e和\x3cstrong\x3e基于原型(protoype-based)的面向对象\x3c\/strong\x3e这两者的差别。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e2. 基于类的面向对象和基于原型的面向对象的比较\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e基于类的面向对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在基于\x3cstrong\x3e类\x3c\/strong\x3e的面向对象语言中（比如Java和C\x2b\x2b）， 是构建在\x3cstrong\x3e类(class)\x3c\/strong\x3e和\x3cstrong\x3e实例(instance)\x3c\/strong\x3e上的。其中\x3cstrong\x3e类\x3c\/strong\x3e定义了所有用于具有某一特征对象的属性。\x3cstrong\x3e类\x3c\/strong\x3e是抽象的事物， 而不是其所描述的全部对象中的任何特定的个体。另一方面， 一个\x3cstrong\x3e实例\x3c\/strong\x3e是一个\x3cstrong\x3e类\x3c\/strong\x3e的实例化，是其中的一个成员。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e基于原型的面向对象\x3c\/strong\x3e\x3cbr\x3e在基于\x3cstrong\x3e原型\x3c\/strong\x3e的语言中（如JavaScript）并不存在这种区别：\x3cstrong\x3e它只有对象！\x3c\/strong\x3e不论是构造函数(constructor)，实例(instance)，原型(prototype)本身都是对象。基于原型的语言具有所谓的原型对象的概念，新对象可以从中获得原始的属性。\x3c\/p\x3e\n\x3cp\x3e所以，在JavaScript中有一个很有意思的\x3ccode\x3e__proto__\x3c\/code\x3e属性（ES6以下是非标准属性）用于访问其原型对象， 你会发现，上面提到的构造函数，实例，原型本身都有\x3ccode\x3e__proto__\x3c\/code\x3e指向原型对象。其最后顺着原型链都会指向\x3ccode\x3eObject\x3c\/code\x3e这个构造函数，然而\x3ccode\x3eObject\x3c\/code\x3e的原型对象的原型是\x3ccode\x3enull\x3c\/code\x3e，不信， 你可以尝试一下\x3ccode\x3eObject.prototype.__proto__ === null\x3c\/code\x3e为\x3ccode\x3etrue\x3c\/code\x3e。然而\x3ccode\x3etypeof null === \x27object\x27\x3c\/code\x3e为\x3ccode\x3etrue\x3c\/code\x3e。到这里， 我相信你应该就能明白为什么JavaScript这类基于原型的语言中没有类和实例的区别， 而是\x3cstrong\x3e万物皆对象！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e差异总结\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e基于类的（Java）\x3c\/th\x3e\n\x3cth\x3e基于原型的（JavaScript）\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e类和实例是不同的事物。\x3c\/td\x3e\n\x3ctd\x3e所有对象均为实例。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e通过类定义来定义类；通过构造器方法来实例化类。\x3c\/td\x3e\n\x3ctd\x3e通过构造器函数来定义和创建一组对象。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e通过 new 操作符创建单个对象。\x3c\/td\x3e\n\x3ctd\x3e相同\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e通过类定义来定义现存类的子类， 从而构建对象的层级结构\x3c\/td\x3e\n\x3ctd\x3e指定一个对象作为原型并且与构造函数一起构建对象的层级结构\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e遵循类链接继承属性\x3c\/td\x3e\n\x3ctd\x3e遵循原型链继承属性\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e类定义指定类的所有实例的所有属性。无法在运行时动态添加属性\x3c\/td\x3e\n\x3ctd\x3e构造器函数或原型指定初始的属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e二. ES5中的面向对象\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cblockquote\x3e*这里的ES5并不特指ECMAScript 5， 而是代表ECMAScript 6 之前的ECMAScript！\x3c\/blockquote\x3e\n\x3ch4\x3e\x3cstrong\x3e(一) ES5中对象的创建\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e在ES5中创建对象有两种方式， 第一种是使用对象字面量的方式， 第二种是使用构造函数的方式。该两种方法在特定的使用场景分别有其优点和缺点， 下面我们来分别介绍这两种创建对象的方式。\x3c\/p\x3e\n\x3ch5\x3e\x3cstrong\x3e1. 使用对象字面量的方式\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e我们通过对象字面量的方式创建两个\x3ccode\x3estudent\x3c\/code\x3e对象，分别是\x3ccode\x3estudent1\x3c\/code\x3e和\x3ccode\x3estudent2\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var student1 = {\n  name: \x27阿辉\x27,\n  age: 22,\n  subject: \x27前端开发\x27\n};\n\nvar student2 = {\n  name: \x27阿傻\x27,\n  age: 22,\n  subject: \x27大数据开发\x27\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e student1 = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esubject\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e student2 = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27阿傻\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esubject\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27大数据开发\x27\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码就是使用对象字面量的方式创建实例对象， 使用对象字面量的方式在创建单一简单对象的时候是非常方便的。但是，它也有其缺点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在生成多个实例对象时， 我们需要每次重复写\x3ccode\x3ename\x3c\/code\x3e,\x3ccode\x3eage\x3c\/code\x3e,\x3ccode\x3esubject\x3c\/code\x3e属性，写起来特别的麻烦\x3c\/li\x3e\n\x3cli\x3e虽然都是学生的对象， 但是看不出\x3ccode\x3estudent1\x3c\/code\x3e和\x3ccode\x3estudent2\x3c\/code\x3e之间有什么联系。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了解决以上两个问题， JavaScript提供了构造函数创建对象的方式。\x3c\/p\x3e\n\x3ch5\x3e\x3cstrong\x3e2. 使用构造函数的方式\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e构造函数就其实就是一个普通的函数，当对构造函数使用\x3ccode\x3enew\x3c\/code\x3e进行实例化时，会将其内部\x3ccode\x3ethis\x3c\/code\x3e的指向绑定实例对象上，下面我们来创建一个\x3ccode\x3eStudent\x3c\/code\x3e构造函数（构造函数约定使用大写开头，和普通函数做区分）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n  console.log(this);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我特意在构造函数中打印出\x3ccode\x3ethis\x3c\/code\x3e的指向。上面我们提到，构造函数其实就是一个普通的函数， 那么我们使用普通函数的调用方式尝试调用\x3ccode\x3eStudent\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Student(\x27阿辉\x27, 22, \x27前端开发\x27); \/\/window{}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eStudent(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/window{}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e采用普通方式调用\x3ccode\x3eStudent\x3c\/code\x3e时， \x3ccode\x3ethis\x3c\/code\x3e的指向是\x3ccode\x3ewindow\x3c\/code\x3e。下面使用\x3ccode\x3enew\x3c\/code\x3e来实例化该构造函数， 生成一个实例对象\x3ccode\x3estudent1\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let student1 = new Student(\x27阿辉\x27, 22, \x27前端开发\x27); \/\/Student\x26nbsp;{name: \x26quot;阿辉\x26quot;, age: 22, subject: \x26quot;前端开发\x26quot;}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/Student\x26nbsp;{name: \x22阿辉\x22, age: 22, subject: \x22前端开发\x22}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们采用\x3ccode\x3enew\x3c\/code\x3e生成实例化对象\x3ccode\x3estudent1\x3c\/code\x3e时， \x3ccode\x3ethis\x3c\/code\x3e不再指向\x3ccode\x3ewindow\x3c\/code\x3e, 而是指向的实例对象本身。这些， 都是\x3ccode\x3enew\x3c\/code\x3e帮我们做的。上面的就是采用构造函数的方式生成实例对象的方式， 并且当我们生成其他实例对象时，由于都是采用\x3ccode\x3eStudent\x3c\/code\x3e这个构造函数实例化而来的， 我们能够清楚的知道各实例对象之间的联系。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let student1 = new Student(\x27阿辉\x27, 22, \x27前端开发\x27);\nlet student2 = new Student(\x27阿傻\x27, 22, \x27大数据开发\x27);\nlet student3 = new Student(\x27阿呆\x27, 22, \x27Python\x27);\nlet student4 = new Student(\x27阿笨\x27, 22, \x27Java\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿傻\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27大数据开发\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿呆\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Python\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿笨\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Java\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e(二) ES5中对象的继承\x3c\/strong\x3e\x3c\/h4\x3e\n\x3ch5\x3e\x3cstrong\x3e1. \x3ccode\x3eprototype\x3c\/code\x3e的原型继承\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e\x3ccode\x3eprototype\x3c\/code\x3e是JavaScript这类基于原型继承的核心， 只要弄明白了原型和原型链， 就基本上完全理解了JavaScript中对象的继承。下面我将着重的讲解为什么要使用\x3ccode\x3eprototype\x3c\/code\x3e和使用\x3ccode\x3eprototype\x3c\/code\x3e实现继承的方式。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e为什么要使用\x3ccode\x3eprototype\x3c\/code\x3e？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们给之前的\x3ccode\x3eStudent\x3c\/code\x3e构造函数新增一个\x3ccode\x3estudy\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n  this.study = function() {\n    console.log(\x27我在学习\x27 \x2b this.subject);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我在学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们来实例化\x3ccode\x3eStudent\x3c\/code\x3e构造函数， 生成\x3ccode\x3estudent1\x3c\/code\x3e和\x3ccode\x3e`student2\x3c\/code\x3e, 并分别调用其\x3ccode\x3estudy\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let student1 = new Student(\x27阿辉\x27, 22, \x27前端开发\x27);\nlet student2 = new Student(\x27阿傻\x27, 22, \x27大数据开发\x27);\n\nstudent1.study(); \/\/我在学习前端开发\nstudent2.study(); \/\/我在学习大数据开发\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿傻\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27大数据开发\x27\x3c\/span\x3e);\n\nstudent1.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习前端开发\x3c\/span\x3e\nstudent2.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习大数据开发\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样生成的实例对象表面上看没有任何问题， 但是其实是有很大的\x3cstrong\x3e性能问题\x3c\/strong\x3e！我们来看下面一段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(student1.study === student2.study); \/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(student1.study === student2.study); \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实对于每一个实例对象\x3ccode\x3estudentx\x3c\/code\x3e，其\x3ccode\x3estudy\x3c\/code\x3e方法的函数体是一模一样的，方法的执行结果只根据其实例对象决定，然而生成的每个实例都需要生成一个\x3ccode\x3estudy\x3c\/code\x3e方法去占用一份内存。这样是非常不经济的做法。新手可能会认为， 上面的代码中也就多生成了一个\x3ccode\x3estudy\x3c\/code\x3e方法， 对于内存的占用可以忽略不计。\x3c\/p\x3e\n\x3cp\x3e那么我们在MDN中看一下在JavaScript中我们使用的\x3ccode\x3eString\x3c\/code\x3e实例对象有多少方法？ \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013229219?w=875\x26amp;h=905\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013229219?w=875\x26amp;h=905\x22 alt=\x22String中的方法\x22 title=\x22String中的方法\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面的方法只是\x3ccode\x3eString\x3c\/code\x3e实例对象中的一部分方法（我一个屏幕截取不完！）， 这也就是为什么我们的字符串能够使用如此多便利的原生方法的原因。设想一下， 如果这些方法不是挂载在\x3ccode\x3eString.prototype\x3c\/code\x3e上， 而是像上面\x3ccode\x3eStudent\x3c\/code\x3e一样写在\x3ccode\x3eString\x3c\/code\x3e构造函数上呢？那么我们项目中的每一个字符串，都会去生成这几十种方法去占用内存，这还没考虑\x3ccode\x3eMath\x3c\/code\x3e,\x3ccode\x3eArray\x3c\/code\x3e,\x3ccode\x3eNumber\x3c\/code\x3e,\x3ccode\x3eObject\x3c\/code\x3e等对象！\x3c\/p\x3e\n\x3cp\x3e现在我们应该知道应该将\x3ccode\x3estudy\x3c\/code\x3e方法挂载到\x3ccode\x3eStudent.prototype\x3c\/code\x3e原型对象上才是正确的写法，所有的\x3ccode\x3estudentx\x3c\/code\x3e实例都能继承该方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n}\nStudent.prototype.study = function() {\n  console.log(\x27我在学习\x27 \x2b this.subject);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n}\nStudent.prototype.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我在学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们实例化\x3ccode\x3estudent1\x3c\/code\x3e和\x3ccode\x3estudent2\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let student1 = new Student(\x27阿辉\x27, 22, \x27前端开发\x27);\nlet student2 = new Student(\x27阿傻\x27, 22, \x27大数据开发\x27);\n\nstudent1.study(); \/\/我在学习前端开发\nstudent2.study(); \/\/我在学习大数据开发\n\nconsole.log(student1.study === student2.study); \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿傻\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27大数据开发\x27\x3c\/span\x3e);\n\nstudent1.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习前端开发\x3c\/span\x3e\nstudent2.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习大数据开发\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(student1.study === student2.study); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的代码我们可以看出， \x3ccode\x3estudent1\x3c\/code\x3e和\x3ccode\x3estudent2\x3c\/code\x3e的\x3ccode\x3estudy\x3c\/code\x3e方法执行结果没有发生变化，但是\x3ccode\x3estudy\x3c\/code\x3e本身指向了一个内存地址。这就是为什么我们要使用\x3ccode\x3eprototype\x3c\/code\x3e进行挂载方法的原因。接下来我们来讲解一下如何使用\x3ccode\x3eprototype\x3c\/code\x3e来实现继承。\x3c\/p\x3e\n\x3ch5\x3e\x3cstrong\x3e如何使用\x3ccode\x3eprototype\x3c\/code\x3e实现继承？\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e“学生”这个对象可以分为小学生， 中学生和大学生等。我们现在新建一个小学生的构造函数\x3ccode\x3ePupil\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Pupil(school) {\n  this.school = school;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePupil\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eschool\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.school = school;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么如何让\x3ccode\x3ePupil\x3c\/code\x3e使用\x3ccode\x3eprototype\x3c\/code\x3e继承\x3ccode\x3eStudent\x3c\/code\x3e呢? 其实我们只要将\x3ccode\x3ePupil\x3c\/code\x3e的\x3ccode\x3eprototype\x3c\/code\x3e指向\x3ccode\x3eStudent\x3c\/code\x3e的一个实例即可。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Pupil.prototype = new Student(\x27小辉\x27, 8, \x27小学义务教育课程\x27);\nPupil.prototype.constructor = Pupil;\n\nlet pupil1 = new Pupil(\x27北大附小\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ePupil.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e);\nPupil.prototype.constructor = Pupil;\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码的第一行， 我们将\x3ccode\x3ePupil\x3c\/code\x3e的原型对象（\x3ccode\x3ePupil.prototype\x3c\/code\x3e）指向了\x3ccode\x3eStudent\x3c\/code\x3e的实例对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Pupil.prototype = new Student(\x27小辉\x27, 8, \x27小学义务教育课程\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ePupil.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码的第二行也许有的读者会不能理解是什么意思。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Pupil.prototype.constructor = Pupil;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ePupil.prototype.constructor = Pupil;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ePupil\x3c\/code\x3e作为构造函数有一个\x3ccode\x3eprotoype\x3c\/code\x3e属性指向原型对象\x3ccode\x3ePupil.prototype\x3c\/code\x3e，而原型对象\x3ccode\x3ePupil.prototype\x3c\/code\x3e也有一个\x3ccode\x3econstructor\x3c\/code\x3e属性指回它的构造函数\x3ccode\x3ePupil\x3c\/code\x3e。如下图所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013229220?w=841\x26amp;h=337\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013229220?w=841\x26amp;h=337\x22 alt=\x22prototype和constructor的指向\x22 title=\x22prototype和constructor的指向\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e然而， 当我们使用实例化\x3ccode\x3eStudent\x3c\/code\x3e去覆盖\x3ccode\x3ePupil.prototype后\x3c\/code\x3e， 如果没有第二行代码的情况下， \x3ccode\x3ePupil.prototype.constructor\x3c\/code\x3e指向了\x3ccode\x3eStudent\x3c\/code\x3e构造函数， 如下图所示：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013229221?w=820\x26amp;h=312\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013229221?w=820\x26amp;h=312\x22 alt=\x22prototype和constructor的指向错误\x22 title=\x22prototype和constructor的指向错误\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而且， \x3ccode\x3epupil1.constructor\x3c\/code\x3e会默认调用\x3ccode\x3ePupil.prototype.constructor\x3c\/code\x3e， 这个时候\x3ccode\x3epupil1.constructor\x3c\/code\x3e指向了\x3ccode\x3eStudent\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Pupil.prototype = new Student(\x27小辉\x27, 8, \x27小学义务教育课程\x27);\nlet pupil1 = new Pupil(\x27北大附小\x27);\n\nconsole.log(pupil1.constructor === Student); \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ePupil.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(pupil1.constructor === Student); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这明显是错误的， \x3ccode\x3epupil1\x3c\/code\x3e明明是用\x3ccode\x3ePupil\x3c\/code\x3e构造函数实例化出来的， 怎么其\x3ccode\x3econstructor\x3c\/code\x3e指向了\x3ccode\x3eStudent\x3c\/code\x3e构造函数呢。所以， 我们就需要加入第二行， 修正其错误：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Pupil.prototype = new Student(\x27小辉\x27, 8, \x27小学义务教育课程\x27);\n\n\/\/修正constructor的指向错误\nPupil.prototype.constructor = Pupil;\n\nlet pupil1 = new Pupil(\x27北大附小\x27);\n\nconsole.log(pupil1.constructor === Student); \/\/false\nconsole.log(pupil1.constructor === Pupil); \/\/ture\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3ePupil.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/修正constructor的指向错误\x3c\/span\x3e\nPupil.prototype.constructor = Pupil;\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(pupil1.constructor === Student); \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(pupil1.constructor === Pupil); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ture\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面就是我们的如何使用\x3ccode\x3eprototype\x3c\/code\x3e实现继承的例子， 需要特别注意的: \x3cstrong\x3e如果替换了prototype对象， 必须手动将\x3ccode\x3eprototype.constructor\x3c\/code\x3e重新指向其构造函数。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch5\x3e\x3cstrong\x3e2. 使用\x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e方法实现继承\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e使用\x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e是我个人比较喜欢的继承方式， 因为只需要一行代码就可以实现继承。但是该方法也有其局限性，\x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e不能继承原型上的属性和方法， 下面会有详细说明。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e使用\x3ccode\x3ecall\x3c\/code\x3e实现继承\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e同样对于上面的\x3ccode\x3eStudent\x3c\/code\x3e构造函数， 我们使用\x3ccode\x3ecall\x3c\/code\x3e实现\x3ccode\x3ePupil\x3c\/code\x3e继承\x3ccode\x3eStudent\x3c\/code\x3e的全部属性和方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/父类构造函数\nfunction Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n}\n\n\/\/子类构造函数\nfunction Pupil(name, age, subject, school) {\n  \/\/使用call实现继承\n  Student.call(this, name, age, subject);\n  this.school = school;\n}\n\n\/\/实例化Pupil\nlet pupil2 = new Pupil(\x27小辉\x27, 8, \x27小学义务教育课程\x27, \x27北大附小\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/父类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/子类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePupil\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, subject, school\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用call实现继承\x3c\/span\x3e\n  Student.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name, age, subject);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.school = school;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化Pupil\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是， \x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e只能继承本地属性和方法， 而不能继承原型上的属性和方法，如下面的代码所示, 我们给\x3ccode\x3eStudent\x3c\/code\x3e挂载\x3ccode\x3estudy\x3c\/code\x3e方法，\x3ccode\x3ePupil\x3c\/code\x3e使用\x3ccode\x3ecall\x3c\/code\x3e继承\x3ccode\x3eStudent\x3c\/code\x3e后， 调用\x3ccode\x3epupil2.study()\x3c\/code\x3e会报错：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/父类构造函数\nfunction Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n}\n\/\/原型上挂载study方法\nStudent.prototype.study = function() {\n  console.log(\x27我在学习\x27 \x2b this.subject);\n}\n\n\/\/子类构造函数\nfunction Pupil(name, age, subject, school) {\n  \/\/使用call实现继承\n  Student.call(this, name, age, subject);\n  this.school = school;\n}\n\nlet pupil2 = new Pupil(\x27小辉\x27, 8, \x27小学义务教育课程\x27, \x27北大附小\x27);\n\n\/\/报错\npupil2.study(); \/\/Uncaught TypeError: pupil2.study is not a function\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/父类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/原型上挂载study方法\x3c\/span\x3e\nStudent.prototype.study = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我在学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/子类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePupil\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, subject, school\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用call实现继承\x3c\/span\x3e\n  Student.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name, age, subject);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.school = school;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/报错\x3c\/span\x3e\npupil2.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/Uncaught TypeError: pupil2.study is not a function\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e使用\x3ccode\x3eapply\x3c\/code\x3e实现继承\x3c\/strong\x3e\x3cbr\x3e使用\x3ccode\x3eapply\x3c\/code\x3e实现继承的方式和\x3ccode\x3ecall\x3c\/code\x3e类似， 唯一的不同只是参数需要使用数组的方法。下面我们使用\x3ccode\x3eapply\x3c\/code\x3e来实现上面\x3ccode\x3ePupil\x3c\/code\x3e继承\x3ccode\x3eStudent\x3c\/code\x3e的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/父类构造函数\nfunction Student (name, age, subject) {\n  this.name = name;\n  this.age = age; \n  this.subject = subject;\n}\n\n\/\/子类构造函数\nfunction Pupil(name, age, subject, school) {\n  \/\/使用applay实现继承\n  Student.apply(this, [name, age, subject]);\n  this.school = school;\n}\n\n\/\/实例化Pupil\nlet pupil2 = new Pupil(\x27小辉\x27, 8, \x27小学义务教育课程\x27, \x27北大附小\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/父类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, age, subject\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age; \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/子类构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePupil\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, subject, school\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用applay实现继承\x3c\/span\x3e\n  Student.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, [name, age, subject]);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.school = school;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化Pupil\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e\x3cstrong\x3e3. 其他继承方式\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3eJavaScript中的继承方式不仅仅只有上面提到的几种方法， 在《JavaScript高级程序设计》中， 还有实例继承，拷贝继承，组合继承，寄生组合继承等众多继承方式。在寄生组合继承中， 就很好的弥补了\x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e无法继承原型属性和方法的缺陷，是最完美的继承方法。这里就不详细的展开论述，感兴趣的可以自行阅读《JavaScript高级程序设计》。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3e三. ES6中的面向对象\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e基于原型的继承方式，虽然实现了代码复用，但是行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效的组织管理。不得不承认，基于类的继承方式在语言实现上更健壮，且在构建可服用代码和组织架构程序方面具有明显的优势。所以，ES6中提供了基于类\x3ccode\x3eclass\x3c\/code\x3e的语法。但\x3ccode\x3eclass\x3c\/code\x3e本质上是ES6提供的一颗\x3cstrong\x3e语法糖\x3c\/strong\x3e，正如我们前面提到的，\x3cstrong\x3eJavaScript是一门基于原型的面向对象语言\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e(一) ES6中对象的创建\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e我们使用ES6的\x3ccode\x3eclass\x3c\/code\x3e来创建\x3ccode\x3eStudent\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/定义类\nclass Student {\n  \/\/构造方法\n  constructor(name, age, subject) {\n    this.name = name;\n    this.age = age;\n    this.subject = subject;\n  }\n\n  \/\/类中的方法\n  study(){\n    console.log(\x27我在学习\x27 \x2b this.subject);\n  }\n}\n\n\/\/实例化类\nlet student3 = new Student(\x27阿辉\x27, 24, \x27前端开发\x27);\nstudent3.study(); \/\/我在学习前端开发\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义类\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/构造方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name, age, subject) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject = subject;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/类中的方法\x3c\/span\x3e\n  study(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我在学习\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject);\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化类\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e student3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27阿辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27前端开发\x27\x3c\/span\x3e);\nstudent3.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习前端开发\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码定义了一个\x3ccode\x3eStudent\x3c\/code\x3e类， 可以看到里面有一个\x3ccode\x3econstructor\x3c\/code\x3e方法， 这就是构造方法，而\x3ccode\x3ethis\x3c\/code\x3e关键字则代表实例对象。也就是说，ES5中的构造函数\x3ccode\x3eStudent\x3c\/code\x3e， 对应的是E6中\x3ccode\x3eStudent\x3c\/code\x3e类中的\x3ccode\x3econstructor\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eStudent\x3c\/code\x3e类除了构造函数方法，还定义了一个\x3ccode\x3estudy\x3c\/code\x3e方法。需要特别注意的是，在ES6中定义类中的方法的时候，前面不需要加上\x3ccode\x3efunction\x3c\/code\x3e关键字，直接把函数定义进去就可以了。另外，方法之间不要用逗号分隔，加了会报错。而且，类中的方法全部是定义在原型上的，我们可以用下面的代码进行验证。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(student3.__proto__.study === Student.prototype.study); \/\/true\nconsole.log(student3.hasOwnProperty(\x27study\x27)); \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(student3.__proto__.study === Student.prototype.study); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(student3.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27study\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的第一行的代码中, \x3ccode\x3estudent3.__proto__\x3c\/code\x3e是指向的原型对象，其中\x3ccode\x3eStudent.prototype\x3c\/code\x3e也是指向的原型的对象，结果为\x3ccode\x3etrue\x3c\/code\x3e就能很好的说明上面的结论： \x3cstrong\x3e类中的方法全部是定义在原型上的\x3c\/strong\x3e。第二行代码是验证\x3ccode\x3estudent3\x3c\/code\x3e实例中是否有\x3ccode\x3estudy\x3c\/code\x3e方法，结果为\x3ccode\x3efalse\x3c\/code\x3e， 表明实例中没有\x3ccode\x3estudy\x3c\/code\x3e方法，这也更好的说明了上面的结论。其实，只要理解了\x3cstrong\x3eES5中的构造函数对应的是类中的\x3ccode\x3econstructor\x3c\/code\x3e方法\x3c\/strong\x3e，就能推断出上面的结论。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e(二) ES6中对象的继承\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3eE6中\x3ccode\x3eclass\x3c\/code\x3e可以通过\x3ccode\x3eextends\x3c\/code\x3e关键字来实现继承， 这比前面提到的ES5中使用原型链来实现继承， 要清晰和方便很多。下面我们使用ES6的语法来实现\x3ccode\x3ePupil\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/子类\nclass Pupil extends Student{\n  constructor(name, age, subject, school) {\n    \/\/调用父类的constructor\n    super(name, age, subject); \n    this.school = school;\n  }\n}\n\nlet pupil = new Pupil(\x27小辉\x27, 8, \x27小学义务教育课程\x27, \x27北大附小\x27);\npupil.study(); \/\/我在学习小学义务教育课程\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/子类\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePupil\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name, age, subject, school) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用父类的constructor\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(name, age, subject); \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.school = school;\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pupil = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pupil(\x3cspan class=\x22hljs-string\x22\x3e\x27小辉\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27小学义务教育课程\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27北大附小\x27\x3c\/span\x3e);\npupil.study(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/我在学习小学义务教育课程\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码代码中， 我们通过了\x3ccode\x3eextends\x3c\/code\x3e实现\x3ccode\x3ePupil\x3c\/code\x3e子类继承\x3ccode\x3eStudent\x3c\/code\x3e父类。需要特别注意的是，子类必须在\x3ccode\x3econstructor\x3c\/code\x3e方法中\x3cstrong\x3e首先调用\x3ccode\x3esuper\x3c\/code\x3e方法\x3c\/strong\x3e，否则实例化时会报错。这是因为子类没有自己的\x3ccode\x3ethis\x3c\/code\x3e对象， 而是继承父类的\x3ccode\x3ethis\x3c\/code\x3e对象，然后对其加工。如果不调用\x3ccode\x3esuper\x3c\/code\x3e方法，子类就得不到\x3ccode\x3ethis\x3c\/code\x3e对象。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3cstrong\x3e四.结束语\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3eJavaScript 被认为是世界上最受误解的编程语言，因为它身披 c 语言家族的外衣，表现的却是 LISP 风格的函数式语言特性；没有类，却实也彻底实现了面向对象。要对这门语言有透彻的理解，就必须扒开其 c 语言的外衣，从新回到函数式编程的角度，同时摒弃原有类的面向对象概念去学习领悟它\x3csup\x3e(摘自参考目录1)\x3c\/sup\x3e。现在的前端中不仅普遍的使用了ES6的新语法，而且在JavaScript的基础上还出现了TypeScript、CoffeeScript这样的超集。可以预见的是，目前在前端生态圈一片繁荣的情况下，对JSer的需求也会越来越多，但同时也对前端开发者的JavaScript的水平提出了更加严苛的要求。使用面向对象的思想去开发前端项目也是未来对JSer的基本要求之一！\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\x3cstrong\x3e五.参考文章\x3c\/strong\x3e\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.ibm.com\/developerworks\/cn\/web\/1304_zengyz_jsoo\/#artrelatedtopics\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIBM: 全面理解面向对象的JavaScript\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Guide\/Details_of_the_Object_Model\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN: 对象模型的细节\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2010\/05\/object-oriented_javascript_encapsulation.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰： Javascript面向对象编程系列\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/class\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰： ECMASciprt6入门\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>重新认识JavaScript面向对象: 从ES5到ES6</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013186214">https://segmentfault.com/a/1190000013186214</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/clmh95ap8pu/" target="_blank">https://alili.tech/archive/clmh95ap8pu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>