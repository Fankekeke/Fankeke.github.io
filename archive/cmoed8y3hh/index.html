<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="谈谈JavaScript异步代码优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>谈谈JavaScript异步代码优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cmoed8y3hh/",
				"appid": "1613049289050283", 
				"title": "谈谈JavaScript异步代码优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-01T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3ixizua869w/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6k01smuoi37/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&text=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&text=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&title=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&is_video=false&description=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&title=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&title=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&title=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcmoed8y3hh%2f&title=%e8%b0%88%e8%b0%88JavaScript%e5%bc%82%e6%ad%a5%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">谈谈JavaScript异步代码优化</h1><div class="meta"><div class="postdate"><time datetime="2018-12-01" itemprop="datePublished">2018-12-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e关于\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e微信公众号：前端呼啦圈（Love-FED）\x3c\/li\x3e\n\x3cli\x3e我的博客：\x3ca href=\x22http:\/\/www.cnblogs.com\/luozhihao\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e劳卜的博客\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e知乎专栏：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/font-end\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端呼啦圈\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e在实际编码中，我们经常会遇到Javascript代码异步执行的场景，比如ajax的调用、定时器的使用等，在这样的场景下也经常会出现这样那样匪夷所思的bug或者糟糕的代码片段，那么处理好你的Javascript异步代码成为了异步编程至关重要的前提。下面我们从问题出发，一步步完善你的异步代码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e异步问题\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1. 回调地狱\x3c\/h3\x3e\n\x3cp\x3e首先，我们来看下异步编程中最常见的一种问题，便是回调地狱。它的出现是由于异步代码执行时间的不确定性及代码间的依赖关系引发的，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 一个动画结束后，执行下一个动画，下一个动画结束后再执行下一个动画\n$(\x27#box\x27).animate({width: \x27100px\x27}, 1000, function(){\n    $(\x27#box\x27).animate({height: \x27100px\x27}, 1000, function(){\n        $(\x27#box\x27).animate({left: 100}, 1000);\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个动画结束后，执行下一个动画，下一个动画结束后再执行下一个动画\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100px\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100px\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        $(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3eleft\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于我们不知道第一个动画什么时候开始或者什么时候结束，所以我们把第二个动画的执行内容放到了第一个动画的结束事件里，把第三个动画放到了第二个动画的结束事件里，这时候如果有很多这样的动画，那么就会形成回调地狱。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2. 捕获异常\x3c\/h3\x3e\n\x3cp\x3e除了回调地狱，如果我们需要在异步代码中捕获异常也比较麻烦，可能需要手动配置捕获方法:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22try {\n    throw new Error(\x27fail\x27);\n} catch (e) {\n    console.log(e);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fail\x27\x3c\/span\x3e);\n} \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的代码书写明显不是我们想要的，不仅不利于维护，而且也在一定程度上违背了良好的Javascript编码规范。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e解决方案\x3c\/h2\x3e\n\x3cp\x3e那么我们如何优雅的写好我们的异步代码呢？我主要列了以下5种常见方案：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e1. callback\x3c\/h3\x3e\n\x3cp\x3ecallback顾名思义便是回调，但并不是将回调内容放在异步方法里，而是放到外部的回调函数中，比如问题1的代码我们通过callback可以变成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(\x27#box\x27).animate({width: \x27100px\x27}, 1000, autoHeight);\n\nfunction autoHeight() {\n    $(\x27#box\x27).animate({height: \x27100px\x27}, 1000, autoLeft);\n}\n\nfunction autoLeft() {\n    $(\x27#box\x27).animate({left: 100}, 1000);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e$(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100px\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e, autoHeight);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eautoHeight\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100px\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e, autoLeft);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eautoLeft\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).animate({\x3cspan class=\x22hljs-attr\x22\x3eleft\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如此我们看似异步的代码变成了同步的写法，避免了层层嵌套的写法，看上去也流畅了很多。同时使用callback也是异步编程最基础和核心的一种解决思路。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2. Promise\x3c\/h3\x3e\n\x3cp\x3e基于callback，Promise目前也被广泛运用，其是异步编程的一种解决方案，比传统的回调函数解决方案更合理和强大。相信了解ES6的同学肯定不会陌生。\x3c\/p\x3e\n\x3cp\x3e比如我们现在有这样一个场景，我们需要异步加载一张图片，在图片加载成功后做一些操作，这里我不想用回调函数或者将逻辑写在图片的成功事件里，那么用Promise我们可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let p = new Promise((resolve, reject) =\x3e {\n    let img = new Image(); \/\/ 创建图片对象\n    \n    \/\/ 图片加载成功事件\n    img.onload = function() {\n        resolve(img); \/\/ 输出图片对象\n    };\n    \n    \/\/ 图片加载失败事件\n    img.onerror = function() {\n        reject(new Error(\x27load error\x27)); \/\/ 输出错误\n    };\n    \n    img.src = \x27xxx\x27; \/\/ 图片路径\n});\n\n\/\/ Promise then回调\np\n.then(result =\x3e {\n    $(\x27#box\x27).append(result); \/\/ 成功后我们把图片放到页面上\n})\n.catch(error =\x3e {\n    console.log(error); \/\/ 打印错误\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e img = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建图片对象\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片加载成功事件\x3c\/span\x3e\n    img.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        resolve(img); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出图片对象\x3c\/span\x3e\n    };\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片加载失败事件\x3c\/span\x3e\n    img.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27load error\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出错误\x3c\/span\x3e\n    };\n    \n    img.src = \x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 图片路径\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Promise then回调\x3c\/span\x3e\np\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27#box\x27\x3c\/span\x3e).append(result); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 成功后我们把图片放到页面上\x3c\/span\x3e\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(error); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打印错误\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过Promise我们把图片构建加载的逻辑和成功或失败后的处理逻辑拆分了开来，将回调函数的嵌套，改成链式调用，同时使用Promise的catch事件回调后异常捕获也变得十分方便。\x3c\/p\x3e\n\x3cp\x3e当然如果要等待多个异步请求完成执行某些操作，可以使用Promise.all方法，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let p = Promise.all([p1, p2, p3]); \/\/ 其中p1、p2、p3都是Promise实例\n\np.then(result =\x3e console.log(result));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([p1, p2, p3]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其中p1、p2、p3都是Promise实例\x3c\/span\x3e\n\np.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然Promise也有其相应的缺点，比如下一个then回调只能获取上一个then返回的数据，不能跨层获取，同时大量的then回调也会使代码不容易维护。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e3. Generator\x3c\/h3\x3e\n\x3cp\x3e与Promise一样，Generator 函数也是 ES6 提供的一种异步编程解决方案，其会返回一个遍历器对象，异步任务需要暂停的地方我们可以使用yield语句，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* getData() {\n    let result = yield fetch(\x26quot;xxx\x26quot;); \/\/ 调用ajax，yield命令后面只能是 Thunk 函数或 Promise 对象\n    \n    console.log(result);\n}\n\n\/\/ 执行\nlet g = getData();\nlet result = g.next(); \/\/ { value: [object Promise], done: false }\n\nresult.value.then(data =\x3e {\n    return data.json();\n}).then(data =\x3e {\n    g.next(data);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egetData\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x22xxx\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用ajax，yield命令后面只能是 Thunk 函数或 Promise 对象\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e g = getData();\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = g.next(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { value: [object Promise], done: false }\x3c\/span\x3e\n\nresult.value.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e data.json();\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    g.next(data);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eGenerator中遇到yield的地方会进行暂停，所以我们需要手动调用next方法往下，next返回值的 value 属性便是我们需要的数据，这里是fetch方法返回的Promise对象，所以我们需要使用then回调，最后再调用g.next(data)结束并输出数据。\x3c\/p\x3e\n\x3cp\x3eGenerator 函数的缺点在于，我们每一次执行yield语句都需要手动进行next，不是很方便。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e4. co\x3c\/h3\x3e\n\x3cp\x3e为了解决上方Generator函数需手动执行next方法的问题，TJ Holowaychuk大神编写了一个co函数库，能够使Generator 函数可以自动执行，比如原来我们需要这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let files = function* (){\n    var f1 = yield readFile(\x27\/xxx\/xxx\x27); \/\/ 读取file1文件\n    var f2 = yield readFile(\x27\/xxx\/xxx\x27); \/\/ 读取file2文件\n    \n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n\nfiles.next(); \/\/ 执行yield\nfiles.next(); \/\/ 执行yield\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e files = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f1 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27\/xxx\/xxx\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取file1文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f2 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27\/xxx\/xxx\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取file2文件\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f1.toString());\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f2.toString());\n};\n\nfiles.next(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行yield\x3c\/span\x3e\nfiles.next(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行yield\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用co后：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var co = require(\x27co\x27);\n\nco(files);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e co = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27co\x27\x3c\/span\x3e);\n\nco(files);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eco 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22co(files).then(() =\x3e {\n  console.log(\x27执行完成\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eco(files).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27执行完成\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后我们可以看到我们没有手动执行next方法，也会打印出所读取的文件。\x3c\/p\x3e\n\x3cp\x3eco模块虽然很好的帮助了我们解决了Generator函数必须靠执行器的问题，但是使用起来我们都需要额外引入一个模块，那么有没有更加方便的方式来解决呢？继续往下看。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e5. async and await\x3c\/h3\x3e\n\x3cp\x3e除了以上4中方式可以解决Javascript异步编程的问题外，ES7还提供了更加方便的async 函数和await命令，了解一下？\x3c\/p\x3e\n\x3cp\x3e其实async是 Generator 函数的语法糖，不同点在于其内置了执行器，也就是说async函数自带执行器。看一下下面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let p1 = new Promise((resolve, reject) =\x3e {\n    setTimeout(() =\x3e {\n        resolve(1);\n    }, 1000);\n});\n\nlet p2 = new Promise((resolve, reject) =\x3e {\n    setTimeout(() =\x3e {\n        resolve(2); \n    }, 1000);\n});\n\nasync function waitFn() {\n    let a = await p1; \/\/ await命令后面可以是 Promise 对象和原始类型的值，如果使原始类型最终也会返回为Promise对象\n    let b = await p2;\n    \n    return a \x2b b\n}\n\n\/\/ async函数的返回值是 Promise 对象， 可以用then方法指定下一步的操作\nwaitFn().then(result =\x3e {\n    console.log(result);  \/\/ 2s后输出3\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewaitFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e p1; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ await命令后面可以是 Promise 对象和原始类型的值，如果使原始类型最终也会返回为Promise对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e b = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e p2;\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b b\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ async函数的返回值是 Promise 对象， 可以用then方法指定下一步的操作\x3c\/span\x3e\nwaitFn().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2s后输出3\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3easync函数内部return语句返回的值，会成为then方法回调函数的参数。因此这就像极了利用co包裹起来的Generator函数，只是把*替换成了async，把yield替换成了await。\x3c\/p\x3e\n\x3cp\x3e可以说async and await 是ES7中最重要的一个特性，虽然其也存在一些弊端，但是相比较而言用其处理异步代码来说还是比较得心应手的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e结语\x3c\/h2\x3e\n\x3cp\x3e本文简单介绍了处理好Javascript异步代码的五种常见方式，每一种方式都有其使用和存在的条件和必要性，有兴趣的同学可以对其进行单独的拓展和探究，只有了解并掌握每一种方式各自的优点并加以运用，才能享受异步编程带来的快感。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>谈谈JavaScript异步代码优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014819809">https://segmentfault.com/a/1190000014819809</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cmoed8y3hh/" target="_blank">https://alili.tech/archive/cmoed8y3hh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>