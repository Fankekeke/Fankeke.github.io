<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端状态管理请三思"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端状态管理请三思 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ct9vl2wnrqi/",
				"appid": "1613049289050283", 
				"title": "前端状态管理请三思 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0lrkurkvlb4/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/khxz3hqn9bs/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&text=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&text=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&title=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&title=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&title=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&title=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fct9vl2wnrqi%2f&title=%e5%89%8d%e7%ab%af%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e8%af%b7%e4%b8%89%e6%80%9d"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端状态管理请三思</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e最近我开始思考React应用的状态管理。我已经取得一些有趣的结论，并且在这篇文章里我会向你展示我们所谓的状态管理并不是真的在管理状态。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e译者：阿里云前端-也树\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e原文链接：\x3ca href=\x22http:\/\/krasimirtsonev.com\/blog\/article\/managing-state-in-javascript-with-state-machines-stent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emanaging-state-in-javascript-with-state-machines-stent\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e我们避而不谈的是什么（The elephant in the room）\x3c\/h2\x3e\n\x3cp\x3e我们来看一个简单的例子。想象这是一个展示用户名称、密码和一个按钮的表单组件。用户会在填写表单后点击提交。如果一切顺利，我们完成了登录，并且有必要展示欢迎信息和一些链接：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858134?w=800\x26amp;h=302\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858134?w=800\x26amp;h=302\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们假定这个组件有两个展示状态。一个是未登录状态，另一个是用户登录后的状态。所以从管理这两种状态开始，我们用一个布尔值的标志位来描述用户的状态。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var isLoggedIn;\nisLoggedIn = false; \/\/ 展示表单\nisLoggedIn = true; \/\/ 展示欢迎信息和链接\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isLoggedIn;\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示表单\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示欢迎信息和链接\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是这样还不够。如果我们点击提交按钮后触发的HTTP请求需要一些时间来响应，我们不能把表单孤零零的放在屏幕上，而需要更多的UI元素来展示这样的中间状态，因此我们不得不在组件中引入另一个状态。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858135?w=800\x26amp;h=214\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858135?w=800\x26amp;h=214\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在我们有了第三种展示状态，仅仅用一个 \x3ccode\x3eisLoggedIn\x3c\/code\x3e 变量已经不能解决了。不走运的是我们不能设置变量值为 \x3ccode\x3efalse-ish\x3c\/code\x3e，它不是 \x3ccode\x3etrue\x3c\/code\x3e 也不是 \x3ccode\x3efalse\x3c\/code\x3e。当然，我们可以引入另一个变量比如说 \x3ccode\x3eisInProgress\x3c\/code\x3e。一旦我们发送请求就会把这个变量的值置为 \x3ccode\x3etrue\x3c\/code\x3e。这个变量会告诉我们是处于请求的过程中并且用户应该看到加载中的展示状态。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var isLoggedIn;\nvar isInProgress; \n\n\/\/ 展示表单\nisLoggedIn = false;\nisInProgress = false;\n\n\/\/ 请求过程中\nisLoggedIn = false;\nisInProgress = true;\n\n\/\/ 展示欢迎信息和链接\nisLoggedIn = true;\nisInProgress = false;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isLoggedIn;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isInProgress; \n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示表单\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 请求过程中\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示欢迎信息和链接\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e非常棒！我们用到两个变量并且需要记住这三种情况对应的变量值。看起来我们解决了问题。但另外的问题是，我们维护了太多状态。如果我们需要展示一个请求成功的信息，或者一切顺利的时候我们需要告知用户：“Yep, 你成功登录了”，并且两秒后信息伴随着华丽的动画隐藏起来，接着展示出最终的界面，要怎么办？\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858136?w=800\x26amp;h=302\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858136?w=800\x26amp;h=302\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e现在情况变得有些复杂。我们有了 \x3ccode\x3eisLoggedIn\x3c\/code\x3e 和 \x3ccode\x3eisInProgress\x3c\/code\x3e，但是看起来仅仅使用它们还不够。\x3ccode\x3eisInProgress\x3c\/code\x3e 在请求结束后确实是 \x3ccode\x3efalse\x3c\/code\x3e，但是他的默认值同样是 \x3ccode\x3efalse\x3c\/code\x3e。我觉得我们需要第三个变量 - \x3ccode\x3eisSuccessful\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var isLoggedIn, isInProgress, isSuccessful;\n\n\/\/ 展示表单\nisLoggedIn = false;\nisInProgress = false;\nisSuccessful = false;\n\n\/\/ 请求过程中\nisLoggedIn = false;\nisInProgress = true;\nisSuccessful = false;\n\n\/\/ 展示成功状态\nisLoggedIn = true;\nisInProgress = false;\nisSuccessful = true;\n\n\/\/ 展示欢迎信息和链接\nisLoggedIn = true;\nisInProgress = false;\nisSuccessful = false;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isLoggedIn, isInProgress, isSuccessful;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示表单\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisSuccessful = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 请求过程中\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\nisSuccessful = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示成功状态\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisSuccessful = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示欢迎信息和链接\x3c\/span\x3e\nisLoggedIn = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\nisInProgress = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\nisSuccessful = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们简单的状态管理一步步变成了由 if-else 组成的巨大的条件网，很难去理解和维护。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (isInProgress) {\n  \/\/ 请求过程中\n} else if (isLoggedIn) {\n  if (isSuccessful) {\n    \/\/ 展示请求成功信息\n  } else {\n    \/\/ 展示欢迎信息和链接\n  }\n} else {\n  \/\/ 等待输入，展示表单\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isInProgress) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 请求过程中\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isLoggedIn) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isSuccessful) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示请求成功信息\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示欢迎信息和链接\x3c\/span\x3e\n  }\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待输入，展示表单\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们还有一个问题会让这个情景变得更糟：如果请求失败我们要怎么做？我们需要展示一个错误信息和一个重试链接，如果点击重试我们会重复一次请求的过程。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858137?w=800\x26amp;h=302\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858137?w=800\x26amp;h=302\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在我们的代码已经没有任何可维护性。我们有非常多的场景需要满足，仅仅依赖引入新的变量是不可接受的。让我们想想是否可以通过更好的命名方式来解决，同时可能还需要引入一个新的条件声明。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eisInProgress\x3c\/code\x3e 仅仅在请求的过程中被用到。我们现在还关心请求结束之后的过程。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eisLoggedIn\x3c\/code\x3e 有一点误导的含义，因为我们只要请求结束就把它置为 \x3ccode\x3etrue\x3c\/code\x3e。而如果请求出错，用户并没有真正登入。所以我们把它重命名为 \x3ccode\x3eisRequestFinished\x3c\/code\x3e。虽然看起来好些了，但是它仅仅代表我们从服务器获得了响应，并不能用它来判断响应是否为错误。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eisSuccessful\x3c\/code\x3e 是一个最终状态合适的候选变量。如果请求出错我们可以把它设置为 \x3ccode\x3efalse\x3c\/code\x3e，但是等等，它的默认值也是 \x3ccode\x3efalse\x3c\/code\x3e。所以它也不能作为代表错误状态的变量。\x3c\/p\x3e\n\x3cp\x3e我们需要第四个变量，\x3ccode\x3eisFailed\x3c\/code\x3e 怎么样？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var isRequestFinished, isInProgress, isSuccessful, isFailed;\n\nif (isInProgress) {\n  \/\/ 请求过程中\n} else if (isRequestFinished) {\n  if (isSuccessful) {\n    \/\/ 展示请求成功信息\n  } else if (isFailed) {\n    \/\/ 展示请求失败信息和重试链接\n  } else {\n    \/\/ 展示欢迎信息和链接\n  }\n} else {\n  \/\/ 等待输入，展示表单\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isRequestFinished, isInProgress, isSuccessful, isFailed;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isInProgress) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 请求过程中\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isRequestFinished) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isSuccessful) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示请求成功信息\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFailed) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示请求失败信息和重试链接\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示欢迎信息和链接\x3c\/span\x3e\n  }\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待输入，展示表单\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这四个变量描述了一个看似简单但实际并不简单的过程，这个过程包含了许多边界情况。当项目进一步迭代时，最终可能会由于已有变量的组合不能满足新的需求，而定义更多的变量。这就是构建用户界面十分困难的原因。\x3c\/p\x3e\n\x3cp\x3e我们需要更好的状态管理方式。也许可以使用更现代和更流行的概念。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eFlux 或者 Redux 怎么样？\x3c\/h2\x3e\n\x3cp\x3e最近我在思考 Flux 架构和 Redux 库在状态管理中的定位。即使这些工具和状态管理有关，但是它们本质上不是解决这类问题的。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eFlux 是 Facebook 用来构建客户端 web 应用的架构。它利用单向数据流补足了 React 的视图组件的组织方式。\x3c\/p\x3e\n\x3cp\x3eRedux 是一个可预测的状态容器，用来构建 JavaScript 应用。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e它们是 “单向数据流” 和 “状态容器”，而不是 “状态管理”。Flux 和 Redux 背后的概念是非常实用和讨巧的。我认为它们是适合构建用户界面的方式。单向数据流让数据拥有可预测性，改进了前端开发。Redux 中的 reducer 拥有的不可变特性，提供了一种可以减少 bug 的数据传送方式。\x3cbr\x3e就我的感受来说，这些模式更适用于数据管理和数据流管理。它们提供了完善的 API 来交换改变我们应用数据的信息，但是并不能解决我们状态管理的问题。这也因为这些问题是跟项目强相关的，问题的上下文取决于我们正在做的事情。\x3cbr\x3e当然像处理 HTTP 请求我们可以通过某个库来解决，但是对其它相关的业务逻辑我们仍然需要自己编写代码来实现。问题在于我们如何用一种合适的方式去组织这些代码，而不至于每两年就把整个应用重写一遍。\x3c\/p\x3e\n\x3cp\x3e几个月之前我开始寻找可以解决状态管理问题的模式，最终我发现了状态机的概念。事实上我们一直都在构建状态机，只不过我们不知道。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e什么是状态机？\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858138?w=800\x26amp;h=212\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858138?w=800\x26amp;h=212\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e状态机的数学定义是一个计算模型，我的理解是：状态机就是保存你的状态和状态变化的一个盒子。这里有一些不同种类的状态机，适用于我们这个案例的是有限状态机。像它的名字一样，有限状态机包含有限的几种状态。它接收一个输入并且基于这个输入和当前的状态决定下一个状态，可能会有多种情况输出。当状态机改变了状态，我们就称为它过渡到一个新的状态。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e实战状态机\x3c\/h2\x3e\n\x3cp\x3e为了使用状态机我们或多或少需要定义两件事 - 状态和可能的过渡方法。让我们来尝试实现上面提到的表单需求。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011858139?w=800\x26amp;h=302\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011858139?w=800\x26amp;h=302\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在这个表格中我们可以清楚的看到所有状态和他们可能的输出情况。我们同样定义了如果输入被传递进状态机后的下一个状态。编写这样的表格对你的开发周期大有裨益，因为他会回答你以下问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e用户界面可能出现的所有状态有哪些？\x3c\/li\x3e\n\x3cli\x3e每种状态之间会发生什么？\x3c\/li\x3e\n\x3cli\x3e如果某种状态改变，结果是什么？\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这三个问题可以解决非常多的难题。想象一下当我们改变内容展示的时候有一个动画效果，当动画开始时，UI 仍然处于之前的状态并且用户仍然可以产生交互。举个例子，用户非常快速地点击了两次提交按钮。如果不适用状态机，我们需要使用if语句通过标志变量来防止代码的执行。但是如果回到上面那个表格，我们会看到 loading 状态不接受 Submit 状态的输入。所以如果我们在第一次点击按钮后把状态机转变为 loading 状态，我们就会处于一个安全的位置。即使 Submit 输入\/动作被分发过来，状态机也会忽略它，当然也不会再向后端发出一个请求。\x3c\/p\x3e\n\x3cp\x3e状态机模式对我来说是适用的。以下有三个理由支撑我在我的应用中使用状态机：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e状态机模式免去了很多可能出现的 bug 和奇怪的清洁，因为它不会让 UI 变化为我们不知道的状态。\x3c\/li\x3e\n\x3cli\x3e状态机不接受没有明确定义的输入作为当前的状态。这会免去我们对其它代码执行的部分容错处理。\x3c\/li\x3e\n\x3cli\x3e状态机强制开发者以声明式的方式思考。因为我们大部分的逻辑需要提前定义。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e在 JavaScript 里实现状态机\x3c\/h2\x3e\n\x3cp\x3e现在，既然我们知道什么是状态机，那就让我们来实现一个并且解决我们一开始的问题。用一些嵌套的属性定义一个简单的对象字面量。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const machine = {\n  currentState: \x27login form\x27,\n  states: {\n    \x27login form\x27: {\n      submit: \x27loading\x27\n    },\n    \x27loading\x27: {\n      success: \x27profile\x27,\n      failure: \x27error\x27\n    },\n    \x27profile\x27: {\n      viewProfile: \x27profile\x27,\n      logout: \x27login form\x27\n    },\n    \x27error\x27: {\n      tryAgain: \x27loading\x27\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e machine = {\n  \x3cspan class=\x22hljs-attr\x22\x3ecurrentState\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27login form\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3estates\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x27login form\x27\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3esubmit\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27loading\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-string\x22\x3e\x27loading\x27\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3esuccess\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3efailure\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3eviewProfile\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3elogout\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27login form\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3etryAgain\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27loading\x27\x3c\/span\x3e\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个状态机对象使用我们上面表格中的内容定义了状态。像示例中那样，当我们在 \x3ccode\x3elogin form\x3c\/code\x3e 状态时，我们用 \x3ccode\x3esubmit\x3c\/code\x3e 作为一个输入并且应该以 \x3ccode\x3eloading\x3c\/code\x3e 状态结束。现在我们需要一个接收输入的函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const input = function (name) {\n  const state = machine.currentState;\n\n  if (machine.states[state][name]) {\n    machine.currentState = machine.states[state][name];\n  }\n  console.log(`${ state } \x2b ${ name } --\x3e ${ machine.currentState }`);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e input = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e state = machine.currentState;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (machine.states[state][name]) {\n    machine.currentState = machine.states[state][name];\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${ state }\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-subst\x22\x3e${ name }\x3c\/span\x3e --\x26gt; \x3cspan class=\x22hljs-subst\x22\x3e${ machine.currentState }\x3c\/span\x3e`\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们获得了当前状态并且检查提供的input是否合法，如果通过检查，我们就改变当前的状态，或者换句话说，将状态机过渡到一个新的状态。我们提供了一个日志输出用来输入、当前状态和新的状态（如果有变化的话）。下面是如何去使用我们的状态机：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22input(\x27tryAgain\x27);\n\/\/ login form \x2b tryAgain --\x3e login form\n\ninput(\x27submit\x27);\n\/\/ login form \x2b submit --\x3e loading\n\ninput(\x27submit\x27);\n\/\/ loading \x2b submit --\x3e loading\n\ninput(\x27failure\x27);\n\/\/ loading \x2b failure --\x3e error\n\ninput(\x27submit\x27);\n\/\/ error \x2b submit --\x3e error\n\ninput(\x27tryAgain\x27);\n\/\/ error \x2b tryAgain --\x3e loading\n\ninput(\x27success\x27);\n\/\/ loading \x2b success --\x3e profile\n\ninput(\x27viewProfile\x27);\n\/\/ profile \x2b viewProfile --\x3e profile\n\ninput(\x27logout\x27);\n\/\/ profile \x2b logout --\x3e login form\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3einput(\x3cspan class=\x22hljs-string\x22\x3e\x27tryAgain\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ login form \x2b tryAgain --\x26gt; login form\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ login form \x2b submit --\x26gt; loading\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ loading \x2b submit --\x26gt; loading\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27failure\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ loading \x2b failure --\x26gt; error\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error \x2b submit --\x26gt; error\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27tryAgain\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ error \x2b tryAgain --\x26gt; loading\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27success\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ loading \x2b success --\x26gt; profile\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27viewProfile\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ profile \x2b viewProfile --\x26gt; profile\x3c\/span\x3e\n\ninput(\x3cspan class=\x22hljs-string\x22\x3e\x27logout\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ profile \x2b logout --\x26gt; login form\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意我们尝试通过在 \x3ccode\x3elogin form\x3c\/code\x3e 状态的时候发送 \x3ccode\x3etryAgain\x3c\/code\x3e 状态来打破状态机的运转或者是重复发送提交请求。在这些场景下，当前的状态没有被改变并且状态机会忽略这些输入。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e最后的话\x3c\/h2\x3e\n\x3cp\x3e我不知道状态机的概念是否适用于你自己的场景，但是对我来说非常适用。我仅仅改变了我处理状态管理的方式。我建议去尝试一下，绝对是值得的。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端状态管理请三思</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011858129">https://segmentfault.com/a/1190000011858129</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ct9vl2wnrqi/" target="_blank">https://alili.tech/archive/ct9vl2wnrqi/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>