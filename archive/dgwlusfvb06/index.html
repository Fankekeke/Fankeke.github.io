<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="很全很全的JavaScript的模块讲解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>很全很全的JavaScript的模块讲解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dgwlusfvb06/",
				"appid": "1613049289050283", 
				"title": "很全很全的JavaScript的模块讲解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-21T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bqvcpuxvfzj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/okovi01cdsi/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&text=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&text=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&is_video=false&description=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdgwlusfvb06%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84JavaScript%e7%9a%84%e6%a8%a1%e5%9d%97%e8%ae%b2%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">很全很全的JavaScript的模块讲解</h1><div class="meta"><div class="postdate"><time datetime="2018-12-21" itemprop="datePublished">2018-12-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e最近一直在搞基础的东西，弄了一个持续更新的github笔记，可以去看看，诚意之作（本来就是写给自己看的……）链接地址：\x3ca href=\x22https:\/\/qiqihaobenben.github.io\/Front-End-Basics\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFront-End-Basics\x3c\/a\x3e  \x3c\/p\x3e\n\x3cp\x3e此篇文章的地址：\x3ca href=\x22https:\/\/qiqihaobenben.github.io\/Front-End-Basics\/JavaScript\/utility\/module\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript的模块\x3c\/a\x3e  \x3c\/p\x3e\n\x3cp\x3e基础笔记的github地址：\x3ca href=\x22https:\/\/github.com\/qiqihaobenben\/Front-End-Basics\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/qiqihaobenben\/Front-End-Basics\x3c\/a\x3e ,可以watch,也可以star。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e正文开始\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eJavaScript的模块\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e介绍\x3c\/h3\x3e\n\x3cp\x3e模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。\x3c\/p\x3e\n\x3ch4\x3e模块的优点\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cstrong\x3e可维护性。\x3c\/strong\x3e  因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e命名空间。\x3c\/strong\x3e 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e重用代码。\x3c\/strong\x3e 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eCommonJS\x3c\/h3\x3e\n\x3cp\x3eCommonJS 最开始是 Mozilla 的工程师于 2009 年开始的一个项目，它的目的是让浏览器之外的 JavaScript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。  \x3c\/p\x3e\n\x3cp\x3e在 CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。  \x3c\/p\x3e\n\x3cp\x3e需要注意的是，CommonJS 规范的主要适用场景是服务器端编程，所以采用同步加载模块的策略。如果我们依赖3个模块，代码会一个一个依次加载它们。  \x3c\/p\x3e\n\x3cp\x3e该模块实现方案主要包含 require 与 module 这两个关键字，其允许某个模块对外暴露部分接口并且由其他模块导入使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/sayModule.js\nfunction SayModule () {\n    this.hello = function () {\n        console.log(\x27hello\x27);\n    };\n\n    this.goodbye = function () {\n        console.log(\x27goodbye\x27);\n    };\n}\n\nmodule.exports = SayModule;\n\n\/\/main.js 引入sayModule.js\nvar Say = require(\x27.\/sayModule.js\x27);\nvar sayer = new Say();\nsayer.hello(); \/\/hello\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/sayModule.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSayModule\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hello = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e);\n    };\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.goodbye = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27goodbye\x27\x3c\/span\x3e);\n    };\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = SayModule;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/main.js 引入sayModule.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Say = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/sayModule.js\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sayer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Say();\nsayer.hello(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/hello\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e作为一个服务器端的解决方案，CommonJS 需要一个兼容的脚本加载器作为前提条件。该脚本加载器必须支持名为 require 和 module.exports 的函数，它们将模块相互导入导出。\x3c\/p\x3e\n\x3ch4\x3e\x3ccode\x3eNode.js\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3eNode 从 CommonJS 的一些创意中，创造出自己的模块化实现。由于Node 在服务端的流行，Node 的模块形式被（不正确地）称为 CommonJS。\x3c\/p\x3e\n\x3cp\x3eNode.js模块可以分为两大类，一类是核心模块，另一类是文件模块。  \x3cbr\x3e\x3cstrong\x3e核心模块\x3c\/strong\x3e 就是Node.js标准的API中提供的模块，如fs、http、net等，这些都是由Node.js官方提供的模块，编译成了二进制代码，可以直接通过require获取核心模块，例如require(\x27fs\x27)，核心模块拥有最高的加载优先级，如果有模块与核心模块命名冲突，Node.js总是会加载核心模块。  \x3cbr\x3e\x3cstrong\x3e文件模块\x3c\/strong\x3e 是存储为单独的文件（或文件夹）的模块，可能是JavaScript代码、JSON或编译好的C\/C\x2b\x2b代码。在不显式指定文件模块扩展名的时候，Node.js会分别试图加上.js、.json、.node(编译好的C\/C\x2b\x2b代码)。\x3c\/p\x3e\n\x3cblockquote\x3e加载方式\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e按路径加载模块\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e如果require参数以\x22\/\x22开头，那么就以绝对路径的方式查找模块名称，如果参数以\x22.\/\x22、\x22..\/\x22开头，那么则是以相对路径的方式来查找模块。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e通过查找node_modules目录加载模块\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e如果require参数不以\x22\/\x22、\x22.\/\x22、\x22..\/\x22开头，而该模块又不是核心模块，那么就要通过查找node_modules加载模块了。我们使用的npm获取的包通常就是以这种方式加载的。\x3c\/p\x3e\n\x3cblockquote\x3e加载缓存\x3c\/blockquote\x3e\n\x3cp\x3eNode.js模块不会被重复加载，这是因为Node.js通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。  \x3cbr\x3e\x3cem\x3e注意：\x3c\/em\x3e Node.js是根据实际文件名缓存的，而不是require()提供的参数缓存的，也就是说即使你分别通过require(\x27express\x27)和require(\x27.\/node_modules\/express\x27)加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。  \x3c\/p\x3e\n\x3cp\x3eNode.js 中的模块在加载之后是以单例化运行，并且遵循值传递原则：如果是一个对象，就相当于这个对象的引用。\x3c\/p\x3e\n\x3cblockquote\x3e模块载入过程\x3c\/blockquote\x3e\n\x3cp\x3e加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22例如运行： node app.js\n\nModule.runMain = function () {\n    \/\/ Load the main module--the command line argument.\n    Module._load(process.argv[1], null, true);\n};\n\n\/\/_load静态方法在分析文件名之后执行\nvar module = new Module(id, parent);\n\n\/\/并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载。\nmodule.load(filename);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e例如运行： node app.js\n\nModule.runMain = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Load the main module--the command line argument.\x3c\/span\x3e\n    Module._load(process.argv[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/_load静态方法在分析文件名之后执行\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Module(id, \x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载。\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.load(filename);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e具体说一下上文提到了文件模块的三类模块,这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法，具体的加载方法在下文\x3ccode\x3erequire.extensions\x3c\/code\x3e中会介绍。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e.js\x3c\/code\x3e 通过fs模块同步读取js文件并编译执行。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.node\x3c\/code\x3e 通过C\/C\x2b\x2b进行编写的Addon。通过dlopen方法进行加载。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.json\x3c\/code\x3e 读取文件，调用JSON.parse解析加载。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e接下来详细描述js后缀的编译过程。Node.js在编译js文件的过程中实际完成的步骤有对js文件内容进行头尾包装。以app.js为例，包装之后的app.js将会变成以下形式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/circle.js\nvar PI = Math.PI;\nexports.area = function (r) {\n    return PI * r * r;\n};\nexports.circumference = function (r) {\n    return 2 * PI * r;\n};\n\n\/\/app.js\nvar circle = require(\x27.\/circle.js\x27);\nconsole.log( \x27The area of a circle of radius 4 is \x27 \x2b circle.area(4));\n\n\/\/app包装后\n(function (exports, require, module, __filename, __dirname) {\n    var circle = require(\x27.\/circle.js\x27);\n    console.log(\x27The area of a circle of radius 4 is \x27 \x2b circle.area(4));\n});\n\n\/\/这段代码会通过vm原生模块的runInThisContext方法执行（类似eval，只是具有明确上下文，不污染全局），返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/circle.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e PI = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.PI;\nexports.area = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3er\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e PI * r * r;\n};\nexports.circumference = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3er\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * PI * r;\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/app.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e circle = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/circle.js\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-string\x22\x3e\x27The area of a circle of radius 4 is \x27\x3c\/span\x3e \x2b circle.area(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/app包装后\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eexports, require, module, __filename, __dirname\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e circle = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/circle.js\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27The area of a circle of radius 4 is \x27\x3c\/span\x3e \x2b circle.area(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e));\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这段代码会通过vm原生模块的runInThisContext方法执行（类似eval，只是具有明确上下文，不污染全局），返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这就是为什么require并没有定义在app.js 文件中，但是这个方法却存在的原因。从Node.js的API文档中可以看到还有\x3ccode\x3e__filename\x3c\/code\x3e、\x3ccode\x3e__dirname\x3c\/code\x3e、\x3ccode\x3emodule\x3c\/code\x3e、\x3ccode\x3eexports\x3c\/code\x3e几个没有定义但是却存在的变量。其中\x3ccode\x3e__filename\x3c\/code\x3e和\x3ccode\x3e__dirname\x3c\/code\x3e在查找文件路径的过程中分析得到后传入的。\x3ccode\x3emodule\x3c\/code\x3e变量是这个模块对象自身，\x3ccode\x3eexports\x3c\/code\x3e是在module的构造函数中初始化的一个空对象（{}，而不是null）。  \x3cbr\x3e在这个主文件中，可以通过require方法去引入其余的模块。而其实这个require方法实际调用的就是module._load方法。  \x3cbr\x3eload方法在载入、编译、缓存了module后，返回module的exports对象。这就是circle.js文件中只有定义在exports对象上的方法才能被外部调用的原因。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e以上所描述的模块载入机制均定义在lib\/module.js中。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3erequire 函数\x3c\/blockquote\x3e\n\x3cp\x3erequire 引入的对象主要是函数。当 Node 调用 require() 函数，并且传递一个文件路径给它的时候，Node 会经历如下几个步骤：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eResolving：找到文件的绝对路径；\x3c\/li\x3e\n\x3cli\x3eLoading：判断文件内容类型；\x3c\/li\x3e\n\x3cli\x3eWrapping：打包，给这个文件赋予一个私有作用范围。这是使 require 和 module 模块在本地引用的一种方法；\x3c\/li\x3e\n\x3cli\x3eEvaluating：VM 对加载的代码进行处理的地方；\x3c\/li\x3e\n\x3cli\x3eCaching：当再次需要用这个文件的时候，不需要重复一遍上面步骤。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3erequire.extensions 来查看对三种文件的支持情况\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0sHs?w=800\x26amp;h=443\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0sHs?w=800\x26amp;h=443\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e可以清晰地看到 Node 对每种扩展名所使用的函数及其操作：对 .js 文件使用 module._compile；对 .json 文件使用 JSON.parse；对 .node 文件使用 process.dlopen。  \x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e文件查找策略\x3c\/em\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e从文件模块缓存中加载\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e尽管原生模块与文件模块的优先级不同，但是优先级最高的是从文件模块的缓存中加载已经存在的模块。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e从原生模块加载\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个\x3ccode\x3ehttp\x3c\/code\x3e、\x3ccode\x3ehttp.js\x3c\/code\x3e、\x3ccode\x3ehttp.node\x3c\/code\x3e、\x3ccode\x3ehttp.json\x3c\/code\x3e文件，\x3ccode\x3erequire(“http”)\x3c\/code\x3e都不会从这些文件中加载，而是从原生模块中加载。  \x3cbr\x3e原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e从文件加载\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前面说过是调用load方法。 \x3cbr\x3e··\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22当 Node 遇到 require(X) 时，按下面的顺序处理。\n\n（1）如果 X 是内置模块（比如 require(\x27http\x27）) \n　　a. 返回该模块。 \n　　b. 不再继续执行。\n\n（2）如果 X 以 \x26quot;.\/\x26quot; 或者 \x26quot;\/\x26quot; 或者 \x26quot;..\/\x26quot; 开头 \n　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 \n　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n        X\n        X.js\n        X.json\n        X.node\n\n　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n        X\/package.json（main字段）\n        X\/index.js\n        X\/index.json\n        X\/index.node\n\n（3）如果 X 不带路径 \n　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。 \n　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。\n\n（4） 抛出 \x26quot;not found\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e当 Node 遇到 require(X) 时，按下面的顺序处理。\n\n（\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e）如果 X 是内置模块（比如 require(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e）) \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e. 返回该模块。 \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e. 不再继续执行。\n\n（\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e）如果 X 以 \x3cspan class=\x22hljs-string\x22\x3e\x22.\/\x22\x3c\/span\x3e 或者 \x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e 或者 \x3cspan class=\x22hljs-string\x22\x3e\x22..\/\x22\x3c\/span\x3e 开头 \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e. 根据 X 所在的父模块，确定 X 的绝对路径。 \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n        X\n        X\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n        X\x3cspan class=\x22hljs-selector-class\x22\x3e.json\x3c\/span\x3e\n        X\x3cspan class=\x22hljs-selector-class\x22\x3e.node\x3c\/span\x3e\n\n　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n        X\/package.json（main字段）\n        X\/index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n        X\/index\x3cspan class=\x22hljs-selector-class\x22\x3e.json\x3c\/span\x3e\n        X\/index\x3cspan class=\x22hljs-selector-class\x22\x3e.node\x3c\/span\x3e\n\n（\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e）如果 X 不带路径 \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e. 根据 X 所在的父模块，确定 X 可能的安装目录。 \n　　\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e. 依次在每个目录中，将 X 当成文件名或目录名加载。\n\n（\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e） 抛出 \x3cspan class=\x22hljs-string\x22\x3e\x22not found\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0sHG?w=479\x26amp;h=601\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0sHG?w=479\x26amp;h=601\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cbr\x3e\x3c\/p\x3e\n\x3cblockquote\x3e模块循环依赖\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/创建两个文件，module1.js 和 module2.js，并且让它们相互引用\n\/\/ module1.js\nexports.a = 1;\nrequire(\x27.\/module2\x27);\nexports.b = 2;\nexports.c = 3;\n\n\/\/ module2.js\nconst Module1 = require(\x27.\/module1\x27);\nconsole.log(\x27Module1 is partially loaded here\x27, Module1);\n\n\/\/执行 node module2.js 打印：Module1 is partially loaded here {a:1,b:2,c:3}\n\/\/执行 node module1.js 打印：Module1 is partially loaded here {a:1}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/创建两个文件，module1.js 和 module2.js，并且让它们相互引用\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ module1.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\nrequire(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/module2\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e.b = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e.c = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ module2.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Module1 = require(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/module1\x27\x3c\/span\x3e);\nconsole.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Module1 is partially loaded here\x27\x3c\/span\x3e, Module1);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/执行 node module2.js 打印：Module1 is partially loaded here {a:1,b:2,c:3}\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/执行 node module1.js 打印：Module1 is partially loaded here {a:1}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 module1 完全加载之前需要先加载 module2，而 module2 的加载又需要 module1。这种状态下，我们从 exports 对象中能得到的就是在发生循环依赖之前的这部分。上面代码中，只有 a 属性被引入，因为 b 和 c 都需要在引入 module2 之后才能加载进来。\x3c\/p\x3e\n\x3cp\x3eNode 使这个问题简单化，在一个模块加载期间开始创建 exports 对象。如果它需要引入其他模块，并且有循环依赖，那么只能部分引入，也就是只能引入发生循环依赖之前所定义的这部分。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eAMD\x3c\/h3\x3e\n\x3cp\x3eAMD 是 Asynchronous Module Definition 的简称，即“异步模块定义”，是从 CommonJS 讨论中诞生的。AMD 优先照顾浏览器的模块加载场景，使用了异步加载和回调的方式。  \x3c\/p\x3e\n\x3cp\x3eAMD 和 CommonJS 一样需要脚本加载器，尽管 AMD 只需要对 define 方法的支持。define 方法需要三个参数：模块名称，模块运行的依赖数组，所有依赖都可用之后执行的函数（该函数按照依赖声明的顺序，接收依赖作为参数）。只有函数参数是必须的。define 既是一种引用模块的方式，也是定义模块的方式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ file lib\/sayModule.js\ndefine(function (){\n    return {\n        sayHello: function () {\n            console.log(\x27hello\x27);\n        }\n    };\n});\n\n\/\/file main.js\ndefine([\x27.\/lib\/sayModule\x27], function (say){\n    say.sayHello(); \/\/hello\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ file lib\/sayModule.js\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3esayHello\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e);\n        }\n    };\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/file main.js\x3c\/span\x3e\ndefine([\x3cspan class=\x22hljs-string\x22\x3e\x27.\/lib\/sayModule\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3esay\x3c\/span\x3e)\x3c\/span\x3e{\n    say.sayHello(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/hello\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emain.js 作为整个应用的入口模块，我们使用 define 关键字声明了该模块以及外部依赖(没有生命模块名称)；当我们执行该模块代码时，也就是执行 define 函数的第二个参数中定义的函数功能，其会在框架将所有的其他依赖模块加载完毕后被执行。这种延迟代码执行的技术也就保证了依赖的并发加载。\x3c\/p\x3e\n\x3ch4\x3e\x3ccode\x3eRequireJS\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3eRequireJS 是一个前端的模块化管理的工具库，遵循AMD规范,通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript data-main=\x27scripts\/main\x27 src=\x27scripts\/require.js\x27\x3e\x3c\/script\x3e\n\/\/scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata-main\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27scripts\/main\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27scripts\/require.js\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\/\/scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edefined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。  \x3cbr\x3e\x3cstrong\x3e1、独立模块 不依赖其他模块。直接定义\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define({\n    methodOne: function (){},\n    methodTwo: function (){}\n});\n\n\/\/等价于\n\ndefine(function (){\n    return {\n        methodOne: function (){},\n        methodTwo: function (){}\n    };\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3edefine({\n    methodOne: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{},\n    methodTwo: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/等价于\x3c\/span\x3e\n\ndefine(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        methodOne: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{},\n        methodTwo: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}\n    };\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e2、非独立模块，对其他模块有依赖\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define([ \x27moduleOne\x27, \x27moduleTwo\x27 ], function(mOne, mTwo){\n    ...\n});\n\n\/\/或者\n\ndefine( function( require ){\n    var mOne = require( \x27moduleOne\x27 ),\n        mTwo = require( \x27moduleTwo\x27 );\n    ...\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3edefine([ \x3cspan class=\x22hljs-string\x22\x3e\x27moduleOne\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27moduleTwo\x27\x3c\/span\x3e ], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emOne, mTwo\x3c\/span\x3e)\x3c\/span\x3e{\n    ...\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/或者\x3c\/span\x3e\n\ndefine( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e require \x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mOne = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e( \x3cspan class=\x22hljs-string\x22\x3e\x27moduleOne\x27\x3c\/span\x3e ),\n        mTwo = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e( \x3cspan class=\x22hljs-string\x22\x3e\x27moduleTwo\x27\x3c\/span\x3e );\n    ...\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上代码， define中有依赖模块数组的 和 没有依赖模块数组用require加载 这两种定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eCMD\x3c\/h3\x3e\n\x3cp\x3eCMD（Common Module Definition），在CMD中，一个模块就是一个文件。  \x3c\/p\x3e\n\x3cp\x3e全局函数define，用来定义模块。  \x3cbr\x3e参数 factory  可以是一个函数，也可以为对象或者字符串。  \x3cbr\x3e当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。  \x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e定义JSON数据模块：\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define({ \x26quot;foo\x26quot;: \x26quot;bar\x26quot; });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edefine\x3c\/span\x3e\x3c\/span\x3e({ \x3cspan class=\x22hljs-string\x22\x3e\x22foo\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3efactory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define( function(require, exports, module) { \n    \/\/ 模块代码\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs oxygene\x22\x3e\x3ccode\x3edefine( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e, exports, \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e)\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{ \n    \/\/ 模块代码\n}\x3c\/span\x3e);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3ccode\x3eSeaJS\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3esea.js 核心特征：\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e遵循CMD规范，与NodeJS般的书写模块代码。\x3c\/li\x3e\n\x3cli\x3e依赖自动加载，配置清晰简洁。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3eseajs.use\x3c\/code\x3e用来在页面中加载一个或者多个模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n \/\/ 加载一个模块 \nseajs.use(\x27.\/a\x27);\n\n\/\/ 加载模块，加载完成时执行回调\nseajs.use(\x27.\/a\x27，function(a){\n    a.doSomething();\n});\n\n\/\/ 加载多个模块执行回调\nseajs.use([\x27.\/a\x27,\x27.\/b\x27]，function(a , b){\n    a.doSomething();\n    b.doSomething();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载一个模块 \x3c\/span\x3e\nseajs.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/a\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载模块，加载完成时执行回调\x3c\/span\x3e\nseajs.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/a\x27\x3c\/span\x3e，\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a)\x3c\/span\x3e\x3c\/span\x3e{\n    a.doSomething();\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载多个模块执行回调\x3c\/span\x3e\nseajs.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27.\/a\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27.\/b\x27\x3c\/span\x3e]，\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a , b)\x3c\/span\x3e\x3c\/span\x3e{\n    a.doSomething();\n    b.doSomething();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3ccode\x3eAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。\x3c\/code\x3e  \x3cbr\x3e很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。  \x3cp\x3e\x3ccode\x3e为什么说是执行时机处理不同？\x3c\/code\x3e  \x3cbr\x3e同样都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。  \x3cbr\x3eCMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eUMD\x3c\/h3\x3e\n\x3cp\x3e统一模块定义（UMD：Universal Module Definition ）就是将 AMD 和 CommonJS 合在一起的一种尝试，常见的做法是将CommonJS 语法包裹在兼容 AMD 的代码中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(define) {\n    define(function () {\n        return {\n            sayHello: function () {\n                console.log(\x27hello\x27);\n            }\n        };\n    });\n}(\n    typeof module === \x27object\x27 \x26amp;\x26amp; module.exports \x26amp;\x26amp; typeof define !== \x27function\x27 ?\n    function (factory) { module.exports = factory(); } :\n    define\n));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edefine\x3c\/span\x3e) \x3c\/span\x3e{\n    define(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3esayHello\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e);\n            }\n        };\n    });\n}(\n    \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e define !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ?\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efactory\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = factory(); } :\n    define\n));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该模式的核心思想在于所谓的 IIFE（Immediately Invoked Function Expression），该函数会根据环境来判断需要的参数类别\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eES6模块(module)\x3c\/h3\x3e\n\x3ch4\x3e严格模式\x26nbsp;\x3c\/h4\x3e\n\x3cp\x3eES6 的模块自动采用严格模式，不管有没有在模块头部加上\x22use strict\x22;。  \x3cbr\x3e严格模式主要有以下限制。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e变量必须声明后再使用\x3c\/li\x3e\n\x3cli\x3e函数的参数不能有同名属性，否则报错\x3c\/li\x3e\n\x3cli\x3e不能使用with语句\x3c\/li\x3e\n\x3cli\x3e不能对只读属性赋值，否则报错\x3c\/li\x3e\n\x3cli\x3e不能使用前缀0表示八进制数，否则报错\x3c\/li\x3e\n\x3cli\x3e不能删除不可删除的属性，否则报错\x3c\/li\x3e\n\x3cli\x3e不能删除变量delete prop，会报错，只能删除属性delete global[prop]\x3c\/li\x3e\n\x3cli\x3eeval不会在它的外层作用域引入变量\x3c\/li\x3e\n\x3cli\x3eeval和arguments不能被重新赋值\x3c\/li\x3e\n\x3cli\x3earguments不会自动反映函数参数的变化\x3c\/li\x3e\n\x3cli\x3e不能使用arguments.callee\x3c\/li\x3e\n\x3cli\x3e不能使用arguments.caller\x3c\/li\x3e\n\x3cli\x3e禁止this指向全局对象\x3c\/li\x3e\n\x3cli\x3e不能使用fn.caller和fn.arguments获取函数调用的堆栈\x3c\/li\x3e\n\x3cli\x3e增加了保留字（比如protected、static和interface）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e模块Module\x3c\/h4\x3e\n\x3cp\x3e一个模块，就是一个对其他模块暴露自己的属性或者方法的文件。\x3c\/p\x3e\n\x3ch4\x3e导出Export\x3c\/h4\x3e\n\x3cp\x3e作为一个模块，它可以选择性地给其他模块暴露（提供）自己的属性和方法，供其他模块使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ profile.js\nexport var firstName = \x27qiqi\x27;\nexport var lastName = \x27haobenben\x27;\nexport var year = 1992;\n\n\/\/等价于\n\nvar firstName = \x27qiqi\x27;\nvar lastName = \x27haobenben\x27;\nvar year = 1992;\nexport {firstName, lastName, year}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ profile.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e firstName = \x3cspan class=\x22hljs-string\x22\x3e\x27qiqi\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e lastName = \x3cspan class=\x22hljs-string\x22\x3e\x27haobenben\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e year = \x3cspan class=\x22hljs-number\x22\x3e1992\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/等价于\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e firstName = \x3cspan class=\x22hljs-string\x22\x3e\x27qiqi\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e lastName = \x3cspan class=\x22hljs-string\x22\x3e\x27haobenben\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e year = \x3cspan class=\x22hljs-number\x22\x3e1992\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e {firstName, lastName, year}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e1、 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n\n\/\/上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ev1\x3c\/span\x3e() { ... }\n\x3cspan class=\x22hljs-symbol\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e() { ... }\n\n\x3cspan class=\x22hljs-symbol\x22\x3eexport\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3ev1\x3c\/span\x3e as \x3cspan class=\x22hljs-keyword\x22\x3estreamV1,\n\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e as \x3cspan class=\x22hljs-keyword\x22\x3estreamV2,\n\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e as \x3cspan class=\x22hljs-keyword\x22\x3estreamLatestVersion\n\x3c\/span\x3e}\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\/\/上面代码使用as关键字，重命名了函数\x3cspan class=\x22hljs-built_in\x22\x3ev1\x3c\/span\x3e和\x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e的对外接口。重命名后，\x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e可以用不同的名字输出两次。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e2、 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 报错\nexport 1;\n\n\/\/ 报错\nvar m = 1;\nexport m;\n\n\/\/上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。\n\n\/ 写法一\nexport var m = 1;\n\n\/\/ 写法二\nvar m = 1;\nexport {m};\n\n\/\/ 写法三\nvar n = 1;\nexport {n as m};\n\n\/\/上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e m;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。\x3c\/span\x3e\n\n\/ 写法一\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 写法二\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e {m};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 写法三\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e {n \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e m};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e3、最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，接下来说的import命令也是如此。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n  export default \x27bar\x27 \/\/ SyntaxError\n}\nfoo()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ SyntaxError\x3c\/span\x3e\n}\nfoo()\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e导入import\x3c\/h4\x3e\n\x3cp\x3e作为一个模块，可以根据需要，引入其他模块的提供的属性或者方法，供自己模块使用。  \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e1、 import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { lastName as surename } from \x27.\/profile\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { lastName \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e surename } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/profile\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e2、import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\x3c\/code\x3e  \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e3、注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22foo();\n\nimport { foo } from \x27my_module\x27;\n\n\/\/上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3efoo();\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { foo } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e上面的代码不会报错，因为\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e的执行早于foo的调用。这种行为的本质是，\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e命令是编译阶段执行的，在代码运行之前。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e4、由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/ 报错\nimport { \x27f\x27 \x2b \x27oo\x27 } from \x27my_module\x27;\n\n\/\/ 报错\nlet module = \x27my_module\x27;\nimport { foo } from module;\n\n\/\/ 报错\nif (x === 1) {\n  import { foo } from \x27module1\x27;\n} else {\n  import { foo } from \x27module2\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\/ 报错\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { \x3cspan class=\x22hljs-string\x22\x3e\x27f\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27oo\x27\x3c\/span\x3e } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { foo } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (x === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { foo } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27module1\x27\x3c\/span\x3e;\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { foo } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27module2\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e5、最后，import语句会执行所加载的模块，因此可以有下面的写法。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import \x27lodash\x27;\n\/\/上面代码仅仅执行lodash模块，但是不输入任何值。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x3cspan class=\x22hljs-meta-keyword\x22\x3eimport\x3c\/span\x3e \x27lodash\x27;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/上面代码仅仅执行lodash模块，但是不输入任何值。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e默认导出(export default)\x3c\/h3\x3e\n\x3cp\x3e每个模块支持我们导出\x3ccode\x3e一个\x3c\/code\x3e没有名字的变量，使用关键语句export default来实现.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function(){\n    \x26nbsp;\x26nbsp; \x26nbsp; \x26nbsp;\x26nbsp; console.log(\x26quot;I am default Fn\x26quot;);\n     \x26nbsp; \x26nbsp;}\n\/\/使用export default关键字对外导出一个匿名函数，导入这个模块的时候，可以为这个匿名函数取任意的名字\n\n\/\/取任意名字均可\nimport sayDefault from \x26quot;.\/module-B.js\x26quot;;\nsayDefault();\n\/\/结果：I am default Fn\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x26nbsp;\x26nbsp; \x26nbsp; \x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I am default Fn\x22\x3c\/span\x3e);\n     \x26nbsp; \x26nbsp;}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用export default关键字对外导出一个匿名函数，导入这个模块的时候，可以为这个匿名函数取任意的名字\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/取任意名字均可\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e sayDefault \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/module-B.js\x22\x3c\/span\x3e;\nsayDefault();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/结果：I am default Fn\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e1、默认输出和正常输出的比较\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 第一组\nexport default function diff() { \/\/ 输出\n  \/\/ ...\n}\n\nimport diff from \x27diff\x27; \/\/ 输入\n\n\/\/ 第二组\nexport function diff() { \/\/ 输出\n  \/\/ ...\n};\n\nimport {diff} from \x27diff\x27; \/\/ 输入\n\n\/\/上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediff\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e diff \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27diff\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输入\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediff\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {diff} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27diff\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输入\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3eexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cbr\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e2、因为export default本质是将该命令后面的值，赋给default变量以后再默认，所以直接将一个值写在export default之后。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/ 正确\nexport default 42;\n\n\/\/ 报错\nexport 42;\n\n\/\/上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\/ 正确\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e3、如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import _, { each } from \x27lodash\x27;\n\n\/\/对应上面代码的export语句如下\nexport default function (){\n    \/\/...\n}\nexport function each (obj, iterator, context){\n    \/\/...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e _, { each } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27lodash\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/对应上面代码的export语句如下\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eeach\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, iterator, context\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eexport 与 import 的复合写法\x3c\/h3\x3e\n\x3cp\x3e如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export { foo, bar } from \x27my_module\x27;\n\n\/\/ 等同于\nimport { foo, bar } from \x27my_module\x27;\nexport { foo, bar };\n\n\/ 接口改名\nexport { foo as myFoo } from \x27my_module\x27;\n\n\/\/ 整体输出\nexport * from \x27my_module\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e { foo, bar } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等同于\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { foo, bar } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e { foo, bar };\n\n\/ 接口改名\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e { foo \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e myFoo } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 整体输出\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e * \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27my_module\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e注意事项  \x3cbr\x3e1、声明的变量，对外都是只读的。但是导出的是对象类型的值，就可修改。  \x3cbr\x3e2、导入不存在的变量，值为undefined。\x3c\/blockquote\x3e\n\x3ch4\x3eES6 中的循环引用\x3c\/h4\x3e\n\x3cp\x3eES6 中，imports 是 exports 的只读视图，直白一点就是，imports 都指向 exports 原本的数据，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/------ lib.js ------\nexport let counter = 3;\nexport function incCounter() {\n    counter\x2b\x2b;\n}\n\n\/\/------ main.js ------\nimport { counter, incCounter } from \x27.\/lib\x27;\n\n\/\/ The imported value `counter` is live\nconsole.log(counter); \/\/ 3\nincCounter();\nconsole.log(counter); \/\/ 4\n\n\/\/ The imported value can’t be changed\ncounter\x2b\x2b; \/\/ TypeError\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/------ lib.js ------\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eincCounter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    counter\x2b\x2b;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/------ main.js ------\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { counter, incCounter } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/lib\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The imported value `counter` is live\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\nincCounter();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The imported value can’t be changed\x3c\/span\x3e\ncounter\x2b\x2b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此在 ES6 中处理循环引用特别简单，看下面这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/------ a.js ------\nimport {bar} from \x27b\x27; \/\/ (1)\nexport function foo() {\n  bar(); \/\/ (2)\n}\n\n\/\/------ b.js ------\nimport {foo} from \x27a\x27; \/\/ (3)\nexport function bar() {\n  if (Math.random()) {\n    foo(); \/\/ (4)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/------ a.js ------\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {bar} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (1)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  bar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (2)\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/------ b.js ------\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {foo} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (3)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random()) {\n    foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (4)\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假设先加载模块 a，在模块 a 加载完成之后，bar 间接性地指向的是模块 b 中的 bar。无论是加载完成的 imports 还是未完成的 imports，imports 和 exports 之间都有一个间接的联系，所以总是可以正常工作。\x3c\/p\x3e\n\x3ch4\x3e实例\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/---module-B.js文件---\n\/\/导出变量：name\nexport var name = \x26quot;cfangxu\x26quot;;\n\nmoduleA模块代码：\n\/\/导入 模块B的属性 name \x26nbsp; \x26nbsp;\nimport { name } from \x26quot;.\/module-B.js\x26quot;;\x26nbsp; \x26nbsp;\nconsole.log(name)\n\/\/打印结果：cfangxu\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/---module-B.js文件---\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/导出变量：name\x3c\/span\x3e\nexport var \x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22cfangxu\x22\x3c\/span\x3e;\n\nmoduleA模块代码：\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/导入 模块B的属性 name \x26nbsp; \x26nbsp;\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e } from \x3cspan class=\x22hljs-string\x22\x3e\x22.\/module-B.js\x22\x3c\/span\x3e;\x26nbsp; \x26nbsp;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/打印结果：cfangxu\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e批量导出\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/属性name\nvar name = \x26quot;cfangxu\x26quot;;\n\/\/属性age\nvar age\x26nbsp; = 26;\n\/\/方法 say\nvar say = function(){\n     \x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; console.log(\x26quot;say hello\x26quot;);\n      \x26nbsp; \x26nbsp;}\n\/\/批量导出\nexport {name,age,say}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/属性name\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22cfangxu\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/属性age\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e age\x26nbsp; = \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/方法 say\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n     \x26nbsp; \x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22say hello\x22\x3c\/span\x3e);\n      \x26nbsp; \x26nbsp;}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/批量导出\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e {name,age,say}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e批量导入\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/导入 模块B的属性\nimport { name,age,say } from \x26quot;.\/module-B.js\x26quot;;\nconsole.log(name)\n\/\/打印结果：cfangxu\nconsole.log(age)\n\/\/打印结果：26\nsay()\n\/\/打印结果：say hello\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/导入 模块B的属性\x3c\/span\x3e\nimport { \x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e,age,\x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/module-B.js\x22\x3c\/span\x3e;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/打印结果：cfangxu\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(age)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/打印结果：26\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3esay\x3c\/span\x3e()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/打印结果：say hello\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e重命名导入变量\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {name as myName} from \x27.\/module-B.js\x27;\nconsole.log(myName) \/\/cfangxu\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {name \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e myName} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/module-B.js\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(myName) \x3cspan class=\x22hljs-comment\x22\x3e\/\/cfangxu\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e整体导入\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/使用*实现整体导入\nimport * as obj from \x26quot;.\/module-B.js\x26quot;;\n\nconsole.log(obj.name)\n\/\/结果：\x26quot;cfangxu\x26quot;\nconsole.log(obj.age)\n\/\/结果：26\nobj.say();\n\/\/结果：say hello\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xl\x22\x3e\x3ccode\x3e\/使用*实现整体导入\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e * \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e obj from \x3cspan class=\x22hljs-string\x22\x3e\x22.\/module-B.js\x22\x3c\/span\x3e;\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(obj.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/结果：\x22cfangxu\x22\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(obj.age)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/结果：26\x3c\/span\x3e\nobj.say();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/结果：say hello\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e推荐资料\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.chinaunix.net\/uid-26672038-id-4112229.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e JavaSript模块规范 - AMD规范与CMD规范介绍 \x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/mp.weixin.qq.com\/s?__biz=MjM5MTA1MjAxMQ==\x26amp;mid=2651226355\x26amp;idx=1\x26amp;sn=aedf47d5a3be53f6c7d5562977624861\x26amp;chksm=bd4959778a3ed06198cbb746067393cd0f189612f4fc577417e0741df3a2b620373ea025978b\x26amp;scene=21#wechat_redirect\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript 模块演化简史\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2015\/05\/require.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erequire() 源码解读\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009060866#articleHeader0\x22\x3e在 Node.js 中引入模块：你所需要知道的一切都在这里\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.infoq.com\/cn\/articles\/nodejs-module-mechanism#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e深入浅出Node.js（三）：深入Node.js的模块机制\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>很全很全的JavaScript的模块讲解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012464333">https://segmentfault.com/a/1190000012464333</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dgwlusfvb06/" target="_blank">https://alili.tech/archive/dgwlusfvb06/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>