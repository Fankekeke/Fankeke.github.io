<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="jsonp-反向代理-CORS解决JS跨域问题的个人总结"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>jsonp-反向代理-CORS解决JS跨域问题的个人总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/do07xw20cru/",
				"appid": "1613049289050283", 
				"title": "jsonp-反向代理-CORS解决JS跨域问题的个人总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-16T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8do23nye48i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/byjqaynyr9h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&text=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&text=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&title=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&is_video=false&description=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&title=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&title=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&title=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdo07xw20cru%2f&title=jsonp-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-CORS%e8%a7%a3%e5%86%b3JS%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e6%80%bb%e7%bb%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">jsonp-反向代理-CORS解决JS跨域问题的个人总结</h1><div class="meta"><div class="postdate"><time datetime="2018-12-16" itemprop="datePublished">2018-12-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ejsonp-反向代理-CORS解决JS跨域问题的个人总结\x3c\/h1\x3e\n\x3cblockquote\x3e网上说了很多很多，但是看完之后还是很混乱，所以我自己重新总结一下。\x3c\/blockquote\x3e\n\x3cp\x3e解决 js 跨域问题一共有8种方法，\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ejsonp（只支持 get）\x3c\/li\x3e\n\x3cli\x3e反向代理\x3c\/li\x3e\n\x3cli\x3eCORS\x3c\/li\x3e\n\x3cli\x3edocument.domain \x2b iframe 跨域\x3c\/li\x3e\n\x3cli\x3ewindow.name \x2b iframe 跨域\x3c\/li\x3e\n\x3cli\x3ewindow.postMessage\x3c\/li\x3e\n\x3cli\x3elocation.hash \x2b iframe\x3c\/li\x3e\n\x3cli\x3eweb sockets\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e各个方法都有各自的优缺点，但是目前前端开发方面比较常用的是 jsonp，反向代理，CORS：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。优点是正统，符合标准，缺点是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e但是需要服务器端配合，比较麻烦。\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eJSONP 优点是对旧式浏览器支持较好，缺点是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e但是只支持 get 请求。\x3c\/li\x3e\n\x3cli\x3e有安全问题(请求代码中可能存在安全隐患)。\x3c\/li\x3e\n\x3cli\x3e要确定jsonp请求是否失败并不容易\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e反向代理都能够兼容以上的确定，但是仅仅作为前端开发模式的时候使用，在正式上线环境较少用到。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e因为开发环境的域名跟线上环境不一样才需要这样处理。\x3c\/li\x3e\n\x3cli\x3e如果线上环境太复杂，本身也是多域（后面说到的同源策略问题，多子域，或者多端口问题），那么需要采用 jsonp 或者 CORS 来处理。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e这里主要说明这三种方式。其他方式暂不说明。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e一、什么是跨域问题\x3c\/h2\x3e\n\x3cp\x3e跨域问题一般只出现在前端开发中使用 javascript 进行网络请求的时候，浏览器为了安全访问网络请求的数据而进行的限制。\x3c\/p\x3e\n\x3cp\x3e提示的错误大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22No \x27Access-Control-Allow-Origin\x27 header is present on the requested resource. Origin \x27http:\/\/XXXXXX\x27 is therefore not allowed access.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eNo \x3cspan class=\x22hljs-string\x22\x3e\x27Access-Control-Allow-Origin\x27\x3c\/span\x3e header is present on the requested resource. Origin \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/XXXXXX\x27\x3c\/span\x3e is therefore not allowed access.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2zyk?w=979\x26amp;h=528\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2zyk?w=979\x26amp;h=528\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e二、为什么会出现跨域问题\x3c\/h2\x3e\n\x3cp\x3e因为浏览器收到同源策略的限制，当前域名的js只能读取同域下的窗口属性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2.1 同源策略\x3c\/h3\x3e\n\x3cp\x3e同源指的是三个源头同时相同：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e协议相同\x3c\/li\x3e\n\x3cli\x3e域名相同\x3c\/li\x3e\n\x3cli\x3e端口相同\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e举例来说，\x3ccode\x3ehttp:\/\/www.example.com\/dir\/page.html\x3c\/code\x3e这个网址，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22协议是 http:\/\/\n域名是 www.example.com\n端口是80 \n\n\/\/它的同源情况如下：\nhttp:\/\/www.example.com\/dir2\/other.html：同源\nhttp:\/\/example.com\/dir\/other.html：不同源（域名不同）\nhttp:\/\/v2.www.example.com\/dir\/other.html：不同源（域名不同）\nhttp:\/\/www.example.com:81\/dir\/other.html：不同源（端口不同）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e协议是 http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x3c\/span\x3e\n域名是 www.example.com\n端口是\x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e \n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/它的同源情况如下：\x3c\/span\x3e\nhttp:\x3cspan class=\x22hljs-comment\x22\x3e\/\/www.example.com\/dir2\/other.html：同源\x3c\/span\x3e\nhttp:\x3cspan class=\x22hljs-comment\x22\x3e\/\/example.com\/dir\/other.html：不同源（域名不同）\x3c\/span\x3e\nhttp:\x3cspan class=\x22hljs-comment\x22\x3e\/\/v2.www.example.com\/dir\/other.html：不同源（域名不同）\x3c\/span\x3e\nhttp:\x3cspan class=\x22hljs-comment\x22\x3e\/\/www.example.com:81\/dir\/other.html：不同源（端口不同）\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同源策略限制了以下行为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCookie、LocalStorage 和 IndexDB 无法读取\x3c\/li\x3e\n\x3cli\x3eDOM 和 JS 对象无法获取\x3c\/li\x3e\n\x3cli\x3eAjax请求发送不出去\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e大概可以知道跨域其实就是同源策略导致的，并且知道同源策略的原理。\x3c\/blockquote\x3e\n\x3cp\x3e详细的同源策略相关，可以参考\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/same-origin-policy.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ruanyifeng.com\/blog\/2016\/04\/same-origin-policy.html\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e三、解决跨域问题\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e3.1 反向代理方式\x3c\/h3\x3e\n\x3cp\x3e反向代理和正向代理的区别：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e正向代理（Forward Proxy），通常都被简称为代理，就是在用户无法正常访问外部资源，比方说受到GFW的影响无法访问twitter的时候，我们可以通过代理的方式，让用户绕过防火墙，从而连接到目标网络或者服务。\x3c\/li\x3e\n\x3cli\x3e反向代理（Reverse Proxy）是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 请求连接的客户端，此时，代理服务器对外就表现为一个服务器。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那么我们可以理解为反向代理\x3c\/p\x3e\n\x3cp\x3e如何使用反向代理服务器来达到跨域问题解决：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e前端ajax请求的是本地反向代理服务器\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e本地反向代理服务器接收到后：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e修改请求的 http-header 信息，例如 referer，host，端口等\x3c\/li\x3e\n\x3cli\x3e修改后将请求发送到实际的服务器\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e实际的服务器会以为是同源（参考同源策略）的请求而作出处理\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e现在前端开发一般使用 nodejs来做本地反向代理服务器\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 在 express 之后引入路由\nvar app = express();\n\nvar apiRoutes = express.Router();\n\napp.use(bodyParser.urlencoded({extended:false}))\n\n\/\/ 自定义 api 路由\napiRoutes.get(\x26quot;\/lyric\x26quot;, function (req, res) {\n  var url = \x26quot;https:\/\/c.y.qq.com\/lyric\/fcgi-bin\/fcg_query_lyric_new.fcg\x26quot;;\n\n  axios.get(url, {\n    headers: { \/\/ 修改 header\n      referer: \x26quot;https:\/\/c.y.qq.com\/\x26quot;,\n      host: \x26quot;c.y.qq.com\x26quot;\n    },\n    params: req.query\n  }).then((response) =\x3e {\n    var ret = response.data\n    if (typeof ret === \x26quot;string\x26quot;) {\n      var reg = \/^\\w\x2b\\(({[^()]\x2b})\\)$\/;\n      var matches = ret.match(reg);\n      if (matches) {\n        ret = JSON.parse(matches[1])\n      }\n    }\n    res.json(ret)\n  }).catch((e) =\x3e {\n    console.log(e)\n  })\n});\n\n\/\/ 使用这个路由\napp.use(\x26quot;\/api\x26quot;, apiRoutes);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 express 之后引入路由\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e app = express();\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e apiRoutes = express.Router();\n\napp.use(bodyParser.urlencoded({\x3cspan class=\x22hljs-attr\x22\x3eextended\x3c\/span\x3e:\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e}))\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义 api 路由\x3c\/span\x3e\napiRoutes.get(\x3cspan class=\x22hljs-string\x22\x3e\x22\/lyric\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/c.y.qq.com\/lyric\/fcgi-bin\/fcg_query_lyric_new.fcg\x22\x3c\/span\x3e;\n\n  axios.get(url, {\n    \x3cspan class=\x22hljs-attr\x22\x3eheaders\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改 header\x3c\/span\x3e\n      referer: \x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/c.y.qq.com\/\x22\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ehost\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22c.y.qq.com\x22\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eparams\x3c\/span\x3e: req.query\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = response.data\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e ret === \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/^\\w\x2b\\(({[^()]\x2b})\\)$\/\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e matches = ret.match(reg);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (matches) {\n        ret = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(matches[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e])\n      }\n    }\n    res.json(ret)\n  }).catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e)\n  })\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用这个路由\x3c\/span\x3e\napp.use(\x3cspan class=\x22hljs-string\x22\x3e\x22\/api\x22\x3c\/span\x3e, apiRoutes);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e3.2 JSONP 方式\x3c\/h3\x3e\n\x3cp\x3eJSONP有些文章会叫动态创建script，因为他确实是动态写入 script 标签的内容从而达到跨域的效果：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eAJAX 无法跨域是受到“同源政策”的限制，但是带有src属性的标签（例如\x3ccode\x3e\x26lt;script\x26gt;、\x26lt;img\x26gt;、\x26lt;iframe\x26gt;\x3c\/code\x3e）是不受该政策限制的，因此我们可以通过向页面中动态添加\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e标签来完成对跨域资源的访问，这也是 JSONP 方案最核心的原理，换句话理解，就是利用了【前端请求静态资源的时候不存在跨域问题】这个思路。\x3c\/li\x3e\n\x3cli\x3eJSONP（JSON with Padding）是数据格式JSON的一种“使用模式”。\x3c\/li\x3e\n\x3cli\x3eJSONP 只能用 get 方式。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实现 jsonp 的方式：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2zyp?w=800\x26amp;h=622\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2zyp?w=800\x26amp;h=622\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e引用来自\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000012469713\x22\x3ehttps:\/\/segmentfault.com\/a\/1190000012469713\x3c\/a\x3e的图\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e客户端和服务器端约定一个参数名是代表 jsonp 请求的，例如约定 callback 这个参数名。\x3c\/li\x3e\n\x3cli\x3e然后服务器端准备好针对之前约定的 callback 参数请求的 javascript 文件，这个文件里面要有一个函数名，要跟客户端请求的时候的函数名要保持一致。（如下面例子：\x3ccode\x3eip.js\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3e然后客户端注册一个本地运行的函数,并且函数的名字要跟去请求服务器进行 callback 回调的函数的名字要一致。（如下面例子：foo 函数跟请求时候\x3ccode\x3ecallback=foo\x3c\/code\x3e的名字是一致的）\x3c\/li\x3e\n\x3cli\x3e然后客户端对服务器端进行 \x3ccode\x3ejsonp 的方式\x3c\/code\x3e请求。\x3c\/li\x3e\n\x3cli\x3e服务器端返回刚才配置好的js 文件（\x3ccode\x3eip.js\x3c\/code\x3e）到客户端\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e客户端浏览器，解析script标签，并执行返回的javascript文件，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e相当于本地执行注册好foo 函数，然后获取了一个foo 函数，并且这个获取的 foo 函数里面包含了传入的参数（例如 \x3ccode\x3efoo({XXXXX})\x3c\/code\x3e）\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这是一个实例 demo：\x3c\/p\x3e\n\x3cp\x3e服务器端文件\x3ccode\x3eip.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22foo({\n  \x26quot;ip\x26quot;: \x26quot;8.8.8.8\x26quot;\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3efoo({\n  \x3cspan class=\x22hljs-string\x22\x3e\x22ip\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x228.8.8.8\x22\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e客户端文件 \x3ccode\x3ejsonp.html\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!DOCTYPE html PUBLIC \x26quot;-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\x26quot; \x26quot;http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\x26quot;\x3e\n\x3chtml xmlns=\x26quot;http:\/\/www.w3.org\/1999\/xhtml\x26quot;\x3e\n\x3chead\x3e\n    \x3ctitle\x3e\x3c\/title\x3e\n    \x3cscript\x3e\n        \/\/ 动态插入 script 标签到 html 中\n        function addScriptTag(src) {\n          var script = document.createElement(\x27script\x27);\n          script.setAttribute(\x26quot;type\x26quot;,\x26quot;text\/javascript\x26quot;);\n          script.src = src;\n          document.body.appendChild(script);\n        }\n        \/\/ 获取 jsonp 文件\n        window.onload = function () {\n          addScriptTag(\x27http:\/\/example.com\/ip?callback=foo\x27);\n        }\n        \/\/ 执行本地的 js 逻辑，这个要跟获取到的 jsonp 文件的函数要一致\n        function foo(data) {\n          console.log(\x27Your public IP address is: \x27 \x2b data.ip);\n        };\n    \x3c\/script\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;!DOCTYPE html PUBLIC \x3cspan class=\x22hljs-string\x22\x3e\x22-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\x22\x3c\/span\x3e\x26gt;\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3exmlns\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.w3.org\/1999\/xhtml\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 动态插入 script 标签到 html 中\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddScriptTag\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esrc\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e script = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27script\x27\x3c\/span\x3e);\n          script.setAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x22type\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e);\n          script.src = src;\n          \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(script);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取 jsonp 文件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          addScriptTag(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/example.com\/ip?callback=foo\x27\x3c\/span\x3e);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行本地的 js 逻辑，这个要跟获取到的 jsonp 文件的函数要一致\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Your public IP address is: \x27\x3c\/span\x3e \x2b data.ip);\n        };\n    \x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e3.3 CORS 方式\x3c\/h3\x3e\n\x3cp\x3eCORS是一个W3C标准，全称是\x22跨域资源共享\x22（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e请求，从而克服了AJAX只能同源使用的限制。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\x3c\/li\x3e\n\x3cli\x3e整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。\x3cstrong\x3e浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e因此，实现CORS通信的关键是服务器端。只要服务器端实现了CORS接口，就可以跨源通信。\x3c\/blockquote\x3e\n\x3ch4\x3e3.3.1 CORS的请求分为两类：\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e简单请求\x3c\/li\x3e\n\x3cli\x3e非简单请求\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e只要同时满足以下两大条件，就属于简单请求。\x3c\/p\x3e\n\x3cp\x3e（1) 请求方法是以下三种方法之一：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eHEAD\x3c\/li\x3e\n\x3cli\x3eGET\x3c\/li\x3e\n\x3cli\x3ePOST\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e（2）HTTP的头信息不超出以下几种字段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eAccept\x3c\/li\x3e\n\x3cli\x3eAccept-Language\x3c\/li\x3e\n\x3cli\x3eContent-Language\x3c\/li\x3e\n\x3cli\x3eLast-Event-ID\x3c\/li\x3e\n\x3cli\x3eContent-Type：只限于三个值application\/x-www-form-urlencoded、multipart\/form-data、text\/plain\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e凡是不同时满足上面两个条件，就属于非简单请求。\x3c\/p\x3e\n\x3ch4\x3e3.3.2 简单请求\x3c\/h4\x3e\n\x3cp\x3e如果是简单请求的话，会自动在头信息之中，添加一个Origin字段\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22GET \/cors HTTP\/1.1\nOrigin: http:\/\/api.bob.com \nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/5.0...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eGET \/cors HTTP\/\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e\nOrigin: http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/api.bob.com \x3c\/span\x3e\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/\x3cspan class=\x22hljs-number\x22\x3e5.0\x3c\/span\x3e...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个Origin对应服务器端的\x3ccode\x3eAccess-Control-Allow-Origin\x3c\/code\x3e设置，所以一般来说需要在服务器端加上这个\x3ccode\x3eAccess-Control-Allow-Origin 指定域名|*\x3c\/code\x3e\x3c\/p\x3e\n\x3ch4\x3e3.3.3 非简单请求\x3c\/h4\x3e\n\x3cp\x3e如果是非简单请求的话，会在正式通信之前，增加一次HTTP查询请求，称为\x22预检\x22请求（preflight）。\x3c\/p\x3e\n\x3cp\x3e浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\x3c\/p\x3e\n\x3cblockquote\x3e需要注意这里是会发送2次请求，第一次是预检请求，第二次才是真正的请求！\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e首先发出预检请求：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 预检请求\nOPTIONS \/cors HTTP\/1.1\nOrigin: http:\/\/api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/5.0..\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 预检请求\x3c\/span\x3e\nOPTIONS \/cors HTTP\/\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e\nOrigin: http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/api.bob.com\x3c\/span\x3e\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/\x3cspan class=\x22hljs-number\x22\x3e5.0\x3c\/span\x3e..\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了Origin字段，\x22预检\x22请求的头信息包括两个特殊字段。\x3c\/p\x3e\n\x3cp\x3e（1）\x3ccode\x3eAccess-Control-Request-Method\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\x3c\/p\x3e\n\x3cp\x3e（2）\x3ccode\x3eAccess-Control-Request-Headers\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e然后服务器收到\x22预检\x22请求以后：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e检查了\x3ccode\x3eOrigin\x3c\/code\x3e、\x3ccode\x3eAccess-Control-Request-Method\x3c\/code\x3e和\x3ccode\x3eAccess-Control-Request-Headers\x3c\/code\x3e字段以后，确认允许跨源请求，就可以做出回应。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 预检请求的回应\nHTTP\/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache\/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http:\/\/api.bob.com\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text\/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text\/plain\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 预检请求的回应\x3c\/span\x3e\nHTTP\/\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e OK\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e: Mon, \x3cspan class=\x22hljs-number\x22\x3e01\x3c\/span\x3e Dec \x3cspan class=\x22hljs-number\x22\x3e2008\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e01\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e39\x3c\/span\x3e GMT\nServer: Apache\/\x3cspan class=\x22hljs-number\x22\x3e2.0\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.61\x3c\/span\x3e (Unix)\nAccess-Control-Allow-Origin: http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/api.bob.com\x3c\/span\x3e\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text\/html; charset=utf\x3cspan class=\x22hljs-number\x22\x3e-8\x3c\/span\x3e\nContent-Encoding: gzip\nContent-Length: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nKeep-Alive: timeout=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, max=\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\nConnection: Keep-Alive\nContent-Type: text\/plain\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e最后一旦服务器通过了\x22预检\x22请求：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 以后的请求，就像拿到了通行证之后，就不需要再做预检请求了。\nPUT \/cors HTTP\/1.1\nOrigin: http:\/\/api.bob.com\nHost: api.alice.com\nX-Custom-Header: value\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/5.0...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以后的请求，就像拿到了通行证之后，就不需要再做预检请求了。\x3c\/span\x3e\nPUT \/cors HTTP\/\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e\nOrigin: http:\x3cspan class=\x22hljs-comment\x22\x3e\/\/api.bob.com\x3c\/span\x3e\nHost: api.alice.com\nX-Custom-Header: value\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla\/\x3cspan class=\x22hljs-number\x22\x3e5.0\x3c\/span\x3e...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e详情参考这里\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/cors.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ruanyifeng.com\/blog\/2016\/04\/cors.html\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e参考文档：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/web.jobbole.com\/88524\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端解决跨域问题的8种方案\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/same-origin-policy.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浏览器同源政策及其规避方法\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/tonghuashuo.github.io\/blog\/jsonp.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/tonghuashuo.github.io\/blog\/jsonp.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/yuzhongwusan\/archive\/2012\/12\/11\/2812849.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cnblogs.com\/yuzhongwusan\/archive\/2012\/12\/11\/2812849.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/dowinning\/archive\/2012\/04\/19\/json-jsonp-jquery.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cnblogs.com\/dowinning\/archive\/2012\/04\/19\/json-jsonp-jquery.html\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000002438126\x22\x3ehttps:\/\/segmentfault.com\/a\/1190000002438126\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>jsonp-反向代理-CORS解决JS跨域问题的个人总结</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012967320">https://segmentfault.com/a/1190000012967320</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/do07xw20cru/" target="_blank">https://alili.tech/archive/do07xw20cru/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>