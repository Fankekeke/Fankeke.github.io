<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webpack实战"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webpack实战 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dwajbk6ehhh/",
				"appid": "1613049289050283", 
				"title": "webpack实战 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-11-29T09:34:56"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/37kkml4eopd/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7ccqwambt8d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&text=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&text=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&title=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&is_video=false&description=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webpack%e5%ae%9e%e6%88%98&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&title=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&title=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&title=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdwajbk6ehhh%2f&title=webpack%e5%ae%9e%e6%88%98"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webpack实战</h1><div class="meta"><div class="postdate"><time datetime="2018-11-29" itemprop="datePublished">2018-11-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ewebpack实战\x3c\/h1\x3e\n\x3cblockquote\x3e查看所有文档页面：\x3ca href=\x22https:\/\/whjin.github.io\/full-stack-development\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e全栈开发\x3c\/a\x3e，获取更多信息。\x3cp\x3e快马加鞭，加班加点，终于把这个文档整理出来了，顺便深入地学习一番，巩固知识，就是太累人，影响睡眠时间和质量。极客就是想要把事情做到极致，开始了就必须到达终点。\x3c\/p\x3e\n\x3cp\x3e原文链接：\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3%E5%AE%9E%E6%88%98\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack实战\x3c\/a\x3e，原文广告模态框遮挡，阅读体验不好，所以整理成本文，方便查找。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e本章教你如何用 Webpack 去解决实际项目中常见的场景。\x3c\/p\x3e\n\x3cp\x3e按照不同场景划分成以下几类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e使用新语言来开发项目：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 ES6 语言\x3c\/li\x3e\n\x3cli\x3e使用 TypeScript 语言\x3c\/li\x3e\n\x3cli\x3e使用 Flow 检查器\x3c\/li\x3e\n\x3cli\x3e使用 SCSS 语言\x3c\/li\x3e\n\x3cli\x3e使用 PostCSS\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e使用新框架来开发项目：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 React 框架\x3c\/li\x3e\n\x3cli\x3e使用 Vue 框架\x3c\/li\x3e\n\x3cli\x3e使用 Angular2 框架\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e用 Webpack 构建单页应用：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e为单页应用生成 HTML\x3c\/li\x3e\n\x3cli\x3e管理多个单页应用\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e用 Webpack 构建不同运行环境的项目：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e构建同构应用\x3c\/li\x3e\n\x3cli\x3e构建 Electron 应用\x3c\/li\x3e\n\x3cli\x3e构建 Npm 模块\x3c\/li\x3e\n\x3cli\x3e构建离线应用\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eWebpack 结合其它工具搭配使用，各取所长：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e搭配 Npm Script\x3c\/li\x3e\n\x3cli\x3e检查代码\x3c\/li\x3e\n\x3cli\x3e通过 Node.js API 启动 Webpack\x3c\/li\x3e\n\x3cli\x3e使用 Webpack Dev Middleware\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e用 Webpack 加载特殊类型的资源：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e加载图片\x3c\/li\x3e\n\x3cli\x3e加载SVG\x3c\/li\x3e\n\x3cli\x3e加载 Source Map\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e使用 TypeScript 语言\x3c\/h2\x3e\n\x3cp\x3e由于本文不推荐使用TypeScript，ES6就足够完成大部分任务。原文链接：\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3%E5%AE%9E%E6%88%98\/3-2%E4%BD%BF%E7%94%A8TypeScript%E8%AF%AD%E8%A8%80.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用 TypeScript 语言\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e使用 Angular2 框架\x3c\/h2\x3e\n\x3cp\x3eAngular2不在我的技术栈范围，所以这一章不加入，有兴趣的查看原文：\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3%E5%AE%9E%E6%88%98\/3-8%E4%BD%BF%E7%94%A8Angular2%E6%A1%86%E6%9E%B6.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用 Angular2 框架\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e使用ES6语言\x3c\/h1\x3e\n\x3cp\x3e通常我们需要把采用 ES6 编写的代码转换成目前已经支持良好的 ES5 代码，这包含2件事：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e把新的 ES6 语法用 ES5 实现，例如 ES6 的 \x3ccode\x3eclass\x3c\/code\x3e 语法用 ES5 的 \x3ccode\x3eprototype\x3c\/code\x3e 实现。\x3c\/li\x3e\n\x3cli\x3e给新的 API 注入 polyfill ，例如使用新的 \x3ccode\x3efetch\x3c\/code\x3e API 时注入对应的 polyfill 后才能让低端浏览器正常运行。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eBabel\x3c\/h2\x3e\n\x3cp\x3eBabel 可以方便的完成以上2件事。\x3c\/p\x3e\n\x3cp\x3eBabel 是一个 JavaScript 编译器，能将 ES6 代码转为 ES5 代码，让你使用最新的语言特性而不用担心兼容性问题，并且可以通过插件机制根据需求灵活的扩展。 \x3c\/p\x3e\n\x3cp\x3e在 Babel 执行编译的过程中，会从项目根目录下的 \x3ccode\x3e.babelrc\x3c\/code\x3e 文件读取配置。\x3ccode\x3e.babelrc\x3c\/code\x3e 是一个 JSON 格式的文件，内容大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;plugins\x26quot;: [\n    [\n      \x26quot;transform-runtime\x26quot;,\n      {\n        \x26quot;polyfill\x26quot;: false\n      }\n    ]\n   ],\n  \x26quot;presets\x26quot;: [\n    [\n      \x26quot;es2015\x26quot;,\n      {\n        \x26quot;modules\x26quot;: false\n      }\n    ],\n    \x26quot;stage-2\x26quot;,\n    \x26quot;react\x26quot;\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22plugins\x22\x3c\/span\x3e: [\n    [\n      \x3cspan class=\x22hljs-string\x22\x3e\x22transform-runtime\x22\x3c\/span\x3e,\n      {\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22polyfill\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      }\n    ]\n   ],\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22presets\x22\x3c\/span\x3e: [\n    [\n      \x3cspan class=\x22hljs-string\x22\x3e\x22es2015\x22\x3c\/span\x3e,\n      {\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22modules\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      }\n    ],\n    \x3cspan class=\x22hljs-string\x22\x3e\x22stage-2\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3ePlugins\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eplugins\x3c\/code\x3e 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。\x3c\/p\x3e\n\x3cp\x3e以上配置文件里的 \x3ccode\x3etransform-runtime\x3c\/code\x3e 对应的插件全名叫做 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e，即在前面加上了 \x3ccode\x3ebabel-plugin-\x3c\/code\x3e，要让 Babel 正常运行我们必须先安装它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D babel-plugin-transform-runtime\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D babel-plugin-\x3cspan class=\x22hljs-attribute\x22\x3etransform\x3c\/span\x3e-runtime\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 是 Babel 官方提供的一个插件，作用是减少冗余代码。 \x3c\/p\x3e\n\x3cp\x3eBabel 在把 ES6 代码转换成 ES5 代码时通常需要一些 ES5 写的辅助函数来完成新语法的实现，例如在转换 \x3ccode\x3eclass extent\x3c\/code\x3e 语法时会在转换后的 ES5 代码里注入 \x3ccode\x3e_extent\x3c\/code\x3e 辅助函数用于实现继承：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function _extent(target) {\n  for (var i = 1; i \x3c arguments.length; i\x2b\x2b) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_extent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e source = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[i];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e source) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这会导致每个使用了 \x3ccode\x3eclass extent\x3c\/code\x3e 语法的文件都被注入重复的 \x3ccode\x3e_extent\x3c\/code\x3e 辅助函数代码，\x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 的作用在于不把辅助函数内容注入到文件里，而是注入一条导入语句：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var _extent = require(\x27babel-runtime\/helpers\/_extent\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _extent = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27babel-runtime\/helpers\/_extent\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样能减小 Babel 编译出来的代码的文件大小。\x3c\/p\x3e\n\x3cp\x3e同时需要注意的是由于 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 注入了 \x3ccode\x3erequire(\x27babel-runtime\/helpers\/_extent\x27)\x3c\/code\x3e 语句到编译后的代码里，需要安装 \x3ccode\x3ebabel-runtime\x3c\/code\x3e 依赖到你的项目后，代码才能正常运行。 也就是说 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 和 \x3ccode\x3ebabel-runtime\x3c\/code\x3e 需要配套使用，使用了 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 后一定需要 \x3ccode\x3ebabel-runtime\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3ePresets\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3epresets\x3c\/code\x3e 属性告诉 Babel 要转换的源码使用了哪些新的语法特性，一个 \x3ccode\x3ePresets\x3c\/code\x3e 对一组新语法特性提供支持，多个 \x3ccode\x3ePresets\x3c\/code\x3e 可以叠加。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ePresets\x3c\/code\x3e 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作。Presets 是按照 ECMAScript 草案来组织的，通常可以分为以下三大类：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里；\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eenv 包含当前所有 ECMAScript 标准里的最新特性。\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e被社区提出来的但还未被写入 ECMAScript 标准里特性，这其中又分为以下四种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3estage0\x3c\/code\x3e 只是一个美好激进的想法，有 Babel 插件实现了对这些特性的支持，但是不确定是否会被定为标准；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estage1\x3c\/code\x3e 值得被纳入标准的特性；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estage2\x3c\/code\x3e 该特性规范已经被起草，将会被纳入标准里；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estage3\x3c\/code\x3e 该特性规范已经定稿，各大浏览器厂商和 Node.js 社区开始着手实现；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estage4\x3c\/code\x3e 在接下来的一年将会加入到标准里去。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e为了支持一些特定应用场景下的语法，和 ECMAScript 标准没有关系，例如 \x3ccode\x3ebabel-preset-react\x3c\/code\x3e 是为了支持 React 开发中的 JSX 语法。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在实际应用中，你需要根据项目源码所使用的语法去安装对应的 Plugins 或 Presets。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e接入 Babel\x3c\/h2\x3e\n\x3cp\x3e由于 Babel 所做的事情是转换代码，所以应该通过 Loader 去接入 Babel，Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        use: [\x27babel-loader\x27],\n      },\n    ]\n  },\n  \/\/ 输出 source-map 方便直接调试 ES6 源码\n  devtool: \x27source-map\x27\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 source-map 方便直接调试 ES6 源码\x3c\/span\x3e\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e配置命中了项目目录下所有的 JavaScript 文件，通过 \x3ccode\x3ebabel-loader\x3c\/code\x3e 去调用 Babel 完成转换工作。 在重新执行构建前，需要先安装新引入的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# Webpack 接入 Babel 必须依赖的模块\nnpm i -D babel-core babel-loader \n# 根据你的需求选择不同的 Plugins 或 Presets\nnpm i -D babel-preset-env\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# Webpack 接入 Babel 必须依赖的模块\x3c\/span\x3e\nnpm i -D \x3cspan class=\x22hljs-keyword\x22\x3ebabel-core \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3ebabel-loader \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# 根据你的需求选择不同的 Plugins 或 Presets\x3c\/span\x3e\nnpm i -D \x3cspan class=\x22hljs-keyword\x22\x3ebabel-preset-env\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e使用SCSS语言\x3c\/h1\x3e\n\x3cp\x3eSCSS 可以让你用更灵活的方式写 CSS。 它是一种 CSS 预处理器，语法和 CSS 相似，但加入了变量、逻辑等编程元素，代码类似这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$blue: #1875e7;　\n\ndiv {\n  color: $blue;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scss\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-variable\x22\x3e$blue\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e#1875e7\x3c\/span\x3e;　\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-variable\x22\x3e$blue\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eSCSS 又叫 SASS，区别在于 SASS 语法类似 Ruby，而 SCSS 语法类似 CSS，对于熟悉 CSS 的前端工程师来说会更喜欢 SCSS。\x3c\/p\x3e\n\x3cp\x3e采用 SCSS 去写 CSS 的好处在于可以方便地管理代码，抽离公共的部分，通过逻辑写出更灵活的代码。 和 SCSS 类似的 CSS 预处理器还有 LESS 等。\x3c\/p\x3e\n\x3cp\x3e使用 SCSS 可以提升编码效率，但是必须把 SCSS 源代码编译成可以直接在浏览器环境下运行的 CSS 代码。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enode-sass\x3c\/code\x3e 核心模块是由 C\x2b\x2b 编写，再用 Node.js 封装了一层，以供给其它 Node.js 调用。 \x3ccode\x3enode-sass\x3c\/code\x3e 还支持通过命令行调用，先安装它到全局：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -g node-sass\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3enpm i -g \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-sass\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再执行编译命令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n# 把 main.scss 源文件编译成 main.css\nnode-sass main.scss main.css\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# 把 main.scss 源文件编译成 main.css\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-sass\x3c\/span\x3e main.scss main.css\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你就能在源码同目录下看到编译后的 \x3ccode\x3emain.css\x3c\/code\x3e 文件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e接入 Webpack\x3c\/h2\x3e\n\x3cp\x3eWebpack 接入 \x3ccode\x3esass-loader\x3c\/code\x3e 相关配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        \/\/ 增加对 SCSS 文件的支持\n        test: \/\\.scss\/,\n        \/\/ SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader\n        use: [\x27style-loader\x27, \x27css-loader\x27, \x27sass-loader\x27],\n      },\n    ]\n  },\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 SCSS 文件的支持\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.scss\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader\x3c\/span\x3e\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27sass-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上配置通过正则 \x3ccode\x3e\/\\.scss\/\x3c\/code\x3e 匹配所有以 \x3ccode\x3e.scss\x3c\/code\x3e 为后缀的 SCSS 文件，再分别使用3个 Loader 去处理。具体处理流程如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e通过 \x3ccode\x3esass-loader\x3c\/code\x3e 把 SCSS 源码转换为 CSS 代码，再把 CSS 代码交给 \x3ccode\x3ecss-loader\x3c\/code\x3e 去处理。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecss-loader\x3c\/code\x3e 会找出 CSS 代码中的 \x3ccode\x3e@import\x3c\/code\x3e 和 \x3ccode\x3eurl()\x3c\/code\x3e 这样的导入语句，告诉 Webpack 依赖这些资源。同时还支持 CSS Modules、压缩 CSS 等功能。处理完后再把结果交给 \x3ccode\x3estyle-loader\x3c\/code\x3e 去处理。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estyle-loader\x3c\/code\x3e 会把 CSS 代码转换成字符串后，注入到 JavaScript 代码中去，通过 JavaScript 去给 DOM 增加样式。如果你想把 CSS 代码提取到一个单独的文件而不是和 JavaScript 混在一起，可以使用1-5 使用Plugin 中介绍过的 ExtractTextPlugin。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e由于接入 \x3ccode\x3esass-loader\x3c\/code\x3e，项目需要安装这些新的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 Webpack Loader 依赖\nnpm i -D  sass-loader css-loader style-loader\n# sass-loader 依赖 node-sass\nnpm i -D node-sass\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Webpack Loader 依赖\x3c\/span\x3e\nnpm i -D  sass-loader css-loader style-loader\n\x3cspan class=\x22hljs-comment\x22\x3e# sass-loader 依赖 node-sass\x3c\/span\x3e\nnpm i -D \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-sass\x3c\/span\x3e\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e使用Flow检查器\x3c\/h1\x3e\n\x3cp\x3eFlow 是一个 Facebook 开源的 JavaScript 静态类型检测器，它是 JavaScript 语言的超集。 \x3c\/p\x3e\n\x3cp\x3e你所需要做的就是在需要的地方加上类型检查，例如在两个由不同人开发的模块对接的接口出加上静态类型检查，能在编译阶段就指出部分模块使用不当的问题。 同时 Flow 也能通过类型推断检查出 JavaScript 代码中潜在的 Bug。\x3c\/p\x3e\n\x3cp\x3eFlow 使用效果如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ @flow\n\n\/\/ 静态类型检查\nfunction square1(n: number): number {\n  return n * n;\n}\nsquare1(\x272\x27); \/\/ Error: square1 需要传入 number 作为参数\n\n\/\/ 类型推断检查\nfunction square2(n) {\n  return n * n; \/\/ Error: 传入的 string 类型不能做乘法运算\n}\nsquare2(\x272\x27);\n\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ @flow\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 静态类型检查\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare1\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n: number)\x3c\/span\x3e: number \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n * n;\n}\nsquare1(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Error: square1 需要传入 number 作为参数\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型推断检查\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare2\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n * n; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Error: 传入的 string 类型不能做乘法运算\x3c\/span\x3e\n}\nsquare2(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e);\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e需要注意的时代码中的第一行 \x3ccode\x3e\/\/ @flow\x3c\/code\x3e 告诉 Flow 检查器这个文件需要被检查。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e使用 Flow\x3c\/h2\x3e\n\x3cp\x3eFlow 检测器由高性能跨平台的 OCaml 语言编写，它的可执行文件可以通过：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D flow-bin\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D flow-bin\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装，安装完成后通过先配置 Npm Script：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;scripts\x26quot;: {\n   \x26quot;flow\x26quot;: \x26quot;flow\x26quot;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22scripts\x22\x3c\/span\x3e: {\n   \x3cspan class=\x22hljs-string\x22\x3e\x22flow\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22flow\x22\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再通过 \x3ccode\x3enpm run flow\x3c\/code\x3e 去调用 Flow 执行代码检查。 \x3c\/p\x3e\n\x3cp\x3e除此之外你还可以通过：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -g flow-bin\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -g flow-bin\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e把 Flow 安装到全局后，再直接通过 \x3ccode\x3eflow\x3c\/code\x3e 命令去执行代码检查。\x3c\/p\x3e\n\x3cp\x3e安装成功后，在项目根目录下执行 Flow 后，Flow 会遍历出所有需要检查的文件并对其进行检查，输出错误结果到控制台。\x3c\/p\x3e\n\x3cp\x3e采用了 Flow 静态类型语法的 JavaScript 是无法直接在目前已有的 JavaScript 引擎中运行的，要让代码可以运行需要把这些静态类型语法去掉。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 采用 Flow 的源代码\nfunction foo(one: any, two: number, three?): string {}\n\n\/\/ 去掉静态类型语法后输出代码\nfunction foo(one, two, three) {}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 采用 Flow 的源代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(one: any, two: number, three?)\x3c\/span\x3e: string \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去掉静态类型语法后输出代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(one, two, three)\x3c\/span\x3e \x3c\/span\x3e{}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有两种方式可以做到这点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eflow-remove-types\x3c\/code\x3e 可单独使用，速度快。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ebabel-preset-flow\x3c\/code\x3e 与 Babel 集成。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e集成 Webpack\x3c\/h2\x3e\n\x3cp\x3e由于使用了 Flow 项目一般都会使用 ES6 语法，所以把 Flow 集成到使用 Webpack 构建的项目里最方便的方法是借助 Babel。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e安装 \x3ccode\x3enpm i -D babel-preset-flow\x3c\/code\x3e 依赖到项目。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e修改 \x3ccode\x3e.babelrc\x3c\/code\x3e 配置文件，加入 Flow Preset：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;presets\x26quot;: [\n...[],\n\x26quot;flow\x26quot;\n]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs prolog\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22presets\x22\x3c\/span\x3e: [\n...[],\n\x3cspan class=\x22hljs-string\x22\x3e\x22flow\x22\x3c\/span\x3e\n]\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e往源码里加入静态类型后重新构建项目，你会发现采用了 Flow 的源码还是能正常在浏览器中运行。\x3c\/p\x3e\n\x3cblockquote\x3e要明确构建的目的只是为了去除源码中的 Flow 静态类型语法，而代码检查和构建无关。 许多编辑器已经整合 Flow，可以实时在代码中高亮指出 Flow 检查出的问题。\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader13\x22\x3e使用PostCSS\x3c\/h1\x3e\n\x3cp\x3ePostCSS 是一个 CSS 处理工具，和 SCSS 不同的地方在于它通过插件机制可以灵活的扩展其支持的特性，而不是像 SCSS 那样语法是固定的。 PostCSS 的用处非常多，包括给 CSS 自动加前缀、使用下一代 CSS 语法等，目前越来越多的人开始用它，它很可能会成为 CSS 预处理器的最终赢家。\x3c\/p\x3e\n\x3cblockquote\x3ePostCSS 和 CSS 的关系就像 Babel 和 JavaScript 的关系，它们解除了语法上的禁锢，通过插件机制来扩展语言本身，用工程化手段给语言带来了更多的可能性。\x3cp\x3ePostCSS 和 SCSS 的关系就像 Babel 和 TypeScript 的关系，PostCSS 更加灵活、可扩张性强，而 SCSS 内置了大量功能而不能扩展。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e给 CSS 自动加前缀，增加各浏览器的兼容性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*输入*\/\nh1 {\n  display: flex;\n}\n\n\/*输出*\/\nh1 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*输入*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eh1\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3edisplay\x3c\/span\x3e: flex;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*输出*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eh1\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3edisplay\x3c\/span\x3e: -webkit-box;\n  \x3cspan class=\x22hljs-attribute\x22\x3edisplay\x3c\/span\x3e: -webkit-flex;\n  \x3cspan class=\x22hljs-attribute\x22\x3edisplay\x3c\/span\x3e: -ms-flexbox;\n  \x3cspan class=\x22hljs-attribute\x22\x3edisplay\x3c\/span\x3e: flex;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用下一代 CSS 语法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*输入*\/\n:root {\n  --red: #d33;\n}\n\nh1 {\n  color: var(--red);\n}\n\n\n\/*输出*\/\nh1 { \n  color: #d33;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*输入*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:root\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3e--red\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e#d33\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3eh1\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e(--red);\n}\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*输出*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eh1\x3c\/span\x3e { \n  \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e#d33\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePostCSS 全部采用 JavaScript 编写，运行在 Node.js 之上，即提供了给 JavaScript 代码调用的模块，也提供了可执行的文件。 \x3c\/p\x3e\n\x3cp\x3e在 PostCSS 启动时，会从目录下的 \x3ccode\x3epostcss.config.js\x3c\/code\x3e 文件中读取所需配置，所以需要新建该文件，文件内容大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  plugins: [\n    \/\/ 需要使用的插件列表\n    require(\x27postcss-cssnext\x27)\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  plugins: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要使用的插件列表\x3c\/span\x3e\n    require(\x3cspan class=\x22hljs-string\x22\x3e\x27postcss-cssnext\x27\x3c\/span\x3e)\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中的 \x3ccode\x3epostcss-cssnext\x3c\/code\x3e 插件可以让你使用下一代 CSS 语法编写代码，再通过 PostCSS 转换成目前的浏览器可识别的 CSS，并且该插件还包含给 CSS 自动加前缀的功能。\x3c\/p\x3e\n\x3cblockquote\x3e目前 Chrome 等现代浏览器已经能完全支持 \x3ccode\x3ecssnext\x3c\/code\x3e 中的所有语法，也就是说按照 \x3ccode\x3ecssnext\x3c\/code\x3e 语法写的 CSS 在不经过转换的情况下也能在浏览器中直接运行。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e接入 Webpack\x3c\/h2\x3e\n\x3cp\x3e虽然使用 PostCSS 后文件后缀还是 \x3ccode\x3e.css\x3c\/code\x3e 但这些文件必须先交给 \x3ccode\x3epostcss-loader\x3c\/code\x3e 处理一遍后再交给 \x3ccode\x3ecss-loader\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e接入 PostCSS 相关的 Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        \/\/ 使用 PostCSS 处理 CSS 文件\n        test: \/\\.css\/,\n        use: [\x27style-loader\x27, \x27css-loader\x27, \x27postcss-loader\x27],\n      },\n    ]\n  },\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用 PostCSS 处理 CSS 文件\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27postcss-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接入 PostCSS 给项目带来了新的依赖需要安装，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 Webpack Loader 依赖\nnpm i -D postcss-loader css-loader style-loader\n# 根据你使用的特性安装对应的 PostCSS 插件依赖\nnpm i -D postcss-cssnext\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Webpack Loader 依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D postcss-loader css-loader style-loader\n\x3cspan class=\x22hljs-comment\x22\x3e# 根据你使用的特性安装对应的 PostCSS 插件依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D postcss-cssnext\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader15\x22\x3e使用React框架\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3eReact 语法特征\x3c\/h2\x3e\n\x3cp\x3e使用了 React 项目的代码特征有 JSX 和 Class 语法，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Button extends Component {\n  render() {\n    return \x3ch1\x3eHello,Webpack\x3c\/h1\x3e\n  }\n}   \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e,\x3cspan class=\x22hljs-type\x22\x3eWebpack\x3c\/span\x3e\x26lt;\/h1\x26gt;\n  }\n}   \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e在使用了 React 的项目里 JSX 和 Class 语法并不是必须的，但使用新语法写出的代码看上去更优雅。\x3c\/blockquote\x3e\n\x3cp\x3e其中 JSX 语法是无法在任何现有的 JavaScript 引擎中运行的，所以在构建过程中需要把源码转换成可以运行的代码，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 原 JSX 语法代码\nreturn \x3ch1\x3eHello,Webpack\x3c\/h1\x3e\n\n\/\/ 被转换成正常的 JavaScript 代码\nreturn React.createElement(\x27h1\x27, null, \x27Hello,Webpack\x27)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原 JSX 语法代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello,Webpack\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 被转换成正常的 JavaScript 代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27h1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Hello,Webpack\x27\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3eReact 与 Babel\x3c\/h2\x3e\n\x3cp\x3e要在使用 Babel 的项目中接入 React 框架是很简单的，只需要加入 React 所依赖的 Presets \x3ccode\x3ebabel-preset-react\x3c\/code\x3e。 \x3c\/p\x3e\n\x3cp\x3e通过以下命令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 React 基础依赖\nnpm i -D react react-dom\n# 安装 babel 完成语法转换所需依赖\nnpm i -D babel-preset-react\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 React 基础依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D react react-dom\n\x3cspan class=\x22hljs-comment\x22\x3e# 安装 babel 完成语法转换所需依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D babel-preset-react\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装新的依赖后，再修改 \x3ccode\x3e.babelrc\x3c\/code\x3e 配置文件加入 React Presets\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;presets\x26quot;: [\n    \x26quot;react\x26quot;\n],\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs prolog\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22presets\x22\x3c\/span\x3e: [\n    \x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e\n],\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就完成了一切准备工作。\x3c\/p\x3e\n\x3cp\x3e再修改 \x3ccode\x3emain.js\x3c\/code\x3e 文件如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import * as React from \x27react\x27;\nimport { Component } from \x27react\x27;\nimport { render } from \x27react-dom\x27;\n\nclass Button extends Component {\n  render() {\n    return \x3ch1\x3eHello,Webpack\x3c\/h1\x3e\n  }\n}\n\nrender(\x3cButton\/\x3e, window.document.getElementById(\x27app\x27));\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e * \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { render } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello,Webpack\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  }\n}\n\nrender(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eButton\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e));\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重新执行构建打开网页你将会发现由 React 渲染出来的 \x3ccode\x3eHello,Webpack\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3eReact 与 TypeScript\x3c\/h2\x3e\n\x3cp\x3eTypeScript 相比于 Babel 的优点在于它原生支持 JSX 语法，你不需要重新安装新的依赖，只需修改一行配置。 但 TypeScript 的不同在于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用了 JSX 语法的文件后缀必须是 \x3ccode\x3etsx\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e由于 React 不是采用 TypeScript 编写的，需要安装 \x3ccode\x3ereact\x3c\/code\x3e 和 \x3ccode\x3ereact-dom\x3c\/code\x3e 对应的 TypeScript 接口描述模块 \x3ccode\x3e@types\/react\x3c\/code\x3e 和 \x3ccode\x3e@types\/react-dom\x3c\/code\x3e 后才能通过编译。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e修改 TypeScript 编译器配置文件 \x3ccode\x3etsconfig.json\x3c\/code\x3e 增加对 JSX 语法的支持，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;compilerOptions\x26quot;: {\n    \x26quot;jsx\x26quot;: \x26quot;react\x26quot; \/\/ 开启 jsx ，支持 React\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22compilerOptions\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22jsx\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e \/\/ 开启 jsx ，支持 React\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于 \x3ccode\x3emain.js\x3c\/code\x3e 文件中存在 JSX 语法，再把 \x3ccode\x3emain.js\x3c\/code\x3e 文件重命名为 \x3ccode\x3emain.tsx\x3c\/code\x3e，同时修改文件内容为在上面 React 与 Babel 里所采用的 React 代码。 同时为了让 Webpack 对项目里的 \x3ccode\x3ets\x3c\/code\x3e 与 \x3ccode\x3etsx\x3c\/code\x3e 原文件都采用 \x3ccode\x3eawesome-typescript-loader\x3c\/code\x3e 去转换， 需要注意的是 Webpack Loader 配置的 \x3ccode\x3etest\x3c\/code\x3e 选项需要匹配到 \x3ccode\x3etsx\x3c\/code\x3e 类型的文件，并且 \x3ccode\x3eextensions\x3c\/code\x3e 中也要加上 \x3ccode\x3e.tsx\x3c\/code\x3e，配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  \/\/ TS 执行入口文件\n  entry: \x27.\/main\x27,\n  output: {\n    filename: \x27bundle.js\x27,\n    path: path.resolve(__dirname, \x27.\/dist\x27),\n  },\n  resolve: {\n    \/\/ 先尝试 ts，tsx 后缀的 TypeScript 源码文件 \n    extensions: [\x27.ts\x27, \x27.tsx\x27, \x27.js\x27,] \n  },\n  module: {\n    rules: [\n      {\n        \/\/ 同时匹配 ts，tsx 后缀的 TypeScript 源码文件 \n        test: \/\\.tsx?$\/,\n        loader: \x27awesome-typescript-loader\x27\n      }\n    ]\n  },\n  devtool: \x27source-map\x27,\/\/ 输出 Source Map 方便在浏览器里调试 TypeScript 代码\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TS 执行入口文件\x3c\/span\x3e\n  entry: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/main\x27\x3c\/span\x3e,\n  output: {\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27bundle.js\x27\x3c\/span\x3e,\n    path: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27.\/dist\x27\x3c\/span\x3e),\n  },\n  resolve: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先尝试 ts，tsx 后缀的 TypeScript 源码文件 \x3c\/span\x3e\n    extensions: [\x3cspan class=\x22hljs-string\x22\x3e\x27.ts\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.tsx\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e,] \n  },\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同时匹配 ts，tsx 后缀的 TypeScript 源码文件 \x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.tsx?$\/\x3c\/span\x3e,\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27awesome-typescript-loader\x27\x3c\/span\x3e\n      }\n    ]\n  },\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 Source Map 方便在浏览器里调试 TypeScript 代码\x3c\/span\x3e\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过\x3ccode\x3enpm i react react-dom @types\/react @types\/react-dom\x3c\/code\x3e安装新的依赖后重启构建，重新打开网页你将会发现由 React 渲染出来的 \x3ccode\x3eHello,Webpack\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader19\x22\x3e使用Vue框架\x3c\/h1\x3e\n\x3cp\x3eVue是一个渐进式的 MVVM 框架，相比于 React、Angular 它更灵活轻量。 它不会强制性地内置一些功能和语法，你可以根据自己的需要一点点地添加功能。 虽然采用 Vue 的项目能用可直接运行在浏览器环境里的代码编写，但为了方便编码大多数项目都会采用 Vue 官方的单文件组件的写法去编写项目。 \x3c\/p\x3e\n\x3cp\x3eVue 的单文件组件通过一个类似 HTML 文件的 \x3ccode\x3e.vue\x3c\/code\x3e 文件就能描述清楚一个组件所需的模版、样式、逻辑。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3emain.js\x3c\/code\x3e 入口文件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vue from \x27vue\x27\nimport App from \x27.\/App.vue\x27\n\nnew Vue({\n  el: \x27#app\x27,\n  render: h =\x3e h(App)\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.vue\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eh\x3c\/span\x3e =\x26gt;\x3c\/span\x3e h(App)\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e入口文件创建一个 Vue 的根实例，在 ID 为 \x3ccode\x3eapp\x3c\/code\x3e 的 DOM 节点上渲染出上面定义的 App 组件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3e接入 Webpack\x3c\/h2\x3e\n\x3cp\x3e目前最成熟和流行的开发 Vue 项目的方式是采用 ES6 加 Babel 转换，这和基本的采用 ES6 开发的项目很相似，差别在于要解析 \x3ccode\x3e.vue\x3c\/code\x3e 格式的单文件组件。 好在 Vue 官方提供了对应的 \x3ccode\x3evue-loader\x3c\/code\x3e 可以非常方便的完成单文件组件的转换。\x3c\/p\x3e\n\x3cp\x3e修改 Webpack 相关配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n  rules: [\n    {\n      test: \/\\.vue$\/,\n      use: [\x27vue-loader\x27],\n    },\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3emodule\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attribute\x22\x3erules\x3c\/span\x3e: [\n    {\n      test: \/\\.vue$\/,\n      use: [\x3cspan class=\x22hljs-string\x22\x3e\x27vue-loader\x27\x3c\/span\x3e],\n    },\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装新引入的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# Vue 框架运行需要的库\nnpm i -S vue\n# 构建所需的依赖\nnpm i -D vue-loader css-loader vue-template-compiler\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# Vue 框架运行需要的库\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -S vue\n\x3cspan class=\x22hljs-comment\x22\x3e# 构建所需的依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D vue-loader css-loader vue-template-compiler\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这些依赖中，它们的作用分别是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3evue-loader\x3c\/code\x3e：解析和转换 \x3ccode\x3e.vue\x3c\/code\x3e 文件，提取出其中的逻辑代码 \x3ccode\x3escript\x3c\/code\x3e、样式代码 \x3ccode\x3estyle\x3c\/code\x3e、以及 HTML 模版 \x3ccode\x3etemplate\x3c\/code\x3e，再分别把它们交给对应的 Loader 去处理。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecss-loader\x3c\/code\x3e：加载由 \x3ccode\x3evue-loader\x3c\/code\x3e 提取出的 CSS 代码。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3evue-template-compiler\x3c\/code\x3e：把 \x3ccode\x3evue-loader\x3c\/code\x3e 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码，这和 React 中的 JSX 语法被编译成 JavaScript 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader21\x22\x3e使用 TypeScript 编写 Vue 应用\x3c\/h2\x3e\n\x3cp\x3e从 Vue 2.5.0\x2b 版本开始，提供了对 TypeScript 的良好支持，使用 TypeScript 编写 Vue 是一个很好的选择，因为 TypeScript 能检查出一些潜在的错误。\x3c\/p\x3e\n\x3cp\x3e新增 \x3ccode\x3etsconfig.json\x3c\/code\x3e 配置文件，内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;compilerOptions\x26quot;: {\n    \/\/ 构建出 ES5 版本的 JavaScript，与 Vue 的浏览器支持保持一致\n    \x26quot;target\x26quot;: \x26quot;es5\x26quot;,\n    \/\/ 开启严格模式，这可以对 `this` 上的数据属性进行更严格的推断\n    \x26quot;strict\x26quot;: true,\n    \/\/ TypeScript 编译器输出的 JavaScript 采用 es2015 模块化，使 Tree Shaking 生效\n    \x26quot;module\x26quot;: \x26quot;es2015\x26quot;,\n    \x26quot;moduleResolution\x26quot;: \x26quot;node\x26quot;\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ruby\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22compilerOptions\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 构建出 ES5 版本的 JavaScript，与 Vue 的浏览器支持保持一致\n    \x3cspan class=\x22hljs-string\x22\x3e\x22target\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22es5\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 开启严格模式，这可以对 \x3cspan class=\x22hljs-string\x22\x3e`this`\x3c\/span\x3e 上的数据属性进行更严格的推断\n    \x3cspan class=\x22hljs-string\x22\x3e\x22strict\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e TypeScript 编译器输出的 JavaScript 采用 es2015 模块化，使 Tree Shaking 生效\n    \x3cspan class=\x22hljs-string\x22\x3e\x22module\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22es2015\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22moduleResolution\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22node\x22\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e修改 \x3ccode\x3eApp.vue\x3c\/code\x3e 脚本部分内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!--组件逻辑--\x3e\n\x3cscript lang=\x26quot;ts\x26quot;\x3e\n  import Vue from \x26quot;vue\x26quot;;\n\n  \/\/ 通过 Vue.extend 启用 TypeScript 类型推断\n  export default Vue.extend({\n    data() {\n      return {\n        msg: \x27Hello,Webpack\x27,\n      }\n    },\n  });\n\x3c\/script\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--组件逻辑--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3elang\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22ts\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22vue\x22\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 Vue.extend 启用 TypeScript 类型推断\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Vue.extend({\n    data() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3emsg\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello,Webpack\x27\x3c\/span\x3e,\n      }\n    },\n  });\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意 \x3ccode\x3escript\x3c\/code\x3e 标签中的 \x3ccode\x3elang=\x22ts\x22\x3c\/code\x3e 是为了指明代码的语法是 TypeScript。\x3c\/p\x3e\n\x3cp\x3e修改 main.ts 执行入口文件为如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vue from \x27vue\x27\nimport App from \x27.\/App.vue\x27\n\nnew Vue({\n  el: \x27#app\x27,\n  render: h =\x3e h(App)\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.vue\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eh\x3c\/span\x3e =\x26gt;\x3c\/span\x3e h(App)\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于 TypeScript 不认识 \x3ccode\x3e.vue\x3c\/code\x3e 结尾的文件，为了让其支持 \x3ccode\x3eimport App from \x27.\/App.vue\x27\x3c\/code\x3e 导入语句，还需要以下文件 \x3ccode\x3evue-shims.d.ts\x3c\/code\x3e 去定义 \x3ccode\x3e.vue\x3c\/code\x3e 的类型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 告诉 TypeScript 编译器 .vue 文件其实是一个 Vue  \ndeclare module \x26quot;*.vue\x26quot; {\n  import Vue from \x26quot;vue\x26quot;;\n  export default Vue;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 告诉 TypeScript 编译器 .vue 文件其实是一个 Vue  \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3edeclare\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e \x22*.vue\x22 {\n  \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22vue\x22\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Vue;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWebpack 配置需要修改两个地方，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\n\nmodule.exports = {\n  resolve: {\n    \/\/ 增加对 TypeScript 的 .ts 和 .vue 文件的支持\n    extensions: [\x27.ts\x27, \x27.js\x27, \x27.vue\x27, \x27.json\x27],\n  },\n  module: {\n    rules: [\n      \/\/ 加载 .ts 文件\n      {\n        test: \/\\.ts$\/,\n        loader: \x27ts-loader\x27,\n        exclude: \/node_modules\/,\n        options: {\n          \/\/ 让 tsc 把 vue 文件当成一个 TypeScript 模块去处理，以解决 moudle not found 的问题，tsc 本身不会处理 .vue 结尾的文件\n          appendTsSuffixTo: [\/\\.vue$\/],\n        }\n      },\n    ]\n  },\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  resolve: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 TypeScript 的 .ts 和 .vue 文件的支持\x3c\/span\x3e\n    extensions: [\x3cspan class=\x22hljs-string\x22\x3e\x27.ts\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.vue\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27.json\x27\x3c\/span\x3e],\n  },\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载 .ts 文件\x3c\/span\x3e\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.ts$\/\x3c\/span\x3e,\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27ts-loader\x27\x3c\/span\x3e,\n        exclude: \x3cspan class=\x22hljs-regexp\x22\x3e\/node_modules\/\x3c\/span\x3e,\n        options: {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 让 tsc 把 vue 文件当成一个 TypeScript 模块去处理，以解决 moudle not found 的问题，tsc 本身不会处理 .vue 结尾的文件\x3c\/span\x3e\n          appendTsSuffixTo: [\x3cspan class=\x22hljs-regexp\x22\x3e\/\\.vue$\/\x3c\/span\x3e],\n        }\n      },\n    ]\n  },\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外还需要安装新引入的依赖：\x3ccode\x3enpm i -D ts-loader typescript\x3c\/code\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader22\x22\x3e为单页应用生成HTML\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3e引入问题\x3c\/h2\x3e\n\x3cp\x3e在使用 React 框架中，是用最简单的 \x3ccode\x3eHello,Webpack\x3c\/code\x3e 作为例子让大家理解， 这个例子里因为只输出了一个 \x3ccode\x3ebundle.js \x3c\/code\x3e文件，所以手写了一个 \x3ccode\x3eindex.html\x3c\/code\x3e 文件去引入这个 \x3ccode\x3ebundle.js\x3c\/code\x3e，才能让应用在浏览器中运行起来。\x3c\/p\x3e\n\x3cp\x3e在实际项目中远比这复杂，一个页面常常有很多资源要加载。接下来举一个实战中的例子，要求如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e项目采用 ES6 语言加 React 框架。\x3c\/li\x3e\n\x3cli\x3e给页面加入 Google Analytics，这部分代码需要内嵌进 HEAD 标签里去。\x3c\/li\x3e\n\x3cli\x3e给页面加入 Disqus 用户评论，这部分代码需要异步加载以提升首屏加载速度。\x3c\/li\x3e\n\x3cli\x3e压缩和分离 JavaScript 和 CSS 代码，提升加载速度。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在开始前先来看看该应用最终发布到线上的\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3%E5%AE%9E%E6%88%98\/3-9%E4%B8%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%94%9F%E6%88%90HTML.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e代码\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e可以看到部分代码被内嵌进了 HTML 的 HEAD 标签中，部分文件的文件名称被打上根据文件内容算出的 Hash 值，并且加载这些文件的 URL 地址也被正常的注入到了 HTML 中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader24\x22\x3e解决方案\x3c\/h2\x3e\n\x3cp\x3e推荐一个用于方便地解决以上问题的 Webpack 插件 \x3ca href=\x22https:\/\/github.com\/gwuhaolin\/web-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eweb-webpack-plugin\x3c\/a\x3e。 该插件已经被社区上许多人使用和验证，解决了大家的痛点获得了很多好评，下面具体介绍如何用它来解决上面的问题。\x3c\/p\x3e\n\x3cp\x3e首先，修改 \x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3%E5%AE%9E%E6%88%98\/3-9%E4%B8%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%94%9F%E6%88%90HTML.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebpack 配置\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e以上配置中，大多数都是按照前面已经讲过的内容增加的配置，例如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e增加对 CSS 文件的支持，提取出 Chunk 中的 CSS 代码到单独的文件中，压缩 CSS 文件；\x3c\/li\x3e\n\x3cli\x3e定义 \x3ccode\x3eNODE_ENV\x3c\/code\x3e 环境变量为 \x3ccode\x3eproduction\x3c\/code\x3e，以去除源码中只有开发时才需要的部分；\x3c\/li\x3e\n\x3cli\x3e给输出的文件名称加上 Hash 值；\x3c\/li\x3e\n\x3cli\x3e压缩输出的 JavaScript 代码。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e但最核心的部分在于 \x3ccode\x3eplugins\x3c\/code\x3e 里的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new WebPlugin({\n  template: \x27.\/template.html\x27, \/\/ HTML 模版文件所在的文件路径\n  filename: \x27index.html\x27 \/\/ 输出的 HTML 的文件名称\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WebPlugin({\n  \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/template.html\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HTML 模版文件所在的文件路径\x3c\/span\x3e\n  filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的 HTML 的文件名称\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中 \x3ccode\x3etemplate: \x27.\/template.html\x27\x3c\/code\x3e 所指的模版文件 \x3ccode\x3etemplate.html\x3c\/code\x3e 的内容是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3chead\x3e\n  \x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n  \x3c!--注入 Chunk app 中的 CSS--\x3e\n  \x3clink rel=\x26quot;stylesheet\x26quot; href=\x26quot;app?_inline\x26quot;\x3e\n  \x3c!--注入 google_analytics 中的 JavaScript 代码--\x3e\n  \x3cscript src=\x26quot;.\/google_analytics.js?_inline\x26quot;\x3e\x3c\/script\x3e\n  \x3c!--异步加载 Disqus 评论--\x3e\n  \x3cscript src=\x26quot;https:\/\/dive-into-webpack.disqus.com\/embed.js\x26quot; async\x3e\x3c\/script\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n\x3cdiv id=\x26quot;app\x26quot;\x3e\x3c\/div\x3e\n\x3c!--导入 Chunk app 中的 JS--\x3e\n\x3cscript src=\x26quot;app\x26quot;\x3e\x3c\/script\x3e\n\x3c!--Disqus 评论容器--\x3e\n\x3cdiv id=\x26quot;disqus_thread\x26quot;\x3e\x3c\/div\x3e\n\x3c\/body\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--注入 Chunk app 中的 CSS--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3elink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22stylesheet\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app?_inline\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--注入 google_analytics 中的 JavaScript 代码--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/google_analytics.js?_inline\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--异步加载 Disqus 评论--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/dive-into-webpack.disqus.com\/embed.js\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3easync\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--导入 Chunk app 中的 JS--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--Disqus 评论容器--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22disqus_thread\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该文件描述了哪些资源需要被以何种方式加入到输出的 HTML 文件中。\x3c\/p\x3e\n\x3cp\x3e以 \x3ccode\x3e\x26lt;link rel=\x22stylesheet\x22 href=\x22app?_inline\x22\x26gt;\x3c\/code\x3e 为例，按照正常引入 CSS 文件一样的语法来引入 Webpack 生产的代码。\x3ccode\x3ehref\x3c\/code\x3e 属性中的 \x3ccode\x3eapp?_inline\x3c\/code\x3e 可以分为两部分，前面的 \x3ccode\x3eapp\x3c\/code\x3e 表示 CSS 代码来自名叫 \x3ccode\x3eapp\x3c\/code\x3e 的 Chunk 中，后面的 \x3ccode\x3e_inline\x3c\/code\x3e 表示这些代码需要被内嵌到这个标签所在的位置。\x3c\/p\x3e\n\x3cp\x3e同样的 \x3ccode\x3e\x26lt;script src=\x22.\/google_analytics.js?_inline\x22\x26gt;\x26lt;\/script\x26gt;\x3c\/code\x3e 表示 JavaScript 代码来自相对于当前模版文件 \x3ccode\x3etemplate.html\x3c\/code\x3e 的本地文件 \x3ccode\x3e.\/google_analytics.js\x3c\/code\x3e， 而且文件中的 JavaScript 代码也需要被内嵌到这个标签所在的位置。\x3c\/p\x3e\n\x3cp\x3e也就是说资源链接 URL 字符串里问号前面的部分表示资源内容来自哪里，后面的 \x3ccode\x3equerystring\x3c\/code\x3e 表示这些资源注入的方式。\x3c\/p\x3e\n\x3cp\x3e除了 \x3ccode\x3e_inline\x3c\/code\x3e 表示内嵌外，还支持以下属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e_dist\x3c\/code\x3e 只有在生产环境下才引入该资源;\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e_dev\x3c\/code\x3e 只有在开发环境下才引入该资源；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e_ie\x3c\/code\x3e 只有IE浏览器才需要引入的资源，通过 \x3ccode\x3e[if IE]\x26gt;resource\x26lt;![endif]\x3c\/code\x3e 注释实现。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这些属性之间可以搭配使用，互不冲突。例如 \x3ccode\x3eapp?_inline\x26amp;_dist\x3c\/code\x3e 表示只在生产环境下才引入该资源，并且需要内嵌到 HTML 里去。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eWebPlugin\x3c\/code\x3e 插件还支持一些其它更高级的用法，详情可以访问该\x3ca href=\x22https:\/\/github.com\/gwuhaolin\/web-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e项目主页\x3c\/a\x3e阅读文档。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader25\x22\x3e管理多个单页应用\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader26\x22\x3e引入问题\x3c\/h2\x3e\n\x3cp\x3e在开始前先来看看该应用最终发布到线上的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3chtml\x3e\n\x3chead\x3e\n\x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n\x3c!--从多个页面中抽离出的公共 CSS 代码--\x3e\n\x3clink rel=\x26quot;stylesheet\x26quot; href=\x26quot;common_7cc98ad0.css\x26quot;\x3e\n\x3c!--只有这个页面需要的 CSS 代码--\x3e\n\x3clink rel=\x26quot;stylesheet\x26quot; href=\x26quot;login_e31e214b.css\x26quot;\x3e\n\x3c!--注入 google_analytics 中的 JS 代码--\x3e\n\x3cscript\x3e(function(i,s,o,g,r,a,m){i[\x27GoogleAnalyticsObject\x27]=r;i[r]=i[r]||function(){\n    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,\x27script\x27,\x27https:\/\/www.google-analytics.com\/analytics.js\x27,\x27ga\x27);\nga(\x27create\x27, \x27UA-XXXXX-Y\x27, \x27auto\x27);\nga(\x27send\x27, \x27pageview\x27);\x3c\/script\x3e\n\x3c!--异步加载 Disqus 评论--\x3e\n\x3cscript async=\x26quot;\x26quot; src=\x26quot;https:\/\/dive-into-webpack.disqus.com\/embed.js\x26quot;\x3e\x3c\/script\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n\x3cdiv id=\x26quot;app\x26quot;\x3e\x3c\/div\x3e\n\x3c!--从多个页面中抽离出的公共 JavaScript 代码--\x3e\n\x3cscript src=\x26quot;common_a1d9142f.js\x26quot;\x3e\x3c\/script\x3e\n\x3c!--只有这个页面需要的 JavaScript 代码--\x3e\n\x3cscript src=\x26quot;login_f926c4e6.js\x26quot;\x3e\x3c\/script\x3e\n\x3c!--Disqus 评论容器--\x3e\n\x3cdiv id=\x26quot;disqus_thread\x26quot;\x3e\x3c\/div\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--从多个页面中抽离出的公共 CSS 代码--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3elink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22stylesheet\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22common_7cc98ad0.css\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--只有这个页面需要的 CSS 代码--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3elink\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22stylesheet\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22login_e31e214b.css\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--注入 google_analytics 中的 JS 代码--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ei,s,o,g,r,a,m\x3c\/span\x3e)\x3c\/span\x3e{i[\x3cspan class=\x22hljs-string\x22\x3e\x27GoogleAnalyticsObject\x27\x3c\/span\x3e]=r;i[r]=i[r]||\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    (i[r].q=i[r].q||[]).push(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e)},i[r].l=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e*\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e();a=s.createElement(o),\n    m=s.getElementsByTagName(o)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];a.async=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;a.src=g;m.parentNode.insertBefore(a,m)\n})(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27script\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/www.google-analytics.com\/analytics.js\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27ga\x27\x3c\/span\x3e);\nga(\x3cspan class=\x22hljs-string\x22\x3e\x27create\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27UA-XXXXX-Y\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27auto\x27\x3c\/span\x3e);\nga(\x3cspan class=\x22hljs-string\x22\x3e\x27send\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27pageview\x27\x3c\/span\x3e);\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--异步加载 Disqus 评论--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3easync\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/dive-into-webpack.disqus.com\/embed.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--从多个页面中抽离出的公共 JavaScript 代码--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22common_a1d9142f.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--只有这个页面需要的 JavaScript 代码--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22login_f926c4e6.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--Disqus 评论容器--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22disqus_thread\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构建出的目录结构为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22dist\n├── common_029086ff.js\n├── common_7cc98ad0.css\n├── index.html\n├── index_04c08fbf.css\n├── index_b3d3761c.js\n├── login.html\n├── login_0a3feca9.js\n└── login_e31e214b.css\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3edist\n├── common_029086ff\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n├── common_7cc98ad0\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.html\x3c\/span\x3e\n├── index_04c08fbf\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n├── index_b3d3761c\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n├── login\x3cspan class=\x22hljs-selector-class\x22\x3e.html\x3c\/span\x3e\n├── login_0a3feca9\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n└── login_e31e214b\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果按照上节的思路，可能需要为每个单页应用配置一段如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new WebPlugin({\n  template: \x27.\/template.html\x27, \/\/ HTML 模版文件所在的文件路径\n  filename: \x27login.html\x27 \/\/ 输出的 HTML 的文件名称\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WebPlugin({\n  \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/template.html\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HTML 模版文件所在的文件路径\x3c\/span\x3e\n  filename: \x3cspan class=\x22hljs-string\x22\x3e\x27login.html\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的 HTML 的文件名称\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e并且把页面对应的入口加入到 \x3ccode\x3eenrty\x3c\/code\x3e 配置项中，就像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22entry: {\n  index: \x27.\/pages\/index\/index.js\x27,\/\/ 页面 index.html 的入口文件\n  login: \x27.\/pages\/login\/index.js\x27,\/\/ 页面 login.html 的入口文件\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3eentry\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attribute\x22\x3eindex\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/index\/index.js\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面 index.html 的入口文件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3elogin\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/pages\/login\/index.js\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面 login.html 的入口文件\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当有新页面加入时就需要修改 Webpack 配置文件，新插入一段以上代码，这会导致构建代码难以维护而且易错。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader27\x22\x3e解决方案\x3c\/h2\x3e\n\x3cp\x3e项目源码目录结构如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22├── pages\n│   ├── index\n│   │   ├── index.css \/\/ 该页面单独需要的 CSS 样式\n│   │   └── index.js \/\/ 该页面的入口文件\n│   └── login\n│       ├── index.css\n│       └── index.js\n├── common.css \/\/ 所有页面都需要的公共 CSS 样式\n├── google_analytics.js\n├── template.html\n└── webpack.config.js\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e├── pages\n│   ├── index\n│   │   ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该页面单独需要的 CSS 样式\x3c\/span\x3e\n│   │   └── index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该页面的入口文件\x3c\/span\x3e\n│   └── login\n│       ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n│       └── index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n├── common\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所有页面都需要的公共 CSS 样式\x3c\/span\x3e\n├── google_analytics\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n├── template\x3cspan class=\x22hljs-selector-class\x22\x3e.html\x3c\/span\x3e\n└── webpack\x3cspan class=\x22hljs-selector-class\x22\x3e.config\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从目录结构中可以看成出下几点要求：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e所有单页应用的代码都需要放到一个目录下，例如都放在 \x3ccode\x3epages\x3c\/code\x3e 目录下；\x3c\/li\x3e\n\x3cli\x3e一个单页应用一个单独的文件夹，例如最后生成的 \x3ccode\x3eindex.html\x3c\/code\x3e 相关的代码都在 \x3ccode\x3eindex\x3c\/code\x3e 目录下，\x3ccode\x3elogin.html\x3c\/code\x3e 同理；\x3c\/li\x3e\n\x3cli\x3e每个单页应用的目录下都有一个 \x3ccode\x3eindex.js\x3c\/code\x3e 文件作为入口执行文件。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e虽然 \x3ccode\x3eAutoWebPlugin\x3c\/code\x3e 强制性的规定了项目部分的目录结构，但从实战经验来看这是一种优雅的目录规范，合理的拆分了代码，又能让新人快速的看懂项目结构，也方便日后的维护。\x3c\/blockquote\x3e\n\x3cp\x3eWebpack 配置文件修改如下：\x3c\/p\x3e\n\x3cp\x3e\x26lt;p data-height=\x22465\x22 data-theme-id=\x220\x22 data-slug-hash=\x22gzJWwB\x22 data-default-tab=\x22js,result\x22 data-user=\x22whjin\x22 data-embed-version=\x222\x22 data-pen-title=\x22webpack管理多个单页应用\x22 class=\x22codepen\x22\x26gt;See the Pen \x3ca href=\x22https:\/\/codepen.io\/whjin\/pen\/gzJWwB\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack管理多个单页应用\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22whjin\/pen\/gzJWwB\/\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e by whjin (\x3ca href=\x22https:\/\/codepen.io\/whjin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e@whjin\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22whjin\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e) on \x3ca href=\x22https:\/\/codepen.io\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCodePen\x3c\/a\x3e.\x26lt;\/p\x26gt;\x3cbr\x3e\x26lt;script async src=\x22\x3ca href=\x22https:\/\/static.codepen.io\/assets\/embed\/ei.js\x26amp;quot\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/static.codepen.io\/ass...\x3c\/a\x3e;\x26gt;\x26lt;\/script\x26gt;\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eAutoWebPlugin\x3c\/code\x3e 会找出 \x3ccode\x3epages\x3c\/code\x3e 目录下的2个文件夹 \x3ccode\x3eindex\x3c\/code\x3e 和 \x3ccode\x3elogin\x3c\/code\x3e，把这两个文件夹看成两个单页应用。 并且分别为每个单页应用生成一个 Chunk 配置和 WebPlugin 配置。 每个单页应用的 Chunk 名称就等于文件夹的名称，也就是说 \x3ccode\x3eautoWebPlugin.entry()\x3c\/code\x3e 方法返回的内容其实是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;index\x26quot;:[\x26quot;.\/pages\/index\/index.js\x26quot;,\x26quot;.\/common.css\x26quot;],\n  \x26quot;login\x26quot;:[\x26quot;.\/pages\/login\/index.js\x26quot;,\x26quot;.\/common.css\x26quot;]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22index\x22\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x22.\/pages\/index\/index.js\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22.\/common.css\x22\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22login\x22\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x22.\/pages\/login\/index.js\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22.\/common.css\x22\x3c\/span\x3e]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但这些事情 \x3ccode\x3eAutoWebPlugin\x3c\/code\x3e 都会自动为你完成，你不用操心，明白大致原理即可。   \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3etemplate.html\x3c\/code\x3e 模版文件如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3chtml\x3e\n\x3chead\x3e\n  \x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n  \x3c!--在这注入该页面所依赖但没有手动导入的 CSS--\x3e\n  \x3c!--STYLE--\x3e\n  \x3c!--注入 google_analytics 中的 JS 代码--\x3e\n  \x3cscript src=\x26quot;.\/google_analytics.js?_inline\x26quot;\x3e\x3c\/script\x3e\n  \x3c!--异步加载 Disqus 评论--\x3e\n  \x3cscript src=\x26quot;https:\/\/dive-into-webpack.disqus.com\/embed.js\x26quot; async\x3e\x3c\/script\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n\x3cdiv id=\x26quot;app\x26quot;\x3e\x3c\/div\x3e\n\x3c!--在这注入该页面所依赖但没有手动导入的 JavaScript--\x3e\n\x3c!--SCRIPT--\x3e\n\x3c!--Disqus 评论容器--\x3e\n\x3cdiv id=\x26quot;disqus_thread\x26quot;\x3e\x3c\/div\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--在这注入该页面所依赖但没有手动导入的 CSS--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--STYLE--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--注入 google_analytics 中的 JS 代码--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/google_analytics.js?_inline\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--异步加载 Disqus 评论--\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/dive-into-webpack.disqus.com\/embed.js\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3easync\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--在这注入该页面所依赖但没有手动导入的 JavaScript--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--SCRIPT--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--Disqus 评论容器--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22disqus_thread\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于这个模版文件被当作项目中所有单页应用的模版，就不能再像上一节中直接写 Chunk 的名称去引入资源，因为需要被注入到当前页面的 Chunk 名称是不定的，每个单页应用都会有自己的名称。 \x3ccode\x3e\x26lt;!--STYLE--\x26gt;\x3c\/code\x3e 和 \x3ccode\x3e\x26lt;!--SCRIPT--\x26gt;\x3c\/code\x3e 的作用在于保证该页面所依赖的资源都会被注入到生成的 HTML 模版里去。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eweb-webpack-plugin\x3c\/code\x3e 能分析出每个页面依赖哪些资源，例如对于 \x3ccode\x3elogin.html\x3c\/code\x3e 来说，插件可以确定该页面依赖以下资源：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e所有页面都依赖的公共 CSS 代码 \x3ccode\x3ecommon.css\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e所有页面都依赖的公共 JavaScrip 代码 \x3ccode\x3ecommon.js\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e只有这个页面依赖的 CSS 代码 \x3ccode\x3elogin.css\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e只有这个页面依赖的 JavaScrip 代码 \x3ccode\x3elogin.css\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e由于模版文件 \x3ccode\x3etemplate.html\x3c\/code\x3e 里没有指出引入这些依赖资源的 HTML 语句，插件会自动将没有手动导入但页面依赖的资源按照不同类型注入到 \x3ccode\x3e\x26lt;!--STYLE--\x26gt;\x3c\/code\x3e 和 \x3ccode\x3e\x26lt;!--SCRIPT--\x26gt;\x3c\/code\x3e 所在的位置。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCSS 类型的文件注入到 \x3ccode\x3e\x26lt;!--STYLE--\x26gt;\x3c\/code\x3e 所在的位置，如果 \x3ccode\x3e\x26lt;!--STYLE--\x26gt;\x3c\/code\x3e 不存在就注入到 HTML HEAD 标签的最后；\x3c\/li\x3e\n\x3cli\x3eJavaScrip 类型的文件注入到 \x3ccode\x3e\x26lt;!--SCRIPT--\x26gt;\x3c\/code\x3e 所在的位置，如果 \x3ccode\x3e\x26lt;!--SCRIPT--\x26gt;\x3c\/code\x3e 不存在就注入到 HTML BODY 标签的最后。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果后续有新的页面需要开发，只需要在 \x3ccode\x3epages\x3c\/code\x3e 目录下新建一个目录，目录名称取为输出 HTML 文件的名称，目录下放这个页面相关的代码即可，无需改动构建代码。\x3c\/p\x3e\n\x3cp\x3e由于 \x3ccode\x3eAutoWebPlugin\x3c\/code\x3e 是间接的通过上一节提到的 \x3ccode\x3eWebPlugin\x3c\/code\x3e 实现的，\x3ccode\x3eWebPlugin\x3c\/code\x3e 支持的功能 \x3ccode\x3eAutoWebPlugin\x3c\/code\x3e 都支持。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader28\x22\x3e构建同构应用\x3c\/h1\x3e\n\x3cp\x3e同构应用是指写一份代码但可同时在浏览器和服务器中运行的应用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader29\x22\x3e认识同构应用\x3c\/h2\x3e\n\x3cp\x3e现在大多数单页应用的视图都是通过 JavaScript 代码在浏览器端渲染出来的，但在浏览器端渲染的坏处有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e搜索引擎无法收录你的网页，因为展示出的数据都是在浏览器端异步渲染出来的，大部分爬虫无法获取到这些数据。\x3c\/li\x3e\n\x3cli\x3e对于复杂的单页应用，渲染过程计算量大，对低端移动设备来说可能会有性能问题，用户能明显感知到首屏的渲染延迟。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了解决以上问题，有人提出能否将原本只运行在浏览器中的 JavaScript 渲染代码也在服务器端运行，在服务器端渲染出带内容的 HTML 后再返回。 这样就能让搜索引擎爬虫直接抓取到带数据的 HTML，同时也能降低首屏渲染时间。 由于 Node.js 的流行和成熟，以及虚拟 DOM 提出与实现，使这个假设成为可能。\x3c\/p\x3e\n\x3cp\x3e实际上现在主流的前端框架都支持同构，包括 React、Vue2、Angular2，其中最先支持也是最成熟的同构方案是 React。 由于 React 使用者更多，它们之间又很相似，本节只介绍如何用 Webpack 构建 React 同构应用。\x3c\/p\x3e\n\x3cp\x3e同构应用运行原理的核心在于虚拟 DOM，虚拟 DOM 的意思是不直接操作 DOM 而是通过 JavaScript Object 去描述原本的 DOM 结构。 在需要更新 DOM 时不直接操作 DOM 树，而是通过更新 JavaScript Object 后再映射成 DOM 操作。\x3c\/p\x3e\n\x3cp\x3e虚拟 DOM 的优点在于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e因为操作 DOM 树是高耗时的操作，尽量减少 DOM 树操作能优化网页性能。而 DOM Diff 算法能找出2个不同 Object 的最小差异，得出最小 DOM 操作；\x3c\/li\x3e\n\x3cli\x3e虚拟 DOM 的在渲染的时候不仅仅可以通过操作 DOM 树来表示出结果，也能有其它的表示方式，例如把虚拟 DOM 渲染成字符串(服务器端渲染)，或者渲染成手机 App 原生的 UI 组件( React Native)。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以 React 为例，核心模块 react 负责管理 React 组件的生命周期，而具体的渲染工作可以交给 \x3ccode\x3ereact-dom\x3c\/code\x3e 模块来负责。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ereact-dom\x3c\/code\x3e 在渲染虚拟 DOM 树时有2中方式可选：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e通过 \x3ccode\x3erender()\x3c\/code\x3e 函数去操作浏览器 DOM 树来展示出结果。\x3c\/li\x3e\n\x3cli\x3e通过 \x3ccode\x3erenderToString()\x3c\/code\x3e 计算出表示虚拟 DOM 的 HTML 形式的字符串。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e构建同构应用的最终目的是从一份项目源码中构建出2份 JavaScript 代码，一份用于在浏览器端运行，一份用于在 Node.js 环境中运行渲染出 HTML。 其中用于在 Node.js 环境中运行的 JavaScript 代码需要注意以下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e不能包含浏览器环境提供的 API，例如使用 \x3ccode\x3edocument\x3c\/code\x3e 进行 DOM 操作，因为 Node.js 不支持这些 API；\x3c\/li\x3e\n\x3cli\x3e不能包含 CSS 代码，因为服务端渲染的目的是渲染出 HTML 内容，渲染出 CSS 代码会增加额外的计算量，影响服务端渲染性能；\x3c\/li\x3e\n\x3cli\x3e不能像用于浏览器环境的输出代码那样把 \x3ccode\x3enode_modules\x3c\/code\x3e 里的第三方模块和 Node.js 原生模块(例如 \x3ccode\x3efs\x3c\/code\x3e 模块)打包进去，而是需要通过 CommonJS 规范去引入这些模块。\x3c\/li\x3e\n\x3cli\x3e需要通过 CommonJS 规范导出一个渲染函数，以用于在 HTTP 服务器中去执行这个渲染函数，渲染出 HTML 内容返回。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader30\x22\x3e解决方案\x3c\/h2\x3e\n\x3cp\x3e用于构建浏览器环境代码的 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 配置文件保留不变，新建一个专门用于构建服务端渲染代码的配置文件 \x3ccode\x3ewebpack_server.config.js\x3c\/code\x3e，内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\nconst nodeExternals = require(\x27webpack-node-externals\x27);\n\nmodule.exports = {\n  \/\/ JS 执行入口文件\n  entry: \x27.\/main_server.js\x27,\n  \/\/ 为了不把 Node.js 内置的模块打包进输出文件中，例如 fs net 模块等\n  target: \x27node\x27,\n  \/\/ 为了不把 node_modules 目录下的第三方模块打包进输出文件中\n  externals: [nodeExternals()],\n  output: {\n    \/\/ 为了以 CommonJS2 规范导出渲染函数，以给采用 Node.js 编写的 HTTP 服务调用\n    libraryTarget: \x27commonjs2\x27,\n    \/\/ 把最终可在 Node.js 中运行的代码输出到一个 bundle_server.js 文件\n    filename: \x27bundle_server.js\x27,\n    \/\/ 输出文件都放到 dist 目录下\n    path: path.resolve(__dirname, \x27.\/dist\x27),\n  },\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        use: [\x27babel-loader\x27],\n        exclude: path.resolve(__dirname, \x27node_modules\x27),\n      },\n      {\n        \/\/ CSS 代码不能被打包进用于服务端的代码中去，忽略掉 CSS 文件\n        test: \/\\.css\/,\n        use: [\x27ignore-loader\x27],\n      },\n    ]\n  },\n  devtool: \x27source-map\x27 \/\/ 输出 source-map 方便直接调试 ES6 源码\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nodeExternals = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-node-externals\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS 执行入口文件\x3c\/span\x3e\n  entry: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/main_server.js\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了不把 Node.js 内置的模块打包进输出文件中，例如 fs net 模块等\x3c\/span\x3e\n  target: \x3cspan class=\x22hljs-string\x22\x3e\x27node\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了不把 node_modules 目录下的第三方模块打包进输出文件中\x3c\/span\x3e\n  externals: [nodeExternals()],\n  output: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了以 CommonJS2 规范导出渲染函数，以给采用 Node.js 编写的 HTTP 服务调用\x3c\/span\x3e\n    libraryTarget: \x3cspan class=\x22hljs-string\x22\x3e\x27commonjs2\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把最终可在 Node.js 中运行的代码输出到一个 bundle_server.js 文件\x3c\/span\x3e\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27bundle_server.js\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件都放到 dist 目录下\x3c\/span\x3e\n    path: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27.\/dist\x27\x3c\/span\x3e),\n  },\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader\x27\x3c\/span\x3e],\n        exclude: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e),\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ CSS 代码不能被打包进用于服务端的代码中去，忽略掉 CSS 文件\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27ignore-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 source-map 方便直接调试 ES6 源码\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码有几个关键的地方，分别是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3etarget: \x27node\x27\x3c\/code\x3e 由于输出代码的运行环境是 Node.js，源码中依赖的 Node.js 原生模块没必要打包进去；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eexternals: [nodeExternals()]\x3c\/code\x3e \x3ccode\x3ewebpack-node-externals\x3c\/code\x3e 的目的是为了防止 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下的第三方模块被打包进去，因为 Node.js 默认会去 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下寻找和使用第三方模块；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e{test: \/\\.css\/, use: [\x27ignore-loader\x27]}\x3c\/code\x3e 忽略掉依赖的 CSS 文件，CSS 会影响服务端渲染性能，又是做服务端渲不重要的部分；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3elibraryTarget\x3c\/code\x3e: \x3ccode\x3e\x27commonjs2\x27\x3c\/code\x3e 以 CommonJS2 规范导出渲染函数，以供给采用 Node.js 编写的 HTTP 服务器代码调用。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了最大限度的复用代码，需要调整下目录结构：\x3c\/p\x3e\n\x3cp\x3e把页面的根组件放到一个单独的文件 \x3ccode\x3eAppComponent.js\x3c\/code\x3e，该文件只能包含根组件的代码，不能包含渲染入口的代码，而且需要导出根组件以供给渲染入口调用，\x3ccode\x3eAppComponent.js\x3c\/code\x3e 内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport \x27.\/main.css\x27;\n\nexport class AppComponent extends Component {\n  render() {\n    return \x3ch1\x3eHello,Webpack\x3c\/h1\x3e\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x27.\/main.css\x27;\n\nexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAppComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e,\x3cspan class=\x22hljs-type\x22\x3eWebpack\x3c\/span\x3e\x26lt;\/h1\x26gt;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e分别为不同环境的渲染入口写两份不同的文件，分别是用于浏览器端渲染 DOM 的 \x3ccode\x3emain_browser.js\x3c\/code\x3e 文件，和用于服务端渲染 HTML 字符串的 \x3ccode\x3emain_server.js\x3c\/code\x3e 文件。 \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3emain_browser.js\x3c\/code\x3e 文件内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport { render } from \x27react-dom\x27;\nimport { AppComponent } from \x27.\/AppComponent\x27;\n\n\/\/ 把根组件渲染到 DOM 树上\nrender(\x3cAppComponent\/\x3e, window.document.getElementById(\x27app\x27));\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { render } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { AppComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/AppComponent\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把根组件渲染到 DOM 树上\x3c\/span\x3e\nrender(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eAppComponent\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e));\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emain_server.js\x3c\/code\x3e 文件内容如下：\x3c\/p\x3e\n\x3cp\x3e为了能把渲染的完整 HTML 文件通过 HTTP 服务返回给请求端，还需要通过用 Node.js 编写一个 HTTP 服务器。 由于本节不专注于将 HTTP 服务器的实现，就采用了 ExpressJS 来实现，\x3ccode\x3ehttp_server.js\x3c\/code\x3e 文件内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const express = require(\x27express\x27);\nconst { render } = require(\x27.\/dist\/bundle_server\x27);\nconst app = express();\n\n\/\/ 调用构建出的 bundle_server.js 中暴露出的渲染函数，再拼接下 HTML 模版，形成完整的 HTML 文件\napp.get(\x27\/\x27, function (req, res) {\n  res.send(`\n\x3chtml\x3e\n\x3chead\x3e\n  \x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n\x3cdiv id=\x26quot;app\x26quot;\x3e${render()}\x3c\/div\x3e\n\x3c!--导入 Webpack 输出的用于浏览器端渲染的 JS 文件--\x3e\n\x3cscript src=\x26quot;.\/dist\/bundle_browser.js\x26quot;\x3e\x3c\/script\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\n  `);\n});\n\n\/\/ 其它请求路径返回对应的本地文件\napp.use(express.static(\x27.\x27));\n\napp.listen(3000, function () {\n  console.log(\x27app listening on port 3000!\x27)\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst express = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27express\x27\x3c\/span\x3e);\nconst { render } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/dist\/bundle_server\x27\x3c\/span\x3e);\nconst app = express();\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 调用构建出的 bundle_server.js 中暴露出的渲染函数，再拼接下 HTML 模版，形成完整的 HTML 文件\napp.get(\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e, function (req, res) {\n  res.send(`\x3cspan class=\x22javascript\x22\x3e\n\x26lt;html\x26gt;\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e${render()}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--导入 Webpack 输出的用于浏览器端渲染的 JS 文件--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/dist\/bundle_browser.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  \x3c\/span\x3e`);\n});\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 其它请求路径返回对应的本地文件\napp.use(express.static(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e));\n\napp.listen(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e, function () {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27app listening on port 3000!\x27\x3c\/span\x3e)\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再安装新引入的第三方依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 Webpack 构建依赖\nnpm i -D css-loader style-loader ignore-loader webpack-node-externals\n# 安装 HTTP 服务器依赖\nnpm i -S express\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Webpack 构建依赖\x3c\/span\x3e\nnpm i -D css-loader style-loader ignore-loader webpack-\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-externals\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# 安装 HTTP 服务器依赖\x3c\/span\x3e\nnpm i -S express\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上所有准备工作已经完成，接下来执行构建，编译出目标文件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e执行命令 \x3ccode\x3ewebpack --config webpack_server.config.js\x3c\/code\x3e 构建出用于服务端渲染的 \x3ccode\x3e.\/dist\/bundle_server.js\x3c\/code\x3e 文件。\x3c\/li\x3e\n\x3cli\x3e执行命令 \x3ccode\x3ewebpack\x3c\/code\x3e 构建出用于浏览器环境运行的 \x3ccode\x3e.\/dist\/bundle_browser.js\x3c\/code\x3e 文件，默认的配置文件为 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e构建执行完成后，执行 \x3ccode\x3enode .\/http_server.js\x3c\/code\x3e 启动 HTTP 服务器后，再用浏览器去访问 \x3ca href=\x22http:\/\/localhost\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/localhost\x3c\/a\x3e:3000 就能看到 Hello,Webpack 了。 但是为了验证服务端渲染的结果，你需要打开浏览器的开发工具中的网络抓包一栏，再重新刷新浏览器后，就能抓到请求 HTML 的包了，抓包效果图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012485472?w=2012\x26amp;h=546\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012485472?w=2012\x26amp;h=546\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到服务器返回的是渲染出内容后的 HTML 而不是 HTML 模版，这说明同构应用的改造完成。\x3c\/p\x3e\n\x3cblockquote\x3e本实例提供\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3-11%E6%9E%84%E5%BB%BA%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8.zip\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e项目完整代码\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader31\x22\x3e构建Electron应用\x3c\/h1\x3e\n\x3cp\x3eElectron 是 Node.js 和 Chromium 浏览器的结合体，用 Chromium 浏览器显示出的 Web 页面作为应用的 GUI，通过 Node.js 去和操作系统交互。 当你在 Electron 应用中的一个窗口操作时，实际上是在操作一个网页。当你的操作需要通过操作系统去完成时，网页会通过 Node.js 去和操作系统交互。\x3c\/p\x3e\n\x3cp\x3e采用这种方式开发桌面端应用的优点有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e降低开发门槛，只需掌握网页开发技术和 Node.js 即可，大量的 Web 开发技术和现成库可以复用于 Electron；\x3c\/li\x3e\n\x3cli\x3e由于 Chromium 浏览器和 Node.js 都是跨平台的，Electron 能做到写一份代码在不同的操作系统运行。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在运行 Electron 应用时，会从启动一个主进程开始。主进程的启动是通过 Node.js 去执行一个入口 JavaScript 文件实现的，这个入口文件 \x3ccode\x3emain.js\x3c\/code\x3e 内容如下：\x3c\/p\x3e\n\x3cp\x3e\x26lt;p data-height=\x22565\x22 data-theme-id=\x220\x22 data-slug-hash=\x22vjweQv\x22 data-default-tab=\x22js\x22 data-user=\x22whjin\x22 data-embed-version=\x222\x22 data-pen-title=\x22Electron-main.js\x22 class=\x22codepen\x22\x26gt;See the Pen \x3ca href=\x22https:\/\/codepen.io\/whjin\/pen\/vjweQv\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eElectron-main.js\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22whjin\/pen\/vjweQv\/\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e by whjin (\x3ca href=\x22https:\/\/codepen.io\/whjin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e@whjin\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22whjin\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e) on \x3ca href=\x22https:\/\/codepen.io\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCodePen\x3c\/a\x3e.\x26lt;\/p\x26gt;\x3cbr\x3e\x26lt;script async src=\x22\x3ca href=\x22https:\/\/static.codepen.io\/assets\/embed\/ei.js\x26amp;quot\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/static.codepen.io\/ass...\x3c\/a\x3e;\x26gt;\x26lt;\/script\x26gt;\x3c\/p\x3e\n\x3cp\x3e主进程启动后会一直驻留在后台运行，你眼睛所看得的和操作的窗口并不是主进程，而是由主进程新启动的窗口子进程。\x3c\/p\x3e\n\x3cp\x3e应用从启动到退出有一系列生命周期事件，通过 \x3ccode\x3eelectron.app.on()\x3c\/code\x3e 函数去监听生命周期事件，在特定的时刻做出反应。 例如在 \x3ccode\x3eapp.on(\x27ready\x27)\x3c\/code\x3e 事件中通过 \x3ccode\x3eBrowserWindow\x3c\/code\x3e 去展示应用的主窗口。\x3c\/p\x3e\n\x3cp\x3e启动的窗口其实是一个网页，启动时会去加载在 \x3ccode\x3eloadURL\x3c\/code\x3e 中传入的网页地址。 每个窗口都是一个单独的网页进程，窗口之间的通信需要借助主进程传递消息。\x3c\/p\x3e\n\x3cp\x3e总体来说开发 Electron 应用和开发 Web 应用很相似，区别在于 Electron 的运行环境同时内置了浏览器和 Node.js 的 API，在开发网页时除了可以使用浏览器提供的 API 外，还可以使用 Node.js 提供的 API。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader32\x22\x3e接入 Webpack\x3c\/h2\x3e\n\x3cp\x3e接下来做一个简单的 Electron 应用，要求为应用启动后显示一个主窗口，在主窗口里有一个按钮，点击这个按钮后新显示一个窗口，且使用 React 开发网页。\x3c\/p\x3e\n\x3cp\x3e由于 Electron 应用中的每一个窗口对应一个网页，所以需要开发2个网页，分别是主窗口的 \x3ccode\x3eindex.html\x3c\/code\x3e 和新打开的窗口 \x3ccode\x3elogin.html\x3c\/code\x3e。 \x3c\/p\x3e\n\x3cp\x3e需要改动的地方如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在项目根目录下新建主进程的入口文件 \x3ccode\x3emain.js\x3c\/code\x3e，内容和上面提到的一致；\x3c\/li\x3e\n\x3cli\x3e主窗口网页的代码如下：\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport { render } from \x27react-dom\x27;\nimport { remote } from \x27electron\x27;\nimport path from \x27path\x27;\nimport \x27.\/index.css\x27;\n\nclass App extends Component {\n\n  \/\/ 在按钮被点击时\n  handleBtnClick() {\n    \/\/ 新窗口对应的页面的 URI 地址\n    const modalPath = path.join(\x27file:\/\/\x27, remote.app.getAppPath(), \x27dist\/login.html\x27);\n    \/\/ 新窗口的大小\n    let win = new remote.BrowserWindow({ width: 400, height: 320 })\n    win.on(\x27close\x27, function () {\n      \/\/ 窗口被关闭时清空资源\n      win = null\n    })\n    \/\/ 加载网页\n    win.loadURL(modalPath)\n    \/\/ 显示窗口\n    win.show()\n  }\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3ch1\x3ePage Index\x3c\/h1\x3e\n        \x3cbutton onClick={this.handleBtnClick}\x3eOpen Page Login\x3c\/button\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nrender(\x3cApp\/\x3e, window.document.getElementById(\x27app\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { render } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { remote } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27electron\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e path \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/index.css\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在按钮被点击时\x3c\/span\x3e\n  handleBtnClick() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新窗口对应的页面的 URI 地址\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e modalPath = path.join(\x3cspan class=\x22hljs-string\x22\x3e\x27file:\/\/\x27\x3c\/span\x3e, remote.app.getAppPath(), \x3cspan class=\x22hljs-string\x22\x3e\x27dist\/login.html\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新窗口的大小\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e win = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e remote.BrowserWindow({ \x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e320\x3c\/span\x3e })\n    win.on(\x3cspan class=\x22hljs-string\x22\x3e\x27close\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 窗口被关闭时清空资源\x3c\/span\x3e\n      win = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载网页\x3c\/span\x3e\n    win.loadURL(modalPath)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显示窗口\x3c\/span\x3e\n    win.show()\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3ePage Index\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleBtnClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eOpen Page Login\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\nrender(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eApp\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中最关键的部分在于在按钮点击事件里通过 \x3ccode\x3eelectron\x3c\/code\x3e 库里提供的 API 去新打开一个窗口，并加载网页文件所在的地址。\x3c\/p\x3e\n\x3cp\x3e页面部分的代码已经修改完成，接下来修改构建方面的代码。 这里构建需要做到以下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e构建出2个可在浏览器里运行的网页，分别对应2个窗口的界面；\x3c\/li\x3e\n\x3cli\x3e由于在网页的 JavaScript 代码里可能会有调用 Node.js 原生模块或者 electron 模块，也就是输出的代码依赖这些模块。但由于这些模块都是内置支持的，构建出的代码不能把这些模块打包进去。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e要完成以上要求非常简单，因为 Webpack 内置了对 Electron 的支持。 只需要给 Webpack 配置文件加上一行代码即可，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22target: \x27electron-renderer\x27,\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3etarget:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27electron-renderer\x27\x3c\/span\x3e,\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上修改都完成后重新执行 Webpack 构建，对应的网页需要的代码都输出到了项目根目录下的 \x3ccode\x3edist\x3c\/code\x3e 目录里。\x3c\/p\x3e\n\x3cp\x3e为了以 Electron 应用的形式运行，还需要安装新依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n# 安装 Electron 执行环境到项目中\nnpm i -D electron\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Electron 执行环境到项目中\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D electron\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader33\x22\x3e构建Npm模块\x3c\/h1\x3e\n\x3cp\x3e发布到 Npm 仓库的模块有以下几个特点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e每个模块根目录下都必须有一个描述该模块的 \x3ccode\x3epackage.json\x3c\/code\x3e 文件。该文件描述了模块的入口文件是哪个，该模块又依赖哪些模块等。\x3c\/li\x3e\n\x3cli\x3e模块中的文件以 JavaScript 文件为主，但不限于 JavaScript 文件。例如一个 UI 组件模块可能同时需要 JavaScript、CSS、图片文件等。\x3c\/li\x3e\n\x3cli\x3e模块中的代码大多采用模块化规范，因为你的这个模块可能依赖其它模块，而且别的模块又可能依赖你的这个模块。因为目前支持比较广泛的是 CommonJS 模块化规范，上传到 Npm 仓库的代码最好遵守该规范。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader34\x22\x3e抛出问题\x3c\/h2\x3e\n\x3cp\x3eWebpack 不仅可用于构建运行的应用，也可用于构建上传到 Npm 的模块。 接下来用教大家如何用 Webpack 构建一个可上传的 Npm 仓库的 React 组件，具体要求如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e源代码采用 ES6 写，但发布到 Npm 仓库的需要是 ES5 的，并且遵守 CommonJS 模块化规范。如果发布到 Npm 上去的 ES5 代码是经过转换的，请同时提供 Source Map 以方便调试。\x3c\/li\x3e\n\x3cli\x3e该 UI 组件依赖的其它资源文件例如 CSS 文件也需要包含在发布的模块里。\x3c\/li\x3e\n\x3cli\x3e尽量减少冗余代码，减少发布出去的组件的代码文件大小。\x3c\/li\x3e\n\x3cli\x3e发布出去的组件的代码中不能含有其依赖的模块的代码，而是让用户可选择性的去安装。例如不能内嵌 React 库的代码，这样做的目的是在其它组件也依赖 React 库时，防止 React 库的代码被重复打包。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在开始前先看下最终发布到 Npm 仓库的模块的目录结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22node_modules\/hello-webpack\n├── lib\n│   ├── index.css (组件所有依赖的 CSS 都在这个文件中)\n│   ├── index.css.map\n│   ├── index.js (符合 CommonJS 模块化规范的 ES5 代码)\n│   └── index.js.map\n├── src (ES6 源码)\n│   ├── index.css\n│   └── index.js\n└── package.json (模块描述文件)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enode_modules\/hello-webpack\n├── lib\n│   ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e (组件所有依赖的 CSS 都在这个文件中)\n│   ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.map\x3c\/span\x3e\n│   ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e (符合 CommonJS 模块化规范的 ES5 代码)\n│   └── index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.map\x3c\/span\x3e\n├── src (ES6 源码)\n│   ├── index\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n│   └── index\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n└── package\x3cspan class=\x22hljs-selector-class\x22\x3e.json\x3c\/span\x3e (模块描述文件)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3esrc\/index.js\x3c\/code\x3e 文件，内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport \x27.\/index.css\x27;\n\n\/\/ 导出该组件供给其它模块使用\nexport default class HelloWebpack extends Component {\n  render() {\n    return \x3ch1 className=\x26quot;hello-component\x26quot;\x3eHello,Webpack\x3c\/h1\x3e\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x27.\/index.css\x27;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出该组件供给其它模块使用\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHelloWebpack\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1 className=\x3cspan class=\x22hljs-string\x22\x3e\x22hello-component\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e,\x3cspan class=\x22hljs-type\x22\x3eWebpack\x3c\/span\x3e\x26lt;\/h1\x26gt;\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e要使用该模块时只需要这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 通过 ES6 语法导入\nimport HelloWebpack from \x27hello-webpack\x27;\nimport \x27hello-webpack\/lib\/index.css\x27;\n\n\/\/ 或者通过 ES5 语法导入\nvar HelloWebpack = require(\x27hello-webpack\x27);\nrequire(\x27hello-webpack\/lib\/index.css\x27);\n\n\/\/ 使用 react-dom 渲染\nrender(\x3cHelloWebpack\/\x3e);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 ES6 语法导入\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e HelloWebpack \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hello-webpack\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hello-webpack\/lib\/index.css\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者通过 ES5 语法导入\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e HelloWebpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27hello-webpack\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27hello-webpack\/lib\/index.css\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用 react-dom 渲染\x3c\/span\x3e\nrender(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHelloWebpack\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader35\x22\x3e使用 Webpack 构建 Npm 模块\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e对于要求1，可以这样做到：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 \x3ccode\x3ebabel-loader\x3c\/code\x3e 把 ES6 代码转换成 ES5 的代码。\x3c\/li\x3e\n\x3cli\x3e通过开启 \x3ccode\x3edevtool: \x27source-map\x27\x3c\/code\x3e 输出 Source Map 以发布调试。\x3c\/li\x3e\n\x3cli\x3e设置 \x3ccode\x3eoutput.libraryTarget=\x27commonjs2\x27\x3c\/code\x3e 使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e相关的 Webpack 配置代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  output: {\n    \/\/ 输出的代码符合 CommonJS 模块化规范，以供给其它模块导入使用。\n    libraryTarget: \x27commonjs2\x27,\n  },\n  \/\/ 输出 Source Map\n  devtool: \x27source-map\x27,\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  output: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的代码符合 CommonJS 模块化规范，以供给其它模块导入使用。\x3c\/span\x3e\n    libraryTarget: \x3cspan class=\x22hljs-string\x22\x3e\x27commonjs2\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 Source Map\x3c\/span\x3e\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e,\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e对于要求2，需要通过 \x3ccode\x3ecss-loader\x3c\/code\x3e 和 \x3ccode\x3eextract-text-webpack-plugin\x3c\/code\x3e 实现，相关的 Webpack 配置代码如下：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27);\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        \/\/ 增加对 CSS 文件的支持\n        test: \/\\.css\/,\n        \/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\n        use: ExtractTextPlugin.extract({\n          use: [\x27css-loader\x27]\n        }),\n      },\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      \/\/ 输出的 CSS 文件名称\n      filename: \x27index.css\x27,\n    }),\n  ],\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27extract-text-webpack-plugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 CSS 文件的支持\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\x3c\/span\x3e\n        use: ExtractTextPlugin.extract({\n          use: [\x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e]\n        }),\n      },\n    ]\n  },\n  plugins: [\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的 CSS 文件名称\x3c\/span\x3e\n      filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.css\x27\x3c\/span\x3e,\n    }),\n  ],\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此步引入了3个新依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 Webpack 构建所需要的新依赖\nnpm i -D style-loader css-loader extract-text-webpack-plugin\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Webpack 构建所需要的新依赖\x3c\/span\x3e\nnpm i -D style-loader css-loader extract-\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e-webpack-plugin\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e对于要求3，需要注意的是 Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e例如下面这段 ES6 代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class HelloWebpack extends Component{\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHelloWebpack\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在被转换成能正常运行的 ES5 代码时需要以下2个辅助函数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ebabel-runtime\/helpers\/createClass\x3c\/code\x3e 用于实现 \x3ccode\x3eclass\x3c\/code\x3e 语法\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ebabel-runtime\/helpers\/inherits\x3c\/code\x3e 用于实现 \x3ccode\x3eextends\x3c\/code\x3e 语法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e默认的情况下 Babel 会在每个输出文件中内嵌这些依赖的辅助函数的代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会重复的出现很多次，造成代码冗余。 \x3c\/p\x3e\n\x3cp\x3e为了不让这些辅助函数的代重复出现，可以在依赖它们的时候通过 \x3ccode\x3erequire(\x27babel-runtime\/helpers\/createClass\x27)\x3c\/code\x3e 的方式去导入，这样就能做到只让它们出现一次。 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 插件就是用来做这个事情的。\x3c\/p\x3e\n\x3cp\x3e修改 \x3ccode\x3e.babelrc\x3c\/code\x3e 文件，为其加入 \x3ccode\x3etransform-runtime\x3c\/code\x3e 插件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;plugins\x26quot;: [\n    [\n      \x26quot;transform-runtime\x26quot;,\n      {\n        \/\/ transform-runtime 默认会自动的为你使用的 ES6 API 注入 polyfill\n        \/\/ 假如你在源码中使用了 Promise，输出的代码将会自动注入 require(\x27babel-runtime\/core-js\/Promise\x27) 语句\n        \/\/ polyfill 的注入应该交给模块使用者，因为使用者可能在其它地方已经注入了其它的 Promise polyfill 库\n        \/\/ 所以关闭该功能\n        \x26quot;polyfill\x26quot;: false\n      }\n    ]\n  ]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clojure\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22plugins\x22\x3c\/span\x3e: [\n    [\n      \x3cspan class=\x22hljs-string\x22\x3e\x22transform-runtime\x22\x3c\/span\x3e,\n      {\n        \/\/ transform-runtime 默认会自动的为你使用的 ES6 API 注入 polyfill\n        \/\/ 假如你在源码中使用了 Promise，输出的代码将会自动注入 require(\x3cspan class=\x22hljs-name\x22\x3e\x27babel-runtime\/core-js\/Promise\x27\x3c\/span\x3e) 语句\n        \/\/ polyfill 的注入应该交给模块使用者，因为使用者可能在其它地方已经注入了其它的 Promise polyfill 库\n        \/\/ 所以关闭该功能\n        \x3cspan class=\x22hljs-string\x22\x3e\x22polyfill\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      }\n    ]\n  ]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于加入 \x3ccode\x3ebabel-plugin-transform-runtime\x3c\/code\x3e 后生成的代码中会大量出现类似 \x3ccode\x3erequire(\x27babel-runtime\/helpers\/createClass\x27)\x3c\/code\x3e 这样的语句，所以输出的代码将依赖 \x3ccode\x3ebabel-runtime\x3c\/code\x3e 模块。\x3c\/p\x3e\n\x3cp\x3e此步引入了3个新依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 Webpack 构建所需要的新依赖\nnpm i -D babel-plugin-transform-runtime\n# 安装输出代码运行时所需的新依赖\nnpm i -S babel-runtime\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 Webpack 构建所需要的新依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -D babel-plugin-transform-runtime\n\x3cspan class=\x22hljs-comment\x22\x3e# 安装输出代码运行时所需的新依赖\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i -S babel-runtime\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e对于要求4，需要通过在 \x3ca href=\x22https:\/\/whjin.github.io\/full-stack-development\/posts\/webpack%E9%85%8D%E7%BD%AE.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e其它配置项\x3c\/a\x3e 中介绍过的 \x3ccode\x3eExternals\x3c\/code\x3e 来实现。    \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eExternals 用来告诉 Webpack 要构建的代码中使用了哪些不用被打包的模块，也就是说这些模版是外部环境提供的，Webpack 在打包时可以忽略它们。\x3c\/p\x3e\n\x3cp\x3e相关的 Webpack 配置代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nmodule.exports = {\n  \/\/ 通过正则命中所有以 react 或者 babel-runtime 开头的模块\n  \/\/ 这些模块通过注册在运行环境中的全局变量访问，不用被重复打包进输出的代码里\n  externals: \/^(react|babel-runtime)\/,\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过正则命中所有以 react 或者 babel-runtime 开头的模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这些模块通过注册在运行环境中的全局变量访问，不用被重复打包进输出的代码里\x3c\/span\x3e\n  externals: \/^(react|babel-runtime)\/,\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e开启以上配置后，输出的代码中会存在导入 \x3ccode\x3ereact\x3c\/code\x3e 或者 \x3ccode\x3ebabel-runtime\x3c\/code\x3e 模块的代码，但是它们的 \x3ccode\x3ereact\x3c\/code\x3e 或者 \x3ccode\x3ebabel-runtime\x3c\/code\x3e 的内容不会被包含进去，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[\n    (function (module, exports) {\n        module.exports = require(\x26quot;babel-runtime\/helpers\/inherits\x26quot;);\n    }),\n    (function (module, exports) {\n        module.exports = require(\x26quot;react\x26quot;);\n    })\n]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clojure\x22\x3e\x3ccode\x3e[\n    (\x3cspan class=\x22hljs-name\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-name\x22\x3emodule\x3c\/span\x3e, exports) {\n        module.exports = require(\x3cspan class=\x22hljs-string\x22\x3e\x22babel-runtime\/helpers\/inherits\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    }),\n    (\x3cspan class=\x22hljs-name\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-name\x22\x3emodule\x3c\/span\x3e, exports) {\n        module.exports = require(\x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    })\n]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样就做到了在保持代码正确性的情况下，输出文件不存放 react 或者 babel-runtime 模块的代码。\x3c\/p\x3e\n\x3cp\x3e实际上当你在开发 Npm 模块时，不只需要对 react 和 babel-runtime 模块做这样的处理，而是需要对所有正在开发的模块所依赖的模块进行这样的处理。 因为正在开发的模块所依赖的模块也可能被其它模块所依赖。 当一个项目中一个模块被依赖多次时，Webpack 只会将其打包一次。\x3c\/p\x3e\n\x3cp\x3e完成以上4步后最终的 Webpack 完整配置代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\nconst ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27);\n\nmodule.exports = {\n  \/\/ 模块的入口文件\n  entry: \x27.\/src\/index.js\x27,\n  output: {\n    \/\/ 输出文件的名称\n    filename: \x27index.js\x27,\n    \/\/ 输出文件的存放目录\n    path: path.resolve(__dirname, \x27lib\x27),\n    \/\/ 输出的代码符合 CommonJS 模块化规范，以供给其它模块导入使用。\n    libraryTarget: \x27commonjs2\x27,\n  },\n  \/\/ 通过正则命中所有以 react 或者 babel-runtime 开头的模块，\n  \/\/ 这些模块使用外部的，不能被打包进输出的代码里，防止它们出现多次。\n  externals: \/^(react|babel-runtime)\/,\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        use: [\x27babel-loader\x27],\n        \/\/ 排除 node_modules 目录下的文件，\n        \/\/ node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换。\n        exclude: path.resolve(__dirname, \x27node_modules\x27),\n      },\n      {\n        \/\/ 增加对 CSS 文件的支持\n        test: \/\\.css\/,\n        \/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\n        use: ExtractTextPlugin.extract({\n          use: [\x27css-loader\x27]\n        }),\n      },\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      \/\/ 输出的 CSS 文件名称\n      filename: \x27index.css\x27,\n    }),\n  ],\n  \/\/ 输出 Source Map\n  devtool: \x27source-map\x27,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27extract-text-webpack-plugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块的入口文件\x3c\/span\x3e\n  entry: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/index.js\x27\x3c\/span\x3e,\n  output: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件的名称\x3c\/span\x3e\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.js\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出文件的存放目录\x3c\/span\x3e\n    path: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27lib\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的代码符合 CommonJS 模块化规范，以供给其它模块导入使用。\x3c\/span\x3e\n    libraryTarget: \x3cspan class=\x22hljs-string\x22\x3e\x27commonjs2\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过正则命中所有以 react 或者 babel-runtime 开头的模块，\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这些模块使用外部的，不能被打包进输出的代码里，防止它们出现多次。\x3c\/span\x3e\n  externals: \x3cspan class=\x22hljs-regexp\x22\x3e\/^(react|babel-runtime)\/\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27babel-loader\x27\x3c\/span\x3e],\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除 node_modules 目录下的文件，\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换。\x3c\/span\x3e\n        exclude: path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e),\n      },\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 CSS 文件的支持\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\x3c\/span\x3e\n        use: ExtractTextPlugin.extract({\n          use: [\x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e]\n        }),\n      },\n    ]\n  },\n  plugins: [\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的 CSS 文件名称\x3c\/span\x3e\n      filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.css\x27\x3c\/span\x3e,\n    }),\n  ],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 Source Map\x3c\/span\x3e\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重新执行构建后，你将会在项目目录下看到一个新目录 \x3ccode\x3elib\x3c\/code\x3e，里面放着要发布到 Npm 仓库的最终代码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader36\x22\x3e发布到 Npm\x3c\/h2\x3e\n\x3cp\x3e在把构建出的代码发布到 Npm 仓库前，还需要确保你的模块描述文件 \x3ccode\x3epackage.json\x3c\/code\x3e 是正确配置的。\x3c\/p\x3e\n\x3cp\x3e由于构建出的代码的入口文件是 \x3ccode\x3e.\/lib\/index.js\x3c\/code\x3e，需要修改 \x3ccode\x3epackage.json\x3c\/code\x3e 中的 \x3ccode\x3emain\x3c\/code\x3e 字段如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;main\x26quot;: \x26quot;lib\/index.js\x26quot;,\n  \x26quot;jsnext:main\x26quot;: \x26quot;src\/index.js\x26quot;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22lib\/index.js\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22jsnext:main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22src\/index.js\x22\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中 \x3ccode\x3ejsnext:main\x3c\/code\x3e 字段用于指出采用 ES6 编写的模块入口文件所在的位置。\x3c\/p\x3e\n\x3cp\x3e修改完毕后在项目目录下执行 \x3ccode\x3enpm publish\x3c\/code\x3e 就能把构建出的代码发布到 Npm 仓库中(确保已经 \x3ccode\x3enpm login\x3c\/code\x3e 过)。\x3c\/p\x3e\n\x3cblockquote\x3e如果你想让发布到 Npm 上去的代码保持和源码的目录结构一致，那么用 Webpack 将不在适合。 因为源码是一个个分割的模块化文件，而 Webpack 会把这些模块组合在一起。 虽然 Webpack 输出的文件也可以是采用 CommonJS 模块化语法的，但在有些场景下把所有模块打包成一个文件发布到 Npm 是不适合的。 例如像 Lodash 这样的工具函数库在项目中可能只用到了其中几个工具函数，如果所有工具函数打包在一个文件中，那么所有工具函数都会被打包进去，而保持模块文件的独立能做到只打包进使用到的。 还有就是像 UI 组件库这样由大量独立组件组成的库也和 Lodash 类似。\x3cbr\x3e所以 Webpack 适合于构建完整不可分割的 Npm 模块。\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader37\x22\x3e构建离线应用\x3c\/h1\x3e\n\x3cp\x3e离线应用的核心是离线缓存技术，历史上曾先后出现2种离线离线缓存技术，它们分别是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eAppCache 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。\x3c\/li\x3e\n\x3cli\x3e\n\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Service_Worker_API\/Using_Service_Workers\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eService Workers\x3c\/a\x3e 是目前最新的离线缓存技术，是 Web Worker 的一部分。 它通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/Apps\/Progressive\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePWA\x3c\/a\x3e 应用的关键技术之一。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader38\x22\x3e认识 Service Workers\x3c\/h2\x3e\n\x3cp\x3eService Workers 是一个在浏览器后台运行的脚本，它生命周期完全独立于网页。它无法直接访问 DOM，但可以通过 postMessage 接口发送消息来和 UI 进程通信。 拦截网络请求是 Service Workers 的一个重要功能，通过它能完成离线缓存、编辑响应、过滤响应等功能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader39\x22\x3eService Workers 兼容性\x3c\/h2\x3e\n\x3cp\x3e目前 Chrome、Firefox、Opera 都已经全面支持 Service Workers，但对于移动端浏览器就不太乐观了，只有高版本的 Android 支持。 由于 Service Workers 无法通过注入 \x3ccode\x3epolyfill\x3c\/code\x3e 去实现兼容，所以在你打算使用它前请先调查清楚你的网页的运行场景。\x3c\/p\x3e\n\x3cp\x3e判断浏览器是否支持 Service Workers 的最简单的方法是通过以下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 如果 navigator 对象上存在 serviceWorker 对象，就表示支持\nif (navigator.serviceWorker) {\n  \/\/ 通过 navigator.serviceWorker 使用\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gcode\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 navigator 对象上存在 serviceWorker 对象，就表示支持\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e(navigator.serviceWorker)\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 navigator.serviceWorker 使用\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader40\x22\x3e注册 Service Workers\x3c\/h2\x3e\n\x3cp\x3e要给网页接入 Service Workers，需要在网页加载后注册一个描述 Service Workers 逻辑的脚本。 代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (navigator.serviceWorker) {\n  window.addEventListener(\x27DOMContentLoaded\x27,function() {\n    \/\/ 调用 serviceWorker.register 注册，参数 \/sw.js 为脚本文件所在的 URL 路径\n      navigator.serviceWorker.register(\x27\/sw.js\x27);\n  });\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (navigator.serviceWorker) {\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMContentLoaded\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 serviceWorker.register 注册，参数 \/sw.js 为脚本文件所在的 URL 路径\x3c\/span\x3e\n      navigator.serviceWorker.register(\x3cspan class=\x22hljs-string\x22\x3e\x27\/sw.js\x27\x3c\/span\x3e);\n  });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一旦这个脚本文件被加载，Service Workers 的安装就开始了。这个脚本被安装到浏览器中后，就算用户关闭了当前网页，它仍会存在。 也就是说第一次打开该网页时 Service Workers 的逻辑不会生效，因为脚本还没有被加载和注册，但是以后再次打开该网页时脚本里的逻辑将会生效。\x3c\/p\x3e\n\x3cp\x3e在 Chrome 中可以通过打开网址 \x3ccode\x3echrome:\/\/inspect\/#service-workers\x3c\/code\x3e 来查看当前浏览器中所有注册了的 Service Workers。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader41\x22\x3e使用 Service Workers 实现离线缓存\x3c\/h2\x3e\n\x3cp\x3eService Workers 在注册成功后会在其生命周期中派发出一些事件，通过监听对应的事件在特点的时间节点上做一些事情。\x3c\/p\x3e\n\x3cp\x3e在 Service Workers 脚本中，引入了新的关键字 \x3ccode\x3eself\x3c\/code\x3e 代表当前的 Service Workers 实例。\x3c\/p\x3e\n\x3cp\x3e在 Service Workers 安装成功后会派发出 \x3ccode\x3einstall\x3c\/code\x3e 事件，需要在这个事件中执行缓存资源的逻辑，实现代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当前缓存版本的唯一标识符，用当前时间代替\nvar cacheKey = new Date().toISOString();\n\n\/\/ 需要被缓存的文件的 URL 列表\nvar cacheFileList = [\n  \x27\/index.html\x27,\n  \x27\/app.js\x27,\n  \x27\/app.css\x27\n];\n\n\/\/ 监听 install 事件\nself.addEventListener(\x27install\x27, function (event) {\n  \/\/ 等待所有资源缓存完成时，才可以进行下一步\n  event.waitUntil(\n    caches.open(cacheKey).then(function (cache) {\n      \/\/ 要缓存的文件 URL 列表\n      return cache.addAll(cacheFileList);\n    })\n  );\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前缓存版本的唯一标识符，用当前时间代替\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheKey = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().toISOString();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要被缓存的文件的 URL 列表\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheFileList = [\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\/index.html\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\/app.js\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\/app.css\x27\x3c\/span\x3e\n];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听 install 事件\x3c\/span\x3e\nself.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27install\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待所有资源缓存完成时，才可以进行下一步\x3c\/span\x3e\n  event.waitUntil(\n    caches.open(cacheKey).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecache\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 要缓存的文件 URL 列表\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cache.addAll(cacheFileList);\n    })\n  );\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来需要监听网络请求事件去拦截请求，复用缓存，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22self.addEventListener(\x27fetch\x27, function(event) {\n  event.respondWith(\n    \/\/ 去缓存中查询对应的请求\n    caches.match(event.request).then(function(response) {\n        \/\/ 如果命中本地缓存，就直接返回本地的资源\n        if (response) {\n          return response;\n        }\n        \/\/ 否则就去用 fetch 下载资源\n        return fetch(event.request);\n      }\n    )\n  );\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27fetch\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(event)\x3c\/span\x3e \x3c\/span\x3e{\n  event.respondWith(\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去缓存中查询对应的请求\x3c\/span\x3e\n    caches.match(event.request).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(response)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果命中本地缓存，就直接返回本地的资源\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (response) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则就去用 fetch 下载资源\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetch(event.request);\n      }\n    )\n  );\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上就实现了离线缓存。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader42\x22\x3e更新缓存\x3c\/h2\x3e\n\x3cp\x3e线上的代码有时需要更新和重新发布，如果这个文件被离线缓存了，那就需要 Service Workers 脚本中有对应的逻辑去更新缓存。 这可以通过更新 Service Workers 脚本文件做到。\x3c\/p\x3e\n\x3cp\x3e浏览器针对 Service Workers 有如下机制：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e每次打开接入了 Service Workers 的网页时，浏览器都会去重新下载 Service Workers 脚本文件（所以要注意该脚本文件不能太大），如果发现和当前已经注册过的文件存在字节差异，就将其视为“新服务工作线程”。\x3c\/li\x3e\n\x3cli\x3e新 Service Workers 线程将会启动，且将会触发其 \x3ccode\x3einstall\x3c\/code\x3e 事件。\x3c\/li\x3e\n\x3cli\x3e当网站上当前打开的页面关闭时，旧 Service Workers 线程将会被终止，新 Service Workers 线程将会取得控制权。\x3c\/li\x3e\n\x3cli\x3e新 Service Workers 线程取得控制权后，将会触发其 activate 事件。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e新 Service Workers 线程中的 activate 事件就是最佳的清理旧缓存的时间点，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key \nvar cacheWhitelist = [cacheKey];\n\nself.addEventListener(\x27activate\x27, function(event) {\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          \/\/ 不在白名单的缓存全部清理掉\n          if (cacheWhitelist.indexOf(cacheName) === -1) {\n            \/\/ 删除缓存\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheWhitelist = [cacheKey];\n\nself.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27activate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n  event.waitUntil(\n    caches.keys().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecacheNames\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(\n        cacheNames.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecacheName\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不在白名单的缓存全部清理掉\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cacheWhitelist.indexOf(cacheName) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除缓存\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终完整的代码 Service Workers 脚本代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当前缓存版本的唯一标识符，用当前时间代替\nvar cacheKey = new Date().toISOString();\n\n\/\/ 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key\nvar cacheWhitelist = [cacheKey];\n\n\/\/ 需要被缓存的文件的 URL 列表\nvar cacheFileList = [\n  \x27\/index.html\x27,\n  \x27app.js\x27,\n  \x27app.css\x27\n];\n\n\/\/ 监听 install 事件\nself.addEventListener(\x27install\x27, function (event) {\n  \/\/ 等待所有资源缓存完成时，才可以进行下一步\n  event.waitUntil(\n    caches.open(cacheKey).then(function (cache) {\n      \/\/ 要缓存的文件 URL 列表\n      return cache.addAll(cacheFileList);\n    })\n  );\n});\n\n\/\/ 拦截网络请求\nself.addEventListener(\x27fetch\x27, function (event) {\n  event.respondWith(\n    \/\/ 去缓存中查询对应的请求\n    caches.match(event.request).then(function (response) {\n        \/\/ 如果命中本地缓存，就直接返回本地的资源\n        if (response) {\n          return response;\n        }\n        \/\/ 否则就去用 fetch 下载资源\n        return fetch(event.request);\n      }\n    )\n  );\n});\n\n\/\/ 新 Service Workers 线程取得控制权后，将会触发其 activate 事件\nself.addEventListener(\x27activate\x27, function (event) {\n  event.waitUntil(\n    caches.keys().then(function (cacheNames) {\n      return Promise.all(\n        cacheNames.map(function (cacheName) {\n          \/\/ 不在白名单的缓存全部清理掉\n          if (cacheWhitelist.indexOf(cacheName) === -1) {\n            \/\/ 删除缓存\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前缓存版本的唯一标识符，用当前时间代替\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheKey = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Date().toISOString();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheWhitelist = [cacheKey];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要被缓存的文件的 URL 列表\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheFileList = [\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\/index.html\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27app.js\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27app.css\x27\x3c\/span\x3e\n];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听 install 事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27install\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(event)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待所有资源缓存完成时，才可以进行下一步\x3c\/span\x3e\n  event.waitUntil(\n    caches.open(cacheKey).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(cache)\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 要缓存的文件 URL 列表\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cache.addAll(cacheFileList);\n    })\n  );\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 拦截网络请求\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27fetch\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(event)\x3c\/span\x3e \x3c\/span\x3e{\n  event.respondWith(\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去缓存中查询对应的请求\x3c\/span\x3e\n    caches.match(event.request).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(response)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果命中本地缓存，就直接返回本地的资源\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (response) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则就去用 fetch 下载资源\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetch(event.request);\n      }\n    )\n  );\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新 Service Workers 线程取得控制权后，将会触发其 activate 事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27activate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(event)\x3c\/span\x3e \x3c\/span\x3e{\n  event.waitUntil(\n    caches.keys().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(cacheNames)\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Promise.all(\n        cacheNames.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(cacheName)\x3c\/span\x3e \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不在白名单的缓存全部清理掉\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cacheWhitelist.indexOf(cacheName) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除缓存\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader43\x22\x3e接入 Webpack\x3c\/h2\x3e\n\x3cp\x3e用 Webpack 构建接入 Service Workers 的离线应用要解决的关键问题在于如何生成上面提到的 \x3ccode\x3esw.js\x3c\/code\x3e 文件， 并且\x3ccode\x3esw.js\x3c\/code\x3e文件中的 \x3ccode\x3ecacheFileList\x3c\/code\x3e 变量，代表需要被缓存文件的 URL 列表，需要根据输出文件列表所对应的 URL 来决定，而不是像上面那样写成静态值。\x3c\/p\x3e\n\x3cp\x3e假如构建输出的文件目录结构为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22├── app_4c3e186f.js\n├── app_7cc98ad0.css\n└── index.html\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e├── app_4c3e186f\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n├── app_7cc98ad0\x3cspan class=\x22hljs-selector-class\x22\x3e.css\x3c\/span\x3e\n└── index\x3cspan class=\x22hljs-selector-class\x22\x3e.html\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么 \x3ccode\x3esw.js\x3c\/code\x3e 文件中 \x3ccode\x3ecacheFileList\x3c\/code\x3e 的值应该是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var cacheFileList = [\n  \x27\/index.html\x27,\n  \x27app_4c3e186f.js\x27,\n  \x27app_7cc98ad0.css\x27\n];\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ebnf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3evar cacheFileList\x3c\/span\x3e = [\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\/index.html\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27app_4c3e186f.js\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27app_7cc98ad0.css\x27\x3c\/span\x3e\n];\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWebpack 没有原生功能能完成以上要求，幸好庞大的社区中已经有人为我们做好了一个插件 \x3ca href=\x22https:\/\/github.com\/oliviertassinari\/serviceworker-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eserviceworker-webpack-plugin\x3c\/a\x3e 可以方便的解决以上问题。 使用该插件后的 Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const path = require(\x27path\x27);\nconst ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27);\nconst { WebPlugin } = require(\x27web-webpack-plugin\x27);\nconst ServiceWorkerWebpackPlugin = require(\x27serviceworker-webpack-plugin\x27);\n\nmodule.exports = {\n  entry: {\n    app: \x27.\/main.js\x27\/\/ Chunk app 的 JS 执行入口文件\n  },\n  output: {\n    filename: \x27[name].js\x27,\n    publicPath: \x27\x27,\n  },\n  module: {\n    rules: [\n      {\n        test: \/\\.css\/,\/\/ 增加对 CSS 文件的支持\n        \/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\n        use: ExtractTextPlugin.extract({\n          use: [\x27css-loader\x27] \/\/ 压缩 CSS 代码\n        }),\n      },\n    ]\n  },\n  plugins: [\n    \/\/ 一个 WebPlugin 对应一个 HTML 文件\n    new WebPlugin({\n      template: \x27.\/template.html\x27, \/\/ HTML 模版文件所在的文件路径\n      filename: \x27index.html\x27 \/\/ 输出的 HTML 的文件名称\n    }),\n    new ExtractTextPlugin({\n      filename: `[name].css`,\/\/ 给输出的 CSS 文件名称加上 Hash 值\n    }),\n    new ServiceWorkerWebpackPlugin({\n      \/\/ 自定义的 sw.js 文件所在路径\n      \/\/ ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中\n      entry: path.join(__dirname, \x27sw.js\x27),\n    }),\n  ],\n  devServer: {\n    \/\/ Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。\n    https: true,\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27extract-text-webpack-plugin\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { WebPlugin } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27web-webpack-plugin\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ServiceWorkerWebpackPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27serviceworker-webpack-plugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  entry: {\n    app: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/main.js\x27\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chunk app 的 JS 执行入口文件\x3c\/span\x3e\n  },\n  output: {\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27[name].js\x27\x3c\/span\x3e,\n    publicPath: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 CSS 文件的支持\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取出 Chunk 中的 CSS 代码到单独的文件中\x3c\/span\x3e\n        use: ExtractTextPlugin.extract({\n          use: [\x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 压缩 CSS 代码\x3c\/span\x3e\n        }),\n      },\n    ]\n  },\n  plugins: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个 WebPlugin 对应一个 HTML 文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WebPlugin({\n      template: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/template.html\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HTML 模版文件所在的文件路径\x3c\/span\x3e\n      filename: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出的 HTML 的文件名称\x3c\/span\x3e\n    }),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin({\n      filename: \x3cspan class=\x22hljs-string\x22\x3e`[name].css`\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给输出的 CSS 文件名称加上 Hash 值\x3c\/span\x3e\n    }),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ServiceWorkerWebpackPlugin({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义的 sw.js 文件所在路径\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中\x3c\/span\x3e\n      entry: path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27sw.js\x27\x3c\/span\x3e),\n    }),\n  ],\n  devServer: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。\x3c\/span\x3e\n    https: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上配置有2点需要注意：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e由于 Service Workers 必须在 HTTPS 环境下才能拦截网络请求实现离线缓存，使用在 DevServer https 中提到的方式去实现 HTTPS 服务。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eserviceworker-webpack-plugin\x3c\/code\x3e 插件为了保证灵活性，允许使用者自定义 \x3ccode\x3esw.js\x3c\/code\x3e，构建输出的 \x3ccode\x3esw.js\x3c\/code\x3e 文件中会在头部注入一个变量 \x3ccode\x3eserviceWorkerOption.assets\x3c\/code\x3e 到全局，里面存放着所有需要被缓存的文件的 URL 列表。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e需要修改上面的 \x3ccode\x3esw.js\x3c\/code\x3e 文件中写成了静态值的 \x3ccode\x3ecacheFileList\x3c\/code\x3e 为如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 需要被缓存的文件的 URL 列表\nvar cacheFileList = global.serviceWorkerOption.assets;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要被缓存的文件的 URL 列表\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cacheFileList = \x3cspan class=\x22hljs-keyword\x22\x3eglobal\x3c\/span\x3e.serviceWorkerOption.assets;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上已经完成所有文件的修改，在重新构建前，先安装新引入的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D serviceworker-webpack-plugin webpack-dev-server\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D serviceworker-webpack-plugin webpack-dev-server\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装成功后，在项目根目录下执行 \x3ccode\x3ewebpack-dev-server\x3c\/code\x3e 命令后，DevServer 将以 HTTPS 模式启动。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader44\x22\x3e搭配Npm Script\x3c\/h1\x3e\n\x3cp\x3eNpm Script 是一个任务执行者。 Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 \x3ccode\x3epackage.json\x3c\/code\x3e 文件里面使用 \x3ccode\x3escripts\x3c\/code\x3e 字段定义任务：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;scripts\x26quot;: {\n    \x26quot;dev\x26quot;: \x26quot;node dev.js\x26quot;,\n    \x26quot;pub\x26quot;: \x26quot;node build.js\x26quot;\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22scripts\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22dev\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22node dev.js\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22pub\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22node build.js\x22\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e里面的 \x3ccode\x3escripts\x3c\/code\x3e 字段是一个对象，每一个属性对应一段脚本，以上定义了两个任务 \x3ccode\x3edev\x3c\/code\x3e 和 \x3ccode\x3epub\x3c\/code\x3e。 Npm Script 底层实现原理是通过调用 Shell 去运行脚本命令，例如执行 \x3ccode\x3enpm run pub\x3c\/code\x3e 命令等同于执行命令 \x3ccode\x3enode build.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eNpm Script 还有一个重要的功能是能运行安装到项目目录里的 \x3ccode\x3enode_modules\x3c\/code\x3e 里的可执行模块，例如在通过命令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D webpack\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D webpack\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将 Webpack 安装到项目中后，是无法直接在项目根目录下通过命令 webpack 去执行 Webpack 构建的，而是要通过命令 \x3ccode\x3e.\/node_modules\/.bin\/webpack\x3c\/code\x3e 去执行。\x3c\/p\x3e\n\x3cp\x3eNpm Script 能方便的解决这个问题，只需要在 \x3ccode\x3escripts\x3c\/code\x3e 字段里定义一个任务，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;scripts\x26quot;: {\n    \x26quot;build\x26quot;: \x26quot;webpack\x26quot;\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22scripts\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22build\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22webpack\x22\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eNpm Script 会先去项目目录下的 \x3ccode\x3enode_modules\x3c\/code\x3e 中寻找有没有可执行的 \x3ccode\x3ewebpack\x3c\/code\x3e 文件，如果有就使用本地的，如果没有就使用全局的。 所以现在执行 Webpack 构建只需要通过执行 \x3ccode\x3enpm run build\x3c\/code\x3e 去实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader45\x22\x3eWebpack 为什么需要 Npm Script\x3c\/h2\x3e\n\x3cp\x3eWebpack 只是一个打包模块化代码的工具，并没有提供任何任务管理相关的功能。 但在实际场景中通常不会是只通过执行 webpack 就能完成所有任务的，而是需要多个任务才能完成。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在开发阶段为了提高开发体验，使用 DevServer 做开发，并且需要输出 Source Map 以方便调试，同时还需要开启自动刷新功能。\x3c\/li\x3e\n\x3cli\x3e为了减小发布到线上的代码尺寸，在构建出发布到线上的代码时，需要压缩输出的代码。\x3c\/li\x3e\n\x3cli\x3e在构建完发布到线上的代码后，需要把构建出的代码提交给发布系统。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可以看出要求1和要求2是相互冲突的，其中任务3又依赖任务2。要满足以上三个要求，需要定义三个不同的任务。\x3c\/p\x3e\n\x3cp\x3e接下来通过 Npm Script 来定义上面的3个任务：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;scripts\x26quot;: {\n  \x26quot;dev\x26quot;: \x26quot;webpack-dev-server --open\x26quot;,\n  \x26quot;dist\x26quot;: \x26quot;NODE_ENV=production webpack --config webpack_dist.config.js\x26quot;,\n  \x26quot;pub\x26quot;: \x26quot;npm run dist \x26amp;\x26amp; rsync dist\x26quot;\n},\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22scripts\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-string\x22\x3e\x22dev\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22webpack-dev-server --open\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22dist\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22NODE_ENV=production webpack --config webpack_dist.config.js\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x22pub\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22npm run dist \x26amp;\x26amp; rsync dist\x22\x3c\/span\x3e\n},\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e含义分别是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3edev\x3c\/code\x3e 代表用于开发时执行的任务，通过 DevServer 去启动构建。所以在开发项目时只需执行 \x3ccode\x3enpm run dev\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3edist\x3c\/code\x3e 代表构建出用于发布到线上去的代码，输出到 \x3ccode\x3edist\x3c\/code\x3e 目录中。其中的 \x3ccode\x3eNODE_ENV=production\x3c\/code\x3e 是为了在运行任务时注入环境变量。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epub\x3c\/code\x3e 代表先构建出用于发布到线上去的代码，再同步 \x3ccode\x3edist\x3c\/code\x3e 目录中的文件到发布系统(如何同步文件需根据你所使用的发布系统而定)。所以在开发完后需要发布时只需执行 \x3ccode\x3enpm run pub\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e使用 Npm Script 的好处是把一连串复杂的流程简化成了一个简单的命令，需要时只需要执行对应的那个简短的命令，而不用去手动的重复整个流程。 这会大大的提高我们的效率和降低出错率。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader46\x22\x3e检查代码\x3c\/h1\x3e\n\x3cp\x3e检查代码和 Code Review 很相似，都是去审视提交的代码可能存在的问题。 但 Code Review 一般通过人去执行，而检查代码是通过机器去执行一些自动化的检查。 自动化的检查代码成本更低，实施代价更小。\x3c\/p\x3e\n\x3cp\x3e检查代码主要检查以下几项：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e代码风格：让项目成员强制遵守统一的代码风格，例如如何缩紧、如何写注释等，保障代码可读性，不把时间浪费在争论如何写代码更好看上；\x3c\/li\x3e\n\x3cli\x3e潜在问题：分析出代码在运行过程中可能出现的潜在 Bug。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e目前已经有成熟的工具可以检验诸如 JavaScript、TypeScript、CSS、SCSS 等常用语言。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader47\x22\x3e检查 JavaScript\x3c\/h2\x3e\n\x3cp\x3e目前最常用的 JavaScript 检查工具是 ESlint ，它不仅内置了大量常用的检查规则，还可以通过插件机制做到灵活扩展。\x3c\/p\x3e\n\x3cp\x3eESlint 的使用很简单，在通过：\x3ccode\x3enpm i -g eslint\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e按照到全局后，再在项目目录下执行：\x3ccode\x3eeslint init\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e来新建一个 ESlint 配置文件 \x3ccode\x3e.eslintrc\x3c\/code\x3e，该文件格式为 JSON。\x3c\/p\x3e\n\x3cp\x3e如果你想覆盖默认的检查规则，或者想加入新的检查规则，你需要修改该文件，例如使用以下配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    \/\/ 从 eslint:recommended 中继承所有检查规则\n    \x26quot;extends\x26quot;: \x26quot;eslint:recommended\x26quot;,\n    \/\/ 再自定义一些规则     \n    \x26quot;rules\x26quot;: {\n        \/\/ 需要在每行结尾加 ;        \n        \x26quot;semi\x26quot;: [\x26quot;error\x26quot;, \x26quot;always\x26quot;],\n        \/\/ 需要使用 \x26quot;\x26quot; 包裹字符串         \n        \x26quot;quotes\x26quot;: [\x26quot;error\x26quot;, \x26quot;double\x26quot;]\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode\x3e{\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 从 eslint:recommended 中继承所有检查规则\n    \x3cspan class=\x22hljs-string\x22\x3e\x22extends\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22eslint:recommended\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 再自定义一些规则     \n    \x3cspan class=\x22hljs-string\x22\x3e\x22rules\x22\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 需要在每行结尾加 ;        \n        \x3cspan class=\x22hljs-string\x22\x3e\x22semi\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22always\x22\x3c\/span\x3e],\n        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 需要使用 \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e 包裹字符串         \n        \x3cspan class=\x22hljs-string\x22\x3e\x22quotes\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22double\x22\x3c\/span\x3e]\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e写好配置文件后，再执行：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22eslint yourfile.js\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eeslint yourfile\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e去检查 \x3ccode\x3eyourfile.js\x3c\/code\x3e 文件，如果你的文件没有通过检查，ESlint 会输出错误原因，例如：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader48\x22\x3e检查 TypeScript\x3c\/h2\x3e\n\x3cp\x3eTSLint 是一个和 ESlint 相似的 TypeScript 代码检查工具，区别在于 TSLint 只专注于检查 TypeScript 代码。\x3c\/p\x3e\n\x3cp\x3eTSLint 和 ESlint 的使用方法很相似，首先通过：\x3ccode\x3enpm i -g tslint\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e安装到全局，再去项目根目录下执行：\x3ccode\x3etslint --init\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e生成配置文件\x3ccode\x3e tslint.json\x3c\/code\x3e，在配置好后，再执行：\x3ccode\x3etslint yourfile.ts\x3c\/code\x3e去检查 \x3ccode\x3eyourfile.ts\x3c\/code\x3e 文件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader49\x22\x3e检查 CSS\x3c\/h2\x3e\n\x3cp\x3estylelint 是目前最成熟的 CSS 检查工具，内置了大量检查规则的同时也提供插件机制让用户自定义扩展。 stylelint 基于 PostCSS，能检查任何 PostCSS 能解析的代码，诸如 SCSS、Less 等。\x3c\/p\x3e\n\x3cp\x3e首先通过\x3ccode\x3enpm i -g stylelint\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e安装到全局后，去项目根目录下新建 \x3ccode\x3e.stylelintrc\x3c\/code\x3e 配置文件， 该配置文件格式为 JSON，其格式和 ESLint 的配置相似，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \/\/ 继承 stylelint-config-standard 中的所有检查规则\n  \x26quot;extends\x26quot;: \x26quot;stylelint-config-standard\x26quot;,\n  \/\/ 再自定义检查规则  \n  \x26quot;rules\x26quot;: {\n    \x26quot;at-rule-empty-line-before\x26quot;: null\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承 stylelint-config-standard 中的所有检查规则\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x22extends\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22stylelint-config-standard\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 再自定义检查规则  \x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x22rules\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22at-rule-empty-line-before\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e配置好后，再执行\x3ccode\x3estylelint \x22yourfile.css\x22\x3c\/code\x3e去检查 \x3ccode\x3eyourfile.css\x3c\/code\x3e 文件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader50\x22\x3e结合 Webpack 检查代码\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader51\x22\x3e结合 ESLint\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eeslint-loader\x3c\/code\x3e 可以方便的把 ESLint 整合到 Webpack 中，使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        \/\/ node_modules 目录的下的代码不用检查\n        exclude: \/node_modules\/,\n        loader: \x27eslint-loader\x27,\n        \/\/ 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查\n        enforce: \x27pre\x27,\n      },\n    ],\n  },\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node_modules 目录的下的代码不用检查\x3c\/span\x3e\n        exclude: \x3cspan class=\x22hljs-regexp\x22\x3e\/node_modules\/\x3c\/span\x3e,\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27eslint-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查\x3c\/span\x3e\n        enforce: \x3cspan class=\x22hljs-string\x22\x3e\x27pre\x27\x3c\/span\x3e,\n      },\n    ],\n  },\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接入 eslint-loader 后就能在控制台中看到 ESLint 输出的错误日志了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader52\x22\x3e结合 TSLint\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3etslint-loader\x3c\/code\x3e 是一个和 \x3ccode\x3eeslint-loader\x3c\/code\x3e 相似的 Webpack Loader， 能方便的把 TSLint 整合到 Webpack，其使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        \/\/ node_modules 目录的下的代码不用检查\n        exclude: \/node_modules\/,\n        loader: \x27tslint-loader\x27,\n        \/\/ 把 tslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 tslint-loader 去检查\n        enforce: \x27pre\x27,\n      },\n    ],\n  },\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node_modules 目录的下的代码不用检查\x3c\/span\x3e\n        exclude: \x3cspan class=\x22hljs-regexp\x22\x3e\/node_modules\/\x3c\/span\x3e,\n        loader: \x3cspan class=\x22hljs-string\x22\x3e\x27tslint-loader\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把 tslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 tslint-loader 去检查\x3c\/span\x3e\n        enforce: \x3cspan class=\x22hljs-string\x22\x3e\x27pre\x27\x3c\/span\x3e,\n      },\n    ],\n  },\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader53\x22\x3e结合 stylelint\x3c\/h3\x3e\n\x3cp\x3eStyleLintPlugin 能把 stylelint 整合到 Webpack，其使用方法很简单，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst StyleLintPlugin = require(\x27stylelint-webpack-plugin\x27);\n\nmodule.exports = {\n  \/\/ ...\n  plugins: [\n    new StyleLintPlugin(),\n  ],\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e StyleLintPlugin = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stylelint-webpack-plugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  plugins: [\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e StyleLintPlugin(),\n  ],\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader54\x22\x3e一些建议\x3c\/h2\x3e\n\x3cp\x3e把代码检查功能整合到 Webpack 中会导致以下问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e由于执行检查步骤计算量大，整合到 Webpack 中会导致构建变慢；\x3c\/li\x3e\n\x3cli\x3e在整合代码检查到 Webpack 后，输出的错误信息是通过行号来定位错误的，没有编辑器集成显示错误直观；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了避免以上问题，还可以这样做：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用集成了代码检查功能的编辑器，让编辑器实时直观地显示错误；\x3c\/li\x3e\n\x3cli\x3e把代码检查步骤放到代码提交时，也就是说在代码提交前去调用以上检查工具去检查代码，只有在检查都通过时才提交代码，这样就能保证提交到仓库的代码都是通过了检查的。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你的项目是使用 Git 管理，Git 提供了 Hook 功能能做到在提交代码前触发执行脚本。\x3c\/p\x3e\n\x3cp\x3ehusky 可以方便快速地为项目接入 Git Hook， 执行\x3ccode\x3enpm i -D husky\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e安装 husky 时，husky 会通过 \x3ccode\x3eNpm Script Hook\x3c\/code\x3e 自动配置好 Git Hook，你需要做的只是在 \x3ccode\x3epackage.json\x3c\/code\x3e 文件中定义几个脚本，方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;scripts\x26quot;: {\n    \/\/ 在执行 git commit 前会执行的脚本  \n    \x26quot;precommit\x26quot;: \x26quot;npm run lint\x26quot;,\n    \/\/ 在执行 git push 前会执行的脚本  \n    \x26quot;prepush\x26quot;: \x26quot;lint\x26quot;,\n    \/\/ 调用 eslint、stylelint 等工具检查代码\n    \x26quot;lint\x26quot;: \x26quot;eslint \x26amp;\x26amp; stylelint\x26quot;\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22scripts\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在执行 git commit 前会执行的脚本  \x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22precommit\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22npm run lint\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在执行 git push 前会执行的脚本  \x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22prepush\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22lint\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 eslint、stylelint 等工具检查代码\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22lint\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22eslint \x26amp;\x26amp; stylelint\x22\x3c\/span\x3e\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eprecommit\x3c\/code\x3e 和 \x3ccode\x3eprepush\x3c\/code\x3e 你需要根据自己的情况选择一个，无需两个都设置。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader55\x22\x3e通过 Node.js API 启动 Webpack\x3c\/h1\x3e\n\x3cp\x3eWebpack 除了提供可执行的命令行工具外，还提供可在 Node.js 环境中调用的库。 通过 Webpack 暴露的 API，可直接在 Node.js 程序中调用 Webpack 执行构建。\x3c\/p\x3e\n\x3cp\x3e通过 API 去调用并执行 Webpack 比直接通过可执行文件启动更加灵活，可用在一些特殊场景，下面将教你如何使用 Webpack 提供的 API。\x3c\/p\x3e\n\x3cblockquote\x3eWebpack 其实是一个 Node.js 应用程序，它全部通过 JavaScript 开发完成。 在命令行中执行 \x3ccode\x3ewebpack\x3c\/code\x3e 命令其实等价于执行 \x3ccode\x3enode .\/node_modules\/webpack\/bin\/webpack.js\x3c\/code\x3e。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader56\x22\x3e安装和使用 Webpack 模块\x3c\/h2\x3e\n\x3cp\x3e在调用 Webpack API 前，需要先安装它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D webpack\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D webpack\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装成功后，可以采用以下代码导入 Webpack 模块：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const webpack = require(\x27webpack\x27);\n\n\/\/ ES6 语法\nimport webpack from \x26quot;webpack\x26quot;;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES6 语法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e webpack \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22webpack\x22\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e导出的 \x3ccode\x3ewebpack\x3c\/code\x3e 其实是一个函数，使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack({\n  \/\/ Webpack 配置，和 webpack.config.js 文件一致\n}, (err, stats) =\x3e {\n  if (err || stats.hasErrors()) {\n    \/\/ 构建过程出错\n  }\n  \/\/ 成功执行完构建\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ewebpack\x3c\/span\x3e({\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 配置，和 webpack.config.js 文件一致\x3c\/span\x3e\n}, (err, stats) =\x26gt; {\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eif\x3c\/span\x3e (err || stats.hasErrors()) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构建过程出错\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 成功执行完构建\x3c\/span\x3e\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你的 Webpack 配置写在 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 文件中，可以这样使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 读取 webpack.config.js 文件中的配置\nconst config = require(\x27.\/webpack.config.js\x27);\nwebpack(config , callback);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取 webpack.config.js 文件中的配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.config.js\x27\x3c\/span\x3e);\nwebpack(\x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e , callback);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader57\x22\x3e以监听模式运行\x3c\/h2\x3e\n\x3cp\x3e以上使用 Webpack API 的方法只能执行一次构建，无法以监听模式启动 Webpack，为了在使用 API 时以监听模式启动，需要获取 Compiler 实例，方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 如果不传 callback 回调函数，就会返回一个 Compiler 实例，用于让你去控制启动，而不是像上面那样立即启动\nconst compiler = webpack(config);\n\n\/\/ 调用 compiler.watch 以监听模式启动，返回的 watching 用于关闭监听\nconst watching = compiler.watch({\n  \/\/ watchOptions\n  aggregateTimeout: 300,\n},(err, stats)=\x3e{\n  \/\/ 每次因文件发生变化而重新执行完构建后\n});\n\n\/\/ 调用 watching.close 关闭监听 \nwatching.close(()=\x3e{\n  \/\/ 在监听关闭后\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不传 callback 回调函数，就会返回一个 Compiler 实例，用于让你去控制启动，而不是像上面那样立即启动\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compiler = webpack(config);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 compiler.watch 以监听模式启动，返回的 watching 用于关闭监听\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e watching = compiler.watch({\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ watchOptions\x3c\/span\x3e\n  aggregateTimeout: \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e,\n},\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, stats\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每次因文件发生变化而重新执行完构建后\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 watching.close 关闭监听 \x3c\/span\x3e\nwatching.close(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在监听关闭后\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader58\x22\x3e使用 Webpack Dev Middleware\x3c\/h1\x3e\n\x3cp\x3eDevServer 是一个方便开发的小型 HTTP 服务器， DevServer 其实是基于 \x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-dev-middleware\x3c\/a\x3e 和 Expressjs 实现的， 而 webpack-dev-middleware 其实是 Expressjs 的一个中间件。\x3c\/p\x3e\n\x3cp\x3e也就是说，实现 DevServer 基本功能的代码大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const express = require(\x27express\x27);\nconst webpack = require(\x27webpack\x27);\nconst webpackMiddleware = require(\x27webpack-dev-middleware\x27);\n\n\/\/ 从 webpack.config.js 文件中读取 Webpack 配置 \nconst config = require(\x27.\/webpack.config.js\x27);\n\/\/ 实例化一个 Expressjs app\nconst app = express();\n\n\/\/ 用读取到的 Webpack 配置实例化一个 Compiler\nconst compiler = webpack(config);\n\/\/ 给 app 注册 webpackMiddleware 中间件\napp.use(webpackMiddleware(compiler));\n\/\/ 启动 HTTP 服务器，服务器监听在 3000 端口 \napp.listen(3000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e express = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27express\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpackMiddleware = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-dev-middleware\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从 webpack.config.js 文件中读取 Webpack 配置 \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.config.js\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例化一个 Expressjs app\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = express();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用读取到的 Webpack 配置实例化一个 Compiler\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compiler = webpack(config);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给 app 注册 webpackMiddleware 中间件\x3c\/span\x3e\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(webpackMiddleware(compiler));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启动 HTTP 服务器，服务器监听在 3000 端口 \x3c\/span\x3e\napp.listen(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从以上代码可以看出，从 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 中导出的 \x3ccode\x3ewebpackMiddleware\x3c\/code\x3e 是一个函数，该函数需要接收一个 Compiler 实例。Webpack API 导出的 \x3ccode\x3ewebpack\x3c\/code\x3e 函数会返回一个Compiler 实例。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ewebpackMiddleware\x3c\/code\x3e 函数的返回结果是一个 Expressjs 的中间件，该中间件有以下功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e接收来自 Webpack Compiler 实例输出的文件，但不会把文件输出到硬盘，而是保存在内存中；\x3c\/li\x3e\n\x3cli\x3e往 Expressjs app 上注册路由，拦截 HTTP 收到的请求，根据请求路径响应对应的文件内容；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通过 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 能够将 DevServer 集成到你现有的 HTTP 服务器中，让你现有的 HTTP 服务器能返回 Webpack 构建出的内容，而不是在开发时启动多个 HTTP 服务器。 这特别适用于后端接口服务采用 Node.js 编写的项目。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader59\x22\x3eWebpack Dev Middleware 支持的配置项\x3c\/h2\x3e\n\x3cp\x3e在 Node.js 中调用 webpack-dev-middleware 提供的 API 时，还可以给它传入一些配置项，方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ webpackMiddleware 函数的第二个参数为配置项\napp.use(webpackMiddleware(compiler, {\n    \/\/ webpack-dev-middleware 所有支持的配置项\n    \/\/ 只有 publicPath 属性为必填，其它都是选填项\n\n    \/\/ Webpack 输出资源绑定在 HTTP 服务器上的根目录，\n    \/\/ 和 Webpack 配置中的 publicPath 含义一致 \n    publicPath: \x27\/assets\/\x27,\n\n    \/\/ 不输出 info 类型的日志到控制台，只输出 warn 和 error 类型的日志\n    noInfo: false,\n\n    \/\/ 不输出任何类型的日志到控制台\n    quiet: false,\n\n    \/\/ 切换到懒惰模式，这意味着不监听文件变化，只会在请求到时再去编译对应的文件，\n    \/\/ 这适合页面非常多的项目。\n    lazy: true,\n\n    \/\/ watchOptions\n    \/\/ 只在非懒惰模式下才有效\n    watchOptions: {\n        aggregateTimeout: 300,\n        poll: true\n    },\n\n    \/\/ 默认的 URL 路径, 默认是 \x27index.html\x27.\n    index: \x27index.html\x27,\n\n    \/\/ 自定义 HTTP 头\n    headers: {\x27X-Custom-Header\x27: \x27yes\x27},\n\n    \/\/ 给特定文件后缀的文件添加 HTTP mimeTypes ，作为文件类型映射表\n    mimeTypes: {\x27text\/html\x27: [\x27phtml\x27]},\n\n    \/\/ 统计信息输出样式\n    stats: {\n        colors: true\n    },\n\n    \/\/ 自定义输出日志的展示方法\n    reporter: null,\n\n    \/\/ 开启或关闭服务端渲染\n    serverSideRender: false,\n}));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpackMiddleware 函数的第二个参数为配置项\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eapp\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.use\x3c\/span\x3e(webpackMiddleware(compiler, {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webpack-dev-middleware 所有支持的配置项\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有 publicPath 属性为必填，其它都是选填项\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 输出资源绑定在 HTTP 服务器上的根目录，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 和 Webpack 配置中的 publicPath 含义一致 \x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3epublicPath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/assets\/\x27\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不输出 info 类型的日志到控制台，只输出 warn 和 error 类型的日志\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3enoInfo\x3c\/span\x3e: false,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不输出任何类型的日志到控制台\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3equiet\x3c\/span\x3e: false,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 切换到懒惰模式，这意味着不监听文件变化，只会在请求到时再去编译对应的文件，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这适合页面非常多的项目。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3elazy\x3c\/span\x3e: true,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ watchOptions\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只在非懒惰模式下才有效\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3ewatchOptions\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attribute\x22\x3eaggregateTimeout\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3epoll\x3c\/span\x3e: true\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认的 URL 路径, 默认是 \x27index.html\x27.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3eindex\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27index.html\x27\x3c\/span\x3e,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义 HTTP 头\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3eheaders\x3c\/span\x3e: {\x3cspan class=\x22hljs-string\x22\x3e\x27X-Custom-Header\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27yes\x27\x3c\/span\x3e},\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给特定文件后缀的文件添加 HTTP mimeTypes ，作为文件类型映射表\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3emimeTypes\x3c\/span\x3e: {\x3cspan class=\x22hljs-string\x22\x3e\x27text\/html\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27phtml\x27\x3c\/span\x3e]},\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 统计信息输出样式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3estats\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attribute\x22\x3ecolors\x3c\/span\x3e: true\n    },\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义输出日志的展示方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3ereporter\x3c\/span\x3e: null,\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开启或关闭服务端渲染\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3eserverSideRender\x3c\/span\x3e: false,\n}));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader60\x22\x3eWebpack Dev Middleware 与模块热替换\x3c\/h2\x3e\n\x3cp\x3eDevServer 提供了一个方便的功能，可以做到在监听到文件发生变化时自动替换网页中的老模块，以做到实时预览。 \x3c\/p\x3e\n\x3cp\x3eDevServer 虽然是基于 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 实现的，但 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 并没有实现模块热替换功能，而是 DevServer 自己实现了该功能。\x3c\/p\x3e\n\x3cp\x3e为了在使用 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 时也能使用模块热替换功能去提升开发效率，需要额外的再接入 \x3ca href=\x22https:\/\/github.com\/glenjamin\/webpack-hot-middleware\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-hot-middleware\x3c\/a\x3e。 需要做以下修改才能实现模块热替换。\x3c\/p\x3e\n\x3cp\x3e第1步：修改 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 文件，加入 \x3ccode\x3eHotModuleReplacementPlugin\x3c\/code\x3e 插件，修改如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HotModuleReplacementPlugin = require(\x27webpack\/lib\/HotModuleReplacementPlugin\x27);\n\nmodule.exports = {\n  entry: [\n    \/\/ 为了支持模块热替换，注入代理客户端\n    \x27webpack-hot-middleware\/client\x27,\n    \/\/ JS 执行入口文件\n    \x27.\/src\/main.js\x27\n  ],\n  output: {\n    \/\/ 把所有依赖的模块合并输出到一个 bundle.js 文件\n    filename: \x27bundle.js\x27,\n  },\n  plugins: [\n    \/\/ 为了支持模块热替换，生成 .hot-update.json 文件\n    new HotModuleReplacementPlugin(),\n  ],\n  devtool: \x27source-map\x27,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HotModuleReplacementPlugin = require(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\/lib\/HotModuleReplacementPlugin\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  entry: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了支持模块热替换，注入代理客户端\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x27webpack-hot-middleware\/client\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS 执行入口文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x27.\/src\/main.js\x27\x3c\/span\x3e\n  ],\n  output: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把所有依赖的模块合并输出到一个 bundle.js 文件\x3c\/span\x3e\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27bundle.js\x27\x3c\/span\x3e,\n  },\n  plugins: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了支持模块热替换，生成 .hot-update.json 文件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HotModuleReplacementPlugin(),\n  ],\n  devtool: \x3cspan class=\x22hljs-string\x22\x3e\x27source-map\x27\x3c\/span\x3e,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第2步：修改 HTTP 服务器代码 \x3ccode\x3eserver.js\x3c\/code\x3e 文件，接入 \x3ccode\x3ewebpack-hot-middleware\x3c\/code\x3e 中间件，修改如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const express = require(\x27express\x27);\nconst webpack = require(\x27webpack\x27);\nconst webpackMiddleware = require(\x27webpack-dev-middleware\x27);\n\n\/\/ 从 webpack.config.js 文件中读取 Webpack 配置\nconst config = require(\x27.\/webpack.config.js\x27);\n\/\/ 实例化一个 Expressjs app\nconst app = express();\n\n\/\/ 用读取到的 Webpack 配置实例化一个 Compiler\nconst compiler = webpack(config);\n\/\/ 给 app 注册 webpackMiddleware 中间件\napp.use(webpackMiddleware(compiler));\n\/\/ 为了支持模块热替换，响应用于替换老模块的资源\napp.use(require(\x27webpack-hot-middleware\x27)(compiler));\n\/\/ 把项目根目录作为静态资源目录，用于服务 HTML 文件\napp.use(express.static(\x27.\x27));\n\/\/ 启动 HTTP 服务器，服务器监听在 3000 端口\napp.listen(3000, () =\x3e {\n  console.info(\x27成功监听在 3000\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e express = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27express\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpackMiddleware = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-dev-middleware\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从 webpack.config.js 文件中读取 Webpack 配置\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/webpack.config.js\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例化一个 Expressjs app\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = express();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用读取到的 Webpack 配置实例化一个 Compiler\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compiler = webpack(config);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给 app 注册 webpackMiddleware 中间件\x3c\/span\x3e\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(webpackMiddleware(compiler));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为了支持模块热替换，响应用于替换老模块的资源\x3c\/span\x3e\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack-hot-middleware\x27\x3c\/span\x3e)(compiler));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把项目根目录作为静态资源目录，用于服务 HTML 文件\x3c\/span\x3e\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(express.\x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启动 HTTP 服务器，服务器监听在 3000 端口\x3c\/span\x3e\napp.listen(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e, () =\x26gt; {\n  console.info(\x3cspan class=\x22hljs-string\x22\x3e\x27成功监听在 3000\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第3步：修改执行入口文件 \x3ccode\x3emain.js\x3c\/code\x3e，加入替换逻辑，在文件末尾加入以下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (module.hot) {\n  module.hot.accept();\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crystal\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ehot\x3c\/span\x3e) {\x3c\/span\x3e\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ehot\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eaccept\x3c\/span\x3e();\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第4步：安装新引入的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D webpack-dev-middleware webpack-hot-middleware express\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D webpack-dev-middleware webpack-hot-middleware express\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e安装成功后，通过 \x3ccode\x3enode .\/server.js\x3c\/code\x3e 就能启动一个类似于 DevServer 那样支持模块热替换的自定义 HTTP 服务了。\x3c\/p\x3e\n\x3cblockquote\x3e本实例提供\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3-18%E4%BD%BF%E7%94%A8WebpackDevMiddleware.zip\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e项目完整代码\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader61\x22\x3e加载图片\x3c\/h1\x3e\n\x3cp\x3e在网页中不可避免的会依赖图片资源，例如 PNG、JPG、GIF，下面来教你如何用 Webpack 加载图片资源。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader62\x22\x3e使用 \x3ccode\x3efile-loader\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/webpack-contrib\/file-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efile-loader\x3c\/a\x3e 可以把 JavaScript 和 CSS 中导入图片的语句替换成正确的地址，并同时把文件输出到对应的位置。\x3c\/p\x3e\n\x3cp\x3e例如 CSS 源码是这样写的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#app {\n  background-image: url(.\/imgs\/a.png);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-id\x22\x3e#app\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(.\/imgs\/a.png);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e被 \x3ccode\x3efile-loader\x3c\/code\x3e 转换后输出的 CSS 会变成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#app {\n  background-image: url(5556e1251a78c5afda9ee7dd06ad109b.png);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-id\x22\x3e#app\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(5556e1251a78c5afda9ee7dd06ad109b.png);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e并且在输出目录 \x3ccode\x3edist\x3c\/code\x3e 中也多出 \x3ccode\x3e.\/imgs\/a.png\x3c\/code\x3e 对应的图片文件 \x3ccode\x3ehash.png\x3c\/code\x3e， 输出的文件名是根据文件内容的计算出的 Hash 值。    \x3c\/p\x3e\n\x3cp\x3e同理在 JavaScript 中导入图片的源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import imgB from \x27.\/imgs\/b.png\x27;\n\nwindow.document.getElementById(\x27app\x27).innerHTML = `\n\x3cimg src=\x26quot;${imgB}\x26quot;\/\x3e\n`;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e imgB \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/imgs\/b.png\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e).innerHTML = `\x3cspan class=\x22javascript\x22\x3e\n\x26lt;img src=\x3cspan class=\x22hljs-string\x22\x3e\x22${imgB}\x22\x3c\/span\x3e\/\x26gt;\n\x3c\/span\x3e`;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e经过 \x3ccode\x3efile-loader\x3c\/code\x3e 处理后输出的 JavaScript 代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = __webpack_require__.p \x2b \x26quot;0bcc1f8d385f78e1271ebfca50668429.png\x26quot;;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = __webpack_require__.p \x2b \x3cspan class=\x22hljs-string\x22\x3e\x220bcc1f8d385f78e1271ebfca50668429.png\x22\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说 \x3ccode\x3eimgB\x3c\/code\x3e 的值就是图片对应的 URL 地址。  \x3c\/p\x3e\n\x3cp\x3e在 Webpack 中使用 \x3ccode\x3efile-loader\x3c\/code\x3e 非常简单，相关配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.png$\/,\n        use: [\x27file-loader\x27]\n      }\n    ]\n  }\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.png$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\x27file-loader\x27]\n      }\n    ]\n  }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader63\x22\x3e使用 \x3ccode\x3eurl-loader\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/webpack-contrib\/url-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eurl-loader\x3c\/a\x3e 可以把文件的内容经过 \x3ccode\x3ebase64\x3c\/code\x3e 编码后注入到 JavaScript 或者 CSS 中去。\x3c\/p\x3e\n\x3cp\x3e例如 CSS 源码是这样写的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#app {\n  background-image: url(.\/imgs\/a.png);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-id\x22\x3e#app\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(.\/imgs\/a.png);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e被 \x3ccode\x3eurl-loader\x3c\/code\x3e 转换后输出的 CSS 会变成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#app {\n  background-image: url(data:image\/png;base64,iVBORw01afer...); \/* 结尾省略了剩下的 base64 编码后的数据 *\/\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-id\x22\x3e#app\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(data:image\/png;base64,iVBORw01afer...); \x3cspan class=\x22hljs-comment\x22\x3e\/* 结尾省略了剩下的 base64 编码后的数据 *\/\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同理在 JavaScript 中效果也类似。\x3c\/p\x3e\n\x3cp\x3e从上面的例子中可以看出 \x3ccode\x3eurl-loader\x3c\/code\x3e 会把根据图片内容计算出的 \x3ccode\x3ebase64\x3c\/code\x3e 编码的字符串直接注入到代码中，由于一般的图片数据量巨大，这会导致 JavaScript、CSS 文件也跟着变大。 所以在使用 \x3ccode\x3eurl-loader\x3c\/code\x3e 时一定要注意图片体积不能太大，不然会导致 JavaScript、CSS 文件过大而带来的网页加载缓慢问题。\x3c\/p\x3e\n\x3cp\x3e一般利用 \x3ccode\x3eurl-loader\x3c\/code\x3e 把网页需要用到的小图片资源注入到代码中去，以减少加载次数。因为在 HTTP\/1 协议中，每加载一个资源都需要建立一次 HTTP 链接， 为了一个很小的图片而新建一次 HTTP 连接是不划算的。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eurl-loader\x3c\/code\x3e 考虑到了以上问题，并提供了一个方便的选择 \x3ccode\x3elimit\x3c\/code\x3e，该选项用于控制当文件大小小于 \x3ccode\x3elimit\x3c\/code\x3e 时才使用 \x3ccode\x3eurl-loader\x3c\/code\x3e，否则使用 \x3ccode\x3efallback\x3c\/code\x3e 选项中配置的 \x3ccode\x3eloader\x3c\/code\x3e。 相关 Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.png$\/,\n        use: [{\n          loader: \x27url-loader\x27,\n          options: {\n            \/\/ 30KB 以下的文件采用 url-loader\n            limit: 1024 * 30,\n            \/\/ 否则采用 file-loader，默认值就是 file-loader \n            fallback: \x27file-loader\x27,\n          }\n        }]\n      }\n    ]\n  },\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3emodule.exports\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  module:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    rules:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e[\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        test:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\\.png$\/,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        use:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e[{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e          loader:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27url-loader\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e          options:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3eKB\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e以下的文件采用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eurl-loader\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e            limit:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1024\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e*\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n            \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e否则采用\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3efile-loader，默认值就是\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3efile-loader\x3c\/span\x3e \n\x3cspan class=\x22hljs-attr\x22\x3e            fallback:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27file-loader\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n          \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n        \x3cspan class=\x22hljs-string\x22\x3e}]\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e]\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外，你还可以做以下优化：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e通过 \x3ca href=\x22https:\/\/www.npmjs.com\/package\/imagemin-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimagemin-webpack-plugin\x3c\/a\x3e 压缩图片；\x3c\/li\x3e\n\x3cli\x3e通过 \x3ca href=\x22https:\/\/www.npmjs.com\/package\/webpack-spritesmith\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-spritesmith\x3c\/a\x3e 插件制作雪碧图。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上加载图片的方法同样适用于其它二进制类型的资源，例如 PDF、SWF 等等。\x3c\/p\x3e\n\x3cblockquote\x3e本实例提供\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/3-19%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87url-loader.zip\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e项目完整代码\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader64\x22\x3e加载 SVG\x3c\/h1\x3e\n\x3cp\x3eSVG 作为矢量图的一种标准格式，已经得到了各大浏览器的支持，它也成为了 Web 中矢量图的代名词。 在网页中采用 SVG 代替位图有如下好处：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eSVG 相对于位图更清晰，在任意缩放的情况下后不会破坏图形的清晰度，SVG 能方便地解决高分辨率屏幕下图像显示不清楚的问题。\x3c\/li\x3e\n\x3cli\x3e在图形线条比较简单的情况下，SVG 文件的大小要小于位图，在扁平化 UI 流行的今天，多数情况下 SVG 会更小。\x3c\/li\x3e\n\x3cli\x3e图形相同的 SVG 比对应的高清图有更好的渲染性能。\x3c\/li\x3e\n\x3cli\x3eSVG 采用和 HTML 一致的 XML 语法描述，灵活性很高。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e画图工具能导出一个个 \x3ccode\x3e.svg\x3c\/code\x3e 文件，SVG 的导入方法和图片类似，既可以像下面这样在 CSS 中直接使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22body {\n  background-image: url(.\/svgs\/activity.svg);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ebody\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(.\/svgs\/activity.svg);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也可以在 HTML 中使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cimg src=\x26quot;.\/svgs\/activity.svg\x26quot;\/\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3eimg\x3c\/span\x3e src=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/svgs\/activity.svg\x22\x3c\/span\x3e\/\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说可以直接把 SVG 文件当成一张图片来使用，方法和使用图片时完全一样。\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3efile-loader\x3c\/code\x3e 和使用 \x3ccode\x3eurl-loader\x3c\/code\x3e 对 SVG 来说同样有效，只需要把 Loader test 配置中的文件后缀改成 \x3ccode\x3e.svg\x3c\/code\x3e，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.svg\/,\n        use: [\x27file-loader\x27]\n      }\n    ]\n  },\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.svg\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\x27file-loader\x27]\n      }\n    ]\n  },\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于 SVG 是文本格式的文件，除了以上两种方法外还有其它方法，下面来一一说明。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader65\x22\x3e使用 \x3ccode\x3eraw-loader\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/webpack-contrib\/raw-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eraw-loader\x3c\/a\x3e 可以把文本文件的内容读取出来，注入到 JavaScript 或 CSS 中去。\x3c\/p\x3e\n\x3cp\x3e例如在 JavaScript 中这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import svgContent from \x27.\/svgs\/alert.svg\x27;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e svgContent \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/svgs\/alert.svg\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e经过 \x3ccode\x3eraw-loader\x3c\/code\x3e 处理后输出的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = \x26quot;\x3csvg xmlns=\\\x26quot;http:\/\/www.w3.org\/2000\/svg\\\x26quot;... \x3c\/svg\x3e\x26quot; \/\/ 末尾省略 SVG 内容\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs java\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;svg xmlns=\\\x22http:\/\/www.w3.org\/2000\/svg\\\x22... \x26lt;\/svg\x26gt;\x22\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 末尾省略 SVG 内容\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说 \x3ccode\x3esvgContent\x3c\/code\x3e 的内容就等于字符串形式的 SVG，由于 SVG 本身就是 HTML 元素，在获取到 SVG 内容后，可以直接通过以下代码将 SVG 插入到网页中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nwindow.document.getElementById(\x27app\x27).innerHTML = svgContent;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e).innerHTML = svgContent;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 \x3ccode\x3eraw-loader\x3c\/code\x3e 时相关的 Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.svg$\/,\n        use: [\x27raw-loader\x27]\n      }\n    ]\n  }\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.svg$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\x27raw-loader\x27]\n      }\n    ]\n  }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于 \x3ccode\x3eraw-loader\x3c\/code\x3e 会直接返回 SVG 的文本内容，并且无法通过 CSS 去展示 SVG 的文本内容，因此采用本方法后无法在 CSS 中导入 SVG。 也就是说在 CSS 中不可以出现 \x3ccode\x3ebackground-image: url(.\/svgs\/activity.svg)\x3c\/code\x3e 这样的代码，因为 \x3ccode\x3ebackground-image: url(\x26lt;svg\x26gt;...\x26lt;\/svg\x26gt;)\x3c\/code\x3e 是不合法的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader66\x22\x3e使用 \x3ccode\x3esvg-inline-loader\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/webpack-contrib\/svg-inline-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esvg-inline-loader\x3c\/a\x3e 和上面提到的 \x3ccode\x3eraw-loader\x3c\/code\x3e 非常相似， 不同在于 \x3ccode\x3esvg-inline-loader\x3c\/code\x3e 会分析 SVG 的内容，去除其中不必要的部分代码，以减少 SVG 的文件大小。\x3c\/p\x3e\n\x3cp\x3e在使用画图工具如 Adobe Illustrator、Sketch 制作 SVG 后，在导出时这些工具会生成对网页运行来说不必要的代码。 举个例子，以下是 Sketch 导出的 SVG 的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3csvg class=\x26quot;icon\x26quot; verison=\x26quot;1.1\x26quot; xmlns=\x26quot;http:\/\/www.w3.org\/2000\/svg\x26quot; width=\x26quot;24\x26quot; height=\x26quot;24\x26quot; viewBox=\x26quot;0 0 24 24\x26quot;\n     stroke=\x26quot;#000\x26quot;\x3e\n  \x3ccircle cx=\x26quot;12\x26quot; cy=\x26quot;12\x26quot; r=\x26quot;10\x26quot;\/\x3e\n\x3c\/svg\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x26lt;svg \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22icon\x22\x3c\/span\x3e verison=\x3cspan class=\x22hljs-string\x22\x3e\x221.1\x22\x3c\/span\x3e xmlns=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.w3.org\/2000\/svg\x22\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x2224\x22\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eheight\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x2224\x22\x3c\/span\x3e viewBox=\x3cspan class=\x22hljs-string\x22\x3e\x220 0 24 24\x22\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3estroke\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#000\x22\x3c\/span\x3e\x26gt;\n  \x26lt;\x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e cx=\x3cspan class=\x22hljs-string\x22\x3e\x2212\x22\x3c\/span\x3e cy=\x3cspan class=\x22hljs-string\x22\x3e\x2212\x22\x3c\/span\x3e r=\x3cspan class=\x22hljs-string\x22\x3e\x2210\x22\x3c\/span\x3e\/\x26gt;\n\x26lt;\/svg\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e被 \x3ccode\x3esvg-inline-loader\x3c\/code\x3e 处理后会精简成如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3csvg viewBox=\x26quot;0 0 24 24\x26quot; stroke=\x26quot;#000\x26quot;\x3e\x3ccircle cx=\x26quot;12\x26quot; cy=\x26quot;12\x26quot; r=\x26quot;10\x26quot;\/\x3e\x3c\/svg\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3esvg\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eviewBox\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x220 0 24 24\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estroke\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#000\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecircle\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecx\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x2212\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecy\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x2212\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3er\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x2210\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3esvg\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说 \x3ccode\x3esvg-inline-loader\x3c\/code\x3e 增加了对 SVG 的压缩功能。\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3esvg-inline-loader\x3c\/code\x3e 时相关的 Webpack 配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.svg$\/,\n        use: [\x27svg-inline-loader\x27]\n      }\n    ]\n  }\n};   \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.svg$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\x27svg-inline-loader\x27]\n      }\n    ]\n  }\n};   \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader67\x22\x3e加载 Source Map\x3c\/h1\x3e\n\x3cp\x3e由于在开发过程中经常会使用新语言去开发项目，最后会把源码转换成能在浏览器中直接运行的 JavaScript 代码。 这样做虽能提升开发效率，在调试代码的过程中你会发现生成的代码可读性非常差，这给代码调试带来了不便。\x3c\/p\x3e\n\x3cp\x3eWebpack 支持为转换生成的代码输出对应的 Source Map 文件，以方便在浏览器中能通过源码调试。 控制 Source Map 输出的 Webpack 配置项是 \x3ccode\x3edevtool\x3c\/code\x3e，它有很多选项，下面来一一详细介绍。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3edevtool\x3c\/th\x3e\n\x3cth\x3e含义\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e空\x3c\/td\x3e\n\x3ctd\x3e不生成 Source Map\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3eeval\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e每个 \x3ccode\x3emodule\x3c\/code\x3e 会封装到 \x3ccode\x3eeval\x3c\/code\x3e 里包裹起来执行，并且会在每个 \x3ccode\x3eeval\x3c\/code\x3e 语句的末尾追加注释 \x3ccode\x3e\/\/# sourceURL=webpack:\/\/\/.\/main.js\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3esource-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e会额外生成一个单独 Source Map 文件，并且会在 JavaScript 文件末尾追加 \x3ccode\x3e\/\/# sourceMappingURL=bundle.js.map\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3ehidden-source-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e和 \x3ccode\x3esource-map\x3c\/code\x3e 类似，但不会在 JavaScript 文件末尾追加 \x3ccode\x3e\/\/# sourceMappingURL=bundle.js.map\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3einline-source-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e和 \x3ccode\x3esource-map\x3c\/code\x3e 类似，但不会额外生成一个单独 Source Map 文件，而是把 Source Map 转换成 \x3ccode\x3ebase64\x3c\/code\x3e 编码内嵌到 JavaScript 中\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3eeval-source-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e和 \x3ccode\x3eeval\x3c\/code\x3e 类似，但会把每个模块的 Source Map 转换成 \x3ccode\x3ebase64\x3c\/code\x3e 编码内嵌到 \x3ccode\x3eeval\x3c\/code\x3e 语句的末尾，例如 \x3ccode\x3e\/\/# sourceMappingURL=data:application\/json;charset=utf-8;base64,eyJ2ZXJzaW...\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3echeap-source-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e和 \x3ccode\x3esource-map\x3c\/code\x3e 类似，但生成的 Source Map 文件中没有列信息，因此生成速度更快\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3echeap-module-source-map\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e和 \x3ccode\x3echeap-source-map\x3c\/code\x3e 类似，但会包含 Loader 生成的 Source Map\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e其实以上表格只是列举了 \x3ccode\x3edevtool\x3c\/code\x3e 可能取值的一部分， 它的取值其实可以由 \x3ccode\x3esource-map\x3c\/code\x3e、\x3ccode\x3eeval\x3c\/code\x3e、\x3ccode\x3einline\x3c\/code\x3e、\x3ccode\x3ehidden\x3c\/code\x3e、\x3ccode\x3echeap\x3c\/code\x3e、\x3ccode\x3emodule\x3c\/code\x3e 这六个关键字随意组合而成。 这六个关键字每个都代表一种特性，它们的含义分别是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eeval\x3c\/code\x3e：用 \x3ccode\x3eeval\x3c\/code\x3e 语句包裹需要安装的模块；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esource-map\x3c\/code\x3e：生成独立的 Source Map 文件；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ehidden\x3c\/code\x3e：不在 JavaScript 文件中指出 Source Map 文件所在，这样浏览器就不会自动加载 Source Map；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3einline\x3c\/code\x3e：把生成的 Source Map 转换成 \x3ccode\x3ebase64\x3c\/code\x3e 格式内嵌在 JavaScript 文件中；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3echeap\x3c\/code\x3e：生成的 Source Map 中不会包含列信息，这样计算量更小，输出的 Source Map 文件更小；同时 Loader 输出的 Source Map 不会被采用；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3emodule\x3c\/code\x3e：来自 Loader 的 Source Map 被简单处理成每行一个模块；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader68\x22\x3e该如何选择\x3c\/h2\x3e\n\x3cp\x3e如果你不关心细节和性能，只是想在不出任何差错的情况下调试源码，可以直接设置成 \x3ccode\x3esource-map\x3c\/code\x3e，但这样会造成两个问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3esource-map\x3c\/code\x3e 模式下会输出质量最高最详细的 Source Map，这会造成构建速度缓慢，特别是在开发过程需要频繁修改的时候会增加等待时间；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esource-map\x3c\/code\x3e 模式下会把 Source Map 暴露出去，如果构建发布到线上的代码的 Source Map 暴露出去就等于源码被泄露；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了解决以上两个问题，可以这样做：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在开发环境下把 \x3ccode\x3edevtool\x3c\/code\x3e 设置成 \x3ccode\x3echeap-module-eval-source-map\x3c\/code\x3e，因为生成这种 Source Map 的速度最快，能加速构建。由于在开发环境下不会做代码压缩，Source Map 中即使没有列信息也不会影响断点调试；\x3c\/li\x3e\n\x3cli\x3e在生产环境下把 \x3ccode\x3edevtool\x3c\/code\x3e 设置成 \x3ccode\x3ehidden-source-map\x3c\/code\x3e，意思是生成最详细的 Source Map，但不会把 Source Map 暴露出去。由于在生产环境下会做代码压缩，一个 JavaScript 文件只有一行，所以需要列信息。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e在生产环境下通常不会把 Source Map 上传到 HTTP 服务器让用户获取，而是上传到 JavaScript 错误收集系统，在错误收集系统上根据 Source Map 和收集到的 JavaScript 运行错误堆栈计算出错误所在源码的位置。\x3cp\x3e不要在生产环境下使用 \x3ccode\x3einline\x3c\/code\x3e 模式的 Source Map， 因为这会使 JavaScript 文件变得很大，而且会泄露源码。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader69\x22\x3e加载现有的 Source Map\x3c\/h2\x3e\n\x3cp\x3e有些从 Npm 安装的第三方模块是采用 ES6 或者 TypeScript 编写的，它们在发布时会同时带上编译出来的 JavaScript 文件和对应的 Source Map 文件，以方便你在使用它们出问题的时候调试它们；\x3c\/p\x3e\n\x3cp\x3e默认情况下 Webpack 是不会去加载这些附加的 Source Map 文件的，Webpack 只会在转换过程中生成 Source Map。 为了让 Webpack 加载这些附加的 Source Map 文件，需要安装 \x3ca href=\x22https:\/\/github.com\/webpack-contrib\/source-map-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esource-map-loader\x3c\/a\x3e 。 使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.js$\/,\n        \/\/ 只加载你关心的目录下的 Source Map，以提升构建速度\n        include: [path.resolve(root, \x27node_modules\/some-components\/\x27)],\n        use: [\x27source-map-loader\x27],\n        \/\/ 要把 source-map-loader 的执行顺序放到最前面，如果在 source-map-loader 之前有 Loader 转换了该 JavaScript 文件，会导致 Source Map 映射错误\n        enforce: \x27pre\x27\n      }\n    ]\n  }\n};\n\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只加载你关心的目录下的 Source Map，以提升构建速度\x3c\/span\x3e\n        include: [path.resolve(root, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\/some-components\/\x27\x3c\/span\x3e)],\n        use: [\x3cspan class=\x22hljs-string\x22\x3e\x27source-map-loader\x27\x3c\/span\x3e],\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 要把 source-map-loader 的执行顺序放到最前面，如果在 source-map-loader 之前有 Loader 转换了该 JavaScript 文件，会导致 Source Map 映射错误\x3c\/span\x3e\n        enforce: \x3cspan class=\x22hljs-string\x22\x3e\x27pre\x27\x3c\/span\x3e\n      }\n    ]\n  }\n};\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e由于 \x3ccode\x3esource-map-loader\x3c\/code\x3e 在加载 Source Map 时计算量很大，因此要避免让该 Loader 处理过多的文件，不然会导致构建速度缓慢。 通常会采用 \x3ccode\x3einclude\x3c\/code\x3e 去命中只关心的文件。\x3c\/blockquote\x3e\n\x3cp\x3e再安装新引入的依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -D source-map-loader\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e -D source-map-loader\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重启 Webpack 后，你就能在浏览器中调试 \x3ccode\x3enode_modules\/some-components\/\x3c\/code\x3e 目录下的源码了。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader70\x22\x3e实战总结\x3c\/h1\x3e\n\x3cp\x3e在实际应用中，会遇到各种各样的需求，虽然前面的小节中已经给出了大部分场景需求的解决方案，但还是很难涵盖所有的可能性。 所以你自己需要有能力去分析遇到的问题，然后去寻找对应的解决方案，你可以按照以下思路去分析和解决问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e对所面临的问题本身要了解。例如在用 Webpack 去构建 React 应用时你需要先掌握 React 的基础知识。\x3c\/li\x3e\n\x3cli\x3e找出现实和目标之间的差异。例如在 React 应用的源码中用到了 JSX 语法和 ES6 语法，需要把源码转换成 ES5。\x3c\/li\x3e\n\x3cli\x3e找出从现实到目标的可能路径。例如把新语法转换成 ES5 可以使用 Babel 去转换源码。\x3c\/li\x3e\n\x3cli\x3e搜索社区中有没有现成的针对可能路径的 Webpack 集成方案。例如社区中已经有 \x3ccode\x3ebabel-loader\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e如果找不到现成的方案说明你的需求非常特别，这时候你就需要编写自己的 Loader 或者 Plugin 了。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在解决问题的过程中有以下2点能力很重要：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从一个知识你需要尽可能多的联想到其相关连的知识，这有利于打通你的知识体系,从经验中更快地得出答案。\x3c\/li\x3e\n\x3cli\x3e善于使用搜索引擎去寻找你所面临的问题，这有利于借助他人的经验更快地得出答案，而不是自己重新探索。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e最重要的是你需要多实战，自己去解决问题，这有利于加深你的影响和理解，而不是只看不做。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webpack实战</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000015020658">https://segmentfault.com/a/1190000015020658</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dwajbk6ehhh/" target="_blank">https://alili.tech/archive/dwajbk6ehhh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>