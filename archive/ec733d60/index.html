<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Rest/Spread 属性 • 探索 ES2018 和 ES2019"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Rest/Spread 属性 • 探索 ES2018 和 ES2019 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ec733d60/",
				"appid": "1613049289050283", 
				"title": "Rest/Spread 属性 • 探索 ES2018 和 ES2019 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-21T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7e362e1c/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c317b289/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&text=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&text=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&title=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&is_video=false&description=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fec733d60%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&title=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&title=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&title=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fec733d60%2f&title=Rest%2fSpread%20%e5%b1%9e%e6%80%a7%20%e2%80%a2%20%e6%8e%a2%e7%b4%a2%20ES2018%20%e5%92%8c%20ES2019"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Rest/Spread 属性 • 探索 ES2018 和 ES2019</h1><div class="meta"><div class="postdate"><time datetime="2018-10-21" itemprop="datePublished">2018-10-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch2\x3eRest\/Spread 属性\x3c\/h2\x3e\n\x3cp\x3eSebastian Markbåge的ECMAScript提案『\x3ca href=\x22https:\/\/github.com\/sebmarkbage\/ecmascript-rest-spread\x22\x3eRest\/Spread属性\x3c\/a\x3e』可以：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3erest操作符（…）在对象解构中的使用。目前，该操作符仅适用于数组解构和参数定义。\x3c\/li\x3e\n\x3cli\x3espread操作符（…）在对象字面量中的使用。目前，这个操作符只能在数组字面量和函数以及方法调用中使用。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3\x3e在对象解构中使用rest操作符（...）\x3c\/h3\x3e\n\x3cp\x3e在对象解构模式中，rest操作符（…）将解构源的所有可枚举的属性复制到其操作数中，但对象自面量中已经提及的那些属性除外。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst obj = {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e};\nconst {foo,...rest} = obj;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Same as:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const foo = 1;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const reset = {bar: 2,baz: 3};\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你正在使用对象解构来处理命名参数，rest操作符（…）可以收集其余所有参数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(param1, param2, \x3cspan class=\x22hljs-rest_arg\x22\x3e...rest\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ rest 操作符\x3c\/span\x3e\n    console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27All parameters:\x27\x3c\/span\x3e,\n               {param1,param2,...rest}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ spread 操作符\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e param1 \x2b param2;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e语法限制\x3c\/h4\x3e\n\x3cp\x3e在每个对象字面量的顶层，最多可以使用一次rest操作符，并且必须出现在对象字面量的末尾：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3econst {...rest,foo} = obj; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ SyntaxError\x3c\/span\x3e\nconst {foo,...rest1,...rest2} = obj; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ SyntaxError\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，如果对象字面量是嵌套的，就可以多次使用rest操作符：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3econst obj = {\n\x3cspan class=\x22hljs-symbol\x22\x3e    foo:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e        a:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e        b:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e        c:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    },\n\x3cspan class=\x22hljs-symbol\x22\x3e    bar:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    baz:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\n};\n\x3cspan class=\x22hljs-class\x22\x3econst \x3c\/span\x3e{foo:{a,...rest1},...rest2} = obj;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Same as:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const a = 1;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const rest1 = {b:2,c:3};\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ const rest2 = {bar:4,baz:5};\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e###在对象字面量中使用spread操作符（...） \x3c\/p\x3e\n\x3cp\x3e通过对象字面量创建对象时，spread操作符（…）将其操作数的所有可枚举属性插入到创建的对象中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e\x26gt; const obj = {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e};\n\x26gt; {...obj,\x3cspan class=\x22hljs-string\x22\x3equx:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e}\n{\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3equx:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，即使属性不冲突，顺序也很重要，因为对象会记录插入的顺序：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x26gt; {\x3cspan class=\x22hljs-attribute\x22\x3equx\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,...obj}\n{\x3cspan class=\x22hljs-attribute\x22\x3equx\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,foo:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,bar:\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,baz:\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果属性发生冲突，顺序排在后面的属性值会覆盖前面的属性值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e\x26gt; const obj = {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e};\n\x26gt; {...obj,\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e}\n{\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e}\n\x26gt; {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,...obj}\n{\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebaz:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3espread操作符的常见用例\x3c\/h3\x3e\n\x3cp\x3e在本节中，我们将介绍spread操作符可以在哪些场景中使用。在这些场景中我们还会用到\x3ca href=\x22http:\/\/exploringjs.com\/es6\/ch_oop-besides-classes.html#Object_assign\x22\x3eObject.assign()\x3c\/a\x3e方法，这个方法和spread操作符类似（我们将在后面详细介绍）。\x3c\/p\x3e\n\x3ch4\x3e克隆对象\x3c\/h4\x3e\n\x3cp\x3e克隆对象Obj的可枚举属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs mipsasm\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3eclone1 \x3c\/span\x3e= {...obj}\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst \x3cspan class=\x22hljs-keyword\x22\x3eclone2 \x3c\/span\x3e= Object.assign({},...obj)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e克隆对象的原型总是Object.prototype，通过对象字面量创建的对象的原型默认也是Object.prototype：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(clone1) === \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype\n\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\n\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(clone2) === \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype\n\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\n\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf({}) === \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype\n\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e克隆一个对象Obj，包括它的原型：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clone1 = {__proto__: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(obj),...obj};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clone2 = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(obj)),obj\n);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，对象字面量中的\x3cstrong\x3eProto\x3c\/strong\x3e只是Web浏览器中实现的属性，一般来说，在javascript引擎中没有实现。（译者注：当\x3ccode\x3eObject.prototype.__proto__\x3c\/code\x3e 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/getPrototypeOf\x22\x3e\x3ccode\x3eObject.getPrototypeOf()\x3c\/code\x3e\x3c\/a\x3e）\x3c\/p\x3e\n\x3ch4\x3e真正的克隆对象\x3c\/h4\x3e\n\x3cp\x3e有时我们需要忠实地复制一个对象Obj的所有属性，包括（writable,enumerable,…）getter和setter。这时Object.assign()和spread操作符就不在起作用，我们需要使用\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch17.html#property_attributes\x22\x3e属性描述符\x3c\/a\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clone1 = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties({},\n   \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptors(obj)                                    \n);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/exploringjs.com\/es2016-es2017\/ch_object-getownpropertydescriptors.html\x22\x3eObject.getOwnPropertyDescriptors()\x3c\/a\x3e在『探索ES2016和ES2017』中有解释。\x3c\/p\x3e\n\x3ch4\x3e陷阱：克隆总是浅拷贝\x3c\/h4\x3e\n\x3cp\x3e请记住，通过之前讲过几种克隆方法，我们只能得到浅拷贝：如果其中的一个原始属性值是对象，则克隆将引用同一对象，但不会（递归地，深入地）克隆自己：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stata\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e original = {\x3cspan class=\x22hljs-keyword\x22\x3eprop\x3c\/span\x3e:{}};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clone = Object.assign({},original);\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(original.\x3cspan class=\x22hljs-keyword\x22\x3eprop\x3c\/span\x3e === clone.\x3cspan class=\x22hljs-keyword\x22\x3eprop\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\noriginal.\x3cspan class=\x22hljs-keyword\x22\x3eprop\x3c\/span\x3e.foo = \x27abc\x27;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(clone.\x3cspan class=\x22hljs-keyword\x22\x3eprop\x3c\/span\x3e.foo); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ abc\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e各种其他用例\x3c\/h4\x3e\n\x3cp\x3e合并两个对象obj1和obj2：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst merged\x3c\/span\x3e = {...obj1,...obj2};\n\x3cspan class=\x22hljs-attribute\x22\x3econst merged\x3c\/span\x3e = Object.assign({},obj1,obj2);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e填写用户数据的默认值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e DEFAULTS = {foo:\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,bar:\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e userData = {foo:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {...DEFAULTS,...userData};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assigin({},DEFAULTS,userData);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {foo:1,bar:\x27b\x27}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e非破坏性地更新foo属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3econst obj = {foo: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, bar: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e};\nconst obj2 = {...obj, foo: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\nconst obj2 = Object.assign({}, obj, {foo: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e});\n\/\/ {foo: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, bar: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为内联属性foo和bar指定默认值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst userData = {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\nconst data = {\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e,...userData};\nconst data = Object.assign({},{\x3cspan class=\x22hljs-string\x22\x3efoo:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3ebar:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e},userData);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {foo:1,bar:\x27b}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3eSpread与Object.assign()\x3c\/h3\x3e\n\x3cp\x3espread操作符和Object.assign()非常相似，两者的主要区别是spread定义新的属性，但Object.assign()设置它们。我们会在后面解释到底是什么意思。\x3c\/p\x3e\n\x3ch4\x3e使用Object.assign()的两种方式\x3c\/h4\x3e\n\x3cp\x3e使用Object.assign()这里有两种方式：\x3c\/p\x3e\n\x3cp\x3e第一种方式：破坏性地（现有的对象会被改变）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs fortran\x22\x3eObject.\x3cspan class=\x22hljs-keyword\x22\x3eassign\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e, source1, source2);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码中，target会被改变；source1和source2被复制到target中。\x3c\/p\x3e\n\x3cp\x3e第二种方式：非破坏性地（现有的对象不会被改变）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs autoit\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = Object.\x3cspan class=\x22hljs-built_in\x22\x3eassign\x3c\/span\x3e({}, source1, source2)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码中，通过对象字面量创建了一个空对象，并且source1和source2被复制到其中。\x3c\/p\x3e\n\x3cp\x3espread操作符与使用Object.assign()的第二种方式非常相似。接下来，我们就来看看两者的相似之处以及它们的不同之处。\x3c\/p\x3e\n\x3ch4\x3espread和Object.assign()都是通过\x22get \x22取值\x3c\/h4\x3e\n\x3cp\x3e两个操作都是通过「get」从源对象读取属性，然后再把取到的属性写入目标对象。结果，在这个过程中，getters变成了普通的数据属性。\x3c\/p\x3e\n\x3cp\x3e下面来看个例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e original = {\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e;\n    }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eoriginal的getter为foo（它的\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch17.html#property_attributes\x22\x3e属性描述符\x3c\/a\x3e有get和set属性)\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x26gt; Object.getOwnPropertyDescriptor(original, \x27foo\x27)\n{ get: [Function: foo],\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e  set:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eundefined,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  configurable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但它的克隆clone1和clone2，foo是一个普通的数据属性（它的属性描述符具有属性值并且是可写的）\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x26gt; const clone1 = {...original};\n\x26gt; Object.getOwnPropertyDescriptor(clone1, \x27foo\x27)\n{ value: 123,\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e  writable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  configurable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-string\x22\x3e\x26gt; const clone2 = Object.assign({}, original);\n\x26gt; Object.getOwnPropertyDescriptor(clone2, \x27foo\x27)\n{ value: 123,\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e  writable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  configurable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3eSpread定义属性，Object.assign()设置属性\x3c\/h3\x3e\n\x3cp\x3espread操作符在目标对象中定义新属性，Object.assign()通过『set』来创建属性，这有两个后果。\x3c\/p\x3e\n\x3ch5\x3e使用setter的目标对象\x3c\/h5\x3e\n\x3cp\x3e首先，Object.assign()会触发setters，但spread不会触发：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x27foo\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e(value) {\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27SET\x27\x3c\/span\x3e, value);\n    },\n});\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {foo: \x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这段代码插入了一个能被所有普通对象继承的setter foo。\x3c\/p\x3e\n\x3cp\x3e如果我们通过Object.assign()克隆obj，则会触发这个继承的setter：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x26gt; \x3cspan class=\x22hljs-selector-tag\x22\x3eObject\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.assign\x3c\/span\x3e({}, \x3cspan class=\x22hljs-selector-tag\x22\x3eobj\x3c\/span\x3e)\n\x3cspan class=\x22hljs-selector-tag\x22\x3eSET\x3c\/span\x3e 123\n{}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用spread操作符，则不会：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dust\x22\x3e\x3cspan class=\x22xml\x22\x3e\x26gt; \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ ...obj }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ foo: 123 }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eObject.assign()也会在复制期间触发自己的setter，它不会覆盖它们。\x3c\/p\x3e\n\x3ch5\x3e具有只读属性的目标对象\x3c\/h5\x3e\n\x3cp\x3e另外，通过继承只读属性Object.assign()可以停止创建自己的属性，但spread操作符不能。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e, {\n    writable: \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e,\n    value: \x3cspan class=\x22hljs-string\x22\x3e\x27abc\x27\x3c\/span\x3e,\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这段代码插入了一个能被所有普通对象继承的只读属性bar。\x3c\/p\x3e\n\x3cp\x3e这样的话，就不能再通过赋值来创建自己的属性bar（只会在严格模式下得到一个异常;在非严格模式下，设置失败不会有异常提示）\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs delphi\x22\x3e\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-comment\x22\x3e{}\x3c\/span\x3e;\n\x26gt; tmp.bar = \x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e;\nTypeError: Cannot assign \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eread\x3c\/span\x3e only \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在下面的代码中，我们通过字面量成功创建了属性bar。这是有效的，因为字面量不设置属性，它们\x3cstrong\x3e定义\x3c\/strong\x3e属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst obj\x3c\/span\x3e = {bar: 123};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，Object.assgin()通过赋值来创建属性，这就是为什么我们无法克隆obj的原因：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs delphi\x22\x3e\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.assign(\x3cspan class=\x22hljs-comment\x22\x3e{}\x3c\/span\x3e, obj)\nTypeError: Cannot assign \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eread\x3c\/span\x3e only \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用spread操作符是可以克隆的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dust\x22\x3e\x3cspan class=\x22xml\x22\x3e\x26gt; \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ ...obj }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ bar: 123 }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3espread和Object.assign()都只考虑自己的枚举属性\x3c\/h4\x3e\n\x3cp\x3e两个操作都忽略所有继承的属性和所有不可枚举的属性。\x3c\/p\x3e\n\x3cp\x3e下面的obj对象继承了proto中的一个（可枚举）属性，并且有两个自己的属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eproto\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    inheritedEnumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eobj\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eObject.create(proto,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    ownEnumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        value:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    ownNonEnumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        value:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        enumerable:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e});\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你克隆obj，结果只有属性ownEnumerable。不会复制inheritedEnumerable和ownNonEnumerable属性：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dust\x22\x3e\x3cspan class=\x22xml\x22\x3e\x26gt; \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{...obj}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ ownEnumerable: 2 }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x26gt; Object.assign(\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e, obj)\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{ ownEnumerable: 2 }\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/rest-spread-properties-exploring-es2018-and-es2019">www.zcfy.cc</a> 原文标题: Rest/Spread 属性 • 探索 ES2018 和 ES2019 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/ec733d60/" target="_blank">https://alili.tech/archive/ec733d60/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>