<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tutorial: GraphQL 订阅 (客户端)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Tutorial: GraphQL 订阅 (客户端) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ed7f0275/",
				"appid": "1613049289050283", 
				"title": "Tutorial: GraphQL 订阅 (客户端) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-21T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/28e8dc11/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7e362e1c/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&text=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&text=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&is_video=false&description=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fed7f0275%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%20%28%e5%ae%a2%e6%88%b7%e7%ab%af%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Tutorial: GraphQL 订阅 (客户端)</h1><div class="meta"><div class="postdate"><time datetime="2018-10-21" itemprop="datePublished">2018-10-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e这是我们全栈GraphQL \x2b React教程的第7部分，它指导您创建消息传递应用程序。 这个系列的每个部分都是独立的，并着重于一些新的主题，所以您可以直接跳到您感兴趣的部分或整个系列。 以下是我们迄今为止所涉及的内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b\x22\x3ePart 1: 创建一个简单的客户端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-part-2-server-99d0528c7928\x22\x3ePart 2: 创建一个简单的服务器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-mutations-764d7ec23c15\x22\x3ePart 3: 编写Mutation并保持客户端同步\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3ePart 4: 友好的用户界面和客户端存储更新\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-input-types-and-client-caching-f11fa0421cfd\x22\x3ePart 5: 输入类型和自定义解析器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-server-side-e51c32dc2951\x22\x3ePart 6: 服务器上的GraphQL订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3ePart 7: 客户端订阅 (这一节!)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823\x22\x3ePart 8: 分页\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e在第6部分中，我们为message channels实现了GraphQL订阅服务器端的部分。 客户端可以使用这些订阅在特定事件发生时收到通知 - 在这种情况下，可以在指定channel中创建消息。 在本教程中，我们将向客户端添加GraphQL订阅，以便客户端实例可以看到信道中消息的实时更新。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e让我们开始克隆Git仓库并安装依赖关系：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3egit \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehttps\x3c\/span\x3e:\/\/github.com\/apollographql\/graphql-tutorial.gitcd graphql-tutorialgit checkout t7-startcd server \x26amp;\x26amp; npm installcd ..\/client \x26amp;\x26amp; npm install\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e首先，通过启动服务器和客户端来确保一切运行正常。 \x3c\/p\x3e\n\x3cp\x3e在一个终端会话中，我们启动将在端口4000上运行的服务器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servernpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在另一个会话中，我们启动将在端口3000上运行的客户端：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e clientnpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01339d810107e8272f.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e当你在你的浏览器中浏览 \x3ca href=\x22http:\/\/localhost:3000\x22\x3ehttp:\/\/localhost:3000\x3c\/a\x3e 的时候, 你应该进入我们的消息应用程序的主页，其中有一个用户创建的频道列表。 点击其中一个频道，你会看到我们创建的详细视图 \x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-input-types-and-client-caching-f11fa0421cfd\x22\x3ePart 5\x3c\/a\x3e, 您可以在该频道中添加新消息。 您会注意到，如果您在多个窗口中打开相同频道，则在一个窗口中添加的消息不会显示在另一个窗口中。 到本教程结束时，客户端同步将允许多个用户查看彼此的更改！\x3c\/p\x3e\n\x3ch4\x3eGraphQL订阅传输\x3c\/h4\x3e\n\x3cp\x3e向客户端添加订阅的第一步是设置客户端和服务器将通过的WebSocket连接。 形成和维护WebSocket连接将是client \/ src \/ App.js中定义的Apollo网络接口的工作。 为了将WebSocket支持添加到我们现有的接口中，我们将构建一个GraphQL订阅客户端并将其与我们现有的网络接口合并，以创建一个新的接口，该接口通过HTTP执行正常的GraphQL查询并通过WebSockets执行订阅查询。\x3c\/p\x3e\n\x3cp\x3e首先，我们在client \/ src \/ App.js的顶部添加必要的导入\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { SubscriptionClient, addGraphQLSubscriptions } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27subscriptions-transport-ws\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，我们构建基于WebSocket的订阅客户端并将其与我们现有的网络接口合并\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst networkInterface\x3c\/span\x3e = createNetworkInterface({ uri:\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/localhost:4000\/graphql\x27\x3c\/span\x3e });\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs elixir\x22\x3enetworkInterface.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e([{  applyMiddleware(req, \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e) {    setTimeout(\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e);\n},}]);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e wsClient = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubscriptionClient(ws:\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost:4000\/subscriptions, {  reconnect: true,});\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst networkInterfaceWithSubscriptions\x3c\/span\x3e = addGraphQLSubscriptions(  networkInterface,  wsClient,);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在我们需要做的只是在我们的应用程序中启用订阅，就是使用networkInterfaceWithSubscriptions作为Apollo客户端的网络接口\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst\x3cspan class=\x22hljs-built_in\x22\x3e client \x3c\/span\x3e= new ApolloClient({  networkInterface: networkInterfaceWithSubscriptions,  \x3cspan class=\x22hljs-built_in\x22\x3e..\x3c\/span\x3e.});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果加载客户端并查看开发人员工具的“网络”选项卡（右键单击和“检查元素”），您应该看到客户端已建立与服务器的WebSocket连接。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0122490deaca06e620.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e监听消息\x3c\/h4\x3e\n\x3cp\x3e现在我们可以在客户端中使用GraphQL订阅，下一步就是使用订阅来检测消息的创建。 我们的目标是使用订阅来更新我们的React视图，以便在添加频道时查看频道中的新消息。\x3c\/p\x3e\n\x3cp\x3e在我们开始之前，我们必须将客户端\/ src \/ components \/ ChannelDetails.js组件重构为完整的ES6类组件，而不仅仅是一个函数，以便我们可以使用React生命周期事件来设置订阅。\x3c\/p\x3e\n\x3cp\x3e首先，我们更新我们的import语句以包含Component类。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后，我们将我们的功能组件重构为ES6类\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChannelDetails\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  render() {    const { data: {loading, error, channel }, \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (loading) {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ;\n}    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (error) {      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {error.message};\n}    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(channel === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e){      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e     }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3e    return\x3c\/span\x3e (                        {channel.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e}                      );\n}}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在我们的组件已准备好处理订阅，我们可以写出订阅查询：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3econst messagesSubscription = gql  subscription messageAdded($channelId: ID!) {    messageAdded(channelId: $channelId) {      id      text    }  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e为了提出订阅请求，我们将使用Apollo Client的subscribeToMore功能，当我们收到新数据时，我们可以让我们更新商店。 首先，我们在组件中定义一个componentWillMount，这是我们开始订阅的地方。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChannelDetails\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  componentWillMount() {  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e  render() {    ...  }}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这个React生命周期函数中，我们设置了我们的订阅来收听新消息，并在他们出现时将它们添加到我们的本地存储。 因为updateQuery函数应该根据prev（先前的存储状态）生成一个新的存储状态实例，所以我们使用Object.assign方法创建存储的副本并添加新消息进行修改。 \x3c\/p\x3e\n\x3cp\x3e另外，因为我们手动管理我们的消息存储，所以可能会有重复的消息。 一条消息可以在执行mutation时添加一次，并在收到订阅通知时再次添加。 为了防止重复，我们添加了一个额外的检查来验证我们是否已将消息添加到具有先前mutation的存储中。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3ecomponentWillMount() {  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.subscribeToMore({    document: messagesSubscription,    variables: {      channelId: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.match.params.channelId,    },    updateQuery: (prev, {subscriptionData}) =\x26gt; {      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!subscriptionData.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e) {        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e prev;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3e      const \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e = subscriptionData.data.messageAdded;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ don\x27t double add the message      if (!prev.channel.messages.find((msg) =\x26gt; msg.id === newMessage.id)) {        return Object.assign({}, prev, {          channel: Object.assign({}, prev.channel, {            messages: [...prev.channel.messages, newMessage],          })        });\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e prev;\n}    }  });}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们现在快完成了！ 我们所要做的就是在AddMessage组件中执行相同的重复数据删除检查，因为当我们创建新的消息时，我们可能会在查询返回数据之前通过WebSocket通知创建。 在client\/src\/components\/AddMessage.js中，替换data.channel.messages.push（addMessage）; 用相同的语句包装在检查重复的条件下\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs armasm\x22\x3e\x3cspan class=\x22hljs-symbol\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-meta\x22\x3edata\x3c\/span\x3e.channel.messages.find((msg) =\x26gt; msg.id === \x3cspan class=\x22hljs-keyword\x22\x3eaddMessage.id)){ \x3c\/span\x3e \/\/ \x3cspan class=\x22hljs-keyword\x22\x3eAdd \x3c\/span\x3eour Message from the mutation to the \x3cspan class=\x22hljs-meta\x22\x3eend\x3c\/span\x3e.  \x3cspan class=\x22hljs-meta\x22\x3edata\x3c\/span\x3e.channel.messages.\x3cspan class=\x22hljs-keyword\x22\x3epush(addMessage);}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在我们准备测试我们的基于订阅的实时更新消息视图！ 打开客户端的两个窗口，并在两个窗口中选择相同的通道。 当您在一个客户端添加消息时，您应该看到在另一个客户端显示相同的消息！\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0101c68c44cab4fc50.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e结论\x3c\/h4\x3e\n\x3cp\x3e恭喜！ 现在，您已通过Apollo将GraphQL订阅的服务器端实现连接到客户端，以便用户可以看到来自其他客户端的消息添加的实时更新。 在下一个[教程]（\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823）\x22\x3ehttps:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823）\x3c\/a\x3e\n中有更多更改（如分页），并授权您的应用程序将准备好实际使用！\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e如果您喜欢本教程并希望继续学习Apollo和GraphQL，请确保点击下面的“关注”按钮，并在Twitter上关注我们[@apollographql]（\x3ca href=\x22https:\/\/twitter.com\/apollographql）\x22\x3ehttps:\/\/twitter.com\/apollographql）\x3c\/a\x3e 和作者 在[@ShadajL]（\x3ca href=\x22http:\/\/twitter.com\/shadajl）。\x22\x3ehttp:\/\/twitter.com\/shadajl）。\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e感谢我的导师, \x3ca href=\x22https:\/\/medium.com\/@helfer\x22\x3eJonas Helfer\x3c\/a\x3e, 多谢他的支持！\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014fc6606574d991f5.jpg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/tutorial-graphql-subscriptions-client-side">www.zcfy.cc</a> 原文标题: Tutorial: GraphQL 订阅 (客户端) 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/ed7f0275/" target="_blank">https://alili.tech/archive/ed7f0275/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>