<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从template到DOM(Vue.js源码角度看内部运行机制)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从template到DOM(Vue.js源码角度看内部运行机制) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/eg6w59utsdo/",
				"appid": "1613049289050283", 
				"title": "从template到DOM(Vue.js源码角度看内部运行机制) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-28T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/na68iep77l/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ucczlxwcyna/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&text=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&text=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&title=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&is_video=false&description=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&title=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&title=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&title=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feg6w59utsdo%2f&title=%e4%bb%8etemplate%e5%88%b0DOM%28Vue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e7%9c%8b%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从template到DOM(Vue.js源码角度看内部运行机制)</h1><div class="meta"><div class="postdate"><time datetime="2018-12-28" itemprop="datePublished">2018-12-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h2\x3e\n\x3cp\x3e这篇文章算是对最近写的一系列Vue.js源码的文章(\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\x3c\/a\x3e)的总结吧，在阅读源码的过程中也确实受益匪浅，希望自己的这些产出也会对同样想要学习Vue.js源码的小伙伴有所帮助。之前这篇文章同样在我司（大搜车）的技术博客中发表过，欢迎大家关注我司的技术博客，给个传送门\x3ca href=\x22https:\/\/blog.souche.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/blog.souche.com\/\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e因为对Vue.js很感兴趣，而且平时工作的技术栈也是Vue.js，这几个月花了些时间研究学习了一下Vue.js源码，并做了总结与输出。\x3c\/p\x3e\n\x3cp\x3e文章的原地址：\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e在学习过程中，为Vue加上了中文的注释\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\x3c\/a\x3e，希望可以对其他想学习Vue源码的小伙伴有所帮助。\x3c\/p\x3e\n\x3cp\x3e可能会有理解存在偏差的地方，欢迎提issue指出，共同学习，共同进步。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e从new一个Vue对象开始\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let vm = new Vue({\n    el: \x27#app\x27,\n    \/*some options*\/\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*some options*\/\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很多同学好奇，在new一个Vue对象的时候，内部究竟发生了什么？\x3c\/p\x3e\n\x3cp\x3e究竟Vue.js是如何将data中的数据渲染到真实的宿主环境环境中的？\x3c\/p\x3e\n\x3cp\x3e又是如何通过“响应式”修改数据的？\x3c\/p\x3e\n\x3cp\x3etemplate是如何被编译成真实环境中可用的HTML的？\x3c\/p\x3e\n\x3cp\x3eVue指令又是执行的？\x3c\/p\x3e\n\x3cp\x3e带着这些疑问，我们从Vue的构造类开始看起。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eVue构造类\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Vue (options) {\n  if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp;\n    !(this instanceof Vue)) {\n    warn(\x27Vue is a constructor and should be called with the `new` keyword\x27)\n  }\n  \/*初始化*\/\n  this._init(options)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVue\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp;\n    !(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Vue)) {\n    warn(\x3cspan class=\x22hljs-string\x22\x3e\x27Vue is a constructor and should be called with the `new` keyword\x27\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init(options)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue的构造类只做了一件事情，就是调用_init函数进行\x3c\/p\x3e\n\x3cp\x3e来看一下init的代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    \/\/ a uid\n    vm._uid = uid\x2b\x2b\n\n    let startTag, endTag\n    \/* istanbul ignore if *\/\n    if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      startTag = `vue-perf-init:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    \/\/ a flag to avoid this being observed\n    \/*一个防止vm实例自身被观察的标志位*\/\n    vm._isVue = true\n    \/\/ merge options\n    if (options \x26amp;\x26amp; options._isComponent) {\n      \/\/ optimize internal component instantiation\n      \/\/ since dynamic options merging is pretty slow, and none of the\n      \/\/ internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    \/* istanbul ignore else *\/\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    \/\/ expose real self\n    vm._self = vm\n    \/*初始化生命周期*\/\n    initLifecycle(vm)\n    \/*初始化事件*\/\n    initEvents(vm)\n    \/*初始化render*\/\n    initRender(vm)\n    \/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*\/\n    callHook(vm, \x27beforeCreate\x27)\n    initInjections(vm) \/\/ resolve injections before data\/props\n    \/*初始化props、methods、data、computed与watch*\/\n    initState(vm)\n    initProvide(vm) \/\/ resolve provide after data\/props\n    \/*调用created钩子函数并且触发created钩子事件*\/\n    callHook(vm, \x27created\x27)\n\n    \/* istanbul ignore if *\/\n    if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      \/*格式化组件名*\/\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`${vm._name} init`, startTag, endTag)\n    }\n\n    if (vm.$options.el) {\n      \/*挂载组件*\/\n      vm.$mount(vm.$options.el)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions?: Object\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm: Component = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a uid\x3c\/span\x3e\n    vm._uid = uid\x2b\x2b\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e startTag, endTag\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      startTag = \x3cspan class=\x22hljs-string\x22\x3e`vue-perf-init:\x3cspan class=\x22hljs-subst\x22\x3e${vm._uid}\x3c\/span\x3e`\x3c\/span\x3e\n      endTag = \x3cspan class=\x22hljs-string\x22\x3e`vue-perf-end:\x3cspan class=\x22hljs-subst\x22\x3e${vm._uid}\x3c\/span\x3e`\x3c\/span\x3e\n      mark(startTag)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a flag to avoid this being observed\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*一个防止vm实例自身被观察的标志位*\/\x3c\/span\x3e\n    vm._isVue = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options \x26amp;\x26amp; options._isComponent) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimize internal component instantiation\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ since dynamic options merging is pretty slow, and none of the\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ internal component options needs special treatment.\x3c\/span\x3e\n      initInternalComponent(vm, options)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      initProxy(vm)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      vm._renderProxy = vm\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ expose real self\x3c\/span\x3e\n    vm._self = vm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化生命周期*\/\x3c\/span\x3e\n    initLifecycle(vm)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化事件*\/\x3c\/span\x3e\n    initEvents(vm)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化render*\/\x3c\/span\x3e\n    initRender(vm)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*\/\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeCreate\x27\x3c\/span\x3e)\n    initInjections(vm) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve injections before data\/props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化props、methods、data、computed与watch*\/\x3c\/span\x3e\n    initState(vm)\n    initProvide(vm) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve provide after data\/props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*调用created钩子函数并且触发created钩子事件*\/\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27created\x27\x3c\/span\x3e)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*格式化组件名*\/\x3c\/span\x3e\n      vm._name = formatComponentName(vm, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\n      mark(endTag)\n      measure(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${vm._name}\x3c\/span\x3e init`\x3c\/span\x3e, startTag, endTag)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$options.el) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*挂载组件*\/\x3c\/span\x3e\n      vm.$mount(vm.$options.el)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e_init主要做了这两件事：\x3c\/p\x3e\n\x3cp\x3e1.初始化（包括生命周期、事件、render函数、state等）。\x3c\/p\x3e\n\x3cp\x3e2.$mount组件。\x3c\/p\x3e\n\x3cp\x3e在生命钩子beforeCreate与created之间会初始化state，在此过程中，会依次初始化props、methods、data、computed与watch，这也就是Vue.js对options中的数据进行“响应式化”（即双向绑定）的过程。对于Vue.js响应式原理不了解的同学可以先看一下笔者的另一片文章\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Vue.js响应式原理》\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*初始化props、methods、data、computed与watch*\/\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  \/*初始化props*\/\n  if (opts.props) initProps(vm, opts.props)\n  \/*初始化方法*\/\n  if (opts.methods) initMethods(vm, opts.methods)\n  \/*初始化data*\/\n  if (opts.data) {\n    initData(vm)\n  } else {\n    \/*该组件没有data的时候绑定一个空对象*\/\n    observe(vm._data = {}, true \/* asRootData *\/)\n  }\n  \/*初始化computed*\/\n  if (opts.computed) initComputed(vm, opts.computed)\n  \/*初始化watchers*\/\n  if (opts.watch) initWatch(vm, opts.watch)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*初始化props、methods、data、computed与watch*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n  vm._watchers = []\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e opts = vm.$options\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化props*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.props) initProps(vm, opts.props)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化方法*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.methods) initMethods(vm, opts.methods)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化data*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.data) {\n    initData(vm)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*该组件没有data的时候绑定一个空对象*\/\x3c\/span\x3e\n    observe(vm._data = {}, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化computed*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.computed) initComputed(vm, opts.computed)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*初始化watchers*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.watch) initWatch(vm, opts.watch)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e双向绑定\x3c\/h2\x3e\n\x3cp\x3e以initData为例，对option的data的数据进行双向绑定Oberver，其他option参数双向绑定的核心原理是一致的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initData (vm: Component) {\n\n  \/*得到data数据*\/\n  let data = vm.$options.data\n  data = vm._data = typeof data === \x27function\x27\n    ? getData(data, vm)\n    : data || {}\n\n  \/*判断是否是对象*\/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n      \x27data functions should return an object:\\n\x27 \x2b\n      \x27https:\/\/vuejs.org\/v2\/guide\/components.html#data-Must-Be-a-Function\x27,\n      vm\n    )\n  }\n\n  \/\/ proxy data on instance\n  \/*遍历data对象*\/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n\n  \/\/遍历data中的数据\n  while (i--) {\n    \/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*\/\n    if (props \x26amp;\x26amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n        `The data property \x26quot;${keys[i]}\x26quot; is already declared as a prop. ` \x2b\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(keys[i])) {\n      \/*判断是否是保留字段*\/\n\n      \/*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*\/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n  \/*Github:https:\/\/github.com\/answershuto*\/\n  \/\/ observe data\n  \/*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*\/\n  observe(data, true \/* asRootData *\/)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*得到data数据*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = vm.$options.data\n  data = vm._data = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e data === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n    ? getData(data, vm)\n    : data || {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*判断是否是对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27data functions should return an object:\\n\x27\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/vuejs.org\/v2\/guide\/components.html#data-Must-Be-a-Function\x27\x3c\/span\x3e,\n      vm\n    )\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ proxy data on instance\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*遍历data对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(data)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e props = vm.$options.props\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = keys.length\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/遍历data中的数据\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (props \x26amp;\x26amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n        \x3cspan class=\x22hljs-string\x22\x3e`The data property \x22\x3cspan class=\x22hljs-subst\x22\x3e${keys[i]}\x3c\/span\x3e\x22 is already declared as a prop. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`Use prop default value instead.`\x3c\/span\x3e,\n        vm\n      )\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isReserved(keys[i])) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*判断是否是保留字段*\/\x3c\/span\x3e\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*\/\x3c\/span\x3e\n      proxy(vm, \x3cspan class=\x22hljs-string\x22\x3e`_data`\x3c\/span\x3e, keys[i])\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*Github:https:\/\/github.com\/answershuto*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ observe data\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*\/\x3c\/span\x3e\n  observe(data, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eobserve会通过defineReactive对data中的对象进行双向绑定，最终通过Object.defineProperty对对象设置setter以及getter的方法。getter的方法主要用来进行依赖收集，对于依赖收集不了解的同学可以参考笔者的另一篇文章\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《依赖收集》\x3c\/a\x3e。setter方法会在对象被修改的时候触发（不存在添加属性的情况，添加属性请用Vue.set），这时候setter会通知闭包中的Dep，Dep中有一些订阅了这个对象改变的Watcher观察者对象，Dep会通知Watcher对象更新视图。\x3c\/p\x3e\n\x3cp\x3e如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\x3cbr\x3eVue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个\x3ca href=\x22http:\/\/v1-cn.vuejs.org\/guide\/list.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数组方法\x3c\/a\x3e。修改数组原型方法的代码可以参考\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/array.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eobserver\/array.js\x3c\/a\x3e以及\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/index.js#L45\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eobserver\/index.js\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; \/\/ number of vms that has this object as root $data\n\n  constructor (value: any) {\n    \/\/.......\n\n    if (Array.isArray(value)) {\n      \/*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      *\/\n      const augment = hasProto\n        ? protoAugment  \/*直接覆盖原型的方法来修改目标对象*\/\n        : copyAugment   \/*定义（覆盖）目标对象或数组的某一个方法*\/\n      augment(value, arrayMethods, arrayKeys)\n\n      \/*如果是数组则需要遍历数组的每一个成员进行observe*\/\n      this.observeArray(value)\n    } else {\n      \/*如果是对象则直接walk进行绑定*\/\n      this.walk(value)\n    }\n  }\n}\n\n\/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\/\n \/*直接覆盖原型的方法来修改目标对象或数组*\/\nfunction protoAugment (target, src: Object) {\n  \/* eslint-disable no-proto *\/\n  target.__proto__ = src\n  \/* eslint-enable no-proto *\/\n}\n\n\/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\/\n\/* istanbul ignore next *\/\n\/*定义（覆盖）目标对象或数组的某一个方法*\/\nfunction copyAugment (target: Object, src: Object, keys: Array\x3cstring\x3e) {\n  for (let i = 0, l = keys.length; i \x3c l; i\x2b\x2b) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  value: any;\n  dep: Dep;\n  vmCount: number; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ number of vms that has this object as root $data\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (value: any) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/.......\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e augment = hasProto\n        ? protoAugment  \x3cspan class=\x22hljs-comment\x22\x3e\/*直接覆盖原型的方法来修改目标对象*\/\x3c\/span\x3e\n        : copyAugment   \x3cspan class=\x22hljs-comment\x22\x3e\/*定义（覆盖）目标对象或数组的某一个方法*\/\x3c\/span\x3e\n      augment(value, arrayMethods, arrayKeys)\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果是数组则需要遍历数组的每一个成员进行observe*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果是对象则直接walk进行绑定*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(value)\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\/\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/*直接覆盖原型的方法来修改目标对象或数组*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprotoAugment\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etarget, src: Object\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable no-proto *\/\x3c\/span\x3e\n  target.__proto__ = src\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-enable no-proto *\/\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore next *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/*定义（覆盖）目标对象或数组的某一个方法*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecopyAugment\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etarget: Object, src: Object, keys: Array\x26lt;string\x26gt;\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = keys.length; i \x26lt; l; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key = keys[i]\n    def(target, key, src[key])\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\n\nimport { def } from \x27..\/util\/index\x27\n\n\/*取得原生数组的原型*\/\nconst arrayProto = Array.prototype\n\/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*\/\nexport const arrayMethods = Object.create(arrayProto)\n\n\/**\n * Intercept mutating methods and emit events\n *\/\n \/*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*\/\n;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27sort\x27,\n  \x27reverse\x27\n]\n.forEach(function (method) {\n  \/\/ cache original method\n  \/*将数组的原生方法缓存起来，后面要调用*\/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    \/\/ avoid leaking arguments:\n    \/\/ http:\/\/jsperf.com\/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    \/*调用原生的数组方法*\/\n    const result = original.apply(this, args)\n\n    \/*数组新插入的元素需要重新进行observe才能响应式*\/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case \x27push\x27:\n        inserted = args\n        break\n      case \x27unshift\x27:\n        inserted = args\n        break\n      case \x27splice\x27:\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    \/\/ notify change\n    \/*dep通知所有注册的观察者进行响应式处理*\/\n    ob.dep.notify()\n    return result\n  })\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { def } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/util\/index\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*取得原生数组的原型*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayProto = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype\n\x3cspan class=\x22hljs-comment\x22\x3e\/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayMethods = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(arrayProto)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Intercept mutating methods and emit events\n *\/\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*\/\x3c\/span\x3e\n;[\n  \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27pop\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27shift\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27sort\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27reverse\x27\x3c\/span\x3e\n]\n.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*将数组的原生方法缓存起来，后面要调用*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e original = arrayProto[method]\n  def(arrayMethods, method, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emutator\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoid leaking arguments:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/jsperf.com\/closure-with-arguments\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e args = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(i)\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      args[i] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[i]\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*调用原生的数组方法*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = original.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*数组新插入的元素需要重新进行observe才能响应式*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__ob__\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e inserted\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (method) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e:\n        inserted = args\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e:\n        inserted = args\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e:\n        inserted = args.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inserted) ob.observeArray(inserted)\n      \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ notify change\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*dep通知所有注册的观察者进行响应式处理*\/\x3c\/span\x3e\n    ob.dep.notify()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n  })\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\x3c\/p\x3e\n\x3cp\x3e在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\x3c\/p\x3e\n\x3cp\x3e但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了\x3ca href=\x22http:\/\/v1-cn.vuejs.org\/guide\/list.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e$set()及$remove()方法\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e对于更具体的讲解数据双向绑定以及Dep、Watcher的实现可以参考笔者的文章\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《从源码角度再看数据绑定》\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3etemplate编译\x3c\/h2\x3e\n\x3cp\x3e在$mount过程中，如果是独立构建构建，则会在此过程中将template编译成render function。当然，你也可以采用运行时构建。具体参考\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/installation.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e运行时-编译器-vs-只包含运行时\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3etemplate是如何被编译成render function的呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  \/*parse解析得到ast树*\/\n  const ast = parse(template.trim(), options)\n  \/*\n    将AST树进行优化\n    优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。\n    一旦检测到这些静态树，我们就能做以下这些事情：\n    1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。\n    2.在patch的过程中直接跳过。\n *\/\n  optimize(ast, options)\n  \/*根据ast树生成所需的code（内部包含render与staticRenderFns）*\/\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebaseCompile\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  template: string,\n  options: CompilerOptions\n\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eCompiledResult\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*parse解析得到ast树*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ast = parse(template.trim(), options)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*\n    将AST树进行优化\n    优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。\n    一旦检测到这些静态树，我们就能做以下这些事情：\n    1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。\n    2.在patch的过程中直接跳过。\n *\/\x3c\/span\x3e\n  optimize(ast, options)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*根据ast树生成所需的code（内部包含render与staticRenderFns）*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code = generate(ast, options)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    ast,\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: code.render,\n    \x3cspan class=\x22hljs-attr\x22\x3estaticRenderFns\x3c\/span\x3e: code.staticRenderFns\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ebaseCompile首先会将模板template进行parse得到一个AST语法树，再通过optimize做一些优化，最后通过generate得到render以及staticRenderFns。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eparse\x3c\/h3\x3e\n\x3cp\x3eparse的源码可以参见\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/vue-src\/compiler\/parser\/index.js#L53\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\/blob\/master\/vue-src\/compiler\/parser\/index.js#L53\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3eparse会用正则等方式解析template模板中的指令、class、style等数据，形成AST语法树。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eoptimize\x3c\/h3\x3e\n\x3cp\x3eoptimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3egenerate\x3c\/h3\x3e\n\x3cp\x3egenerate是将AST语法树转化成render funtion字符串的过程，得到结果是render的字符串以及staticRenderFns字符串。\x3c\/p\x3e\n\x3cp\x3e具体的template编译实现请参考\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E8%81%8A%E8%81%8AVue%E7%9A%84template%E7%BC%96%E8%AF%91.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《聊聊Vue.js的template编译》\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3eWatcher到视图\x3c\/h2\x3e\n\x3cp\x3eWatcher对象会通过调用updateComponent方法来达到更新视图的目的。这里提一下，其实Watcher并不是实时更新视图的，Vue.js默认会将Watcher对象存在一个队列中，在下一个tick时更新异步更新视图，完成了性能优化。关于nextTick感兴趣的小伙伴可以参考\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Vue.js异步更新DOM策略及nextTick》\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22updateComponent = () =\x3e {\n    vm._update(vm._render(), hydrating)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eupdateComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    vm._update(vm._render(), hydrating)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eupdateComponent就执行一句话，_render函数会返回一个新的Vnode节点，传入_update中与旧的VNode对象进行对比，经过一个patch的过程得到两个VNode节点的差异，最后将这些差异渲染到真实环境形成视图。\x3c\/p\x3e\n\x3cp\x3e什么是VNode？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eVNode\x3c\/h2\x3e\n\x3cp\x3e在刀耕火种的年代，我们需要在各个事件方法中直接操作DOM来达到修改视图的目的。但是当应用一大就会变得难以维护。\x3c\/p\x3e\n\x3cp\x3e那我们是不是可以把真实DOM树抽象成一棵以JavaScript对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实DOM重绘到页面上呢？于是虚拟DOM出现了，它是真实DOM的一层抽象，用属性描述真实DOM的各个特性。当它发生变化的时候，就会去修改视图。\x3c\/p\x3e\n\x3cp\x3e但是这样的JavaScript操作DOM进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以Vue.js将DOM抽象成一个以JavaScript对象为节点的虚拟DOM树，以VNode节点模拟真实DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实DOM，只需要操作JavaScript对象，大大提升了性能。修改以后经过diff算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的DOM操作，大大提高了性能。\x3c\/p\x3e\n\x3cp\x3eVue就使用了这样的抽象节点VNode，它是对真实DOM的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是weex，甚至是node平台也可以对这样一棵抽象DOM树进行创建删除修改等操作，这也为前后端同构提供了可能。\x3c\/p\x3e\n\x3cp\x3e先来看一下Vue.js源码中对VNode类的定义。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array\x3cVNode\x3e;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; \/\/ rendered in this component\x27s scope\n  functionalContext: Component | void; \/\/ only for functional component root nodes\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; \/\/ component instance\n  parent: VNode | void; \/\/ component placeholder node\n  raw: boolean; \/\/ contains raw HTML? (server only)\n  isStatic: boolean; \/\/ hoisted static node\n  isRootInsert: boolean; \/\/ necessary for enter transition check\n  isComment: boolean; \/\/ empty comment placeholder?\n  isCloned: boolean; \/\/ is a cloned node?\n  isOnce: boolean; \/\/ is a v-once node?\n\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array\x3cVNode\x3e,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions\n  ) {\n    \/*当前节点的标签名*\/\n    this.tag = tag\n    \/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*\/\n    this.data = data\n    \/*当前节点的子节点，是一个数组*\/\n    this.children = children\n    \/*当前节点的文本*\/\n    this.text = text\n    \/*当前虚拟节点对应的真实dom节点*\/\n    this.elm = elm\n    \/*当前节点的名字空间*\/\n    this.ns = undefined\n    \/*编译作用域*\/\n    this.context = context\n    \/*函数化组件作用域*\/\n    this.functionalContext = undefined\n    \/*节点的key属性，被当作节点的标志，用以优化*\/\n    this.key = data \x26amp;\x26amp; data.key\n    \/*组件的option选项*\/\n    this.componentOptions = componentOptions\n    \/*当前节点对应的组件的实例*\/\n    this.componentInstance = undefined\n    \/*当前节点的父节点*\/\n    this.parent = undefined\n    \/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*\/\n    this.raw = false\n    \/*静态节点标志*\/\n    this.isStatic = false\n    \/*是否作为跟节点插入*\/\n    this.isRootInsert = true\n    \/*是否为注释节点*\/\n    this.isComment = false\n    \/*是否为克隆节点*\/\n    this.isCloned = false\n    \/*是否有v-once指令*\/\n    this.isOnce = false\n  }\n\n  \/\/ DEPRECATED: alias for componentInstance for backwards compat.\n  \/* istanbul ignore next *\/\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVNode\x3c\/span\x3e \x3c\/span\x3e{\n  tag: string | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  data: VNodeData | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  children: ?\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;VNode\x26gt;;\n  text: string | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  elm: Node | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  ns: string | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  context: Component | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ rendered in this component\x27s scope\x3c\/span\x3e\n  functionalContext: Component | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ only for functional component root nodes\x3c\/span\x3e\n  key: string | number | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  componentOptions: VNodeComponentOptions | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e;\n  componentInstance: Component | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component instance\x3c\/span\x3e\n  parent: VNode | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component placeholder node\x3c\/span\x3e\n  raw: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ contains raw HTML? (server only)\x3c\/span\x3e\n  isStatic: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ hoisted static node\x3c\/span\x3e\n  isRootInsert: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ necessary for enter transition check\x3c\/span\x3e\n  isComment: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ empty comment placeholder?\x3c\/span\x3e\n  isCloned: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ is a cloned node?\x3c\/span\x3e\n  isOnce: boolean; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ is a v-once node?\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array\x26lt;VNode\x26gt;,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions\n  ) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点的标签名*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tag = tag\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点的子节点，是一个数组*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.children = children\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点的文本*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.text = text\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前虚拟节点对应的真实dom节点*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.elm = elm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点的名字空间*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ns = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*编译作用域*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context = context\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*函数化组件作用域*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.functionalContext = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*节点的key属性，被当作节点的标志，用以优化*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key = data \x26amp;\x26amp; data.key\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*组件的option选项*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentOptions = componentOptions\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点对应的组件的实例*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentInstance = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*当前节点的父节点*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.raw = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*静态节点标志*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isStatic = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*是否作为跟节点插入*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isRootInsert = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*是否为注释节点*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isComment = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*是否为克隆节点*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isCloned = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*是否有v-once指令*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isOnce = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ DEPRECATED: alias for componentInstance for backwards compat.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore next *\/\x3c\/span\x3e\n  get child (): Component | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentInstance\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是一个最基础的VNode节点，作为其他派生VNode类的基类，里面定义了下面这些数据。\x3c\/p\x3e\n\x3cp\x3etag: 当前节点的标签名\x3c\/p\x3e\n\x3cp\x3edata: 当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息\x3c\/p\x3e\n\x3cp\x3echildren: 当前节点的子节点，是一个数组\x3c\/p\x3e\n\x3cp\x3etext: 当前节点的文本\x3c\/p\x3e\n\x3cp\x3eelm: 当前虚拟节点对应的真实dom节点\x3c\/p\x3e\n\x3cp\x3ens: 当前节点的名字空间\x3c\/p\x3e\n\x3cp\x3econtext: 当前节点的编译作用域\x3c\/p\x3e\n\x3cp\x3efunctionalContext: 函数化组件作用域\x3c\/p\x3e\n\x3cp\x3ekey: 节点的key属性，被当作节点的标志，用以优化\x3c\/p\x3e\n\x3cp\x3ecomponentOptions: 组件的option选项\x3c\/p\x3e\n\x3cp\x3ecomponentInstance: 当前节点对应的组件的实例\x3c\/p\x3e\n\x3cp\x3eparent: 当前节点的父节点\x3c\/p\x3e\n\x3cp\x3eraw: 简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false\x3c\/p\x3e\n\x3cp\x3eisStatic: 是否为静态节点\x3c\/p\x3e\n\x3cp\x3eisRootInsert: 是否作为跟节点插入\x3c\/p\x3e\n\x3cp\x3eisComment: 是否为注释节点\x3c\/p\x3e\n\x3cp\x3eisCloned: 是否为克隆节点\x3c\/p\x3e\n\x3cp\x3eisOnce: 是否有v-once指令\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e打个比方，比如说我现在有这么一个VNode树\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    tag: \x27div\x27\n    data: {\n        class: \x27test\x27\n    },\n    children: [\n        {\n            tag: \x27span\x27,\n            data: {\n                class: \x27demo\x27\n            }\n            text: \x27hello,VNode\x27\n        }\n    ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e{\n    tag: \x27div\x27\n    data: {\n        class: \x27test\x27\n    },\n    children: [\n        {\n            tag: \x27span\x27,\n            data: {\n                class: \x27demo\x27\n            }\n            text: \x27hello,VNode\x27\n        }\n    ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e渲染之后的结果就是这样的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv class=\x26quot;test\x26quot;\x3e\n    \x3cspan class=\x26quot;demo\x26quot;\x3ehello,VNode\x3c\/span\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22test\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22demo\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3ehello,VNode\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更多操作VNode的方法，请参考\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/VNode%E8%8A%82%E7%82%B9.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《VNode节点》\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3epatch\x3c\/h2\x3e\n\x3cp\x3e最后_update会将新旧两个VNode进行一次patch的过程，得出两个VNode最小的差异，然后将这些差异渲染到视图上。\x3c\/p\x3e\n\x3cp\x3e首先说一下patch的核心diff算法，diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563756?w=706\x26amp;h=295\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563756?w=706\x26amp;h=295\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563757?w=628\x26amp;h=214\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563757?w=628\x26amp;h=214\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这两张图代表旧的VNode与新VNode进行patch的过程，他们只是在同层级的VNode之间进行比较得到变化（第二张图中相同颜色的方块代表互相进行比较的VNode节点），然后修改变化的视图，所以十分高效。\x3c\/p\x3e\n\x3cp\x3e在patch的过程中，如果两个VNode被认为是同一个VNode（sameVnode），则会进行深度的比较，得出最小差异，否则直接删除旧有DOM节点，创建新的DOM节点。\x3c\/p\x3e\n\x3cp\x3e什么是sameVnode？\x3c\/p\x3e\n\x3cp\x3e我们来看一下sameVnode的实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n  判断两个VNode节点是否是同一个节点，需要满足以下条件\n  key相同\n  tag（当前节点的标签名）相同\n  isComment（是否为注释节点）相同\n  是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义\n  当标签是\x3cinput\x3e的时候，type必须相同\n*\/\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key \x26amp;\x26amp;\n    a.tag === b.tag \x26amp;\x26amp;\n    a.isComment === b.isComment \x26amp;\x26amp;\n    isDef(a.data) === isDef(b.data) \x26amp;\x26amp;\n    sameInputType(a, b)\n  )\n}\n\n\/\/ Some browsers do not support dynamically changing type for \x3cinput\x3e\n\/\/ so they need to be treated as different nodes\n\/*\n  判断当标签是\x3cinput\x3e的时候，type是否相同\n  某些浏览器不支持动态修改\x3cinput\x3e类型，所以他们被视为不同类型\n*\/\nfunction sameInputType (a, b) {\n  if (a.tag !== \x27input\x27) return true\n  let i\n  const typeA = isDef(i = a.data) \x26amp;\x26amp; isDef(i = i.attrs) \x26amp;\x26amp; i.type\n  const typeB = isDef(i = b.data) \x26amp;\x26amp; isDef(i = i.attrs) \x26amp;\x26amp; i.type\n  return typeA === typeB\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n  判断两个VNode节点是否是同一个节点，需要满足以下条件\n  key相同\n  tag（当前节点的标签名）相同\n  isComment（是否为注释节点）相同\n  是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义\n  当标签是\x26lt;input\x26gt;的时候，type必须相同\n*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esameVnode\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    a.key === b.key \x26amp;\x26amp;\n    a.tag === b.tag \x26amp;\x26amp;\n    a.isComment === b.isComment \x26amp;\x26amp;\n    isDef(a.data) === isDef(b.data) \x26amp;\x26amp;\n    sameInputType(a, b)\n  )\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Some browsers do not support dynamically changing type for \x26lt;input\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ so they need to be treated as different nodes\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n  判断当标签是\x26lt;input\x26gt;的时候，type是否相同\n  某些浏览器不支持动态修改\x26lt;input\x26gt;类型，所以他们被视为不同类型\n*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esameInputType\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a.tag !== \x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e typeA = isDef(i = a.data) \x26amp;\x26amp; isDef(i = i.attrs) \x26amp;\x26amp; i.type\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e typeB = isDef(i = b.data) \x26amp;\x26amp; isDef(i = i.attrs) \x26amp;\x26amp; i.type\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e typeA === typeB\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同。这时候这两个VNode则算sameVnode，可以直接进行patchVnode操作。\x3c\/p\x3e\n\x3cp\x3epatchVnode的规则是这样的：\x3c\/p\x3e\n\x3cp\x3e1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。\x3c\/p\x3e\n\x3cp\x3e2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。\x3c\/p\x3e\n\x3cp\x3e3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。\x3c\/p\x3e\n\x3cp\x3e4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。\x3c\/p\x3e\n\x3cp\x3e5.当新老节点都无子节点的时候，只是文本的替换。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3eupdateChildren\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, elmToMove, refElm\n\n    \/\/ removeOnly is a special flag used only by \x3ctransition-group\x3e\n    \/\/ to ensure removed elements stay in correct relative positions\n    \/\/ during leaving transitions\n    const canMove = !removeOnly\n\n    while (oldStartIdx \x3c= oldEndIdx \x26amp;\x26amp; newStartIdx \x3c= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx] \/\/ Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        \/*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*\/\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { \/\/ Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { \/\/ Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } else {\n        \/*\n          生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）\n          比如childre是这样的 [{xx: xx, key: \x27key0\x27}, {xx: xx, key: \x27key1\x27}, {xx: xx, key: \x27key2\x27}]  beginIdx = 0   endIdx = 2  \n          结果生成{key0: 0, key1: 1, key2: 2}\n        *\/\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        \/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*\/\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null\n        if (isUndef(idxInOld)) { \/\/ New element\n          \/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*\/\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } else {\n          \/*获取同key的老节点*\/\n          elmToMove = oldCh[idxInOld]\n          \/* istanbul ignore if *\/\n          if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !elmToMove) {\n            \/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*\/\n            warn(\n              \x27It seems there are duplicate keys that is causing an update error. \x27 \x2b\n              \x27Make sure each v-for item has a unique key.\x27\n            )\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            \/*Github:https:\/\/github.com\/answershuto*\/\n            \/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*\/\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            \/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*\/\n            oldCh[idxInOld] = undefined\n            \/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*\/\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } else {\n            \/\/ same key but different element. treat as new element\n            \/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*\/\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\n        }\n      }\n    }\n    if (oldStartIdx \x3e oldEndIdx) {\n      \/*全部比较完成以后，发现oldStartIdx \x3e oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*\/\n      refElm = isUndef(newCh[newEndIdx \x2b 1]) ? null : newCh[newEndIdx \x2b 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx \x3e newEndIdx) {\n      \/*如果全部比较完成以后发现newStartIdx \x3e newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*\/\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateChildren\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentElm, oldCh, newCh, insertedVnodeQueue, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndIdx = oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartVnode = oldCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndVnode = oldCh[oldEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndIdx = newCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStartVnode = newCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndVnode = newCh[newEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldKeyToIdx, idxInOld, elmToMove, refElm\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ removeOnly is a special flag used only by \x26lt;transition-group\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ to ensure removed elements stay in correct relative positions\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ during leaving transitions\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e canMove = !removeOnly\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (oldStartIdx \x26lt;= oldEndIdx \x26amp;\x26amp; newStartIdx \x26lt;= newEndIdx) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode has been moved left\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newStartVnode)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*\/\x3c\/span\x3e\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newEndVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved right\x3c\/span\x3e\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newStartVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved left\x3c\/span\x3e\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*\n          生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）\n          比如childre是这样的 [{xx: xx, key: \x27key0\x27}, {xx: xx, key: \x27key1\x27}, {xx: xx, key: \x27key2\x27}]  beginIdx = 0   endIdx = 2  \n          结果生成{key0: 0, key1: 1, key2: 2}\n        *\/\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*\/\x3c\/span\x3e\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(idxInOld)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New element\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*\/\x3c\/span\x3e\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/*获取同key的老节点*\/\x3c\/span\x3e\n          elmToMove = oldCh[idxInOld]\n          \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !elmToMove) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*\/\x3c\/span\x3e\n            warn(\n              \x3cspan class=\x22hljs-string\x22\x3e\x27It seems there are duplicate keys that is causing an update error. \x27\x3c\/span\x3e \x2b\n              \x3cspan class=\x22hljs-string\x22\x3e\x27Make sure each v-for item has a unique key.\x27\x3c\/span\x3e\n            )\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(elmToMove, newStartVnode)) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*Github:https:\/\/github.com\/answershuto*\/\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*\/\x3c\/span\x3e\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*\/\x3c\/span\x3e\n            oldCh[idxInOld] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*\/\x3c\/span\x3e\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ same key but different element. treat as new element\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*\/\x3c\/span\x3e\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\n        }\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldStartIdx \x26gt; oldEndIdx) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*全部比较完成以后，发现oldStartIdx \x26gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*\/\x3c\/span\x3e\n      refElm = isUndef(newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStartIdx \x26gt; newEndIdx) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果全部比较完成以后发现newStartIdx \x26gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*\/\x3c\/span\x3e\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e直接看源码可能比较难以捋清其中的关系，我们通过图来看一下。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563758?w=885\x26amp;h=397\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563758?w=885\x26amp;h=397\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx \x26lt;= oldEndIdx或者newStartIdx \x26lt;= newEndIdx时结束循环。\x3c\/p\x3e\n\x3cp\x3e索引与VNode节点的对应关系：\x3cbr\x3eoldStartIdx =\x26gt; oldStartVnode\x3cbr\x3eoldEndIdx =\x26gt; oldEndVnode\x3cbr\x3enewStartIdx =\x26gt; newStartVnode\x3cbr\x3enewEndIdx =\x26gt; newEndVnode\x3c\/p\x3e\n\x3cp\x3e在遍历中，如果存在key，并且满足sameVnode，会将该DOM节点进行复用，否则则会创建一个新的DOM节点。\x3c\/p\x3e\n\x3cp\x3e首先，oldStartVnode、oldEndVnode与newStartVnode、newEndVnode两两比较一共有2*2=4种比较方法。\x3c\/p\x3e\n\x3cp\x3e当新老VNode节点的start或者end满足sameVnode时，也就是sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)，直接将该VNode节点进行patchVnode即可。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563759?w=618\x26amp;h=251\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563759?w=618\x26amp;h=251\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果oldStartVnode与newEndVnode满足sameVnode，即sameVnode(oldStartVnode, newEndVnode)。\x3c\/p\x3e\n\x3cp\x3e这时候说明oldStartVnode已经跑到了oldEndVnode后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563760?w=1540\x26amp;h=776\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563760?w=1540\x26amp;h=776\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果oldEndVnode与newStartVnode满足sameVnode，即sameVnode(oldEndVnode, newStartVnode)。\x3c\/p\x3e\n\x3cp\x3e这说明oldEndVnode跑到了oldStartVnode的前面，进行patchVnode的同时真实的DOM节点移动到了oldStartVnode的前面。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563761?w=810\x26amp;h=432\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563761?w=810\x26amp;h=432\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果以上情况均不符合，则通过createKeyToOldIdx会得到一个oldKeyToIdx，里面存放了一个key为旧的VNode，value为对应index序列的哈希表。从这个哈希表中可以找到是否有与newStartVnode一致key的旧的VNode节点，如果同时满足sameVnode，patchVnode的同时会将这个真实DOM（elmToMove）移动到oldStartVnode对应的真实DOM的前面。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563762?w=750\x26amp;h=373\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563762?w=750\x26amp;h=373\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当然也有可能newStartVnode在旧的VNode节点找不到一致的key，或者是即便key相同却不是sameVnode，这个时候会调用createElm创建一个新的DOM节点。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563763?w=927\x26amp;h=462\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563763?w=927\x26amp;h=462\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e到这里循环已经结束了，那么剩下我们还需要处理多余或者不够的真实DOM节点。\x3c\/p\x3e\n\x3cp\x3e1.当结束时oldStartIdx \x26gt; oldEndIdx，这个时候老的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老的VNode节点多，也就是比真实DOM多，需要将剩下的（也就是新增的）VNode节点插入到真实DOM节点中去，此时调用addVnodes（批量调用createElm的接口将这些节点加入到真实DOM中去）。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563764?w=784\x26amp;h=373\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563764?w=784\x26amp;h=373\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e2。同理，当newStartIdx \x26gt; newEndIdx时，新的VNode节点已经遍历完了，但是老的节点还有剩余，说明真实DOM节点多余了，需要从文档中删除，这时候调用removeVnodes将这些多余的真实DOM删除。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563765?w=836\x26amp;h=367\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563765?w=836\x26amp;h=367\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e更详细的diff实现参考笔者的文章\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/VirtualDOM%E4%B8%8Ediff(Vue%E5%AE%9E%E7%8E%B0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVirtualDOM与diff(Vue.js实现)\x3c\/a\x3e.MarkDown)。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e映射到真实DOM\x3c\/h2\x3e\n\x3cp\x3e由于Vue使用了虚拟DOM，所以虚拟DOM可以在任何支持JavaScript语言的平台上操作，譬如说目前Vue支持的浏览器平台或是weex，在虚拟DOM的实现上是一致的。那么最后虚拟DOM如何映射到真实的DOM节点上呢？\x3c\/p\x3e\n\x3cp\x3eVue为平台做了一层适配层，浏览器平台见\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/vue-src\/platforms\/web\/runtime\/node-ops.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/platforms\/web\/runtime\/node-ops.js\x3c\/a\x3e以及weex平台见\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/vue-src\/platforms\/weex\/runtime\/node-ops.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/platforms\/weex\/runtime\/node-ops.js\x3c\/a\x3e。不同平台之间通过适配层对外提供相同的接口，虚拟DOM进行操作真实DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变。\x3c\/p\x3e\n\x3cp\x3e现在又出现了一个问题，我们只是将虚拟DOM映射成了真实的DOM。那如何给这些DOM加入attr、class、style等DOM属性呢？\x3c\/p\x3e\n\x3cp\x3e这要依赖于虚拟DOM的生命钩子。虚拟DOM提供了如下的钩子函数，分别在不同的时期会进行调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const hooks = [\x27create\x27, \x27activate\x27, \x27update\x27, \x27remove\x27, \x27destroy\x27]\n\n\/*构建cbs回调函数，web平台上见\/platforms\/web\/runtime\/modules*\/\n  for (i = 0; i \x3c hooks.length; \x2b\x2bi) {\n    cbs[hooks[i]] = []\n    for (j = 0; j \x3c modules.length; \x2b\x2bj) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]])\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hooks = [\x3cspan class=\x22hljs-string\x22\x3e\x27create\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27activate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27update\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27remove\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27destroy\x27\x3c\/span\x3e]\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*构建cbs回调函数，web平台上见\/platforms\/web\/runtime\/modules*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; hooks.length; \x2b\x2bi) {\n    cbs[hooks[i]] = []\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; modules.length; \x2b\x2bj) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]])\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同理，也会根据不同平台有自己不同的实现，我们这里以Web平台为例。Web平台的钩子函数见\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\/platforms\/web\/runtime\/modules\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\/platforms\/web\/runtime\/modules\x3c\/a\x3e。里面有对attr、class、props、events、style以及transition（过渡状态）的DOM属性进行操作。\x3c\/p\x3e\n\x3cp\x3e以attr为例，代码很简单。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* @flow *\/\n\nimport { isIE9 } from \x27core\/util\/env\x27\n\nimport {\n  extend,\n  isDef,\n  isUndef\n} from \x27shared\/util\x27\n\nimport {\n  isXlink,\n  xlinkNS,\n  getXlinkProp,\n  isBooleanAttr,\n  isEnumeratedAttr,\n  isFalsyAttrValue\n} from \x27web\/util\/index\x27\n\n\/*更新attr*\/\nfunction updateAttrs (oldVnode: VNodeWithData, vnode: VNodeWithData) {\n  \/*如果旧的以及新的VNode节点均没有attr属性，则直接返回*\/\n  if (isUndef(oldVnode.data.attrs) \x26amp;\x26amp; isUndef(vnode.data.attrs)) {\n    return\n  }\n  let key, cur, old\n  \/*VNode节点对应的Dom实例*\/\n  const elm = vnode.elm\n  \/*旧VNode节点的attr*\/\n  const oldAttrs = oldVnode.data.attrs || {}\n  \/*新VNode节点的attr*\/\n  let attrs: any = vnode.data.attrs || {}\n  \/\/ clone observed objects, as the user probably wants to mutate it\n  \/*如果新的VNode的attr已经有__ob__（代表已经被Observe处理过了）， 进行深拷贝*\/\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs)\n  }\n\n  \/*遍历attr，不一致则替换*\/\n  for (key in attrs) {\n    cur = attrs[key]\n    old = oldAttrs[key]\n    if (old !== cur) {\n      setAttr(elm, key, cur)\n    }\n  }\n  \/\/ #4391: in IE9, setting type can reset value for input[type=radio]\n  \/* istanbul ignore if *\/\n  if (isIE9 \x26amp;\x26amp; attrs.value !== oldAttrs.value) {\n    setAttr(elm, \x27value\x27, attrs.value)\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key))\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key)\n      }\n    }\n  }\n}\n\n\/*设置attr*\/\nfunction setAttr (el: Element, key: string, value: any) {\n  if (isBooleanAttr(key)) {\n    \/\/ set attribute for blank value\n    \/\/ e.g. \x3coption disabled\x3eSelect one\x3c\/option\x3e\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key)\n    } else {\n      el.setAttribute(key, key)\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === \x27false\x27 ? \x27false\x27 : \x27true\x27)\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key))\n    } else {\n      el.setAttributeNS(xlinkNS, key, value)\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key)\n    } else {\n      el.setAttribute(key, value)\n    }\n  }\n}\n\nexport default {\n  create: updateAttrs,\n  update: updateAttrs\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* @flow *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { isIE9 } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27core\/util\/env\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {\n  extend,\n  isDef,\n  isUndef\n} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27shared\/util\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {\n  isXlink,\n  xlinkNS,\n  getXlinkProp,\n  isBooleanAttr,\n  isEnumeratedAttr,\n  isFalsyAttrValue\n} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27web\/util\/index\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*更新attr*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateAttrs\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoldVnode: VNodeWithData, vnode: VNodeWithData\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*如果旧的以及新的VNode节点均没有attr属性，则直接返回*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldVnode.data.attrs) \x26amp;\x26amp; isUndef(vnode.data.attrs)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key, cur, old\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*VNode节点对应的Dom实例*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e elm = vnode.elm\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*旧VNode节点的attr*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldAttrs = oldVnode.data.attrs || {}\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*新VNode节点的attr*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e attrs: any = vnode.data.attrs || {}\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ clone observed objects, as the user probably wants to mutate it\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*如果新的VNode的attr已经有__ob__（代表已经被Observe处理过了）， 进行深拷贝*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*遍历attr，不一致则替换*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e attrs) {\n    cur = attrs[key]\n    old = oldAttrs[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (old !== cur) {\n      setAttr(elm, key, cur)\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ #4391: in IE9, setting type can reset value for input[type=radio]\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isIE9 \x26amp;\x26amp; attrs.value !== oldAttrs.value) {\n    setAttr(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e, attrs.value)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldAttrs) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(attrs[key])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key))\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key)\n      }\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*设置attr*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetAttr\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eel: Element, key: string, value: any\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isBooleanAttr(key)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set attribute for blank value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ e.g. \x26lt;option disabled\x26gt;Select one\x26lt;\/option\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFalsyAttrValue(value)) {\n      el.removeAttribute(key)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      el.setAttribute(key, key)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === \x3cspan class=\x22hljs-string\x22\x3e\x27false\x27\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27false\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27true\x27\x3c\/span\x3e)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isXlink(key)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key))\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      el.setAttributeNS(xlinkNS, key, value)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFalsyAttrValue(value)) {\n      el.removeAttribute(key)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      el.setAttribute(key, value)\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateAttrs,\n  \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateAttrs\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eattr只需要在create以及update钩子被调用时更新DOM的attr属性即可。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e至此，我们已经从template到真实DOM的整个过程梳理完了。现在再去看这张图，是不是更清晰了呢？\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011563766?w=1200\x26amp;h=750\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011563766?w=1200\x26amp;h=750\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e关于\x3c\/h2\x3e\n\x3cp\x3e作者：染陌 \x3c\/p\x3e\n\x3cp\x3eEmail：answershuto@gmail.com  or  answershuto@126.com\x3c\/p\x3e\n\x3cp\x3eGithub:  \x3ca href=\x22https:\/\/github.com\/answershuto\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eBlog：\x3ca href=\x22http:\/\/answershuto.github.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/answershuto.github.io\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e知乎主页：\x3ca href=\x22https:\/\/www.zhihu.com\/people\/cao-yang-49\/activities\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.zhihu.com\/people\/cao-yang-49\/activities\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e知乎专栏：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/ranmo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/zhuanlan.zhihu.com\/ranmo\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e掘金： \x3ca href=\x22https:\/\/juejin.im\/user\/58f87ae844d9040069ca7507\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/juejin.im\/user\/58f87ae844d9040069ca7507\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eosChina：\x3ca href=\x22https:\/\/my.oschina.net\/u\/3161824\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/my.oschina.net\/u\/3161824\/blog\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e转载请注明出处，谢谢。\x3c\/p\x3e\n\x3cp\x3e欢迎关注我的公众号\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011335965\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011335965\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从template到DOM(Vue.js源码角度看内部运行机制)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011563751">https://segmentfault.com/a/1190000011563751</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/eg6w59utsdo/" target="_blank">https://alili.tech/archive/eg6w59utsdo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>