<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="使用 PHP 来做 Vue.js 的 SSR 服务端渲染"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>使用 PHP 来做 Vue.js 的 SSR 服务端渲染 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ehdh9abcu2n/",
				"appid": "1613049289050283", 
				"title": "使用 PHP 来做 Vue.js 的 SSR 服务端渲染 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9u9aipqwc4s/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qpgs5dzs7n/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&text=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&text=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&title=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&is_video=false&description=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&title=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&title=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&title=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fehdh9abcu2n%2f&title=%e4%bd%bf%e7%94%a8%20PHP%20%e6%9d%a5%e5%81%9a%20Vue.js%20%e7%9a%84%20SSR%20%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">使用 PHP 来做 Vue.js 的 SSR 服务端渲染</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014155032\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014155032\x22 alt=\x22file\x22 title=\x22file\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e对于客户端应用来说，服务端渲染是一个热门话题。然而不幸的是，这并不是一件容易的事，尤其是对于不用 Node.js 环境开发的人来说。\x3c\/p\x3e\n\x3cp\x3e我发布了两个库让 PHP 从服务端渲染成为可能.\x3ca href=\x22https:\/\/github.com\/spatie\/server-side-rendering\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espatie\/server-side-rendering\x3c\/a\x3e\x26nbsp;和\x26nbsp;\x3ca href=\x22https:\/\/github.com\/spatie\/laravel-server-side-rendering\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espatie\/laravel-server-side-rendering\x3c\/a\x3e适配 laravel  应用。\x3c\/p\x3e\n\x3cp\x3e让我们一起来仔细研究一些服务端渲染的概念，权衡优缺点，然后遵循第一法则用 PHP 建立一个服务端渲染。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e什么是服务端渲染\x3c\/h2\x3e\n\x3cp\x3e一个单页应用（通常也叫做 SPA ）是一个客户端渲染的 App 。这是一个仅在浏览器端运行的应用。如果你正在使用框架，比如 React， Vue.js 或者  AngularJS ，客户端将从头开始渲染你的 App 。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e浏览器的工作\x3c\/h3\x3e\n\x3cp\x3e在 SPA 被启动并准备使用之前，浏览器需要经过几个步骤。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e下载 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e解析 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e运行 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e取回数据（可选，但普遍）\x3c\/li\x3e\n\x3cli\x3e在原本的空容器渲染应用\x26nbsp; \x3cem\x3e（首次有意义的渲染）\x3c\/em\x3e\n\x3c\/li\x3e\n\x3cli\x3e准备完成！\x26nbsp;\x3cem\x3e（可以交互啦）\x3c\/em\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e用户不会看到任何有意义的内容，直到浏览器完全渲染 App（需要花费一点时间）。这会造成一个明显的延迟，直到 \x3ca href=\x22https:\/\/developers.google.com\/web\/tools\/lighthouse\/audits\/first-meaningful-paint\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e首次有意义的渲染\x3c\/a\x3e 完成，从而影响了用户体验。\x3c\/p\x3e\n\x3cp\x3e这就是为什么服务端渲染（一般被称作 SSR ）登场的原因。SSR 在服务器预渲染初始应用状态。这里是浏览器在使用服务端渲染后需要经过的步骤：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e渲染来自服务端的 HTML \x3cem\x3e（首次有意义的渲染）\x3c\/em\x3e\n\x3c\/li\x3e\n\x3cli\x3e下载 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e解析 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e运行 JavaScript 脚本\x3c\/li\x3e\n\x3cli\x3e取回数据\x3c\/li\x3e\n\x3cli\x3e使已存在的 HTML 页面可交互\x3c\/li\x3e\n\x3cli\x3e准备完成！\x26nbsp;\x3cem\x3e(可以交互啦)\x3c\/em\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e由于服务器提供了 HTML 的预渲染块，因此用户无需等到一切完成后才能看到有意义的内容。注意，虽然 \x3ca href=\x22https:\/\/developers.google.com\/web\/tools\/lighthouse\/audits\/time-to-interactive\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e交互时间\x3c\/a\x3e 仍然处于最后，但可感知的表现得到了巨大的提升。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e服务端渲染的优点\x3c\/h3\x3e\n\x3cp\x3e服务端渲染的主要优点是可以提升用户体验。并且，如果你的网站需要应对不能执行 JavaScript 的老旧爬虫，SSR 将是必须的，这样，爬虫才能索引服务端渲染过后的页面，而不是一个空荡荡的文档。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e服务端如何渲染？\x3c\/h2\x3e\n\x3cp\x3e记住服务端渲染并非微不足道，这一点很重要。当你的 Web 应用同时运行在浏览器和服务器，而你的 Web 应用依赖 DOM 访问，那么你需要确保这些调用不会在服务端触发，因为没有 DOM API 可用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e基础设施复杂性\x3c\/h3\x3e\n\x3cp\x3e假设你决定了服务端渲染你的应用端程序，你如果正在阅读这篇文章，很大可能正在使用 PHP 构建应用的大部分（功能）。但是，服务端渲染的 SPA 需要运行在 Node.js 环境，所以将需要维护第二个程序。\x3c\/p\x3e\n\x3cp\x3e你需要构建两个应用程序之间的桥梁，以便它们进行通信和共享数据：需要一个 API。构建无状态 API 相比于构建有状态是比较 \x3cem\x3e困难\x3c\/em\x3e 的。你需要熟悉一些新概念，例如基于 JWT 或 OAUTH 的验证，CORS，REST ，添加这些到现有应用中是很重要的。\x3c\/p\x3e\n\x3cp\x3e有得必有所失，我们已经建立了 SSR 以增加 Web 应用的用户体验，但 SSR 是有成本的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e服务器端渲染权衡取舍\x3c\/h3\x3e\n\x3cp\x3e服务器上多了一个额外的操作。一个是服务器增加了负载压力，第二个是页面响应时间也会稍微加长。 不过因为现在服务器返回了有效内容，在用户看来，第二个问题的影响不大。\x3c\/p\x3e\n\x3cp\x3e大部分时候你会使用 Node.js 来渲染你的 SPA 代码。如果你的后端代码不是使用 Javascript 编写的话，新加入 Node.js 堆栈将使你的程序架构变得复杂。\x3c\/p\x3e\n\x3cp\x3e为了简化基础架构的复杂度， 我们需要找到一个方法，使已有的 PHP 环境作为服务端来渲染客户端应用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e在 PHP 中渲染 JavaScript\x3c\/h2\x3e\n\x3cp\x3e在服务器端渲染 SPA 需要集齐以下三样东西：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e一个可以执行 JavaScript 的引擎\x3c\/li\x3e\n\x3cli\x3e一个可以在服务器上渲染应用的脚本\x3c\/li\x3e\n\x3cli\x3e一个可以在客户端渲染和运行应用的脚本\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eSSR scripts 101\x3c\/h3\x3e\n\x3cp\x3e下面的例子使用了 Vue.js。你如果习惯使用其它的框架（例如 React），不必担心，它们的核心思想都是类似的，一切看起来都是那么相似。\x3c\/p\x3e\n\x3cp\x3e简单起见，我们使用经典的 “ Hello World ” 例子。\x3c\/p\x3e\n\x3cp\x3e下面是程序的代码（没有 SSR）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ app.js\nimport Vue from \x27vue\x27\n\nnew Vue({\n  template: `\n    \x3cdiv\x3eHello, world!\x3c\/div\x3e\n  `,\n\n  el: \x27#app\x27\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e app.js\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  template: `\x3cspan class=\x22javascript\x22\x3e\n    \x26lt;div\x26gt;Hello, world!\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  \x3c\/span\x3e`,\n\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这短代码实例化了一个 Vue 组件，并且在一个容器（id 值为 \x3ccode\x3eapp\x3c\/code\x3e 的 空 \x3ccode\x3ediv\x3c\/code\x3e）渲染。\x3c\/p\x3e\n\x3cp\x3e如果在服务端运行这点脚本，会抛出错误，因为没有 DOM 可访问，而 Vue 却尝试在一个不存在的元素里渲染应用。\x3c\/p\x3e\n\x3cp\x3e重构这段脚本，使其 \x3cem\x3e可以\x3c\/em\x3e 在服务端运行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ app.js\nimport Vue from \x27vue\x27\n\nexport default () =\x3e new Vue({\n  template: `\n    \x3cdiv\x3eHello, world!\x3c\/div\x3e\n  `\n})\n\n\/\/ entry-client.js\nimport createApp from \x27.\/app\x27\n\nconst app = createApp()\n\napp.$mount(\x27#app\x27)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ app.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e () =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div\x26gt;Hello, world!\x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ entry-client.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e createApp \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = createApp()\n\napp.$mount(\x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将之前的代码分成两部分。\x3ccode\x3eapp.js\x3c\/code\x3e 作为创建应用实例的工厂，而第二部分，即 \x3ccode\x3eentry-client.js\x3c\/code\x3e，会运行在浏览器，它使用工厂创建了应用实例，并且挂载在 DOM。\x3c\/p\x3e\n\x3cp\x3e现在我们可以创建一个没有 DOM 依赖性的应用程序，可以为服务端编写第二个脚本。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ entry-server.js\nimport createApp from \x27.\/app\x27\nimport renderToString from \x27vue-server-renderer\/basic\x27\n\nconst app = createApp()\n\nrenderToString(app, (err, html) =\x3e {\n  if (err) {\n    throw new Error(err)\n  }\n  \/\/ Dispatch the HTML string to the client...\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ entry-server.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e createApp \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e renderToString \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue-server-renderer\/basic\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = createApp()\n\nrenderToString(app, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, html\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(err)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Dispatch the HTML string to the client...\x3c\/span\x3e\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们引入了相同的应用工厂，但我们使用服务端渲染的方式来渲染纯 HTML 字符串，它将包含应用初始状态的展示。\x3c\/p\x3e\n\x3cp\x3e我们已经具备三个关键因素中的两个：服务端脚本和客户端脚本。现在，让我们在 PHP 上运行它吧！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e执行 JavaScript\x3c\/h2\x3e\n\x3cp\x3e在 PHP 运行 JavaScript，想到的第一个选择是 V8Js。V8Js 是嵌入在 PHP 扩展的 V8 引擎，它允许我们执行 JavaScript。\x3c\/p\x3e\n\x3cp\x3e使用 V8Js 执行脚本非常直接。我们可以用 PHP 中的输出缓冲和 JavaScript 中的 \x3ccode\x3eprint\x3c\/code\x3e 来捕获结果。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$v8 = new V8Js();\n\nob_start();\n\n\/\/ $script 包含了我们想执行的脚本内容\n\n$v8-\x3eexecuteString($script);\n\necho ob_get_contents();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e$v8 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e V8Js();\n\nob_start();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ $script 包含了我们想执行的脚本内容\x3c\/span\x3e\n\n$v8-\x26gt;executeString($script);\n\n\x3cspan class=\x22hljs-keyword\x22\x3eecho\x3c\/span\x3e ob_get_contents();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22print(\x27\x3cdiv\x3eHello, world!\x3c\/div\x3e\x27)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;Hello, world!\x26lt;\/div\x26gt;\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方法的缺点是需要第三方 PHP 扩展，而扩展可能很难或者不能在你的系统上安装，所以如果有其他（不需要安装扩展的）方法，它会更好的选择。\x3c\/p\x3e\n\x3cp\x3e这个不一样的方法就是使用 Node.js 运行 JavaScript。我们可以开启一个 Node 进程，它负责运行脚本并且捕获输出。\x3cbr\x3eSymfony 的\x26nbsp;\x3ccode\x3eProcess\x3c\/code\x3e 组件就是我们想要的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22use Symfony\\Component\\Process\\Process;\n\n\/\/ $nodePath 是可执行的 Node.js 的路径\n\/\/ $scriptPath 是想要执行的 JavaScript 脚本的路径\n\nnew Process([$nodePath, $scriptPath]);\n\necho $process-\x3emustRun()-\x3egetOutput();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSymfony\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ $nodePath 是可执行的 Node.js 的路径\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ $scriptPath 是想要执行的 JavaScript 脚本的路径\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Process([$nodePath, $scriptPath]);\n\n\x3cspan class=\x22hljs-keyword\x22\x3eecho\x3c\/span\x3e $process-\x26gt;mustRun()-\x26gt;getOutput();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x27\x3cdiv\x3eHello, world!\x3c\/div\x3e\x27)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;Hello, world!\x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\x27)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，（打印）在 Node 中是调用 \x3ccode\x3econsole.log\x3c\/code\x3e 而不是 \x3ccode\x3eprint\x3c\/code\x3e 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e让我们一起来实现它吧！\x3c\/h2\x3e\n\x3cp\x3espatie\/server-side-rendering 包的其中一个关键理念是\x26nbsp;\x3ccode\x3e引擎\x3c\/code\x3e\x26nbsp;接口。引擎就是上述 JavaScript 执行的一个抽象概念。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22namespace Spatie\\Ssr;\n\n\/**\n * 创建引擎接口。\n *\/\ninterface Engine\n{\n    public function run(string $script): string;\n    public function getDispatchHandler(): string;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e Spatie\\Ssr;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 创建引擎接口。\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEngine\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(string $script)\x3c\/span\x3e: string\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetDispatchHandler\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e: string\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3erun\x3c\/code\x3e\x26nbsp;方法预期一个脚本的输入 （脚本 \x3cem\x3e内容\x3c\/em\x3e，不是一条路径），并且返回执行结果。\x26nbsp;\x3ccode\x3egetDispatchHandler\x3c\/code\x3e\x26nbsp;允许引擎声明它预期脚本如何展示发布。例如 V8 中的\x3ccode\x3eprint\x3c\/code\x3e\x26nbsp;方法，或是 Node 中的 \x3ccode\x3econsole.log\x3c\/code\x3e\x26nbsp;。\x3c\/p\x3e\n\x3cp\x3eV8Js 引擎实现起来并不是很花俏。它更类似于我们上述理念的验证，带有一些附加的错误处理机制。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22namespace Spatie\\Ssr\\Engines;\n\nuse V8Js;\nuse V8JsException;\nuse Spatie\\Ssr\\Engine;\nuse Spatie\\Ssr\\Exceptions\\EngineError;\n\n\/**\n * 创建一个 V8 类来实现引擎接口类 Engine 。\n *\/\nclass V8 implements Engine。\n{\n    \/** @var \\V8Js *\/\n    protected $v8;\n\n    public function __construct(V8Js $v8)\n    {\n        $this-\x3ev8 = $v8;\n    }\n\n    \/**\n     * 打开缓冲区。\n     * 返回缓冲区存储v8的脚本处理结果。\n     *\/\n    public function run(string $script): string\n    {\n        try {\n            ob_start();\n\n            $this-\x3ev8-\x3eexecuteString($script);\n\n            return ob_get_contents();\n        } catch (V8JsException $exception) {\n            throw EngineError::withException($exception);\n        } finally {\n            ob_end_clean();\n        }\n    }\n\n    public function getDispatchHandler(): string\n    {\n        return \x27print\x27;\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngines\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eV8Js\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eV8JsException\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngine\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eExceptions\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngineError\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 创建一个 V8 类来实现引擎接口类 Engine 。\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eV8\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEngine\x3c\/span\x3e。\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** \x3cspan class=\x22hljs-doctag\x22\x3e@var\x3c\/span\x3e \\V8Js *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eprotected\x3c\/span\x3e $v8;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e__construct\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(V8Js $v8)\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;v8 = $v8;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 打开缓冲区。\n     * 返回缓冲区存储v8的脚本处理结果。\n     *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(string $script)\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            ob_start();\n\n            \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;v8-\x26gt;executeString($script);\n\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ob_get_contents();\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (V8JsException $exception) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e EngineError::withException($exception);\n        } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n            ob_end_clean();\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetDispatchHandler\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27print\x27\x3c\/span\x3e;\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意这里我们将\x26nbsp;\x3ccode\x3eV8JsException\x3c\/code\x3e\x26nbsp;重新抛出作为我们的\x26nbsp;\x3ccode\x3eEngineError\x3c\/code\x3e。 这样我们就可以在任何的引擎视线中捕捉相同的异常。\x3c\/p\x3e\n\x3cp\x3eNode 引擎会更加复杂一点。不像 V8Js，Node 需要\x26nbsp;\x3cem\x3e文件\x3c\/em\x3e\x26nbsp;去执行，而不是脚本内容。在执行一个服务端脚本前，它需要被保存到一个临时的路径。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22namespace Spatie\\Ssr\\Engines;\n\nuse Spatie\\Ssr\\Engine;\nuse Spatie\\Ssr\\Exceptions\\EngineError;\nuse Symfony\\Component\\Process\\Process;\nuse Symfony\\Component\\Process\\Exception\\ProcessFailedException;\n\n\/**\n * 创建一个 Node 类来实现引擎接口类 Engine 。\n *\/\nclass Node implements Engine\n{\n    \/** @var string *\/\n    protected $nodePath;\n\n    \/** @var string *\/\n    protected $tempPath;\n\n    public function __construct(string $nodePath, string $tempPath)\n    {\n        $this-\x3enodePath = $nodePath;\n        $this-\x3etempPath = $tempPath;\n    }\n\n    public function run(string $script): string\n    {\n        \/\/ 生成一个随机的、独一无二的临时文件路径。\n        $tempFilePath = $this-\x3ecreateTempFilePath();\n\n        \/\/ 在临时文件中写进脚本内容。\n        file_put_contents($tempFilePath, $script);\n\n        \/\/ 创建进程执行临时文件。\n        $process = new Process([$this-\x3enodePath, $tempFilePath]);\n\n        try {\n            return substr($process-\x3emustRun()-\x3egetOutput(), 0, -1);\n        } catch (ProcessFailedException $exception) {\n            throw EngineError::withException($exception);\n        } finally {\n            unlink($tempFilePath);\n        }\n    }\n\n    public function getDispatchHandler(): string\n    {\n        return \x27console.log\x27;\n    }\n\n    protected function createTempFilePath(): string\n    {\n        return $this-\x3etempPath.\x27\/\x27.md5(time()).\x27.js\x27;\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngines\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngine\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSpatie\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eSsr\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eExceptions\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eEngineError\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSymfony\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSymfony\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcess\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eException\x3c\/span\x3e\\\x3cspan class=\x22hljs-title\x22\x3eProcessFailedException\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 创建一个 Node 类来实现引擎接口类 Engine 。\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEngine\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** \x3cspan class=\x22hljs-doctag\x22\x3e@var\x3c\/span\x3e string *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eprotected\x3c\/span\x3e $nodePath;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** \x3cspan class=\x22hljs-doctag\x22\x3e@var\x3c\/span\x3e string *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eprotected\x3c\/span\x3e $tempPath;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e__construct\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(string $nodePath, string $tempPath)\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;nodePath = $nodePath;\n        \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;tempPath = $tempPath;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(string $script)\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成一个随机的、独一无二的临时文件路径。\x3c\/span\x3e\n        $tempFilePath = \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;createTempFilePath();\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在临时文件中写进脚本内容。\x3c\/span\x3e\n        file_put_contents($tempFilePath, $script);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建进程执行临时文件。\x3c\/span\x3e\n        $process = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Process([\x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;nodePath, $tempFilePath]);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e substr($process-\x26gt;mustRun()-\x26gt;getOutput(), \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (ProcessFailedException $exception) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e EngineError::withException($exception);\n        } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n            unlink($tempFilePath);\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetDispatchHandler\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27console.log\x27\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eprotected\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateTempFilePath\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;tempPath.\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e.md5(time()).\x3cspan class=\x22hljs-string\x22\x3e\x27.js\x27\x3c\/span\x3e;\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了临时路径步骤之外，实现方法看起来也是相当直截了当。\x3c\/p\x3e\n\x3cp\x3e我们已经创建好了 \x3ccode\x3eEngine\x3c\/code\x3e 接口，接下来需要编写渲染的类。以下的渲染类来自于 spatie\/server-side-rendering 扩展包，是一个最基本的渲染类的结构。\x3c\/p\x3e\n\x3cp\x3e渲染类唯一的依赖是 \x3ccode\x3eEngine\x3c\/code\x3e 接口的实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Renderer\n{\n    public function __construct(Engine $engine)\n    {\n        $this-\x3eengine = $engine;\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRenderer\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e__construct\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Engine $engine)\x3c\/span\x3e\n    \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;engine = $engine;\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e渲染方法 \x3ccode\x3erender\x3c\/code\x3e 里将会处理渲染部分的逻辑，想要执行一个 JavaScript 脚本文件，需要以下两个元素：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e我们的应用脚本文件；\x3c\/li\x3e\n\x3cli\x3e一个用来获取解析产生的 HTML 的分发方法；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一个简单的 \x3ccode\x3erender\x3c\/code\x3e\x26nbsp;如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Renderer\n{\n    public function render(string $entry): string\n    {\n        $serverScript = implode(\x27;\x27, [\n            \x26quot;var dispatch = {$this-\x3eengine-\x3egetDispatchHandler()}\x26quot;,\n            file_get_contents($entry),\n        ]);\n\n        return $this-\x3eengine-\x3erun($serverScript);\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRenderer\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(string $entry)\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\n    \x3c\/span\x3e{\n        $serverScript = implode(\x3cspan class=\x22hljs-string\x22\x3e\x27;\x27\x3c\/span\x3e, [\n            \x3cspan class=\x22hljs-string\x22\x3e\x22var dispatch = {$this-\x26gt;engine-\x26gt;getDispatchHandler()}\x22\x3c\/span\x3e,\n            file_get_contents($entry),\n        ]);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3e$this\x3c\/span\x3e-\x26gt;engine-\x26gt;run($serverScript);\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此方法接受 \x26nbsp;\x3ccode\x3eentry-server.js\x3c\/code\x3e\x26nbsp;文件路径作为参数。\x3c\/p\x3e\n\x3cp\x3e我们需要将解析前的 HTML 从脚本中分发到 PHP 环境中。\x3ccode\x3edispatch\x3c\/code\x3e 方法返回  \x3ccode\x3eEngine\x3c\/code\x3e 类里的 \x3ccode\x3egetDispatchHandler\x3c\/code\x3e 方法，\x3ccode\x3edispatch\x3c\/code\x3e 需要在服务器脚本加载前运行。\x3c\/p\x3e\n\x3cp\x3e还记得我们的服务器端入口脚本吗？接下来我们在此脚本中调用我们的 \x26nbsp;\x3ccode\x3edispatch\x3c\/code\x3e 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ entry-server.js\nimport app from \x27.\/app\x27\nimport renderToString from \x27vue-server-renderer\/basic\x27\n\nrenderToString(app, (err, html) =\x3e {\n  if (err) {\n    throw new Error(err)\n  }\n  dispatch(html)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ entry-server.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e app \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e renderToString \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue-server-renderer\/basic\x27\x3c\/span\x3e\n\nrenderToString(app, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, html\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(err)\n  }\n  dispatch(html)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue 的应用脚本无需特殊处理，只需要使用 \x26nbsp;\x3ccode\x3efile_get_contents\x3c\/code\x3e 方法读取文件即可。\x3c\/p\x3e\n\x3cp\x3e我们已经成功创建了一个 PHP 的 SSR 。spatie\/server-side-rendering 中的完整渲染器 \x3ccode\x3eRenderer\x3c\/code\x3e\x26nbsp;跟我们实现有点不一样，他们拥有更高的容错能力，和更加丰富的功能如有一套 PHP 和 JavaScript 共享数据的机制。如果你感兴趣的话，建议你阅读下源码 \x3ca href=\x22https:\/\/github.com\/spatie\/server-side-rendering\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eserver-side-rendering 代码库\x3c\/a\x3e\x26nbsp;。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e三思而后行\x3c\/h2\x3e\n\x3cp\x3e我们弄清楚了服务器端渲染的利和弊，知道 SSR 会增加应用程序架构和基础结构的复杂度。如果服务器端渲染不能为你的业务提供任何价值，那么你可能不应该首先考虑他。\x3c\/p\x3e\n\x3cp\x3e如果你 \x3cem\x3e确实\x3c\/em\x3e 想开始使用服务器端渲染，请先阅读应用程序的架构。大多数 JavaScript 框架都有关于 SSR 的深入指南。Vue.js 甚至有一个专门的 SSR \x3ca href=\x22https:\/\/ssr.vuejs.org\/en\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文档网站\x3c\/a\x3e，解释了诸如数据获取和管理用于服务器端渲染的应用程序方面的坑。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e如果可能，请使用经过实战检验的解决方案\x3c\/h3\x3e\n\x3cp\x3e有许多经过实战检验的解决方案，能提供很好的 SSR 开发体验。比如，如果你在构建 React 应用，可以使用 \x3ca href=\x22https:\/\/github.com\/zeit\/next.js\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNext.js\x3c\/a\x3e，或者你更青睐于 Vue\x26nbsp;则可用 \x3ca href=\x22https:\/\/nuxtjs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNuxt.js\x3c\/a\x3e，这些都是很引人注目的项目。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e还不够？尝试 PHP 服务端渲染\x3c\/h3\x3e\n\x3cp\x3e你仅能以有限的资源来管理基础架构上的复杂性。你想将服务端渲染作为大型 PHP 应用中的一部分。你不想构建和维护无状态的 API。 如果这些原因和你的情况吻合，那么使用 PHP 进行服务端渲染将会是个不错方案。\x3c\/p\x3e\n\x3cp\x3e我已经发布两个库来支持 PHP 的服务端 JavaScript 渲染： \x26nbsp;\x3ca href=\x22https:\/\/github.com\/spatie\/server-side-rendering\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espatie\/server-side-rendering\x3c\/a\x3e\x26nbsp; 和专为 Laravel 应用打造的 \x3ca href=\x22https:\/\/github.com\/spatie\/laravel-server-side-rendering\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espatie\/laravel-server-side-rendering\x3c\/a\x3e\x26nbsp;\x26nbsp;。Laravel 定制版在 Laravel 应用中近乎 0 配置即可投入使用，通用版需要根据运行环境做一些设置调整。当然，详细内容可以参考软件包自述文件。\x3c\/p\x3e\n\x3cp\x3e如果你仅是想体验，从 \x3ca href=\x22http:\/\/github.com\/spatie\/laravel-server-side-rendering-examples\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espatie\/laravel-server-side-rendering-examples\x3c\/a\x3e\x26nbsp; 检出项目并参考指南进行安装。\x3c\/p\x3e\n\x3cp\x3e如果你考虑服务端渲染，我希望这类软件包可以帮到你，并期待通过 Github 做进一步问题交流和反馈！\x3c\/p\x3e\n\x3cblockquote\x3e更多现代化 PHP 知识，请前往 \x3ca href=\x22https:\/\/laravel-china.org\/topics\/8928\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLaravel \/ PHP 知识社区\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>使用 PHP 来做 Vue.js 的 SSR 服务端渲染</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014155027">https://segmentfault.com/a/1190000014155027</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ehdh9abcu2n/" target="_blank">https://alili.tech/archive/ehdh9abcu2n/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>