<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="NodeJs爬虫抓取古代典籍，共计16000个页面心得体会总结及项目分享"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>NodeJs爬虫抓取古代典籍，共计16000个页面心得体会总结及项目分享 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ei5zzughtel/",
				"appid": "1613049289050283", 
				"title": "NodeJs爬虫抓取古代典籍，共计16000个页面心得体会总结及项目分享 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-20T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ckn5cx86xz8/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/oyc8oeyxub/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&text=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&text=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&title=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&is_video=false&description=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&title=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&title=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&title=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fei5zzughtel%2f&title=NodeJs%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96%e5%8f%a4%e4%bb%a3%e5%85%b8%e7%b1%8d%ef%bc%8c%e5%85%b1%e8%ae%a116000%e4%b8%aa%e9%a1%b5%e9%9d%a2%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a%e6%80%bb%e7%bb%93%e5%8f%8a%e9%a1%b9%e7%9b%ae%e5%88%86%e4%ba%ab"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">NodeJs爬虫抓取古代典籍，共计16000个页面心得体会总结及项目分享</h1><div class="meta"><div class="postdate"><time datetime="2018-12-20" itemprop="datePublished">2018-12-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e前言\x3c\/h3\x3e\n\x3cp\x3e之前研究数据，零零散散的写过一些数据抓取的爬虫，不过写的比较随意。有很多地方现在看起来并不是很合理 这段时间比较闲，本来是想给之前的项目做重构的。\x3cbr\x3e后来 利用这个周末，索性重新写了一个项目，就是本项目 guwen-spider。目前这个爬虫还是比较简单的类型的， 直接抓取页面，然后在页面中提取数据，保存数据到数据库。\x3cbr\x3e通过与之前写的对比，我觉得难点在于整个程序的健壮性，以及相应的容错机制。在昨天写代码的过程中其实也有反映， 真正的主体代码其实很快就写完了 ，花了大部分时间是在\x3cbr\x3e做稳定性的调试， 以及寻求一种更合理的方式来处理数据与流程控制的关系。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012561778?w=1200\x26amp;h=498\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012561778?w=1200\x26amp;h=498\x22 alt=\x22spider-shortcut1.png\x22 title=\x22spider-shortcut1.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e背景\x3c\/h3\x3e\n\x3cp\x3e项目的背景是抓取一个一级页面是目录列表 ，点击一个目录进去 是一个章节 及篇幅列表 ，点击章节或篇幅进入具体的内容页面。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e概述\x3c\/h3\x3e\n\x3cp\x3e本项目github地址 : \x3ca href=\x22https:\/\/github.com\/yangfan0095\/guwen-spider\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eguwen-spider\x3c\/a\x3e  （PS:最后面还有彩蛋 ~~逃\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e项目技术细节\x3c\/strong\x3e\x3cbr\x3e   项目大量用到了 ES7 的async 函数, 更直观的反应程序了的流程。为了方便，在对数据遍历的过程中直接使用了著名的async这个库，所以不可避免的还是用到了回调promise ，因为数据的处理发生在回调函数中，不可避免的会遇到一些数据传递的问题，其实也可以直接用ES7的async await 写一个方法来实现相同的功能。这里其实最赞的一个地方是使用了 Class 的 static 方法封装对数据库的操作， static 顾名思义 静态方法 就跟 prototype 一样 ，不会占用额外空间。\x3cbr\x3e项目主要用到了\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e1 ES7的 async await 协程做异步有关的逻辑处理。\x3c\/li\x3e\n\x3cli\x3e2 使用 npm的 async库 来做循环遍历，以及并发请求操作。\x3c\/li\x3e\n\x3cli\x3e3 使用 log4js 来做日志处理\x3c\/li\x3e\n\x3cli\x3e4 使用 cheerio 来处理dom的操作。\x3c\/li\x3e\n\x3cli\x3e5 使用 mongoose 来连接mongoDB 做数据的保存以及操作。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e目录结构\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x26lt;pre\x26gt;\x3cbr\x3e├── bin              \/\/ 入口\x3cbr\x3e│\x26nbsp;  ├── booklist.js         \/\/ 抓取书籍逻辑\x3cbr\x3e│\x26nbsp;  ├── chapterlist.js      \/\/ 抓取章节逻辑\x3cbr\x3e│\x26nbsp;  ├── content.js          \/\/ 抓取内容逻辑\x3cbr\x3e│\x26nbsp;  └── index.js            \/\/ 程序入口\x3cbr\x3e├── config             \/\/ 配置文件\x3cbr\x3e├── dbhelper           \/\/ 数据库操作方法目录\x3cbr\x3e├── logs             \/\/ 项目日志目录\x3cbr\x3e├── model         \/\/ mongoDB 集合操作实例\x3cbr\x3e├── node_modules         \x3cbr\x3e├── utils         \/\/ 工具函数\x3cbr\x3e├── package.json       \x3cbr\x3e\x26lt;\/pre\x26gt;\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e项目实现方案分析\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e项目是一个典型的多级抓取案例，目前只有三级，即 书籍列表， 书籍项对应的 章节列表，一个章节链接对应的内容。 抓取这样的结构可以采用两种方式， 一是 直接从外层到内层 内层抓取完以后再执行下一个外层的抓取， 还有一种就是先把外层抓取完成保存到数据库，然后根据外层抓取到所有内层章节的链接，再次保存，然后从数据库查询到对应的链接单元 对之进行内容抓取。这两种方案各有利弊，其实两种方式我都试过， 后者有一个好处，因为对三个层级是分开抓取的， 这样就能够更方便，尽可能多的保存到对应章节的相关数据。 可以试想一下 ，如果采用前者 按照正常的逻辑\x3cbr\x3e对一级目录进行遍历抓取到对应的二级章节目录， 再对章节列表进行遍历 抓取内容，到第三级 内容单元抓取完成 需要保存时，如果需要很多的一级目录信息，就需要 这些分层的数据之间进行数据传递 ，想想其实应该是比较复杂的一件事情。所以分开保存数据 一定程度上避开了不必要的复杂的数据传递。\x3c\/p\x3e\n\x3cp\x3e目前我们考虑到 其实我们要抓取到的古文书籍数量并不多，古文书籍大概只有180本囊括了各种经史。其和章节内容本身是一个很小的数据 ，即一个集合里面有180个文档记录。 这180本书所有章节抓取下来一共有一万六千个章节，对应需要访问一万六千个页面爬取到对应的内容。所以选择第二种应该是合理的。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e项目实现\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e主程有三个方法 bookListInit ,chapterListInit,contentListInit, 分别是抓取书籍目录，章节列表，书籍内容的方法对外公开暴露的初始化方法。通过async 可以实现对这三个方法的运行流程进行控制，书籍目录抓取完成将数据保存到数据库，然后执行结果返回到主程序，如果运行成功 主程序则执行根据书籍列表对章节列表的抓取，同理对书籍内容进行抓取。 \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e项目主入口\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 爬虫抓取主入口\n *\/\nconst start = async() =\x3e {\n    let booklistRes = await bookListInit();\n    if (!booklistRes) {\n        logger.warn(\x27书籍列表抓取出错，程序终止...\x27);\n        return;\n    }\n    logger.info(\x27书籍列表抓取成功，现在进行书籍章节抓取...\x27);\n\n    let chapterlistRes = await chapterListInit();\n    if (!chapterlistRes) {\n        logger.warn(\x27书籍章节列表抓取出错，程序终止...\x27);\n        return;\n    }\n    logger.info(\x27书籍章节列表抓取成功，现在进行书籍内容抓取...\x27);\n\n    let contentListRes = await contentListInit();\n    if (!contentListRes) {\n        logger.warn(\x27书籍章节内容抓取出错，程序终止...\x27);\n        return;\n    }\n    logger.info(\x27书籍内容抓取成功\x27);\n}\n\/\/ 开始入口\nif (typeof bookListInit === \x27function\x27 \x26amp;\x26amp; typeof chapterListInit === \x27function\x27) {\n    \/\/ 开始抓取\n    start();\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 爬虫抓取主入口\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e start = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e() =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e booklistRes = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookListInit();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!booklistRes) {\n        logger.warn(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍列表抓取出错，程序终止...\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍列表抓取成功，现在进行书籍章节抓取...\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e chapterlistRes = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e chapterListInit();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!chapterlistRes) {\n        logger.warn(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍章节列表抓取出错，程序终止...\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍章节列表抓取成功，现在进行书籍内容抓取...\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e contentListRes = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e contentListInit();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!contentListRes) {\n        logger.warn(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍章节内容抓取出错，程序终止...\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍内容抓取成功\x27\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始入口\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e bookListInit === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e chapterListInit === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始抓取\x3c\/span\x3e\n    start();\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e引入的 bookListInit ,chapterListInit,contentListInit,  三个方法\x3c\/p\x3e\n\x3cp\x3ebooklist.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 初始化方法 返回抓取结果 true 抓取成果 false 抓取失败\n *\/\nconst bookListInit = async() =\x3e {\n    logger.info(\x27抓取书籍列表开始...\x27);\n    const pageUrlList = getPageUrlList(totalListPage, baseUrl);\n    let res = await getBookList(pageUrlList);\n    return res;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 初始化方法 返回抓取结果 true 抓取成果 false 抓取失败\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bookListInit = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e() =\x26gt; {\n    logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27抓取书籍列表开始...\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pageUrlList = getPageUrlList(totalListPage, baseUrl);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e res = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getBookList(pageUrlList);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3echapterlist.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 初始化入口\n *\/\nconst chapterListInit = async() =\x3e {\n    const list = await bookHelper.getBookList(bookListModel);\n    if (!list) {\n        logger.error(\x27初始化查询书籍目录失败\x27);\n    }\n    logger.info(\x27开始抓取书籍章节列表，书籍目录共：\x27 \x2b list.length \x2b \x27条\x27);\n    let res = await asyncGetChapter(list);\n    return res;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 初始化入口\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chapterListInit = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e() =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookHelper.getBookList(bookListModel);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27初始化查询书籍目录失败\x27\x3c\/span\x3e);\n    }\n    logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27开始抓取书籍章节列表，书籍目录共：\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.length \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27条\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e res = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncGetChapter(\x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3econtent.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 初始化入口\n *\/\nconst contentListInit = async() =\x3e {\n    \/\/获取书籍列表\n    const list = await bookHelper.getBookLi(bookListModel);\n    if (!list) {\n        logger.error(\x27初始化查询书籍目录失败\x27);\n        return;\n    }\n    const res = await mapBookList(list);\n    if (!res) {\n        logger.error(\x27抓取章节信息，调用 getCurBookSectionList() 进行串行遍历操作，执行完成回调出错，错误信息已打印，请查看日志!\x27);\n        return;\n    }\n    return res;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 初始化入口\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e contentListInit = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e() =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取书籍列表\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookHelper.getBookLi(bookListModel);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27初始化查询书籍目录失败\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mapBookList(\x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!res) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27抓取章节信息，调用 getCurBookSectionList() 进行串行遍历操作，执行完成回调出错，错误信息已打印，请查看日志!\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e内容抓取的思考\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e书籍目录抓取其实逻辑非常简单，只需要使用async.mapLimit做一个遍历就可以保存数据了,但是我们在保存内容的时候 简化的逻辑其实就是 遍历章节列表 抓取链接里的内容。但是实际的情况是链接数量多达几万 我们从内存占用角度也不能全部保存到一个数组中，然后对其遍历，所以我们需要对内容抓取进行单元化。\x3cbr\x3e普遍的遍历方式 是每次查询一定的数量，来做抓取，这样缺点是只是以一定数量做分类，数据之间没有关联，以批量方式进行插入，如果出错 则容错会有一些小问题，而且我们想一本书作为一个集合单独保存会遇到问题。因此我们采用第二种就是以一个书籍单元进行内容抓取和保存。\x3cbr\x3e这里使用了 \x3ccode\x3easync.mapLimit(list, 1, (series, callback) =\x26gt; {})\x3c\/code\x3e这个方法来进行遍历，不可避免的用到了回调，感觉很恶心。async.mapLimit()的第二个参数可以设置同时请求数量。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/* \n * 内容抓取步骤：\n * 第一步得到书籍列表， 通过书籍列表查到一条书籍记录下 对应的所有章节列表， \n * 第二步 对章节列表进行遍历获取内容保存到数据库中 \n * 第三步 保存完数据后 回到第一步 进行下一步书籍的内容抓取和保存\n *\/\n\n\/**\n * 初始化入口\n *\/\nconst contentListInit = async() =\x3e {\n    \/\/获取书籍列表\n    const list = await bookHelper.getBookList(bookListModel);\n    if (!list) {\n        logger.error(\x27初始化查询书籍目录失败\x27);\n        return;\n    }\n    const res = await mapBookList(list);\n    if (!res) {\n        logger.error(\x27抓取章节信息，调用 getCurBookSectionList() 进行串行遍历操作，执行完成回调出错，错误信息已打印，请查看日志!\x27);\n        return;\n    }\n    return res;\n}\n\/**\n * 遍历书籍目录下的章节列表\n * @param {*} list \n *\/\nconst mapBookList = (list) =\x3e {\n    return new Promise((resolve, reject) =\x3e {\n        async.mapLimit(list, 1, (series, callback) =\x3e {\n            let doc = series._doc;\n            getCurBookSectionList(doc, callback);\n        }, (err, result) =\x3e {\n            if (err) {\n                logger.error(\x27书籍目录抓取异步执行出错!\x27);\n                logger.error(err);\n                reject(false);\n                return;\n            }\n            resolve(true);\n        })\n    })\n}\n\n\/**\n * 获取单本书籍下章节列表 调用章节列表遍历进行抓取内容\n * @param {*} series \n * @param {*} callback \n *\/\nconst getCurBookSectionList = async(series, callback) =\x3e {\n\n    let num = Math.random() * 1000 \x2b 1000;\n    await sleep(num);\n    let key = series.key;\n    const res = await bookHelper.querySectionList(chapterListModel, {\n        key: key\n    });\n    if (!res) {\n        logger.error(\x27获取当前书籍: \x27 \x2b series.bookName \x2b \x27 章节内容失败，进入下一部书籍内容抓取!\x27);\n        callback(null, null);\n        return;\n    }\n    \/\/判断当前数据是否已经存在\n    const bookItemModel = getModel(key);\n    const contentLength = await bookHelper.getCollectionLength(bookItemModel, {});\n    if (contentLength === res.length) {\n        logger.info(\x27当前书籍：\x27 \x2b series.bookName \x2b \x27数据库已经抓取完成，进入下一条数据任务\x27);\n        callback(null, null);\n        return;\n    }\n    await mapSectionList(res);\n    callback(null, null);\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* \n * 内容抓取步骤：\n * 第一步得到书籍列表， 通过书籍列表查到一条书籍记录下 对应的所有章节列表， \n * 第二步 对章节列表进行遍历获取内容保存到数据库中 \n * 第三步 保存完数据后 回到第一步 进行下一步书籍的内容抓取和保存\n *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 初始化入口\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e contentListInit = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e() =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取书籍列表\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e list = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookHelper.getBookList(bookListModel);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!list) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27初始化查询书籍目录失败\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mapBookList(list);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!res) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27抓取章节信息，调用 getCurBookSectionList() 进行串行遍历操作，执行完成回调出错，错误信息已打印，请查看日志!\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 遍历书籍目录下的章节列表\n * @param {*} list \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapBookList = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3elist\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e.mapLimit(list, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseries, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e doc = series._doc;\n            getCurBookSectionList(doc, callback);\n        }, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, result\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n                logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍目录抓取异步执行出错!\x27\x3c\/span\x3e);\n                logger.error(err);\n                reject(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n            resolve(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        })\n    })\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 获取单本书籍下章节列表 调用章节列表遍历进行抓取内容\n * @param {*} series \n * @param {*} callback \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getCurBookSectionList = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e(series, callback) =\x26gt; {\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e num = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e sleep(num);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key = series.key;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookHelper.querySectionList(chapterListModel, {\n        key: key\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!res) {\n        logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27获取当前书籍: \x27\x3c\/span\x3e \x2b series.bookName \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 章节内容失败，进入下一部书籍内容抓取!\x27\x3c\/span\x3e);\n        callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断当前数据是否已经存在\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bookItemModel = getModel(key);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e contentLength = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e bookHelper.getCollectionLength(bookItemModel, {});\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (contentLength === res.length) {\n        logger.info(\x3cspan class=\x22hljs-string\x22\x3e\x27当前书籍：\x27\x3c\/span\x3e \x2b series.bookName \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27数据库已经抓取完成，进入下一条数据任务\x27\x3c\/span\x3e);\n        callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mapSectionList(res);\n    callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e数据抓取完了 怎么保存是个问题\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这里我们通过key 来给数据做分类，每次按照key来获取链接，进行遍历，这样的好处是保存的数据是一个整体，现在思考数据保存的问题\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e1 可以以整体的方式进行插入 \x3cp\x3e优点 : 速度快 数据库操作不浪费时间。 \x3c\/p\x3e\n\x3cp\x3e缺点 : 有的书籍可能有几百个章节 也就意味着要先保存几百个页面的内容再进行插入，这样做同样很消耗内存，有可能造成程序运行不稳定。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e2可以以每一篇文章的形式插入数据库。\x3cp\x3e优点 : 页面抓取即保存的方式 使得数据能够及时保存，即使后续出错也不需要重新保存前面的章节， \x3c\/p\x3e\n\x3cp\x3e缺点 : 也很明显 就是慢 ，仔细想想如果要爬几万个页面 做 几万次*N 数据库的操作 这里还可以做一个缓存器一次性保存一定条数 当条数达到再做保存这样也是一个不错的选择。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 遍历单条书籍下所有章节 调用内容抓取方法\n * @param {*} list \n *\/\nconst mapSectionList = (list) =\x3e {\n    return new Promise((resolve, reject) =\x3e {\n        async.mapLimit(list, 1, (series, callback) =\x3e {\n            let doc = series._doc;\n            getContent(doc, callback)\n        }, (err, result) =\x3e {\n            if (err) {\n                logger.error(\x27书籍目录抓取异步执行出错!\x27);\n                logger.error(err);\n                reject(false);\n                return;\n            }\n            const bookName = list[0].bookName;\n            const key = list[0].key;\n\n            \/\/ 以整体为单元进行保存\n            saveAllContentToDB(result, bookName, key, resolve);\n\n            \/\/以每篇文章作为单元进行保存\n            \/\/ logger.info(bookName \x2b \x27数据抓取完成，进入下一部书籍抓取函数...\x27);\n            \/\/ resolve(true);\n\n        })\n    })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 遍历单条书籍下所有章节 调用内容抓取方法\n * @param {*} list \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapSectionList = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3elist\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e.mapLimit(list, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseries, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e doc = series._doc;\n            getContent(doc, callback)\n        }, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, result\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n                logger.error(\x3cspan class=\x22hljs-string\x22\x3e\x27书籍目录抓取异步执行出错!\x27\x3c\/span\x3e);\n                logger.error(err);\n                reject(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bookName = list[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].bookName;\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key = list[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].key;\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以整体为单元进行保存\x3c\/span\x3e\n            saveAllContentToDB(result, bookName, key, resolve);\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/以每篇文章作为单元进行保存\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ logger.info(bookName \x2b \x27数据抓取完成，进入下一部书籍抓取函数...\x27);\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve(true);\x3c\/span\x3e\n\n        })\n    })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两者各有利弊，这里我们都做了尝试。 准备了两个错误保存的集合,errContentModel, errorCollectionModel,在插入出错时 分别保存信息到对应的集合中，二者任选其一即可。增加集合来保存数据的原因是 便于一次性查看以及后续操作， 不用看日志。\x3c\/p\x3e\n\x3cp\x3e（PS ，其实完全用 errorCollectionModel 这个集合就可以了  ，errContentModel这个集合可以完整保存章节信息）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/保存出错的数据名称\nconst errorSpider = mongoose.Schema({\n    chapter: String,\n    section: String,\n    url: String,\n    key: String,\n    bookName: String,\n    author: String,\n})\n\/\/ 保存出错的数据名称 只保留key 和 bookName信息\nconst errorCollection = mongoose.Schema({\n    key: String,\n    bookName: String,\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/保存出错的数据名称\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e errorSpider = mongoose.Schema({\n    chapter: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    section: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    url: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    bookName: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    author: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存出错的数据名称 只保留key 和 bookName信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e errorCollection = mongoose.Schema({\n    \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n    bookName: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e,\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将每一条书籍信息的内容 放到一个新的集合中，集合以key来进行命名。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e写这个项目 其实主要的难点在于程序稳定性的控制，容错机制的设置，以及错误的记录，目前这个项目基本能够实现直接运行 一次性跑通整个流程。 但是程序设计也肯定还存在许多问题 ，欢迎指正和交流。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e彩蛋\x3c\/h2\x3e\n\x3cp\x3e写完这个项目 做了一个基于React开的前端网站用于页面浏览 和一个基于koa2.x开发的服务端, 整体技术栈相当于是 React \x2b Redux \x2b Koa2 ,前后端服务是分开部署的，各自独立可以更好的去除前后端服务的耦合性，比如同一套服务端代码，不仅可以给web端 还可以给 移动端 ，app 提供支持。目前整个一套还很简陋，但是可以满足基本的查询浏览功能。希望后期有时间可以把项目变得更加丰富。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e本项目地址  地址 : \x3ca href=\x22https:\/\/github.com\/yangfan0095\/guwen-spider\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eguwen-spider\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e对应前端 React \x2b Redux \x2b semantic-ui   地址 : \x3ca href=\x22https:\/\/github.com\/yangfan0095\/guwen-react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eguwen-react\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e对应Node端 Koa2.2 \x2b mongoose  地址 : \x3ca href=\x22https:\/\/github.com\/yangfan0095\/guwen-node\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eguwen-node\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e项目挺简单的 ，但是多了一个学习和研究 从前端到服务端的开发的环境。\x3c\/p\x3e\n\x3cp\x3e以上です\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>NodeJs爬虫抓取古代典籍，共计16000个页面心得体会总结及项目分享</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012561786">https://segmentfault.com/a/1190000012561786</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ei5zzughtel/" target="_blank">https://alili.tech/archive/ei5zzughtel/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>