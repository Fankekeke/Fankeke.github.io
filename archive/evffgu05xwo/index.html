<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Javascript事件循环机制以及渲染引擎何时渲染UI"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Javascript事件循环机制以及渲染引擎何时渲染UI | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/evffgu05xwo/",
				"appid": "1613049289050283", 
				"title": "Javascript事件循环机制以及渲染引擎何时渲染UI | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-14T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jlrarcxdpmg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/mlw8afd1ep/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&text=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&text=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&title=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&is_video=false&description=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&title=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&title=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&title=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fevffgu05xwo%2f&title=Javascript%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e4%bb%a5%e5%8f%8a%e6%b8%b2%e6%9f%93%e5%bc%95%e6%93%8e%e4%bd%95%e6%97%b6%e6%b8%b2%e6%9f%93UI"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Javascript事件循环机制以及渲染引擎何时渲染UI</h1><div class="meta"><div class="postdate"><time datetime="2018-12-14" itemprop="datePublished">2018-12-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3eJavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e事件循环基本概念\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3eJavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。\x3c\/li\x3e\n\x3cli\x3e一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。\x3c\/li\x3e\n\x3cli\x3e任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。\x3c\/li\x3e\n\x3cli\x3emacro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I\/O, UI rendering。\x3c\/li\x3e\n\x3cli\x3emicro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)\x3c\/li\x3e\n\x3cli\x3esetTimeout\/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ setTimeout中的回调函数才是进入任务队列的任务\nsetTimeout(function() {\n    console.log(\x27xxxx\x27);\n})\n\/\/ 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：\n\/\/ setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ setTimeout中的回调函数才是进入任务队列的任务\x3c\/span\x3e\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27xxxx\x27\x3c\/span\x3e);\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。\x3c\/li\x3e\n\x3cli\x3e其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e事件循环执行循序\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(\x3c\/strong\x3e只剩全局\x3cstrong\x3e)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后，本轮循环结束。下一轮循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e那么整个事件循环中何时进行ui render呢？\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;div\x26quot;\x3e\n    begin\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    begin\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(function() {\n    \/\/ 应该是这里执行前开始渲染ui，试试用alert阻塞下。\n    alert(\x27 ui 已经渲染完毕了吗？ \x27);\n    console.log(\x27timeout1\x27);\n})\n\nnew Promise(function(resolve) {\n    console.log(\x27promise1\x27);\n    for(var i = 0; i \x3c 1000; i\x2b\x2b) {\n        i == 99 \x26amp;\x26amp; resolve();\n    }\n    console.log(\x27promise2\x27);\n}).then(function() {\n    console.log(\x27then1\x27);\n    alert(\x27 ui 开始渲染 \x27);\n})\n\nconsole.log(\x27global1\x27);\n\ndiv.innerHTML = \x27end\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 应该是这里执行前开始渲染ui，试试用alert阻塞下。\x3c\/span\x3e\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x27 ui 已经渲染完毕了吗？ \x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout1\x27\x3c\/span\x3e);\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise1\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e; i\x2b\x2b) {\n        i == \x3cspan class=\x22hljs-number\x22\x3e99\x3c\/span\x3e \x26amp;\x26amp; resolve();\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise2\x27\x3c\/span\x3e);\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27then1\x27\x3c\/span\x3e);\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x27 ui 开始渲染 \x27\x3c\/span\x3e);\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27global1\x27\x3c\/span\x3e);\n\ndiv.innerHTML = \x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中修改了div的内容，那么在执行那句js代码之后渲染引擎开始修改div的内容呢？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e根据HTML Standard，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行UI render。即：macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UI render。UI render完毕之后接着下一轮循环。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在chrome浏览器中执行以上代码，控制台先输出promise1,promise2,global1,then1(micro-task任务输出)，弹出\x27ui 开始渲染\x27警告框，点击确定之后，页面中的\x27begin\x27变为\x27end\x27，再弹出警告框\x27ui 已经渲染完毕了吗？\x27 ，点击确认之后再输入timeout1.\x3c\/p\x3e\n\x3ch5\x3e再来一个稍微复杂一点的例子\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv class=\x26quot;outer\x26quot; style=\x26quot;width:200px;height:200px;background-color: #ccc\x26quot;\x3e\n    1\n    \x3cdiv class=\x26quot;inner\x26quot; style=\x26quot;width:100px;height:100px;background-color: #ddd\x26quot;\x3ebegin\x3c\/div\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22outer\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22width:200px;height:200px;background-color: #ccc\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    1\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22inner\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22width:100px;height:100px;background-color: #ddd\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3ebegin\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Let\x27s get hold of those elements\nvar outer = document.querySelector(\x27.outer\x27);\nvar inner = document.querySelector(\x27.inner\x27);\n\nvar i = 0;\n\n\/\/ Let\x27s listen for attribute changes on the\n\/\/ outer element\nnew MutationObserver(function() {\n    console.log(\x27mutate\x27);\n}).observe(outer, {\n    attributes: true\n});\n\n\/\/ Here\x27s a click listener…\nfunction onClick() {\n    i\x2b\x2b;\n\n    if(i === 1) {\n        inner.innerHTML = \x27end\x27;\n    }\n\n    console.log(\x27click\x27);\n\n    setTimeout(function() {\n        alert(\x27锚点\x27);\n        console.log(\x27timeout\x27);\n    }, 0);\n\n    Promise.resolve().then(function() {\n        console.log(\x27promise\x27);\n    });\n\n\n    outer.setAttribute(\x27data-random\x27, Math.random());\n}\n\n\/\/ …which we\x27ll attach to both elements\ninner.addEventListener(\x27click\x27, onClick);\nouter.addEventListener(\x27click\x27, onClick);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Let\x27s get hold of those elements\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e outer = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27.outer\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inner = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27.inner\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Let\x27s listen for attribute changes on the\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ outer element\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27mutate\x27\x3c\/span\x3e);\n}).observe(outer, {\n    \x3cspan class=\x22hljs-attr\x22\x3eattributes\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Here\x27s a click listener…\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonClick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    i\x2b\x2b;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(i === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        inner.innerHTML = \x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e);\n\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x27锚点\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise\x27\x3c\/span\x3e);\n    });\n\n\n    outer.setAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x27data-random\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random());\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ …which we\x27ll attach to both elements\x3c\/span\x3e\ninner.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\nouter.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们点击 inner div 时程序依次的执行顺序是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eonclick 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 click\x3c\/li\x3e\n\x3cli\x3e将 timeout 压入到 macrotask\x3c\/li\x3e\n\x3cli\x3e将 promise 压入到 microtask\x3c\/li\x3e\n\x3cli\x3e修改 outer 属性 data-random\x3c\/li\x3e\n\x3cli\x3e将 mutate 压入到 microtask，\x3c\/li\x3e\n\x3cli\x3eonclick 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，由于用户点击事件onclick产生的macrotask执行完毕，JS stack 清空，开始执行microtask.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3epromise 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 promise\x3c\/li\x3e\n\x3cli\x3epromise 出 JS stack\x3c\/li\x3e\n\x3cli\x3emutate 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 mutate\x3c\/li\x3e\n\x3cli\x3emutate 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，microtask 执行完毕，JS stack 清空，但是由于事件冒泡，接着执行outer上的onclick事件.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eonclick 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 click\x3c\/li\x3e\n\x3cli\x3e将 timeout 压入到 macrotask\x3c\/li\x3e\n\x3cli\x3e将 promise 压入到 microtask\x3c\/li\x3e\n\x3cli\x3e修改 outer 属性 data-random\x3c\/li\x3e\n\x3cli\x3e将 mutate 压入到 microtask，\x3c\/li\x3e\n\x3cli\x3eonclick 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，由于outer上的onclick事件产生的macrotask执行完毕，JS stack 清空，开始执行microtask.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3epromise 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 promise\x3c\/li\x3e\n\x3cli\x3epromise 出 JS stack\x3c\/li\x3e\n\x3cli\x3emutate 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 mutate\x3c\/li\x3e\n\x3cli\x3emutate 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，本轮事件循环结束，UI 开始 render.\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e页面中inner的innerHTML变为end\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e此时，UI render 完毕，开始下一轮事件循环.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3etimeout 入 JS stack\x3c\/li\x3e\n\x3cli\x3e弹出警告 锚点.\x3c\/li\x3e\n\x3cli\x3e打印出 timeout\x3c\/li\x3e\n\x3cli\x3etimeout 出 JS stack\x3c\/li\x3e\n\x3cli\x3etimeout 入 JS stack\x3c\/li\x3e\n\x3cli\x3e弹出警告 锚点.\x3c\/li\x3e\n\x3cli\x3e打印出 timeout\x3c\/li\x3e\n\x3cli\x3etimeout 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e到此为止，整个事件执行完毕，\x3cstrong\x3e我们可以看到在弹出警告框之前inner的内容已经改变\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch5\x3e那如果不是用户点击事件触发onclick，而是js触发呢？\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22inner.addEventListener(\x27click\x27, onClick);\nouter.addEventListener(\x27click\x27, onClick);\ninner.click();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3einner.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\nouter.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\ninner.click();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时的执行顺序是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e首先是script(整体代码)入 JS stack\x3c\/li\x3e\n\x3cli\x3eonclick 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 click\x3c\/li\x3e\n\x3cli\x3e将 timeout 压入到 macrotask\x3c\/li\x3e\n\x3cli\x3e将 promise 压入到 microtask\x3c\/li\x3e\n\x3cli\x3e修改 outer 属性 data-random\x3c\/li\x3e\n\x3cli\x3e将 mutate 压入到 microtask，\x3c\/li\x3e\n\x3cli\x3eonclick 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，inner 的 onclick 已经出 JS stack，但是script(整体代码)还没有出 JS stack，还不能执行microtask，由于冒泡，接着执行 outer 的 onclick.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eonclick 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 click\x3c\/li\x3e\n\x3cli\x3e将 timeout 压入到 macrotask\x3c\/li\x3e\n\x3cli\x3e将 promise 压入到 microtask\x3c\/li\x3e\n\x3cli\x3e修改 outer 属性 data-random\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e接着执行的outer.setAttribute(\x27data-random\x27, Math.random());，但是由于上一个mutation microtask还处于等待状态，不能再添加mutation microtask，所以这里不会将 mutate 压入到 microtask。接着执行：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eonclick 出 JS stack\x3c\/li\x3e\n\x3cli\x3escript(整体代码)出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，inner.click()执行完毕，script(整体代码)已出 JS stack，JS stack 清空，开始执行mircotask.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3epromise 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 promise\x3c\/li\x3e\n\x3cli\x3epromise 出 JS stack\x3c\/li\x3e\n\x3cli\x3emutate 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 mutate\x3c\/li\x3e\n\x3cli\x3emutate 出 JS stack\x3c\/li\x3e\n\x3cli\x3epromise 入 JS stack\x3c\/li\x3e\n\x3cli\x3e打印出 promise\x3c\/li\x3e\n\x3cli\x3epromise 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e此时，所有的mircotask执行完毕，本轮事件循环结束，UI 开始 render.\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e页面中inner的innerHTML变为end\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e此时，UI render 完毕，开始下一轮事件循环.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3etimeout 入 JS stack\x3c\/li\x3e\n\x3cli\x3e弹出警告 锚点.\x3c\/li\x3e\n\x3cli\x3e打印出 timeout\x3c\/li\x3e\n\x3cli\x3etimeout 出 JS stack\x3c\/li\x3e\n\x3cli\x3etimeout 入 JS stack\x3c\/li\x3e\n\x3cli\x3e弹出警告 锚点.\x3c\/li\x3e\n\x3cli\x3e打印出 timeout\x3c\/li\x3e\n\x3cli\x3etimeout 出 JS stack\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e到此为止，整个事件执行完毕，\x3cstrong\x3e我们可以看到在弹出警告框之前inner的内容已经改变\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结：首先执行macrotask，当js stack为空时执行microtask，接着开始UI render，接着再开始下一轮循环\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e参考文献：\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000012646373\x22\x3e深入核心，详解事件循环机制\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTasks, microtasks, queues and schedules\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Javascript事件循环机制以及渲染引擎何时渲染UI</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013212944">https://segmentfault.com/a/1190000013212944</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/evffgu05xwo/" target="_blank">https://alili.tech/archive/evffgu05xwo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>