<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="白洁血战Node.js并发编程 01 状态机"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>白洁血战Node.js并发编程 01 状态机 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/f9s6dvrscro/",
				"appid": "1613049289050283", 
				"title": "白洁血战Node.js并发编程 01 状态机 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wopfkkbujh/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/kvm1l1mbytb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&text=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&text=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&title=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&is_video=false&description=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&title=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&title=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&title=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff9s6dvrscro%2f&title=%e7%99%bd%e6%b4%81%e8%a1%80%e6%88%98Node.js%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2001%20%e7%8a%b6%e6%80%81%e6%9c%ba"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">白洁血战Node.js并发编程 01 状态机</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e这一篇是这个系列的开篇，没有任何高级内容，就讲讲状态机。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e状态机\x3c\/h1\x3e\n\x3cp\x3e状态机是模型层面的概念，与编程语言无关。它的目的是为对象行为建模，属于设计范畴。它的基础概念是状态（state）和事件（event）。\x3c\/p\x3e\n\x3cp\x3e对象的内部结构描述为一组状态S1, S2, ... Sn，它的行为的trigger，包括内部的和外部的，描述成为一组事件E1, E2, ... En，在任何状态下，任何事件到来，对象状态的改变用Sx -\x26gt; Sy的状态迁移（State Transition）来描述，这个状态迁移就是对象的行为（behavior）。\x3c\/p\x3e\n\x3cp\x3e对对象行为的完备定义就是{ S } x { E }的矩阵，如果存在(Sx, Ey)的组合未定义行为，这个对象行为模型在设计层面上就不完备，当然实际的代码不可能没有行为，这往往就是错误发生的地方。\x3c\/p\x3e\n\x3cp\x3e状态机具有良好的可实现性和可测试性。完备定义的状态机很容易写出对应的代码，也很容易遍历全部的状态迁移过程完成测试，当然这只意味着代码实现和设计（模型）相符，并不意味着设计是正确的。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e设计的正确性是一个复杂的多的话题，严格的定义是设计符合Specification。什么是符合Specification？要去看Robin Milner, Tony Hoare, Leslie Lamport等人的书了，老实说我也不懂，所以就此打住。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这篇文章不会详细介绍状态机，网上有非常多的资料，四人帮的书上有State Pattern - OO语言下的状态机实现，UML有State Diagram，是非常好的图示工具；这里只给出一个代码例子，对照这个实例帮助理解状态机模型的代码实现。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e一个例子\x3c\/h1\x3e\n\x3cp\x3e假定我们要解决这样一个任务：我们有一个模块是为了存储（save）一个文件，写状态机的目的是为了解决并发操作时排队存储的请求，因为请求是并发的，如果写入文件的io操作也是并发的话，这个文件可能被损坏。这是一个非常常见的应用场景。\x3c\/p\x3e\n\x3cp\x3e这个模块定义有三种状态：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eIdle\x3c\/code\x3e， 这是不工作的状态；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ePending\x3c\/code\x3e，这是等待工作的状态，等待的目的是为了，如果在很短的时间内出现连续多次的写入请求，我们只写入最后一个，减少io操作的次数；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eWorking\x3c\/code\x3e，该状态下在执行写入操作，如果在执行io操作的时候收到写入请求，我们把请求内容保存在一个临时的位置；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3eIdle\x3c\/code\x3e状态没有任何特殊资源，只有一个save请求事件；当有save请求时，它迁移到\x3ccode\x3ePending\x3c\/code\x3e状态。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ePending\x3c\/code\x3e状态具有的特殊资源是一个timer，它可能有两个事件：来自外部的save请求，和来自内部的timeout。在JavaScript代码里，这是一个callback，但是我们在状态机模型中要把他理解为事件。在\x3ccode\x3ePending\x3c\/code\x3e状态中如果有save请求，不发生状态迁移，新的请求数据会覆盖旧的版本，原来的timer会被清除，重新开始新的timer。在timeout发生时，迁移到\x3ccode\x3eWorking\x3c\/code\x3e状态。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eWorking\x3c\/code\x3e状态在进入时会启动存储文件的操作，它可能有两个事件：来自外部的save请求，和来自内部的保存文件操作的异步返回，同样的，它也被理解为一个（内部）事件。当外部的save请求到来时，该请求被保存在内部的\x3ccode\x3enext\x3c\/code\x3e变量里；当文件操作返回时：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e如果操作成功\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果存在\x3ccode\x3enext\x3c\/code\x3e，向\x3ccode\x3ePending\x3c\/code\x3e状态迁移\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果不存在\x3ccode\x3enext\x3c\/code\x3e，向\x3ccode\x3eIdle\x3c\/code\x3e状态迁移\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果操作失败\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果存在\x3ccode\x3enext\x3c\/code\x3e，向\x3ccode\x3ePending\x3c\/code\x3e状态迁移，用\x3ccode\x3enext\x3c\/code\x3e作为数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果不存在\x3ccode\x3enext\x3c\/code\x3e，也向\x3ccode\x3ePending\x3c\/code\x3e状态迁移，仍然使用当前数据，相当于等待后retry\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我偷个懒，没给出图示，实际上这样的语言描述不如State Diagram来得直观。下面的表格是上述语言描述的归纳，史称状态迁移表（State Transition Table），有了State Diagram或者State Transition Table，任何人写出来的代码都一样。为了表述清晰，表中把\x3ccode\x3eWorking\x3c\/code\x3e状态的文件操作返回分成了两个事件：success和error。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eStateEvent\x3c\/th\x3e\n\x3cth\x3eSave\x3c\/th\x3e\n\x3cth\x3eTimeout\x3c\/th\x3e\n\x3cth\x3eSuccess\x3c\/th\x3e\n\x3cth\x3eError\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eIdle\x3c\/td\x3e\n\x3ctd\x3e-\x26gt; Pending\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ePending\x3c\/td\x3e\n\x3ctd\x3eoverwrite data, restart timer\x3c\/td\x3e\n\x3ctd\x3e-\x26gt; Working\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eWorking\x3c\/td\x3e\n\x3ctd\x3eset next\x3c\/td\x3e\n\x3ctd\x3en\/a\x3c\/td\x3e\n\x3ctd\x3eif next, -\x26gt; Pending; else -\x26gt; Idle\x3c\/td\x3e\n\x3ctd\x3e-\x26gt; Pending(next ? next : data)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e代码\x3c\/h1\x3e\n\x3cp\x3e下面是代码，首先有个base class，三个状态都继承自这个base class：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class State {\n\n  constructor(ctx) {\n    this.ctx = ctx\n  }\n\n  setState(nextState, ...args) {\n    this.exit()\n    this.ctx.state = new nextState(this.ctx, ...args)\n  }\n\n  exit() {}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eState\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(ctx) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx = ctx\n  }\n\n  setState(nextState, ...args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.exit()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e nextState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx, ...args)\n  }\n\n  exit() {}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在状态机的代码实现上，标志性的方法名称是\x3ccode\x3esetState\x3c\/code\x3e，它负责状态迁移；其次是\x3ccode\x3eenter\x3c\/code\x3e和\x3ccode\x3eexit\x3c\/code\x3e，分别对应进入该状态和离开该状态。\x3c\/p\x3e\n\x3cp\x3e状态机模式（State Pattern）的一个显著的编程收益是：每个状态都有自己的资源，在迁入该状态的时候建立资源，在离开该状态的时候释放资源，这很容易保证资源的正确使用。\x3c\/p\x3e\n\x3cp\x3e在上述代码中，\x3ccode\x3econstructor\x3c\/code\x3e充当了\x3ccode\x3eenter\x3c\/code\x3e逻辑的角色，所以没有提供独立的\x3ccode\x3eenter\x3c\/code\x3e方法；JavaScript Class是一个语法糖，没有和constructor相对应的destructor，所以我们这里写一个\x3ccode\x3eexit\x3c\/code\x3e函数，如果继承类里没有\x3ccode\x3eexit\x3c\/code\x3e逻辑，这个基类上的方法就是一个fallback。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ectx\x3c\/code\x3e是一个外部容器，相当于所有状态对象的上下文（context），它同时具有一个叫做\x3ccode\x3estate\x3c\/code\x3e的成员，该成员是一个\x3ccode\x3eIdle\x3c\/code\x3e，\x3ccode\x3ePending\x3c\/code\x3e，或者\x3ccode\x3eWorking\x3c\/code\x3e类的实例；无论\x3ccode\x3ectx.state\x3c\/code\x3e是哪个状态，\x3ccode\x3ectx\x3c\/code\x3e都把\x3ccode\x3esave\x3c\/code\x3e方法forward到\x3ccode\x3estate\x3c\/code\x3e上，这样写是一个很标准的State Pattern。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetState\x3c\/code\x3e的实现有点tricky，是JavaScript的特色。它首先调用当前类的\x3ccode\x3eexit\x3c\/code\x3e函数迁出状态，然后使用new来构造下一个类，这意味着第一个参数\x3ccode\x3enextState\x3c\/code\x3e是一个构造函数；后面的参数使用了spread operator，把这些参数传入了构造函数，同时把新对象安装到了\x3ccode\x3ectx\x3c\/code\x3e，即把自己替换了；这不是唯一的做法，是比较简洁的一种写法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eIdle\x3c\/code\x3e类的实现非常简单，在save的时候用data作为参数构造了\x3ccode\x3ePending\x3c\/code\x3e对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Idle extends State{\n\n  save(data) {\n    this.setState(Pending, data)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eIdle\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eState\x3c\/span\x3e\x3c\/span\x3e{\n\n  save(data) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Pending, data)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ePending\x3c\/code\x3e类的\x3ccode\x3esave\x3c\/code\x3e方法里保存了\x3ccode\x3edata\x3c\/code\x3e和启动timer。它的构造函数重用了\x3ccode\x3esave\x3c\/code\x3e方法。因为JavaScript的clearTimeout方法是安全的，这样写没什么问题。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eexit\x3c\/code\x3e函数实际上没有必要，但这样书写是推荐的，它确保资源清理，如果未来设计变更出现其他的状态迁出逻辑，这个代码就有用了。\x3c\/p\x3e\n\x3cp\x3etimeout时\x3ccode\x3ePending\x3c\/code\x3e向\x3ccode\x3eWorking\x3c\/code\x3e状态迁移。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nclass Pending extends State {\n\n  constructor(ctx, data) {\n    super(ctx)\n    this.save(data)\n  }\n\n  save(data) {\n    clearTimeout(this.timer)\n    this.data = data \n    this.timer = setTimeout(() =\x3e {\n      this.setState(Working, this.data) \n    }, this.ctx.delay)\n  }\n\n  exit() {\n    clearTimeout(this.timer)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePending\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eState\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(ctx, data) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(ctx)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.save(data)\n  }\n\n  save(data) {\n    clearTimeout(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.timer)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.timer = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Working, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data) \n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx.delay)\n  }\n\n  exit() {\n    clearTimeout(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.timer)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eWorking\x3c\/code\x3e代码稍微多点，但是对照状态迁移表很容易读懂。不赘述每个方法了。保存文件的操作采用了先写入临时文件然后重命名的做法，这是保证文件完整性的常规做法，系统即使断电也不会损坏磁盘文件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Working extends State {\n\n  constructor(ctx, data) { \n    super(ctx)\n    this.data = data \n\n    \/\/ console.log(\x27start saving data\x27, data)\n    let tmpfile = path.join(this.ctx.tmpdir, UUID.v4())\n    fs.writeFile(tmpfile, JSON.stringify(this.data), err =\x3e {\n\n      if (err) return this.error(err)\n      fs.rename(tmpfile, this.ctx.target, err =\x3e {\n\n        \/\/ console.log(\x27finished saving data\x27, data, err)\n        if (err) return this.error(err)\n        this.success()\n      }) \n    })\n  } \n\n  error(e) {\n    \/\/ console.log(\x27error writing persistent file\x27, e)\n    if (this.next)    \n      this.setState(Pending, this.next)\n    else\n      this.setState(Pending, this.data)\n  }\n\n  success() {\n    if (this.next)\n      this.setState(Pending, this.next)\n    else \n      this.setState(Idle)\n  }\n\n  save(data) {\n    \/\/ console.log(\x27Working save\x27, data)\n    this.next = data\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWorking\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eState\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(ctx, data) { \n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(ctx)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data \n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27start saving data\x27, data)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e tmpfile = path.join(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx.tmpdir, UUID.v4())\n    fs.writeFile(tmpfile, \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data), err =\x26gt; {\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.error(err)\n      fs.rename(tmpfile, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ctx.target, err =\x26gt; {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27finished saving data\x27, data, err)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.error(err)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.success()\n      }) \n    })\n  } \n\n  error(e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27error writing persistent file\x27, e)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next)    \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Pending, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next)\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Pending, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data)\n  }\n\n  success() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Pending, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next)\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(Idle)\n  }\n\n  save(data) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27Working save\x27, data)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next = data\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后是\x3ccode\x3ectx\x3c\/code\x3e，我们在实际项目中称之为\x3ccode\x3ePersistence\x3c\/code\x3e。它初始化时设置state为\x3ccode\x3eIdle\x3c\/code\x3e状态；把所有的save操作都forward到内部对象\x3ccode\x3estate\x3c\/code\x3e上。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Persistence {\n\n  constructor(target, tmpdir, delay) {\n    this.target = target \n    this.tmpdir = tmpdir\n    this.delay = delay || 500\n    this.state = new Idle(this) \n  }\n\n  save(data) {\n    this.state.save(data)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePersistence\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(target, tmpdir, delay) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.target = target \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tmpdir = tmpdir\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.delay = delay || \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Idle(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) \n  }\n\n  save(data) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.save(data)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e要点\x3c\/h1\x3e\n\x3cp\x3e这一篇粗略的讲了两个问题：状态机模型和状态机模式（State Pattern）。他们两个不是一回事。\x3c\/p\x3e\n\x3cp\x3e状态机模式是一种写法，上述写法不唯一；不使用Class，仅仅在\x3ccode\x3ePersistence\x3c\/code\x3e类中使用（枚举）变量表示状态也是可以的，使用Class则相当于用变量类型来代表状态。\x3c\/p\x3e\n\x3cp\x3e状态机模式的显著优点在于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e不同状态的资源和行为逻辑分开\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在\x3ccode\x3esetState\x3c\/code\x3e, \x3ccode\x3eenter\x3c\/code\x3e, \x3ccode\x3eexit\x3c\/code\x3e等标志性方法中不需要使用if \/ then或switch语句\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在对象行为定义发生变化时，修改容易，不易犯错误；感谢enter和exit的封装，它强制了资源回收逻辑\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e状态机模型的意义对后面的内容更为重要。上面的例子具有这样几个特征：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e状态具有显式定义\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e事件内外有别\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e外部事件对所有状态成立，因此\x3ccode\x3ePersistence\x3c\/code\x3e类的使用非常简单，从外部其实看不到内部有什么状态定义，黑盒意义上说，\x3ccode\x3ePersistence\x3c\/code\x3e是无态的，这对使用便利性来说极为重要；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e内部事件仅仅对某些状态成立，所有异步函数的返回都理解为事件，而且是唯一的内部事件；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e从并发角度说，\x3ccode\x3ePersistence\x3c\/code\x3e类是一个同步器（Synchronizer），即并发的save操作在这里被排序执行了；当然我们没有设计更复杂的逻辑，例如任务队列，但显然那不是很难；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e问题\x3c\/h1\x3e\n\x3cp\x3e纯粹的状态机（automata）对于并发编程是无力的，这是一种共识，因为并发带来的状态组合会迅速爆炸状态空间，我们要找到办法对付这个问题，此其一。\x3c\/p\x3e\n\x3cp\x3e其二，实际的程序模块组合时常见包含关系，用经典的状态机模型会产生组合状态机（Hierarchical State Machine），它的代码书写远比上述例子的Flat State Machine难写，除非在语言一级或者有类库支持，否则可读性和可维护性都很差，设计变更时代码改动幅度非常大，不是解决常见问题的好办法，虽然在一些特殊应用领域卓有建树，例如嵌入式设备的通讯协议栈。\x3c\/p\x3e\n\x3cp\x3e事件(Event)和线程(Thread)是形式上对立，但是数学上对等，的两个编程方式。两者各有利弊，战争也是古老的，你在网络上很容易搜索到Why Event (Model) is Evil或者Why Thread (Model) is Evil的学术文章，都有大量的支持者。\x3c\/p\x3e\n\x3cp\x3eNode.js的与众不同之处在于它的强制non-blocking i\/o设计。这给习惯Thread编程的开发者制造了麻烦，所以在过去的几年里新的过程原语被发明出来解决这个问题，包括promise，generator，async\/await。bluebird的使用者越来越多，而caolan的曾经很流行的async库用户越来越少。\x3c\/p\x3e\n\x3cp\x3e但是众所周知JavaScript语言是事件模型的。在基础特性上寻求类thread编程形式去解决一切问题本身就是表里不一的，而且promise和async\/await的实现本身也有很多不尽人意的地方。\x3c\/p\x3e\n\x3cp\x3e这让我们倒回来思考两个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e寻求各种CPS（Continuation Passing Style）是解决non-blocking i\/o的必经之路吗？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e事件和状态机模型真的没有办法写规模化的并发程序吗？\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3cp\x3eNode原作者Ryan Dahl最近在一次访谈里说了他对Node的看法。他说在最初的两三年中他是狂热的支持Node的强制non-blocking i\/o设计的，达到那种认为“原来我们都做错了”的程度，但是慢慢的他的态度发生了转变，尤其是在接触了Go语言之后；现在他的看法是，最初他以为Node可以做到是end-all或者for-all的，但是现在他没那么有信心了，在并发编程上他认为Go可能是更好的设计。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我的个人观点，谈Node必谈callback hell的开发者，并不熟悉在Event Model下的并发编程技术，promise和async\/await本质上，绝大多数情况下是在serialize过程，如果只是serialize，那么结果和blocking i\/o的编程并不会有区别。Promise对parallel的支持很有限，它只是在serial的过程序列上偶尔撒一点parallel的flavor。而且如果你喜欢的就是Thread Model，那么就应该选择对它有良好支持的编程语言或环境，例如Go或者fibjs。\x3c\/p\x3e\n\x3cp\x3e如果你像我一样，喜欢JavaScript语言的简单，喜欢Event Model的简单，而不只是因为Node有良好的生态圈和海量的npm包可用而选择了Node——如果你只是因为这两点选择了Node，你肯定会后悔的——那么摆在我们面前的问题就是：事件模型，显式状态，non-blocking i\/o，我们能不能找到一种办法，一种\x3cstrong\x3eend-all\x3c\/strong\x3e和\x3cstrong\x3efor-all\x3c\/strong\x3e的办法，最好能够直接体现在代码形式上，或者至少体现在一个简单、直觉、不易错、同时保持经典状态机模型的完备性的Mental Model上，能够为复杂的并发编程问题建模和书写代码？\x3c\/p\x3e\n\x3cp\x3e在这里经典状态机模式可以给我们一个简单启迪：我们不仅可以用\x3cstrong\x3e值\x3c\/strong\x3e来表示状态，我们也可以用\x3cstrong\x3e对象类型\x3c\/strong\x3e表示状态，而且有明显的收益。同样的，在事件模型下解决并发问题的关键，就是把这个设计继续向前推进一步，我们还可以用\x3cstrong\x3e结构\x3c\/strong\x3e来表示状态。具体怎么写和怎么思考建模，则是这个系列文章的主旨。\x3c\/p\x3e\n\x3cp\x3e这在数学层面上非常容易理解：所谓并发编程，它\x3cstrong\x3e就是在structure过程\x3c\/strong\x3e（Rob Pike）。函数或者类函数，包括promise，async function，generator，coroutine，他们是Thread Model下的（黑盒）原语和原语组合，对应的，我们要找到事件模型下的显式状态方法来应对这个问题，如果能做到这一点，我们就可以回到纯粹的事件模型下编写程序。\x3c\/p\x3e\n\x3cp\x3e这个结果并不难，但是，它也确实有一段路要走，我们需要仔细梳理过程原语的优点缺点，梳理并发编程的本质，梳理常见问题的各种编程方式，最后回到我们的事件模型和状态机上来。等这个系列写完，你也读完，我向你保证，你再次看到callback函数时会觉得原来它那么简单且美。\x3c\/p\x3e\n\x3cp\x3e下一篇我们开始谈并发编程，敬请期待。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>白洁血战Node.js并发编程 01 状态机</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011086405">https://segmentfault.com/a/1190000011086405</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/f9s6dvrscro/" target="_blank">https://alili.tech/archive/f9s6dvrscro/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>