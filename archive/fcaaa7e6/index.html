<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="初学者应该了解的数据结构： Tree"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>初学者应该了解的数据结构： Tree | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fcaaa7e6/",
				"appid": "1613049289050283", 
				"title": "初学者应该了解的数据结构： Tree | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6bceb83f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cf024897/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&text=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&is_video=false&description=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffcaaa7e6%2f&title=%e5%88%9d%e5%ad%a6%e8%80%85%e5%ba%94%e8%af%a5%e4%ba%86%e8%a7%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%20Tree"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">初学者应该了解的数据结构： Tree</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e\x3cimg src=\x22https:\/\/adrianmejia.com\/images\/data-structures-for-beginners-trees-binary-search-tree-large.jpg\x22 alt=\x22Tree Data Structures for Beginners\x22\x3e\x3c\/p\x3e\n\x3cp\x3e很多（上层）数据结构，如 Map、Set 等，它们的基础数据结构都（可以）是 Tree。同时，在数据库中快速搜索（元素）用到了树。HTML 的 DOM 节点也通过树来表示对应的层次结构。以上仅仅是树的一少部分例子。在这篇文章中，我们将探讨不同类型的树，如二叉树、二叉搜索树以及如何实现它们。\x3c\/p\x3e\n\x3cp\x3e在\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/05\/14\/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial\/\x22\x3e上一篇文章\x3c\/a\x3e中，我们探讨了数据结构：图，它是树一般化的情况。让我们开始学习树吧！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e本篇是以下教程的一部分（译者注：如果大家觉得还不错，我会翻译整个系列的文章）:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e初学者应该了解的数据结构与算法（DSA）\x3c\/strong\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/04\/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial\/\x22\x3e算法的时间复杂性与大 O 符号\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/05\/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course\/\x22\x3e每个程序员应该知道的八种时间复杂度\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/28\/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial\/\x22\x3e初学者应该了解的数据结构：Array、HashMap 与 List\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/05\/14\/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial\/\x22\x3e初学者应该了解的数据结构： Graph\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e初学者应该了解的数据结构：Tree \x3cstrong\x3e👈 即本文\x3c\/strong\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/07\/16\/self-balanced-binary-search-trees-with-avl-tree-data-structure-for-beginners\/\x22\x3e自平衡二叉搜索树\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/24\/Analysis-of-Recursive-Algorithms\/\x22\x3e附录 I：递归算法分析\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3chr\x3e\n\x3ch1\x3e树的基本概念\x3c\/h1\x3e\n\x3cp\x3e在树中，每个节点可有零个或多个子节点，每个节点都包含一个\x3cstrong\x3e值\x3c\/strong\x3e。和图一样，节点之间的连接被称为\x3cstrong\x3e边\x3c\/strong\x3e。树是图的一种，但并不是所有图都是树（只有无环无向图才是树）。\x3c\/p\x3e\n\x3cp\x3e这种数据类型之所以被称为树，是因为它长得很像一棵（倒置的）树 🌳。它从\x3cstrong\x3e根\x3c\/strong\x3e节点出发，它的子节点是它的\x3cstrong\x3e分支\x3c\/strong\x3e，没有任何子节点的节点就是树的\x3cstrong\x3e叶子\x3c\/strong\x3e（即叶节点）。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t015cb24ea4f5b908a4.jpg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e以下是树的一些属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e最顶层的节点被称为\x3cstrong\x3e根\x3c\/strong\x3e（root）节点（译者注：即没有任何父节点的节点）。\x3c\/li\x3e\n\x3cli\x3e没有任何子节点的节点被称为\x3cstrong\x3e叶\x3c\/strong\x3e节点（leaf node）或者\x3cstrong\x3e终端\x3c\/strong\x3e节点（terminal node）。\x3c\/li\x3e\n\x3cli\x3e树的\x3cstrong\x3e度\x3c\/strong\x3e（Height）是最深的叶节点与根节点之间的距离（即边的数量）。\x3cul\x3e\n\x3cli\x3e\x3ccode\x3eA\x3c\/code\x3e 的度是 3。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eI\x3c\/code\x3e 的度是 0（译者注：子树也是树，I 的度是指 I 为根节点的子树的度）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e深度\x3c\/strong\x3e（Depth）或者\x3cstrong\x3e层次\x3c\/strong\x3e（level）是节点与根节点的距离。\x3cul\x3e\n\x3cli\x3e\x3ccode\x3eH\x3c\/code\x3e 的层次是 2。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eB\x3c\/code\x3e 的层次是 1。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3e树的简单实现\x3c\/h2\x3e\n\x3cp\x3e正如此前所见，树的节点有一个值，且存有它每一个子节点的引用。\x3c\/p\x3e\n\x3cp\x3e以下是节点的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTreeNode\x3c\/span\x3e {\n  constructor(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents = [];\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们可以创建一棵树，它有三个叶节点：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ create nodes with values\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e abe = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TreeNode(\x3cspan class=\x22hljs-string\x22\x3e\x27Abe\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e homer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TreeNode(\x3cspan class=\x22hljs-string\x22\x3e\x27Homer\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bart = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TreeNode(\x3cspan class=\x22hljs-string\x22\x3e\x27Bart\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lisa = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TreeNode(\x3cspan class=\x22hljs-string\x22\x3e\x27Lisa\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e maggie = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TreeNode(\x3cspan class=\x22hljs-string\x22\x3e\x27Maggie\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ associate root with is descendents\x3c\/span\x3e\nabe.descendents.push(homer);\nhomer.descendents.push(bart, lisa, maggie);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这样就完成啦，我们有了一棵树！\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01516921afe77ca73b.jpg\x22 alt=\x22\x22 title=\x22Simpson tree data structure\x22\x3e\x3c\/p\x3e\n\x3cp\x3e节点 \x3ccode\x3eabe\x3c\/code\x3e 是\x3cstrong\x3e根\x3c\/strong\x3e节点，而节点 \x3ccode\x3ebart\x3c\/code\x3e、\x3ccode\x3elisa\x3c\/code\x3e 和 \x3ccode\x3emaggie\x3c\/code\x3e 则是这棵树的 \x3cstrong\x3e叶\x3c\/strong\x3e节点。注意，树的节点的子节点可以是任意数量的，无论是 0 个、1 个、3 个或是多个均可。\x3c\/p\x3e\n\x3ch1\x3e二叉树\x3c\/h1\x3e\n\x3cp\x3e树的节点可以有 0 个或多个子节点。然而，当一棵树（的所有节点）最多只能有两个子节点时，这样的树被称为\x3cstrong\x3e二叉树\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e二叉树是树中最常见的形式之一，它应用广泛，如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/28\/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial\/#HashMaps\x22\x3eMaps\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/adrianmejia.com\/blog\/2018\/04\/28\/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial\/#Sets\x22\x3eSets\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e数据库\x3c\/li\x3e\n\x3cli\x3e优先队列\x3c\/li\x3e\n\x3cli\x3e在 LDAP（Lightweight Directory Access Protocol）中查找相应信息。\x3c\/li\x3e\n\x3cli\x3e在 XML\/HTML 文件中，使用文档对象模型（DOM）接口进行搜索。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3e完满二叉树、完全二叉树、完美二叉树\x3c\/h2\x3e\n\x3cp\x3e取决于二叉树节点的组织方式，一棵二叉树可以是\x3cstrong\x3e完满二叉树\x3c\/strong\x3e、\x3cstrong\x3e完全二叉树\x3c\/strong\x3e或\x3cstrong\x3e完美二叉树\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e完满二叉树\x3c\/strong\x3e（Full binary tree）：除去叶节点，每个节点都有两个子节点。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e完全二叉树\x3c\/strong\x3e（Complete binary tree）：除了最深一层之外，其余所有层的节点都必须有两个子节点（译者注：其实还需要最深一层的节点均集中在左边，即左对齐）。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e完美二叉树\x3c\/strong\x3e（Perfect binary tree）：满足完全二叉树性质，树的叶子节点均在最后一层（也就是形成了一个完美的三角形）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e（译者注：国内外的定义是不同的，此处根据原文与查找的资料，作了一定的修改，用的是国外的标准）\x3c\/p\x3e\n\x3cp\x3e下图是上述概念的例子：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01b0d1575bd8040171.jpg\x22 alt=\x22\x22 title=\x22Full vs. Complete vs. Perfect Binary Tree\x22\x3e\x3c\/p\x3e\n\x3cp\x3e完满二叉树、完全二叉树与完美二叉树并不总是互斥的：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e完美二叉树\x3cstrong\x3e必然\x3c\/strong\x3e是完满二叉树和完全二叉树。\x3cul\x3e\n\x3cli\x3e完美的二叉树正好有 2 的 k 次方 减 1 个节点，其中 k 是树的最深一层（从1开始）。.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e完全二叉树并不总是完满二叉树。\x3cul\x3e\n\x3cli\x3e正如上面的完全二叉树例子，最右侧的灰色节点是它父子点仅有的一个子节点。如果移除掉它，这棵树就既是完全二叉树，也是完满二叉树。（译者注：其实有了那个灰色节点的话，这颗树不能算是完全二叉树的，因为完满二叉树需要左对齐）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e完满二叉树并不一定是完全二叉树与完美二叉树。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1\x3e二叉搜索树 (BST)\x3c\/h1\x3e\n\x3cp\x3e二叉搜索树（Binary Search Tree，简写为：BST）是二叉树的特定应用。BST 的每个节点如二叉树一样，最多只能有两个子节点。然而，BST 左子节点的值必须小于父节点的值，而右子节点的值则必须大于父节点的值。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e强调一下\x3c\/strong\x3e：一些 BST 并不允许重复值的节点被添加到树中，如若允许，那么重复值的节点将作为右子节点。有些二叉搜索树的实现，会记录起重复的情况（这也是接下来我们需要实现的）。 \x3c\/p\x3e\n\x3cp\x3e一起来实现二叉搜索树吧！\x3c\/p\x3e\n\x3ch2\x3eBST 的实现\x3c\/h2\x3e\n\x3cp\x3eBST 的实现与上文树的实现相像，然而有两点不同：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e节点最多只能拥有两个子节点。\x3c\/li\x3e\n\x3cli\x3e节点的值满足以下关系：\x3ccode\x3e左子节点 \x26lt; 父节点 \x26lt; 右子节点\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以下是树节点的实现，与之前树的实现类似，但会为左右子节点添加 \x3ccode\x3egetter\x3c\/code\x3e 与 \x3ccode\x3esetter\x3c\/code\x3e。请注意，实例中会保存父节点的引用，当添加新的子节点时，将更新（子节点中）父节点的引用。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3econst LEFT = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\nconst RIGHT = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTreeNode\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/译者注：原文并没有以下两个属性，但不加上去话下文的实现会报错\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newNode.isParentLeftChild = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.meta = {};  \n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e left() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents[LEFT];\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e left(node) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents[LEFT] = node;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node) {\n      node.parent = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e right() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents[RIGHT];\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e right(node) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.descendents[RIGHT] = node;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node) {\n      node.parent = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eOK，现在已经可以添加左右子节点。接下来将编写 BST 类，使其满足 \x3ccode\x3e左子节点 \x26lt; 父节点 \x26lt; 右子节点\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cs\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBinarySearchTree\x3c\/span\x3e {\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\n  find(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\n  \x3cspan class=\x22hljs-keyword\x22\x3eremove\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\n  getMax() { \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\n  getMin() { \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e下面先编写插入新节点相关的的代码。\x3c\/p\x3e\n\x3ch2\x3eBST 节点的插入\x3c\/h2\x3e\n\x3cp\x3e要将一个新的节点插入到二叉搜索树中，我们需要以下三步：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果树中没有任何节点，第一个节点当成为\x3cstrong\x3e根节点\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e（将新插入节点的值）与树中的根节点或树节点进行对比，如果值 _更大_，则放至右子树（进行下一次对比），反之放到左子树（进行对比） 。如果值一样，则说明被重复添加，可增加重复节点的计数。\x3c\/li\x3e\n\x3cli\x3e重复第二点操作，直至找到空位插入新节点。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让我们通过以下例子来说明，树中将依次插入30、40、10、15、12、50：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011df4b16eceab43de.gif\x22 alt=\x22\x22 title=\x22Inserting nodes on a Binary Search Tree (BST)\x22\x3e\x3c\/p\x3e\n\x3cp\x3e代码实现如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3eadd(value) {\n  const \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eTreeNode\x3c\/span\x3e(value);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.root) {\n    const { found, parent } = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.findNodeAndParent(value);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (found) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ duplicated: value already exist on the tree\x3c\/span\x3e\n      found.meta.multiplicity = (found.meta.multiplicity || \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value \x26lt; parent.value) {\n      parent.left = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/译者注：原文并没有这行代码，但不加上去的话下文实现会报错\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e.isParentLeftChild = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      parent.right = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.root = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.size \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eNode\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们使用了名为 \x3ccode\x3efindNodeAndParent\x3c\/code\x3e  的辅助函数。如果（与新插入节点值相同的）节点已存在于树中，则将节点统计重复的计数器加一。看看这个辅助函数该如何实现：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3efindNodeAndParent(value) {\n  let \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= this\x3c\/span\x3e.root;\n  let parent;\n  while (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n    if\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3evalue\x3c\/span\x3e === value) {\n      break;\n    }\n    parent = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    node\x3c\/span\x3e = ( value \x26gt;= \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3evalue\x3c\/span\x3e) ? \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e;\n  }\n  return { found: \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, parent\x3c\/span\x3e };\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3efindNodeAndParent\x3c\/code\x3e 沿着树的结构搜索值。它从根节点出发，往左还是往右搜索取决于节点的值。如果已存在相同值的节点，函数返回找到的节点（即相同值的节点）与它的父节点。如果没有相同值的节点，则返回最后找到的节点（即将变为新插入节点父节点的节点）。\x3c\/p\x3e\n\x3ch2\x3eBST 节点的删除\x3c\/h2\x3e\n\x3cp\x3e我们已经知道如何（在二叉搜索树中）插入与查找值，现在将实现删除操作。这比插入而言稍微麻烦一点，让我们用下面的例子进行说明：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e删除叶节点（即没有任何子节点的节点）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e    \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e                             \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n \/     \\         remove(\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e)     \/     \\\n\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e       ---------\x26gt;    \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e\n  \\    \/  \\                      \\    \/  \\\n  \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e  \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e                    \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e  \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n  \/\n\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e*\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e只需要删除父节点（即节点 #15）中保存着的 节点 #12 的引用即可。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e删除有一个子节点的节点\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e    \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e                              \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n \/     \\         remove(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e)      \/     \\\n\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e*     \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e       ---------\x26gt;     \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e\n  \\    \/  \\                            \/  \\\n  \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e  \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e                         \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这种情况中，我们将父节点 #30 中保存着的子节点 #10 的引用，替换为子节点的子节点 #15 的引用。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e删除有两个子节点的节点\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e   \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e                              \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n \/     \\         remove(\x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e)      \/     \\\n\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e*      ---------\x26gt;     \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n       \/  \\                            \/\n      \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e                         \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e待删除的节点 #40 有两个子节点（#35 与 #50）。我们将待删除节点替换为节点 #50。待删除的左子节点 #35 将在原位不动，但它的父节点已被替换。\x3c\/p\x3e\n\x3cp\x3e另一个删除节点 #40 的方式是：将左子节点 #35 移到节点 #40 的位置，右子节点位置保持不变。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e    \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n \/     \\\n\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e\n          \\\n           \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e两种形式都可以，这是因为它们都遵循了二叉搜索树的原则：\x3ccode\x3e左子节点 \x26lt; 父节点 \x26lt; 右子节点\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e删除根节点\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e   \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e*                            \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n \/     \\       remove(\x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e)      \/     \\\n\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e     ---------\x26gt;     \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e\n       \/\n      \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e删除根节点与此前讨论的机制情况差不多。唯一的区别是需要更新二叉搜索树实例中根节点的引用。\x3c\/p\x3e\n\x3cp\x3e以下的动画是上述操作的具体展示：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01ae013251439d3f4b.gif\x22 alt=\x22\x22 title=\x22Removing a node with 0, 1, 2 children from a binary search tree\x22\x3e\x3c\/p\x3e\n\x3cp\x3e在动画中，被移动的节点是左子节点或者左子树，右子节点或右子树位置保持不变。\x3c\/p\x3e\n\x3cp\x3e关于删除节点，已经有了思路，让我们来实现它吧：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs kotlin\x22\x3eremove(value) {\n  const nodeToRemove = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(value);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!nodeToRemove) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Combine left and right children into one subtree without nodeToRemove\x3c\/span\x3e\n  const nodeToRemoveChildren = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.combineLeftIntoRightSubtree(nodeToRemove);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nodeToRemove.meta.multiplicity \x26amp;\x26amp; nodeToRemove.meta.multiplicity \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    nodeToRemove.meta.multiplicity -= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ handle duplicated\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nodeToRemove === \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Replace (root) node to delete with the combined subtree.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root = nodeToRemoveChildren;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root.parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ clearing up old parent\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    const side = nodeToRemove.isParentLeftChild ? \x3cspan class=\x22hljs-string\x22\x3e\x27left\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27right\x27\x3c\/span\x3e;\n    const { parent } = nodeToRemove; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ get parent\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Replace node to delete with the combined subtree.\x3c\/span\x3e\n    parent[side] = nodeToRemoveChildren;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size -= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e以下是实现中一些要注意的地方：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e首先，搜索待删除的节点是否存在。如果不存在，返回 \x3ccode\x3efalse\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e如果待删除的节点存在，则将它的左子树合并到右子树中，组合为一颗新子树。\x3c\/li\x3e\n\x3cli\x3e替换待删除的节点为组合好的子树。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e将左子树组合到右子树的函数如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3ecombineLeftIntoRightSubtree(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n  if\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e) {\n    \/\/译者注：原文是  getLeftmost，寻找左子树最大的节点，这肯定有问题，应该是找最小的节点才对\n    const leftLeast = this.getLefLeast(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e);  \n    leftLeast.left = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e;\n    return \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e;\n  }\n  return \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e正如下面例子所示，我们想把节点 #30 删除，将待删除节点的左子树整合到右子树中，结果如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e   \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e*                             \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e\n \/     \\                          \/  \\\n\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e    combine(\x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e)       \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e\n  \\    \/  \\   -----------\x26gt;      \/\n  \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e  \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e                  \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n                                \\\n                                 \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在把新的子树的根节点作为整个二叉树的根节点，节点 #30 将不复存在！\x3c\/p\x3e\n\x3ch1\x3e二叉树的遍历\x3c\/h1\x3e\n\x3cp\x3e根据遍历的顺序，二叉树的遍历有若干种形式：中序遍历、先序遍历与后序遍历。同时，我们也可以使用在《初学者应该了解的数据结构： Graph》一文中学到的  DFS 或 BFS 来遍历整棵树。以下是具体的实现：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e中序遍历\x3c\/strong\x3e（In-Order Traversal）\x3c\/p\x3e\n\x3cp\x3e中序遍历访问节点的顺序是：左子节点、节点本身、右子节点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e* inOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= this\x3c\/span\x3e.root) {\n    if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e) { yield* this.inOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e); }\n    yield \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    if\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e) { yield* this.inOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e); }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e用以下这棵树作为例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e         \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n       \/    \\\n      \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e      \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n    \/       \/  \\\n   \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e       \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e   \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e\n \/\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e中序遍历将按照以下顺序输出对应的值：3、4、5、10、15、30、40。也就是说，如果待遍历的树是一颗二叉搜索树，那输出值的顺序将是升序的。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e后序遍历\x3c\/strong\x3e（Post-Order Traversal）\x3c\/p\x3e\n\x3cp\x3e后序遍历访问节点的顺序是：左子节点、右子节点、节点本身。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e* postOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= this\x3c\/span\x3e.root) {\n    if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e) { yield* this.postOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e); }\n    if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e) { yield* this.postOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e); }\n    yield \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n  }\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e后序遍历将按照以下顺序输出对应的值：3、4、5、15、40、30、10。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e先序遍历与 DFS\x3c\/strong\x3e（Pre-Order Traversal）\x3c\/p\x3e\n\x3cp\x3e先序遍历访问节点的顺序是：节点本身、左子节点、右子节点。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e* preOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e= this\x3c\/span\x3e.root) {\n    yield \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e;\n    if\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e) { yield* this.preOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eleft\x3c\/span\x3e); }\n    if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e) { yield* this.preOrderTraversal(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eright\x3c\/span\x3e); }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e先序遍历将按照以下顺序输出对应的值：10、5、4、3、30、15、40。与深度优先搜索（DPS）的顺序是一致的。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e广度优先搜索 (BFS)\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e树的 BFS 可以通过队列来实现：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e* bfs() {\n    const\x3cspan class=\x22hljs-built_in\x22\x3e queue \x3c\/span\x3e= new Queue();\n    queue.\x3cspan class=\x22hljs-builtin-name\x22\x3eadd\x3c\/span\x3e(this.root);\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (!queue.isEmpty()) {\n      const node = queue.\x3cspan class=\x22hljs-builtin-name\x22\x3eremove\x3c\/span\x3e();\n      yield node;\n      node.descendents.\x3cspan class=\x22hljs-keyword\x22\x3eforEach\x3c\/span\x3e(child =\x26gt; queue.\x3cspan class=\x22hljs-builtin-name\x22\x3eadd\x3c\/span\x3e(child));\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eBFS 将按照以下顺序输出对应的值：10、5、30、4、15、40、3。\x3c\/p\x3e\n\x3ch1\x3e平衡树 vs. 非平衡树\x3c\/h1\x3e\n\x3cp\x3e目前，我们已经讨论了如何新增、删除与查找元素。然而，我们并未谈到（相关操作的）时间复杂度，先思考一下最坏的情况。\x3c\/p\x3e\n\x3cp\x3e假设按升序添加数字：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014b63aee408286fcc.gif\x22 alt=\x22\x22 title=\x22Inserting values in ascending order in a Binary Search Tree\x22\x3e\x3c\/p\x3e\n\x3cp\x3e树的左侧没有任何节点！在这颗非平衡树（ Non-balanced Tree）中进行查找元素并不比使用链表所花的时间短，都是 \x3cem\x3eO(n)\x3c\/em\x3e。 😱\x3c\/p\x3e\n\x3cp\x3e在非平衡树中查找元素，如同以逐页翻看的方式在字典中寻找一个单词。但如果树是平衡的，将类似于对半翻开字典，视乎该页的字母，选择左半部分或右半部分继续查找（对应的词）。\x3c\/p\x3e\n\x3cp\x3e需要找到一种方式使树变得平衡！\x3c\/p\x3e\n\x3cp\x3e如果树是\x3cstrong\x3e平衡\x3c\/strong\x3e的，查找元素不在需要遍历全部元素，时间复杂度降为 \x3cem\x3eO(log n)\x3c\/em\x3e。让我们探讨一下平衡树的意义。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01348a324b8b528bae.jpg\x22 alt=\x22\x22 title=\x22Balanced vs unbalanced Tree\x22\x3e\x3c\/p\x3e\n\x3cp\x3e如果在非平衡树中寻找值为 7 的节点，就必须从节点 #1 往下直到节点 #7。然而在平衡树中，我们依次访问 #4、#6 后，下一个节点将到达 #7。随着树规模的增大，（非平衡树的）表现会越来越糟糕。如果树中有上百万个节点，查找一个不存在的元素需要上百万次访问，而平衡树中只要20次！这是天壤之别！\x3c\/p\x3e\n\x3cp\x3e我们将在下一篇文章中通过自平衡树来解决这个问题。\x3c\/p\x3e\n\x3ch1\x3e总结\x3c\/h1\x3e\n\x3cp\x3e我们讨论了不少树的基础，以下是相关的总结：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e树是一种数据结构，它的节点有 0 个或多个子节点。\x3c\/li\x3e\n\x3cli\x3e树并不存在环，图才存在。\x3c\/li\x3e\n\x3cli\x3e在二叉树中，每个节点最多只有两个子节点。\x3c\/li\x3e\n\x3cli\x3e当一颗二叉树中，左子节点的值小于节点的值，而右子节点的值大于节点的值时，这颗树被称为\x3cstrong\x3e二叉搜索树\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e可以通过先序、后续和中序的方式访问一棵树。\x3c\/li\x3e\n\x3cli\x3e在非平衡树中查找的时间复杂度是 \x3cem\x3eO(n)\x3c\/em\x3e。 🤦🏻\x3c\/li\x3e\n\x3cli\x3e在平衡树中查找的时间复杂度是 \x3cem\x3eO(log n)\x3c\/em\x3e。 🎉\x3c\/li\x3e\n\x3c\/ul\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/tree-data-structures-for-beginners">https://www.zcfy.cc/article/tree-data-structures-for-beginners</a> 原文标题: 初学者应该了解的数据结构： Tree 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/fcaaa7e6/" target="_blank">https://alili.tech/archive/fcaaa7e6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>