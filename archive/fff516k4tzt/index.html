<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【Node.js】理解事件循环机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【Node.js】理解事件循环机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fff516k4tzt/",
				"appid": "1613049289050283", 
				"title": "【Node.js】理解事件循环机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-23T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3o6hu28856o/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zqs2pve9lp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&text=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&text=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&title=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&is_video=false&description=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&title=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&title=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&title=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffff516k4tzt%2f&title=%e3%80%90Node.js%e3%80%91%e7%90%86%e8%a7%a3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【Node.js】理解事件循环机制</h1><div class="meta"><div class="postdate"><time datetime="2018-12-23" itemprop="datePublished">2018-12-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前沿\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3eNode.js 是基于V8引擎的javascript运行环境. Node.js具有\x3ccode\x3e事件驱动\x3c\/code\x3e, \x3ccode\x3e非阻塞I\/O\x3c\/code\x3e等特点. 结合Node API, Node.js 具有网络编程, 文件系统等服务端的功能, Node.js用\x3ccode\x3elibuv\x3c\/code\x3e库进行异步事件处理.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e线程\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3eNode.js的单线程含义, 实际上说的是执行同步代码的主线程. 一个Node程序的启动, 不止是分配了一个线程，而是我们只能在一个线程执行代码. 当出现I\/O资源调用, TCP连接等外部资源申请的时候, 不会阻塞主线程, 而是委托给I\/O线程进行处理,并且进入等待队列. 一旦主线程执行完成，将会消费事件队列(Event Queue). 因为只有一个主线程, 只占用CPU内核处理逻辑计算, 因此不适合在CPU密集型进行使用.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVZBap?w=800\x26amp;h=316\x22 src=\x22https:\/\/static.alili.tech\/img\/bVZBap?w=800\x26amp;h=316\x22 alt=\x22Node核心\x22 title=\x22Node核心\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意，上图的\x3ccode\x3eEVENT_QUEUE\x3c\/code\x3e 给人看起来是只有一个队列, 根据Node.js官方介绍, \x3ccode\x3eEventLoop\x3c\/code\x3e有6个阶段, 同时每个阶段都有对应的一个先进先出的回调队列. \x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e什么是事件循环(EventLoop) ?\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3eIn computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or messages in a program. -- \x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Event_loop\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efrom wiki\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e大概含义: EventLoop 是一种常用的机制，通过对内部或外部的事件提供者发出请求, 如文件读写, 网络连接 等异步操作, 完成后调用事件处理程序. 整个过程都是异步阶段\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eNode.js的事件循环机制\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3eWhen Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which is not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop. -- from \x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/v6.x\/doc\/topics\/event-loop-timers-and-nexttick.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode.js doc\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e大致含义: 当Node.js 启动, 就会初始化一个 event loop, 处理脚本时, 可能会发生异步API行为调用, 使用定时器任务或者nexTick, 处理完成后进入事件循环处理过程\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e事件循环阶段\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   ┌───────────────────────┐\n┌─\x3e│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I\/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │\x3c─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3e   ┌───────────────────────┐\n┌─\x26gt;│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I\/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │\x26lt;─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │       \x3cspan class=\x22hljs-built_in\x22\x3e check \x3c\/span\x3e         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e每一个阶段都有一个FIFO的callbacks队列, 每个阶段都有自己的事件处理方式. 当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段. \x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3etimers\x3c\/strong\x3e 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback;\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eI\/O callbacks\x3c\/strong\x3e 阶段: 执行除了close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks; (目前这个阶段)\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eidle, prepare\x3c\/strong\x3e 阶段: 仅node内部使用;\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3epoll\x3c\/strong\x3e 阶段: 获取新的I\/O事件, 适当的条件下node将阻塞在这里;\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3echeck\x3c\/strong\x3e 阶段: 执行setImmediate() 设定的callbacks;\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eclose callbacks\x3c\/strong\x3e 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e下面是摘抄\x3ca href=\x22https:\/\/github.com\/creeperyang\/blog\/issues\/26\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecreeperyang\x3c\/a\x3e 对上面6个阶段的 (\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/v6.x\/doc\/topics\/event-loop-timers-and-nexttick.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文翻译\x3c\/a\x3e)\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3etimers阶段\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e一个timer指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定时间过后，timers会尽可能早地执行回调，但系统调度或者其它回调的执行可能会延迟它们。\x3c\/p\x3e\n\x3cp\x3e注意：技术上来说，poll 阶段控制 timers 什么时候执行。\x3c\/p\x3e\n\x3cp\x3e注意：这个下限时间有个范围：[1, 2147483647]，如果设定的时间不在这个范围，将被设置为1。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3eI\/O callbacks阶段\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e这个阶段执行一些系统操作的回调。比如TCP错误，如一个TCP socket在想要连接时收到ECONNREFUSED,\x3cbr\x3e类unix系统会等待以报告错误，这就会放到 I\/O callbacks 阶段的队列执行.\x3cbr\x3e名字会让人误解为执行I\/O回调处理程序, 实际上I\/O回调会由poll阶段处理.\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3epoll阶段\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3epoll 阶段有两个主要功能：\x3c\/p\x3e\n\x3cp\x3e执行下限时间已经达到的timers的回调，然后\x3cbr\x3e处理 poll 队列里的事件。\x3cbr\x3e当event loop进入 poll 阶段，并且 没有设定的timers（there are no timers scheduled），会发生下面两件事之一：\x3c\/p\x3e\n\x3cp\x3e如果 poll 队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限；\x3c\/p\x3e\n\x3cp\x3e如果 poll 队列为空，则发生以下两件事之一：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果代码已经被setImmediate()设定了回调, event loop将结束 poll 阶段进入 check 阶段来执行 check 队列（里的回调）。\x3c\/li\x3e\n\x3cli\x3e如果代码没有被setImmediate()设定回调，event loop将阻塞在该阶段等待回调被加入 poll 队列，并立即执行。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e但是，当event loop进入 poll 阶段，并且 有设定的timers，一旦 poll 队列为空（poll 阶段空闲状态）：\x3c\/p\x3e\n\x3col\x3e\x3cli\x3eevent loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 \x3cstrong\x3etimers\x3c\/strong\x3e 阶段，并执行 \x3cstrong\x3etimer\x3c\/strong\x3e 队列。\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\x3cstrong\x3echeck阶段\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e这个阶段允许在 poll 阶段结束后立即执行回调。如果 poll 阶段空闲，并且有被setImmediate()设定的回调，event loop会转到 check 阶段而不是继续等待。\x3c\/p\x3e\n\x3cp\x3esetImmediate()实际上是一个特殊的timer，跑在event loop中一个独立的阶段。它使用libuv的API\x3cbr\x3e来设定在 poll 阶段结束后立即执行回调。\x3c\/p\x3e\n\x3cp\x3e通常上来讲，随着代码执行，event loop终将进入 poll 阶段，在这个阶段等待 incoming connection, request 等等。但是，只要有被setImmediate()设定了回调，一旦 poll 阶段空闲，那么程序将结束 poll 阶段并进入 check 阶段，而不是继续等待 poll 事件们 （poll events）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3eclose callbacks 阶段\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e如果一个 socket 或 handle 被突然关掉（比如 socket.destroy()），close事件将在这个阶段被触发，否则将通过process.nextTick()触发\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e简单的 EventLoop\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nlet counts = 0;\n\nfunction wait (mstime) {\n  let date = Date.now();\n  while (Date.now() - date \x3c mstime) {\n    \/\/ do nothing\n  }\n}\n\nfunction asyncOperation (callback) {\n  fs.readFile(__dirname \x2b \x27\/\x27 \x2b __filename, callback);\n}\n\nconst lastTime = Date.now();\n\nsetTimeout(() =\x3e {\n  console.log(\x27timers\x27, Date.now() - lastTime \x2b \x27ms\x27);\n}, 0);\n\nprocess.nextTick(() =\x3e {\n  \/\/ 进入event loop\n  \/\/ timers阶段之前执行\n  wait(20);\n  asyncOperation(() =\x3e {\n    console.log(\x27poll\x27);\n  });  \n});\n\n\/**\n * result:\n * timers 21ms\n * poll\n *\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e counts = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewait\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emstime\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - date \x26lt; mstime) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do nothing\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easyncOperation\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  fs.readFile(__dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e \x2b __filename, callback);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lastTime = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timers\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - lastTime \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27ms\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 进入event loop\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ timers阶段之前执行\x3c\/span\x3e\n  wait(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n  asyncOperation(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27poll\x27\x3c\/span\x3e);\n  });  \n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * result:\n * timers 21ms\n * poll\n *\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了让\x3ccode\x3esetTimeout\x3c\/code\x3e优先于\x3ccode\x3efs.readFile\x3c\/code\x3e 回调, 执行了process.nextTick, 表示在进入 timers阶段前, 等待20ms后执行文件读取.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3enextTick 与 setImmediate\x3c\/h3\x3e\n\x3cp\x3eprocess.nextTick 不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调。有给人一种插队的感觉. \x3c\/p\x3e\n\x3cp\x3esetImmediate的回调处于check阶段, 当poll阶段的队列为空, 且check阶段的事件队列存在的时候，切换到check阶段执行. \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3enextTick 递归的危害\x3c\/strong\x3e \x3cbr\x3e由于nextTick具有插队的机制，nextTick的递归会让事件循环机制无法进入下一个阶段. 导致I\/O处理完成或者定时任务超时后仍然无法执行, 导致了其它事件处理程序处于饥饿状态. 为了防止递归产生的问题, Node.js 提供了一个 process.maxTickDepth (默认 1000)。 \x3c\/p\x3e\n\x3cp\x3e递归nextTick\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nlet counts = 0;\n\nfunction wait (mstime) {\n  let date = Date.now();\n  while (Date.now() - date \x3c mstime) {\n    \/\/ do nothing\n  }\n}\n\nfunction nextTick () {\n  process.nextTick(() =\x3e {\n    wait(20);\n    nextTick();\n  });\n}\n\nconst lastTime = Date.now();\n\nsetTimeout(() =\x3e {\n  console.log(\x27timers\x27, Date.now() - lastTime \x2b \x27ms\x27);\n}, 0);\n\nnextTick();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e counts = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewait\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emstime\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - date \x26lt; mstime) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do nothing\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enextTick\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    wait(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n    nextTick();\n  });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lastTime = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timers\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - lastTime \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27ms\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nnextTick();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时永远无法跳到timer阶段, 因为在进入timers阶段前有不断的nextTick插入执行. 除非执行了1000次到了执行上限.\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3esetImmediate\x3c\/strong\x3e\x3cbr\x3e如果在一个I\/O周期内进行调度，setImmediate（）将始终在任何定时器之前执行.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3esetTimeout 与 setImmediate\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3esetImmediate()被设计在 poll 阶段结束后立即执行回调；\x3c\/li\x3e\n\x3cli\x3esetTimeout()被设计在指定下限时间到达后执行回调;\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e无 I\/O 处理情况下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(function timeout () {\n  console.log(\x27timeout\x27);\n},0);\n\nsetImmediate(function immediate () {\n  console.log(\x27immediate\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e);\n},\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimmediate\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27immediate\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e输出结果是 不确定 的！\x3c\/strong\x3e\x3cbr\x3esetTimeout(fn, 0) 具有几毫秒的不确定性. 无法保证进入timers阶段, 定时器能够立即执行处理程序.\x3c\/p\x3e\n\x3cp\x3e在I\/O事件处理程序下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fs = require(\x27fs\x27)\n\nfs.readFile(__filename, () =\x3e {\n  setTimeout(() =\x3e {\n    console.log(\x27timeout\x27)\n  }, 0)\n  setImmediate(() =\x3e {\n    console.log(\x27immediate\x27)\n  })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e)\n\nfs.readFile(__filename, () =\x26gt; {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e)\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n  setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27immediate\x27\x3c\/span\x3e)\n  })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时 \x3ccode\x3esetImmediate\x3c\/code\x3e 优先于 \x3ccode\x3esetTimeout\x3c\/code\x3e 执行，因为 poll阶段执行完成后 进入 check阶段. timers阶段处于下一个事件循环阶段了.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e相关文章\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.cnblogs.com\/onepixel\/p\/7143769.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅析 Node.js 单线程模型\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/cnodejs.org\/topic\/57d68794cb6f605d360105bf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js Event Loop 的理解 Timers，process.nextTick()\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/creeperyang\/blog\/issues\/26\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js的event loop及timer\/setImmediate\/nextTick\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/v6.x\/doc\/topics\/event-loop-timers-and-nexttick.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThe Node.js Event Loop, Timers, and process.nextTick()\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【Node.js】理解事件循环机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012258592">https://segmentfault.com/a/1190000012258592</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fff516k4tzt/" target="_blank">https://alili.tech/archive/fff516k4tzt/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>