<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="学习数据结构与算法之二叉搜索树"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>学习数据结构与算法之二叉搜索树 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fgqo3xvc4w7/",
				"appid": "1613049289050283", 
				"title": "学习数据结构与算法之二叉搜索树 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-04T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fydd68xf0nl/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/13ccopgj61if/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&text=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&text=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&title=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&is_video=false&description=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&title=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&title=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&title=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffgqo3xvc4w7%2f&title=%e5%ad%a6%e4%b9%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e4%b9%8b%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">学习数据结构与算法之二叉搜索树</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本系列所有文章：\x3cbr\x3e第一篇文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010562555\x22\x3e学习数据结构与算法之栈与队列\x3c\/a\x3e\x3cbr\x3e第二篇文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010581042\x22 target=\x22_blank\x22\x3e学习数据结构与算法之链表\x3c\/a\x3e\x3cbr\x3e第三篇文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010602109\x22\x3e学习数据结构与算法之集合\x3c\/a\x3e\x3cbr\x3e第四篇文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010622249\x22 target=\x22_blank\x22\x3e学习数据结构与算法之字典和散列表\x3c\/a\x3e\x3cbr\x3e第五篇文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010640395\x22\x3e学习数据结构与算法之二叉搜索树\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e二叉搜索树简介\x3c\/h2\x3e\n\x3cp\x3e二叉树是一种非线性数据结构，其中的每个元素我们称为节点，二叉树中每个节点最多只能有两个子节点；没有父节点的节点称为根节点，没有子节点的节点称为叶节点。二叉搜索树是二叉树的一种，其特征是左侧子节点存储比父节点小的值，右侧子节点存储比父节点大（或等于父节点）的值。下图就是一颗典型的二叉搜索树:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640400\x22 alt=\x22二叉搜索树\x22 title=\x22二叉搜索树\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e二叉搜索树的实现\x3c\/h2\x3e\n\x3cp\x3e二叉搜索树的节点，我们用类似双向链表的方式存储节点（都包含两个对其他节点的引用），但是这里两个引用指向的分别是左右两个子节点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function BinarySearchTree () {\n  \/\/ 二叉树的键\n  var Node = function (key) {\n    \/\/ 键值\n    this.key = key\n    \/\/ 左节点\n    this.left = null\n    \/\/ 右节点\n    this.right = null\n  }\n  \n  \/\/ 根节点\n  var root = null\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBinarySearchTree\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 二叉树的键\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Node = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 键值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key = key\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 左节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.left = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 右节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.right = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根节点\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e二叉搜索树需要实现以下方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3einsert(key)：向树中插入一个新的键\x3c\/li\x3e\n\x3cli\x3esearch(key)：在树中查找一个键，如果节点存在返回tue，否则返回false\x3c\/li\x3e\n\x3cli\x3einOrderTraverse：通过中序遍历方式遍历所有节点\x3c\/li\x3e\n\x3cli\x3epreOrderTraverse：通过先序遍历方式遍历节点\x3c\/li\x3e\n\x3cli\x3epostOrderTraverse：通过后序遍历方式遍历所有节点\x3c\/li\x3e\n\x3cli\x3emin：返回树中最小的值\x3c\/li\x3e\n\x3cli\x3emax：返回树中最大的值\x3c\/li\x3e\n\x3cli\x3eremove(key)：从树中移除某个键\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e注意：本文中很多地方使用了递归的方法，如果不了解递归，可以先看看这个\x3ca href=\x22https:\/\/www.zhihu.com\/question\/20507130\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e知乎问题-递归\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e实现insert\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 用于插入节点\nvar insertNode = function (node, newNode) {\n  \/\/ 在二叉搜索树中，比父节点小的值存在左侧节点，大于等于父节点的存在右侧节点\n  \/\/ 若要插入一个节点（根节点已存在），首先与根节点比大小，若比根节点小则应插入根节点的左侧\n  \/\/ 如果左侧已存在节点，则递归调用函数，将左侧节点传入递归函数作为当前节点\n  \/\/ 如果插入的节点比当前节点大且当前节点右侧为空，则插入右侧\n  \/\/ 如果插入节点比根节点大，原理同上\n  if (newNode.key \x3c node.key) {\n    if (node.left === null) {\n      node.left = newNode\n    } else {\n      insertNode(node.left, newNode)\n    }\n  } else {\n    if (node.right === null) {\n      node.right = newNode\n    } else {\n      insertNode(node.right, newNode)\n    }\n  }\n}\n\n\/\/ 插入\nthis.insert = function (key) {\n  var node = new Node(key)\n\n  if (root === null) {\n    root = node\n  } else {\n    insertNode(root, node)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于插入节点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e insertNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, newNode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在二叉搜索树中，比父节点小的值存在左侧节点，大于等于父节点的存在右侧节点\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若要插入一个节点（根节点已存在），首先与根节点比大小，若比根节点小则应插入根节点的左侧\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果左侧已存在节点，则递归调用函数，将左侧节点传入递归函数作为当前节点\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果插入的节点比当前节点大且当前节点右侧为空，则插入右侧\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果插入节点比根节点大，原理同上\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newNode.key \x26lt; node.key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.left === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node.left = newNode\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      insertNode(node.left, newNode)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.right === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node.right = newNode\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      insertNode(node.right, newNode)\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 插入\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.insert = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e node = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(key)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    root = node\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    insertNode(root, node)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e实现search\x3c\/h3\x3e\n\x3cp\x3e这里同样借助一个辅助函数使用，辅助函数同样是用了递归，简单比较输入的key与当前节点的key，当相等时（意味着找到了目标节点）就返回true；当查找完最末端的节点时，即传入的node为null时，就返回false，表示未找到。\x3c\/p\x3e\n\x3cp\x3e有人可能会怀疑，这样真的找到吗？实际上，由于二叉搜索树子节点“左小右大”的性质，一个特定的值在二叉搜索树中的大致位置是可预见的（即使是插入那个值也不会跑出那个范围）。所以仅仅通过简单的比较key就能在某个范围中找到目标节点，而且这种方法不用遍历整棵树去找，非常节省性能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var searchNode = function (node, key) {\n  if (node === null) {\n    false\n  }\n\n  if (key \x3c node.key) {\n    return searchNode(node.left, key)\n  } else if (key \x3e node.key) {\n    return searchNode(node.right, key)\n  } else {\n    return true\n  }\n}\n\n\/\/ 查找节点\nthis.search = function (key) {\n  return searchNode(root, key)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e searchNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, key\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26lt; node.key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e searchNode(node.left, key)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26gt; node.key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e searchNode(node.right, key)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 查找节点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.search = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e searchNode(root, key)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e实现中序遍历\x3c\/h3\x3e\n\x3cp\x3e接下来就是三个遍历方法，先从中序遍历开始，其作用是按顺序（从小到大）访问整棵树的所有节点，也就是常见的升序排序。\x3c\/p\x3e\n\x3cp\x3e其实这三种遍历并没有那么复杂，简单地观察一下回调函数（也就是访问key）的位置，就能看出来是哪种排序。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var inOrderTraverseNode = function (node, callback) {\n  if (node !== null) { \/\/ 停止递归的条件\n    inOrderTraverseNode(node.left, callback)\n    callback(node.key)\n    inOrderTraverseNode(node.right, callback)\n  }\n}\n\n\/\/ 中序遍历\nthis.inOrderTraverse = function (callback) {\n  inOrderTraverseNode(root, callback)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inOrderTraverseNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止递归的条件\x3c\/span\x3e\n    inOrderTraverseNode(node.left, callback)\n    callback(node.key)\n    inOrderTraverseNode(node.right, callback)\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 中序遍历\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inOrderTraverse = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  inOrderTraverseNode(root, callback)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e实现先序遍历\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var preOrderTraverseNode = function (node, callback) {\n  if (node !== null) {\n    callback(node.key)\n    preOrderTraverseNode(node.left, callback)\n    preOrderTraverseNode(node.right, callback)\n  }\n}\n\n\/\/ 先序遍历\nthis.preOrderTraverse = function (callback) {\n  preOrderTraverseNode(root, callback)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e preOrderTraverseNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    callback(node.key)\n    preOrderTraverseNode(node.left, callback)\n    preOrderTraverseNode(node.right, callback)\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先序遍历\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.preOrderTraverse = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  preOrderTraverseNode(root, callback)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e实现后序遍历\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var postOrderTraverseNode = function (node, callback) {\n  if (node !== null) {\n    postOrderTraverseNode(node.left, callback)\n    postOrderTraverseNode(node.right, callback)\n    callback(node.key)\n  }\n}\n\n\/\/ 后序遍历\nthis.postOrderTraverse = function (callback) {\n  postOrderTraverseNode(root, callback)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e postOrderTraverseNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    postOrderTraverseNode(node.left, callback)\n    postOrderTraverseNode(node.right, callback)\n    callback(node.key)\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后序遍历\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.postOrderTraverse = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  postOrderTraverseNode(root, callback)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里先停一下：的确看回调函数就能知道这是哪种遍历，但是这些函数递归理解起来确实有点困难，这里我建议在重复的大问题面前先拆成小问题来看：\x3c\/p\x3e\n\x3cp\x3e请看这个最简单的二叉树\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640401\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640401\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果现在先序遍历这个二叉树，它的顺序应该是M -\x26gt; H -\x26gt; Z；中序遍历的顺序是H -\x26gt; M -\x26gt; Z；后序遍历是：H -\x26gt; Z -\x26gt; M\x3c\/p\x3e\n\x3cp\x3e那么再看下面这棵大树的中序遍历就会好理解了：先从根节点左侧子树开始遍历，左侧子树里面又有小左侧子树，里面最小的由3，5，6组成的子树就和上面最简单的二叉树一样了。这时遍历从3开始，以正常的中序遍历顺序3 -\x26gt; 5 -\x26gt; 6。当遍历完6之后我们可以将这个小的子树看成一个整体，这个整体和上面的父节点7以及右边的子树也组成了一个简单的二叉树结构，然后正常遍历7 -\x26gt; 右侧子树，右侧子树中依旧按照中序遍历的顺序：8 -\x26gt; 9 -\x26gt; 10，按此顺序不断遍历完所有的节点。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640402\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640402\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e实现min和max\x3c\/h3\x3e\n\x3cp\x3e这个两个方法其实挺简单的，最小的节点就在二叉搜索树的最左；反之，最大的就在最右。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var minNode = function(node) {\n  \/\/ 如果node存在，则开始搜索。能避免树的根节点为Null的情况\n  if (node) {\n    \/\/ 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。\n    \/\/ 若左子节点为null，则该节点肯定为最小值。\n    while (node \x26amp;\x26amp; node.left !== null) {\n      node = node.left\n    }\n    return node.key\n  }\n  return null\n}\n\nvar maxNode = function(node) {\n  if (node) {\n    while (node \x26amp;\x26amp; node.right !== null) {\n      node = node.right\n    }\n    return node.key\n  }\n  return null\n}\n\n\/\/ 找到最小节点\nthis.min = function () {\n  return minNode(root)\n}\n\n\/\/ 找到最大节点\nthis.max = function () {\n  return maxNode(root)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e minNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果node存在，则开始搜索。能避免树的根节点为Null的情况\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若左子节点为null，则该节点肯定为最小值。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (node \x26amp;\x26amp; node.left !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = node.left\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node.key\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e maxNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (node \x26amp;\x26amp; node.right !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = node.right\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node.key\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到最小节点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.min = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e minNode(root)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到最大节点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.max = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e maxNode(root)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e实现remove\x3c\/h3\x3e\n\x3cp\x3e好了，现在剩下最后一个方法了，先深吸一口气。。。\x3c\/p\x3e\n\x3cp\x3e接下来实现的方法号称全书最复杂的方法，鉴于本人目前水平有限，我只能将自己看懂的思路写出来，如果讲得不好大家可以去看原书《学习JavaScript数据结构与算法》。\x3c\/p\x3e\n\x3cp\x3e下面进入正题：\x3c\/p\x3e\n\x3cp\x3e移除二叉搜索树中的一个节点需要考虑三种情况：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e删除的是叶节点（没有子节点的节点）\x3c\/li\x3e\n\x3cli\x3e删除的节点有一侧子节点\x3c\/li\x3e\n\x3cli\x3e删除的节点有两侧子节点\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e还是老原则，化繁为简。\x3c\/p\x3e\n\x3cp\x3e先看第一个比较简单的：既然它没有子节点，那就先找到它，再直接将它与父节点的联系切断就行了；\x3c\/p\x3e\n\x3cp\x3e第二个就稍微复杂一点：你得先把它删掉，然后把它的子节点接到它的父节点上去；\x3c\/p\x3e\n\x3cp\x3e第三个最复杂：你不能直接删掉它，你应该在它的右侧子树里面找到最小的那个节点把它替换掉，然后为防止重复，把替换它的节点删掉就万事大吉了。\x3c\/p\x3e\n\x3cp\x3e这里前两种情况都还能理解，所以我只解释为什么是右侧子树的最小节点。\x3c\/p\x3e\n\x3cp\x3e其实这是为了防止顺序乱掉而做的处理，举个例子：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010640402\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010640402\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e还是之前的那张图，我要删掉15这个节点，那么这时无论是把20还是13接到根节点11下面都会导致二叉搜索树“左小右大”的结构大乱（就像曹操如果没有接班人就死了北方就会大乱），因此最好的办法是找一个比他大一点的节点来替换它（找一个强一点的接班人坐他的位子维持秩序）。\x3c\/p\x3e\n\x3cp\x3e这里为啥是大一点而不是大很多？因为大太多也会导致结构混乱（过于强势成为暴君就不给底下人活路了）。所以就选了一个大一点的节点替换到这个位置上来，同时为防止重复就删掉了原来的节点（接班人不能身兼两职所以要辞掉原来的职位）。\x3c\/p\x3e\n\x3cp\x3e说到这里我就直接贴代码了，反正现在让我写，一时半会是写不出来的，因此仅供观摩：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这个辅助函数和minNode函数是一样的，只不过返回值不一样\nvar findMinNode = function (node) {\n  if (node === null) {\n    while (node \x26amp;\x26amp; node.left !== null) {\n      node = node.left\n    }\n    return node\n  }\n  return null\n}\n\nvar removeNode = function (node, key) {\n  if (node === null) {\n    return null\n  }\n\n  if (key \x3c node.key) {\n    node.left = removeNode(node.left, key)\n    return node\n  } else if (key \x3e node.key) {\n    node.right = removeNode(node.right, key)\n    return node\n  } else {\n    \/\/ 第一种情况：删除叶节点\n    if (node.left === null \x26amp;\x26amp; node.right === null) {\n      node = null\n      return node\n    }\n\n    \/\/ 第二种情况：删除一侧有子节点的节点\n    \/\/ 将一侧的子节点替换为当前节点\n    if (node.left === null) {\n      node = node.right\n      return node\n    } else if (node.right === null) {\n      node = node.left\n      return node\n    }\n\n    \/\/ 第三种情况：删除两侧都有子节点的节点\n    \/\/ 找到当前节点右侧子树中最小的那个节点，替换掉要删除的节点\n    \/\/ 然后再把右侧子树中最小的节点移除\n    var aux = findMinNode(node.right)\n    node.key = aux.key\n    node.right = removeNode(node.right, aux.key)\n    return node\n  }\n}\n\n\/\/ 删除节点\nthis.remove = function (key) {\n  root = removeNode(root, key)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个辅助函数和minNode函数是一样的，只不过返回值不一样\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e findMinNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (node \x26amp;\x26amp; node.left !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = node.left\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e removeNode = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enode, key\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26lt; node.key) {\n    node.left = removeNode(node.left, key)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26gt; node.key) {\n    node.right = removeNode(node.right, key)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一种情况：删除叶节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.left === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; node.right === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二种情况：删除一侧有子节点的节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将一侧的子节点替换为当前节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.left === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = node.right\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.right === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      node = node.left\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第三种情况：删除两侧都有子节点的节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到当前节点右侧子树中最小的那个节点，替换掉要删除的节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后再把右侧子树中最小的节点移除\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e aux = findMinNode(node.right)\n    node.key = aux.key\n    node.right = removeNode(node.right, aux.key)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除节点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n  root = removeNode(root, key)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e源代码在此：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/laobeijing0806\/Algorithm-And-Datastructure\/blob\/master\/binarySearchTree.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e二叉搜索树的实现-源代码\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e实现二叉搜索树花了好长时间，后面的图也是挺麻烦的数据结构，但是这段时间不停地学习数据结构也是让自己得到了很大成长。继续加油～\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>学习数据结构与算法之二叉搜索树</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010640395">https://segmentfault.com/a/1190000010640395</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fgqo3xvc4w7/" target="_blank">https://alili.tech/archive/fgqo3xvc4w7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>