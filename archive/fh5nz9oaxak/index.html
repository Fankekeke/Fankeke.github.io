<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React中state和props分别是什么？"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React中state和props分别是什么？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fh5nz9oaxak/",
				"appid": "1613049289050283", 
				"title": "React中state和props分别是什么？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bsbgiwmjow/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/exggnju9p46/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&text=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&text=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&title=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&is_video=false&description=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&title=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&title=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&title=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffh5nz9oaxak%2f&title=React%e4%b8%adstate%e5%92%8cprops%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React中state和props分别是什么？</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e整理一下React中关于state和props的知识点。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e中，这两个属性有啥子区别呢？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eprops\x3c\/h2\x3e\n\x3cp\x3eReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。\x3c\/p\x3e\n\x3cp\x3e组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是\x3ccode\x3eprops\x3c\/code\x3e，所以可以把\x3ccode\x3eprops\x3c\/code\x3e理解为从外部传入组件内部的数据。由于React是单向数据流，所以\x3ccode\x3eprops\x3c\/code\x3e基本上也就是从服父级组件向子组件传递的数据。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e用法\x3c\/h3\x3e\n\x3cp\x3e假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：\x3ccode\x3e\x26lt;ItemList\/\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;Item\/\x26gt;\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e先看看\x3ccode\x3e\x26lt;ItemList\/\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Item from \x26quot;.\/item\x26quot;;\nexport default class ItemList extends React.Component{\n  const itemList = data.map(item =\x3e \x3cItem item=item \/\x3e);\n  render(){\n    return (\n      {itemList}\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Item \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/item\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eItemList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e itemList = data.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x26lt;Item item=item \/\x26gt;);\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      {itemList}\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e列表的数据我们就暂时先假设是放在一个\x3ccode\x3edata\x3c\/code\x3e变量中，然后通过\x3ccode\x3emap\x3c\/code\x3e函数返回一个每一项都是\x3ccode\x3e\x26lt;Item item=\x27数据\x27\/\x26gt;\x3c\/code\x3e的数组，也就是说这里其实包含了\x3ccode\x3edata.length\x3c\/code\x3e个\x3ccode\x3e\x26lt;Item\/\x26gt;\x3c\/code\x3e组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3e\x26lt;Item \/\x26gt;\x3c\/code\x3e中是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Item extends React.Component{\n  render(){\n    return (\n      \x3cli\x3e{this.props.item}\x3c\/li\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eItem\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.props.item}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3erender\x3c\/code\x3e函数中可以看出，组件内部是使用\x3ccode\x3ethis.props\x3c\/code\x3e来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个\x3ccode\x3eitem\x3c\/code\x3e属性，所以通过\x3ccode\x3ethis.props.item\x3c\/code\x3e来获取即可。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e只读性\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eprops\x3c\/code\x3e经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的\x3ccode\x3eprops\x3c\/code\x3e是只读的，不可改变的。如果\x3ccode\x3eprops\x3c\/code\x3e在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的\x3ccode\x3eprops\x3c\/code\x3e传入组件中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e默认参数\x3c\/h3\x3e\n\x3cp\x3e在组件中，我们最好为\x3ccode\x3eprops\x3c\/code\x3e中的参数设置一个\x3ccode\x3edefaultProps\x3c\/code\x3e，并且制定它的类型。比如，这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Item.defaultProps = {\n  item: \x27Hello Props\x27,\n};\n\nItem.propTypes = {\n  item: PropTypes.string,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eItem.defaultProps = {\n  \x3cspan class=\x22hljs-attr\x22\x3eitem\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello Props\x27\x3c\/span\x3e,\n};\n\nItem.propTypes = {\n  \x3cspan class=\x22hljs-attr\x22\x3eitem\x3c\/span\x3e: PropTypes.string,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于\x3ccode\x3epropTypes\x3c\/code\x3e，可以声明为以下几种类型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22optionalArray: PropTypes.array,\noptionalBool: PropTypes.bool,\noptionalFunc: PropTypes.func,\noptionalNumber: PropTypes.number,\noptionalObject: PropTypes.object,\noptionalString: PropTypes.string,\noptionalSymbol: PropTypes.symbol,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eoptionalArray: PropTypes.array,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalBool\x3c\/span\x3e: PropTypes.bool,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalFunc\x3c\/span\x3e: PropTypes.func,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalNumber\x3c\/span\x3e: PropTypes.number,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalObject\x3c\/span\x3e: PropTypes.object,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalString\x3c\/span\x3e: PropTypes.string,\n\x3cspan class=\x22hljs-attr\x22\x3eoptionalSymbol\x3c\/span\x3e: PropTypes.symbol,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，\x3ccode\x3ebool\x3c\/code\x3e和\x3ccode\x3efunc\x3c\/code\x3e是简写。\x3c\/p\x3e\n\x3cp\x3e这些知识基础数据类型，还有一些复杂的，附上链接：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/typechecking-with-proptypes.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/facebook.github.io\/react\/docs\/typechecking-with-proptypes.html\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eprops\x3c\/code\x3e是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的\x3ccode\x3eprops\x3c\/code\x3e来重新渲染子组件，否则子组件的\x3ccode\x3eprops\x3c\/code\x3e以及展现形式不会改变。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3estate\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3estate\x3c\/code\x3e是什么呢？\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eState is similar to props, but it is private and fully controlled by the component.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是\x3ccode\x3eprops\x3c\/code\x3e，而数据状态就是\x3ccode\x3estate\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e用法\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class ItemList extends React.Component{\n  constructor(){\n    super();\n    this.state = {\n      itemList:\x27一些数据\x27,\n    }\n  }\n  render(){\n    return (\n      {this.state.itemList}\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eItemList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3eitemList\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27一些数据\x27\x3c\/span\x3e,\n    }\n  }\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.itemList}\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先，在组件初始化的时候，通过\x3ccode\x3ethis.state\x3c\/code\x3e给组件设定一个初始的\x3ccode\x3estate\x3c\/code\x3e，在第一次\x3ccode\x3erender\x3c\/code\x3e的时候就会用这个数据来渲染组件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3esetState\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3estate\x3c\/code\x3e不同于\x3ccode\x3eprops\x3c\/code\x3e的一点是，\x3ccode\x3estate\x3c\/code\x3e是可以被改变的。不过，不可以直接通过\x3ccode\x3ethis.state=\x3c\/code\x3e的方式来修改，而需要通过\x3ccode\x3ethis.setState()\x3c\/code\x3e方法来修改\x3ccode\x3estate\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e比如，我们经常会通过异步操作来获取数据，我们需要在\x3ccode\x3edidMount\x3c\/code\x3e阶段来执行异步操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentDidMount(){\n  fetch(\x27url\x27)\n    .then(response =\x3e response.json())\n    .then((data) =\x3e {\n      this.setState({itemList:item});  \n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ecomponentDidMount(){\n  fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url\x27\x3c\/span\x3e)\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e response.json())\n    .then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3eitemList\x3c\/span\x3e:item});  \n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当数据获取完成后，通过\x3ccode\x3ethis.setState\x3c\/code\x3e来修改数据状态。\x3c\/p\x3e\n\x3cp\x3e当我们调用\x3ccode\x3ethis.setState\x3c\/code\x3e方法时，React会更新组件的数据状态\x3ccode\x3estate\x3c\/code\x3e，并且重新调用\x3ccode\x3erender\x3c\/code\x3e方法，也就是会对组件进行重新渲染。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：通过\x3ccode\x3ethis.state=\x3c\/code\x3e来初始化\x3ccode\x3estate\x3c\/code\x3e，使用\x3ccode\x3ethis.setState\x3c\/code\x3e来修改\x3ccode\x3estate\x3c\/code\x3e，\x3ccode\x3econstructor\x3c\/code\x3e是唯一能够初始化的地方。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetState\x3c\/code\x3e接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class ItemList extends React.Component{\n  constructor(){\n    super();\n    this.state = {\n      name:\x27axuebin\x27,\n      age:25,\n    }\n  }\n  componentDidMount(){\n    this.setState({age:18})  \n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eItemList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27axuebin\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e,\n    }\n  }\n  componentDidMount(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e18\x3c\/span\x3e})  \n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在执行完\x3ccode\x3esetState\x3c\/code\x3e之后的\x3ccode\x3estate\x3c\/code\x3e应该是\x3ccode\x3e{name:\x27axuebin\x27,age:18}\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetState\x3c\/code\x3e还可以接受第二个参数，它是一个函数，会在\x3ccode\x3esetState\x3c\/code\x3e调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState({\n  name:\x27xb\x27\n},()=\x3econsole.log(\x27setState finished\x27))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27xb\x27\x3c\/span\x3e\n},()=\x26gt;\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27setState finished\x27\x3c\/span\x3e))\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3estate\x3c\/code\x3e的主要作用是用于组件保存、控制以及修改自己的状态，它只能在\x3ccode\x3econstructor\x3c\/code\x3e中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的\x3ccode\x3ethis.setState\x3c\/code\x3e来修改，修改\x3ccode\x3estate\x3c\/code\x3e属性会导致组件的重新渲染。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e区别\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3estate\x3c\/code\x3e是组件自己管理数据，控制自己的状态，可变；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eprops\x3c\/code\x3e是外部传入的数据参数，不可变；\x3c\/li\x3e\n\x3cli\x3e没有\x3ccode\x3estate\x3c\/code\x3e的叫做无状态组件，有\x3ccode\x3estate\x3c\/code\x3e的叫做有状态组件；\x3c\/li\x3e\n\x3cli\x3e多用\x3ccode\x3eprops\x3c\/code\x3e，少用\x3ccode\x3estate\x3c\/code\x3e。也就是多写无状态组件。\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React中state和props分别是什么？</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011184076">https://segmentfault.com/a/1190000011184076</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fh5nz9oaxak/" target="_blank">https://alili.tech/archive/fh5nz9oaxak/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>