<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="《算法》第一章学习笔记js实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>《算法》第一章学习笔记js实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fmj1x7uyadw/",
				"appid": "1613049289050283", 
				"title": "《算法》第一章学习笔记js实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-28T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/kfysdgg5c08/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/gh1pyegklzp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&text=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&text=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&title=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&is_video=false&description=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&title=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&title=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&title=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffmj1x7uyadw%2f&title=%e3%80%8a%e7%ae%97%e6%b3%95%e3%80%8b%e7%ac%ac%e4%b8%80%e7%ab%a0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0js%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">《算法》第一章学习笔记js实现</h1><div class="meta"><div class="postdate"><time datetime="2018-12-28" itemprop="datePublished">2018-12-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e《算法》第一章学习笔记js实现\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/xiyuyizhi\/notes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e更多内容\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e目标：总结本书主要内容，相应算法使用js来模仿实现\x3c\/p\x3e\n\x3cblockquote\x3e在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。\x3cp\x3e我们关注的大多数算法都需要\x3ccode\x3e适当地组织数据\x3c\/code\x3e，而为了组织数据就产生了\x3ccode\x3e数据结构\x3c\/code\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e原书所有代码是基于JAVA语法的，这里，我们使用js来实现所有算法逻辑\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e队列、栈的实现\x3c\/h2\x3e\n\x3cblockquote\x3e队列是一种先进先出的集合类型，栈是一种先进后出的集合类型\x3c\/blockquote\x3e\n\x3cp\x3e首先定义要实现的队列、栈的API\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e\x3cstrong\x3eQueue\x3c\/strong\x3e\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eQueue()\x3c\/td\x3e\n\x3ctd\x3e创建空队列\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eenqueue(item)\x3c\/td\x3e\n\x3ctd\x3e添加一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3edequeue()\x3c\/td\x3e\n\x3ctd\x3e删除最近添加的元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eisEmpty()\x3c\/td\x3e\n\x3ctd\x3e队列是否为空\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3esize（）\x3c\/td\x3e\n\x3ctd\x3e队列中元素的数量\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eiterator()\x3c\/td\x3e\n\x3ctd\x3e返回一个可迭代对象\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3chr\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e\x3cstrong\x3eStack\x3c\/strong\x3e\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eStack()\x3c\/td\x3e\n\x3ctd\x3e创建空栈\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3epush(item)\x3c\/td\x3e\n\x3ctd\x3e添加一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3epop()\x3c\/td\x3e\n\x3ctd\x3e删除最近添加的元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eisEmpty()\x3c\/td\x3e\n\x3ctd\x3e栈是否为空\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3esize（）\x3c\/td\x3e\n\x3ctd\x3e栈中元素的数量\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eiterator()\x3c\/td\x3e\n\x3ctd\x3e返回一个可迭代对象\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3chr\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eIterator\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3ehasNext()\x3c\/td\x3e\n\x3ctd\x3e是否还有下一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3enext()\x3c\/td\x3e\n\x3ctd\x3e返回下一个元素\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cul\x3e\x3cli\x3e\x3ch3 id=\x22articleHeader2\x22\x3e数组方式\x3c\/h3\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e由于JS语言的特殊性，采用数组的方式来实现队列、栈是非常容易的,js中数组本来就提供了从头部插入、删除元素，从尾部插入、删除元素的功能。这里只需要简单的封装一下(js的弱类型特点，不需要像JAVA那样采用泛型来声明可以储存任意类型的数据，同时，js中数组是不定长的，可以动态扩展)\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e实现\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e队列的数组方式实现，并模拟可迭代功能\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Queue() {\n    this.container = []\n}\nQueue.prototype.enqueue = function (ele) {\n    this.container.push(ele)\n}\nQueue.prototype.dequeue = function () {\n    return this.container.shift()\n}\nQueue.prototype.isEmpty = function () {\n    return !this.container.length\n}\nQueue.prototype.size = function () {\n    return this.container.length\n}\n\nQueue.prototype.iterator = function () {\n    var container = this.container\n    var current = 0\n    return {\n        hasNext: function () {\n            return current !== container.length\n        },\n        next: function () {\n            return container[current\x2b\x2b]\n        }\n    }\n}\n\n用例:\nvar Qu = new Queue()\nQu.enqueue(\x27to\x27)\nQu.enqueue(\x27be\x27)\nQu.enqueue(\x27or\x27)\nQu.enqueue(\x27not\x27)\nQu.dequeue()\nvar iterator = Qu.iterator()\nwhile (iterator.hasNext()) {\n    console.log(iterator.next())\n}\n输出:\nbe\nor\nnot\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = []\n}\nQueue.prototype.enqueue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eele\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.push(ele)\n}\nQueue.prototype.dequeue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.shift()\n}\nQueue.prototype.isEmpty = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.length\n}\nQueue.prototype.size = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.length\n}\n\nQueue.prototype.iterator = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e container = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e current = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3ehasNext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e current !== container.length\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e container[current\x2b\x2b]\n        }\n    }\n}\n\n用例:\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Qu = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Queue()\nQu.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nQu.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nQu.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27or\x27\x3c\/span\x3e)\nQu.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27not\x27\x3c\/span\x3e)\nQu.dequeue()\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e iterator = Qu.iterator()\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (iterator.hasNext()) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(iterator.next())\n}\n输出:\nbe\nor\nnot\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e栈的数组方式实现，并模拟可迭代功能\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 class Stack {\n\n    constructor() {\n        this.container = []\n    }\n\n    push(ele) {\n        this.container.unshift(ele)\n    }\n\n    pop() {\n        return this.container.shift()\n    }\n\n    isEmpty() {\n        return !this.container.length\n    }\n    size() {\n        return this.container.length\n    }\n\n    iterator() {\n        const container = this.container\n        let current = 0\n        return {\n            hasNext: function () {\n                return current !== container.length\n            },\n            next: function () {\n                return container[current\x2b\x2b]\n            }\n        }\n    }\n\n}\n用例:\nvar St = new Stack()\nStack.push(\x27to\x27)\nStack.push(\x27be\x27)\nStack.push(\x27or\x27)\nStack.push(\x27not\x27)\nStack.pop()\nvar iterator = Stack.iterator()\nwhile (iterator.hasNext()) {\n    console.log(iterator.next())\n}\n输出:\nor\nbe\nto\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStack\x3c\/span\x3e \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = []\n    }\n\n    push(ele) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.unshift(ele)\n    }\n\n    pop() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.shift()\n    }\n\n    isEmpty() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.length\n    }\n    size() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.length\n    }\n\n    iterator() {\n        const container = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container\n        let current = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            hasNext: function () {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e current !== container.length\n            },\n            next: function () {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e container[current\x2b\x2b]\n            }\n        }\n    }\n\n}\n用例:\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e St = new Stack()\nStack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nStack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nStack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27or\x27\x3c\/span\x3e)\nStack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27not\x27\x3c\/span\x3e)\nStack.pop()\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e iterator = Stack.iterator()\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (iterator.hasNext()) {\n    console.log(iterator.next())\n}\n输出:\nor\nbe\nto\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3ch3 id=\x22articleHeader3\x22\x3e链表方式实现\x3c\/h3\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一个链表的引用。\x3c\/blockquote\x3e\n\x3cp\x3e在这个定义中，结点是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。\x3c\/p\x3e\n\x3cp\x3e结点表示:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function Node(){\n        this.item=null\n        this.next=null\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.item=\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next=\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造链表：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577586?w=370\x26amp;h=500\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577586?w=370\x26amp;h=500\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在表头插入结点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var oldFirst=first\n    first=new Node()\n    first.next=oldFirst\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e oldFirst=\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e=\x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Node()\n    \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e.next=oldFirst\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从表头删除结点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    first=first.next\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs q\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e    \x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e=\x3cspan class=\x22hljs-built_in\x22\x3efirst\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从表尾插入结点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var oldlast=last\n    lst=new Node()\n    oldlast.next=last\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e    var \x3cspan class=\x22hljs-attr\x22\x3eoldlast=\x3c\/span\x3elast\n    \x3cspan class=\x22hljs-attr\x22\x3elst=\x3c\/span\x3enew \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e()\n    oldlast\x3c\/span\x3e.\x3cspan class=\x22hljs-attr\x22\x3enext=\x3c\/span\x3elast\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接，分别指向不同的方向\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e栈的链表实现\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction Node(item) {\n    this.item = item\n    this.next = null\n}\n\nfunction Stack() {\n    this.count = 0 \/\/元素数量\n    this.first = null \/\/指向栈顶\n}\n\nStack.prototype.isEmpty = function () {\n    return this.first == null\n}\nStack.prototype.size = function () {\n    return this.count\n}\nStack.prototype.push = function (ele) {\n    var oldfirst = this.first\n    var newnode = new Node(ele)\n    newnode.next = oldfirst\n    this.first = newnode\n    this.count\x2b\x2b\n}\nStack.prototype.pop = function () {\n    var ele = this.first.item\n    this.first = this.first.next\n    this.count--\n    return ele\n}\nStack.prototype.iterator = function () {\n    var firstnode = this.first\n    var count = this.count\n    return {\n        hasNext: function () {\n            return  count\n        },\n        next: function () {\n            var ele=firstnode.item\n            firstnode=firstnode.next\n            count--\n            return ele\n        }\n    }\n}\n用例：\nvar stack=new Stack()\nstack.push(\x27to\x27)\nstack.push(\x27be\x27)\nstack.push(\x27or\x27)\nstack.push(\x27not\x27)\nstack.push(\x27to\x27)\nstack.push(\x27be\x27)\nconsole.log(stack.size())\nvar iterator=stack.iterator()\nwhile(iterator.hasNext()){\n    console.log(iterator.next())\n}\n输出：\n6\nbe\nto\nnot\nor\nbe\nto\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\nfunction Node(item) {\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.item\x3c\/span\x3e = item\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.next\x3c\/span\x3e = null\n}\n\nfunction Stack() {\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.count\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/元素数量\x3c\/span\x3e\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e = null \x3cspan class=\x22hljs-comment\x22\x3e\/\/指向栈顶\x3c\/span\x3e\n}\n\nStack\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.isEmpty\x3c\/span\x3e = function () {\n    return this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e == null\n}\nStack\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.size\x3c\/span\x3e = function () {\n    return this\x3cspan class=\x22hljs-selector-class\x22\x3e.count\x3c\/span\x3e\n}\nStack\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.push\x3c\/span\x3e = function (ele) {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e oldfirst = this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e newnode = new Node(ele)\n    newnode\x3cspan class=\x22hljs-selector-class\x22\x3e.next\x3c\/span\x3e = oldfirst\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e = newnode\n    this.count\x2b\x2b\n}\nStack\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.pop\x3c\/span\x3e = function () {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e ele = this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.item\x3c\/span\x3e\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e = this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.next\x3c\/span\x3e\n    this\x3cspan class=\x22hljs-selector-class\x22\x3e.count--\x3c\/span\x3e\n    return ele\n}\nStack\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.iterator\x3c\/span\x3e = function () {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e firstnode = this\x3cspan class=\x22hljs-selector-class\x22\x3e.first\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e count = this\x3cspan class=\x22hljs-selector-class\x22\x3e.count\x3c\/span\x3e\n    return {\n        hasNext: function () {\n            return  count\n        },\n        next: function () {\n            \x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e ele=firstnode\x3cspan class=\x22hljs-selector-class\x22\x3e.item\x3c\/span\x3e\n            firstnode=firstnode\x3cspan class=\x22hljs-selector-class\x22\x3e.next\x3c\/span\x3e\n            count--\n            return ele\n        }\n    }\n}\n用例：\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e stack=new Stack()\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27or\x27\x3c\/span\x3e)\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27not\x27\x3c\/span\x3e)\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nstack.push(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nconsole.log(stack.size())\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e iterator=stack.iterator()\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ewhile\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(iterator.hasNext()\x3c\/span\x3e\x3c\/span\x3e){\n    console.log(iterator.next())\n}\n输出：\n\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\nbe\nto\nnot\nor\nbe\nto\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e队列的链表实现\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e将链表表示为一条从最早插入的元素到最近插入的元素的链表，实例变量first指向队列的开头，last指向队列的结尾。这样，要讲一个元素入列，就将它添加到表尾，要将一个元素出列，就删除表头的结点.\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Node(item) {\n    this.item = item\n    this.next = null\n}\n\nclass Queue {\n\n    constructor() {\n        this.first = null\n        this.last = null\n        this.count = 0\n    }\n\n    isEmpty() {\n        return this.first == null\n    }\n    size() {\n        return this.count\n    }\n    enqueue(item) {\n        const oldlast = this.last\n        const last = new Node(item)\n        this.last = last\n        if (this.isEmpty()) {\n            this.first = last\n        } else {\n            oldlast.next = last\n        }\n        this.count\x2b\x2b\n    }\n    dequeue() {\n        const ele = this.first.item\n        this.first = this.first.next\n        if (this.isEmpty()) {\n            this.last = null\n        }\n        this.count--\n        return ele\n    }\n    iterator() {\n        let firstnode = this.first\n        let count = this.count\n        return {\n            hasNext: function () {\n                return count\n            },\n            next: function () {\n                var ele = firstnode.item\n                firstnode = firstnode.next\n                count--\n                return ele\n            }\n        }\n    }\n}\n用例:\nconst queue=new Queue()\nqueue.enqueue(\x27to\x27)\nqueue.enqueue(\x27be\x27)\nqueue.enqueue(\x27or\x27)\nqueue.enqueue(\x27not\x27)\nqueue.enqueue(\x27to\x27)\nqueue.enqueue(\x27be\x27)\nqueue.dequeue()\nconsole.log(queue.size())\nconst iterator=queue.iterator()\nwhile(iterator.hasNext()){\n    console.log(iterator.next())\n}\n\n输出:\n5\nbe\nor\nnot \nto\nbe\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction Node(item) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.item = item\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.next = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n\n    isEmpty() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    }\n    size() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\n    }\n    enqueue(item) {\n        const oldlast = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last\n        const last = new Node(item)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = last\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isEmpty()) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = last\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            oldlast.next = last\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\x2b\x2b\n    }\n    dequeue() {\n        const ele = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first.item\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first.next\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isEmpty()) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.last = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count--\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ele\n    }\n    iterator() {\n        let firstnode = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.first\n        let count = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            hasNext: function () {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e count\n            },\n            next: function () {\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ele = firstnode.item\n                firstnode = firstnode.next\n                count--\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ele\n            }\n        }\n    }\n}\n用例:\nconst queue=new Queue()\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27or\x27\x3c\/span\x3e)\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27not\x27\x3c\/span\x3e)\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27to\x27\x3c\/span\x3e)\nqueue.enqueue(\x3cspan class=\x22hljs-string\x22\x3e\x27be\x27\x3c\/span\x3e)\nqueue.dequeue()\nconsole.log(queue.size())\nconst iterator=queue.iterator()\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(iterator.hasNext()){\n    console.log(iterator.next())\n}\n\n输出:\n\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\nbe\nor\nnot \nto\nbe\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e在结构化存储数据集时，链表是数组的一种重要的替代方式，两者都非常基础，常常被称为顺序存储和链式存储。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577587?w=1852\x26amp;h=334\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577587?w=1852\x26amp;h=334\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e常见的时间复杂度的级别\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577588?w=577\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577588?w=577\x26amp;h=400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3ch3 id=\x22articleHeader5\x22\x3ethreeSum问题分析\x3c\/h3\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e问题描述：\x3c\/p\x3e\n\x3cblockquote\x3e假设所有整数都不相同，统计一个数组中所有和为0的三整数元组的数量\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e最基本的实现,暴力算法\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function threesum(arr){\n    var N=arr.length\n    var count=0\n    for(var i=0;i\x3cN;i\x2b\x2b){\n        for(var j=i\x2b1;j\x3cN;j\x2b\x2b){\n            for(var k=j\x2b1;k\x3cN;k\x2b\x2b){\n                if(arr[i]\x2barr[j]\x2barr[k]==0){\n                    count\x2b\x2b\n                }\n            }\n        }\n    }\n    return count\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3efunction threesum(arr){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eN\x3c\/span\x3e=arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecount\x3c\/span\x3e=0\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=0;i\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3eN\x3c\/span\x3e;i\x2b\x2b){\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=i\x2b1;j\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3eN\x3c\/span\x3e;j\x2b\x2b){\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k=j\x2b1;k\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3eN\x3c\/span\x3e;k\x2b\x2b){\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr[i]\x2barr[j]\x2barr[k]==0){\n                    \x3cspan class=\x22hljs-keyword\x22\x3ecount\x3c\/span\x3e\x2b\x2b\n                }\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecount\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e分析：\x3c\/p\x3e\n\x3cp\x3e执行最频繁的指令决定了程序执行的总时间，对上面的threesum算法，最频繁的部分就是if语句判断，它套在三个for循环内，对于给定的N，if语句执行次数为\x3ccode\x3eN*(N-1)*(N-2)\/6=N^3\/6-N^2\/2\x2bN\/3\x3c\/code\x3e,当N很大时，首项后的其他项都相对较小可以忽略，所以if语句的执行次数约等于\x3ccode\x3eN^3\/6\x3c\/code\x3e,表示为(~N^3\/6)\x3c\/p\x3e\n\x3cp\x3e所以暴力算法的threesum执行用时的增长数量级为\x3ccode\x3eN^3\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e优化\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e学习程序的增长数量级的一个重要动力是为了帮助我们为同一个问题设计更快的算法\x3c\/blockquote\x3e\n\x3cp\x3e改进后的算法的思路是：当且仅当-( a[i]\x2ba[j] )在数组中( 不是a[i]也不是a[j] )时,整数对( a[i]和a[j] )为某个和为0的三元组的一部分。要解决这个问题，首先对数组进行排序(为二分查找做准备),然后对数组中的每个a[i]\x2ba[j],使用二分查找算法对-(a[i]\x2ba[j])进行二分查找，如果结果为k，且k\x26gt;j,则count加一。\x3c\/p\x3e\n\x3cp\x3e下面中的代码会将数组排序并进行N*(N-1)\/2次二分查找，每次查找所需的时间都和logN成正比，因此总的运行时间和N^2logN成正比。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/二分查找\nfunction binarySearch(key, arr) {\n    var start = 0\n    var end = arr.length - 1\n    while (start \x3c= end) {\n        var mid = start \x2b Math.floor((end - start) \/ 2)\n        if (key \x3c arr[mid]) {\n            end = mid - 1\n        } else if (key \x3e arr[mid]) {\n            start = mid \x2b 1\n        } else {\n            return mid\n        }\n    }\n    return -1\n}\n\nfunction threesum(arr) {\n    var N = arr.length\n    var count = 0\n    arr = arr.sort(function (a, b) {\n        return a \x3e b ? 1 : -1\n    })\n    for (var i = 0; i \x3c N; i\x2b\x2b) {\n        for (var j = i \x2b 1; j \x3c N; j\x2b\x2b) {\n            if (binarySearch(-arr[i] - arr[j], arr) \x3e j) {\n                count\x2b\x2b\n            }\n        }\n    }\n    return count\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/二分查找\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebinarySearch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekey, arr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e start = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e end = arr.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (start \x26lt;= end) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mid = start \x2b \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor((end - start) \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26lt; arr[mid]) {\n            end = mid - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (key \x26gt; arr[mid]) {\n            start = mid \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mid\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethreesum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e N = arr.length\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    arr = arr.sort(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x26gt; b ? \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; N; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26lt; N; j\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (binarySearch(-arr[i] - arr[j], arr) \x26gt; j) {\n                count\x2b\x2b\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e count\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e增长数量级的分类\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577589?w=1822\x26amp;h=1064\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577589?w=1822\x26amp;h=1064\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e案例研究:union-find算法\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e动态连通性问题\x3c\/h3\x3e\n\x3cp\x3e首先我们详细说明一下问题\x3c\/p\x3e\n\x3cblockquote\x3e问题的输入是一列整数对，对于一对整数p,q,如果p,q不相连，则将p,q连接\x3c\/blockquote\x3e\n\x3cp\x3e所谓的相连:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e[x] 自反性: p与p是相连的\x3c\/li\x3e\n\x3cli\x3e[x] 对称性: 若p与q是相连的,则q与p是相连的\x3c\/li\x3e\n\x3cli\x3e[x] 传递性: 若p与q是相连的,且q和r相连，则p与r是相连的\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们假设相连的整数构成了一个“集合”,对于新的连接，就是在将新的元素加入“集合”来构成更大的“集合”,若判断p,q是否相连，只要判断p,q是否在同一个“集合”中即可。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577590?w=146\x26amp;h=300\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577590?w=146\x26amp;h=300\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e这里我们应用动态连通性来处理计算机网络中的主机之间的连通关系\x3cp\x3e输入中的整数表示的可能是一个大型计算机网络中的计算机，而整数对则表示网络中的连接，这个程序能够判定我们是否需要在p和q之间架设一条新的连接来通信，或是我们可以通过已有的连接在两者之间建立通信线路。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这里我们使用网络方面的术语，将\x3ccode\x3e输入的整数\x3c\/code\x3e称为\x3ccode\x3e触点\x3c\/code\x3e，将形成的\x3ccode\x3e集合\x3c\/code\x3e称为\x3ccode\x3e连通分量\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e分析\x3c\/h3\x3e\n\x3cp\x3e为了说明问题，我们设计一份API来封装所需的基本操作:初始化、连接两个触点、判断包含某个触点的分量、判断两个触点是否存在于同一个分量之中以及返回所有分量的数量\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eUF\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eUF(N)\x3c\/td\x3e\n\x3ctd\x3e以整数标识（0到N-1）初始化N个触点\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eunion(p,q)\x3c\/td\x3e\n\x3ctd\x3e连接触点p、q\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3efind(p)\x3c\/td\x3e\n\x3ctd\x3e返回p所在分量的标识符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3econnected(p,q)\x3c\/td\x3e\n\x3ctd\x3e判断p,q是否存在于同一个连通分量中\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ecount()\x3c\/td\x3e\n\x3ctd\x3e连通分量的数量\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e我们看到，为解决动态连通性问题设计算法的任务转化成了实现这份API，所有的实现都应该\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e[x] 定义一种数据结构表示已知的连接\x3c\/p\x3e\n\x3cp\x3e[x] 基于此数据结构实现高效的union()、find()、connected()、count()\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e我们用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量，我们将使用分量中的某个触点的名称作为分量的标识符\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e一开始，我们有N个分量，每个触点都构成了一个只含有自己的分量，因此我们将id[i]的值设为i。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UF {\n\n    \/**\n     * \n     * @param {number} N \n     *\/\n    constructor(N) {\n        this.id = new Array(N).fill(0).map((x, index) =\x3e index)\n        this.count = 0\n    }\n\n    count(){\n        return this.count\n    }\n\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    connected(p,q){\n        return this.find(p)===this.find(q)\n    }\n\n    \/** \n     * @param {number} p \n     *\/\n    find(p){\n\n    }\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    union(p,q){\n\n    }\n\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUF\x3c\/span\x3e \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} N \n     *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(N) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = new Array(N).fill(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e).map((x, index) =\x26gt; index)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n\n    count(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    connected(p,q){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(p)===\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(q)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     *\/\x3c\/span\x3e\n    find(p){\n\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    union(p,q){\n\n    }\n\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3efind()和union()是实现的重点,我们将讨论三种不同的实现，它们均根据以触点为索引的id[]数组来确定两个触点是否存在于相同的连通分量中\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e实现\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3equick-find算法\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e思想是:保证当且仅当\x3ccode\x3eid[p]==id[q]\x3c\/code\x3e时，p和q是连通的。换句话说，在同一个连通分量中的所有触点在id[]数组中的值都一样。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/** \n     * @param {number} p \n     *\/\n    find(p){\n        return this.id[p]\n    }\n\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    union(p,q){\n        var pId=this.find(p)\n        var qId=this.find(q)\n        if(pId==qId) return\n        this.id.forEach(x=\x3e{\n            if(id[x]==pId){\n                id[x]==qId\n            }\n        })\n        this.count--\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/** \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     *\/\x3c\/span\x3e\n    find(p){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id[p]\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    union(p,q){\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pId=\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(p)\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e qId=\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(q)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(pId==qId) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id.forEach(x=\x26gt;{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(id[x]==pId){\n                id[x]==qId\n            }\n        })\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count--\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e复杂度分析:\x3c\/p\x3e\n\x3cp\x3efind()操作很快，它只访问id[]数组一次,但union()会整个扫描id[]数组\x3c\/p\x3e\n\x3cp\x3e在union()中,find p、q会访问2次数组，for循环及赋值操作会访问数组 N\x2b1 ~ N\x2b（N-1）次。\x3c\/p\x3e\n\x3cp\x3e所以union()方法访问数组的次数在(2\x2bN\x2b1) ~(2\x2bN\x2b(N-1)) 即 N\x2b3 ~ 2N\x2b1 次之间\x3c\/p\x3e\n\x3cp\x3e假设我们使用quick-union算法来解决动态连通性问题并最后只得到一个连通分量，则至少需要调用(N-1)次 union(),\x3cbr\x3e即（N\x2b3）\x3cem\x3e（N-1） ~（2N\x2b1）\x3c\/em\x3e（N-1）次数组访问\x3c\/p\x3e\n\x3cp\x3e所以此算法的时间复杂度是\x3ccode\x3e平方级别的\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3equick-union算法\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e此算法的重点是提高union()方法的速度，它也是基于相同的数据结构--以触点作为索引的id[]数组，但我们赋予这些值的意义不同，我们需要用他们来定义更加复杂的数据结构:\x3c\/p\x3e\n\x3cblockquote\x3e每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可以说是它自己，即根触点）--我们将这种联系称为链接。\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/** \n     * 找到根触点，即分量的标识符\n     * @param {number} p \n     *\/\n    find(p) {\n        while (p !== this.id[p]) p = this.id[p]\n        return p\n    }\n\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    union(p, q) {\n        let pRoot = this.find(p)\n        let qRoot = this.find(q)\n        if (pRoot == qRoot) return\n        id[pRoot] = qRoot\n        this.count--\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/** \n     * 找到根触点，即分量的标识符\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     *\/\x3c\/span\x3e\n    find(p) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (p !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id[p]) p = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id[p]\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e p\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    union(p, q) {\n        let pRoot = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(p)\n        let qRoot = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(q)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (pRoot == qRoot) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        id[pRoot] = qRoot\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count--\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577591?w=588\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577591?w=588\x26amp;h=400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如图所示：id[]数组用父链接的形式表示了一片森林\x3c\/p\x3e\n\x3cp\x3e复杂度分析：\x3c\/p\x3e\n\x3cblockquote\x3e一棵树的大小是它的节点的数量，树中一个节点的深度是它到根节点路径上的链接数\x3c\/blockquote\x3e\n\x3cp\x3equick-union算法的分析依赖于输入的特点，find()访问数组的次数为1加上给定的触点所对应的节点的深度的2倍。\x3c\/p\x3e\n\x3cp\x3e在最好的情况下，find()只需要访问数组1次就能够得到当前触点所在分量的标识符\x3c\/p\x3e\n\x3cp\x3e在最坏的情况下，find()需要1 \x2b 2*(N-1) 即 2N-1 次数组访问\x3c\/p\x3e\n\x3cp\x3e如下图所示\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577592?w=446\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577592?w=446\x26amp;h=400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e对最坏的情况，处理N对整数所需的所有find()操作访问数组的总次数为:\x3c\/p\x3e\n\x3cp\x3e等差数列 (1\x2b 2N-1) *N \/2 = N^2,即\x3ccode\x3e在最差的情况下，quick-union算的复杂度为平方级的\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3eunion()访问数组的次数是两次find()操作，(如果union中给定的两个触点在不同的分量还要加1)\x3c\/p\x3e\n\x3cp\x3e由此，我们构造了一个最佳情况的输入使得算法的运行时间是线性的，最差情况的输入使得算法的运行时间是平方级的。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e加权 quick-union算法 (控制树的深度)\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e与其在union()中随意将一颗树连接到另一棵树，我们现在会记录每一颗树的大小并总是将较小的树连接到较大的树上。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577593?w=588\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577593?w=588\x26amp;h=400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UF {\n\n    \/**\n     * \n     * @param {number} N \n     *\/\n    constructor(N) {\n        this.id = new Array(N).fill(0).map((x, index) =\x3e index)\n        \/\/各个根节点所对应的分量的大小\n        this.sz = new Array(N).fill(1)\n        this.count = 0\n    }\n\n    count() {\n        return this.count\n    }\n\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    connected(p, q) {\n        return this.find(p) === this.find(q)\n    }\n\n    \/** \n     * 找到根触点，即分量的标识符\n     * @param {number} p \n     *\/\n    find(p) {\n        while (p !== this.id[p]) p = this.id[p]\n        return p\n    }\n    \/**\n     * \n     * @param {number} p \n     * @param {number} q \n     *\/\n    union(p, q) {\n        let pRoot = this.find(p)\n        let qRoot = this.find(q)\n        if (pRoot == qRoot) return\n        \/\/将小树连接到大树上\n        if (sz[pRoot] \x3c sz[qRoot]) {\n            id[p] = qRoot\n            sz[qRoot] \x2b= sz[pRoot]\n        } else {\n            id[q] = pRoot\n            sz[pRoot] \x2b= sz[qRoot]\n        }\n        this.count--\n    }\n\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUF\x3c\/span\x3e \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} N \n     *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(N) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = new Array(N).fill(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e).map((x, index) =\x26gt; index)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/各个根节点所对应的分量的大小\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sz = new Array(N).fill(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n\n    count() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    connected(p, q) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(p) === \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(q)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** \n     * 找到根触点，即分量的标识符\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     *\/\x3c\/span\x3e\n    find(p) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (p !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id[p]) p = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id[p]\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e p\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} p \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {number} q \n     *\/\x3c\/span\x3e\n    union(p, q) {\n        let pRoot = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(p)\n        let qRoot = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.find(q)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (pRoot == qRoot) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/将小树连接到大树上\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sz[pRoot] \x26lt; sz[qRoot]) {\n            id[p] = qRoot\n            sz[qRoot] \x2b= sz[pRoot]\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            id[q] = pRoot\n            sz[pRoot] \x2b= sz[qRoot]\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count--\n    }\n\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e复杂度分析：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011577594?w=271\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011577594?w=271\x26amp;h=400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如图所示，在最坏的情况下，其中将要被归并的树的大小总是相等的，它们均含有2^n个节点（树的高度为n）,当我们归并两个2^n个节点的树时，得到的树的高度增加到n\x2b1。\x3c\/p\x3e\n\x3cp\x3e对于加权quick-union算法和N个触点，在最坏的情况下，find() union()的运行时间的增长数量级为logN\x3c\/p\x3e\n\x3cblockquote\x3e加权quick-union算法处理N个触点和M条连接时最多访问数组cMlgN次，这与quick-find需要MN形成了鲜明对比\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e通过《算法》第一章我学习了\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e[x] 基本的数据类型栈、队列\x3c\/li\x3e\n\x3cli\x3e[x] 通过数组、链表来构造队列和栈\x3c\/li\x3e\n\x3cli\x3e[x] 数组和链表是两种基本的数据结构\x3c\/li\x3e\n\x3cli\x3e[x] 时间复杂度的分析和常见的复杂度增长数量级\x3c\/li\x3e\n\x3cli\x3e[x] 二分查找算法\x3c\/li\x3e\n\x3cli\x3e[x] 对一个问题寻求解决方案时，要确定好基本的数据结构，好的数据结构是构造高效算法的前提\x3c\/li\x3e\n\x3cli\x3e[x] 动态连通性问题\x3c\/li\x3e\n\x3cli\x3e[x] 动态连通性问题的解决方案，并不断优化算法\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>《算法》第一章学习笔记js实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011577583">https://segmentfault.com/a/1190000011577583</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fmj1x7uyadw/" target="_blank">https://alili.tech/archive/fmj1x7uyadw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>