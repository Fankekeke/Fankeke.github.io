<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="30分钟理解GraphQL核心概念"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>30分钟理解GraphQL核心概念 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/g8x5xffigy9/",
				"appid": "1613049289050283", 
				"title": "30分钟理解GraphQL核心概念 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/dtup9svmqyt/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zm2u9iewb9d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&text=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&text=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&title=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&is_video=false&description=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&title=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&title=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&title=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg8x5xffigy9%2f&title=30%e5%88%86%e9%92%9f%e7%90%86%e8%a7%a3GraphQL%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">30分钟理解GraphQL核心概念</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h2\x3e\n\x3cp\x3e在上一篇文章\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000013961872\x22\x3eRPC vs REST vs GraphQL\x3c\/a\x3e中，对于这三者的优缺点进行了比较宏观的对比，而且我们也会发现，一般比较简单的项目其实并不需要GraphQL，但是我们仍然需要对新的技术有一定的了解和掌握，在新技术普及时才不会措手不及。\x3c\/p\x3e\n\x3cp\x3e这篇文章主要介绍一些我接触GraphQL的这段时间，觉得需要了解的比较核心的概念，比较适合一下人群：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e听说过GraphQL的读者，想深入了解一下\x3c\/li\x3e\n\x3cli\x3e想系统地学习GraphQL的读者\x3c\/li\x3e\n\x3cli\x3e正在调研GraphQL技术的读者\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这些概念并不局限于服务端或者是客户端，如果你熟悉这些概念，在接触任意使用GraphQL作为技术背景的库或者框架时，都可以通过文档很快的上手。\x3c\/p\x3e\n\x3cp\x3e如果你已经GraphQL应用于了实际项目中，那么这篇文章可能不适合你，因为其中并没有包含一些实践中的总结和经验，关于实践的东西我会在之后再单另写一篇文章总结。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e什么是GraphQL\x3c\/h2\x3e\n\x3cp\x3e介绍GraphQL是什么的文章网上一搜一大把，篇幅有长有短，但是从最核心上讲，它是一种查询语言，再进一步说，是一种API查询语言。\x3c\/p\x3e\n\x3cp\x3e这里可能有的人就会说，什么？API还能查？API不是用来调用的吗？是的，这正是GraphQL的强大之处，引用官方文档的一句话：\x3c\/p\x3e\n\x3cblockquote\x3eask exactly what you want.\x3c\/blockquote\x3e\n\x3cp\x3e我们在使用REST接口时，接口返回的数据格式、数据类型都是后端预先定义好的，如果返回的数据格式并不是调用者所期望的，作为前端的我们可以通过以下两种方式来解决问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e和后端沟通，改接口（更改数据源）\x3c\/li\x3e\n\x3cli\x3e自己做一些适配工作（处理数据源）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一般如果是个人项目，改后端接口这种事情可以随意搞，但是如果是公司项目，改后端接口往往是一件比较敏感的事情，尤其是对于三端（web、andriod、ios）公用同一套后端接口的情况。大部分情况下，均是按第二种方式来解决问题的。\x3c\/p\x3e\n\x3cp\x3e因此如果接口的返回值，可以通过某种手段，从静态变为动态，即调用者来声明接口返回什么数据，很大程度上可以进一步解耦前后端的关联。\x3c\/p\x3e\n\x3cp\x3e在GraphQL中，我们通过预先定义一张\x3ccode\x3eSchema\x3c\/code\x3e和声明一些\x3ccode\x3eType\x3c\/code\x3e来达到上面提及的效果，我们需要知道：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e对于数据模型的抽象是通过Type来描述的\x3c\/li\x3e\n\x3cli\x3e对于接口获取数据的逻辑是通过Schema来描述的\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这么说可能比较抽象，我们一个一个来说明。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eType\x3c\/h2\x3e\n\x3cp\x3e对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。\x3c\/p\x3e\n\x3cp\x3eGraphQL的Type简单可以分为两种，一种叫做\x3ccode\x3eScalar Type(标量类型)\x3c\/code\x3e，另一种叫做\x3ccode\x3eObject Type(对象类型)\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eScalar Type\x3c\/h3\x3e\n\x3cp\x3eGraphQL中的内建的标量包含，\x3ccode\x3eString\x3c\/code\x3e、\x3ccode\x3eInt\x3c\/code\x3e、\x3ccode\x3eFloat\x3c\/code\x3e、\x3ccode\x3eBoolean\x3c\/code\x3e、\x3ccode\x3eEnum\x3c\/code\x3e，对于熟悉编程语言的人来说，这些都应该很好理解。\x3c\/p\x3e\n\x3cp\x3e值得注意的是，GraphQL中可以通过\x3ccode\x3eScalar\x3c\/code\x3e声明一个新的标量，比如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eprisma（一个使用GraphQL来抽象数据库操作的库）中，还有\x3ccode\x3eDateTime\x3c\/code\x3e和\x3ccode\x3eID\x3c\/code\x3e这两个标量分别代表日期格式和主键\x3c\/li\x3e\n\x3cli\x3e在使用GraphQL实现文件上传接口时，需要声明一个\x3ccode\x3eUpload\x3c\/code\x3e标量来代表要上传的文件\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e总之，我们只需要记住，标量是GraphQL类型系统中最小的颗粒，关于它在GraphQL解析查询结果时，我们还会再提及它。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eObject Type\x3c\/h3\x3e\n\x3cp\x3e仅有标量是不够的抽象一些复杂的数据模型的，这时候我们需要使用对象类型，举个例子(先忽略语法，仅从字面上看)：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type Article {\n  id: ID\n  text: String\n  isPublished: Boolean\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eArticle\x3c\/span\x3e {\n  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e\n  text: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e\n  isPublished: \x3cspan class=\x22hljs-type\x22\x3eBoolean\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码，就声明了一个\x3ccode\x3eArticle\x3c\/code\x3e类型，它有3个Field，分别是\x3ccode\x3eID\x3c\/code\x3e类型的id，\x3ccode\x3eString\x3c\/code\x3e类型的text和\x3ccode\x3eBoolean\x3c\/code\x3e类型的isPublished。\x3c\/p\x3e\n\x3cp\x3e对于对象类型的Field的声明，我们一般使用标量，但是我们也可以使用另外一个对象类型，比如如果我们再声明一个新的\x3ccode\x3eUser\x3c\/code\x3e类型，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type User {\n  id: ID\n  name: String\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eUser\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e{\n  id\x3c\/span\x3e: ID\n  name: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时我们就可以稍微的更改一下关于\x3ccode\x3eArticle\x3c\/code\x3e类型的声明代码，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type Article {\n  id: ID\n  text: String\n  isPublished: Boolean\n  author: User\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eArticle\x3c\/span\x3e {\n  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e\n  text: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e\n  isPublished: \x3cspan class=\x22hljs-type\x22\x3eBoolean\x3c\/span\x3e\n  author: \x3cspan class=\x22hljs-type\x22\x3eUser\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eArticle\x3c\/code\x3e新增的\x3ccode\x3eauthor\x3c\/code\x3e的Field是\x3ccode\x3eUser\x3c\/code\x3e类型, 代表这篇文章的作者。\x3c\/p\x3e\n\x3cp\x3e总之，我们通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eType Modifier\x3c\/h3\x3e\n\x3cp\x3e关于类型，还有一个较重要的概念，即类型修饰符，当前的类型修饰符有两种，分别是\x3ccode\x3eList\x3c\/code\x3e和\x3ccode\x3eRequired \x3c\/code\x3e，它们的语法分别为\x3ccode\x3e[Type]\x3c\/code\x3e和\x3ccode\x3eType!\x3c\/code\x3e, 同时这两者可以互相组合，比如\x3ccode\x3e[Type]!\x3c\/code\x3e或者\x3ccode\x3e[Type!]\x3c\/code\x3e或者\x3ccode\x3e[Type!]!\x3c\/code\x3e(请仔细看这里\x3ccode\x3e!\x3c\/code\x3e的位置)，它们的含义分别为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e列表本身为必填项，但其内部元素可以为空\x3c\/li\x3e\n\x3cli\x3e列表本身可以为空，但是其内部元素为必填\x3c\/li\x3e\n\x3cli\x3e列表本身和内部元素均为必填\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们进一步来更改上面的例子，假如我们又声明了一个新的\x3ccode\x3eComment\x3c\/code\x3e类型，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type Comment {\n  id: ID!\n  desc: String,\n  author: User!\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eComment\x3c\/span\x3e {\n  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!\n  desc: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e,\n  author: \x3cspan class=\x22hljs-type\x22\x3eUser\x3c\/span\x3e!\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会发现这里的\x3ccode\x3eID\x3c\/code\x3e有一个\x3ccode\x3e!\x3c\/code\x3e，它代表这个Field是必填的，再来更新\x3ccode\x3eArticle\x3c\/code\x3e对象，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type Article {\n  id: ID!\n  text: String\n  isPublished: Boolean\n  author: User!\n  comments: [Comment!]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eArticle\x3c\/span\x3e {\n  id: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!\n  text: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e\n  isPublished: \x3cspan class=\x22hljs-type\x22\x3eBoolean\x3c\/span\x3e\n  author: \x3cspan class=\x22hljs-type\x22\x3eUser\x3c\/span\x3e!\n  comments: [\x3cspan class=\x22hljs-type\x22\x3eComment\x3c\/span\x3e!]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们这里的作出的更改如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eid字段改为必填\x3c\/li\x3e\n\x3cli\x3eauthor字段改为必填\x3c\/li\x3e\n\x3cli\x3e新增了comments字段，它的类型是一个元素为Comment类型的List类型\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最终的\x3ccode\x3eArticle\x3c\/code\x3e类型，就是GraphQL中关于文章这个数据模型，一个比较简单的类型声明。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eSchema\x3c\/h2\x3e\n\x3cp\x3e现在我们开始介绍\x3ccode\x3eSchema\x3c\/code\x3e，我们之前简单描述了它的作用，即它是用来描述\x3ccode\x3e对于接口获取数据逻辑\x3c\/code\x3e的，但这样描述仍然是有些抽象的，我们其实不妨把它当做REST架构中每个独立资源的\x3ccode\x3euri\x3c\/code\x3e来理解它，只不过在GraphQL中，我们用Query来描述资源的获取方式。因此，我们可以将\x3ccode\x3eSchema\x3c\/code\x3e理解为多个Query组成的一张表。\x3c\/p\x3e\n\x3cp\x3e这里又涉及一个新的概念\x3ccode\x3eQuery\x3c\/code\x3e，GraphQL中使用\x3ccode\x3eQuery\x3c\/code\x3e来抽象数据的查询逻辑，当前标准下，有三种查询类型，分别是\x3cem\x3equery（查询）\x3c\/em\x3e、\x3cem\x3emutation（更改）\x3c\/em\x3e和\x3cem\x3esubscription（订阅）\x3c\/em\x3e。 \x3c\/p\x3e\n\x3cp\x3eNote: 为了方便区分，\x3ccode\x3eQuery\x3c\/code\x3e特指GraphQL中的查询（包含三种类型），\x3ccode\x3equery\x3c\/code\x3e指GraphQL中的查询类型（仅指查询类型）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eQuery\x3c\/h3\x3e\n\x3cp\x3e上面所提及的3中基本查询类型是作为\x3ccode\x3eRoot Query（根查询）\x3c\/code\x3e存在的，对于传统的CRUD项目，我们只需要前两种类型就足够了，第三种是针对当前日趋流行的\x3ccode\x3ereal-time\x3c\/code\x3e应用提出的。\x3c\/p\x3e\n\x3cp\x3e我们按照字面意思来理解它们就好，如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3equery（查询）：当获取数据时，应当选取Query类型\x3c\/li\x3e\n\x3cli\x3emutation（更改）：当尝试修改数据时，应当使用mutation类型\x3c\/li\x3e\n\x3cli\x3esubscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e仍然以一个例子来说明。\x3c\/p\x3e\n\x3cp\x3e首先，我们分别以REST和GraphQL的角度，以\x3ccode\x3eArticle\x3c\/code\x3e为数据模型，编写一系列CRUD的接口，如下：\x3c\/p\x3e\n\x3cp\x3eRest 接口\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22GET \/api\/v1\/articles\/\nGET \/api\/v1\/article\/:id\/\nPOST \/api\/v1\/article\/\nDELETE \/api\/v1\/article\/:id\/\nPATCH \/api\/v1\/article\/:id\/\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3eGET \x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/articles\/\x3c\/span\x3e\nGET \x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/article\/\x3c\/span\x3e:id\/\nPOST \x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/article\/\x3c\/span\x3e\nDELETE \x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/article\/\x3c\/span\x3e:id\/\nPATCH \x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/article\/\x3c\/span\x3e:id\/\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eGraphQL Query\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22query {\n  articles(): [Article!]!\n  article(id: Int): Article!\n}\n\nmutation {\n  createArticle(): Article!\n  updateArticle(id: Int): Article!\n  deleteArticle(id: Int): Article!\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3equery\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-selector-tag\x22\x3earticles\x3c\/span\x3e(): \x3cspan class=\x22hljs-selector-attr\x22\x3e[Article!]\x3c\/span\x3e!\n  \x3cspan class=\x22hljs-selector-tag\x22\x3earticle\x3c\/span\x3e(\x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e: Int): \x3cspan class=\x22hljs-selector-tag\x22\x3eArticle\x3c\/span\x3e!\n}\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3emutation\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-selector-tag\x22\x3ecreateArticle\x3c\/span\x3e(): \x3cspan class=\x22hljs-selector-tag\x22\x3eArticle\x3c\/span\x3e!\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eupdateArticle\x3c\/span\x3e(\x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e: Int): \x3cspan class=\x22hljs-selector-tag\x22\x3eArticle\x3c\/span\x3e!\n  \x3cspan class=\x22hljs-selector-tag\x22\x3edeleteArticle\x3c\/span\x3e(\x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e: Int): \x3cspan class=\x22hljs-selector-tag\x22\x3eArticle\x3c\/span\x3e!\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对比我们较熟悉的REST的接口我们可以发现，GraphQL中是按根查询的类型来划分Query职能的，同时还会明确的声明每个Query所返回的数据类型，这里的关于类型的语法和上一章节中是一样的。需要注意的是，我们所声明的任何\x3ccode\x3eQuery\x3c\/code\x3e都必须是\x3ccode\x3eRoot Query\x3c\/code\x3e的子集，这和GraphQL内部的运行机制有关。\x3c\/p\x3e\n\x3cp\x3e例子中我们仅仅声明了Query类型和Mutation类型，如果我们的应用中对于评论列表有\x3ccode\x3ereal-time\x3c\/code\x3e的需求的话，在REST中，我们可能会直接通过长连接或者通过提供一些带验证的获取长连接url的接口，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22POST \/api\/v1\/messages\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ePOST \x3cspan class=\x22hljs-regexp\x22\x3e\/api\/\x3c\/span\x3ev1\x3cspan class=\x22hljs-regexp\x22\x3e\/messages\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之后长连接会将新的数据推送给我们，在GraphQL中，我们则会以更加声明式的方式进行声明，如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22subscription {\n  updatedArticle() {\n    mutation\n    node {\n        comments: [Comment!]!\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3esubscription {\n  updatedArticle() {\n    mutation\n    \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e{\n        comments\x3c\/span\x3e: [Comment!]!\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们不必纠结于这里的语法，因为这篇文章的目的不是让你在30分钟内学会GraphQL的语法，而是理解的它的一些核心概念，比如这里，我们就声明了一个订阅Query，这个Query会在有新的Article被创建或者更新时，推送新的数据对象。当然，在实际运行中，其内部实现仍然是建立于长连接之上的，但是我们能够以更加声明式的方式来进行声明它。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eResolver\x3c\/h3\x3e\n\x3cp\x3e如果我们仅仅在Schema中声明了若干Query，那么我们只进行了一半的工作，因为我们并没有提供相关Query所返回数据的逻辑。为了能够使GraphQL正常工作，我们还需要再了解一个核心概念，\x3ccode\x3eResolver（解析函数）\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eGraphQL中，我们会有这样一个约定，Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来，举个例子，比如关于\x3ccode\x3earticles(): [Article!]!\x3c\/code\x3e这个Query, 它的Resolver的名字必然叫做\x3ccode\x3earticles\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在介绍Resolver之前，是时候从整体上了解下GraphQL的内部工作机制了，假设现在我们要对使用我们已经声明的\x3ccode\x3earticles\x3c\/code\x3e的Query，我们可能会写以下查询语句（同样暂时忽略语法）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Query {\n  articles {\n       id\n       author {\n           name\n       }\n       comments {\n      id\n      desc\n      author\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nginx\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3eQuery\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-section\x22\x3earticles\x3c\/span\x3e {\n       \x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e\n       author {\n           \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e\n       }\n       comments {\n      \x3cspan class=\x22hljs-attribute\x22\x3eid\x3c\/span\x3e\n      desc\n      author\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eGraphQL在解析这段查询语句时会按如下步骤（简略版）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e首先进行第一层解析，当前\x3ccode\x3eQuery\x3c\/code\x3e的\x3ccode\x3eRoot Query\x3c\/code\x3e类型是\x3ccode\x3equery\x3c\/code\x3e，同时需要它的名字是\x3ccode\x3earticles\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e之后会尝试使用\x3ccode\x3earticles\x3c\/code\x3e的\x3ccode\x3eResolver\x3c\/code\x3e获取解析数据，第一层解析完毕\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e之后对第一层解析的返回值，进行第二层解析，当前\x3ccode\x3earticles\x3c\/code\x3e还包含三个子\x3ccode\x3eQuery\x3c\/code\x3e，分别是\x3ccode\x3eid\x3c\/code\x3e、\x3ccode\x3eauthor\x3c\/code\x3e和\x3ccode\x3ecomments\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eid在Author类型中为标量类型，解析结束\x3c\/li\x3e\n\x3cli\x3eauthor在Author类型中为对象类型User，尝试使用\x3ccode\x3eUser\x3c\/code\x3e的\x3ccode\x3eResolver\x3c\/code\x3e获取数据，当前field解析完毕\x3c\/li\x3e\n\x3cli\x3e之后对第二层解析的返回值，进行第三层解析，当前\x3ccode\x3eauthor\x3c\/code\x3e还包含一个\x3ccode\x3eQuery\x3c\/code\x3e, \x3ccode\x3ename\x3c\/code\x3e，由于它是标量类型，解析结束\x3c\/li\x3e\n\x3cli\x3ecomments同上...\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们可以发现，GraphQL大体的解析流程就是遇到一个Query之后，尝试使用它的Resolver取值，之后再对返回值进行解析，这个过程是递归的，直到所解析Field的类型是\x3ccode\x3eScalar Type（标量类型）\x3c\/code\x3e为止。解析的整个过程我们可以把它想象成一个很长的Resolver Chain（解析链）。\x3c\/p\x3e\n\x3cp\x3e这里对于GraphQL的解析过程只是很简单的概括，其内部运行机制远比这个复杂，当然这些对于使用者是黑盒的，我们只需要大概了解它的过程即可。\x3c\/p\x3e\n\x3cp\x3eResolver本身的声明在各个语言中是不一样的，因为它代表数据获取的具体逻辑。它的函数签名(以js为例子)如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function(parent, args, ctx, info) {\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(parent, args, ctx, info)\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中的参数的意义如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eparent: 当前上一个Resolver的返回值\x3c\/li\x3e\n\x3cli\x3eargs: 传入某个Query中的函数（比如上面例子中\x3ccode\x3earticle(id: Int)\x3c\/code\x3e中的\x3ccode\x3eid\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3ectx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\x3c\/li\x3e\n\x3cli\x3einfo: 当前Query的AST对象\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e值得注意的是，Resolver内部实现对于GraphQL完全是黑盒状态。这意味着Resolver如何返回数据、返回什么样的数据、从哪返回数据，完全取决于Resolver本身，基于这一点，在实际中，很多人往往把GraphQL作为一个中间层来使用，数据的获取通过Resolver来封装，内部数据获取的实现可能基于RPC、REST、WS、SQL等多种不同的方式。同时，基于这一点，当你在对一些未使用GraphQL的系统进行迁移时（比如REST），可以很好的进行增量式迁移。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e大概就这么多，首先感谢你耐心的读到这里，虽然题目是30分钟熟悉GraphQL核心概念，但是可能已经超时了，不过我相信你对GraphQL中的核心概念已经比较熟悉了。但是它本身所涉及的东西远远比这个丰富，同时它还处于飞速的发展中。\x3c\/p\x3e\n\x3cp\x3e最后我尝试根据这段时间的学习GraphQL的经验，提供一些进一步学习和了解GraphQL的方向和建议，仅供参考：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e想进一步了解GraphQL本身\x3c\/h3\x3e\n\x3cp\x3e我建议再仔细去官网，读一下官方文档，如果有兴趣的话，看看GraphQL的spec也是极好的。这篇文章虽然介绍了核心概念，但是其他一些概念没有涉及，比如Union、Interface、Fragment等等，这些概念均是基于核心概念之上的，在了解核心概念后，应当会很容易理解。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e偏向服务端\x3c\/h3\x3e\n\x3cp\x3e偏向服务端方向的话，除了需要进一步了解GraphQL在某个语言的具体生态外，还需要了解一些关于缓存、上传文件等特定方向的东西。如果是想做系统迁移，还需要对特定的框架做一些调研，比如graphene-django。\x3c\/p\x3e\n\x3cp\x3e如果是想使用GraphQL本身做系统开发，这里推荐了解一个叫做\x3ca href=\x22https:\/\/www.prisma.io\/docs\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eprisma\x3c\/a\x3e的框架，它本身是在GraphQL的基础上构建的，并且与一些GraphQL的生态框架兼容性也较好，在各大编程语言也均有适配，它本身可以当做一个ORM来使用，也可以当做一个与数据库交互的中间层来使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e偏向客户端\x3c\/h3\x3e\n\x3cp\x3e偏向客户端方向的话，需要进一步了解关于graphql-client的相关知识，我这段时间了解的是apollo，一个开源的grapql-client框架，并且与各个主流前端技术栈如Angular、React等均有适配版本，使用感觉良好。\x3c\/p\x3e\n\x3cp\x3e同时，还需要了解一些额外的查询概念，比如分页查询中涉及的Connection、Edge等。\x3c\/p\x3e\n\x3cp\x3e大概就这么多，如有错误，还望指正。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>30分钟理解GraphQL核心概念</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014131950">https://segmentfault.com/a/1190000014131950</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/g8x5xffigy9/" target="_blank">https://alili.tech/archive/g8x5xffigy9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>