<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript难点笔记"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript难点笔记 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/gd37d4lupn5/",
				"appid": "1613049289050283", 
				"title": "JavaScript难点笔记 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0snn8gfg6ek/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/d1x0c9azfki/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&text=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&text=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&title=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&is_video=false&description=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&title=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&title=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&title=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgd37d4lupn5%2f&title=JavaScript%e9%9a%be%e7%82%b9%e7%ac%94%e8%ae%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript难点笔记</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e由于工作需求重新回顾了一下JavaScript，以下内容是我以前的学习笔记和其他参考资料整理完善后的内容，都是常用到的，使用频率比较高的，自己必须得精通的知识点的总结，便以后再复习参考。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e第一章 JavaScript原型对象与原型链\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e1.1 构造函数的缺点\x3c\/h3\x3e\n\x3cp\x3e自定义对象时，以构造函数为模板，对象的属性和方法，可以定义在构造函数内部。每当获取对象时都会在内存中创建新的对象属性和方法，这既是增加页面代码量有浪费内存（系统资源）。\x3c\/p\x3e\n\x3cp\x3e同一个构造函数的对象实例之间无法共享属性，而所有的方法都是同样的行为，因此属性和方法完全应该共享。但无法共享这就是缺点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(Name,Class){\n    this.name=Name;\n    this.class=Class;\n    this.f=function(){\n        console.log(this.name\x2b\x27是\x27\x2bthis.class\x2b\x27班的学生\x27);\n    }\n}\n\/\/此时，每当得到一个对象实例，就会多一个“01”的班，浪费内存，\n\/\/因为只有一个班，而学生两个，只在内存中存在一个班级而学生不一样就可以了，但构造函数无法实现\nvar Stu1=new Student(\x27Aklman\x27,\x2701\x27);\nvar Stu2=new Student(\x27Ahmatbek\x27,\x2701\x27);\nStu1.f();\nStu2.f();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eName,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=Name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.class=Class;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.f=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27是\x27\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.class\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27班的学生\x27\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/此时，每当得到一个对象实例，就会多一个“01”的班，浪费内存，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/因为只有一个班，而学生两个，只在内存中存在一个班级而学生不一样就可以了，但构造函数无法实现\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Stu1=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27Aklman\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x2701\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Stu2=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27Ahmatbek\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x2701\x27\x3c\/span\x3e);\nStu1.f();\nStu2.f();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.2 prototype属性\x3c\/h3\x3e\n\x3cp\x3eJavaScript中每一个对象都继承另一个对象，父类对象称之为“原型”（prototype）对象。\x3cstrong\x3e只有null除外，其他都有自己的原型对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e而原型对象上的所有属性和方法，都能被派生（子类）对象共享。通过构造方法生成生成实例化对象时，会自动生成实例化对象分配原型对象。每一个构造方法都有一个prototype属性，这个属性就是实例化对象的原型对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(Name,Class){\n    this.name=Name;\n    this.f=function(){\n        console.log(this.name\x2b\x27是\x27\x2bthis.class\x2b\x27班的学生\x27);\n    }\n}\n\/\/构造函数的prototype就是由这个构造函数得到的对象的原型对象（父类对象）\nStudent.prototype.class=\x2701\x27;\nvar stu1=new Student(\x27aklman\x27);\nvar stu2=new Student(\x27ahmatbek\x27);\nstu1.f();\nstu2.f();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eName,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=Name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.f=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27是\x27\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.class\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27班的学生\x27\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/构造函数的prototype就是由这个构造函数得到的对象的原型对象（父类对象）\x3c\/span\x3e\nStudent.prototype.class=\x3cspan class=\x22hljs-string\x22\x3e\x2701\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu1=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu2=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27ahmatbek\x27\x3c\/span\x3e);\nstu1.f();\nstu2.f();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数Student的prototype对象就是实例化对象stu1和stu2的原型对象。在原型对象上添加一个color属性。结果，实例化对象都能读取属性。实现属性共享；\x3c\/p\x3e\n\x3cp\x3e原型对象的属性不是实例化对象自身的属性。但是只要修改原型对象，变动会立刻回提现到所有实例化对象上。\x3c\/p\x3e\n\x3cblockquote\x3e如果实例化对象自身就有某个属性或方法，那么原型对象上的属性和方法便会失效：\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(Name,Class){\n    this.name=Name;\n    this.f=function(){\n        console.log(this.name\x2b\x27是\x27\x2bthis.class\x2b\x27班的学生\x27);\n    }\n}\n\/\/将class属性，赋值给原型对象，此后所有对象共享class属性\nStudent.prototype.class=\x2701\x27;\nvar stu1=new Student(\x27aklman\x27);\nvar stu2=new Student(\x27ahmatbek\x27);\n\/\/为stu2对象定义class属性，原型对象的class属性则失效，也就是说在stu2上的属性发生变化\nstu2.class=\x2702\x27;\nstu1.f();\nstu2.f();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eName,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=Name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.f=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27是\x27\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.class\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27班的学生\x27\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将class属性，赋值给原型对象，此后所有对象共享class属性\x3c\/span\x3e\nStudent.prototype.class=\x3cspan class=\x22hljs-string\x22\x3e\x2701\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu1=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu2=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27ahmatbek\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/为stu2对象定义class属性，原型对象的class属性则失效，也就是说在stu2上的属性发生变化\x3c\/span\x3e\nstu2.class=\x3cspan class=\x22hljs-string\x22\x3e\x2702\x27\x3c\/span\x3e;\nstu1.f();\nstu2.f();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e总结：原型对象的作用就是定义所有数理化对象共享的属性和方法。这也是他被称为原型对象的原因，而实例化对象可以视作从原型对象衍生出来的子对象。\x3cp\x3e由于JavaScript的所有对象都是构造函数（只有null除外）。而所有构造函数都有prototype属性（其实是所有函数都有prototype属性），所以所有对象都有自己的原型对象。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.3 原型链\x3c\/h3\x3e\n\x3cp\x3e对象的属性和方法，有可能是定义在自身内，也有可能是定义在它的原型对象上。由于原型对象本身也是对象，又有自己的原型，所有生成了一条原型链（prototype chain）。例如，a对象是b对象的原型，b对象是c对象的原型，依次类推。\x3c\/p\x3e\n\x3cp\x3e如果那么一层层地上溯，所有对象的原型最终都可以上溯到Object对象上。Object对象也有原型就是一个没有任何属性和方法的null对象，而null对象没有自己的原型。\x3c\/p\x3e\n\x3cp\x3e获取对象的原型对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(Name){\n    this.name=Name;\n}\nvar stu1=new Student(\x27aklman\x27);\nconsole.log(Student.prototype);\nconsole.log(Student.prototype.constructor.prototype);\n\/\/由于对象自身直接获取原型对象，最终的大对象就是object,也就是说，在JavaScript中所有对象（不管从何而来）都基于object大对象，而最大对象Object的原型指向null，也就是没有\nconsole.log(stu1.__pro__.__proto__.__proto__);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eName\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=Name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu1=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Student.prototype);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Student.prototype.constructor.prototype);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/由于对象自身直接获取原型对象，最终的大对象就是object,也就是说，在JavaScript中所有对象（不管从何而来）都基于object大对象，而最大对象Object的原型指向null，也就是没有\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu1.__pro__.__proto__.__proto__);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型链的作用是读取对象某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到就找它的原型（父类对象），如果还是找不到就找原型的原型。如果直到最顶层的Object。prototype还是找不到，则返回undefined。\x3c\/p\x3e\n\x3cblockquote\x3e如果对象自身和它的原型，都定义了一个同名属性，那么悠闲读取对象自身的属性，这叫\x3cstrong\x3e覆盖(overriding)\x3c\/strong\x3e。\x3c\/blockquote\x3e\n\x3cp\x3e注意：一级级向上，在原型链寻找某个属性，对性能是有影响的。如果寻找某个不存在的属性将会遍历整个原型链。\x3c\/p\x3e\n\x3cp\x3e实际开发上注意事项：通常使用第三方框架（一个类），但是我们发现这个类中并不存在我们想要的属性或方法时，不能直接修改源代码，但是可以通过原型对象来添加我们想要的属性和方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e1.4 原型操作\x3c\/h3\x3e\n\x3ch4\x3e1.4.1 constructor属性\x3c\/h4\x3e\n\x3cp\x3e对象有一个constructor属性指向原型对象所在的构造函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name){\n    this.name=name;\n}\nvar stu=new Student(\x27aklman\x27);\nconsole.log(stu.constructor);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.constructor);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e1.4.2 设置获取原型对象\x3c\/h4\x3e\n\x3cp\x3eObject.getPrototypeOf()方法返回一个对象的原型对象，也就是通过它获取原型对象，这是标准的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name,Class){\n    this.name=name;\n}\nvar stu=new Student(\x27aklman\x27);\n\/\/获取stu对象的原型对象\nvar s=Object.getPrototypeOf(stu);\nconsole.log(s);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取stu对象的原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s=\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(stu);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eObject.setPrototypeOd()为现有对象设置原型对象，第一个参数是现有对象，第二个是要设置成为原型对象的对象，用这个方法来设置原型对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name,Class){\n    this.name=name;\n}\nvar ob={p:\x27aklan\x27};\nvar stu=new Student(\x27Jappar\x27);\n\/\/设置stu的原型对象ob\nObject.setPrototypeOf(stu,ob); \nconsole.log(stu.p);\/\/aklman\nconsole.log(stu.name);\/\/Jappar\nconsole.log(Object.getPrototypeOf(stu));\/\/由大对象提供的getPrototypeOf方法获取对象的原型对象\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob={\x3cspan class=\x22hljs-attr\x22\x3ep\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27aklan\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27Jappar\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/设置stu的原型对象ob\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(stu,ob); \n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.p);\x3cspan class=\x22hljs-comment\x22\x3e\/\/aklman\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.name);\x3cspan class=\x22hljs-comment\x22\x3e\/\/Jappar\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(stu));\x3cspan class=\x22hljs-comment\x22\x3e\/\/由大对象提供的getPrototypeOf方法获取对象的原型对象\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eproto属性：前面用proto来获取原型对象，如果给proto属性赋值，则设置原型对象；最好不用这个，用Object.getPrototypeOf()来读取，用Object.setPrototypeof()来设置。也就是用这两个方法来对原型对象做读写操作。\x3c\/p\x3e\n\x3ch4\x3e1.4.3 获取原型对象方法及比较\x3c\/h4\x3e\n\x3cp\x3e上面写过获取原型对象的方法有三种：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22obj.__proto__\nobj.constructor.prototype\nObject.getPrototypeOf(obj)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eobj.__proto__\nobj.constructor.prototype\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(obj)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中前两个方法不是很友好，最新的ES6标准规定，proto属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，会失效。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name,Class){\n    this.name=name;\n}\nvar ob={p:\x27aklman\x27};\nvar stu=new Student(\x27Jappar\x27);\n\/\/使用constructor属性获取原型对象\nconsole.log(stu.constructor.prtototype);\n\n\/\/修改stu的原型对象为ob\nObject.setPrototypeOf(stu,ob);\n\n\/\/使用getPrototypeOf方法来查看stu的原型对象为ob\nconsole.log(Object.getPrototypeOf(stu));\n\n\/\/使用constructor属性获取原型对象为Object，这是错误的,构造函数无法修改对象的原型对象\nconsole.log(stu.constructor.prototype);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,Class\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob={\x3cspan class=\x22hljs-attr\x22\x3ep\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stu=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27Jappar\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用constructor属性获取原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.constructor.prtototype);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/修改stu的原型对象为ob\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(stu,ob);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用getPrototypeOf方法来查看stu的原型对象为ob\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(stu));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用constructor属性获取原型对象为Object，这是错误的,构造函数无法修改对象的原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.constructor.prototype);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总结：最好使用Object.getPrototypeOf()方法获取原型对象，没了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Student(name){\n    this.name=name;\n}\nvat stu=new Student(\x27aklman\x27);\n\/\/1.构造函数获取原型对象\nconsole.log(stu.constructor.prototype);\n\/\/2.由对象自身获取原型对象\nconsole.log(stu.__proto__);\n\/\/3.有大树提供的getPrototypeOf()方法获取对象的原型对象\nconsole.log(Obj.getPrototypeOf(stu));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n}\nvat stu=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Student(\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/1.构造函数获取原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.constructor.prototype);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/2.由对象自身获取原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stu.__proto__);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/3.有大树提供的getPrototypeOf()方法获取对象的原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Obj.getPrototypeOf(stu));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e第二章 闭包\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.1 闭包的概念\x3c\/h3\x3e\n\x3cp\x3eJavaScript有两种作用域：全局作用域和函数作用域（局部作用域）。函数内部可以直接读取全局变量，但是函数外部无法读取函数内部声明的变量。\x3c\/p\x3e\n\x3cp\x3e但是，有时候却需要在函数外部访问函数内部的变量；正常情况下，这是无法的访问的，只有通过变通方法才能实现访问，也就是在函数内部再定义一个函数，通过内部函数来访问函数内部的变量。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun1(){\n    var n=100;\n    var fun2=function(){\n        console.log(n);\n    }\n    return funct;\n}\nvar pack=fun1();\npack();\/\/100\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun2=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(n);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e funct;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pack=fun1();\npack();\x3cspan class=\x22hljs-comment\x22\x3e\/\/100\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e说明：函数fun2就在函数fun1()内部，这是fun1（）内部的所有局部变量对fun2（）是可访问的。反过来就不行，内部函数中的局部变量对父类函数是不可访问的。这就是JavaScript中特有的\x3cstrong\x3e链式作用域（chain scope）\x3c\/strong\x3e结构，子对象会一级一级地向上寻找所有父类对象的变量，所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\x3c\/p\x3e\n\x3cp\x3e既然fun2()可以读取fun1()中的局部变量，那么只要把fun2()作为返回值，我们就可以在fun1()外部读取它的内部变量了。\x3c\/p\x3e\n\x3cp\x3e重点：\x3c\/p\x3e\n\x3cblockquote\x3e闭包就是函数fun2，既能狗读取其他函数内部变量的函数。由于JavaScript中，只要函数内部的子函数才能够读取函数内部的局部变量，因此可以把闭包简单理解成“定义一个函数内部的函数”。\x3cp\x3e闭包的最大特点就是它可以“记住”诞生的环境，比如fun2()记住，所以从fun2()可以得到fun1()的内部变量。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e2.2 垃圾回收机制及闭包\x3c\/h3\x3e\n\x3ch4\x3e2.2.1 垃圾回收机制\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun1(){\n    var n=100;\n    console.log(\x2b\x2bn);\n}\nfun1();\/\/101\nfun1();\/\/101\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2b\x2bn);\n}\nfun1();\x3cspan class=\x22hljs-comment\x22\x3e\/\/101\x3c\/span\x3e\nfun1();\x3cspan class=\x22hljs-comment\x22\x3e\/\/101\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e说明：在函数内部引入一个变量或者函数时，系统都会开辟一块内存空间；还会将这块内存的引用计数器初始化，初始化值为0；如果外部有全局变量或者程序引用了这块空间，则引用计数器会自动进行\x2b1操作，当函数执行完毕后，变量计数器会重新归零，系统会运行垃圾回收机制，将函数运行产生的数据销毁；如果计数器不是0，则不会清楚数据；这过程就是\x3cstrong\x3eJavaScript的垃圾回收机制\x3c\/strong\x3e；\x3c\/p\x3e\n\x3cp\x3eJavaScript的垃圾回收机制原理图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6fHv?w=512\x26amp;h=278\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6fHv?w=512\x26amp;h=278\x22 alt=\x22JavaScript垃圾回收机制原理图\x22 title=\x22JavaScript垃圾回收机制原理图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e用闭包的分析话更能体验此原理：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun1(){\n    var n=100;\n    function fun2(){\n        console.log(\x2b\x2bn);\n    }\n    return fun2;\n}\nvar fu=fun1();\/\/实际上返回了fun2\nfu();\/\/101,相当于调用了fun2(),\nfu();\/\/102,相当于在此调用了fun2()\nfu();\/\/103\nfu();\/\/104\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2b\x2bn);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fun2;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fu=fun1();\x3cspan class=\x22hljs-comment\x22\x3e\/\/实际上返回了fun2\x3c\/span\x3e\nfu();\x3cspan class=\x22hljs-comment\x22\x3e\/\/101,相当于调用了fun2(),\x3c\/span\x3e\nfu();\x3cspan class=\x22hljs-comment\x22\x3e\/\/102,相当于在此调用了fun2()\x3c\/span\x3e\nfu();\x3cspan class=\x22hljs-comment\x22\x3e\/\/103\x3c\/span\x3e\nfu();\x3cspan class=\x22hljs-comment\x22\x3e\/\/104\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码分析（注释）：\x3c\/p\x3e\n\x3cblockquote\x3e因函数fun1被调用时，返回的结果是fun2函数体，也就是说，fun2函数被当做返回值给fun1的调用者，但是fun2函数并没有在此被调用执行（只是把函数体返回到函数外了）;\x3cp\x3e因此整个fun1函数体，无法判断子函数fun2会对其产生何种影响，无法判断变量n是否会被使用，即使fun1函数被调用结束，整个fun1函数始终保留在内存中，不会被垃圾回收机制回收；\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e也就是运行代码发现，函数调用一次（在这里是指fun2），其变量n变化一次；\x3c\/p\x3e\n\x3cp\x3e闭包的最大用处：\x3c\/p\x3e\n\x3cblockquote\x3e可以读取函数内部的变量。\x3cp\x3e让函数内部读取的变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e注意的是，外层函数每次运行，都会生成一个新的闭包，而这个闭包有会保留外层函数的内部变量，所以内存消耗很大；因此不能滥用闭包，否则会造成网页的性能问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e第三章 call和apply方法\x3c\/h2\x3e\n\x3cp\x3e关于JavaScript中的this的指向：\x3c\/p\x3e\n\x3cblockquote\x3e1.全局作用域下，this指向window对象\x3cp\x3e2.构造函数中，this指向实例化对象\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e如果要在调用函数是直接修改函数内部的this指向使用call或者apply方法来修改指向。\x3c\/p\x3e\n\x3cblockquote\x3e1.call方法格式：函数名称.call(obj,arg1,arg2,...argN);说明其中：obj是函数内this要指向的对象，arg列表是参数列表，参数与参数之间使用一个逗号隔开\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ob1={name:\x27Aklman\x27,age:23};\nvar ob2={name:\x27ahmatbek\x27};\nfunction fun(sex){\n    console.log(this.name\x2bthis.age\x2bsex);\n}\nfun.call(ob1,\x27男\x27);\/\/Aklman23男\nfun.call(ob2,\x27男\x27);\/\/ahmatbekundefined男,因为对象ob2中没有age属性\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob1={\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27Aklman\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob2={\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27ahmatbek\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esex\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age\x2bsex);\n}\nfun.call(ob1,\x3cspan class=\x22hljs-string\x22\x3e\x27男\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/Aklman23男\x3c\/span\x3e\nfun.call(ob2,\x3cspan class=\x22hljs-string\x22\x3e\x27男\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ahmatbekundefined男,因为对象ob2中没有age属性\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e2.apply方法格式：函数名称.apply(obj,[arg1,,arg2,...argN]);说明其中：obj是函数内this要指向的对象，arg列表是参数列表，要求格式为数组\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ob1={name:\x27aklman\x27,age:23};\nvar ob2={name:\x27ahmatbek\x27,tel:176};\nfunction fun(sex,age,tel){\n    console.log(this.name\x2bage\x2bsex\x2btel);\n}\nfun.apply(ob1, [\x27男\x27, 23, 176]);\/\/aklman23男176\nfun.apply(ob2, [\x27男\x27, 20, 133]);\/\/ahmatbek20男133\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob1={\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob2={\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27ahmatbek\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3etel\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e176\x3c\/span\x3e};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esex,age,tel\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2bage\x2bsex\x2btel);\n}\nfun.apply(ob1, [\x3cspan class=\x22hljs-string\x22\x3e\x27男\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e176\x3c\/span\x3e]);\x3cspan class=\x22hljs-comment\x22\x3e\/\/aklman23男176\x3c\/span\x3e\nfun.apply(ob2, [\x3cspan class=\x22hljs-string\x22\x3e\x27男\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e133\x3c\/span\x3e]);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ahmatbek20男133\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两种修改this指向方法的区别：\x3c\/p\x3e\n\x3cblockquote\x3e相同点：功能完全一样，都是为了改变函数内部的hits指向，唯一的不同就在于参数传递方式不同\x3cp\x3e不同点：call方法可能多个参数，第一个要指向的对象，其他参数为函数的实参；apply方法最多只能有两个实参，第一个要指向的对象，第二个是数组，数组内容为函数的实参。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e第四章 私有属性\x3c\/h2\x3e\n\x3cp\x3eJavaScript与其他语言不太一样，它只有两种属性，即公有属性和私有属性，概念很好理解，也就是在构造函数内部通过this声明的属性就是公有属性，通过var声明的就是私有属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Employee(){\n    this.name=\x27aklman\x27;\/\/公有属性\n    var age=18;\/\/私有属性\n    this.fun=function(){\/\/公有方法\n        console.log(this.name\x2bage);\/\/age只能在构造函数内部访问\n    }\n}\nvar m=new Employee();\nconsole.log(m.name);\/\/aklman\nconsole.log(m.age);\/\/undefined\nm.fun();\/\/aklman18\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEmployee\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=\x3cspan class=\x22hljs-string\x22\x3e\x27aklman\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/公有属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e age=\x3cspan class=\x22hljs-number\x22\x3e18\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/私有属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fun=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/公有方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2bage);\x3cspan class=\x22hljs-comment\x22\x3e\/\/age只能在构造函数内部访问\x3c\/span\x3e\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Employee();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(m.name);\x3cspan class=\x22hljs-comment\x22\x3e\/\/aklman\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(m.age);\x3cspan class=\x22hljs-comment\x22\x3e\/\/undefined\x3c\/span\x3e\nm.fun();\x3cspan class=\x22hljs-comment\x22\x3e\/\/aklman18\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e第五章 对象继承\x3c\/h2\x3e\n\x3cp\x3eJavaScript中的继承的实现与其他语言也不相同，它没有关键字提供继承的功能。所谓\x3cstrong\x3e继承\x3c\/strong\x3e就是\x3cstrong\x3e为了子类中提供父类中的属性和方法，子类能够使用父类中的属性和方法\x3c\/strong\x3e；\x3c\/p\x3e\n\x3cp\x3eJavaScript中继承的实现方式有：\x3c\/p\x3e\n\x3cblockquote\x3e1.通过原型对象实现继承\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/声明构造函数\nfunction Study(){\n    this.fun=function(){\n        console.log(\x27我是构造函数中的公有方法\x27);\n    }\n}\n\/\/声明构造函数\nfunction Student(){}\nStudent.prototype=new Study();\/\/设置构造函数Student的原型为Study,实现继承\nvar extend=new Study();\nextend.fun();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/声明构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudy\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fun=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我是构造函数中的公有方法\x27\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/声明构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\nStudent.prototype=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Study();\x3cspan class=\x22hljs-comment\x22\x3e\/\/设置构造函数Student的原型为Study,实现继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extend=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Study();\nextend.fun();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e2.通过call或apply方法继承（实质就是改变指向使用父类中的属性和方法）\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/声明构造函数\nfunction Study(){\n    this.fun=function(){\n        console.log(\x27我是构造函数中的公有方法\x27);\n    }\n}\n\/\/声明构造函数\nfunction Student(){\n    Study.call(this);\/\/将Study函数内部的this指向Student的实例化对象\n}\nvar extend=new Study();\nextend.fun();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/声明构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudy\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fun=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我是构造函数中的公有方法\x27\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/声明构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStudent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    Study.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/将Study函数内部的this指向Student的实例化对象\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extend=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Study();\nextend.fun();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e第六章 定时器\x3c\/h2\x3e\n\x3cp\x3eJavaScript提供定时执行代码的功能叫做定时器；\x3c\/p\x3e\n\x3cblockquote\x3e1.setTimeout():用来指定某个函数或某代码，在多少秒之后执行。\x3cp\x3e2.setInterval():指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3esetTimeout(),setInterval()的第一个参数都是指定执行的函数名称或者代码段，第二个参数是时间：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun(){\n    var n=1;\n    return function(){\n        console.log(\x2b\x2bn);\n    }\n}\nvar s=fun();\n\/\/3秒后调用函数；\nsetTimeout(\x27s()\x27,3000);\n\/\/每隔1秒就执行函数名为s的函数\nsetInterval(s,100);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2b\x2bn);\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s=fun();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/3秒后调用函数；\x3c\/span\x3e\nsetTimeout(\x3cspan class=\x22hljs-string\x22\x3e\x27s()\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/每隔1秒就执行函数名为s的函数\x3c\/span\x3e\nsetInterval(s,\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esetTimeout()函数和setInterval()函数都返回一个表示计数器编号的整数值，将该整数传入clearTimeout()和clearInterval()函数，就可以取消对应的定时器。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput type=\x26quot;button\x26quot; value=\x26quot;停止\x26quot;\x3e\n\x3cscript\x3e\nfunction fun(){\n    var n=1;\n    return function(){\n        console.log(\x2b\x2bn);\n    }\n}\nvar s=fun();\n\/\/3秒后调用函数；\nvar i=setTimeout(\x27s()\x27,3000);\n\/\/每隔1秒就执行函数名为s的函数\nvar j=setInterval(s,100);\ndocument.querySelector(\x27input\x27).onclick=function(){\n    \/\/停止定时器\n    clearInterval(j);\n    clearTimeout(i);\n}\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;input type=\x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e value=\x3cspan class=\x22hljs-string\x22\x3e\x22停止\x22\x3c\/span\x3e\x26gt;\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2b\x2bn);\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s=fun();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/3秒后调用函数；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=setTimeout(\x3cspan class=\x22hljs-string\x22\x3e\x27s()\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/每隔1秒就执行函数名为s的函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=setInterval(s,\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e).onclick=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/停止定时器\x3c\/span\x3e\n    clearInterval(j);\n    clearTimeout(i);\n}\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e补充知识点\x3c\/h2\x3e\n\x3cp\x3e上面提过内存，计数器，那么就谷歌一下什么是内存及计数器。\x3c\/p\x3e\n\x3cp\x3e通常说的内存是计算机的主存储器(main memory),简称主存。主存通过控制芯片等与CPU相连，主要负责存储指令和数据。主存由可读写的元素构成，每个字节(1字节=8位)都带有一个地址编号（也就是所谓的内存地址）。CPU可以通过改地址读取主存中的指令和数据，当然也可以写入数据。注意的是，主存中存储的指令和数据会随着计算机的关机自动清除（自动销毁，释放）。\x3c\/p\x3e\n\x3cp\x3e寄存器是CPU的组件之一，，CPU由控制器，运算器，时钟，寄存器组成。控制器做的是数据运算以外的处理（主要是输入和输出的时机控制），比如内存和磁盘等媒介的输入输出，显示器，打印机的输出等，都是控制器做的事。\x3c\/p\x3e\n\x3cp\x3e废话不多说，听大师们说CPU中程序员只要搞明白寄存器就可以飞上天了。原因是程序是把寄存器作为对象来描述，也就是计算机中每一句命令都是通过寄存器才能执行（数据存储，假发运算等），寄存器也有很多种类，根据类型存储的数据也不一样，不同的CPU中的寄存器数量也不一样以及寄存器存储的数值范围也不一样。\x3c\/p\x3e\n\x3cp\x3e寄存器由程序计数器，标志寄存器，累加寄存器，基址寄存器，变址寄存器，通用寄存器等组成，其中程序计数器和标志寄存器比较特殊。计数器以二进制形式技术，计数规则是：\x3cstrong\x3eCPU每执行一个命令，计数器的值就会自动加1,\x3c\/strong\x3e例如，CPU执行0100地址的指令后，计数器的值就变成了0101（当执行的指令占据多个内存地址是，增加与指令长度相应的数值）。\x3cstrong\x3e然后CPU的控制器就会参照计数器的数值，从内存中读取命令并执行，也就是说，程序计数器决定着程序的运行流程。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader14\x22\x3e参考资料\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.w3school.com.cn\/b.asp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eW3school\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.runoob.com\/js\/js-tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e菜鸟教程\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/item.jd.com\/10974436.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript权威指南（第6版）\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/item.jd.com\/11758229.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e计算机科学导论（第三版）\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript难点笔记</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013844401">https://segmentfault.com/a/1190000013844401</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/gd37d4lupn5/" target="_blank">https://alili.tech/archive/gd37d4lupn5/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>