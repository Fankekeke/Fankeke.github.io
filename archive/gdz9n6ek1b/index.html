<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JS中的继承(上)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JS中的继承(上) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/gdz9n6ek1b/",
				"appid": "1613049289050283", 
				"title": "JS中的继承(上) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0q7rtlrfe1k/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/mlhln5s2gji/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&text=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&text=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&title=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&is_video=false&description=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&title=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&title=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&title=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgdz9n6ek1b%2f&title=JS%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%28%e4%b8%8a%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JS中的继承(上)</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3\x3eJS中的继承(上)\x3c\/h3\x3e\n\x3cblockquote\x3e学过java或者c#之类语言的同学,应该会对js的继承感到很困惑--不要问我怎么知道的,js的继承主要是基于原型(prototype)的,对js的原型感兴趣的同学,\x3cbr\x3e可以了解一下我之前写的\x3ca href=\x22https:\/\/github.com\/noahlam\/articles\/blob\/master\/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.md\x22 rel=\x22nofollow noreferrer\x22\x3eJS中的原型对象\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e相信很多同学也跟我一样,刚开始接触js的面向对象编程的时候,都抱着一种排斥的心态--为什么js这么麻烦?\x3cbr\x3e其实了解完原型链后,再来看js的继承,你会发现js的继承其实比其他OOP语言更简单,更灵活,我们来看一个基于原型链的继承\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person() {}\n\n\/\/ 子类\nfunction Student(){}\n\n\/\/ 继承\nStudent.prototype = new Person()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们只要\x3ccode\x3e把子类的prototype设置为父类的实例\x3c\/code\x3e,就完成了继承,怎么样? 是不是超级简单? 有没有比Java,C#的清晰?\x3cbr\x3e事实上,以上就是js里面的\x3cstrong\x3e原型链继承\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当然,通过以上代码,我们的Student只是继承了一个空壳的Person,这样视乎是毫无意义的,我们使用继承的目的,\x3cbr\x3e就是要通过继承获取父类的内容,那我们先给父类加上一点点简单的内容(新增的地方标记 \x27\/\/ 新增的代码\x27):\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person(name,age) {\n  this.name = name || \x27unknow\x27     \/\/ 新增的代码\n  this.age = age || 0              \/\/ 新增的代码\n}\n\n\/\/ 子类\nfunction Student(name){\n  this.name = name                 \/\/ 新增的代码\n  this.score = 80                  \/\/ 新增的代码\n}\n\n\/\/ 继承\nStudent.prototype = new Person()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu = new Student(\x27lucy\x27)\n\nconsole.log(stu.name)  \/\/ lucy    --子类覆盖父类的属性\nconsole.log(stu.age)   \/\/ 0       --父类的属性\nconsole.log(stu.score) \/\/ 80      --子类自己的属性\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里为了降低复杂度,我们只演示了普通属性的继承,没有演示方法的继承,事实上,方法的继承也很简单,\x3cbr\x3e我们再来稍微修改一下代码,基于上面的代码,给父类和子类分别加一个方法(新增的地方标记 \x27\/\/ 新增的代码\x27)\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person(name,age) {\n  this.name = name || \x27unknow\x27\n  this.age = age || 0\n}\n\n\/\/ 为父类新曾一个方法\nPerson.prototype.say = function() {         \/\/ 新增的代码\n    console.log(\x27I am a person\x27)\n}\n\n\/\/ 子类\nfunction Student(name){\n  this.name = name\n  this.score = 80\n}\n\n\/\/ 继承 注意,继承必须要写在子类方法定义的前面\nStudent.prototype = new Person()\n\n\/\/ 为子类新增一个方法(在继承之后,否则会被覆盖)\nStudent.prototype.study = function () {     \/\/ 新增的代码\n    console.log(\x27I am studing\x27)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu = new Student(\x27lucy\x27)\n\nconsole.log(stu.name)  \/\/ lucy               --子类覆盖父类的属性\nconsole.log(stu.age)   \/\/ 0                  --父类的属性\nconsole.log(stu.score) \/\/ 80                 --子类自己的属性\nstu.say()              \/\/ I am a person      --继承自父类的方法\nstu.study()            \/\/ I am studing       --子类自己的方法\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样,看起来我们好像已经完成了一个完整的继承了,这个就是\x3cstrong\x3e原型链继承\x3c\/strong\x3e,怎么样,是不是很好理解?\x3cbr\x3e但是,原型链继承有一个缺点,就是属性如果是引用类型的话,会共享引用类型,请看以下代码\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person() {\n  this.hobbies = [\x27music\x27,\x27reading\x27]\n}\n\n\/\/ 子类\nfunction Student(){}\n\n\/\/ 继承\nStudent.prototype = new Person()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu1 = new Student()\nvar stu2 = new Student()\n\nstu1.hobbies.push(\x27basketball\x27)\n\nconsole.log(stu1.hobbies)   \/\/ music,reading,basketball\nconsole.log(stu2.hobbies)   \/\/ music,reading,basketball\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以看到,当我们改变stu1的引用类型的属性时,stu2对应的属性,也会跟着更改,这就是\x3cstrong\x3e原型链继承缺点\x3c\/strong\x3e --引用属性会被所有实例共享,\x3cbr\x3e那我们如何解决这个问题呢? 就是下面我们要提到的\x3cstrong\x3e借用构造函数继承\x3c\/strong\x3e,我们来看一下使用构造函数继承的最简单例子:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person() {\n  this.hobbies = [\x27music\x27,\x27reading\x27]\n}\n\n\/\/ 子类\nfunction Student(){\n    Person.call(this)              \/\/ 新增的代码\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu1 = new Student()\nvar stu2 = new Student()\n\nstu1.hobbies.push(\x27basketball\x27)\nconsole.log(stu1.hobbies)   \/\/ music,reading,basketball\nconsole.log(stu2.hobbies)   \/\/ music,reading\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样,我们就解决了引用类型被所有实例共享的问题了\x3c\/p\x3e\n\x3cblockquote\x3e注意,这里跟 原型链继承 有个比较明显的区别是并没有使用prototype继承,而是在子类里面执行父类的构造函数,\x3cbr\x3e相当于把父类的代码复制到子类里面执行一遍,这样做的另一个好处就是可以给父类传参\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person(name) {\n  this.name = name              \/\/ 新增的代码\n}\n\n\/\/ 子类\nfunction Student(name){\n    Person.call(this,name)      \/\/ 改动的代码\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu1 = new Student(\x27lucy\x27)\nvar stu2 = new Student(\x27lili\x27)\nconsole.log(stu1.name)   \/\/ lucy\nconsole.log(stu2.name)   \/\/ lili\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看起来已经很有Java,C#的味道了有没有?\x3c\/p\x3e\n\x3cp\x3e但是,构造函数解决了引用类型被所有实例共享的问题,但正是因为解决了这个问题,导致一个很矛盾的问题出现了,\x3cstrong\x3e--函数也是引用类型\x3c\/strong\x3e,\x3cbr\x3e也没办法共享了.也就是说,每个实例里面的函数,虽然功能一样,但是却不是同一个函数,就相当于我们每实例化一个子类,就复制了一遍的函数代码\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person(name) {\n  this.say = function() {}    \/\/ 改动的代码\n}\n\n\/\/ 子类\nfunction Student(name){\n    Person.call(this,name)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar stu1 = new Student(\x27lucy\x27)\nvar stu2 = new Student(\x27lili\x27)\nconsole.log(stu1.say === stu2.say)   \/\/ false\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码可以证明,父类的函数,在子类的实例下是不共享的\x3c\/p\x3e\n\x3ch4\x3e总结\x3c\/h4\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e继承方式\x3c\/th\x3e\n\x3cth\x3e继承核心代码\x3c\/th\x3e\n\x3cth\x3e优缺点\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e原型链继承\x3c\/td\x3e\n\x3ctd\x3e\x3ccode\x3eStudent.prototype = new Person()\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e实例的引用类型共享\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e构造函数继承\x3c\/td\x3e\n\x3ctd\x3e在子类(Student)里执行 \x3ccode\x3ePerson.call(this)\x3c\/code\x3e\n\x3c\/td\x3e\n\x3ctd\x3e实例的引用类型不共享\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e从上表我们可以看出 \x3ccode\x3e原型链继承\x3c\/code\x3e 和 \x3ccode\x3e构造函数继承\x3c\/code\x3e 这两种继承方式的优缺点刚好是互相矛盾的,那么我们有没有办法鱼和熊掌兼得呢?\x3cbr\x3e没有的话,我就不会说出来了,^_^,接下来请允许我隆重介绍 \x3cstrong\x3e组合继承\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e组合继承,就是各取上面2种继承的长处,\x3cstrong\x3e普通属性\x3c\/strong\x3e 使用 \x3ccode\x3e构造函数继承\x3c\/code\x3e,\x3cstrong\x3e函数\x3c\/strong\x3e 使用 \x3ccode\x3e原型链继承\x3c\/code\x3e,\x3cbr\x3e这个代码稍微复杂一点,不过相信有了上面的基础后,看起来也是很轻松\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 父类\nfunction Person() {\n  this.hobbies = [\x27music\x27,\x27reading\x27]\n}\n\n\/\/ 父类函数\nPerson.prototype.say = function() {console.log(\x27I am a person\x27)}\n\n\/\/ 子类\nfunction Student(){\n    Person.call(this)             \/\/ 构造函数继承(继承属性)\n}\n\/\/ 继承\nStudent.prototype = new Person()  \/\/ 原型链继承(继承方法)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 实例化\nvar stu1 = new Student()\nvar stu2 = new Student()\n\nstu1.hobbies.push(\x27basketball\x27)\nconsole.log(stu1.hobbies)           \/\/ music,reading,basketball\nconsole.log(stu2.hobbies)           \/\/ music,reading\n\nconsole.log(stu1.say == stu2.say)   \/\/ true\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样,我们就既能实现属性的独立,又能做到函数的共享,是不是很完美呢?\x3c\/p\x3e\n\x3cblockquote\x3e组合继承据说是JavaScript中最常用的继承方式(具体无法考证哈).\x3c\/blockquote\x3e\n\x3cp\x3e至此,我们就把js里面的常用继承了解完了,其实也没有那么难嘛!不过,我们总结一下3种继承\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e原型链继承,会共享引用属性\x3c\/li\x3e\n\x3cli\x3e构造函数继承,会独享所有属性,包括引用属性(重点是函数)\x3c\/li\x3e\n\x3cli\x3e组合继承,利用原型链继承要共享的属性,利用构造函数继承要独享的属性,实现相对完美的继承\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e上面为什么要说相对完美呢? 因为本文的标题叫【JS中的继承(上)】,那肯定是还有\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/noahlam\/articles\/blob\/master\/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF(%E4%B8%8B\x22 rel=\x22nofollow noreferrer\x22\x3e【JS中的继承(下)】\x3c\/a\x3e.md)咯，\x3cbr\x3e目前为止,我们只讲了3种最基本的继承,事实上,JavaScript还有好多继承方式,为了让你不至于学习疲劳，所以我打算分开来讲，\x3cbr\x3e如果你没有那个耐性继续看下去，那么看完这篇对于理解JavaScript的继承，也是够用的。但是建议多看两遍，加深印象，\x3cbr\x3e我学js继承的时候，那本犀牛书都被我翻烂了，写这篇文字的时候，我还在一遍翻一边写的呢(嘘！)\x3c\/p\x3e\n\x3cp\x3e好了，今天就到这里，感谢收看，如果觉得对您有用，请给本文的\x3ca href=\x22https:\/\/github.com\/noahlam\/articles\x22 rel=\x22nofollow noreferrer\x22\x3egithub\x3c\/a\x3e加个star,万分感谢，\x3cbr\x3e另外，github上还有其他一些关于前端的教程和组件，有兴趣的童鞋可以看看，你们的支持就是我最大的动力。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JS中的继承(上)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014476341">https://segmentfault.com/a/1190000014476341</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/gdz9n6ek1b/" target="_blank">https://alili.tech/archive/gdz9n6ek1b/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>