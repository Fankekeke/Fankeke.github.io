<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="认识node核心模块--从Buffer、Stream到fs"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>认识node核心模块--从Buffer、Stream到fs | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/gvpfixfz84j/",
				"appid": "1613049289050283", 
				"title": "认识node核心模块--从Buffer、Stream到fs | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/cmbhqqwtrv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/b6mo2s0u32f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&text=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&text=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&title=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&is_video=false&description=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&title=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&title=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&title=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgvpfixfz84j%2f&title=%e8%ae%a4%e8%af%86node%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97--%e4%bb%8eBuffer%e3%80%81Stream%e5%88%b0fs"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">认识node核心模块--从Buffer、Stream到fs</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22http:\/\/realtcg.com\/2017\/11\/10\/%E8%AE%A4%E8%AF%86node%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-%E4%BB%8EBuffer%E3%80%81Stream%E5%88%B0fs\/http:\/\/realtcg.com\/2017\/11\/10\/%E8%AE%A4%E8%AF%86node%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-%E4%BB%8EBuffer%E3%80%81Stream%E5%88%B0fs\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文地址\x3c\/a\x3e在我的博客\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3enode中的Buffer和Stream会给刚接触Node的前端工程师们带来困惑，原因是前端并没有类似概念(or 有我们也没意识到)。然而，在后端，在node中，Buffer和Stream处处体现。Buffer是缓冲区的意思，Stream是流的意思。在计算机中，缓冲区是存储中间变量，方便CPU读取数据的一块存储区域；流是类比水流形容数据的流动。Buffer和Stream一般都是字节级操作。本文将介绍这两个模块的具体细节后再介绍文件模块，以让读者有更清晰的认识。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e正文\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e二进制缓冲区Buffer\x3c\/h3\x3e\n\x3cp\x3e在前端，我们只需做字符串级别的操作，很少接触字节、进制等底层操作，一方面这足以满足日常需求，另一方面Javascript这种应用层语言并不是干这个的；然而在后端，处理文件、网络协议、图片、视频等时是非常常见的，尤其像文件、网络流等操作处理的都是二进制数据。为了让javascript能够处理二进制数据，node封装了一个Buffer类，主要用于操作字节，处理二进制数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个长度为 10、且用 30 填充的 Buffer。\nconst buf1 = Buffer.alloc(10, 30)\nconsole.log(buf1)\/\/ \x3cBuffer 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e\x3e\n\/\/ 字符串转Buffer\nconst buf2 = Buffer.from(\x27javascript\x27)\nconsole.log(buf2)\/\/ \x3cBuffer 6a 61 76 61 73 63 72 69 70 74\x3e\n\/\/ 字符串转 buffer\nconsole.log(buf2.toString())\/\/ javascript\nconsole.log(buf2.toString(\x27hex\x27)) \/\/6a617661736372697074\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个长度为 10、且用 30 填充的 Buffer。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e buf1 = Buffer.alloc(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(buf1)\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;Buffer 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 字符串转Buffer\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e buf2 = Buffer.from(\x3cspan class=\x22hljs-string\x22\x3e\x27javascript\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(buf2)\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;Buffer 6a 61 76 61 73 63 72 69 70 74\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 字符串转 buffer\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(buf2.toString())\x3cspan class=\x22hljs-comment\x22\x3e\/\/ javascript\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(buf2.toString(\x3cspan class=\x22hljs-string\x22\x3e\x27hex\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/6a617661736372697074\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个 Buffer 类似于一个整数数组，可以取下标，有length属性，有剪切复制操作等，很多API也类似数组，但Buffer的大小在被创建时确定，且无法调整。Buffer处理的是字节，两位十六进制，因此在整数范围就是0～255。\x3c\/p\x3e\n\x3cp\x3e可以看到，Buffer可以与string互相转化，还可以设置字符集编码。Buffer用来处理文件I／O、网络I\/O传输的二进制数据，string用来呈现。在处理文件I／O、网络I\/O传输的二进制数据时，应该尽量以Buffer形式直接传输，速度会得到很好的提升，但操作字符串比操作Buffer还是快很多的。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eBuffer内存分配与性能优化\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eBuffer是一个典型的javascript与C\x2b\x2b结合的模块，与性能有关的用C\x2b\x2b来实现，javascript 负责衔接和提供接口。Buffer所占的内存不是V8分配的，是独立于V8堆内存之外的内存，通过C\x2b\x2b层面实现内存申请、javascript 分配内存。值得一提的是，每当我们使用\x3ccode\x3eBuffer.alloc(size)\x3c\/code\x3e请求一个Buffer内存时，Buffer会以8KB为界限来判断分配的是大对象还是小对象，小对象存入剩余内存池，不够再申请一个8KB的内存池；大对象直接采用C\x2b\x2b层面申请的内存。因此，对于一个大尺寸对象，申请一个大内存比申请众多小内存池快很多。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e流Stream\x3c\/h3\x3e\n\x3cp\x3e前面讲到，流类比水流形容数据的流动，在文件I\/O、网络I／O中数据的传输都可以称之为流，流是能统一描述所有常见输入输出类型的模型，是顺序读写字节序列的抽象表示。数据从A端流向B端与从B端流向A端是不一样的，因此，流是有方向的。A端输入数据到B端，对B就是输入流，得到的对象就是可读流；对A就是输出端、得到的对象是可写流。有的流即可以读又可以写，如TCP连接，Socket连接等，称为读写流(\x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_duplex\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDuplex\x3c\/a\x3e)。还有一种在读写过程中可以修改和变换数据的读写流称为\x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_transform\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTransform\x3c\/a\x3e流。\x3c\/p\x3e\n\x3cp\x3e在node中，这些流中的数据就是Buffer对象，可读、可写流会将数据存储到\x3cstrong\x3e内部\x3c\/strong\x3e的缓存中，等待被消费；\x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_duplex\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDuplex\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_transform\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTransform\x3c\/a\x3e 则是都维护了\x3cstrong\x3e两个相互独立\x3c\/strong\x3e的缓存用于读和写。 在维持了合理高效的数据流的同时，也使得对于读和写可以独立进行而互不影响。\x3c\/p\x3e\n\x3cp\x3e在node中，这四种流都是EventEmitter的实例，它们都有close、error事件，可读流具有监听数据到来的data事件等，可写流则具有监听数据已传给低层系统的finish事件等，\x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_duplex\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDuplex\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_transform\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTransform\x3c\/a\x3e 都同时实现了 \x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_readable\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReadable\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/nodejs.cn\/api\/stream.html#stream_class_stream_writable\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWritable\x3c\/a\x3e 的事件和接口    。\x3c\/p\x3e\n\x3cp\x3e值得一提的是writable的drain事件，这个事件表示\x3ccode\x3e缓存的数据被排空了\x3c\/code\x3e。为什么有这个事件呢？起因是调用可写流的write和可读流的read都会有一个缓存区用来缓存写／读的数据，缓存区是有大小的，一旦写的内容超过这个大小，write方法就会返回false，表示写入停止，这时如果继续read完缓存区数据，缓存区被排空，就会触发drain事件，可以这样来防止缓存区爆仓：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var rs = fs.createReadStream(src);\nvar ws = fs.createWriteStream(dst);\n\nrs.on(\x27data\x27, function (chunk) {\n    if (ws.write(chunk) === false) {\n        rs.pause();\n    }\n});\n\nrs.on(\x27end\x27, function () {\n    ws.end();\n});\n\nws.on(\x27drain\x27, function () {\n    rs.resume();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rs = fs.createReadStream(src);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ws = fs.createWriteStream(dst);\n\nrs.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3echunk\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ws.write(chunk) === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n        rs.pause();\n    }\n});\n\nrs.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    ws.end();\n});\n\nws.on(\x3cspan class=\x22hljs-string\x22\x3e\x27drain\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    rs.resume();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一些常见流分类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e可写流：HTTP requests, on the client、HTTP responses, on the server、fs write streams、zlib streams、crypto streams、TCP sockets、child process stdin、process.stdout, process.stderr\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可读流：HTTP responses, on the client、HTTP requests, on the server、fs read streams、zlib streams、crypto streams、TCP sockets、child process stdout and stderr、process.stdin\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可读可写流：TCP sockets、zlib streams、crypto streams\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e变换流：zlib streams、crypto streams\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外，提到流就不得不提到\x3cstrong\x3e管道\x3c\/strong\x3e的概念，这个概念也非常形象：水流从一端到另一端流动需要管道作为通道或媒介。流也是这样，数据在端之间的传送也需要管道，在node中是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将 readable 中的所有数据通过管道传递给名为 file.txt 的文件\nconst readable = getReadableStreamSomehow();\nconst writable = getWritableStreamSomehow(\x27file.txt\x27);\n\/\/ readable 中的所有数据都传给了 \x27file.txt\x27\nreadable.pipe(writable);\n\n\/\/ 对流进行链式地管道操作\nconst r = fs.createReadStream(\x27file.txt\x27);\nconst z = zlib.createGzip();\nconst w = fs.createWriteStream(\x27file.txt.gz\x27);\nr.pipe(z).pipe(w);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 readable 中的所有数据通过管道传递给名为 file.txt 的文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e readable = getReadableStreamSomehow();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e writable = getWritableStreamSomehow(\x3cspan class=\x22hljs-string\x22\x3e\x27file.txt\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ readable 中的所有数据都传给了 \x27file.txt\x27\x3c\/span\x3e\nreadable.pipe(writable);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对流进行链式地管道操作\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r = fs.createReadStream(\x3cspan class=\x22hljs-string\x22\x3e\x27file.txt\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e z = zlib.createGzip();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e w = fs.createWriteStream(\x3cspan class=\x22hljs-string\x22\x3e\x27file.txt.gz\x27\x3c\/span\x3e);\nr.pipe(z).pipe(w);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，只有可读流才具有pipe能力，可写流作为目的地。\x3c\/p\x3e\n\x3cp\x3epipe不仅可以作为通道，还能很好的控制管道里的流，控制读和写的平衡，不让任一方过度操作。另外，pipe可以监听可读流的data、end事件，这样就可以构建快速的响应：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 一个文件下载的例子，使用回调函数的话需要等到服务器读取完文件才能向浏览器发送数据\nvar http = require(\x27http\x27) ;\nvar fs = require(\x27fs\x27) ;\nvar server = http.createServer(function (req, res) {\n    fs.readFile(__dirname \x2b \x27\/data.txt\x27, function (err, data) {\n        res.end(data);\n    }) ;\n}) ;\nserver.listen(8888) ;\n\n\/\/ 而采用流的方式，只要建立连接，就会接受到数据，不用等到服务器缓存完data.txt\nvar http = require(\x27http\x27) \nvar fs = require(\x27fs\x27) \nvar server = http.createServer(function (req, res) {\n    var stream = fs.createReadStream(__dirname \x2b \x27\/data.txt\x27) \n    stream.pipe(res) \n}) \nserver.listen(8888) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个文件下载的例子，使用回调函数的话需要等到服务器读取完文件才能向浏览器发送数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e http = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e) ;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e) ;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e server = http.createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n    fs.readFile(__dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/data.txt\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\n        res.end(data);\n    }) ;\n}) ;\nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8888\x3c\/span\x3e) ;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而采用流的方式，只要建立连接，就会接受到数据，不用等到服务器缓存完data.txt\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e http = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e) \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e) \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e server = http.createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stream = fs.createReadStream(__dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/data.txt\x27\x3c\/span\x3e) \n    stream.pipe(res) \n}) \nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8888\x3c\/span\x3e) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，使用pipe即可解决上面那个爆仓问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3efs文件模块\x3c\/h3\x3e\n\x3cp\x3efs文件模块是高阶模块，继承了EventEmitter、stream、path等底层模块，提供了对文件的操作，包括文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统等操作。与node设计思想和其他模块不同的是，fs模块中的所有操作都提供了\x3cstrong\x3e异步和同步\x3c\/strong\x3e两个版本。fs模块主要由下面几部分组成:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e对底层POSIX文件系统的封装,对应于操作系统的原生文件操作\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e继承Stream的文件流 fs.createReadStream和fs.createWriteStream\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e同步文件操作方法，如fs.readFileSync、fs.writeFileSync\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e异步文件操作方法， fs.readFile和fs.writeFile\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e模块API架构如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/segmentfault.com\/img\/remote\/1460000004957227\x22 src=\x22https:\/\/static.alili.techhttps:\/\/segmentfault.com\/img\/remote\/1460000004957227\x22 alt=\x22fs主要操作\x22 title=\x22fs主要操作\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e读写操作：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27); \/\/ 引入fs模块\n\/* 读文件 *\/\n\n\/\/ 使用流\nconst read = fs.createReadStream(\x27sam.js\x27,{encoding:\x27utf8\x27});\nread.on(\x27data\x27,(str)=\x3e{\n    console.log(str);\n})\n\/\/ 使用readFile\nfs.readFile(\x27test.txt\x27, {}, function(err, data) {\n    if (err) {\n        throw err;\n    }\n    console.log(data);\n});\n\/\/ open \x2b read\nfs.open(\x27test.txt\x27,\x27r\x27,(err, fd) =\x3e {\n    fs.fstat(fd,(err,stat)=\x3e{\n        var len = stat.size;  \/\/检测文件长度\n        var buf = new Buffer(len);\n        fs.read(fd,buf,0,len,0,(err,bw,buf)=\x3e{\n            console.log(buf.toString(\x27utf8\x27));\n            fs.close(fd);\n        })\n    });\n});\n\n\/* 写文件与读取文件API形式类似 *\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入fs模块\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 读文件 *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用流\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e read = fs.createReadStream(\x3cspan class=\x22hljs-string\x22\x3e\x27sam.js\x27\x3c\/span\x3e,{\x3cspan class=\x22hljs-attr\x22\x3eencoding\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e});\nread.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,(str)=\x26gt;{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str);\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用readFile\x3c\/span\x3e\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27test.txt\x27\x3c\/span\x3e, {}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ open \x2b read\x3c\/span\x3e\nfs.open(\x3cspan class=\x22hljs-string\x22\x3e\x27test.txt\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27r\x27\x3c\/span\x3e,(err, fd) =\x26gt; {\n    fs.fstat(fd,(err,stat)=\x26gt;{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = stat.size;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/检测文件长度\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e buf = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Buffer(len);\n        fs.read(fd,buf,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,len,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,(err,bw,buf)=\x26gt;{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(buf.toString(\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e));\n            fs.close(fd);\n        })\n    });\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 写文件与读取文件API形式类似 *\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e读\/写文件都有三种方式，那么区别是什么呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ecreateReadStream\/createWriteStream创建一个将文件内容读取为流数据的ReadStream对象，这个方法主要目的就是把数据读入到流中，得到是可读流，方便以流进行操作\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ereadFile\/writeFile：Node.js会将文件内容视为一个整体，为其分配缓存区并且一次性将文件内容读\/写取到缓存区中，在这个期间，Node.js将不能执行任何其他处理，所以当读写大文件的时候，有可能造成缓存区“爆仓”\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eread\/write读\/写文件内容是不断地将文件中的一小块内容读\/写入缓存区，最后从该缓存区中读取文件内容\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e同步API也是如此。其中最常用的是readFile，读取大文件则采取用，read则提供更为细节、底层的操作，而且read要配合open。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e获取文件的状态：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fs.stat(\x27eda.txt\x27, (err, stat) =\x3e {\n  if (err)\n    throw err\n  console.log(stat)\n})\n\/* \nStats {\n  dev: 16777220,\n  mode: 33279,\n  nlink: 1,\n  uid: 501,\n  gid: 20,\n  rdev: 0,\n  blksize: 4194304,\n  ino: 4298136825,\n  size: 0,\n  blocks: 0,\n  atimeMs: 1510317983760.94, - 文件数据最近被访问的时间\n  mtimeMs: 1510317983760.94, - 文件数据最近被修改的时间。\n  ctimeMs: 1510317983777.8538, - 文件状态最近更改的时间\n  birthtimeMs: 1509537398000,\n  atime: 2017-11-10T12:46:23.761Z,\n  mtime: 2017-11-10T12:46:23.761Z,\n  ctime: 2017-11-10T12:46:23.778Z,\n  birthtime: 2017-11-01T11:56:38.000Z \n}*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3efs.stat(\x3cspan class=\x22hljs-string\x22\x3e\x27eda.txt\x27\x3c\/span\x3e, (err, stat) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(stat)\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/* \nStats {\n  dev: 16777220,\n  mode: 33279,\n  nlink: 1,\n  uid: 501,\n  gid: 20,\n  rdev: 0,\n  blksize: 4194304,\n  ino: 4298136825,\n  size: 0,\n  blocks: 0,\n  atimeMs: 1510317983760.94, - 文件数据最近被访问的时间\n  mtimeMs: 1510317983760.94, - 文件数据最近被修改的时间。\n  ctimeMs: 1510317983777.8538, - 文件状态最近更改的时间\n  birthtimeMs: 1509537398000,\n  atime: 2017-11-10T12:46:23.761Z,\n  mtime: 2017-11-10T12:46:23.761Z,\n  ctime: 2017-11-10T12:46:23.778Z,\n  birthtime: 2017-11-01T11:56:38.000Z \n}*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e监听文件：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const FSWatcher = fs.watch(\x27eda.txt\x27, (eventType, filename) =\x3e {\n    console.log(`${eventType}`)\n})\nFSWatcher.on(\x27change\x27, (eventType, filename) =\x3e {\n    console.log(`${filename}`)\n})\n\/\/ watch和返回的FSWatcher实例的回调函数都绑定在了 change 事件上\n\nfs.watchFile(\x27message.text\x27, (curr, prev) =\x3e {\n  console.log(`the current mtime is: ${curr.mtime}`);\n  console.log(`the previous mtime was: ${prev.mtime}`);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FSWatcher = fs.watch(\x3cspan class=\x22hljs-string\x22\x3e\x27eda.txt\x27\x3c\/span\x3e, (eventType, filename) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${eventType}\x3c\/span\x3e`\x3c\/span\x3e)\n})\nFSWatcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x27change\x27\x3c\/span\x3e, (eventType, filename) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${filename}\x3c\/span\x3e`\x3c\/span\x3e)\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ watch和返回的FSWatcher实例的回调函数都绑定在了 change 事件上\x3c\/span\x3e\n\nfs.watchFile(\x3cspan class=\x22hljs-string\x22\x3e\x27message.text\x27\x3c\/span\x3e, (curr, prev) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`the current mtime is: \x3cspan class=\x22hljs-subst\x22\x3e${curr.mtime}\x3c\/span\x3e`\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`the previous mtime was: \x3cspan class=\x22hljs-subst\x22\x3e${prev.mtime}\x3c\/span\x3e`\x3c\/span\x3e);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e监听文件仍然有两种方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ewatch 调用的是底层的API来监视文件，很快，可靠性也较高\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewatchFile 是通过不断轮询 \x3ccode\x3efs.Stat\x3c\/code\x3e （文件的统计数据）来获取被监视文件的变化，较慢，可靠性较低，另外回调函数的参数是 \x3ccode\x3efs.Stat\x3c\/code\x3e 实例\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e因此尽可能多的使用watch，watchFile 用于需要得到文件更多信息的场景。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e其他\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e创建、删除、复制、移动、重命名、检查文件、修改权限...\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e由Buffer到Stream，再到fs文件模块，将它们串联起来能对整块知识有更清晰的认识，也对webpack、gulp等前端自动化工具构建工作流的机制和实现有了更深的了解。学习其他知识亦是如此——知道来龙去脉，知道为什么会存在，知道它们之间的联系，就能让碎片化的知识串联起来，能让它们make sense，能够让自己“上的厅堂、下得厨房”。\x3c\/p\x3e\n\x3cp\x3e参考：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004957223\x22\x3enodeJs高阶模块--fs\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/yjhjstz\/deep-into-node\/blob\/master\/chapter11\/chapter11-4.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edeep into node\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>认识node核心模块&ndash;从Buffer、Stream到fs</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011968267">https://segmentfault.com/a/1190000011968267</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/gvpfixfz84j/" target="_blank">https://alili.tech/archive/gvpfixfz84j/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>