<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端开发的客户端本地存储"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端开发的客户端本地存储 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/gycygxpqvtd/",
				"appid": "1613049289050283", 
				"title": "前端开发的客户端本地存储 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-17T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/q77e6mbwjic/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ye6ktjneh6n/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&text=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&text=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&title=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&title=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&title=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&title=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgycygxpqvtd%2f&title=%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端开发的客户端本地存储</h1><div class="meta"><div class="postdate"><time datetime="2018-12-17" itemprop="datePublished">2018-12-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在前端开发过程中，为了与服务器更方便的交互或者提升用户体验，我们都会在客户端（用户）本地保存一部分数据，比如\x3ccode\x3ecookie\/localStorage\/sessionStorage\x3c\/code\x3e。在后端管理系统的前端，更是会涉及到一部分超大数据的请求，一个接口有时会达到5M甚至15M的程度，当这个接口数据并不是经常更新时，我们可以用两种方式，一种是分页请求\x2b预加载\x2b懒加载，另一种就是本地存储\x2b热更新。而由于第二种方式用户体验更优秀，便是我常用的方式。\x3c\/p\x3e\n\x3cp\x3e这篇文章的客户端本地存储，我们主要讲到\x3ccode\x3ecookie\/localStorage\/sessionStorage\/indexedDB\x3c\/code\x3e四种技术。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e\x3ccode\x3ecookie\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eHTTP Cookie\x3c\/code\x3e通常简称\x3ccode\x3ecookie\x3c\/code\x3e，该标准用于浏览器存储会话信息，在发起HTTP请求时携带\x3ccode\x3eCookie\x3c\/code\x3e参数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Request Header \n\nGET \/oss\/index.php?r=api\/jlog\/collect HTTP\/1.1\nHost: gzhxy.baidu.com:8090\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/63.0.3239.84 Safari\/537.36\n\n···\n\nCookie: name=Leon; age=24\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Request Header \x3c\/span\x3e\n\nGET \x3cspan class=\x22hljs-regexp\x22\x3e\/oss\/\x3c\/span\x3eindex.php?r=api\/jlog\/collect HTTP\/1.1\nHost: gzhxy.baidu.\x3cspan class=\x22hljs-string\x22\x3ecom:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e8090\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eConnection:\x3c\/span\x3e keep-alive\n\x3cspan class=\x22hljs-string\x22\x3ePragma:\x3c\/span\x3e no-cache\nCache-\x3cspan class=\x22hljs-string\x22\x3eControl:\x3c\/span\x3e no-cache\nX-Requested-\x3cspan class=\x22hljs-string\x22\x3eWith:\x3c\/span\x3e XMLHttpRequest\nUser-\x3cspan class=\x22hljs-string\x22\x3eAgent:\x3c\/span\x3e Mozilla\x3cspan class=\x22hljs-regexp\x22\x3e\/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit\/\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e537.36\x3c\/span\x3e (KHTML, like Gecko) Chrome\x3cspan class=\x22hljs-regexp\x22\x3e\/63.0.3239.84 Safari\/\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e537.36\x3c\/span\x3e\n\n···\n\x3cspan class=\x22hljs-symbol\x22\x3e\nCookie:\x3c\/span\x3e name=Leon; age=\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eCookie\x3c\/code\x3e有一些限制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e它是以\x3ccode\x3e; \x3c\/code\x3e（分号\x2b一个空格）分割的键值对字符串，在网络传送时必须是URL编码的。\x3c\/li\x3e\n\x3cli\x3e绑定在固定域名下，不允许其它域名访问。\x3c\/li\x3e\n\x3cli\x3e有些浏览器有数量限制，在超出后删除顺序不统一，有些最近最少使用\x3ccode\x3e（LRU）\x3c\/code\x3e，有些随机删\x3c\/li\x3e\n\x3cli\x3e同一域名下总大小限制\x3ccode\x3e5KB\x3c\/code\x3e，超出限制后静默失败\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3eCookie\x3c\/code\x3e的参数构成：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e名称：唯一确定，不区分大小写（实际编写建议区分），必须URL编码\x3c\/li\x3e\n\x3cli\x3e值：字符串值，必须URL编码\x3c\/li\x3e\n\x3cli\x3e域：该\x3ccode\x3ecookie\x3c\/code\x3e字段有效的域，可以为\x3ccode\x3ebaidu.com\x3c\/code\x3e域名，也可以为\x3ccode\x3ecdn.baidu.com\x3c\/code\x3e子域名，缺省值为当前页面子域名\x3c\/li\x3e\n\x3cli\x3e路径：该\x3ccode\x3ecookie\x3c\/code\x3e字段有效范围为指定域下的具体路径，如\x3ccode\x3ecdn.baidu.com\/oss\x3c\/code\x3e，那么其他路径就无法访问\x3c\/li\x3e\n\x3cli\x3e失效时间：\x3ccode\x3ecookie\x3c\/code\x3e被删除的时间戳，缺省值为浏览器会话结束被删除，也可以手动设置，时间格式为\x3ccode\x3eGMT\x3c\/code\x3e格式\x3ccode\x3eWdy, DD-Mon-YYYY HH:MM:SS GMT\x3c\/code\x3e，可以调用\x3ccode\x3eDate\x3c\/code\x3e实例的\x3ccode\x3etoGMTString()\x3c\/code\x3e方法转换，如果设置为过去的时间，该\x3ccode\x3ecookie\x3c\/code\x3e被立刻删除\x3c\/li\x3e\n\x3cli\x3e安全标志：为单词\x3ccode\x3esecure\x3c\/code\x3e而非键值对，指定后，只有在\x3ccode\x3eSSL\x3c\/code\x3e连接的时候才会被发送到服务器，也就是\x3ccode\x3ehttps\x3c\/code\x3e协议\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e注意参数中只有名称和值才会被发送给服务器，其余的只是需要浏览器识别的命令式参数。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecookie\x3c\/code\x3e的接口设置非常的不人性化，往往需要我们对其操作进行封装才会方便使用。下面我们对其进行增删查改。\x3c\/p\x3e\n\x3cp\x3e查看cookie：\x3ccode\x3edecodeURIComponent(document.cookie);\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e添加或修改cookie：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 需要改成自己需要的cookie和域名、路径以及是否为https\ndocument.cookie = \x27encodeURIComponent(name)=encodeURIComponent(Leon); expries=\x27 \x2b (new Date(Date.now() \x2b 24*60*60*1000)).toGMTString() \x2b \x27; path=oss; domain=cdn.baidu.com; secure\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要改成自己需要的cookie和域名、路径以及是否为https\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie = \x3cspan class=\x22hljs-string\x22\x3e\x27encodeURIComponent(name)=encodeURIComponent(Leon); expries=\x27\x3c\/span\x3e \x2b (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() \x2b \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e*\x3cspan class=\x22hljs-number\x22\x3e60\x3c\/span\x3e*\x3cspan class=\x22hljs-number\x22\x3e60\x3c\/span\x3e*\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)).toGMTString() \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27; path=oss; domain=cdn.baidu.com; secure\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e删除cookie: \x3ccode\x3edocument.cookie = \x27name=Leon; expires=\x27 \x2b (new Date(0)).toGMTString();\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e具体的封装的方式网上有很多，可以去搜一搜，核心就是对\x3ccode\x3ecookie\x3c\/code\x3e进行字符串检索和切分，以及将传入的函数参数最终转换为字符串。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3ccode\x3eStorage\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3e由于\x3ccode\x3ecookie\x3c\/code\x3e的大小限制和需要全量传递给服务器，在很多场景下并不适用，所以\x3ccode\x3eHTML5\x3c\/code\x3e规范中出现了\x3ccode\x3eStorage\x3c\/code\x3e对象，包含\x3ccode\x3elocalStorage\x3c\/code\x3e和\x3ccode\x3esessionStorage\x3c\/code\x3e两种继承对象，属于\x3ccode\x3ewindow\x3c\/code\x3e的属性。它提供了通常\x3ccode\x3e5M\x3c\/code\x3e的大小空间来保存无需服务器交互的本地数据。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eStorage\x3c\/code\x3e的常用方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eclear()\x3c\/code\x3e: 清除所有值\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3egetItem(name)\x3c\/code\x3e: 获取指定name的值\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ekey(index)\x3c\/code\x3e: 获得对应索引值的键名\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eremoveItem(name)\x3c\/code\x3e: 删除指定name的键值对\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esetItem(name, value)\x3c\/code\x3e: 为指定name设置对应的值\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e除了这些方法之外，\x3ccode\x3eStorage\x3c\/code\x3e对象可以直接通过点语法或者方括号语法访问属性和操作属性，也可以通过\x3ccode\x3edelete\x3c\/code\x3e关键字删除属性。该对象中的值均为字符串。\x3c\/p\x3e\n\x3cp\x3e持久化数据\x3ccode\x3elocalStorage\x3c\/code\x3e通常保留到JS删除或者用户清除浏览器缓存。\x3c\/p\x3e\n\x3cp\x3e会话数据\x3ccode\x3esessionStorage\x3c\/code\x3e保留到关闭浏览器。由于绑定会话窗口，所以不支持本地文件读写。另外在IE8中，该对象为异步读写，需要调用\x3ccode\x3ebegin()\x3c\/code\x3e和\x3ccode\x3ecommit()\x3c\/code\x3e方法保证成功读取，不再赘述。\x3c\/p\x3e\n\x3cp\x3e对\x3ccode\x3eStorage\x3c\/code\x3e对象做任何的新增，修改或者删除操作，都会触发\x3ccode\x3estorage\x3c\/code\x3e事件。该事件只支持在与服务端通信时，一个页面修改，另一个页面会触发该事件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.addEventListener(\x27storage\x27, function (e) {\n    console.log(e);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27storage\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该事件对象的主要属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3edomain\x3c\/code\x3e: 发生变化的存储空间的域名\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ekey\x3c\/code\x3e：修改的键名\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3enewValue\x3c\/code\x3e：如果是设置值，则为新值；如果删除，则为\x3ccode\x3enull\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eoldValue\x3c\/code\x3e：更改前的值\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\x3ccode\x3eIndexedDB\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3e拥有了\x3ccode\x3eStorage\x3c\/code\x3e利器，已经能解决很多问题，但是通常\x3ccode\x3e5M\x3c\/code\x3e的大小限制还是会限制一部分场景，比如后台管理系统的接口数据很容易突破\x3ccode\x3e5M\x3c\/code\x3e，这个时候就需要我们的浏览器数据库\x3ccode\x3eIndexedDB\x3c\/code\x3e了。其实在此之前，各家厂商主要推广的是\x3ccode\x3eWeb SQL Database\x3c\/code\x3e，不过后来被废弃了，虽然现在在部分平台上也能使用，但我们不做介绍了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eIndexedDB\x3c\/code\x3e数据库用于浏览器保存结构化数据，区别于传统数据库它保存的是对象，完全采用事务类型，所有的操作被转换为请求的方式，所以我们需要对每一步操作添加回调函数。\x3c\/p\x3e\n\x3cp\x3e一个完整的实例为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 判断能否正确打开数据库，避免多次检测\nlet dbOpened = false;\n\/\/ 打开本地持久化数据库，默认版本为1\nconst request = indexedDB.open(\x27jomocha\x27);\n\/\/ 当打开错误时\nrequest.onerror = function(event){\n    console.error(\x27打开本地持久化数据错误\x27, event);\n    OSS.commonUI.showMsg(\x27打开本地持久化数据库错误，试用功能，不影响使用，请联系zhaoshuaiqiang\x27, \x27error\x27);\n};\n\/\/ 当数据库首次创建该版本时（首次创建或更新版本）\nrequest.onupgradeneeded = function(event){\n    const db = event.target.result;\n    \/\/ 创建一个数据库存储对象，保存所有的维度项，分为name和list两个属性\n    const objectStore = db.createObjectStore(\x27dimensions\x27, {\n        keyPath: \x27name\x27\n    });\n    \/\/ 定义存储对象的数据项属性\n    objectStore.createIndex(\x27name\x27, \x27name\x27, {\n        unique: true\n    });\n};\n\/\/ 成功打开了数据库\nrequest.onsuccess = function(event){\n    dbOpened = true;\n    const db = event.target.result;\n    \/\/ 新建一个事务，包含oncomplete 和onerror句柄事件，缺省值为readonly，只读模式，可并行\n    const transaction = db.transaction([\x27dimensions\x27]);\n    \/\/ 打开存储对象\n    const objectStore = transaction.objectStore(\x27dimensions\x27);\n    const request = objectStore.get(\x27host\x27);\n    request.onsuccess = function (event) {\n        \/\/ 第一次打开数据库时，肯定没有数据，所以需要检测\n        if (event.target.result) {\n            JomoCha.data = event.target.result.list;\n        }\n    };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断能否正确打开数据库，避免多次检测\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dbOpened = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开本地持久化数据库，默认版本为1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = indexedDB.open(\x3cspan class=\x22hljs-string\x22\x3e\x27jomocha\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当打开错误时\x3c\/span\x3e\nrequest.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27打开本地持久化数据错误\x27\x3c\/span\x3e, event);\n    OSS.commonUI.showMsg(\x3cspan class=\x22hljs-string\x22\x3e\x27打开本地持久化数据库错误，试用功能，不影响使用，请联系zhaoshuaiqiang\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e);\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当数据库首次创建该版本时（首次创建或更新版本）\x3c\/span\x3e\nrequest.onupgradeneeded = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e db = event.target.result;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个数据库存储对象，保存所有的维度项，分为name和list两个属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e objectStore = db.createObjectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e, {\n        \x3cspan class=\x22hljs-attr\x22\x3ekeyPath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义存储对象的数据项属性\x3c\/span\x3e\n    objectStore.createIndex(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e, {\n        \x3cspan class=\x22hljs-attr\x22\x3eunique\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    });\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 成功打开了数据库\x3c\/span\x3e\nrequest.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n    dbOpened = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e db = event.target.result;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建一个事务，包含oncomplete 和onerror句柄事件，缺省值为readonly，只读模式，可并行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开存储对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = objectStore.get(\x3cspan class=\x22hljs-string\x22\x3e\x27host\x27\x3c\/span\x3e);\n    request.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一次打开数据库时，肯定没有数据，所以需要检测\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (event.target.result) {\n            JomoCha.data = event.target.result.list;\n        }\n    };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e数据库\x3c\/h3\x3e\n\x3cp\x3e当我们需要使用\x3ccode\x3eIndexedDB\x3c\/code\x3e时，首先要调用\x3ccode\x3eindexedDB.open()\x3c\/code\x3e方法打开数据库，如果该数据存在，则发起打开的请求，如果不存在，则发起创建并打开的请求。该方法会返回一个\x3ccode\x3eIDBRequest\x3c\/code\x3e对象，可以在该对象上添加回调方法。具体的方法如示例中的最外层请求。\x3c\/p\x3e\n\x3cp\x3e回调函数传入的事件属性\x3ccode\x3eevent.target\x3c\/code\x3e就指向该请求，即\x3ccode\x3erequest\x3c\/code\x3e。如果发生了错误，\x3ccode\x3eevent.target.errorCode\x3c\/code\x3e将会保存错误信息的错误码；如果成功，\x3ccode\x3eevent.target.result\x3c\/code\x3e就会保存一个数据库实例对象。\x3c\/p\x3e\n\x3cp\x3e错误码列表（第二个开始省略前缀\x3ccode\x3eIDBDatabaseException.\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eIDBDatabaseException.UNKNOWN_ERR(1)\x3c\/code\x3e：意外错误，无法归类\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eNON_TRANSIENT_ERR(2)\x3c\/code\x3e：操作不合法\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eNOT_FOUND_ERR(3)\x3c\/code\x3e：未发现要操作的数据库\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eCONSTRAINT_ERR(4)\x3c\/code\x3e：违反了数据库约束\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eDATA_ERR(5)\x3c\/code\x3e：提供给事务的数据不满足要求\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eNOT_ALLOWED_ERR(6)\x3c\/code\x3e：操作不合法\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eTRANSACTION_INACTIVE_ERR(7)\x3c\/code\x3e：试图重用已完成的事务\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eABORT_ERR(8)\x3c\/code\x3e：请求中断，未完成\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eREAD_ONLY_ERR(9)\x3c\/code\x3e：试图在只读模式下写入或修改数据\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eTIMEOUT_ERR(10)\x3c\/code\x3e：在有效时间内未完成操作\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eQUOTA_ERR(11)\x3c\/code\x3e：磁盘空间不足\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e对象存储空间（表）\x3c\/h3\x3e\n\x3cp\x3e成功打开数据库之后，我们就可以打开对象存储空间了，你可以把它理解成数据库中的表，用于保存不同的数据，如用户、交易、购物车等。下面的所有\x3ccode\x3edb\x3c\/code\x3e代表成功回调中的数据库对象.\x3c\/p\x3e\n\x3cp\x3e我们先调用\x3ccode\x3edb.createObjectStore(\x27dimensions\x27, {keyPath:\x27name\x27});\x3c\/code\x3e来创建一张表，这个\x3ccode\x3edimensions\x3c\/code\x3e为唯一表名，其中的\x3ccode\x3ekeyPath\x3c\/code\x3e属性指定该表的键名，后面存储的所有数据都必须拥有该属性。\x3c\/p\x3e\n\x3cp\x3e看下写入数据库的实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 每次同步更新最新数据\n$.ajax({\n    url: \x27?r=tools\/api\/hosts\x27,\n    success: function (data) {\n        \/\/ 如果能够打开本地数据库，则保存\n        if (dbOpened) {\n            const request = indexedDB.open(\x27jomocha\x27);\n            request.onsuccess = function(event){\n                const db = event.target.result;\n                \/\/ 新建一个事务，读写模式，不可并行\n                const transaction = db.transaction([\x27dimensions\x27], \x27readwrite\x27);\n                \/\/ 打开存储对象\n                const objectStore = transaction.objectStore(\x27dimensions\x27);\n                \/\/ 使用put方法，有则修改，没有则添加\n                const request = objectStore.put({\n                    name: \x27host\x27,\n                    list: data.data\n                });\n            }\n        }\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每次同步更新最新数据\x3c\/span\x3e\n$.ajax({\n    \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27?r=tools\/api\/hosts\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esuccess\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果能够打开本地数据库，则保存\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dbOpened) {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = indexedDB.open(\x3cspan class=\x22hljs-string\x22\x3e\x27jomocha\x27\x3c\/span\x3e);\n            request.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e db = event.target.result;\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建一个事务，读写模式，不可并行\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27readwrite\x27\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开存储对象\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用put方法，有则修改，没有则添加\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = objectStore.put({\n                    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27host\x27\x3c\/span\x3e,\n                    \x3cspan class=\x22hljs-attr\x22\x3elist\x3c\/span\x3e: data.data\n                });\n            }\n        }\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里写入数据库的对象里就包含了\x3ccode\x3ename\x3c\/code\x3e参数。我们拿到数据使用\x3ccode\x3eadd()\x3c\/code\x3e或\x3ccode\x3eput()\x3c\/code\x3e方法添加数据，这两种方法区别在于遇到相同的键名存在时，\x3ccode\x3eadd()\x3c\/code\x3e报错，\x3ccode\x3eput()\x3c\/code\x3e修改原有值。这两种方法依然为请求，可以对其指定\x3ccode\x3eonsuccess()\x3c\/code\x3e或\x3ccode\x3eonerror()\x3c\/code\x3e事件处理回调，示例中省略了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e事务\x3c\/h3\x3e\n\x3cp\x3e在创建完成数据后，就可以对其进行查询了，\x3ccode\x3eindexedDB\x3c\/code\x3e中所有读写操作都要通过事务，我们调用\x3ccode\x3edb.transaction();\x3c\/code\x3e方法来打开所有存储空间（表），也可以传入参数来控制我们需要打开的表：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 打开一张表\ndb.transaction(\x27user\x27);\n\/\/ 打开多张表\ndb.transaction([\x27user\x27, \x27dimensions\x27]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开一张表\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3edb\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.transaction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27user\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开多张表\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3edb\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.transaction\x3c\/span\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27user\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该方法还接受第二个参数作为访问方式，包含3种：\x3ccode\x3ereadonly\x3c\/code\x3e(缺省值)、\x3ccode\x3ereadwrite\x3c\/code\x3e、\x3ccode\x3eversionchange\x3c\/code\x3e。最后一个比较特别，为在版本更新时使用，不可以与其他事务并发执行，允许任何操作，包括删除和创建索引。\x3c\/p\x3e\n\x3cp\x3e现在通过事务我们已经确定了操作空间，接下来就可以获取具体的数据对象了，下面的\x3ccode\x3etransaction\x3c\/code\x3e代表着上面的\x3ccode\x3edb.transaction()\x3c\/code\x3e方法返回的事务。事务可以执行多个请求，本身也是一个请求，可以指定相应的\x3ccode\x3eoncomplete()\x3c\/code\x3e和\x3ccode\x3eonerror()\x3c\/code\x3e事件处理回调。其中的\x3ccode\x3eoncomplete()\x3c\/code\x3e事件不能拿到该事务中请求的数据。\x3c\/p\x3e\n\x3cp\x3e使用\x3ccode\x3etransaction.objectStore(\x27dimension\x27);\x3c\/code\x3e获取数据对象，然后就可以通过\x3ccode\x3eadd\/put\/get\/delete\/clear\x3c\/code\x3e方法进行增删查改，均为请求，需要设置\x3ccode\x3eonsuccess()\x3c\/code\x3e和\x3ccode\x3eonerror()\x3c\/code\x3e回调。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e游标遍历\x3c\/h3\x3e\n\x3cp\x3e我们可以使用\x3ccode\x3eget()\x3c\/code\x3e方法检索出具体的单个对象，但是如果需要遍历，我们就要使用到游标查询了，也就是指定范围，然后遍历数据。下面的\x3ccode\x3eobjectStore\x3c\/code\x3e指代上面\x3ccode\x3etransaction.objectStore()\x3c\/code\x3e返回的数据对象集。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 指定游标范围\nconst cursorRange = IDBKeyRange.bound(\x27001\x27, \x27100\x27);\n\/\/ 打开游标查询\nconst request = objectStore.openCursor(cursorRange);\nrequest.onsuccess = function (event) {\n    const cursor = event.target.result;\n    \/\/ 必须检查cursor是否存在，如果该项存在，则为IDBCursor实例，否则为null\n    if (cursor) {\n        console.log(cursor.key \x2b \x27: \x27 \x2b cursor.value);\n        cursor.continue();\n    } else {\n        console.log(\x27遍历完成\x27);\n    }\n}\nrequest.onerror = function (event) {\n    console.error(\x27游标区间获取失败\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定游标范围\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cursorRange = IDBKeyRange.bound(\x3cspan class=\x22hljs-string\x22\x3e\x27001\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27100\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开游标查询\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = objectStore.openCursor(cursorRange);\nrequest.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cursor = event.target.result;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 必须检查cursor是否存在，如果该项存在，则为IDBCursor实例，否则为null\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cursor) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(cursor.key \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: \x27\x3c\/span\x3e \x2b cursor.value);\n        cursor.continue();\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27遍历完成\x27\x3c\/span\x3e);\n    }\n}\nrequest.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27游标区间获取失败\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在游标遍历时，具体的数据会保存在\x3ccode\x3eevent.target.result\x3c\/code\x3e里，如果该项存在，则会为一个\x3ccode\x3eIDBCursor\x3c\/code\x3e对象实例，否则为\x3ccode\x3enull\x3c\/code\x3e。实例的属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3edirection\x3c\/code\x3e：数值，表示游标的方向，\x3ccode\x3enext\/nextunique\/prev\/prevunique\x3c\/code\x3e，带有\x3ccode\x3eunique\x3c\/code\x3e的会去重\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ekey\x3c\/code\x3e：数据对象键\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3evalue\x3c\/code\x3e：数据对象值\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eprimaryKey\x3c\/code\x3e：游标当前的使用键值，后面会说\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在遍历到游标中具体的每一项时，可以使用\x3ccode\x3eupdate()\x3c\/code\x3e和\x3ccode\x3edelete()\x3c\/code\x3e来修改，如果想要移动游标：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3econtinue(key)\x3c\/code\x3e：存在key移动到指定项，否则下一项\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eadvance(count)\x3c\/code\x3e：存在count移动指定项数，否则上一项\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们通过\x3ccode\x3eIDBKeyRange\x3c\/code\x3e对象来控制键范围，有4种方式指定：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eonly(key)\x3c\/code\x3e：只取得想要的键值对，等同于直接调用\x3ccode\x3eget(key)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3elowerBound(key, true)\x3c\/code\x3e：第一个元素为key，如果第二个参数为true，从该项的下一项开始，缺省值为false\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eupperBound(key, true)\x3c\/code\x3e：最后一个元素为key，如果第二个参数为true，从该项的下一项开始，缺省值为false\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ebound(lowerkey, upperkey, true, true)\x3c\/code\x3e：前两者的结合，1和3对应lower，2和4对应upper\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3eopenCursor()\x3c\/code\x3e方法接收的第一个参数为范围区间，如果为null，则默认全部范围；第二个参数为方向，为\x3ccode\x3enext\/nextunique\/prev\/prevunique\x3c\/code\x3e四个，带有\x3ccode\x3eunique\x3c\/code\x3e的会去重\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e索引\x3c\/h3\x3e\n\x3cp\x3e可以使用\x3ccode\x3eobjectStore.createIndex(\x27name\x27, \x27name\x27, {unique: true});\x3c\/code\x3e来创建索引，分别为索引名，索引的属性名，该属性值是否唯一。调用\x3ccode\x3eobjectStore.delete(\x27name\x27);\x3c\/code\x3e来删除索引。删除索引不会影响数据，所以没有回调函数。\x3c\/p\x3e\n\x3cp\x3e如果我们不想在主键上遍历游标或者获取数据，可以在数据集上取得新的索引列表：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 直接切换索引\nconst index = objectStore(\x27dimensions\x27);\n\/\/ 在该索引上进行游标遍历\nrequest = index.openCursor();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直接切换索引\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e = objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27dimensions\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在该索引上进行游标遍历\x3c\/span\x3e\nrequest = \x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e.openCursor();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们在非主键的游标中，想要去的主键值，调用\x3ccode\x3eindex.getKey(\x27007\x27);\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e并发问题\x3c\/h3\x3e\n\x3cp\x3e数据库操作存在并发问题，但由于是异步，我们不用担心，但是如果存在新版本变更还是会导致问题。所以打开数据库时指定\x3ccode\x3eonversionchange()\x3c\/code\x3e处理事件，可以避免这个问题，在\x3ccode\x3esetVesion()\x3c\/code\x3e时，如果触发\x3ccode\x3eonerror()\x3c\/code\x3e代表已经打开了该数据库，无法现在更新版本，提示用户关闭其它网页，重新调用更新。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e如果需要与服务器实时交互，使用\x3ccode\x3ecookie\x3c\/code\x3e，如果需要保存一些小信息字段，使用\x3ccode\x3elocalStorage\x3c\/code\x3e，如果只需要本次会话有效，使用\x3ccode\x3esessionStorage\x3c\/code\x3e，如果数据很大，使用\x3ccode\x3eindexedDB\x3c\/code\x3e。使用什么技术跟业务场景匹配，但是技术还是都要了解都要会，毕竟，巧妇难为无米之炊。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e参考资料\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3eJavaScript高级程序设计 23章-离线应用与客户端存储\x3c\/li\x3e\n\x3cli\x3estorage事件使用：\x3ca href=\x22https:\/\/www.cnblogs.com\/inconceivable\/p\/5960202.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.cnblogs.com\/incon...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eIDBCursor对象：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/IDBCursor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端开发的客户端本地存储</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012828660">https://segmentfault.com/a/1190000012828660</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/gycygxpqvtd/" target="_blank">https://alili.tech/archive/gycygxpqvtd/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>