<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="express分析和对比"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>express分析和对比 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/h30seyyacs/",
				"appid": "1613049289050283", 
				"title": "express分析和对比 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/z9skhjhbaqq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/p4st69z8off/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&text=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&text=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&title=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&is_video=false&description=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&title=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&title=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&title=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh30seyyacs%2f&title=express%e5%88%86%e6%9e%90%e5%92%8c%e5%af%b9%e6%af%94"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">express分析和对比</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e目前express最新版本是4.16.2,所以本文分析也基于这个版本。目前从npm仓库上来看express使用量挺高的,express月下载量约为koa的40倍。所以目前研究下express还是有一定意义的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e源码分析\x3c\/h2\x3e\n\x3cp\x3e直接切入主题,由于目前express是一个独立的路由和中间件web框架。所以分析的方向也以这两个为主。源码的研究只注重关键步骤和流程思想, 具体的hack,异常,边界处理不做过多精力关注。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e关键步骤\x3c\/h3\x3e\n\x3ch4\x3e中间件的执行\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * \/\/负责具体请求的逻辑处理,当一维layer中所对应的stack执行完后执行done(目的是为了一维路由列表中进行下一个路由的匹配执行)。\n * @param done(路由中的next)\n *\/\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n    var idx = 0;\n    var stack = this.stack;\n    next();\n    \/\/递归方式执行stack中的layer,通过next控制流程的执行\n    function next(err) {\n        \/\/ 出错直接退出当前stack和路由列表中回调的后续执行\n        if (err \x26amp;\x26amp; err === \x27router\x27) {\n            return done(err)\n        }\n        \/\/出错直接退出当前stack列表后续执行,进行下一个路由匹配\n        if (err \x26amp;\x26amp; err === \x27route\x27) {\n            return done();\n        }\n        var layer = stack[idx\x2b\x2b];\n        \/\/执行结束\n        if (!layer) {\n            return done(err);\n        }\n        if (layer.method \x26amp;\x26amp; layer.method !== method) {\n            return next(err);\n        }\n            \/\/调用具体注册好的逻辑\n        if (err) {\n            layer.handle_error(err, req, res, next);\n        } else {\n            layer.handle_request(req, res, next);\n        }\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs hsp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * \/\/负责具体请求的逻辑处理,当一维layer中所对应的stack执行完后执行done(目的是为了一维路由列表中进行下一个路由的匹配执行)。\n * @param done(路由中的next)\n *\/\x3c\/span\x3e\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n    var idx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    var stack = this.stack\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/递归方式执行stack中的layer,通过next控制流程的执行\x3c\/span\x3e\n    function \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 出错直接退出当前stack和路由列表中回调的后续执行\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27router\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e done(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/出错直接退出当前stack列表后续执行,进行下一个路由匹配\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27route\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e done()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        }\n        var layer = stack[idx\x2b\x2b]\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行结束\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!layer) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e done(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (layer.method \x26amp;\x26amp; layer.method !== method) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用具体注册好的逻辑\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e) {\n            layer.handle_error(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e, req, res, \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            layer.handle_request(req, res, \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        }\n    }\n}\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 上面是源码的部分摘要,去除了无关的信息,对关键步骤加了注解。\x3c\/p\x3e\n\x3ch4\x3e路由匹配\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 对具体请求进行路由分发处理\n * out 是最后一个处理器,默认是请求的回调,不传的话是内部提供的error handlers\n *\/\nproto.handle = function handle(req, res, out) {\n    var self = this;\n    var idx = 0;\n    var paramcalled = {};\n    \/\/ middleware 和 roues\n    var stack = self.stack;\n    var done = restore(out, req, \x27baseUrl\x27, \x27next\x27, \x27params\x27);\n\n    next();\n    \/\/递归方式遍历注册的一维路由\n    function next(err) {\n        var layerError = err === \x27route\x27\n            ? null\n            : err;\n        var layer,match,route;\n        \/\/取出注册好的路由,进行请求匹配\n        while (match !== true \x26amp;\x26amp; idx \x3c stack.length) {\n            layer = stack[idx\x2b\x2b];\n            \/\/req的path匹配,如果有注册参数路由会解析参数到layer.params上\n            match = matchLayer(layer, path);\n            route = layer.route;\n        }\n\n        if (match !== true) {\n            return done(layerError);\n        }\n        \/\/将解析好的路径参数放到请求对象上,以便后续参数回调逻辑的使用\n        req.params = layer.params;\n\n         \/\/路径参数回调回调  ,例如请求 \/user\/1 ,参数回调 app.param(\x27user\x27,cb1) app.get(\x27\/user\/:user\x27,cb2)   会先执行注册的param cb1,然后才会是router中注册的cb2\n        self.process_params(layer, paramcalled, req, res, function (err) {\n            if (err) {\n                return next(layerError || err);\n            }\n            if (route) {\n                return layer.handle_request(req, res, next);\n            }\n\n        });\n    }\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 对具体请求进行路由分发处理\n * out 是最后一个处理器,默认是请求的回调,不传的话是内部提供的error handlers\n *\/\x3c\/span\x3e\nproto.handle = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandle\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(req, res, out)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e = this;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e idx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e paramcalled = {};\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ middleware 和 roues\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.stack;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e done = restore(out, req, \x3cspan class=\x22hljs-string\x22\x3e\x27baseUrl\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27next\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27params\x27\x3c\/span\x3e);\n\n    next();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/递归方式遍历注册的一维路由\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enext\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e layerError = err === \x3cspan class=\x22hljs-string\x22\x3e\x27route\x27\x3c\/span\x3e\n            ? \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n            : err;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e layer,match,route;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/取出注册好的路由,进行请求匹配\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (match !== \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e \x26amp;\x26amp; idx \x26lt; stack.length) {\n            layer = stack[idx\x2b\x2b];\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/req的path匹配,如果有注册参数路由会解析参数到layer.params上\x3c\/span\x3e\n            match = matchLayer(layer, path);\n            route = layer.route;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (match !== \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e done(layerError);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/将解析好的路径参数放到请求对象上,以便后续参数回调逻辑的使用\x3c\/span\x3e\n        req.params = layer.params;\n\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/路径参数回调回调  ,例如请求 \/user\/1 ,参数回调 app.param(\x27user\x27,cb1) app.get(\x27\/user\/:user\x27,cb2)   会先执行注册的param cb1,然后才会是router中注册的cb2\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.process_params(layer, paramcalled, req, res, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(err)\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next(layerError || err);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (route) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e layer.handle_request(req, res, next);\n            }\n\n        });\n    }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  上面摘取了请求进行路由分发处理的关键步骤,并做了相应的注解。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e执行流程\x3c\/h3\x3e\n\x3cp\x3e当一个请求过来的时候交给handler方法,进行路由的匹配,以递归的方式遍历(路由匹配一节中介绍过),当匹配到某一个路由的时候在dispatch执行,web应用启动初始化前注册好的回调逻辑,执行的方式也是以递归的方式(中间件执行一节中介绍过)。\x3cbr\x3e请求匹配执行逻辑已经介绍过了,下面结合着初始化的逻辑,进行分析,具体如下图所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/img.wuage.com\/152083811955039express.jpeg\x22 src=\x22https:\/\/static.alili.techhttps:\/\/img.wuage.com\/152083811955039express.jpeg\x22 alt=\x22express-jsdt\x22 title=\x22express-jsdt\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e初始化\x3c\/h4\x3e\n\x3cp\x3e针对上图做一下说明,启动服务应用的时候先进行初始化,注册\x27\/jsdt\x27的get请求,并给路由绑定相应的回调。其中我们的路由放在一维的layer中,每一层路由,例如\x27\/jsdt\x27又对应一个处理列表,这个二维列表里又存储着一系列layer(具体的回调处理逻辑),因为一维layer中已经记录了路径\x27\/jsdt\x27,所以二维的layer中就不用记录路径了,给个默认值\x27\/\x27,以保持一维layer和二维layer中结构的统一。\x3c\/p\x3e\n\x3ch4\x3e请求\x3c\/h4\x3e\n\x3cp\x3e当一个请求过来的时候先去一维layer所存储的路由中进行路径匹配,以递归的方式。匹配到了,通过dispatch方法,在执行路由所对应的二维layer中的回调逻辑,也是以递归的方式执行,在递归的过程中,如果发生异常,通过路由中传递过来的out,直接进行下一个路由的匹配。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n *递归执行stack中的handle\n * @param out  路由中的next\n *\/\nRoute.prototype.dispatch = function (req, res, out) （xxx）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n *递归执行stack中的handle\n * @param out  路由中的next\n *\/\x3c\/span\x3e\nRoute.prototype.\x3cspan class=\x22hljs-built_in\x22\x3edispatch\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eres\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eout\x3c\/span\x3e) （\x3cspan class=\x22hljs-title\x22\x3exxx\x3c\/span\x3e）\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当执行遇到res.end()的时候,数据响应完后,整个请求响应过程就结束了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3ekoa vs express\x3c\/h2\x3e\n\x3cblockquote\x3e\n\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008836418\x22\x3ekao源码\x3c\/a\x3e去年的时候有分析过,现在对比分析思考下。\x3cbr\x3ekoa比较迷你,微内核,拓展性强,所以一些web框架例如阿里的eggjs就是基于koa。而express集成了路由和static中间件所以显得重一些。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eexpress中间件和koa中间件区别,以及与redux中间件区别 ?\x3c\/h3\x3e\n\x3cp\x3e网上很多文章都说一个是线性的,一个是洋葱模型。因为两个我都研究过,我觉的这种说法不对,其实执行的时候都是洋葱形。主要的区别是koa内核底层原生支持async语法,koa中的middlewares经过compose以后,每次执行到await next返回的都是一个promise,所以我们可以在顶层加一个try……catch进行异常捕获,这算是koa比较方便的一点。还有一点很多人提到过说koa可以记录处理时间,那是因为每次res.body赋值的时候并没有res.end,所以在第一个中间件很容易记录处理的时间,如下所示,在中间件执行完后,在handleResponse中才会将请求处理结果返回给客户端。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fn(ctx)[是一个立即状态的promise].then(handleResponse).catch(onerror);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3efn\x3c\/span\x3e(ctx)\x3cspan class=\x22hljs-selector-attr\x22\x3e[是一个立即状态的promise]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.then\x3c\/span\x3e(handleResponse)\x3cspan class=\x22hljs-selector-class\x22\x3e.catch\x3c\/span\x3e(onerror);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而express每次res.send的时候数据已经发给客户端了,当然也可以实现这种需求,只不过没有koa方便。多说几句,其实java中也有类似的实现,例如java中的aop,过滤器,将通用的逻辑,例如日志,权限等模块通过配置的方式进行灵活的插入,配置在xml中。比较灵活,每个模块之间互相解耦,根据需求实现可插拔效果。\x3cbr\x3e在说一下与react中redux中间件机制区别,redux中的applyMiddleware中间件机制,可以在处理store前后加一些通用处理,利用高阶函数compose,通过reduce将多个函数组合成一个可执行执行函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/applyMiddleware.js\nchain = middlewares.map(middleware =\x3e middleware(middlewareAPI))\ndispatch = compose(...chain)(store.dispatch) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nix\x22\x3e\x3ccode\x3e\/\/applyMiddleware.js\n\x3cspan class=\x22hljs-attr\x22\x3echain\x3c\/span\x3e = middlewares.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(\x3cspan class=\x22hljs-attr\x22\x3emiddleware\x3c\/span\x3e =\x26gt; middleware(middlewareAPI))\n\x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e = compose(...chain)(store.dispatch) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/compose.js\nexport default function compose(...funcs) {\n  return funcs.reduce((a, b) =\x3e (...args) =\x3e a(b(...args)))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/compose.js\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecompose\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...funcs\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e funcs.reduce((a, b) =\x26gt; (...args) =\x26gt; a(b(...args)))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组合好最后执行的时候是洋葱模型效果,举个例子 compose(a, b, c)变成 a(b(c())),而a,b,c的结构类似下面这种形式\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fnA(next) {\n  return function() {\n    console.log(\x27fnA start\x27)\n    next()\n    console.log(\x27fnA end\x27)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efnA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enext\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27fnA start\x27\x3c\/span\x3e)\n    next()\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27fnA end\x27\x3c\/span\x3e)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以a(b(c()))()执行的时候,就会通过next来控制调用下一个中间件,整体的执行等价于express递归调用方式\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eexpress路由和  vue路由共同点\x3c\/h3\x3e\n\x3cp\x3evue中也有路由,官方的vue-router,他解决的是url和模板组件匹配渲染的问题, 而express中解决的url和handler匹配执行的问题,而koa内核里面没有集成路由。 从vue-router和express路由中可以看出路由的共性,是为了解决路径和相应处理逻辑的匹配问题在web开发中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3etoy版本express\x3c\/h2\x3e\n\x3cp\x3e根据上述分析的逻辑,实现了一个简化版的\x3ca href=\x22https:\/\/github.com\/gcyStar\/toy-express\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eexpress\x3c\/a\x3e ,融入了express的核心思想,有详尽的步骤注释,有需要的可以参考下。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e参考源码版本说明\x3c\/strong\x3e\x3cbr\x3eexpress 4.16.2\x3cbr\x3ekoa 2.2\x3cbr\x3eredux 3.7.2\x3cbr\x3e\x3cstrong\x3e参考链接\x3c\/strong\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/koajs\/koa\/blob\/master\/docs\/koa-vs-express.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/koajs\/koa\/...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/www.reddit.com\/r\/node\/comments\/692w23\/express_vs_koa_with_asyncawait\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.reddit.com\/r\/node...\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/blog.jscrambler.com\/migrate-your-express-app-to-koa-2\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/blog.jscrambler.com\/m...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>express分析和对比</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013710406">https://segmentfault.com/a/1190000013710406</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/h30seyyacs/" target="_blank">https://alili.tech/archive/h30seyyacs/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>