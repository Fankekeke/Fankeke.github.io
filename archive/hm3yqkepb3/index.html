<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="WebVR开发教程——交互事件（三）Cardboard与注视"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>WebVR开发教程——交互事件（三）Cardboard与注视 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hm3yqkepb3/",
				"appid": "1613049289050283", 
				"title": "WebVR开发教程——交互事件（三）Cardboard与注视 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-27T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8htnbgad815/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/nl7a77v99yb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&text=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&text=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&title=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&is_video=false&description=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&title=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&title=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&title=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhm3yqkepb3%2f&title=WebVR%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b%e2%80%94%e2%80%94%e4%ba%a4%e4%ba%92%e4%ba%8b%e4%bb%b6%ef%bc%88%e4%b8%89%ef%bc%89Cardboard%e4%b8%8e%e6%b3%a8%e8%a7%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">WebVR开发教程——交互事件（三）Cardboard与注视</h1><div class="meta"><div class="postdate"><time datetime="2018-12-27" itemprop="datePublished">2018-12-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814846?w=1240\x26amp;h=587\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814846?w=1240\x26amp;h=587\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eCardboard可以说是手机VR头显的元老了，狭义上指的是Google推出的一个带有双凸透镜的盒子，广义上则表示智能手机\x2b盒子的VR体验平台。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3eCardboard与gaze注视\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814847?w=209\x26amp;h=241\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814847?w=209\x26amp;h=241\x22 alt=\x22cardboard\x22 title=\x22cardboard\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e它的交互方式较为简单，利用了手机的陀螺仪，采用gaze注视行为来触发场景里的事件，比如用户在虚拟商店中注视一款商品时，弹出这个商品的价格信息。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814848?w=800\x26amp;h=600\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814848?w=800\x26amp;h=600\x22 alt=\x22gaze交互\x22 title=\x22gaze交互\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e注视事件是WebVR最基本的交互方式，用户通过头部运动改变视线朝向，当用户视线正对着物体时，触发物体绑定的事件，具体分为三个基本事件，分别是\x3ccode\x3egazeEnter\x3c\/code\x3e,\x3ccode\x3egazeTrigger\x3c\/code\x3e,\x3ccode\x3egazeLeave\x3c\/code\x3e。\x3cbr\x3e我们可以设置一个位于相机中心的准心来描述这三个基本事件（准确的说，在VR模式下是两个，分别位于左右相机的中心）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3egazeEnter：当准心进入物体时，即用户注视了物体，触发一次\x3c\/li\x3e\n\x3cli\x3egazeLeave：当准心离开物体时，即用户停止注视该物体时，触发一次\x3c\/li\x3e\n\x3cli\x3egazeTrigger：当准心处于物体时触发，不同于gazeEnter，gazeTrigger会在每一帧刷触发，直到准心离开物体\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e注视事件原理\x3c\/h3\x3e\n\x3cp\x3e注视事件触发条件其实就是物体被用户视线“击中”。在每帧动画渲染中，从准心处沿z轴负方向发出射线，如果射线与物体相交，即物体被射线击中，说明前方的物体被用户注视，这里使用Three提供的raycaster对象,对场景里的3d物体进行射线拾取。\x3c\/p\x3e\n\x3cp\x3e下面是使用\x3ccode\x3eTHREE.Raycaster\x3c\/code\x3e拾取物体的简单例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建射线发射器实例raycaster\nconst raycaster = new THREE.Raycaster();\nraycaster.setFromCamera(origin,camera); \/\/ 设置射线源点\nraycaster.intersectObjects(targetList); \/\/ 检测targetList的object物体是否与射线相交\nif (intersects.length \x3e 0) {\n    \/\/ 获取从源点触发，与射线相交的首个物体\n    const target = intersects[0].object;\n    \/\/ TODO\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建射线发射器实例raycaster\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e raycaster = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e THREE.Raycaster();\nraycaster.setFromCamera(origin,camera); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置射线源点\x3c\/span\x3e\nraycaster.intersectObjects(targetList); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测targetList的object物体是否与射线相交\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (intersects.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取从源点触发，与射线相交的首个物体\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = intersects[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].object;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TODO\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e主要分为三步：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3e new THREE.Raycaster()\x3c\/code\x3e创建一个射线发射器；\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3e.setFromCamera(origin,camera)\x3c\/code\x3e设置射线发射源位置，第一个参数origin传入NDC标准化设备坐标，即归一化的屏幕坐标，第二个参数传入相机，此时射线将在屏幕的origin处，沿垂直于相机的近切面的方向进行投射；\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3e.intersectObjects(targetList)\x3c\/code\x3e检测targetList的物体是否相交\x3cbr\x3e\x3ccode\x3eRaycaster\x3c\/code\x3e借鉴了\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Ray_casting\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e光线投射法\x3c\/a\x3e进行物体拾取，更多用法可参考\x3ca href=\x22https:\/\/threejs.org\/docs\/#api\/core\/Raycaster\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ethree.js官方文档\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3egazeEnter, gazeLeave, gazeTrigger实现\x3c\/h3\x3e\n\x3cp\x3e根据上文对gaze基本事件的描述，现在开始创建注视监听器\x3ccode\x3eGazer\x3c\/code\x3e类，提供事件绑定\x3ccode\x3eon\x3c\/code\x3e、解绑\x3ccode\x3eoff\x3c\/code\x3e、更新\x3ccode\x3eupdate\x3c\/code\x3e的公用方法，物体可注册\x3ccode\x3egazeEnter\x3c\/code\x3e,\x3ccode\x3egazeLeave\x3c\/code\x3e,\x3ccode\x3egazeTrigger\x3c\/code\x3e事件回调，以下是完整代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 注视事件监听器\nclass Gazer {\n    constructor() {\n        \/\/ 初始化射线发射源\n        this.raycaster = new THREE.Raycaster();\n        this._center = new THREE.Vector2();\n        this.rayList = {},this.targetList = [];\n        this._lastTarget = null;\n    }\n    \/** 物体绑定gaze事件的公用方法\n     * @param {THREE.Object3D} target 监听的3d网格\n     * @param {String} eventType 事件类型 \n     * @param {Function} callback 事件回调\n     **\/\n    on(target, eventType, callback) {\n        const noop = () =\x3e {};\n        \/\/ target首次绑定事件，则创建监听对象，加入raylist监听列表，并将三个基本事件的回调初始为空方法\n        if (!this.rayList[target.id]) this.rayList[target.id] = { target, gazeEnter: noop, gazeTrigger: noop, gazeLeave: noop };\n        \/\/ 根据传入的 eventType与callback更新事件回调\n        this.rayList[target.id][eventType] = callback;\n        this.targetList = Object.keys(this.rayList).map(key =\x3e this.rayList[key].target);\n    }\n    off(target) {\n        delete this.rayList[target.id];\n        this.targetList = Object.keys(this.rayList).map(key =\x3e this.rayList[key].target);\n    }\n    update(camera) {\n        if (this.targetList.length \x3c= 0) return;\n        \/\/更新射线位置\n        this.raycaster.setFromCamera(this._center,camera);\n        const intersects = this.raycaster.intersectObjects(this.targetList);\n        if (intersects.length \x3e 0) { \/\/ 当前帧射线击中物体\n            const currentTarget = intersects[0].object;\n            if (this._lastTarget) { \/\/ 上一帧射线击中物体\n                if (this._lastTarget.id !== currentTarget.id) { \/\/ 上一帧射线击中物体与当前帧不同\n                    this.rayList[this._lastTarget.id].gazeLeave(); \n                    this.rayList[currentTarget.id].gazeEnter();\n                }\n            } else { \/\/ 上一帧射线未击中物体\n                this.rayList[currentTarget.id].gazeEnter(); \/\/ 触发当前帧物体的gazeEnter事件\n            }\n            this.rayList[currentTarget.id].gazeTrigger(); \/\/ 当前帧射线击中物体，触发物体的gazeTrigger事件\n            this._lastTarget = currentTarget;\n        } else { \/\/ 当前帧我击中物体\n            if ( this._lastTarget ) this.rayList[this._lastTarget.id].gazeLeave(); \/\/ 触发上一帧物体gazeLeave\n            this._lastTarget = null;\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注视事件监听器\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGazer\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化射线发射源\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.raycaster = new THREE.Raycaster();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._center = new THREE.Vector2();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList = {},\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetList = [];\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/** 物体绑定gaze事件的公用方法\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {THREE.Object3D} target 监听的3d网格\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {String} eventType 事件类型 \n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {Function} callback 事件回调\n     **\/\x3c\/span\x3e\n    on(target, eventType, callback) {\n        const noop = () =\x26gt; {};\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ target首次绑定事件，则创建监听对象，加入raylist监听列表，并将三个基本事件的回调初始为空方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[target.id]) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[target.id] = { target, gazeEnter: noop, gazeTrigger: noop, gazeLeave: noop };\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据传入的 eventType与callback更新事件回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[target.id][eventType] = callback;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetList = Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList).map(key =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[key].target);\n    }\n    off(target) {\n        delete \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[target.id];\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetList = Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList).map(key =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[key].target);\n    }\n    update(camera) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetList.length \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新射线位置\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.raycaster.setFromCamera(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._center,camera);\n        const intersects = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.raycaster.intersectObjects(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetList);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (intersects.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧射线击中物体\x3c\/span\x3e\n            const currentTarget = intersects[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线击中物体\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id !== currentTarget.id) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线击中物体与当前帧不同\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id].gazeLeave(); \n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeEnter();\n                }\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线未击中物体\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeEnter(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发当前帧物体的gazeEnter事件\x3c\/span\x3e\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeTrigger(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧射线击中物体，触发物体的gazeTrigger事件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget = currentTarget;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧我击中物体\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget ) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id].gazeLeave(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发上一帧物体gazeLeave\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面一起来看\x3ccode\x3eGazer\x3c\/code\x3e实现的三步曲，这里用“击中”表示射线与物体相交。\x3c\/p\x3e\n\x3ch6\x3e第一步，使用构造函数\x3ccode\x3econstructor\x3c\/code\x3e初始化：\x3c\/h6\x3e\n\x3col\x3e\n\x3cli\x3e初始化射线发射器\x3ccode\x3eraycaster\x3c\/code\x3e实例；\x3c\/li\x3e\n\x3cli\x3e创建\x3ccode\x3erayList\x3c\/code\x3e以记录注册gaze事件的物体对象；\x3c\/li\x3e\n\x3cli\x3e创建\x3ccode\x3elastTarget\x3c\/code\x3e记录前一帧被射线击中的物体，初始为null。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch6\x3e第二步，创建\x3ccode\x3eon\x3c\/code\x3e方法提供事件绑定API\x3c\/h6\x3e\n\x3cp\x3e通过调用\x3ccode\x3egazer.on(target,eventType,callback)\x3c\/code\x3e方式，传入绑定事件的Obect3D对象\x3ccode\x3etarget\x3c\/code\x3e，绑定事件类型\x3ccode\x3eeventType\x3c\/code\x3e以及事件回调\x3ccode\x3ecallback\x3c\/code\x3e三个参数。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e判断这个target是否存在，不存在，则创建一个监听对象，存在则更新对象里的事件函数。这个对象包括传入的target本身，以及三个基本事件的回调函数（初始值为空方法）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.rayList[target.id] = { \n   target, \n   gazeEnter, \n   gazeTrigger, \n   gazeLeave\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.id] = { \n   \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e, \n   gazeEnter, \n   gazeTrigger, \n   gazeLeave\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将这个对象以键值对形式赋值给\x3ccode\x3eraylist[target.id]\x3c\/code\x3e监听序列对象；\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e将\x3ccode\x3eraylist\x3c\/code\x3e对象处理成\x3ccode\x3e[ target1, ..., targetN ]\x3c\/code\x3e的形式赋值给\x3ccode\x3ethis.targetList\x3c\/code\x3e，作为\x3ccode\x3eraycaster.intersectObjects\x3c\/code\x3e的入参。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch6\x3e第三步，创建\x3ccode\x3eupdate\x3c\/code\x3e方法，在动画帧中监听三个基本事件是否触发\x3c\/h6\x3e\n\x3col\x3e\n\x3cli\x3e调用\x3ccode\x3eraycaster.setFromCamera\x3c\/code\x3e更新射线起点与方向；\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3eraycaster.intersectObjects\x3c\/code\x3e检测监听序列\x3ccode\x3ethis.targetList\x3c\/code\x3e是否有物体与射线相交；\x3c\/li\x3e\n\x3cli\x3e根据\x3ccode\x3egazeEnter\x3c\/code\x3e和\x3ccode\x3egazeLeave\x3c\/code\x3e和\x3ccode\x3egazeTrigger\x3c\/code\x3e实现的情况，总结了以下这三个事件触发的逻辑图。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814849?w=1240\x26amp;h=570\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814849?w=1240\x26amp;h=570\x22 alt=\x22gaze基本事件逻辑图\x22 title=\x22gaze基本事件逻辑图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e逻辑图里的三个条件用代码表示如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e当前帧射线是否击中物体：\x3ccode\x3eif (intersects.length \x26gt; 0)\x3c\/code\x3e\x3cbr\x3e上一帧射线是否击中物体：\x3ccode\x3eif (this._lastTarget)\x3c\/code\x3e\x3cbr\x3e当前帧射线击中物体是否与上一帧不同：\x3ccode\x3eif (this._lastTarget.id !== currentTarget.id)\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (intersects.length \x3e 0) { \/\/ 当前帧射线击中物体\n    const currentTarget = intersects[0].object;\n    if (this._lastTarget) { \/\/ 上一帧射线击中物体\n        if (this._lastTarget.id !== currentTarget.id) { \n            \/\/ 上一帧射线击中物体与当前帧不同，触发上一帧物体的gazeLeave事件，触发当前帧物体的gazeEnter事件\n            this.rayList[this._lastTarget.id].gazeLeave(); \n            this.rayList[currentTarget.id].gazeEnter();\n        }\n    } else { \/\/ 上一帧射线未击中物体\n        this.rayList[currentTarget.id].gazeEnter(); \/\/ 上一帧射线没有击中物体，触发当前帧物体的gazeEnter事件\n    }\n    this.rayList[currentTarget.id].gazeTrigger(); \/\/ 当前帧射线击中物体，触发物体的gazeTrigger事件\n    this._lastTarget = currentTarget;\n} else { \/\/ 当前帧我击中物体\n    if ( this._lastTarget ) this.rayList[this._lastTarget.id].gazeLeave(); \/\/ 上一帧射线击中物体，触发上一帧物体gazeLeave\n    this._lastTarget = null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (intersects.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧射线击中物体\x3c\/span\x3e\n    const currentTarget = intersects[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线击中物体\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id !== currentTarget.id) { \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线击中物体与当前帧不同，触发上一帧物体的gazeLeave事件，触发当前帧物体的gazeEnter事件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id].gazeLeave(); \n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeEnter();\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线未击中物体\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeEnter(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线没有击中物体，触发当前帧物体的gazeEnter事件\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[currentTarget.id].gazeTrigger(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧射线击中物体，触发物体的gazeTrigger事件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget = currentTarget;\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前帧我击中物体\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget ) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rayList[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget.id].gazeLeave(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一帧射线击中物体，触发上一帧物体gazeLeave\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._lastTarget = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后，我们需要更新\x3ccode\x3ethis._lastTarget\x3c\/code\x3e值，供下一帧进行逻辑判断，如果当前帧有物体击中，则\x3ccode\x3ethis._lastTarget = currentTarget\x3c\/code\x3e，否则执行\x3ccode\x3ethis._lastTarget = null\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e事件绑定示例\x3c\/h3\x3e\n\x3cp\x3e接下来，我们调用前面定义的\x3ccode\x3eGazer\x3c\/code\x3e类开发gaze交互，实现一个简单例子：随机创建100个cube立方体，当用户注视立方体时，立方体半透明。\x3cbr\x3e首先创建准心，设置为一个圆点作为展现给用户的光标，当然你可以创建其它准心形状，比如十字形或环形等。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建准心\ncreateCrosshair () {\n    const geometry = new THREE.CircleGeometry( 0.002, 16 );\n    const material = new THREE.MeshBasicMaterial({\n        color: 0xffffff,\n        opacity: 0.5,\n        transparent: true\n    });\n    const crosshair = new THREE.Mesh(geometry,material);\n    crosshair.position.z = -0.5;\n    return crosshair;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs go\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建准心\x3c\/span\x3e\ncreateCrosshair () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e geometry = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e THREE.CircleGeometry( \x3cspan class=\x22hljs-number\x22\x3e0.002\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e );\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e material = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e THREE.MeshBasicMaterial({\n        color: \x3cspan class=\x22hljs-number\x22\x3e0xffffff\x3c\/span\x3e,\n        opacity: \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e,\n        transparent: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e crosshair = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e THREE.Mesh(geometry,material);\n    crosshair.position.z = \x3cspan class=\x22hljs-number\x22\x3e-0.5\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e crosshair;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来，在\x3ccode\x3estart()\x3c\/code\x3e方法创建物体并绑定事件，在\x3ccode\x3eupdate\x3c\/code\x3e监听事件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 场景物体初始化\nstart() {\n    const { scene, camera } = this;\n    ... 创建灯光、地板等\n    \/\/ 添加准心到相机\n    camera.add(this.createCrosshair());\n    this.gazer = new Gazer();\n    \/\/ 创建立方体\n    for (let i = 0; i \x3c 100; i\x2b\x2b) {\n        const cube = this.createCube(2,2,2 );\n        cube.position.set( 100*Math.random() - 50, 50*Math.random() -10, 100*Math.random() - 50 );\n        scene.add(cube);\n        \/\/ 绑定注视事件\n        this.gazer.on(cube,\x27gazeEnter\x27,() =\x3e {\n            cube.material.opacity = 0.5;\n        });\n        this.gazer.on(cube,\x27gazeLeave\x27,() =\x3e {\n            cube.material.opacity = 1;\n        });\n    }\n}\n\/\/ 动画更新\nupdate() {\n    const { scene, camera, renderer, gazer } = this;\n    gazer.update(camera);\n    renderer.render(scene, camera);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 场景物体初始化\x3c\/span\x3e\nstart() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { scene, \x3cspan class=\x22hljs-built_in\x22\x3ecamera\x3c\/span\x3e } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    ... 创建灯光、地板等\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加准心到相机\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ecamera\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createCrosshair());\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Gazer();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建立方体\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cube = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createCube(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e );\n        cube.position.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e( \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e*Math.\x3cspan class=\x22hljs-built_in\x22\x3erandom\x3c\/span\x3e() - \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e*Math.\x3cspan class=\x22hljs-built_in\x22\x3erandom\x3c\/span\x3e() \x3cspan class=\x22hljs-number\x22\x3e-10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e*Math.\x3cspan class=\x22hljs-built_in\x22\x3erandom\x3c\/span\x3e() - \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e );\n        scene.\x3cspan class=\x22hljs-built_in\x22\x3eadd\x3c\/span\x3e(cube);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定注视事件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeEnter\x27\x3c\/span\x3e,() =\x26gt; {\n            cube.material.opacity = \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e;\n        });\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeLeave\x27\x3c\/span\x3e,() =\x26gt; {\n            cube.material.opacity = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n        });\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 动画更新\x3c\/span\x3e\nupdate() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { scene, \x3cspan class=\x22hljs-built_in\x22\x3ecamera\x3c\/span\x3e, renderer, gazer } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    gazer.update(\x3cspan class=\x22hljs-built_in\x22\x3ecamera\x3c\/span\x3e);\n    renderer.render(scene, \x3cspan class=\x22hljs-built_in\x22\x3ecamera\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在示例中，我们遵循上一期WebVRApp的代码结构，在\x3ccode\x3estart\x3c\/code\x3e方法里增加了一个准心，为100个cube立方体绑定\x3ccode\x3egazeEnter\x3c\/code\x3e事件和\x3ccode\x3egazeLeave\x3c\/code\x3e事件，触发\x3ccode\x3egazeEnter\x3c\/code\x3e时，立方体半透明，触发\x3ccode\x3egazeLeave\x3c\/code\x3e时，立方体恢复不透明。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814850?w=640\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814850?w=640\x26amp;h=350\x22 alt=\x22gaze注视交互\x22 title=\x22gaze注视交互\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e演示地址：\x3ca href=\x22https:\/\/yonechen.github.io\/WebVR-helloworld\/cardboard.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eyonechen.github.io\/WebVR-helloworld\/cardboard.html\x3c\/a\x3e\x3cbr\x3e源码地址：\x3ca href=\x22https:\/\/github.com\/YoneChen\/WebVR-helloworld\/blob\/master\/cardboard.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub.com\/YoneChen\/WebVR-helloworld\/blob\/master\/cardboard.html\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cp\x3e注视事件除了以上三种基本事件外，还衍生了像注视延迟事件和注视点击事件，这些gaze事件都可以在\x3ccode\x3egazeTrigger\x3c\/code\x3e里进行拓展。\x3c\/p\x3e\n\x3ch5\x3e注视点击事件\x3c\/h5\x3e\n\x3cp\x3ecardboard二代在盒子上提供了一个按钮，当用户通过注视物体并点击按钮，由按钮点击屏幕触发。\x3cbr\x3e实现思路：在\x3ccode\x3ewindow\x3c\/code\x3e绑定click事件，触发click时改变标志位，在\x3ccode\x3egazeTrigger\x3c\/code\x3e方法内根据标志位来判断是否执行回调，关键代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/按钮事件监听\nwindow.addEventListener(\x27click\x27, e =\x3e this.state._clicked = true);\nthis.gazer.on(cube,\x27gazeTrigger\x27,() =\x3e {\n    \/\/ 当用户点击时触发\n    if (this.state._clicked) {\n        this.state._clicked = false; \/\/ 重置点击标志位\n        cube.scale.set(1.5,1.5,1.5); \/\/ TODO\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/按钮事件监听\x3c\/span\x3e\nwindow.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._clicked = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeTrigger\x27\x3c\/span\x3e,() =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当用户点击时触发\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._clicked) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._clicked = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置点击标志位\x3c\/span\x3e\n        cube.scale.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1.5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1.5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1.5\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TODO\x3c\/span\x3e\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e注视延迟事件\x3c\/h5\x3e\n\x3cp\x3e当准心在物体上超过一定时间时触发，一般会在准心处设置一个进度条动画。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011814851?w=480\x26amp;h=270\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011814851?w=480\x26amp;h=270\x22 alt=\x22注视延迟事件\x22 title=\x22注视延迟事件\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e实现思路：在\x3ccode\x3egazeEnter\x3c\/code\x3e时记录开始时间点，在\x3ccode\x3egazeTrigger\x3c\/code\x3e计算出时间差是否超过预设延迟时间，如果是则执行回调，关键代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/准心进入物体，开启事件触发计时\nthis.gazer.on(cube,\x27gazeEnter\x27,() =\x3e {\n    this.state._wait = true; \/\/ 计时已开始\n    this.animate.loader.start(); \/\/ 开启准心进度条动画\n    this.state.gazeEnterTime = Date.now(); \/\/ 记录计时开始时间点\n});\nthis.gazer.on(cube,\x27gazeTrigger\x27,() =\x3e {\n    \/\/ 当计时已开始，且延迟时长超过1.5秒触发\n    if (this.state._wait \x26amp;\x26amp; Date.now() - this.state.gazeEnterTime \x3e 1500) {\n        this.animate.loader.stop(); \/\/ 停止准心进度条动画\n        this.state._wait = false; \/\/ 计时结束\n        cube.material.opacity = 0.5; \/\/ TODO\n    }\n});\nthis.gazer.on(cube,\x27gazeLeave\x27,() =\x3e {\n    this.animate.loader.stop(); \/\/ 停止准心进度条动画\n    this.state._wait = false; \/\/ 计时结束\n    ...\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/准心进入物体，开启事件触发计时\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeEnter\x27\x3c\/span\x3e,() =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._wait = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计时已开始\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.animate.loader.start(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开启准心进度条动画\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.gazeEnterTime = Date.now(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录计时开始时间点\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeTrigger\x27\x3c\/span\x3e,() =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当计时已开始，且延迟时长超过1.5秒触发\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._wait \x26amp;\x26amp; Date.now() - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.gazeEnterTime \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1500\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.animate.loader.stop(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止准心进度条动画\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._wait = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计时结束\x3c\/span\x3e\n        cube.material.opacity = \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TODO\x3c\/span\x3e\n    }\n});\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.gazer.on(cube,\x3cspan class=\x22hljs-string\x22\x3e\x27gazeLeave\x27\x3c\/span\x3e,() =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.animate.loader.stop(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止准心进度条动画\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state._wait = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计时结束\x3c\/span\x3e\n    ...\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里准心计时进度条loader动画使用了\x3ccode\x3eTween.js\x3c\/code\x3e，这里就不展开了，更多可在源码地址查看。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e演示地址：\x3ca href=\x22https:\/\/yonechen.github.io\/WebVR-helloworld\/cardboard2.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eyonechen.github.io\/WebVR-helloworld\/cardboard2.html\x3c\/a\x3e\x3cbr\x3e源码地址：\x3ca href=\x22https:\/\/github.com\/YoneChen\/WebVR-helloworld\/blob\/master\/cardboard2.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub.com\/YoneChen\/WebVR-helloworld\/blob\/master\/cardboard2.html\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e小结\x3c\/h3\x3e\n\x3cp\x3e以上介绍了Cardboard的gaze事件概念与原理，以及三个基本事件的开发过程，通过例子展示gaze交互实现方法，最后文末补充了gaze事件的扩展。\x3cbr\x3e上文提及的注视点击也是Gear VR最常用的交互方式，不过Gear VR提供了更为丰富的touchpad而不是按钮，下一期将详细介绍Gear VR与touchpad的事件开发，敬请期待。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch5\x3eWebVR开发传送门：\x3c\/h5\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/29888602\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebVR开发教程——交互事件（一）头显与手柄\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/30630559\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebVR开发教程——交互事件（二）使用Gamepad\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/28324884\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebVR开发教程——深度剖析\x3c\/a\x3e 关于WebVR的开发调试方案以及原理机制\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/25567905\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebVR开发教程——标准入门\x3c\/a\x3e 使用Three.js开发WebVR场景的入门教程\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>WebVR开发教程——交互事件（三）Cardboard与注视</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011814841">https://segmentfault.com/a/1190000011814841</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hm3yqkepb3/" target="_blank">https://alili.tech/archive/hm3yqkepb3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>