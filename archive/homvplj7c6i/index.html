<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【Chrome扩展开发】定制HTTP请求响应头域"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【Chrome扩展开发】定制HTTP请求响应头域 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/homvplj7c6i/",
				"appid": "1613049289050283", 
				"title": "【Chrome扩展开发】定制HTTP请求响应头域 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:13"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hffja9befw4/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4e8i4f3cql5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&text=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&text=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&title=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&is_video=false&description=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&title=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&title=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&title=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhomvplj7c6i%2f&title=%e3%80%90Chrome%e6%89%a9%e5%b1%95%e5%bc%80%e5%8f%91%e3%80%91%e5%ae%9a%e5%88%b6HTTP%e8%af%b7%e6%b1%82%e5%93%8d%e5%ba%94%e5%a4%b4%e5%9f%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【Chrome扩展开发】定制HTTP请求响应头域</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e本文首发于《程序员》杂志2017年第9、10、11期，下面的版本又经过进一步的修订。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e关于\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eGithub：\x3ca href=\x22https:\/\/github.com\/Louiszhai\/IHeader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIHeader\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我的博客：\x3ca href=\x22http:\/\/louiszhai.github.io\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elouis blog\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e掘金专栏：\x3ca href=\x22https:\/\/juejin.im\/user\/5735109371cfe4006cdd254d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e路易斯专栏\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e原文链接：\x3ca href=\x22http:\/\/louiszhai.github.io\/2017\/11\/14\/iheader\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e【Chrome扩展开发】定制HTTP请求响应头域\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e本文共15k字，阅读需15分钟。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e导读\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e搜索是程序员的灵魂，为了提升搜索的效率，以便更快的查询信息，我试着同时搜索4个网站，分别是百度、Google、维基、Bing。一个可行的做法就是网页中嵌入4个iframe，通过js拼接前面4个搜索引擎的Search URL并依次在iframe中加载。这个构思丝毫没有问题，简单粗暴。然而就是这么简单的功能，也无法实现。由于Google网站在HTML的response header中添加了\x3ccode\x3eX-Frame-Options\x3c\/code\x3e字段以防止网页被Frame（这项设置常被用来防止Click Cheats），因此我无法将Google Search加入到iframe中来。那么，我会放弃Google吗？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3eNginx反向代理Google\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e显然不会，既然问题出在\x3ccode\x3eX-Frame-Options\x3c\/code\x3e上，我去掉就行了。对于请求或响应头域定制，nginx是个不错的选择，其第三方的\x3ccode\x3engx_headers_more\x3c\/code\x3e模块就特别擅长这种处理。由于nginx无法动态加载第三方模块，我动态编译了nginx以便加入\x3ccode\x3engx_headers_more\x3c\/code\x3e模块。至此，第一步完成，以下是nginx的部分配置。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22location \/ {\n  more_clear_headers \x27X-Frame-Options\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elocation\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\/ {\n  more_clear_headers\x3c\/span\x3e \x27X-Frame-Options\x27;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了让\x3ccode\x3ewww.google.com\x3c\/code\x3e正常访问，我需要使用另外一个域名比如\x3ccode\x3elouis.google.com\x3c\/code\x3e。通过nginx，让\x3ccode\x3elouis.google.com\x3c\/code\x3e转发到\x3ccode\x3ewww.google.com\x3c\/code\x3e，转发的同时去掉响应头域中的\x3ccode\x3eX-Frame-Options\x3c\/code\x3e字段。于是nginx配置看起来像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22server {\n  listen 80;\n  server_name louis.google.com;\n  location \/ {\n    proxy_pass https:\/\/www.google.com\/;\n    more_clear_headers \x27X-Frame-Options\x27;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nginx\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3eserver\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3elisten\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-attribute\x22\x3eserver_name\x3c\/span\x3e louis.google.com;\n  \x3cspan class=\x22hljs-attribute\x22\x3elocation\x3c\/span\x3e \/ {\n    \x3cspan class=\x22hljs-attribute\x22\x3eproxy_pass\x3c\/span\x3e https:\/\/www.google.com\/;\n    \x3cspan class=\x22hljs-attribute\x22\x3emore_clear_headers\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27X-Frame-Options\x27\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上的配置有什么问题吗？且不说http直接转https的问题，即使能转发，实际上由于Google的安全策略限制，我们也访问不了Google首页！\x3c\/p\x3e\n\x3cp\x3e最终我使用了一个Nginx Google代理模块\x3ca\x3e\x3ccode\x3engx_http_google_filter_module\x3c\/code\x3e\x3c\/a\x3e)，nginx配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22server {\n    listen 80;\n    server_name louis.google.com;\n    resolver 192.168.1.1; # 需要设置为当前路由的网关\n    location \/ {\n        google on;\n        google_robots_allow on;\n        more_clear_headers \x27X-Frame-Options\x27;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nginx\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3eserver\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attribute\x22\x3elisten\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-attribute\x22\x3eserver_name\x3c\/span\x3e louis.google.com;\n    \x3cspan class=\x22hljs-attribute\x22\x3eresolver\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e192.168.1.1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e# 需要设置为当前路由的网关\x3c\/span\x3e\n    \x3cspan class=\x22hljs-attribute\x22\x3elocation\x3c\/span\x3e \/ {\n        \x3cspan class=\x22hljs-attribute\x22\x3egoogle\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-attribute\x22\x3egoogle_robots_allow\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-attribute\x22\x3emore_clear_headers\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27X-Frame-Options\x27\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上，通过实现一个Google网站的反向代理，代理的同时去掉了响应头域中的\x3ccode\x3eX-Frame-Options\x3c\/code\x3e字段。至此，nginx方案完结。\x3c\/p\x3e\n\x3cp\x3enginx方案有一个明显的缺陷是，配置中resolver对应的网关IP\x3ccode\x3e192.168.1.1\x3c\/code\x3e是随着路由器的改变而改变的，家里和公司就是两个不同的网关（更别说去星巴克了办公了），因此经常需要手动去修改网关然后重启nginx。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3cstrong\x3eIHeader缘起\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3enginx方案的这个缺陷多少有些麻烦，恰好Chrome Extension可以定制headers，为了解决这个问题，我便尝试开发Chrome Extension。（使用Chrome以来，我下载试用过无数的Chrome Extension。每每看到一款优秀的Extension，都要激动好久，总有一种相见恨晚的感觉。Extension以其强大的定制能力，神奇的运行机制征服了无数的开发者，我也不例外。然而无论多少次的学习和模仿，最终的目的还是为了使用，故开发一款定制请求的Extension势在必行。）由于Chrome浏览器与网页的天然联系，使用Chrome Extension的方式去掉响应头域字段，比其它方案要更加简单高效。\x3c\/p\x3e\n\x3cp\x3e要知道，Chrome Extension提供的API中有\x3ccode\x3echrome.webRequest.onHeadersReceived\x3c\/code\x3e。它能够添加对响应头的监听并同步修改响应头域，去掉\x3ccode\x3eX-Frame-Options\x3c\/code\x3e似乎是小case。\x3c\/p\x3e\n\x3cp\x3e于是新建项目，取名\x3ca href=\x22http:\/\/github.com\/Louiszhai\/IHeader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIHeader\x3c\/a\x3e。目录结构如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzDC\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzDC\x22 alt=\x22目录结构\x22 title=\x22目录结构\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中，_locales是国际化配置，目前IHeader支持中文和英文两种语言。\x3c\/p\x3e\n\x3cp\x3eres是资源目录，index.html是extension的首页，options.html是选项页面。\x3c\/p\x3e\n\x3cp\x3emanifest.json是extension的声明配置（总入口），在这里配置extension的名称、版本号、图标、快捷键、资源路径以及权限等。\x3c\/p\x3e\n\x3cp\x3emanifest.json贴出来如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;name\x26quot;: \x26quot;IHeader\x26quot;, \/\/ 扩展名称\n  \x26quot;version\x26quot;: \x26quot;1.1.0\x26quot;, \/\/ 扩展版本号\n  \x26quot;icons\x26quot;: { \/\/ 上传到chrome webstore需要32px、64px、128px边长的方形图标\n    \x26quot;128\x26quot;: \x26quot;res\/images\/lightning_green128.png\x26quot;,\n    \x26quot;32\x26quot;: \x26quot;res\/images\/lightning_green.png\x26quot;,\n    \x26quot;64\x26quot;: \x26quot;res\/images\/lightning_green64.png\x26quot;\n  },\n  \x26quot;page_action\x26quot;: { \/\/ 扩展的一种类型，说明这是页面级的扩展\n    \x26quot;default_title\x26quot;: \x26quot;IHeader\x26quot;, \/\/ 默认名称\n    \x26quot;default_icon\x26quot;: \x26quot;res\/images\/lightning_default.png\x26quot;, \/\/ 默认图标\n    \x26quot;default_popup\x26quot;: \x26quot;res\/index.html\x26quot; \/\/ 点击时弹出的页面路径\n  },\n  \x26quot;background\x26quot;: { \/\/ 扩展在后台运行的脚本\n    \x26quot;persistent\x26quot;: true, \/\/ 由于后台脚本需要持续运行，需要设置为true，反之扩展不活动时可能被浏览器关闭\n    \x26quot;scripts\x26quot;: [\x26quot;res\/js\/message.js\x26quot;, \x26quot;res\/js\/background.js\x26quot;] \/\/ 指定运行的脚本，实际上Chrome会启用一个匿名的html去引用这些js脚本。等同于\x26quot;pages\x26quot;:[\x26quot;background.html\x26quot;]这种方式（注意这两种互斥，同时设置时，后一种有效）\n  },\n  \x26quot;commands\x26quot;: { \/\/ 指定快捷键\n    \x26quot;toggle_status\x26quot;: { \/\/ 快捷命令的名称\n      \x26quot;suggested_key\x26quot;: { \/\/ 快捷命令的热键\n        \x26quot;default\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n        \x26quot;windows\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n        \x26quot;mac\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n        \x26quot;chromeos\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n        \x26quot;linux\x26quot;: \x26quot;Alt\x2bH\x26quot;\n      },\n      \x26quot;description\x26quot;: \x26quot;Toggle IHeader\x26quot; \/\/ 描述\n    }\n  },\n  \x26quot;content_scripts\x26quot;: [ \/\/ 随着每个页面加载的内容脚本，通过它可以访问到页面的DOM\n    {\n      \x26quot;all_frames\x26quot;: false, \/\/ frame中不加载\n      \x26quot;matches\x26quot;: [\x26quot;\\u003Call_urls\x3e\x26quot;], \/\/ 匹配所有URL\n      \x26quot;js\x26quot;: [\x26quot;res\/js\/message.js\x26quot;, \x26quot;res\/js\/content.js\x26quot;] \/\/ 内容脚本的路径\n    }\n  ],\n  \x26quot;default_locale\x26quot;: \x26quot;en\x26quot;, \/\/ 默认语言\n  \x26quot;description\x26quot;: \x26quot;__MSG_description__\x26quot;, \/\/ 扩展描述\n  \x26quot;manifest_version\x26quot;: 2, \/\/ Chrome 18及更高版本中，应该指定为2，低于v18版本的Chrome浏览器可以指定为1或不指定\n  \x26quot;minimum_chrome_version\x26quot;: \x26quot;26.0\x26quot;, \/\/ 最低支持到v26版本，主要受制于chrome.runtime api\n  \x26quot;options_page\x26quot;: \x26quot;res\/options.html\x26quot;, \/\/ 选项页面的路径\n  \x26quot;permissions\x26quot;: [ \x26quot;tabs\x26quot; , \x26quot;webRequest\x26quot;, \x26quot;webRequestBlocking\x26quot;, \x26quot;http:\/\/*\/*\x26quot;, \x26quot;https:\/\/*\/*\x26quot;, \x26quot;contextMenus\x26quot;, \x26quot;notifications\x26quot;] \/\/ 扩展需要的权限\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22name\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22IHeader\x22\x3c\/span\x3e, \/\/ 扩展名称\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x221.1.0\x22\x3c\/span\x3e, \/\/ 扩展版本号\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22icons\x22\x3c\/span\x3e: { \/\/ 上传到chrome webstore需要32px、64px、128px边长的方形图标\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22128\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_green128.png\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x2232\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_green.png\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x2264\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_green64.png\x22\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22page_action\x22\x3c\/span\x3e: { \/\/ 扩展的一种类型，说明这是页面级的扩展\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22default_title\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22IHeader\x22\x3c\/span\x3e, \/\/ 默认名称\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22default_icon\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_default.png\x22\x3c\/span\x3e, \/\/ 默认图标\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22default_popup\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/index.html\x22\x3c\/span\x3e \/\/ 点击时弹出的页面路径\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22background\x22\x3c\/span\x3e: { \/\/ 扩展在后台运行的脚本\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22persistent\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \/\/ 由于后台脚本需要持续运行，需要设置为true，反之扩展不活动时可能被浏览器关闭\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22scripts\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/message.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/background.js\x22\x3c\/span\x3e] \/\/ 指定运行的脚本，实际上Chrome会启用一个匿名的html去引用这些js脚本。等同于\x3cspan class=\x22hljs-string\x22\x3e\x22pages\x22\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x22background.html\x22\x3c\/span\x3e]这种方式（注意这两种互斥，同时设置时，后一种有效）\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22commands\x22\x3c\/span\x3e: { \/\/ 指定快捷键\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22toggle_status\x22\x3c\/span\x3e: { \/\/ 快捷命令的名称\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22suggested_key\x22\x3c\/span\x3e: { \/\/ 快捷命令的热键\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22default\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22windows\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22mac\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22chromeos\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e\x22linux\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22description\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Toggle IHeader\x22\x3c\/span\x3e \/\/ 描述\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22content_scripts\x22\x3c\/span\x3e: [ \/\/ 随着每个页面加载的内容脚本，通过它可以访问到页面的DOM\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22all_frames\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \/\/ frame中不加载\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22matches\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22\\u003Call_urls\x26gt;\x22\x3c\/span\x3e], \/\/ 匹配所有URL\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22js\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/message.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/content.js\x22\x3c\/span\x3e] \/\/ 内容脚本的路径\n    }\n  ],\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_locale\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22en\x22\x3c\/span\x3e, \/\/ 默认语言\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22description\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22__MSG_description__\x22\x3c\/span\x3e, \/\/ 扩展描述\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22manifest_version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \/\/ Chrome 18及更高版本中，应该指定为2，低于v18版本的Chrome浏览器可以指定为1或不指定\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22minimum_chrome_version\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2226.0\x22\x3c\/span\x3e, \/\/ 最低支持到v26版本，主要受制于chrome.runtime api\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22options_page\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/options.html\x22\x3c\/span\x3e, \/\/ 选项页面的路径\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22permissions\x22\x3c\/span\x3e: [ \x3cspan class=\x22hljs-string\x22\x3e\x22tabs\x22\x3c\/span\x3e , \x3cspan class=\x22hljs-string\x22\x3e\x22webRequest\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22webRequestBlocking\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/*\/*\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/*\/*\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22contextMenus\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22notifications\x22\x3c\/span\x3e] \/\/ 扩展需要的权限\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\x3cstrong\x3eChrome Extension简介\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e开始开发之前，我们先来刷一波基础知识。\x3c\/p\x3e\n\x3cp\x3eChrome官方明确规定了插件、扩展和应用的区别：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e插件（Plugin）是通过调用 Webkit 内核 NPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C\/C\x2b\x2b、Java 等。插件重点在于接入浏览器底层，拥有更多的权限，可调用系统API，因此插件一般都不能跨系统。比如说最近Adobe宣布放弃的Flash，下载资源的迅雷以及网上付款的网银，它们都提供了Chrome插件，用以在特定场景启用并运行，从而实现丰富的功能。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e扩展（Extension）是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，它完全基于Chrome浏览器，借助HTML，CSS，JS等web技术实现功能，是Chrome提供的一种可开发的扩展技术。比如说今年横空出世的微信小程序，它就是微信提供的一种扩展技术。相对于插件而言，扩展程序拥有有限的权限和API，对底层系统不感知，从而具有良好的跨平台特性。注意插件和扩展都只有在Chrome启动后才会运行。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e应用（Application）同样是用于扩充Chrome浏览器功能。它与扩展的区别就在于，它拥有独立运行的用户界面，并且Chrome未启动时也能独立调用，就像一个独立的App一样。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e不注意区分的话，我们讲到Chrome插件，往往指的就是以上三者之一。为了避免引起误解，本篇将严格区分概念，避免使用插件这种含糊的说法。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e如何安装扩展\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e开发扩展，首先得从安装开始，从Chrome 21起，Chrome浏览器就增加了对扩展安装的限制，默认只允许从 Chrome Web Store （Chrome 网上应用店）安装扩展和应用，这意味着用户一般只能安装Chrome Web Store内的扩展和应用。\x3c\/p\x3e\n\x3cp\x3e如果你拖动一个crx安装文件到Chrome浏览器的任何一个普通网页，将会出现如下提示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26ecca096?w=299\x26amp;h=40\x26amp;f=png\x26amp;s=10013\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26ecca096?w=299\x26amp;h=40\x26amp;f=png\x26amp;s=10013\x22 alt=\x22扩展功能、应用和主题背景可能会损害您的计算机\x22 title=\x22扩展功能、应用和主题背景可能会损害您的计算机\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e点击\x3ccode\x3e继续\x3c\/code\x3e按钮，则会在浏览器左上角弹出如下警告。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f159d74?w=417\x26amp;h=90\x26amp;f=png\x26amp;s=17931\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f159d74?w=417\x26amp;h=90\x26amp;f=png\x26amp;s=17931\x22 alt=\x22无法添加来自此网站的应用、扩展程序和用于脚本\x22 title=\x22无法添加来自此网站的应用、扩展程序和用于脚本\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果你恰好在Github上发现一个不错的Chrome扩展程序，而Chrome Web Store中没有。是不是就没有办法安装呢？当然不是的，Chrome浏览器还有三种其它的方式可以加载扩展程序。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果是扩展程序源码目录，点击\x3ccode\x3echrome:\/\/extensions\/\x3c\/code\x3e页面的\x3ccode\x3e加载已解压的扩展程序\x3c\/code\x3e按钮就可以直接安装。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果是crx安装文件，直接拖动至\x3ccode\x3echrome:\/\/extensions\/\x3c\/code\x3e页面即可安装。安装过程如下所示：\x3c\/p\x3e\n\x3cp\x3e1） 拖放安装\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f130a43?w=438\x26amp;h=102\x26amp;f=png\x26amp;s=7676\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f130a43?w=438\x26amp;h=102\x26amp;f=png\x26amp;s=7676\x22 alt=\x22拖放以安装\x22 title=\x22拖放以安装\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e​    2）点击添加扩展程序\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f6370aa?w=506\x26amp;h=174\x26amp;f=png\x26amp;s=25028\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26f6370aa?w=506\x26amp;h=174\x26amp;f=png\x26amp;s=25028\x22 alt=\x22添加扩展\x22 title=\x22添加扩展\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e​    3）添加好的扩展如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26ed9575b?w=699\x26amp;h=173\x26amp;f=png\x26amp;s=34741\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e26ed9575b?w=699\x26amp;h=173\x26amp;f=png\x26amp;s=34741\x22 alt=\x22拖放安装后\x22 title=\x22拖放安装后\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e启动Chrome时添加参数\x3ccode\x3e--enable-easy-off-store-extension-install\x3c\/code\x3e ，用以开启简单的扩展安装模式，然后就能像之前一样随意拖动crx文件到浏览器页面进行安装。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e说到安装，自然有人会问，安装了某款扩展后，怎么查看该扩展的源码呢？Mac系统的用户请记住这个目录\x3ccode\x3e~\/Library\/Application Support\/Google\/Chrome\/Default\/Extensions\/\x3c\/code\x3e（windows的扩展目录暂无）。\x3c\/p\x3e\n\x3ch4\x3e扩展打包和更新\x3c\/h4\x3e\n\x3cp\x3e另外，中间的\x3ccode\x3e打包扩展程序\x3c\/code\x3e按钮用于将本地开发的扩展程序打包成crx包，首次打包还会生成秘钥文件（如IHeader.pem），如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzEg\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzEg\x22 alt=\x22打包扩展程序\x22 title=\x22打包扩展程序\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e36d4f467e?w=543\x26amp;h=251\x26amp;f=png\x26amp;s=33814\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e36d4f467e?w=543\x26amp;h=251\x26amp;f=png\x26amp;s=33814\x22 alt=\x22已打包好的扩展程序\x22 title=\x22已打包好的扩展程序\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e打包好的扩展程序，可以发送给其他人安装，或发布到Chrome Web Store（开发者注册费用为5$）。\x3c\/p\x3e\n\x3cp\x3e右边的\x3ccode\x3e立即更新扩展程序\x3c\/code\x3e按钮则用于更新扩展。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e扩展的基本组成\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e通常一个Chrome扩展包含如下资源或目录：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3emanifest.json入口配置文件（1个，位于根目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ejs文件（至少1个，位于根目录或子级目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e32px、64px、128px的方形icon各1个（位于根目录或子级目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e_locales目录， 用于提供国际化支持（可选，位于根目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epopup.html 弹出页面（可选，位于根目录或子级目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebackground.html 后台运行的页面，主要用于引入多个后台运行的js（可选，位于根目录或子级目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eoptions.html 选项页面，用于扩展的设置（可选，位于根目录或子级目录）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了方便管理，个人倾向于将HTML、JS、CSS，ICON等资源分类统一到同一个目录。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e扩展的分类\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e从使用场景上看，Chrome扩展可分为以下三类：\x3c\/p\x3e\n\x3cp\x3e1）Browser Action，浏览器扩展，可通过manifest.json中的\x3ccode\x3ebrowser_action\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;browser_action\x26quot;: {\n  \x26quot;default_title\x26quot;: \x26quot;Qrcode\x26quot;,\n  \x26quot;default_icon\x26quot;: \x26quot;images\/icon.png\x26quot;,\n  \x26quot;default_popup\x26quot;: \x26quot;index.html\x26quot; \/\/ 可选的\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22browser_action\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_title\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Qrcode\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_icon\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22images\/icon.png\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_popup\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22index.html\x22\x3c\/span\x3e \/\/ 可选的\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是URL生成二维码的Browser Action扩展，运行如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e36e7b35ff?w=274\x26amp;h=290\x26amp;f=gif\x26amp;s=31839\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e36e7b35ff?w=274\x26amp;h=290\x26amp;f=gif\x26amp;s=31839\x22 alt=\x22Browser Action演示\x22 title=\x22Browser Action演示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e该类扩展特点：全局扩展，icon长期占据浏览器右上角工具栏，每个页面均可用。\x3c\/p\x3e\n\x3cp\x3e2）Page Action，页面级扩展，可通过manifest.json中的\x3ccode\x3epage_action\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;page_action\x26quot;: {\n  \x26quot;default_title\x26quot;: \x26quot;IHeader\x26quot;,\n  \x26quot;default_icon\x26quot;: \x26quot;res\/images\/lightning_default.png\x26quot;,\n  \x26quot;default_popup\x26quot;: \x26quot;res\/index.html\x26quot; \/\/ 可选的\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22page_action\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_title\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22IHeader\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_icon\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_default.png\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_popup\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/index.html\x22\x3c\/span\x3e \/\/ 可选的\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是本篇将要讲解的Page Action的扩展——IHeader，它被指定为所有页面可见，其icon状态切换如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e3dedaaf2f?w=259\x26amp;h=232\x26amp;f=gif\x26amp;s=87285\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e3dedaaf2f?w=259\x26amp;h=232\x26amp;f=gif\x26amp;s=87285\x22 alt=\x22Page Action演示\x22 title=\x22Page Action演示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e该类扩展特点：不同页面可以拥有不同的状态和不同的icon，icon在指定的页面可见，可见时位于浏览器右上角工具栏。\x3c\/p\x3e\n\x3cp\x3e由上可见，Browser Action与Page Action功能上非常相似，配置上各自的内部属性也完全一致，它们不仅可以配置点击时弹出的页面，同时还可以绑定点击事件，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 以下事件绑定一般在background.js中运行\n\/\/ Browser Action\nchrome.browserAction.onClicked.addListener(function(tab) {\n  console.log(tab.id, tab.url);\n  chrome.tabs.executeScript(tab.id, {file: \x27content.js\x27});\n});\n\/\/ Page Action\nchrome.pageAction.onClicked.addListener(function(tab) {\n  console.log(tab.id, tab.url);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以下事件绑定一般在background.js中运行\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Browser Action\x3c\/span\x3e\nchrome.browserAction.onClicked.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etab\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(tab.id, tab.url);\n  chrome.tabs.executeScript(tab.id, {\x3cspan class=\x22hljs-attr\x22\x3efile\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27content.js\x27\x3c\/span\x3e});\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Page Action\x3c\/span\x3e\nchrome.pageAction.onClicked.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etab\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(tab.id, tab.url);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果非要说两者的差别，开发中能够感受到的就是：前者不需要维护icon状态，后者需要针对每个启用的页面管理不同的icon状态。\x3c\/p\x3e\n\x3cp\x3e3）Omnibox，全能工具条，可通过manifest.json中的\x3ccode\x3eomnibox\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;omnibox\x26quot;: {\n  \x26quot;keyword\x26quot;: \x26quot;mdn-\x26quot; \/\/URL地址栏输入关键字\x26quot;mdn-\x26quot;\x2b空格后，就会触发Omnibox\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22omnibox\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22keyword\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22mdn-\x22\x3c\/span\x3e \/\/URL地址栏输入关键字\x3cspan class=\x22hljs-string\x22\x3e\x22mdn-\x22\x3c\/span\x3e\x2b空格后，就会触发Omnibox\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是MDN网站快捷查询的Omnibox扩展，运行如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4619f4890?w=560\x26amp;h=136\x26amp;f=gif\x26amp;s=235309\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4619f4890?w=560\x26amp;h=136\x26amp;f=gif\x26amp;s=235309\x22 alt=\x22Omnibox演示\x22 title=\x22Omnibox演示\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e很明显，你可以对地址栏的各种输入做定制，Chrome的URL地址栏只所以强大，omnibox可谓功不可没。\x3c\/p\x3e\n\x3cp\x3e该类扩展特点：运行在URL地址栏，无弹出界面，用户在输入时，扩展就可以显示建议或者自动完成一些工作。\x3c\/p\x3e\n\x3cp\x3e以上三类决定了扩展如何在浏览器中运行。除此之外，每个扩展程序还可以任意搭载如下页面或脚本。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eBackground Page，后台页面，可通过manifest.json中的\x3ccode\x3ebackground\x3c\/code\x3e属性设置，里面再细分\x3ccode\x3escript\x3c\/code\x3e或\x3ccode\x3epage\x3c\/code\x3e，分别表示脚本和页面，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;background\x26quot;: {\n  \x26quot;persistent\x26quot;: true, \/\/默认为false，指定为true时将在后台持续运行\n  \x26quot;scripts\x26quot;: [\x26quot;res\/js\/background.js\x26quot;] \/\/ 指定后台运行的js\n  \/\/ \x26quot;page\x26quot;: [\x26quot;res\/background.html\x26quot;]  \/\/ 指定后台运行的html，html中需引入若干个js，没有用户界面，实际上就相当于引入多个js脚本\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22background\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22persistent\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \/\/默认为false，指定为true时将在后台持续运行\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22scripts\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/background.js\x22\x3c\/span\x3e] \/\/ 指定后台运行的js\n  \/\/ \x3cspan class=\x22hljs-string\x22\x3e\x22page\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22res\/background.html\x22\x3c\/span\x3e]  \/\/ 指定后台运行的html，html中需引入若干个js，没有用户界面，实际上就相当于引入多个js脚本\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eBackground Page在扩展中之所以重要，主要归功于\x3cstrong\x3e它可以使用所有的Chrome.* API\x3c\/strong\x3e。借助它\x3ccode\x3epopup.js\x3c\/code\x3e 和 \x3ccode\x3econtent.js\x3c\/code\x3e 可以随时进行消息通信，并且调用它们原本无法调用的API。\x3c\/p\x3e\n\x3cp\x3e根据persistent值是否为true，Background Page可分为两类：① \x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/background_pages\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePersistent Background Pages\x3c\/a\x3e，② \x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/event_pages\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEvent Pages\x3c\/a\x3e。前者持续运行，随时可访问；后者只有在事件触发时才能访问。\x3c\/p\x3e\n\x3cp\x3e该页面特点：运行在浏览器后台，无用户界面，后台页面可用于页面间消息通信以及后台监控，一旦浏览器启动，后台页面就会自动运行。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eContent Script，内容脚本，可通过manifest.json中的\x3ccode\x3econtent_scripts\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;content_scripts\x26quot;: [\n  {\n    \x26quot;all_frames\x26quot;: true, \/\/ 默认为false，指定为true意味着frame中也加载内容脚本\n    \x26quot;matches\x26quot;: [\x26quot;\\u003Call_urls\x3e\x26quot;], \/\/ 匹配所有URL，意味着任何页面都会加载\n    \x26quot;js\x26quot;: [\x26quot;res\/js\/content.js\x26quot;], \/\/ 指定运行的内容脚本\n    \x26quot;run_at\x26quot;: \x26quot;document_end\x26quot; \/\/ 页面加载完成后执行\n  }\n],\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22content_scripts\x22\x3c\/span\x3e: [\n  {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22all_frames\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \/\/ 默认为false，指定为true意味着frame中也加载内容脚本\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22matches\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22\\u003Call_urls\x26gt;\x22\x3c\/span\x3e], \/\/ 匹配所有URL，意味着任何页面都会加载\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22js\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22res\/js\/content.js\x22\x3c\/span\x3e], \/\/ 指定运行的内容脚本\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22run_at\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22document_end\x22\x3c\/span\x3e \/\/ 页面加载完成后执行\n  }\n],\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了配置之外，内容脚本还可以通过js的方式动态载入。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 动态载入js文件\nchrome.tabs.executeScript(tabId, {file: \x27res\/js\/content.js\x27});\n\/\/ 动态载入js语句\nchrome.tabs.executeScript(tabId, {code: \x27alert(\x26quot;Hello Extension!\x26quot;)\x27});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 动态载入js文件\x3c\/span\x3e\nchrome.tabs.executeScript(tabId, {\x3cspan class=\x22hljs-attr\x22\x3efile\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27res\/js\/content.js\x27\x3c\/span\x3e});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 动态载入js语句\x3c\/span\x3e\nchrome.tabs.executeScript(tabId, {\x3cspan class=\x22hljs-attr\x22\x3ecode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27alert(\x22Hello Extension!\x22)\x27\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该脚本特点：每个页面在加载时都会加载内容脚本，加载时机可以指定为\x3ccode\x3edocument_start\x3c\/code\x3e、\x3ccode\x3eidel\x3c\/code\x3e或\x3ccode\x3eend\x3c\/code\x3e（分别为页面DOM加载开始时，空闲时及完成后）；\x3cstrong\x3e内容脚本是唯一可以访问页面DOM的脚本\x3c\/strong\x3e，通过它可以操作页面的DOM节点，从而影响视觉呈现；基于安全考虑，内容脚本被设计成与页面其他的JS存在于两个不同的沙盒，因此无法互相访问各自的全局变量。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eOption Html，设置页面，可通过manifest.json中的\x3ccode\x3eoptions_page\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;options_page\x26quot;: \x26quot;res\/options.html\x26quot;,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22options_page\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/options.html\x22\x3c\/span\x3e,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该页面特点：点击扩展程序icon的右键菜单上【选项】按钮进入到设置页面，该页面一般用于扩展的选项设置。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eOverride Html，替换新建标签页的空白页面，可通过manifest.json中的\x3ccode\x3echrome_url_overrides\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;chrome_url_overrides\x26quot;:{\n  \x26quot;newtab\x26quot;: \x26quot;blank.html\x26quot;\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22chrome_url_overrides\x22\x3c\/span\x3e:{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22newtab\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22blank.html\x22\x3c\/span\x3e\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该页面特点：常用于替换浏览器默认的空白标签页内容，多见于新开标签页时的壁纸程序，基于它你完全可以打造一个属于自己的空白页。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eDevtool Page，开发者页面，可通过manifest.json中的\x3ccode\x3edevtools_page\x3c\/code\x3e属性设置，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;devtools_page\x26quot;: \x26quot;debug.html\x26quot;,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22devtools_page\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22debug.html\x22\x3c\/span\x3e,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该页面特点：随着控制台打开而启动，可用于将扩展收到的消息输出到当前控制台。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e总之，对于Chrome扩展而言，Browser Action、Page Action 或 Omnibox之间是互斥的，其它情况下它并不限制你需要添加哪些页面或脚本，只要你愿意，就可以随意组合。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e扩展如何运行调试\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e只要你会写js，就可以开发Chrome扩展程序了。涉及到开发，调试是不可避免的，Chrome扩展的调试也非常简单。我们都知道Chrome浏览器的 \x3ccode\x3echrome:\/\/extensions\/\x3c\/code\x3e页面可以查看所有的Chrome扩展，不仅如此，该页面下的\x3ccode\x3e加载已解压的扩展程序\x3c\/code\x3e按钮，便可以直接加载本地开发的扩展程序，如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzEL\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzEL\x22 alt=\x22加载已解压的扩展程序\x22 title=\x22加载已解压的扩展程序\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e注意：需要勾选开发者模式才会出现\x3ccode\x3e加载已解压的扩展程序\x3c\/code\x3e按钮。\x3c\/p\x3e\n\x3cp\x3e成功加载后的扩展跟正常安装的扩展程序，没有什么不同，接下来，我们就可以使用web技术进行调试了。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e点击以上的\x3ccode\x3e选项\x3c\/code\x3e或\x3ccode\x3e背景页\x3c\/code\x3e按钮，将分别打开选项页面和背景页。选项页面是一个正常的html页面，按\x3ccode\x3e⌃\x2b⌘\x2bJ\x3c\/code\x3e 键打开控制台就可以调试了。背景页没有界面，打开的就是控制台。这两个页面都可以断点debug。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eBrowser Action 或 Page Action的扩展通常在Chrome浏览器的右上角会出现一个Icon，右键点击该Icon，点击右键菜单的\x3ccode\x3e审查弹出内容\x3c\/code\x3e按钮，将会在打开弹出页面的同时打开它的控制台。这个控制台也可以直接debug。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\x3cstrong\x3eChrome Extension API\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3eChrome陆续向开发者开放了大量的API。使用这些API，我们可以监听或代理网络请求，存储数据，管理标签页和Cookie，绑定快捷键、设置右键菜单，添加通知和闹钟，获取CPU、电池、内存、显示器的信息等等（还有很多没有列举出来）。具体请阅读\x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/api_index\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChrome API官方文档\x3c\/a\x3e。请注意，使用相应的API，往往需要申请对应的权限，如IHeader申请的权限如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;permissions\x26quot;: [ \x26quot;tabs\x26quot; , \x26quot;webRequest\x26quot;, \x26quot;webRequestBlocking\x26quot;, \x26quot;http:\/\/*\/*\x26quot;, \x26quot;https:\/\/*\/*\x26quot;, \x26quot;contextMenus\x26quot;, \x26quot;notifications\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22permissions\x22\x3c\/span\x3e: [ \x3cspan class=\x22hljs-string\x22\x3e\x22tabs\x22\x3c\/span\x3e , \x3cspan class=\x22hljs-string\x22\x3e\x22webRequest\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22webRequestBlocking\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/*\/*\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/*\/*\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22contextMenus\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22notifications\x22\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上，IHeader依次申请了标签页、请求、请求断点、http网站，https网站，右键菜单，桌面通知的权限。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3eWebRequest API\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3eChrome Extension API中，能够修改请求的，只有chrome.webRequest了。webRequest能够为请求的不同阶段添加事件监听器，这些事件监听器，可以收集请求的详细信息，甚至修改或取消请求。\x3c\/p\x3e\n\x3cp\x3e事件监听器只在特定阶段触发，它们的触发顺序如下所示。（图片来自\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/Add-ons\/WebExtensions\/API\/webRequest\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4980b474e?w=624\x26amp;h=340\x26amp;f=png\x26amp;s=24362\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4980b474e?w=624\x26amp;h=340\x26amp;f=png\x26amp;s=24362\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e事件监听器的含义如下所示。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonBeforeRequest\x3c\/strong\x3e，请求发送之前触发（请求的第1个事件，请求尚未创建，此时可以取消或者重定向请求）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonBeforeSendHeaders\x3c\/strong\x3e，请求头发送之前触发（请求的第2个事件，此时可定制请求头，\x3cstrong\x3e部分缓存等有关的请求头\x3c\/strong\x3e（Authorization、Cache-Control、Connection、Content-\x3cbr\x3eLength、Host、If-Modified-Since、If-None-Match、If-Range、Partial-Data、Pragma、Proxy-\x3cbr\x3eAuthorization、Proxy-Connection和Transfer-Encoding）不出现在请求信息中，可以通过添加同名的key覆盖修改其值，但是不能删除）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonSendHeaders\x3c\/strong\x3e，请求头发送之前触发（请求的第3个事件，此时只能查看请求信息，可以确认onBeforeSendHeaders事件中都修改了哪些请求头）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonHeadersReceived\x3c\/strong\x3e，响应头收到之后触发（请求的第4个事件，此时可定制响应头，且只能修改或删除非缓存相关字段或添加字段，由于响应头允许多个同名字段同时存在，因此无法覆盖修改缓存相关的字段）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonResponseStarted\x3c\/strong\x3e，响应内容开始传输之后触发（请求的第5个事件，此时只能查看响应信息，可以确认onHeadersReceived事件中都修改了哪些响应头）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonCompleted\x3c\/strong\x3e，响应接受完成后触发（请求的第6个事件，此时只能查看响应信息）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonBeforeRedirect\x3c\/strong\x3e，onHeadersReceived事件之后，请求重定向之前触发（此时只能查看响应头信息）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eonAuthRequired\x3c\/strong\x3e，onHeadersReceived事件之后，收到401或者407状态码时触发（此时可以取消请求、同步提供凭证或异步提供凭证）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上，凡是能够修改请求的事件监听器，都能够指定其extraInfoSpec参数数组中包含\x22blocking\x22字符串（意味着能阻塞请求并修改），反之则不行。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e另外请注意，Chrome对于请求头和响应头的展示有着明确的规定，即控制台中只展示发送出去或刚接收到的字段。因此编辑后的请求字段，控制台的network栏能够正常展示；而编辑后的响应字段由于不属于刚接收到的字段，所以从控制台上就会看不到编辑的痕迹，如同没修改过一样，实际上编辑仍然有效。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e事件监听器含义虽不同，但语法却一致。接下来我们就以onHeadersReceived为例，进行深入分析。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\x3cstrong\x3e如何绑定header监听\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e还记得我们的目标吗？想要去掉Google网站HTML响应头的\x3ccode\x3eX-Frame-Options\x3c\/code\x3e字段。请看如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 监听的回调\nvar callback = function(details) {\n  var headers = details.responseHeaders;\n  for (var i = 0; i \x3c headers.length; \x2b\x2bi) {\n    \/\/ 移除X-Frame-Options字段\n    if (headers[i].name === \x27X-Frame-Options\x27) {\n      headers.splice(i, 1);\n      break;\n    }\n  }\n  \/\/ 返回修改后的headers列表\n  return { responseHeaders: headers };\n};\n\/\/ 监听哪些内容\nvar filter = {\n  urls: [\x26quot;\x3call_urls\x3e\x26quot;]\n};\n\/\/ 额外的信息规范，可选的\nvar extraInfoSpec = [\x26quot;blocking\x26quot;, \x26quot;responseHeaders\x26quot;];\n\/* 监听response headers接收事件*\/\nchrome.webRequest.onHeadersReceived.addListener(callback, filter, extraInfoSpec);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听的回调\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edetails\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e headers = details.responseHeaders;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; headers.length; \x2b\x2bi) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除X-Frame-Options字段\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (headers[i].name === \x3cspan class=\x22hljs-string\x22\x3e\x27X-Frame-Options\x27\x3c\/span\x3e) {\n      headers.splice(i, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回修改后的headers列表\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3eresponseHeaders\x3c\/span\x3e: headers };\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听哪些内容\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e filter = {\n  \x3cspan class=\x22hljs-attr\x22\x3eurls\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;all_urls\x26gt;\x22\x3c\/span\x3e]\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 额外的信息规范，可选的\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extraInfoSpec = [\x3cspan class=\x22hljs-string\x22\x3e\x22blocking\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22responseHeaders\x22\x3c\/span\x3e];\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 监听response headers接收事件*\/\x3c\/span\x3e\nchrome.webRequest.onHeadersReceived.addListener(callback, filter, extraInfoSpec);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3echrome.webRequest.onHeadersReceived.addListener表示添加一个接收响应头的监听。以上代码中的关键参数或属性，下面逐一讲解。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ecallback，即事件触发时的回调，该回调默认传入一个参数（details），details就是请求的详情。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3efilter，Object类型，限制事件回调callback触发的过滤器。filter有四个属性可以指定，分别为①urls（包含指定url的数组）、②types（请求的类型，共8种）、③tabId（标签页id）、④windowId（窗口id）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eextraInfoSpec，数组类型，指的是额外的选项列表。对于headersReceived事件而言，包含\x22blocking\x22，意味着要求请求同步，基于此才可以修改响应头；包含\x22responseHeaders\x22意味着事件回调的默认参数details中将包含responseHeaders字段，该字段指向响应头列表。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e既然有了添加监听的方法，自然，还会有移除监听的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.webRequest.onHeadersReceived.removeListener(listener);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3echrome.webRequest.onHeadersReceived.removeListener(listener);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外，为了避免重复监听，还可以判断监听是否已经存在。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var bool = chrome.webRequest.onHeadersReceived.hasListener(listener);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bool = chrome.webRequest.onHeadersReceived.hasListener(listener);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了保证更好的理清以上属性、方法或参数的逻辑关系，请看如下脑图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86fcf7da724c?w=1000\x26amp;h=481\x26amp;f=png\x26amp;s=301151\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86fcf7da724c?w=1000\x26amp;h=481\x26amp;f=png\x26amp;s=301151\x22 alt=\x22headersReceived事件\x22 title=\x22headersReceived事件\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e\x3cstrong\x3e扩展状态管理\x3c\/strong\x3e\x3c\/h3\x3e\n\x3ch4\x3e\x3cstrong\x3e监听器的状态管理\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e知道了如何绑定监听器，仅仅是第一步。监听器需要在合适的时机绑定，也需要在合适的时机解绑。为了不影响Chrome的访问速度，我们只在需要的标签页创建新的监听器，因此监听器需要依赖filter来区分不同的tabId，考虑到用户可能只需要监听一部分请求类型，types的区分也是不可避免的。又由于一个Tab里不同的时间段可能会加载不同的页面，一个监听器在不同的页面下正常运行也是必须的（因此监听器的filter中不需要指定urls）。\x3c\/p\x3e\n\x3cp\x3e寥寥数语，可能不足以描述出监听器状态管理的原貌，请看下图进一步帮助理解。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4d2ea395c?w=1327\x26amp;h=346\x26amp;f=png\x26amp;s=58933\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e4d2ea395c?w=1327\x26amp;h=346\x26amp;f=png\x26amp;s=58933\x22 alt=\x22页面监听器\x22 title=\x22页面监听器\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e以上，一个请求将依次触发上述①②③④⑤五个事件回调，每个事件回调都对应着一个监听器，这些监听器分为两类（从颜色上也可看出端倪）。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e②③⑤监听器的主要功能是\x3cstrong\x3e记录\x3c\/strong\x3e，用于监听页面上每一个Request的请求头和响应头，以及请求响应时间。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e①④监听器的主要功能是\x3cstrong\x3e更新\x3c\/strong\x3e，用于增加、删除或修改指定Request的请求头和响应头。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e若Chrome指定的标签页激活了IHeader扩展，②③⑤监听器就会记录当前标签页后续的指定类型的请求信息。若用户在激活了IHeader扩展的标签页更新了Request的请求头或响应头，①或④监听器就会被开启。不用担心监听器开启无限个，我准备了回收机制，单个标签页的所有监听器都会在标签页关闭或IHeader扩展取消激活后释放掉。\x3c\/p\x3e\n\x3cp\x3e首先，为方便管理，先封装下监听器的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 独立的监听器 *\/\nvar Listener = (function(){\n  var webRequest = chrome.webRequest;\n\n  function Listener(type, filter, extraInfoSpec, callback){\n    this.type = type; \/\/ 事件名称\n    this.filter = filter; \/\/ 过滤器\n    this.extraInfoSpec = extraInfoSpec; \/\/ 额外的参数\n    this.callback = callback; \/\/ 事件回调\n    this.init();\n  }\n  Listener.prototype.init = function(){\n    webRequest[this.type].addListener( \/\/ 添加一个监听器\n      this.callback,\n      this.filter,\n      this.extraInfoSpec\n    );\n    return this;\n  };\n  Listener.prototype.remove = function(){\n    webRequest[this.type].removeListener(this.callback); \/\/ 移除监听器\n    return this;\n  };\n  Listener.prototype.reload = function(){ \/\/ 重启监听器(用于选项页面更新请求类型后重启所有已开启的监听器)\n    this.remove().init();\n    return this;\n  };\n  return Listener;\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 独立的监听器 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Listener = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e webRequest = chrome.webRequest;\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eListener\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, filter, extraInfoSpec, callback\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件名称\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.filter = filter; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 过滤器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.extraInfoSpec = extraInfoSpec; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 额外的参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.callback = callback; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件回调\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.init();\n  }\n  Listener.prototype.init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    webRequest[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type].addListener( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加一个监听器\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.callback,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.filter,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.extraInfoSpec\n    );\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  Listener.prototype.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    webRequest[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type].removeListener(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.callback); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除监听器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  Listener.prototype.reload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重启监听器(用于选项页面更新请求类型后重启所有已开启的监听器)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.remove().init();\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Listener;\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e监听器封装好了，剩下的便是管理，监听器控制器基于标签页的维度统一管理标签页上所有的监听器，代码如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 监听器控制器 *\/\nvar ListenerControler = (function(){\n  var allListeners = {}; \/* 所有的监听器控制器列表 *\/\n  function ListenerControler(tabId){\n    if(allListeners[tabId]){ \/* 如有就返回已有的实例 *\/\n      return allListeners[tabId];\n    }\n    if(!(this instanceof ListenerControler)){ \/* 强制以构造器方式调用 *\/\n      return new ListenerControler(tabId);\n    }\n\n    \/* 初始化变量 *\/\n    var _this = this;\n    var filter = getFilter(tabId); \/\/ 获取当前监听的filter设置\n    \/* 捕获requestHeaders *\/\n    var l1 = new Listener(\x27onSendHeaders\x27, filter, [\x27requestHeaders\x27], function(details){\n      _this.saveMesage(\x27request\x27, details); \/\/ 记录请求的头域信息\n    });\n    \/* 捕获responseHeaders *\/\n    var l2 = new Listener(\x27onResponseStarted\x27, filter, [\x27responseHeaders\x27], function(details){\n      _this.saveMesage(\x27response\x27, details); \/\/ 记录响应的头域信息\n    });\n    \/* 捕获 Completed Details *\/\n    var l3 = new Listener(\x27onCompleted\x27, filter, [\x27responseHeaders\x27], function(details){\n      _this.saveMesage(\x27complete\x27, details); \/\/ 记录请求完成时的时间等信息\n    });\n\n    allListeners[tabId] = this; \/\/ 记录当前的标签页控制器\n    this.tabId = tabId;\n    this.listeners = {  \/\/ 记录已开启的监听器\n      \x27onSendHeaders\x27: l1,\n      \x27onResponseStarted\x27: l2,\n      \x27onCompleted\x27: l3\n    };\n    this.messages = {}; \/\/ 当前标签页的请求信息集合\n    console.log(\x27tabId=\x27 \x2b tabId \x2b \x27 listener on\x27);\n  }\n  ListenerControler.has = function(tabId){...} \/\/ 判断是否包含指定标签页的控制器\n  ListenerControler.get = function(tabId){...} \/\/ 返回指定标签页的控制器\n  ListenerControler.getAll = function(){...} \/\/ 获取所有的标签页控制器\n  ListenerControler.remove = function(tabId){...} \/\/ 移除指定标签页下的所有监听器\n  ListenerControler.prototype.remove = function(){...} \/\/ 移除当前控制器中的所有监听器\n  ListenerControler.prototype.saveMesage = function(type, message){...} \/\/ 记录请求信息\n  return ListenerControler;\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 监听器控制器 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ListenerControler = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e allListeners = {}; \x3cspan class=\x22hljs-comment\x22\x3e\/* 所有的监听器控制器列表 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eListenerControler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(allListeners[tabId]){ \x3cspan class=\x22hljs-comment\x22\x3e\/* 如有就返回已有的实例 *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e allListeners[tabId];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e ListenerControler)){ \x3cspan class=\x22hljs-comment\x22\x3e\/* 强制以构造器方式调用 *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ListenerControler(tabId);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 初始化变量 *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e filter = getFilter(tabId); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取当前监听的filter设置\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 捕获requestHeaders *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Listener(\x3cspan class=\x22hljs-string\x22\x3e\x27onSendHeaders\x27\x3c\/span\x3e, filter, [\x3cspan class=\x22hljs-string\x22\x3e\x27requestHeaders\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edetails\x3c\/span\x3e)\x3c\/span\x3e{\n      _this.saveMesage(\x3cspan class=\x22hljs-string\x22\x3e\x27request\x27\x3c\/span\x3e, details); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录请求的头域信息\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 捕获responseHeaders *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Listener(\x3cspan class=\x22hljs-string\x22\x3e\x27onResponseStarted\x27\x3c\/span\x3e, filter, [\x3cspan class=\x22hljs-string\x22\x3e\x27responseHeaders\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edetails\x3c\/span\x3e)\x3c\/span\x3e{\n      _this.saveMesage(\x3cspan class=\x22hljs-string\x22\x3e\x27response\x27\x3c\/span\x3e, details); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录响应的头域信息\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 捕获 Completed Details *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Listener(\x3cspan class=\x22hljs-string\x22\x3e\x27onCompleted\x27\x3c\/span\x3e, filter, [\x3cspan class=\x22hljs-string\x22\x3e\x27responseHeaders\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edetails\x3c\/span\x3e)\x3c\/span\x3e{\n      _this.saveMesage(\x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e, details); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录请求完成时的时间等信息\x3c\/span\x3e\n    });\n\n    allListeners[tabId] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录当前的标签页控制器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId = tabId;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listeners = {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录已开启的监听器\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e\x27onSendHeaders\x27\x3c\/span\x3e: l1,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27onResponseStarted\x27\x3c\/span\x3e: l2,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27onCompleted\x27\x3c\/span\x3e: l3\n    };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.messages = {}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前标签页的请求信息集合\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27tabId=\x27\x3c\/span\x3e \x2b tabId \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 listener on\x27\x3c\/span\x3e);\n  }\n  ListenerControler.has = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断是否包含指定标签页的控制器\x3c\/span\x3e\n  ListenerControler.get = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回指定标签页的控制器\x3c\/span\x3e\n  ListenerControler.getAll = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取所有的标签页控制器\x3c\/span\x3e\n  ListenerControler.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除指定标签页下的所有监听器\x3c\/span\x3e\n  ListenerControler.prototype.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除当前控制器中的所有监听器\x3c\/span\x3e\n  ListenerControler.prototype.saveMesage = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, message\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录请求信息\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ListenerControler;\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过监听器控制器的统一调度，标签页中的多个监听器才能高效的工作。\x3c\/p\x3e\n\x3cp\x3e实际上，还有很多工作，上述代码还没有体现出来。比方说用户在激活了IHeader扩展的标签页更新了Request的请求头或响应头，①beforeSendHeaders或④headersReceived监听器又是怎么运作的呢？这部分内容，请结合『如何绑定header监听』节点的内容理解。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3ePage Action图标状态管理\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e标签页控制器的状态需要由视觉体现出来，因此Page Action图标的管理也是不可避免的。通常，默认的icon可以在manifest.json中指定。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;page_action\x26quot;: {\n  \x26quot;default_icon\x26quot;: \x26quot;res\/images\/lightning_default.png\x26quot;, \/\/ 默认图标\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22page_action\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22default_icon\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22res\/images\/lightning_default.png\x22\x3c\/span\x3e, \/\/ 默认图标\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eicon有如下3种状态（后两种状态可以互相切换）。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e默认状态，展示默认的icon。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e初始状态，展示扩展初始化后的icon。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e激活状态，展示扩展激活后的icon。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eChrome提供了chrome.pageAction的API供Page Action使用。目前chrome.pageAction拥有如下方法。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eshow，在指定的tab下展示Page Action。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehide，在指定的tab下隐藏Page Action。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3esetTitle，设置Page Action的标题（鼠标移动到该Page Action上时会出现设置好的标题提示）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egetTitle，获取Page Action的标题。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3esetIcon，设置Page Action的图标。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3esetPopup，设置点击时弹出页面的URL。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egetPopup，获取点击时弹出页面的URL。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上，setTitle、setIcon 和 show方法比较常用。其中，show方法有两种作用，①展示icon，②更新icon，因此一般是先设置好icon的标题和路径，然后调用show展示出来（或更新）。需要注意的是，Page Action在show方法被调用之前，是不会响应点击的，所以需要在初始化工作结束之前调用show方法。千言万语不如上代码，如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 声明3种icon状态 *\/\nvar UNINIT = 0, \/\/ 扩展未初始化\n    INITED = 1, \/\/ 扩展已初始化，但未激活\n    ACTIVE = 2; \/\/ 扩展已激活\n\/* 处理扩展icon状态 *\/\nvar PageActionIcon = (function(){\n  var pageAction = chrome.pageAction, icons = {}, tips = {};\n  icons[INITED] = \x27res\/images\/lightning_green.png\x27; \/\/ 设置不同状态下的icon路径(相对于扩展根目录)\n  icons[ACTIVE] = \x27res\/images\/lightning_red.png\x27;\n\n  tips[INITED] = Text(\x27iconTips\x27); \/\/ 其它地方有处理，Text被指向chrome.i18n.getMessage，用以读取_locales中指定语言的对应字段的文本信息\n  tips[ACTIVE] = Text(\x27iconHideTips\x27);\n\n  function PageActionIcon(tabId){ \/\/ 构造器\n    this.tabId  = tabId;\n    this.status = UNINIT; \/\/ 默认为未初始化状态\n    pageAction.show(tabId); \/\/ 展示Page Action\n  }\n  PageActionIcon.prototype.init = function(){...} \/\/ 初始化icon\n  PageActionIcon.prototype.active = function(){...} \/\/ icon切换为激活状态\n  PageActionIcon.prototype.hide = function(){...} \/\/ 隐藏icon\n  PageActionIcon.prototype.setIcon = function(){ \/\/ 设置icon\n    pageAction.setIcon({ \/\/ 设置icon的路径\n      tabId : this.tabId,\n      path  : icons[this.status]\n    });\n    pageAction.setTitle({ \/\/ 设置icon的标题\n      tabId : this.tabId,\n      title : tips[this.status]\n    });\n    return this;\n  };\n  PageActionIcon.prototype.restore = function(){\/\/ 刷新页面后，icon之前的状态会丢失，需要手动恢复\n    this.setIcon();\n    pageAction.show(this.tabId);\n    return this;\n  };\n  return PageActionIcon;\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 声明3种icon状态 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e UNINIT = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 扩展未初始化\x3c\/span\x3e\n    INITED = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 扩展已初始化，但未激活\x3c\/span\x3e\n    ACTIVE = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 扩展已激活\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 处理扩展icon状态 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e PageActionIcon = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pageAction = chrome.pageAction, icons = {}, tips = {};\n  icons[INITED] = \x3cspan class=\x22hljs-string\x22\x3e\x27res\/images\/lightning_green.png\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置不同状态下的icon路径(相对于扩展根目录)\x3c\/span\x3e\n  icons[ACTIVE] = \x3cspan class=\x22hljs-string\x22\x3e\x27res\/images\/lightning_red.png\x27\x3c\/span\x3e;\n\n  tips[INITED] = Text(\x3cspan class=\x22hljs-string\x22\x3e\x27iconTips\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其它地方有处理，Text被指向chrome.i18n.getMessage，用以读取_locales中指定语言的对应字段的文本信息\x3c\/span\x3e\n  tips[ACTIVE] = Text(\x3cspan class=\x22hljs-string\x22\x3e\x27iconHideTips\x27\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePageActionIcon\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId  = tabId;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status = UNINIT; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为未初始化状态\x3c\/span\x3e\n    pageAction.show(tabId); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示Page Action\x3c\/span\x3e\n  }\n  PageActionIcon.prototype.init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化icon\x3c\/span\x3e\n  PageActionIcon.prototype.active = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ icon切换为激活状态\x3c\/span\x3e\n  PageActionIcon.prototype.hide = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 隐藏icon\x3c\/span\x3e\n  PageActionIcon.prototype.setIcon = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置icon\x3c\/span\x3e\n    pageAction.setIcon({ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置icon的路径\x3c\/span\x3e\n      tabId : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId,\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e  : icons[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status]\n    });\n    pageAction.setTitle({ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置icon的标题\x3c\/span\x3e\n      tabId : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId,\n      \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e : tips[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status]\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  PageActionIcon.prototype.restore = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 刷新页面后，icon之前的状态会丢失，需要手动恢复\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setIcon();\n    pageAction.show(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e PageActionIcon;\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eicon管理的准备工作ok了，剩下的就是使用了，如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new PageActionIcon(this.tabId).init();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e PageActionIcon(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId).init();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e标签页的状态管理\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e对于IHeader扩展程序，一个标签页同时包含了监听器状态和icon状态的变化。因此需要再抽象出一个标签页控制器，对两者进行统一管理，从而供外部调用。代码如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 处理标签页状态 *\/\nvar TabControler = (function(){\n  var tabs = {}; \/\/ 所有的标签页控制器列表\n  function TabControler(tabId, url){\n    if(tabs[tabId]){ \/* 如有就返回已有的实例 *\/\n      return tabs[tabId];\n    }\n    if(!(this instanceof TabControler)){ \/* 强制以构造器方式调用 *\/\n      return new TabControler(tabId);\n    }\n    \/* 初始化属性 *\/\n    tabs[tabId] = this;\n    this.tabId = tabId;\n    this.url    = url;\n    this.init();\n  }\n  TabControler.get = function(tabId){...} \/\/ 获取指定的标签页控制器\n  TabControler.remove = function(tabId){\n    if(tabs[tabId]){\n      delete tabs[tabId]; \/\/ 移除指定的标签页控制器\n      ListenerControler.remove(tabId); \/\/ 移除指定的监听器控制器\n    }\n  };\n  TabControler.prototype.init = function(){...} \/\/ 初始化标签页控制器\n  TabControler.prototype.switchActive = function(){ \/\/ 当前标签页状态切换\n    var icon = this.icon;\n    if(icon){\n      var status = icon.status;\n      var tabId = this.tabId;\n      switch(status){\n        case ACTIVE: \/\/ 如果是激活状态，则恢复初始状态，移除监听器控制器\n          icon.init(); \n          ListenerControler.remove(tabId);\n          Message.send(tabId, \x27ListeningCancel\x27); \/\/ 通知内容脚本从而在控制台输出取消提示(后续将讲到消息通信)\n          break;\n        default: \/\/ 如果不是激活状态，则激活之，添加监听器控制器\n          icon.active();\n          ListenerControler(tabId);\n          Message.send(tabId, \x27Listening\x27); \/\/ 并通知内容脚本从而在控制台输出监听提示\n      }\n    }\n    return this;\n  };\n  TabControler.prototype.restore = function(){...} \/\/ 恢复标签页控制器的状态(针对页面刷新场景)\n  TabControler.prototype.remove = function(){...} \/\/ 移除标签页控制器\n  return TabControler;\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 处理标签页状态 *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e TabControler = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tabs = {}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所有的标签页控制器列表\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTabControler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId, url\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(tabs[tabId]){ \x3cspan class=\x22hljs-comment\x22\x3e\/* 如有就返回已有的实例 *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e tabs[tabId];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e TabControler)){ \x3cspan class=\x22hljs-comment\x22\x3e\/* 强制以构造器方式调用 *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TabControler(tabId);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 初始化属性 *\/\x3c\/span\x3e\n    tabs[tabId] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId = tabId;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.url    = url;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.init();\n  }\n  TabControler.get = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取指定的标签页控制器\x3c\/span\x3e\n  TabControler.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(tabs[tabId]){\n      \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e tabs[tabId]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除指定的标签页控制器\x3c\/span\x3e\n      ListenerControler.remove(tabId); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除指定的监听器控制器\x3c\/span\x3e\n    }\n  };\n  TabControler.prototype.init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化标签页控制器\x3c\/span\x3e\n  TabControler.prototype.switchActive = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前标签页状态切换\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e icon = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.icon;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(icon){\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e status = icon.status;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tabId = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tabId;\n      \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e(status){\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e ACTIVE: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是激活状态，则恢复初始状态，移除监听器控制器\x3c\/span\x3e\n          icon.init(); \n          ListenerControler.remove(tabId);\n          Message.send(tabId, \x3cspan class=\x22hljs-string\x22\x3e\x27ListeningCancel\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知内容脚本从而在控制台输出取消提示(后续将讲到消息通信)\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不是激活状态，则激活之，添加监听器控制器\x3c\/span\x3e\n          icon.active();\n          ListenerControler(tabId);\n          Message.send(tabId, \x3cspan class=\x22hljs-string\x22\x3e\x27Listening\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并通知内容脚本从而在控制台输出监听提示\x3c\/span\x3e\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n  TabControler.prototype.restore = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复标签页控制器的状态(针对页面刷新场景)\x3c\/span\x3e\n  TabControler.prototype.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{...} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除标签页控制器\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e TabControler;\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e标签页控制器的抽象，有助于封装扩展的内部运行细节，方便了后续各种场景中对扩展的管理 。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e标签页关闭或更新的妥善处理\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e标签页关闭或更新时，为了避免内存泄露和运行稳定，部分数据需要释放或者同步。刚刚封装好的标签页控制器就可以用来做这件事。\x3c\/p\x3e\n\x3cp\x3e首先，Tab关闭时需要释放当前标签页的控制器和监听器对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 监听tab关闭的事件 *\/\nchrome.tabs.onRemoved.addListener(function(tabId, removeInfo){\n  TabControler.remove(tabId); \/\/ 释放内存，移除标签页控制器和监听器\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 监听tab关闭的事件 *\/\x3c\/span\x3e\nchrome.tabs.onRemoved.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId, removeInfo\x3c\/span\x3e)\x3c\/span\x3e{\n  TabControler.remove(tabId); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 释放内存，移除标签页控制器和监听器\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其次，每次Tab在执行跳转或刷新动作时，Page Action的icon都会回到初始状态并且不可点击，此时需要恢复icon之前的状态。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 监听tab更新的事件、包含跳转或刷新的动作 *\/\nchrome.tabs.onUpdated.addListener(function(tabId, changeInfo){\n  if(changeInfo.status === \x27loading\x27){ \/\/ 页面处于loading时触发\n    TabControler(tabId).restore(); \/\/ 恢复icon状态\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 监听tab更新的事件、包含跳转或刷新的动作 *\/\x3c\/span\x3e\nchrome.tabs.onUpdated.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabId, changeInfo\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(changeInfo.status === \x3cspan class=\x22hljs-string\x22\x3e\x27loading\x27\x3c\/span\x3e){ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面处于loading时触发\x3c\/span\x3e\n    TabControler(tabId).restore(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复icon状态\x3c\/span\x3e\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上，页面跳转或刷新时，changeInfo将依次经历两种状态：\x3ccode\x3eloading\x3c\/code\x3e 和\x3ccode\x3ecomplete\x3c\/code\x3e（部分页面会包含\x3ccode\x3efavIconUrl\x3c\/code\x3e或\x3ccode\x3etitle\x3c\/code\x3e信息），如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e504bae3ff?w=800\x26amp;h=142\x26amp;f=png\x26amp;s=48873\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e504bae3ff?w=800\x26amp;h=142\x26amp;f=png\x26amp;s=48873\x22 alt=\x22changeInfo\x22 title=\x22changeInfo\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e随着状态管理的逐渐完善，那么，是时候进行消息通信了（不知道你注意到上述代码中出现的Message对象没有？它就是消息处理的对象）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e\x3cstrong\x3e消息通信\x3c\/strong\x3e\x3c\/h3\x3e\n\x3ch4\x3e\x3cstrong\x3e扩展内部消息通信\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3eChrome扩展内的各页面之间的消息通信，有如下四种方式（以下接口省略chrome前缀）。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e消息发送\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e消息接收\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e支持版本\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e一次性消息\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eextension.sendRequest\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eextension.onRequest\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev33起废弃（早期方案）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e一次性消息\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eextension.sendMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eextension.onMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev20\x2b（不建议使用）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e一次性消息\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eruntime.sendMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eruntime.onMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev26\x2b（现在主流，推荐使用）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e长期连接\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eruntime.connect\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eruntime.onConnect\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev26\x2b\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e目前以上四种方案都可以使用。其中\x3ccode\x3eextension.sendRequest\x3c\/code\x3e发送的消息，只有\x3ccode\x3eextension.onRequest\x3c\/code\x3e才能接收到（已废弃不建议使用，可选读\x3ca href=\x22https:\/\/codereview.chromium.org\/9965005\/#ps3001\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIssue 9965005\x3c\/a\x3e）。\x3ccode\x3eextension.sendMessage\x3c\/code\x3e 或 \x3ccode\x3eruntime.sendMessage\x3c\/code\x3e 发送的消息，虽然\x3ccode\x3eextension.onMessage\x3c\/code\x3e 和 \x3ccode\x3eruntime.onMessage\x3c\/code\x3e都可以接收，但是runtime api的优先触发。若多个监听同时存在，只有第一个响应才能触发消息的sendResponse回调，其他响应将被忽略，如下所述。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eIf multiple pages are listening for onMessage events, only the first to call sendResponse() for a particular event will succeed in sending the response. All other responses to that event will be ignored.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我们先看一次性的消息通信，它的基本规律如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzFh\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzFh\x22 alt=\x22一次性消息通信图示\x22 title=\x22一次性消息通信图示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e图中出现了一种新的消息通信方式，即\x3ccode\x3echrome.extension.getBackgroundPage\x3c\/code\x3e，通过它能够获取background.js（后台脚本）的window对象，从而调用window下的任意全局方法。严格来说它不是消息通信，但是它完全能够胜任消息通信的工作，之所以出现在图示中，是因为它才是消息从popup.html到background.js的主流沟通方式。那么你可能会问了，为什么content.js中不具有同样的API呢？\x3c\/p\x3e\n\x3cp\x3e这是因为它们的使用方式不同，各自的权限也不同。popup.html或background.js中chrome.extension对象打印如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e61e703a0d?w=800\x26amp;h=300\x26amp;f=png\x26amp;s=72312\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e61e703a0d?w=800\x26amp;h=300\x26amp;f=png\x26amp;s=72312\x22 alt=\x22chrome.extension对象\x22 title=\x22chrome.extension对象\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3econtent.js中chrome.extension对象打印如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e5cb33e1ba?w=757\x26amp;h=179\x26amp;f=png\x26amp;s=32837\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e5cb33e1ba?w=757\x26amp;h=179\x26amp;f=png\x26amp;s=32837\x22 alt=\x22content.js下的chrome.extension对象\x22 title=\x22content.js下的chrome.extension对象\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看出，前者包含了全量的属性，后者只保留少量的属性。content.js中并没有\x3ccode\x3echrome.extension.getBackgroundPage\x3c\/code\x3e方法，因此content.js不能直接调用background.js中的全局方法。\x3c\/p\x3e\n\x3cp\x3e回到消息通信的话题，请看消息发送和监听的简单示例，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 消息流：弹窗页面、选项页面 或 background.js --\x3e content.js\n\/\/ 由于每个tab都可能加载内容脚本，因此需要指定tab\nchrome.tabs.query( \/\/ 查询tab\n  { active: true, currentWindow: true }, \/\/ 获取当前窗口激活的标签页，即当前tab\n  function(tabs) { \/\/ 获取的列表是包含一个tab对象的数组\n    chrome.tabs.sendMessage( \/\/ 向tab发送消息\n      tabs[0].id, \/\/ 指定tab的id\n      { message: \x27Hello content.js\x27 }, \/\/ 消息内容可以为任意对象\n      function(response) { \/\/ 收到响应后的回调\n        console.log(response);\n      }\n    );\n  }\n);\n\n\/* 消息流：\n * 1. 弹窗页面或选项页面 --\x3e background.js\n * 2. background.js --\x3e 弹窗页面或选项页面\n * 3. content.js --\x3e 弹窗页面、选项页面 或 background.js\n *\/\nchrome.runtime.sendMessage({ message: \x27runtime-message\x27 }, function(response) {\n  console.log(response);\n});\n\n\/\/ 可任意选用runtime或extension的onMessage方法监听消息\nchrome.runtime.onMessage.addListener( \/\/ 添加消息监听\n  function(request, sender, sendResponse) { \/\/ 三个参数分别为①消息内容，②消息发送者，③发送响应的方法\n    console.log(sender.tab ?\n                \x26quot;from a content script:\x26quot; \x2b sender.tab.url :\n                \x26quot;from the extension\x26quot;);\n    if (request.message === \x27Hello content.js\x27){\n      sendResponse({ answer: \x27goodbye\x27 }); \/\/ 发送响应内容\n    }\n    \/\/ return true; \/\/ 如需异步调用sendResponse方法，需要显式返回true\n  }\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 消息流：弹窗页面、选项页面 或 background.js --\x26gt; content.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于每个tab都可能加载内容脚本，因此需要指定tab\x3c\/span\x3e\nchrome.tabs.query( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 查询tab\x3c\/span\x3e\n  { \x3cspan class=\x22hljs-attr\x22\x3eactive\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecurrentWindow\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取当前窗口激活的标签页，即当前tab\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabs\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取的列表是包含一个tab对象的数组\x3c\/span\x3e\n    chrome.tabs.sendMessage( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 向tab发送消息\x3c\/span\x3e\n      tabs[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].id, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定tab的id\x3c\/span\x3e\n      { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello content.js\x27\x3c\/span\x3e }, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 消息内容可以为任意对象\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 收到响应后的回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(response);\n      }\n    );\n  }\n);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 消息流：\n * 1. 弹窗页面或选项页面 --\x26gt; background.js\n * 2. background.js --\x26gt; 弹窗页面或选项页面\n * 3. content.js --\x26gt; 弹窗页面、选项页面 或 background.js\n *\/\x3c\/span\x3e\nchrome.runtime.sendMessage({ \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27runtime-message\x27\x3c\/span\x3e }, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(response);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可任意选用runtime或extension的onMessage方法监听消息\x3c\/span\x3e\nchrome.runtime.onMessage.addListener( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加消息监听\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequest, sender, sendResponse\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 三个参数分别为①消息内容，②消息发送者，③发送响应的方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sender.tab ?\n                \x3cspan class=\x22hljs-string\x22\x3e\x22from a content script:\x22\x3c\/span\x3e \x2b sender.tab.url :\n                \x3cspan class=\x22hljs-string\x22\x3e\x22from the extension\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (request.message === \x3cspan class=\x22hljs-string\x22\x3e\x27Hello content.js\x27\x3c\/span\x3e){\n      sendResponse({ \x3cspan class=\x22hljs-attr\x22\x3eanswer\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27goodbye\x27\x3c\/span\x3e }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发送响应内容\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return true; \/\/ 如需异步调用sendResponse方法，需要显式返回true\x3c\/span\x3e\n  }\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e\x3cstrong\x3e一次性消息通信API\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e上述涉及到的API语法如下：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cem\x3echrome.tabs.query(object queryInfo, function callback)\x3c\/em\x3e，查询符合条件的tab。其中，callback为查询结果的回调，默认传入tabs列表作为参数；queryInfo为标签页的描述信息，包含如下属性。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e属性\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e支持性\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eactive\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否激活\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eaudible\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev45\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否允许声音播放\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eautoDiscardable\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev54\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否允许被丢弃\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ecurrentWindow\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev19\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否在当前窗口中\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ediscarded\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev54\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否处于被丢弃状态\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ehighlighted\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否高亮\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eindex\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eNumber\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev18\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab在窗口中的序号\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3emuted\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev45\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否静音\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3elastFocusedWindow\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ev19\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否位于最后选中的窗口中\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3epinned\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eboolean\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab是否固定\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3estatus\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab的状态，可选值为\x3ccode\x3eloading\x3c\/code\x3e或\x3ccode\x3ecomplete\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3etitle\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab中页面的标题（需要申请tabs权限）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eurl\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString or Array\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab中页面的链接\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ewindowId\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eNumber\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab所处窗口的id\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ewindowType\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3etab所处窗口的类型，值包含\x3ccode\x3enormal\x3c\/code\x3e、\x3ccode\x3epopup\x3c\/code\x3e、\x3ccode\x3epanel\x3c\/code\x3e、\x3ccode\x3eapp\x3c\/code\x3eor\x3ccode\x3edevtools\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e注：丢弃的tab指的是tab内容已经从内存中卸载，但是tab未关闭。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e\x3cem\x3echrome.tabs.sendMessage(integer tabId, any request, object options, function responseCallback)\x3c\/em\x3e\x3c\/strong\x3e，向指定tab下的content.js发送单次消息。其中tabId为标签页的id，request为消息内容，options参数从v41版开始支持，通过它可以指定frameId的值，以便向指定的frame发送消息，responseCallback即收到响应后的回调。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e\x3cem\x3echrome.runtime.sendMessage(string extensionId, any message, object options, function responseCallback)\x3c\/em\x3e\x3c\/strong\x3e，向扩展内或指定的其他扩展发送消息。其中extensionId为其他指定扩展的id，扩展内通信可以忽略该参数，message为消息内容，options参数从v32版开始支持，通过它可以指定includeTlsChannelId（boolean）的值，以便决定TLS通道ID是否会传递到onMessageExternal事件监听回调中，responseCallback即收到响应后的回调。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e\x3cem\x3echrome.runtime.onMessage.addListener(function callback)\x3c\/em\x3e\x3c\/strong\x3e，添加单次消息通信的监听。其中callback类似function(any message, MessageSender sender, function sendResponse) {...}这种函数，message为消息内容，sender即消息发送者，sendResponse用于向消息发送者回复响应，如果需要异步发送响应，请在callback回调中return true（此时将保持消息通道不关闭直到sendResponse方法被调用）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e综上，我们选用chrome.runtime api即可完美的进行消息通信，对于v25，甚至v20以下的版本，请参考以下兼容代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var callback = function(message, sender, sendResponse) {\n  \/\/ Do something\n});\nvar message = { message: \x27hello\x27 }; \/\/ message\nif (chrome.extension.sendMessage) { \/\/ chrome20\x2b\n  var runtimeOrExtension = chrome.runtime \x26amp;\x26amp; chrome.runtime.sendMessage ? \x27runtime\x27 : \x27extension\x27;\n  chrome[runtimeOrExtension].onMessage.addListener(callback); \/\/ bind event\n  chrome[runtimeOrExtension].sendMessage(message); \/\/ send message\n} else { \/\/ chrome19-\n  chrome.extension.onRequest.addListener(callback); \/\/ bind event\n  chrome.extension.sendRequest(message); \/\/ send message\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessage, sender, sendResponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do something\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e message = { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e }; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ message\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (chrome.extension.sendMessage) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ chrome20\x2b\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e runtimeOrExtension = chrome.runtime \x26amp;\x26amp; chrome.runtime.sendMessage ? \x3cspan class=\x22hljs-string\x22\x3e\x27runtime\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27extension\x27\x3c\/span\x3e;\n  chrome[runtimeOrExtension].onMessage.addListener(callback); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind event\x3c\/span\x3e\n  chrome[runtimeOrExtension].sendMessage(message); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ send message\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ chrome19-\x3c\/span\x3e\n  chrome.extension.onRequest.addListener(callback); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind event\x3c\/span\x3e\n  chrome.extension.sendRequest(message); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ send message\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e\x3cstrong\x3e长期连接消息通信\x3c\/strong\x3e\x3c\/h5\x3e\n\x3cp\x3e想必，一次性的消息通信你已经驾轻就熟了。如果是频繁的通信呢？此时，一次性的消息通信就显得有些复杂。为了满足这种频繁通信的需要，Chrome浏览器专门提供了\x3ccode\x3eChrome.runtime.connect\x3c\/code\x3e API。基于它，通信的双方就可以建立长期的连接。\x3c\/p\x3e\n\x3cp\x3e长期连接基本规律如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e6eaab094f?w=1414\x26amp;h=548\x26amp;f=png\x26amp;s=95420\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e6eaab094f?w=1414\x26amp;h=548\x26amp;f=png\x26amp;s=95420\x22 alt=\x22一次性消息通信图示\x22 title=\x22一次性消息通信图示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e以上，与上述一次性消息通信一样，长期连接也可以在popup.html、background.js 和 content.js三者中两两之间建立（注意：无论何时主动与content.js建立连接，都需要指定tabId）。如下是popup.html与content.js之间建立长期连接的举例?。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ popup.html 发起长期连接\nchrome.tabs.query(\n  {active: true, currentWindow: true}, \/\/ 获取当前窗口的激活tab\n  function(tabs) {\n    \/\/ 建立连接，如果是与background.js建立连接，应该使用chrome.runtime.connect api\n    var port = chrome.tabs.connect( \/\/ 返回Port对象\n      tabs[0].id, \/\/ 指定tabId\n      {name: \x27call2content.js\x27} \/\/ 连接名称\n    );\n    port.postMessage({ greeting: \x27Hello\x27 }); \/\/ 发送消息\n    port.onMessage.addListener(function(msg) { \/\/ 监听消息\n      if (msg.say == \x27Hello, who\\\x27s there?\x27) {\n        port.postMessage({ say: \x27Louis\x27 });\n      } else if (msg.say == \x26quot;Oh, Louis, how\\\x27s it going?\x26quot;) {\n        port.postMessage({ say: \x27It\\\x27s going well, thanks. How about you?\x27 });\n      } else if (msg.say == \x26quot;Not good, can you lend me five bucks?\x26quot;) {\n        port.postMessage({ say: \x27What did you say? Inaudible? The signal was terrible\x27 });\n        port.disconnect(); \/\/ 断开长期连接\n      }\n    });\n  }\n);\n\n\/\/ content.js 监听并响应长期连接\nchrome.runtime.onConnect.addListener(function(port) { \/\/ 监听长期连接，默认传入Port对象\n  console.assert(port.name == \x26quot;call2content.js\x26quot;); \/\/ 筛选连接名称\n  console.group(\x27Long-lived connection is established, sender:\x27 \x2b JSON.stringify(port.sender));\n  port.onMessage.addListener(function(msg) {\n    var word;\n    if (msg.greeting == \x27Hello\x27) {\n      word = \x27Hello, who\\\x27s there?\x27;\n      port.postMessage({ say: word });\n    } else if (msg.say == \x27Louis\x27) {\n      word = \x27Oh, Louis, how\\\x27s it going?\x27;\n      port.postMessage({ say: word });\n    } else if (msg.say == \x27It\\\x27s going well, thanks. How about you?\x27) {\n      word = \x27Not good, can you lend me five bucks?\x27;\n      port.postMessage({ say: word });\n    } else if (msg.say == \x27What did you say? Inaudible? The signal was terrible\x27) {\n      word = \x27Don\\\x27t hang up!\x27;\n      port.postMessage({ say: word });\n    }\n    console.log(msg);\n    console.log(word);\n  });\n  port.onDisconnect.addListener(function(port) { \/\/ 监听长期连接的断开事件\n    console.groupEnd();\n    console.warn(port.name \x2b \x27: The phone went dead\x27);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ popup.html 发起长期连接\x3c\/span\x3e\nchrome.tabs.query(\n  {\x3cspan class=\x22hljs-attr\x22\x3eactive\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecurrentWindow\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取当前窗口的激活tab\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabs\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 建立连接，如果是与background.js建立连接，应该使用chrome.runtime.connect api\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e port = chrome.tabs.connect( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回Port对象\x3c\/span\x3e\n      tabs[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].id, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定tabId\x3c\/span\x3e\n      {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27call2content.js\x27\x3c\/span\x3e} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 连接名称\x3c\/span\x3e\n    );\n    port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3egreeting\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello\x27\x3c\/span\x3e }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发送消息\x3c\/span\x3e\n    port.onMessage.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听消息\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x27Hello, who\\\x27s there?\x27\x3c\/span\x3e) {\n        port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Louis\x27\x3c\/span\x3e });\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x22Oh, Louis, how\\\x27s it going?\x22\x3c\/span\x3e) {\n        port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27It\\\x27s going well, thanks. How about you?\x27\x3c\/span\x3e });\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x22Not good, can you lend me five bucks?\x22\x3c\/span\x3e) {\n        port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27What did you say? Inaudible? The signal was terrible\x27\x3c\/span\x3e });\n        port.disconnect(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 断开长期连接\x3c\/span\x3e\n      }\n    });\n  }\n);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ content.js 监听并响应长期连接\x3c\/span\x3e\nchrome.runtime.onConnect.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eport\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听长期连接，默认传入Port对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.assert(port.name == \x3cspan class=\x22hljs-string\x22\x3e\x22call2content.js\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 筛选连接名称\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.group(\x3cspan class=\x22hljs-string\x22\x3e\x27Long-lived connection is established, sender:\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(port.sender));\n  port.onMessage.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e word;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.greeting == \x3cspan class=\x22hljs-string\x22\x3e\x27Hello\x27\x3c\/span\x3e) {\n      word = \x3cspan class=\x22hljs-string\x22\x3e\x27Hello, who\\\x27s there?\x27\x3c\/span\x3e;\n      port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: word });\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x27Louis\x27\x3c\/span\x3e) {\n      word = \x3cspan class=\x22hljs-string\x22\x3e\x27Oh, Louis, how\\\x27s it going?\x27\x3c\/span\x3e;\n      port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: word });\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x27It\\\x27s going well, thanks. How about you?\x27\x3c\/span\x3e) {\n      word = \x3cspan class=\x22hljs-string\x22\x3e\x27Not good, can you lend me five bucks?\x27\x3c\/span\x3e;\n      port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: word });\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (msg.say == \x3cspan class=\x22hljs-string\x22\x3e\x27What did you say? Inaudible? The signal was terrible\x27\x3c\/span\x3e) {\n      word = \x3cspan class=\x22hljs-string\x22\x3e\x27Don\\\x27t hang up!\x27\x3c\/span\x3e;\n      port.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: word });\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(msg);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(word);\n  });\n  port.onDisconnect.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eport\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听长期连接的断开事件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.groupEnd();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.warn(port.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: The phone went dead\x27\x3c\/span\x3e);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台输出如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e7bbd4c1fe?w=1000\x26amp;h=291\x26amp;f=png\x26amp;s=95832\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e7bbd4c1fe?w=1000\x26amp;h=291\x26amp;f=png\x26amp;s=95832\x22 alt=\x22扩展内长期连接消息通信输出\x22 title=\x22扩展内长期连接消息通信输出\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e建立长期连接涉及到的API语法如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3echrome.tabs.connect(integer tabId, object connectInfo)\x3c\/em\x3e，与content.js建立长期连接。tabId为标签页的id，connectInfo为连接的配置信息，可以指定两个属性，分别为name和frameId。name属性指定连接的名称，frameId属性指定tab中唯一的frame去建立连接。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3echrome.runtime.connect(string extensionId, object connectInfo)\x3c\/em\x3e，发起长期的连接。其中extensionId为扩展的id，connectInfo为连接的配置信息，目前可以指定两个属性，分别是name和includeTlsChannelId。name属性指定连接的名称，includeTlsChannelId属性从v32版本开始支持，表示TLS通道ID是否会传递到onConnectExternal的监听器中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3echrome.runtime.onConnect.addListener(function callback)\x3c\/em\x3e，监听长期连接的建立。callback为连接建立后的事件回调，该回调默认传入Port对象，通过Port对象可进行页面间的双向通信。Port对象结构如下：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e属性\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ename\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e连接的名称\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3edisconnect\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eFunction\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e立即断开连接（已经断开的连接再次调用没有效果，连接断开后将不会收到新的消息）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eonDisconnect\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eObject\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e断开连接时触发（可添加监听器）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eonMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eObject\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e收到消息时触发（可添加监听器）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3epostMessage\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eFunction\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e发送消息\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3esender\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/runtime#type-MessageSender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMessageSender\x3c\/a\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e连接的发起者（该属性只会出现在连接监听器中，即onConnect 或onConnectExternal中）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch4\x3e\x3cstrong\x3e扩展程序间消息通信\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e相对于扩展内部的消息通信而言，扩展间的消息通信更加简单。对于一次性消息通信，共涉及到如下两个API：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echrome.runtime.sendMessage\x3c\/strong\x3e，之前讲过，需要特别指定第一个参数extensionId，其它不变。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echrome.runtime.onMessageExternal\x3c\/strong\x3e，监听其它扩展的消息，用法与chrome.runtime.onMessage一致。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于长期连接消息通信，共涉及到如下两个API：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echrome.runtime.connect\x3c\/strong\x3e，之前讲过，需要特别指定第一个参数extensionId，其它不变。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echrome.runtime.onConnectExternal\x3c\/strong\x3e，监听其它扩展的消息，用法与chrome.runtime.onConnect一致。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e发送消息可参考如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var extensionId = \x26quot;oknhphbdjjokdjbgnlaikjmfpnhnoend\x26quot;; \/\/ 目标扩展id\n\/\/ 发起一次性消息通信\nchrome.runtime.sendMessage(extensionId, { message: \x27hello\x27 }, function(response) {\n  console.log(response);\n});\n\/\/ 发起长期连接消息通信\nvar port = chrome.runtime.connect(extensionId, {name: \x27web-page-messages\x27});\nport.postMessage({ greeting: \x27Hello\x27 });\nport.onMessage.addListener(function(msg) {\n  \/\/ 通信逻辑见『长期连接消息通信』popup.html示例代码\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extensionId = \x3cspan class=\x22hljs-string\x22\x3e\x22oknhphbdjjokdjbgnlaikjmfpnhnoend\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 目标扩展id\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发起一次性消息通信\x3c\/span\x3e\nchrome.runtime.sendMessage(extensionId, { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e }, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(response);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发起长期连接消息通信\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e port = chrome.runtime.connect(extensionId, {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27web-page-messages\x27\x3c\/span\x3e});\nport.postMessage({ \x3cspan class=\x22hljs-attr\x22\x3egreeting\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello\x27\x3c\/span\x3e });\nport.onMessage.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通信逻辑见『长期连接消息通信』popup.html示例代码\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e监听消息可参考如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 监听一次性消息\nchrome.runtime.onMessageExternal.addListener( function(request, sender, sendResponse) {\n  console.group(\x27simple request arrived\x27);\n  console.log(JSON.stringify(request));\n  console.log(JSON.stringify(sender));\n  sendResponse(\x27bye\x27);\n});\n\/\/ 监听长期连接\nchrome.runtime.onConnect.addListener(function(port) {\n  console.assert(port.name == \x26quot;web-page-messages\x26quot;);\n  console.group(\x27Long-lived connection is established, sender:\x27 \x2b JSON.stringify(port.sender));\n  port.onMessage.addListener(function(msg) {\n    \/\/ 通信逻辑见『长期连接消息通信』content.js示例代码\n  });\n  port.onDisconnect.addListener(function(port) {\n    console.groupEnd();\n    console.warn(port.name \x2b \x27: The phone went dead\x27);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听一次性消息\x3c\/span\x3e\nchrome.runtime.onMessageExternal.addListener( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequest, sender, sendResponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.group(\x3cspan class=\x22hljs-string\x22\x3e\x27simple request arrived\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(request));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(sender));\n  sendResponse(\x3cspan class=\x22hljs-string\x22\x3e\x27bye\x27\x3c\/span\x3e);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听长期连接\x3c\/span\x3e\nchrome.runtime.onConnect.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eport\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.assert(port.name == \x3cspan class=\x22hljs-string\x22\x3e\x22web-page-messages\x22\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.group(\x3cspan class=\x22hljs-string\x22\x3e\x27Long-lived connection is established, sender:\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(port.sender));\n  port.onMessage.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通信逻辑见『长期连接消息通信』content.js示例代码\x3c\/span\x3e\n  });\n  port.onDisconnect.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eport\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.groupEnd();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.warn(port.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: The phone went dead\x27\x3c\/span\x3e);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台输出如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e87ec344fb?w=1200\x26amp;h=328\x26amp;f=png\x26amp;s=199979\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86e87ec344fb?w=1200\x26amp;h=328\x26amp;f=png\x26amp;s=199979\x22 alt=\x22扩展间消息通信输出\x22 title=\x22扩展间消息通信输出\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3eWeb页面与扩展间消息通信\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e除了扩展内部和扩展之间的通信，Web pages 也可以与扩展进行消息通信（单向）。这种通信方式与扩展间的通信非常相似，共需要如下三步便可以通信。\x3c\/p\x3e\n\x3cp\x3e首先，manifest.json指定可接收页面的url规则。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;externally_connectable\x26quot;: {\n  \x26quot;matches\x26quot;: [\x26quot;https:\/\/developer.chrome.com\/*\x26quot;]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22externally_connectable\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22matches\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/developer.chrome.com\/*\x22\x3c\/span\x3e]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其次，Web pages 发送信息，比如说在 \x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/messaging\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.chrome.com\/...\x3c\/a\x3e 页面控制台执行以上『扩展程序间消息通信』小节——消息发送的语句。\x3c\/p\x3e\n\x3cp\x3e最后，扩展监听消息，代码同以上『扩展程序间消息通信』小节——消息监听部分。\x3c\/p\x3e\n\x3cp\x3e至此，扩展程序的消息通信聊得差不多了。基于以上内容，你完全可以自行封装一个message.js，用于简化消息通信。实际上，\x3ca href=\x22https:\/\/chrome.google.com\/webstore\/detail\/iibolhpkjjmoepndefdmdlmbpfhlgjpl\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阅读模式\x3c\/a\x3e扩展程序就封装了一个\x3ca href=\x22https:\/\/github.com\/Louiszhai\/IHeader\/blob\/master\/res\/js\/message.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emessage.js\x3c\/a\x3e，IHeader扩展中的消息通信便基于它。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e\x3cstrong\x3e设置快捷键\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e一般涉及到状态切换的，快捷键能有效提升使用体验。为此我也为IHeader添加了快捷键功能。\x3c\/p\x3e\n\x3cp\x3e为扩展程序设置快捷键，共需要两步。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3emanifest.json中添加commands声明（可以指定多个命令）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;commands\x26quot;: { \/\/ 命令\n  \x26quot;toggle_status\x26quot;: { \/\/ 命令名称\n    \x26quot;suggested_key\x26quot;: { \/\/ 指定默认的和各个平台上绑定的快捷键\n      \x26quot;default\x26quot;: \x26quot;Alt\x2bH\x26quot;, \n      \x26quot;windows\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n      \x26quot;mac\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n      \x26quot;chromeos\x26quot;: \x26quot;Alt\x2bH\x26quot;,\n      \x26quot;linux\x26quot;: \x26quot;Alt\x2bH\x26quot;\n    }, \n    \x26quot;description\x26quot;: \x26quot;Toggle IHeader\x26quot; \/\/ 命令的描述\n  }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22commands\x22\x3c\/span\x3e: { \/\/ 命令\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22toggle_status\x22\x3c\/span\x3e: { \/\/ 命令名称\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22suggested_key\x22\x3c\/span\x3e: { \/\/ 指定默认的和各个平台上绑定的快捷键\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22default\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e, \n      \x3cspan class=\x22hljs-attr\x22\x3e\x22windows\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22mac\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22chromeos\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22linux\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Alt\x2bH\x22\x3c\/span\x3e\n    }, \n    \x3cspan class=\x22hljs-attr\x22\x3e\x22description\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Toggle IHeader\x22\x3c\/span\x3e \/\/ 命令的描述\n  }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ebackground.js中添加命令的监听。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 监听快捷键 *\/\nchrome.commands.onCommand.addListener(function(command) {\n  if (command == \x26quot;toggle_status\x26quot;) { \/\/ 匹配命令名称\n    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { \/\/ 查询当前激活tab\n      var tab = tabs[0];\n      tab \x26amp;\x26amp; TabControler(tab.id, tab.url).switchActive(); \/\/ 切换tab控制器的状态\n    });\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 监听快捷键 *\/\x3c\/span\x3e\nchrome.commands.onCommand.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecommand\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (command == \x3cspan class=\x22hljs-string\x22\x3e\x22toggle_status\x22\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配命令名称\x3c\/span\x3e\n    chrome.tabs.query({\x3cspan class=\x22hljs-attr\x22\x3eactive\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecurrentWindow\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabs\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 查询当前激活tab\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tab = tabs[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n      tab \x26amp;\x26amp; TabControler(tab.id, tab.url).switchActive(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 切换tab控制器的状态\x3c\/span\x3e\n    });\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e以上，按下\x3ccode\x3eAlt\x2bH\x3c\/code\x3e键，便可以切换IHeader扩展程序的监听状态了。\x3c\/p\x3e\n\x3cp\x3e设置快捷键时，请注意Mac与Windows、linux等系统的差别，Mac既有\x3ccode\x3eCtrl\x3c\/code\x3e键又有\x3ccode\x3eCommand\x3c\/code\x3e键。另外，若设置的快捷键与Chrome的默认快捷键冲突，那么设置将静默失败，因此请记得绕过以下Chrome快捷键（KeyCue是查看快捷键的应用，请忽略之）。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86eb5d677c17?w=912\x26amp;h=461\x26amp;f=png\x26amp;s=199419\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86eb5d677c17?w=912\x26amp;h=461\x26amp;f=png\x26amp;s=199419\x22 alt=\x22Chrome快捷键\x22 title=\x22Chrome快捷键\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e\x3cstrong\x3e添加右键菜单\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e除了快捷键外，还可以为扩展程序添加右键菜单，如IHeader的右键菜单。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ecfc4130f1?w=250\x26amp;h=367\x26amp;f=gif\x26amp;s=146873\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ecfc4130f1?w=250\x26amp;h=367\x26amp;f=gif\x26amp;s=146873\x22 alt=\x22IHeader右键菜单演示\x22 title=\x22IHeader右键菜单演示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为扩展程序添加右键菜单，共需要三步。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e申请菜单权限，需在manifest.json的permissions属性中添加\x22contextMenus\x22权限。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;permissions\x26quot;: [\x26quot;contextMenus\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22permissions\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22contextMenus\x22\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e菜单需在background.js中手动创建。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.contextMenus.removeAll(); \/\/ 创建之前建议清空菜单\nchrome.contextMenus.create({ \/\/ 创建右键菜单\n  title: \x27切换Header监听模式\x27, \/\/ 指定菜单名称\n  id: \x27contextMenu-0\x27, \/\/ 指定菜单id\n  contexts: [\x27all\x27] \/\/ 所有地方可见\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3echrome.contextMenus.removeAll(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建之前建议清空菜单\x3c\/span\x3e\nchrome.contextMenus.create({ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建右键菜单\x3c\/span\x3e\n  title: \x3cspan class=\x22hljs-string\x22\x3e\x27切换Header监听模式\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定菜单名称\x3c\/span\x3e\n  id: \x3cspan class=\x22hljs-string\x22\x3e\x27contextMenu-0\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定菜单id\x3c\/span\x3e\n  contexts: [\x3cspan class=\x22hljs-string\x22\x3e\x27all\x27\x3c\/span\x3e] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所有地方可见\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于\x3cem\x3echrome.contextMenus.create(object createProperties, function callback)\x3c\/em\x3e方法默认返回新菜单的id，因此它通过回调（第二个参数callback）来告知是否创建成功，而第一个参数createProperties则为菜单项指定配置信息。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e绑定右键菜单的功能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.contextMenus.onClicked.addListener(function (menu, tab){ \/\/ 绑定点击事件\n  TabControler(tab.id, tab.url).switchActive(); \/\/ 切换扩展状态\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3echrome.contextMenus.onClicked.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emenu, tab\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定点击事件\x3c\/span\x3e\n  TabControler(tab.id, tab.url).switchActive(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 切换扩展状态\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e\x3cstrong\x3e安装或更新\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3eChrome为扩展程序提供了丰富的API，比如说，你可以监听扩展安装或更新事件，进行一些初始化处理或给予友好的提示，如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* 安装提示 *\/\nchrome.runtime.onInstalled.addListener(function(data){\n  if(data.reason == \x27install\x27 || data.reason == \x27update\x27){\n    chrome.tabs.query({}, function(tabs){\n      tabs.forEach(function(tab){\n        TabControler(tab.id).restore(); \/\/ 恢复所有tab的状态\n      });\n    });\n    \/\/ 初始化时重启全局监听器 ...\n    \/\/ 动态载入Notification js文件\n    setTimeout(function(){\n      var partMessage = data.reason == \x27install\x27 ? \x27安装成功\x27 : \x27更新成功\x27;\n      chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {\n        var tab = tabs[0];\n        if (!\/chrome:\\\/\\\/\/.test(tab.url)){ \/\/ 只能在url不是\x26quot;Chrome:\/\/ URL\x26quot;开头的页面注入内容脚本\n          chrome.tabs.executeScript(tab.id, {file: \x27res\/js\/notification.js\x27}, function(){\n            chrome.tabs.executeScript(tab.id, {code: \x27notification(\x26quot;IHeader\x27\x2b partMessage \x2b\x27\x26quot;)\x27}, function(log){\n              log[0] \x26amp;\x26amp; console.log(\x27[Notification]: 成功弹出通知\x27);\n            });\n          });\n        } else {\n          console.log(\x27[Notification]: Cannot access a chrome:\/\/ URL\x27);\n        }\n      });\n    },1000); \/\/ 延迟1s的目的是为了调试时能够及时切换到其他的tab下，从而弹出Notification。\n    console.log(\x27[扩展]:\x27, data.reason);\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 安装提示 *\/\x3c\/span\x3e\nchrome.runtime.onInstalled.addListener(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data.reason == \x3cspan class=\x22hljs-string\x22\x3e\x27install\x27\x3c\/span\x3e || data.reason == \x3cspan class=\x22hljs-string\x22\x3e\x27update\x27\x3c\/span\x3e){\n    chrome.tabs.query({}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabs\x3c\/span\x3e)\x3c\/span\x3e{\n      tabs.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etab\x3c\/span\x3e)\x3c\/span\x3e{\n        TabControler(tab.id).restore(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 恢复所有tab的状态\x3c\/span\x3e\n      });\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化时重启全局监听器 ...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 动态载入Notification js文件\x3c\/span\x3e\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e partMessage = data.reason == \x3cspan class=\x22hljs-string\x22\x3e\x27install\x27\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27安装成功\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27更新成功\x27\x3c\/span\x3e;\n      chrome.tabs.query({\x3cspan class=\x22hljs-attr\x22\x3eactive\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecurrentWindow\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etabs\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tab = tabs[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-regexp\x22\x3e\/chrome:\\\/\\\/\/\x3c\/span\x3e.test(tab.url)){ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只能在url不是\x22Chrome:\/\/ URL\x22开头的页面注入内容脚本\x3c\/span\x3e\n          chrome.tabs.executeScript(tab.id, {\x3cspan class=\x22hljs-attr\x22\x3efile\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27res\/js\/notification.js\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            chrome.tabs.executeScript(tab.id, {\x3cspan class=\x22hljs-attr\x22\x3ecode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27notification(\x22IHeader\x27\x3c\/span\x3e\x2b partMessage \x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\x22)\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elog\x3c\/span\x3e)\x3c\/span\x3e{\n              log[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[Notification]: 成功弹出通知\x27\x3c\/span\x3e);\n            });\n          });\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[Notification]: Cannot access a chrome:\/\/ URL\x27\x3c\/span\x3e);\n        }\n      });\n    },\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 延迟1s的目的是为了调试时能够及时切换到其他的tab下，从而弹出Notification。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[扩展]:\x27\x3c\/span\x3e, data.reason);\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上，\x3cem\x3echrome.tabs.executeScript(integer tabId, object details)\x3c\/em\x3e接口，用于动态注入内容脚本，且只能在url不是\x22Chrome:\/\/ URL\x22开头的页面注入。其中tabId参数用于指定目标标签页的id，details参数用于指定内容脚本的路径或语句，它的file属性指定脚本路径，code属性指定动态语句。若分别往同一个标签页注入多个脚本或语句，这些注入的脚本或语句处于同一个沙盒，即全局变量可以共享。\x3c\/p\x3e\n\x3cp\x3enotification.js如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function notification(message) {\n  if (!(\x27Notification\x27 in window)) { \/\/ 判断浏览器是否支持Notification功能\n    console.log(\x27This browser does not support desktop notification\x27);\n  } else if (Notification.permission === \x26quot;granted\x26quot;) { \/\/ 判断是否授予通知的权限\n    new Notification(message); \/\/ 创建通知\n    return true;\n  } else if (Notification.permission !== \x27denied\x27) { \/\/ 首次向用户申请权限\n    Notification.requestPermission(function (permission) { \/\/ 申请权限\n      if (permission === \x26quot;granted\x26quot;) { \/\/ 用户授予权限后, 弹出通知\n        new Notification(message); \/\/ 创建通知\n        return true;\n      }\n    });\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enotification\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessage\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-string\x22\x3e\x27Notification\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断浏览器是否支持Notification功能\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27This browser does not support desktop notification\x27\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Notification.permission === \x3cspan class=\x22hljs-string\x22\x3e\x22granted\x22\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断是否授予通知的权限\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Notification(message); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建通知\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Notification.permission !== \x3cspan class=\x22hljs-string\x22\x3e\x27denied\x27\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首次向用户申请权限\x3c\/span\x3e\n    Notification.requestPermission(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epermission\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 申请权限\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (permission === \x3cspan class=\x22hljs-string\x22\x3e\x22granted\x22\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用户授予权限后, 弹出通知\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Notification(message); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建通知\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      }\n    });\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终弹出通知如下。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ed5f203654?w=646\x26amp;h=126\x26amp;f=png\x26amp;s=37805\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ed5f203654?w=646\x26amp;h=126\x26amp;f=png\x26amp;s=37805\x22 alt=\x22Notification\x22 title=\x22Notification\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e\x3cstrong\x3e国际化\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e为了让全球都能使用你开发的扩展，国际化是必须的。从软件工程的角度讲，国际化就是将产品用户界面中可见的字符串全部存放在资源文件中，然后根据用户所处不同的语言环境，展示相应语言的视觉信息。Chrome从v17版本开始就提供了国际化标准API——chrome.i18n。i18n即internationalization（国际化），由于i和n中间共计18个字母，故简称为i18n。\x3c\/p\x3e\n\x3cp\x3eChrome扩展预留了_locales目录，用于存放多种语言版本的资源文件——message.json。目录结构为 \x22_locales\/locales_code\/message.json\x22，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_locales\n|-- en\n    |-- message.json\n|-- zh_CN\n    |-- message.json\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e_locales\n\x3cspan class=\x22hljs-string\x22\x3e|-- en\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e|-- message.json\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e|-- zh_CN\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e|-- message.json\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3elocales_code不仅包含以上举例的en（英文）、zh_CN（简体中文）等，还包含全球多种其它语言，具体请参考\x3ca href=\x22https:\/\/developer.chrome.com\/webstore\/i18n?csw=1#localeTable\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChoosing locales to support\x3c\/a\x3e，对于不支持的locale，Chrome会自动忽略。\x3c\/p\x3e\n\x3cp\x3emessage.json资源文件如下所示，其中key为关键字，其message属性指定了它对应的值，description属性用于描述该key。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;key\x26quot;: {\n    \x26quot;message\x26quot;: \x26quot;the value for the key\x26quot;,\n    \x26quot;description\x26quot;: \x26quot;the description for the key\x26quot;\n  },\n  ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22key\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22message\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22the value for the key\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22description\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22the description for the key\x22\x3c\/span\x3e\n  },\n  ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据i18n的官网文档\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3eImportant:\x3c\/strong\x3e If an extension has a \x3ccode\x3e_locales\x3c\/code\x3e directory, the manifest \x3cstrong\x3emust\x3c\/strong\x3e define \x22default_locale\x22.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e一旦扩展中有了_locales目录，那么就必须要在manifest.json中指定\x22default_locale\x22，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;default_locale\x26quot;: \x26quot;en\x26quot;,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22default_locale\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22en\x22\x3c\/span\x3e,\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e如何引用国际化字符串\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e如需在manifest.json或CSS文件中引用一个名称为\x22key\x22的字符串，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22__MSG_key__\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-strong\x22\x3e__MSG_key__\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如需在扩展程序的JS中引用key对应的字符串，则需要借助\x3cem\x3echrome.i18n.getMessage(string messageName, any substitutions)\x3c\/em\x3e这个API。其中messageName指的是信息的关键字（key），substitutions数组用于存放字符串待替换字符对应的值（该参数可选，且最多不超过9个替换值）。使用如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.i18n.getMessage(\x26quot;key\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3echrome.i18n.getMessage(\x3cspan class=\x22hljs-string\x22\x3e\x22key\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果获取不到key对应的值，chrome.i18n.getMessage将返回空字符串\x3ccode\x3e\x22\x22\x3c\/code\x3e；若messageName不是字符串或者substitutions数组长度超过9，那么该方法将返回\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e那么，如何为message.json添加含有占位符的字符串呢？如下就以IHeader中message.json的代码做测试：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;iconTips\x26quot;: {\n  \x26quot;message\x26quot;: \x26quot;进入Header监听模式 $a$ $b$\x26quot;,\n  \x26quot;placeholders\x26quot;: {\n    \x26quot;a\x26quot;: {\n      \x26quot;content\x26quot;: \x26quot;$1\x26quot;\n    },\n    \x26quot;b\x26quot;: {\n      \x26quot;content\x26quot;: \x26quot;$2\x26quot;\n    }\n  }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22iconTips\x22\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22message\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22进入Header监听模式 $a$ $b$\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3e\x22placeholders\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22a\x22\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22content\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22b\x22\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3e\x22content\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22$2\x22\x3c\/span\x3e\n    }\n  }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上，占位符格式为\x3ccode\x3e$key$\x3c\/code\x3e，\x3ccode\x3e$key$\x3c\/code\x3e为字符串待注入标示, key是注入点名称，它需要在placeholders配置中指定第几个substitutions的值注入到这里。如上所述，注入点\x3ccode\x3ea\x3c\/code\x3e的内容指定为\x3ccode\x3e$1\x3c\/code\x3e，即第一个替换的值注入到\x3ccode\x3ea\x3c\/code\x3e所在的位置，注入点\x3ccode\x3eb\x3c\/code\x3e的内容指定为\x3ccode\x3e$2\x3c\/code\x3e，即第二个替换的值注入到\x3ccode\x3eb\x3c\/code\x3e所在的位置，以此类推。\x3c\/p\x3e\n\x3cp\x3e实际上，我们有如下两种方式去注入。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 替换注入点a为\x26quot;apple\x26quot;，如果只是替换一个占位点的话，传入数组或字符串都行\nchrome.i18n.getMessage(\x27iconTips\x27, \x27apple\x27); \nchrome.i18n.getMessage(\x27iconTips\x27, [\x27apple\x27]);\n\n\/\/ 替换注入点a为\x26quot;apple\x26quot;，替换b为\x26quot;oranges\x26quot;，对于两个或以上的点位的替换，substitutions类型只能为数组\nchrome.i18n.getMessage(\x27iconTips\x27, [\x27apple\x27, \x27oranges\x27]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 替换注入点a为\x22apple\x22，如果只是替换一个占位点的话，传入数组或字符串都行\x3c\/span\x3e\nchrome.i18n.getMessage(\x3cspan class=\x22hljs-string\x22\x3e\x27iconTips\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27apple\x27\x3c\/span\x3e); \nchrome.i18n.getMessage(\x3cspan class=\x22hljs-string\x22\x3e\x27iconTips\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27apple\x27\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 替换注入点a为\x22apple\x22，替换b为\x22oranges\x22，对于两个或以上的点位的替换，substitutions类型只能为数组\x3c\/span\x3e\nchrome.i18n.getMessage(\x3cspan class=\x22hljs-string\x22\x3e\x27iconTips\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27apple\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27oranges\x27\x3c\/span\x3e]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实际效果如图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ed7de6a4c9?w=357\x26amp;h=72\x26amp;f=gif\x26amp;s=96143\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86ed7de6a4c9?w=357\x26amp;h=72\x26amp;f=gif\x26amp;s=96143\x22 alt=\x22通过占位符注入内容\x22 title=\x22通过占位符注入内容\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e以上引用过程，如下所示（图片来自MDN）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86edb06f143b?w=782\x26amp;h=228\x26amp;f=gif\x26amp;s=16256\x22 src=\x22https:\/\/static.alili.techhttps:\/\/user-gold-cdn.xitu.io\/2017\/11\/14\/15fb86edb06f143b?w=782\x26amp;h=228\x26amp;f=gif\x26amp;s=16256\x22 alt=\x22国际化字符串引用图示\x22 title=\x22国际化字符串引用图示\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e预定义消息\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e以上，提供了这些API还不够，国际化系统还提供了一些预定义的消息，它们如下。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3eMessage Name\x3c\/th\x3e\n\x3cth\x3eDescription\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@extension_id\x3c\/td\x3e\n\x3ctd\x3e扩展ID，可用于拼接链接，即使没有国际化的扩展也可用，注意不能用于manifest.json文件。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@ui_locale\x3c\/td\x3e\n\x3ctd\x3e当前语言，可用于拼接本地化的链接。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@bidi_dir\x3c\/td\x3e\n\x3ctd\x3e当前语言的文字方向，包含\x3ccode\x3eltr\x3c\/code\x3e、\x3ccode\x3ertl\x3c\/code\x3e，分别为从左到右、从右到左。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@bidi_reversed_dir\x3c\/td\x3e\n\x3ctd\x3e若@@bidi_dir值为\x3ccode\x3eltr\x3c\/code\x3e，则它的值为\x3ccode\x3ertl\x3c\/code\x3e，否则为\x3ccode\x3eltr\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@bidi_start_edge\x3c\/td\x3e\n\x3ctd\x3e若@@bidi_dir值为\x3ccode\x3ertl\x3c\/code\x3e，则它的值为\x3ccode\x3eleft\x3c\/code\x3e，否则为\x3ccode\x3eright\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e@@bidi_end_edge\x3c\/td\x3e\n\x3ctd\x3e若@@bidi_dir值为\x3ccode\x3eltr\x3c\/code\x3e，则它的值为\x3ccode\x3eright\x3c\/code\x3e，否则为\x3ccode\x3eleft\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e预定义的消息可在Chrome扩展的JavaScript和CSS中使用，如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var extensionId = chrome.i18n.getMessage(\x27@@extension_id\x27);\nlocation.href = \x27chrome-extension:\/\/\x27 \x2b extensionId \x2b \x27\/res\/options.html\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extensionId = chrome.i18n.getMessage(\x3cspan class=\x22hljs-string\x22\x3e\x27@@extension_id\x27\x3c\/span\x3e);\nlocation.href = \x3cspan class=\x22hljs-string\x22\x3e\x27chrome-extension:\/\/\x27\x3c\/span\x3e \x2b extensionId \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/res\/options.html\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22body {\n  direction: __MSG_@@bidi_dir__;\n  background-image:url(\x27chrome-extension:\/\/__MSG_@@extension_id__\/background.png\x27);\n}\ndiv {\n  padding-__MSG_@@bidi_start_edge__: 5px;\n  padding-__MSG_@@bidi_end_edge__: 10px;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22css hljs\x22\x3e\x3ccode class=\x22css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ebody\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3edirection\x3c\/span\x3e: __MSG_@@bidi_dir__;\n  \x3cspan class=\x22hljs-attribute\x22\x3ebackground-image\x3c\/span\x3e:\x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27chrome-extension:\/\/__MSG_@@extension_id__\/background.png\x27\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e {\n  padding-__MSG_@@\x3cspan class=\x22hljs-attribute\x22\x3ebidi_start_edge__\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e5px\x3c\/span\x3e;\n  padding-__MSG_@@\x3cspan class=\x22hljs-attribute\x22\x3ebidi_end_edge__\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10px\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e其它国际化API\x3c\/h4\x3e\n\x3cp\x3e除了chrome.i18n.getMessage外，还有另外三个API。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3egetAcceptLanguages，获取浏览器可接受的语言列表。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.i18n.getAcceptLanguages(function(languageArray){\n    console.log(languageArray);\n});\n\/\/ 由于IHeader只支持中文和英文，故输出 [\x26quot;zh-CN\x26quot;, \x26quot;zh\x26quot;, \x26quot;en\x26quot;, \x26quot;zh-TW\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3echrome.i18n.getAcceptLanguages(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elanguageArray\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(languageArray);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于IHeader只支持中文和英文，故输出 [\x22zh-CN\x22, \x22zh\x22, \x22en\x22, \x22zh-TW\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3egetUILanguage，获取浏览器用户界面的语言（从Chrome v35起支持）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.i18n.getUILanguage(); \/\/ \x26quot;zh-CN\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3echrome.i18n.getUILanguage(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22zh-CN\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3edetectLanguage，使用CLD检测文本对应的语言。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chrome.i18n.detectLanguage(\x27你好nihaoこんにちは how are you\x27, function(result){\n  console.log(result);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3echrome.i18n.detectLanguage(\x3cspan class=\x22hljs-string\x22\x3e\x27你好nihaoこんにちは how are you\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出如下图：\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzFO\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzFO\x22 alt=\x22chrome.i18n.detectLanguage\x22 title=\x22chrome.i18n.detectLanguage\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e\x3cstrong\x3eChrome扩展开发的心得\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e到目前为止，IHeader是我业余开发时间最长的一款Chrome扩展。从今年的5月8号始，到6月14号，第一版才完工，然后又经过7月、8月近两个月的陆续修改，最终v1.1.0版才成型，这才达到了我最初的开发初衷。\x3c\/p\x3e\n\x3cp\x3e现在网络上流传的各种扩展开发教程非常之多，甚至API翻译的网站也很多，就我所知道的至少有这些：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/open.chrome.360.cn\/extension_dev\/overview.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e360--扩展开发文档\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/chajian.baidu.com\/developer\/extensions\/api_index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript API -百度浏览器应用开发文档\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.ituring.com.cn\/book\/1421\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChrome扩展及应用开发（首发版）\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/champagne\/tag\/Google%20Chrome%E6%89%A9%E5%B1%95\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChrome扩展开发极客\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通过查看这些资源，基本上就能快速上手Chrome扩展开发。\x3c\/p\x3e\n\x3cp\x3e当然，教程再完善也不及官方文档，开发过程中，最难过的就是Chrome开发者网站连接不稳定，经常无法访问（即使自带梯子），因此查看官方网站的资料有些困难，这点比较影响开发进度，所以本文有意多介绍了一些Chrome API的用法。另外，开发好的扩展发布过程中也需要注意两点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e注册Chrome开发者需要5$，亲测浦发的visa信用卡可以支付，没有网上讲的那么复杂。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e发布的扩展，为方便用户查看，需要完善的文档。由于Chrome webstore的扩展面向全球用户，所以文档至少要支持两种语言：中文和英文。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e总之，Chrome扩展，万变不离其宗，无论扩展多么神奇和强大，最终都是通过HTML、CSS、JS来实现功能，脱离不了Web的小天地。因此理论上，只要你会写JS，就完全可以开发Chrome扩展。甚至，连第一个Demo，Chrome都帮你写好了，下载并安装\x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/samples\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSample Extensions - Google Chrome\x3c\/a\x3e网站的随意一个扩展源码，修修改改你就能运行属于自己的扩展了。\x3c\/p\x3e\n\x3cp\x3e当然，一个好的扩展应该是对工作或生活有帮助的。只要你抓住痛点，用心实现功能，利用业余时间开发出一个强大的扩展自然不是问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e\x3cstrong\x3e小结\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e至此，Chrome扩展有关的介绍差不多了，让我们来看看IHeader的效果。借助IHeader扩展程序，我去掉了 www.google.com 网站response的\x3ccode\x3eX-Frame-Options\x3c\/code\x3e字段，终于解决了文章开头的难题，如下所示。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVYzGa\x22 src=\x22https:\/\/static.alili.tech\/img\/bVYzGa\x22 alt=\x22定制response header\x22 title=\x22定制response header\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e安装好IHeader后，可以戳此链接\x3ca href=\x22http:\/\/louiszhai.github.io\/res\/search\/index.html?q=123\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/louiszhai.github.io\/re...\x3c\/a\x3e ，试用IHeader。\x3c\/p\x3e\n\x3cp\x3e不仅如此，IHeader还可以新增、删除或编辑任意指定url的请求响应头，并且即使浏览器重启后，全局监听器依然有效。它适合用于HTTP缓存研究，HTTP接口字段调试，甚至还可以为接口调试时的跨域问题提供临时的解决方案（笔者基于此完成了很多跨域接口的调试工作）。因此，只要您基于HTTP请求响应头去做事情，IHeader都可以帮您简化工作。至于如何使用，这里有一个\x3ca href=\x22https:\/\/github.com\/Louiszhai\/IHeader\/blob\/master\/README_zh_CN.md#iheader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIHeader-Guide\x3c\/a\x3e（由于网络原因，Chrome webstore上更新可能不及时，推荐安装Github上的IHeader源码）。\x3c\/p\x3e\n\x3cp\x3e对Chrome扩展感兴趣的同学，欢迎来\x3ca href=\x22https:\/\/github.com\/Louiszhai\/IHeader\/issues\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub\x3c\/a\x3e学习交流扩展开发的经验。\x3c\/p\x3e\n\x3cp\x3e本文以IHeader扩展程序为引，逐步讲解Chrome扩展程序的开发，涉及内容较多，难免有所疏漏，欢迎批评斧正，谢谢。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e版权声明：转载需注明作者和出处。\x3c\/p\x3e\n\x3cp\x3e本文作者：\x3ca href=\x22https:\/\/github.com\/Louiszhai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elouis\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文链接：\x3ca href=\x22http:\/\/louiszhai.github.io\/2017\/11\/14\/iheader\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/louiszhai.github.io\/20...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e相关文章\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript APIs - Google Chrome\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.chrome.com\/extensions\/messaging\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMessage Passing - Google Chrome\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/15718066\/chrome-runtime-sendmessage-not-working-as-expected\/15718294#15718294\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echromium - chrome.runtime.sendMessage not working as expected\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/codereview.chromium.org\/9965005\/#ps3001\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIssue 9965005: Deprecate chrome.extension.sendRequest in favor of sendMessage, with a safer - Code Review\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/champagne\/p\/4848520.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eChrome浏览器扩展开发系列之十三：消息传递Message\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【Chrome扩展开发】定制HTTP请求响应头域</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011997656">https://segmentfault.com/a/1190000011997656</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/homvplj7c6i/" target="_blank">https://alili.tech/archive/homvplj7c6i/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>