<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Node.js Event Loop之Timers, process.nextTick()"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Node.js Event Loop之Timers, process.nextTick() | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hy68c9soav/",
				"appid": "1613049289050283", 
				"title": "Node.js Event Loop之Timers, process.nextTick() | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-03T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/g6uxhl9lurc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/caza8go4bn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&text=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&text=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&title=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&is_video=false&description=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&title=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&title=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&title=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhy68c9soav%2f&title=Node.js%20Event%20Loop%e4%b9%8bTimers%2c%20process.nextTick%28%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Node.js Event Loop之Timers, process.nextTick()</h1><div class="meta"><div class="postdate"><time datetime="2019-01-03" itemprop="datePublished">2019-01-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3eNode.js以异步I\/O和事件驱动的特性著称,但异步I\/O是怎么实现的呢?其中核心的一部分就是event loop,下文中内容基本来自于\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/v6.x\/doc\/topics\/event-loop-timers-and-nexttick.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js文档\x3c\/a\x3e,有不准确地方请指出.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e什么是Event loop\x3c\/h2\x3e\n\x3cp\x3eevent loop能让Node.js的I\/O操作表现得无阻塞,尽管JavaScript是单线程的但通过尽可能的将操作放到操作系统内核.\x3c\/p\x3e\n\x3cp\x3e由于现在大多数内核都是多线程的,它们可以在后台执行多个操作. 当这些操作完成时,内核通知Node.js应该把回调函数添加到\x3cstrong\x3epoll\x3c\/strong\x3e队列被执行.我们将在接下来的话题里详细讨论.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eEvent Loop 说明\x3c\/h2\x3e\n\x3cp\x3e当Node.js开始时,它将会初始化event loop,处理提供可能造成异步API调用,timers任务,或调用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e的脚本(或者将它放到[REPL][]中,这篇文章中将不会讨论),然后开始处理event loop.\x3c\/p\x3e\n\x3cp\x3e下面是一张event loop操作的简单概览图.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   ┌───────────────────────┐\n┌─\x3e│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I\/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │\x3c─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode class=\x22txt\x22\x3e   ┌───────────────────────┐\n┌─\x26gt;│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I\/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │\x26lt;─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │       \x3cspan class=\x22hljs-built_in\x22\x3e check \x3c\/span\x3e         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e注意: 每一个方框将被简称为一个event loop的阶段.\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e每一个阶段都有一个回调函数的FIFO队列被执行.每一个阶段都有自己特有的方式,通常even loop进入一个给定的阶段时,它将执行该阶段任何的特定操作,然后执行该阶段队列中的回调函数,直到执行完所有回调或执行了最大回调的次数.当队列中的回调已被执行完或者到达了限制次数,eventloop将会从下一个阶段开始依次执行.\x3c\/p\x3e\n\x3cp\x3e由于这些操作可能造成更多的操作,并且在\x3cstrong\x3epoll\x3c\/strong\x3e阶段中产生的新事件被内核推入队列,所以poll事件可以被推入队列当有其它poll事件正在执行时.因此长时间执行回调可以允许poll阶段超过timers设定的时间.详细内容请看\x3ca\x3e\x3cstrong\x3etimers\x3c\/strong\x3e\x3c\/a\x3e和\x3ca\x3e\x3cstrong\x3epoll\x3c\/strong\x3e\x3c\/a\x3e章节.\x3c\/p\x3e\n\x3cp\x3eps: 个人理解-在轮询阶段一个回调执行可能会产生新的事件处理,这些新事件会被推入到轮询队列中,所以poll阶段可以一直执行回调,即使timers的回调已到时间应该被执行时.\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e\x3cstrong\x3e注意:\x3c\/strong\x3e Windows和Unix\/Linux在实现时有一些细微的差异,但那都不是事儿.重点是: 实际上有7或8个步骤,Node.js实际上使用的是它们所有.\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e阶段概览\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3etimers\x3c\/strong\x3e: 这个阶段执行\x3ccode\x3esetTimeout()\x3c\/code\x3e和 \x3ccode\x3esetInterval()\x3c\/code\x3e产生的回调.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eI\/O callbacks\x3c\/strong\x3e: 执行大多数的回调,除了close callbacks,timers和\x3ccode\x3esetImmediate()\x3c\/code\x3e的回调.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eidle, prepare\x3c\/strong\x3e: 仅供内部使用.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3epoll\x3c\/strong\x3e: 获取新的I\/O事件;node会在适当时候在这里阻塞.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3echeck\x3c\/strong\x3e: 执行\x3ccode\x3esetImmediate()\x3c\/code\x3e回调.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eclose callbacks\x3c\/strong\x3e: e.g. \x3ccode\x3esocket.on(\x27close\x27, ...)\x3c\/code\x3e.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在每次event loop之间,Node.js会检查它是否正在等待任何异步I\/O或计时器,如果没有就会完全关闭.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e阶段详情\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3etimers\x3c\/h3\x3e\n\x3cp\x3e一个定时器指定的是执行回调函数的\x3cstrong\x3e阈值\x3c\/strong\x3e,而不是\x3cstrong\x3e确定\x3c\/strong\x3e的时间点.定时器的回调将在规定的时间过后运行;然而,操作系统调度或其他回调函数的运行可能会使执行回调延迟.\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e\x3cstrong\x3e注意\x3c\/strong\x3e: 技术上,\x3ca\x3e\x3cstrong\x3epoll\x3c\/strong\x3e 阶段\x3c\/a\x3e控制了timers被执行.\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e例如, 你要在100ms的延时后在回调函数并且执行一个耗时95ms的异步读取文本操作:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\n\nfunction someAsyncOperation(callback) {\n  \/\/ Assume this takes 95ms to complete\n  fs.readFile(\x27\/path\/to\/file\x27, callback);\n}\n\nconst timeoutScheduled = Date.now();\n\nsetTimeout(function() {\n\n  const delay = Date.now() - timeoutScheduled;\n\n  console.log(delay \x2b \x27ms have passed since I was scheduled\x27);\n}, 100);\n\n\n\/\/ do someAsyncOperation which takes 95 ms to complete\nsomeAsyncOperation(function() {\n\n  const startCallback = Date.now();\n\n  \/\/ do something that will take 10ms...\n  while (Date.now() - startCallback \x3c 10) {\n    \/\/ do nothing\n  }\n\n});\n\n\/\/ 输出: 105ms have passed since I was scheduled\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeAsyncOperation\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Assume this takes 95ms to complete\x3c\/span\x3e\n  fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27\/path\/to\/file\x27\x3c\/span\x3e, callback);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e timeoutScheduled = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e delay = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - timeoutScheduled;\n\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(delay \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27ms have passed since I was scheduled\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ do someAsyncOperation which takes 95 ms to complete\x3c\/span\x3e\nsomeAsyncOperation(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e startCallback = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something that will take 10ms...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - startCallback \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do nothing\x3c\/span\x3e\n  }\n\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出: 105ms have passed since I was scheduled\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当event loop进入\x3cstrong\x3epoll\x3c\/strong\x3e阶段时,它是一个空的队列(\x3ccode\x3efs.readFile()\x3c\/code\x3e还没有完成),所以它会等待数毫秒等待timers设定时间的到达.直到等待95 ms过后, \x3ccode\x3efs.readFile()\x3c\/code\x3e完成文件读取然后它的回调函数会被添加至\x3cstrong\x3epoll\x3c\/strong\x3e队列然后执行.当执行完成后队列中没有其他回调,所以event loop会查看定时器设定的时间已经到达然后回撤到timers阶段执行timers的回调函数.在例子里你会发现,从定时器被记录到执行回调函数耗时105ms.\x3c\/p\x3e\n\x3cp\x3e注意: 为了防止\x3cstrong\x3epoll\x3c\/strong\x3e阶段阻塞死event loop, [libuv]\x3cbr\x3e(\x3ca href=\x22http:\/\/libuv.org\/)\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/libuv.org\/)\x3c\/a\x3e (实现Node.js事件循环的C库和平台的所有异步行为)\x3cbr\x3e也有一个固定最大值(系统依赖).\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eI\/O callbacks\x3c\/h3\x3e\n\x3cp\x3e这个阶段执行一些系统操作的回调,例如TCP错误等类型.例如TCP socket 尝试连接时收到了\x3ccode\x3eECONNREFUSED\x3c\/code\x3e,一些*nix系统想等待错误日志记录.这些都将在\x3cstrong\x3eI\/O callbacks\x3c\/strong\x3e阶段被推入队列执行.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3epoll\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3epoll\x3c\/strong\x3e 阶段有两个主要的功能:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e为已经到达或超时的定时器执行脚本\x3c\/li\x3e\n\x3cli\x3e处理在\x3cstrong\x3epoll\x3c\/strong\x3e队列中的事件.\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e当event loop进入\x3cstrong\x3epoll\x3c\/strong\x3e阶段并且没有timers任务时会执行下面某一条操作:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果\x3cstrong\x3epoll\x3c\/strong\x3e队列\x3cstrong\x3e不为空\x3c\/strong\x3e,则event loop会同步的执行回调队列,直到执行完回调或达到系统最大限制.\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果\x3cstrong\x3epoll\x3c\/strong\x3e队列\x3cstrong\x3e为空\x3c\/strong\x3e,会执行下面某一条操做:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果脚本被\x3ccode\x3esetImmediate()\x3c\/code\x3e执行,则event loop会结束 \x3cstrong\x3epoll\x3c\/strong\x3e阶段,继续向下进入到\x3cstrong\x3echeck\x3c\/strong\x3e阶段执行\x3ccode\x3esetImmediate()\x3c\/code\x3e的脚本.\x3c\/li\x3e\n\x3cli\x3e如果脚本不是被\x3ccode\x3esetImmediate()\x3c\/code\x3e执行,event loop会等待回调函数被添加至队列,然后立刻执行它们.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一旦\x3cstrong\x3epoll\x3c\/strong\x3e队列空了,event loop会检查timers是否有以满足条件的定时器,如果有一个以上满足执行条件的定时器,event loop将会撤回至\x3cstrong\x3etimers\x3c\/strong\x3e阶段去执行定时器的回调函数.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3echeck\x3c\/h3\x3e\n\x3cp\x3e这个阶段允许立刻执行一个回调在\x3cstrong\x3epoll\x3c\/strong\x3e阶段完成后.如果\x3cstrong\x3epoll\x3c\/strong\x3e阶段已经执行完成或脚本已经使用\x3ccode\x3esetImmediate()\x3c\/code\x3e,event loop 可能就会继续到\x3cstrong\x3echeck\x3c\/strong\x3e阶段而不是等待.\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetImmediate()\x3c\/code\x3e实际是在event loop 独立阶段运行的特殊定时器.它使用了libuv API来使回调函数在\x3cstrong\x3epoll\x3c\/strong\x3e阶段后执行.\x3c\/p\x3e\n\x3cp\x3e通常在代码执行时,event loop 最终会到达poll阶段,等待传入连接,请求等等.然而,如果有一个被\x3ccode\x3esetImmediate()\x3c\/code\x3e执行的回调,\x3cstrong\x3epoll\x3c\/strong\x3e阶段会变得空闲,它将会结束并进入\x3cstrong\x3echeck\x3c\/strong\x3e阶段而不是等待新的\x3cstrong\x3epoll\x3c\/strong\x3e事件.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eclose callbacks\x3c\/h3\x3e\n\x3cp\x3e如果一个socket或者操作被突然关闭(例如.\x3ccode\x3esocket.destroy()\x3c\/code\x3e),这个\x3ccode\x3eclose\x3c\/code\x3e事件将在这个阶段被触发.否则它将会通过\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e被触发.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e\n\x3ccode\x3esetImmediate()\x3c\/code\x3e vs \x3ccode\x3esetTimeout()\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3esetImmediate\x3c\/code\x3e 和 \x3ccode\x3esetTimeout()\x3c\/code\x3e 是很相似的,但是它们的调用方式不同导致了会有不同的表现.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3esetImmediate()\x3c\/code\x3e 会中断\x3cstrong\x3epoll\x3c\/strong\x3e阶段,立即执行..\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esetTimeout()\x3c\/code\x3e 将在给定的毫秒后执行设定的脚本.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3etimers的执行顺序会根据它们被调用的上下文而变化.如果两个都在主模块内被调用，则时序将受到进程的性能的限制（可能受机器上运行的其他应用程序的影响）.\x3c\/p\x3e\n\x3cp\x3e例如,我们执行下面两个不在I\/O周期内(主模块)的脚本,这两个timers的执行顺序是不确定的,它受到进程性能的影响:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ timeout_vs_immediate.js\nsetTimeout(function timeout() {\n  console.log(\x27timeout\x27);\n}, 0);\n\nsetImmediate(function immediate() {\n  console.log(\x27immediate\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ timeout_vs_immediate.js\x3c\/span\x3e\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimmediate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27immediate\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ node timeout_vs_immediate.js\ntimeout\nimmediate\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode class=\x22console\x22\x3e$ \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout_vs_immediate\x3c\/span\x3e.js\ntimeout\nimmediate\n\n$ \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout_vs_immediate\x3c\/span\x3e.js\nimmediate\ntimeout\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而,如果你把这两个调用放到I\/O周期内,则immediate的回调总会被先执行:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ timeout_vs_immediate.js\nconst fs = require(\x27fs\x27);\n\nfs.readFile(__filename, () =\x3e {\n  setTimeout(() =\x3e {\n    console.log(\x27timeout\x27);\n  }, 0);\n  setImmediate(() =\x3e {\n    console.log(\x27immediate\x27);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ timeout_vs_immediate.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\nfs.readFile(__filename, () =\x26gt; {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e);\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27immediate\x27\x3c\/span\x3e);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ node timeout_vs_immediate.js\nimmediate\ntimeout\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode class=\x22console\x22\x3e$ \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout_vs_immediate\x3c\/span\x3e.js\nimmediate\ntimeout\n\n$ \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout_vs_immediate\x3c\/span\x3e.js\nimmediate\ntimeout\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3ccode\x3esetImmediate()\x3c\/code\x3e比\x3ccode\x3esetTimeout()\x3c\/code\x3e的好处是\x3ccode\x3esetImmediate()\x3c\/code\x3e在I\/O周期内总是比所有timers先执行,无论有多少timers存在.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e理解 \x3ccode\x3eprocess.nextTick()\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e你可能已经注意到\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e没有在概览图中列出,尽管他是异步API的一部分.这是因为\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e在技术上不是event loop的一部分.反而\x3ccode\x3enextTickQueue\x3c\/code\x3e会在当前操作完成后会被执行,无论当前处于event loop的什么阶段.\x3c\/p\x3e\n\x3cp\x3e再看看概览图,在给定的阶段你任何时候调用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e,通过\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e指定的回调函数都会在event loop继续执行前被解析.这可能会造成一些不好的情况,因为\x3cstrong\x3e它允许你通过递归调用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e而造成I\/O阻塞死\x3c\/strong\x3e,因为它阻止了event loop到达\x3cstrong\x3epoll\x3c\/strong\x3e阶段.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e为什么这种操作会被允许呢?\x3c\/h3\x3e\n\x3cp\x3e部分原因是一个API应该是异步事件尽管它可能不是异步的.看看下面代码片段:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function apiCall(arg, callback) {\n  if (typeof arg !== \x27string\x27)\n    return process.nextTick(callback,\n                            new TypeError(\x27argument should be string\x27));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapiCall\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earg, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e arg !== \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e process.nextTick(callback,\n                            \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27argument should be string\x27\x3c\/span\x3e));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码里对参数做了校验,如果不正确,它将会在回调函数中抛出错误.API最近更新，允许传递参数给 process.nextTick() ，process.nextTick()可以接受任何参数，回调函数被当做参数传递给回调函数后，你就不必使用嵌套函数了.\x3c\/p\x3e\n\x3cp\x3e我们所做的就是将错误回传给用户当用户的其它代码执行后.通过使用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e我们确保\x3ccode\x3eapiCall()\x3c\/code\x3e执行回调函数在用户的代码之后,在event loop运行的阶段之前.为了实现这一点,JS调用的堆栈被允许释放掉,然后立刻执行提供的回调函数,回调允许用户递归的调用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e直到v8限制的调用堆栈最大值.\x3c\/p\x3e\n\x3cp\x3e这种理念可能会导致一些潜在的问题.来看这段代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let bar;\n\n\/\/ this has an asynchronous signature, but calls callback synchronously\nfunction someAsyncApiCall(callback) { callback(); }\n\n\/\/ the callback is called before `someAsyncApiCall` completes.\nsomeAsyncApiCall(() =\x3e {\n\n  \/\/ since someAsyncApiCall has completed, bar hasn\x27t been assigned any value\n  console.log(\x27bar\x27, bar); \/\/ undefined\n\n});\n\nbar = 1;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e bar;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this has an asynchronous signature, but calls callback synchronously\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeAsyncApiCall\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{ callback(); }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the callback is called before `someAsyncApiCall` completes.\x3c\/span\x3e\nsomeAsyncApiCall(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ since someAsyncApiCall has completed, bar hasn\x27t been assigned any value\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e, bar); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\n});\n\nbar = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用户定义了一个有异步标签的函数\x3ccode\x3esomeAsyncApiCall()\x3c\/code\x3e,尽管他的操作是同步的.当它被调用的时候,提供的回调函数在event loop的同一阶段中被调用,因为\x3ccode\x3esomeAsyncApiCall()\x3c\/code\x3e没有任何异步操作.所以回调函数尝试引用\x3ccode\x3ebar\x3c\/code\x3e尽管这个变量在作用域没有值,因为代码还没有执行到最后.\x3c\/p\x3e\n\x3cp\x3e通过将回调函数放在\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e里,代码仍然有执行完的能力,允许所有的变量,函数等先被初始化来供回调函数调用.它还有不允许event loop继续执行的优势.它可能在event loop继续执行前抛出一个错误给用户很有用.这里提供一个使用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e的示例:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let bar;\n\nfunction someAsyncApiCall(callback) {\n  process.nextTick(callback);\n}\n\nsomeAsyncApiCall(() =\x3e {\n  console.log(\x27bar\x27, bar); \/\/ 1\n});\n\nbar = 1;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e bar;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeAsyncApiCall\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n  process.nextTick(callback);\n}\n\nsomeAsyncApiCall(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e, bar); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n});\n\nbar = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有另一个真实的例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const server = net.createServer(() =\x3e {}).listen(8080);\n\nserver.on(\x27listening\x27, () =\x3e {});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e server = net.createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}).listen(\x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e);\n\nserver.on(\x3cspan class=\x22hljs-string\x22\x3e\x27listening\x27\x3c\/span\x3e, () =\x26gt; {});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e仅当端口可用时端口立即被绑定.所以\x3ccode\x3e\x27listening\x27\x3c\/code\x3e的回调函数能立即被调用.问题是那时候不会设置\x3ccode\x3e.on(\x27listening\x27)\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e为了解决这个问题,\x3ccode\x3e\x27listening\x27\x3c\/code\x3e事件被放入\x3ccode\x3enextTick()\x3c\/code\x3e队列来允许代码执行完.这会允许用户设置他们想要的任何事件处理.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e\n\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e vs \x3ccode\x3esetImmediate()\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e我们有两个直到现在用户都关心的相似的调用,但他们的名字令人困惑.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e 在同一阶段立即触发\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esetImmediate()\x3c\/code\x3e 在以下迭代器或者event loop的\x27tick\x27中触发\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e本质上,这两个名字应该交换.\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e比\x3ccode\x3esetImmediate()\x3c\/code\x3e触发要快但这是一个不想改变的历史的命名.做这个改变会破坏npm上大多数包.每天都有新模块被增加,意味着每天我们都在等待更多的潜在错误发生.当他们困惑时,这个名字就不会被改变.\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e我们建议开发者使用\x3ccode\x3esetImmediate()\x3c\/code\x3e因为它更容易被理解(并且它保持了更好的兼容性,例如浏览器的JS)\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e为什么使用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e?\x3c\/h2\x3e\n\x3cp\x3e有两个主要原因:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e允许用户处理错误，清除任何不需要的资源，或者可能在事件循环继续之前再次尝试该请求.\x3c\/li\x3e\n\x3cli\x3e同时有必要允许回调函数执行在调用堆栈释放之后但在event loop继续之前.\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e一个满足用户期待的简单例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const server = net.createServer();\nserver.on(\x27connection\x27, function(conn) { });\n\nserver.listen(8080);\nserver.on(\x27listening\x27, function() { });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e server = net.createServer();\nserver.on(\x3cspan class=\x22hljs-string\x22\x3e\x27connection\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econn\x3c\/span\x3e) \x3c\/span\x3e{ });\n\nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e);\nserver.on(\x3cspan class=\x22hljs-string\x22\x3e\x27listening\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3elisten()\x3c\/code\x3e在event loop开始时执行,但是listening的回调函数被放在一个\x3ccode\x3esetImmediate()\x3c\/code\x3e中.现在除非主机名可用于绑定端口会立即执行.现在为了event loop继续执行,它必须进入\x3cstrong\x3epoll\x3c\/strong\x3e阶段,意味着在监听事件前且没有触发允许连接事件时没有接收到请求的可能.\x3c\/p\x3e\n\x3cp\x3e另一个例子是运行一个函数构造函数，例如，继承自\x3ccode\x3eEventEmitter\x3c\/code\x3e，并且想要在构造函数中调用一个事件:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const EventEmitter = require(\x27events\x27);\nconst util = require(\x27util\x27);\n\nfunction MyEmitter() {\n  EventEmitter.call(this);\n  this.emit(\x27event\x27);\n}\nutil.inherits(MyEmitter, EventEmitter);\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on(\x27event\x27, function() {\n  console.log(\x27an event occurred!\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EventEmitter = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27events\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyEmitter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  EventEmitter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27event\x27\x3c\/span\x3e);\n}\nutil.inherits(MyEmitter, EventEmitter);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e myEmitter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyEmitter();\nmyEmitter.on(\x3cspan class=\x22hljs-string\x22\x3e\x27event\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27an event occurred!\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你不能在构造函数中立即触发事件,因为代码不会执行到用户为该事件分配回调函数的地方,所以,在构造函数本身中,你可以使用\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e设置回调函数来在够咱函数完成后触发事件.有一个小栗子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const EventEmitter = require(\x27events\x27);\nconst util = require(\x27util\x27);\n\nfunction MyEmitter() {\n  EventEmitter.call(this);\n\n  \/\/ use nextTick to emit the event once a handler is assigned\n  process.nextTick(function() {\n    this.emit(\x27event\x27);\n  }.bind(this));\n}\nutil.inherits(MyEmitter, EventEmitter);\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on(\x27event\x27, function() {\n  console.log(\x27an event occurred!\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EventEmitter = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27events\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyEmitter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  EventEmitter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use nextTick to emit the event once a handler is assigned\x3c\/span\x3e\n  process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27event\x27\x3c\/span\x3e);\n  }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}\nutil.inherits(MyEmitter, EventEmitter);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e myEmitter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyEmitter();\nmyEmitter.on(\x3cspan class=\x22hljs-string\x22\x3e\x27event\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27an event occurred!\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e部分个人理解\x3c\/h2\x3e\n\x3cp\x3e前面基本是基于文档的翻译(由于英文能力问题,很多地方都模模糊糊,甚至是狗屁不通[捂脸]),下面写一些重点部分的理解\x3c\/p\x3e\n\x3ch4\x3e几个概念\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3eevent loop是跑在主进程上的一个\x3ccode\x3ewhile(true) {}\x3c\/code\x3e循环.\x3c\/li\x3e\n\x3cli\x3etimers阶段包括\x3ccode\x3esetTimeout()\x3c\/code\x3e,\x3ccode\x3esetInterval()\x3c\/code\x3e两个定时器,回调执行时间等于或者晚于定时器设定的时间,因为在\x3cstrong\x3epoll\x3c\/strong\x3e阶段会执行其它回调函数,在空闲时才回去检查定时器(event loop的开始和结束时检查).\x3c\/li\x3e\n\x3cli\x3e在I\/O callback阶段,虽然在阶段介绍里说的是执行除timers,Immediate,close之外的所有回调,但后面详细介绍中又说了,这里执行的大多是stream, pipe, tcp, udp通信错误的回调,例如fs产生的回调应该还是在\x3cstrong\x3epoll\x3c\/strong\x3e阶段执行的.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3epoll\x3c\/strong\x3e阶段应该才是真正的执行了除timers,Immediate,close外的所有回调.\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eprocess.nextTick()\x3c\/strong\x3e没有在任何一个阶段执行,它执行的时间应该是在各个阶段切换的中间执行.\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch4\x3e几段代码\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\n\nfs.readFile(\x27..\/mine.js\x27, () =\x3e {\n    setTimeout(() =\x3e { console.log(\x26quot;setTimeout\x26quot;) }, 0);\n    process.nextTick(() =\x3e { console.log(\x26quot;process.nextTick\x26quot;) })\n    setImmediate(() =\x3e { console.log(\x26quot;setImmediate\x26quot;) })\n});\n\/*log -------------------\nprocess.nextTick\nsetImmediate\nsetTimeout\n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/mine.js\x27\x3c\/span\x3e, () =\x26gt; {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setTimeout\x22\x3c\/span\x3e) }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22process.nextTick\x22\x3c\/span\x3e) })\n    setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setImmediate\x22\x3c\/span\x3e) })\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/*log -------------------\nprocess.nextTick\nsetImmediate\nsetTimeout\n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e当文件读取完成后在\x3cstrong\x3epoll\x3c\/strong\x3e阶段执行回调函数\x3c\/li\x3e\n\x3cli\x3e将\x3ccode\x3esetTimeout\x3c\/code\x3e添加至timers队列,解析\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e回调函数,将\x3ccode\x3esetImmediate\x3c\/code\x3e添加至\x3cstrong\x3echeck\x3c\/strong\x3e队列\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3epoll\x3c\/strong\x3e队列为空,有\x3ccode\x3esetImmediate\x3c\/code\x3e的代码,继续向下一个阶段.\x3c\/li\x3e\n\x3cli\x3e在到达\x3cstrong\x3echeck\x3c\/strong\x3e阶段前执行\x3ccode\x3eprocess.nextTick()\x3c\/code\x3e回调函数\x3c\/li\x3e\n\x3cli\x3e在\x3cstrong\x3echeck\x3c\/strong\x3e阶段执行\x3ccode\x3esetImmediate\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e在\x3cstrong\x3etimers\x3c\/strong\x3e阶段执行\x3ccode\x3esetTimeout\x3c\/code\x3e回调\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\n\nconst start = new Date();\nfs.readFile(\x27..\/mine.js\x27, () =\x3e {\n    setTimeout(() =\x3e { console.log(\x26quot;setTimeout spend: \x26quot;, new Date() - start) }, 0);\n    setImmediate(() =\x3e { console.log(\x26quot;setImmediate spend: \x26quot;, new Date() - start) })\n    process.nextTick(() =\x3e { console.log(\x26quot;process.nextTick spend: \x26quot;, new Date() - start) })\n});\nsetTimeout(() =\x3e { console.log(\x26quot;setTimeout-main spend: \x26quot;, new Date() - start) }, 0);\nsetImmediate(() =\x3e { console.log(\x26quot;setImmediate-main spend: \x26quot;, new Date() - start) })\nprocess.nextTick(() =\x3e { console.log(\x26quot;process.nextTick-main spend: \x26quot;, new Date() - start) })\n\/* log ----------------\nprocess.nextTick-main spend:  9\nsetTimeout-main spend:  12\nsetImmediate-main spend:  13\nprocess.nextTick spend:  14\nsetImmediate spend:  15\nsetTimeout spend:  15\n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e start = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e();\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/mine.js\x27\x3c\/span\x3e, () =\x26gt; {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setTimeout spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setImmediate spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) })\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22process.nextTick spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) })\n});\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setTimeout-main spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22setImmediate-main spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) })\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22process.nextTick-main spend: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() - start) })\n\x3cspan class=\x22hljs-comment\x22\x3e\/* log ----------------\nprocess.nextTick-main spend:  9\nsetTimeout-main spend:  12\nsetImmediate-main spend:  13\nprocess.nextTick spend:  14\nsetImmediate spend:  15\nsetTimeout spend:  15\n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里没有搞懂为什么主进程内的\x3ccode\x3esetTimeout\x3c\/code\x3e总是比\x3ccode\x3esetImmediate\x3c\/code\x3e先执行,按文档所说,两个应该是不确定谁先执行.\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Node.js Event Loop之Timers, process.nextTick()</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010832691">https://segmentfault.com/a/1190000010832691</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hy68c9soav/" target="_blank">https://alili.tech/archive/hy68c9soav/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>