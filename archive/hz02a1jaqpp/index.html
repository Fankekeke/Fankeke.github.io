<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="还在用 Redux，要不要试试 GraphQL 和 Apollo？"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>还在用 Redux，要不要试试 GraphQL 和 Apollo？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hz02a1jaqpp/",
				"appid": "1613049289050283", 
				"title": "还在用 Redux，要不要试试 GraphQL 和 Apollo？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-11T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/xrnp7inbr1n/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/3gp8uwj4tkw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&text=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&text=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&title=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&is_video=false&description=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&title=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&title=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&title=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhz02a1jaqpp%2f&title=%e8%bf%98%e5%9c%a8%e7%94%a8%20Redux%ef%bc%8c%e8%a6%81%e4%b8%8d%e8%a6%81%e8%af%95%e8%af%95%20GraphQL%20%e5%92%8c%20Apollo%ef%bc%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">还在用 Redux，要不要试试 GraphQL 和 Apollo？</h1><div class="meta"><div class="postdate"><time datetime="2018-12-11" itemprop="datePublished">2018-12-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e还在用 Redux，要不要试试 GraphQL \x26amp; Apollo？\x3c\/h1\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV48Lu?w=618\x26amp;h=602\x22 src=\x22https:\/\/static.alili.tech\/img\/bV48Lu?w=618\x26amp;h=602\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e前段时间刷 Twitter 的时候看到大 V 纷纷提到 Apollo，预测它将在 2018 年崛起。正巧碰上有使用 GraphQL 的机会，在大概翻了下 Apollo 的文档之后，我下定决心在新的前端项目里尝试下抛开已经熟悉的 Redux，完全使用 Apollo 来写数据层。一个月后的现在，我必须出来好好赞美下这位“太阳神”了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eGraphQL\x3c\/h2\x3e\n\x3cp\x3e转眼已经 2018 年了，GraphQL 已不再是个新鲜的名词了。15 年短暂的掀起一波讨论之后，似乎也没有听到多少它的声音了。然而 Github 在这几年里慢慢成熟，Github 也将新版 api 完全用 GraphQL 实现。在这里我就不展开讨论 GraphQL 的本身了，它让前后端之间的数据获取变得更加简单。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eRedux\x3c\/h2\x3e\n\x3cp\x3e提到前端数据管理，最先想到的就是 Redux，我想很多人都体验过对 Redux 从陌生到熟悉的各个阶段，大致应该是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV48LC?w=1492\x26amp;h=830\x22 src=\x22https:\/\/static.alili.tech\/img\/bV48LC?w=1492\x26amp;h=830\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e开始：Facebook 设计的 Flux 架构，很厉害的样子，大家都在用那我也用吧\x3c\/li\x3e\n\x3cli\x3e半年：数据管理变的清晰些，终于不用在组件里来回混乱的 setState 了\x3c\/li\x3e\n\x3cli\x3e一年：我就是个 CRUD 工程师，写个千篇一律的列表，表单页用 redux 真是折腾，多些了多少代码啊\x3c\/li\x3e\n\x3cli\x3e一年半：看了 redux-action，redux-promise，dva， mirror ...，根据团队的业务场景定制了最合适的中间件和插件。代码又变的简洁啦\x3c\/li\x3e\n\x3cli\x3e两年：该折腾的都折腾过了。有点累了，但是也离不开了。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为什么累了呢？因为 Flux 的单向数据流对你来说已经不再新鲜了。大部分时候，store 里存放的都是从后端请求来的数据，对于它们而言，怎么样做 dispatch 和 reduce 其实并不是关键，反倒是怎么设计 store 值得考虑。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e当 Redux 遇上业务需求\x3c\/h1\x3e\n\x3cp\x3e让我们直接以一个真实的场景作为例子吧：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV48LJ?w=1280\x26amp;h=658\x22 src=\x22https:\/\/static.alili.tech\/img\/bV48LJ?w=1280\x26amp;h=658\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这是一个很常见的评论列表，拿到需求后我们就开始写我们的 \x3ccode\x3e\x26lt;Comments \/\x26gt;\x3c\/code\x3e 组件了，在 Redux 的范式下，我们难免要按照这个逻辑来写：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在 \x3ccode\x3eComments\x3c\/code\x3e 的 \x3ccode\x3edidMount\x3c\/code\x3e 里，\x3ccode\x3edispatch\x3c\/code\x3e 一个获取数据的 \x3ccode\x3eaction\x3c\/code\x3e，在这个 \x3ccode\x3efetch action\x3c\/code\x3e 内发送请求。为了做 loading，我们很可能要再 dispatch 一个 action 去通知 redux 我们发起了一个请求。\x3c\/li\x3e\n\x3cli\x3e如果请求顺利成功了，我们 dispatch 一个请求数据成功的 action，然后在 reducer 内处理并更新数据。\x3c\/li\x3e\n\x3cli\x3e在 \x3ccode\x3eComments\x3c\/code\x3e 内我们收到了 props 传来的数据，正式开始渲染\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们大量的工作花费在了如何获取数据上。而我们面临的挑战又是什么呢？看几个产品经理们可能会提的需求\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e用户创建或修改评论，要能立刻在列表中看到更新；\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e简单，重新请求一遍整个列表接口就好了！一般而言确实足够了，不过要求高的产品可能会要求你做”乐观“更新来让体验更好。这也没什么问题，加个 \x3ccode\x3ereducer\x3c\/code\x3e 就是。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e当鼠标 hover 在用户头像上的时候，要弹出用户的详细数据（个人简介，联系方式...）\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e首先你会想，后端大哥能不能把这些字段都帮我加在评论的接口数据里，他毫不犹豫的拒绝了你，拿出一个 commonUser 的接口让你自己去调。细一想用户数据量不小，评论里也有大量的相同用户，不放在列表里也确实合理。心一横，干脆把前端这里的数据结构全部 normalize 化，按用户 id 为 key 用哈希表来存放数据。也就一个下午，你得到了一个非常完美的解决方案。\x3c\/p\x3e\n\x3cp\x3e面对这样的场景，我们写了太多的 \x3cem\x3e命令式\x3c\/em\x3e 代码，我们一步步的描述了怎么去获取评论数据，在得到评论数据后再提取出所有的用户 id，去重后再次请求获取所有的用户数据，等等。我们还需要考虑缓 normalize, 缓存，乐观更新等等细节上的问题。而这些，恰恰是 redux 帮不了我们的。于是我们会基于 Redux 封装更强大的库和框架，但真正 focus 在数据获取上的好像还真没看到非常合适的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3eDeclarative（声明式） vs Imperative（命令式）\x3c\/h1\x3e\n\x3cp\x3e那么在 Apollo 的世界里是什么样的呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { graphql } from \x27react-apollo\x27;\n\nconst CommentsQuery = gql`\n    query Comments() {\n        comments {\n            id\n            content\n            creator {\n                id\n                name\n            }\n        }\n    }\n`;\n\nexport default graphql(CommentsQuery)(Comments);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { graphql } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-apollo\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e CommentsQuery = gql\x3cspan class=\x22hljs-string\x22\x3e`\n    query Comments() {\n        comments {\n            id\n            content\n            creator {\n                id\n                name\n            }\n        }\n    }\n`\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e graphql(CommentsQuery)(Comments);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们使用了 \x3ccode\x3egraphql\x3c\/code\x3e(类比到 redux 中的 connect) 作为高阶组件将一条 GraphQL 的查询语句绑定到了 Comments 组件上，然后你所有的一切就准备就绪了。这么简单么？是的，我们不再需要描述怎么在 didMount 里发送请求，怎么处理请求来的数据。而是委托 Apollo 帮我们处理这些所有事情，它会称职的帮我们在需要的时候发送请求获取数据，然后将 data 映射到 Comments 的 props 中交给我们。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV48LQ?w=689\x26amp;h=378\x22 src=\x22https:\/\/static.alili.tech\/img\/bV48LQ?w=689\x26amp;h=378\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e不止于此，当我们做更新操作的时候也会便捷许多。比如修改一条评论。我们定义一个 graphql 的 mutation 操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n\nconst updateComment = gql`\n    mutation UpdateComment($id: Int!, $content: String!) {\n      UpdateComment(id: $id, content: $content) {\n        id\n        content\n        gmtModified\n      }\n    }\n`;\n\nclass Comments extends React.Component {\n    \/\/ ...\n    onUpdateComment(id, content) {\n        this.props.updateComment(id, content);\n    }\n    \n    \/\/ ...\n}\n\nexport default graphql(updateComment)(graphql(CommentsQuery)(Comments));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22es6\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\nconst updateComment = gql`\n    mutation \x3cspan class=\x22hljs-type\x22\x3eUpdateComment\x3c\/span\x3e($id: \x3cspan class=\x22hljs-type\x22\x3eInt\x3c\/span\x3e!, $content: \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e!) {\n      \x3cspan class=\x22hljs-type\x22\x3eUpdateComment\x3c\/span\x3e(id: $id, content: $content) {\n        id\n        content\n        gmtModified\n      }\n    }\n`;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComments\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    onUpdateComment(id, content) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.updateComment(id, content);\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e graphql(updateComment)(graphql(\x3cspan class=\x22hljs-type\x22\x3eCommentsQuery\x3c\/span\x3e)(\x3cspan class=\x22hljs-type\x22\x3eComments\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们调用 updateComment 时，你就会神奇的发现，列表中的评论数据自动更新了。这是因为 apollo-client 把数据按照类型自动缓存在了 cache 中，GraphQL 节点返回的任何数据都会自动被用来更新缓存，在 UpdateComment 这个 mutation 中，我们定义了它的返回值，一条类型为 Comment 的新修改评论，并且指定了需要接受的字段，\x3ccode\x3econtent\x3c\/code\x3e 和 \x3ccode\x3egmtModified\x3c\/code\x3e。这样，apollo-client 就会自动通过 id 和类型去更新缓存中的数据，从而重新渲染我们的列表。\x3c\/p\x3e\n\x3cp\x3e再看看剩下的需求，我们需要在鼠标停留在用户头像时展开用户详情。这个需求下我们不仅仅需要定义我们需要什么数据，还会关心“怎么”获取数据（在 hover 头像时发送请求）。Apollo 同样为我们提供了 “命令式” 的支持。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UserItem extends React.Component {\n    \/\/ ...\n    onHover() {\n        const { client, id } = this.props;\n        \n        client.query({\n           query: UserQuery,\n           variables: { id }\n        }).then(data =\x3e {\n            this.setState({ fullUserInfo: data });\n        });\n    }\n}\n\nexport default withApollo(UserItem);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22es6\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUserItem\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    onHover() {\n        const { client, id } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n        \n        client.query({\n           query: \x3cspan class=\x22hljs-type\x22\x3eUserQuery\x3c\/span\x3e,\n           variables: { id }\n        }).then(data =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ fullUserInfo: data });\n        });\n    }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e withApollo(\x3cspan class=\x22hljs-type\x22\x3eUserItem\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e幸运的是这里我们依然不需要自己考虑缓存的问题。得益于 Apollo 全局的数据缓存，当我们查询过用户 A 之后，再次查询相同 id 的数据会直接命中缓存，apollo-client 会直接 resolve 缓存中的数据，并不发送请求。这时候问题来了，假设我就是想要每次都重新查询呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22client.query({\n   query: UserQuery,\n   variables: { id },\n   fetchPolicy: \x27cache-and-network\x27\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eclient.query({\n   \x3cspan class=\x22hljs-attr\x22\x3equery\x3c\/span\x3e: UserQuery,\n   \x3cspan class=\x22hljs-attr\x22\x3evariables\x3c\/span\x3e: { id },\n   \x3cspan class=\x22hljs-attr\x22\x3efetchPolicy\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27cache-and-network\x27\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eApollo 给我们提供了很多策略来自定义缓存逻辑，比如默认的 \x3ccode\x3ecache-first\x3c\/code\x3e (优先使用缓存)，这里的 \x3ccode\x3ecache-and-network\x3c\/code\x3e（先使用缓存，同时发请求更新），以及 \x3ccode\x3ecache-only\x3c\/code\x3e 和 \x3ccode\x3enetwork-only\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这些就是 GraphQL 和 Apollo 很吸引我的一些地方。当你开始从 GraphQL 的角度来思考，你更多的关心的是你的业务组件需要什么数据，而不是怎么一步步的获得它。而剩下的大部分业务场景，都可以通过前端的数据类型推导和缓存自动解决掉。当然，篇幅有限，还有很多优雅的地方来不及提及，比如分页，直接操作缓存达到乐观更新，轮询查询，以及数据订阅等等。如果有机会的话我们可以继续深入探讨。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eREST 和其他本地状态 ？\x3c\/h2\x3e\n\x3cp\x3e看到这里，你可能会觉得 “GraphQL 很酷，Apollo 也很酷，但是我的后端是 REST，目前是与他们无缘了”。其实不然，从 Apollo Client 的 2.0 版本开始引入了 Apollo Link，理论上来说我们可以通过 GraphQL 从任何类型的数据源获取数据。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV48LZ?w=1552\x26amp;h=950\x22 src=\x22https:\/\/static.alili.tech\/img\/bV48LZ?w=1552\x26amp;h=950\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e“通过 GraphQL“ 意味着我们可以使用书写 GraphQL 的查询语句来获取无论是 rest api 或是 client state 中的数据，这样 Apollo Client 可以替我们管理应用中所有的数据，包括缓存和数据拼接。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const MIXED_QUERY = gql`\n    query UserInfo() {\n        \/\/ graphql endpoint\n        currentUser {\n            id\n            name\n        }\n        \/\/ client state\n        browserInfo @client {\n            platform\n        }\n        \/\/ rest api\n        messages @rest(route: \x27\/user\/messages\x27) @type(type: \x27[Message]\x27) {\n            title\n        }\n    }\n`;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MIXED_QUERY = gql\x3cspan class=\x22hljs-string\x22\x3e`\n    query UserInfo() {\n        \/\/ graphql endpoint\n        currentUser {\n            id\n            name\n        }\n        \/\/ client state\n        browserInfo @client {\n            platform\n        }\n        \/\/ rest api\n        messages @rest(route: \x27\/user\/messages\x27) @type(type: \x27[Message]\x27) {\n            title\n        }\n    }\n`\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这样一个 Query 查询中，我们使用 GraphQL 的 directive 拼接了来自于 GraphQL，rest，client state 中的数据，将它们抽象在一起维护。与之类似的，我们还可以封装相应的 mutation 实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e尾巴\x3c\/h2\x3e\n\x3cp\x3e以上大概就是我这段时间使用 Apollo 和 GraphQL 的一些浅浅的实践。虽然接触的不深，但我可以感受到 Thinking in GraphQL 为前端带来的更优雅的解决方式，和 Apollo Client 这样一个完整的前端数据层解决方案的高效。我相信在 2018 年，它们会迎来更大的增长，甚至有代替 redux 成为通用数据管理方案的可能。\x3c\/p\x3e\n\x3cp\x3eApollo 相关的社区也比较活跃，在 \x3ca\x3edev-blog.apollodata.com\x3c\/a\x3e 上也经常发表一些很有参考价值的文章，有兴趣可以随便看看~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>还在用 Redux，要不要试试 GraphQL 和 Apollo？</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013579354">https://segmentfault.com/a/1190000013579354</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hz02a1jaqpp/" target="_blank">https://alili.tech/archive/hz02a1jaqpp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>