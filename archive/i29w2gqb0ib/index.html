<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue2 &#43; koa2 &#43; webpack4 的SSR之旅"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue2 &#43; koa2 &#43; webpack4 的SSR之旅 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/i29w2gqb0ib/",
				"appid": "1613049289050283", 
				"title": "vue2 &#43; koa2 &#43; webpack4 的SSR之旅 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/y6pkk9sgqcm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bm0bsj31bma/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&text=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&text=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&title=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&is_video=false&description=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&title=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&title=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&title=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi29w2gqb0ib%2f&title=vue2%20%2b%20koa2%20%2b%20webpack4%20%e7%9a%84SSR%e4%b9%8b%e6%97%85"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue2 &#43; koa2 &#43; webpack4 的SSR之旅</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e因为自己的博客完全的前后端分离写的，在 \x3ccode\x3eseo\x3c\/code\x3e 这一块也没考虑过，于是乎，便开始了本次的\x3ccode\x3eSSR\x3c\/code\x3e之旅\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e技术栈\x3c\/h2\x3e\n\x3cp\x3evue2 \x2b koa2 \x2b webpack4 \x2b mongodb\x3c\/p\x3e\n\x3cp\x3e因为webpack也已经到了 \x3ccode\x3e4.1\x3c\/code\x3e 的版本了，所以顺带把\x3ccode\x3ewebpack3\x3c\/code\x3e迁移到了\x3ccode\x3ewebpack4\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e服务端渲染（SSR）\x3c\/h2\x3e\n\x3cp\x3e大概意思就是在服务端生成\x3ccode\x3ehtml\x3c\/code\x3e片段，然后返回给客户端\x3c\/p\x3e\n\x3cp\x3e所以\x3ccode\x3evue-ssr\x3c\/code\x3e也可以理解为就是把我们以前在客户端写的 \x3ccode\x3e.vue\x3c\/code\x3e文件 转换成 \x3ccode\x3ehtml\x3c\/code\x3e片段，返回给客户端。\x3c\/p\x3e\n\x3cp\x3e实际上当然是会复杂点，比如服务端 返回 \x3ccode\x3ehtml\x3c\/code\x3e 片段，客户端直接接受显示，不做任何操作的话，我们是无法触发事件（点击事件等等）的。\x3cbr\x3e为了解决上述问题。\x3cbr\x3e所以 你通过 \x3ca href=\x22https:\/\/ssr.vuejs.org\/zh\/api.html#webpack-plugins\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-server-renderer\x3c\/a\x3e 进行渲染的话， 会在根节点上附带一个 \x3ccode\x3edata-server-rendered=\x22true\x22\x3c\/code\x3e 的特殊属性。\x3cbr\x3e让客户端 \x3ccode\x3eVue\x3c\/code\x3e 知道这部分 \x3ccode\x3eHTML\x3c\/code\x3e 是由 \x3ccode\x3eVue\x3c\/code\x3e 在服务端渲染的，并且应该以激活模式进行挂载\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e激活模式:\x3c\/strong\x3e指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。\x3cbr\x3e大概意思就是 服务端 已经渲染好了 \x3ccode\x3ehtml\x3c\/code\x3e， 只不过服务端渲染过来的是静态页面，无法操作\x3ccode\x3eDOM\x3c\/code\x3e 。\x3cbr\x3e但是因为\x3ccode\x3edom\x3c\/code\x3e元素已经生成好了， 没有必要丢弃重新创建。\x3cbr\x3e所以客户端便只需要激活这些静态页面，让他们变成动态的（能够响应后续的数据变化）就行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\n\x3ccode\x3eSSR\x3c\/code\x3e优势\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\x3c\/li\x3e\n\x3cli\x3e更快的内容到达时间(time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\n\x3ccode\x3eSSR\x3c\/code\x3e开发需要注意的问题\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e服务端渲染只会执行 \x3ccode\x3evue\x3c\/code\x3e 的两个钩子函数 \x3ccode\x3ebeforeCreate \x3c\/code\x3e 和 \x3ccode\x3ecreated\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e服务端渲染无法访问 \x3ccode\x3ewindow \x3c\/code\x3e 和 \x3ccode\x3edocument\x3c\/code\x3e等只有浏览器才有的全局对象。（假如你项目里面有全局引入的插件和JS文件或着在\x3ccode\x3ebeforeCreate\x3c\/code\x3e和\x3ccode\x3ecreated\x3c\/code\x3e 用到了的这些对象的话，是会报错的，因为服务端不存在这些对象。实在要用的话，可以试下这个插件\x3ca href=\x22https:\/\/www.npmjs.com\/package\/jsdom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejsdom\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e基本上只要你对\x3ccode\x3enode\x3c\/code\x3e有了解，会配置\x3ccode\x3ewebpack\x3c\/code\x3e，\x3ccode\x3evue\x3c\/code\x3e能正常使用，基本上这东西实现起来还是比较轻松的，尤其官网给出了完整的例子\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-hackernews-2.0\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHackerNews Demo\x3c\/a\x3e,当然这个是基于\x3ccode\x3eexpress\x3c\/code\x3e框架的，使用\x3ccode\x3ekoa\x3c\/code\x3e的话里面中间件的使用需要做点修改。其余的基本只需要跟着官网的例子来一遍就基本OK了\x3cbr\x3e上面官网的例子需要终端翻墙才能访问数据，如果不想的话可以看下这个例子，跟官网例子基本一样\x3ca href=\x22https:\/\/github.com\/tiodot\/vnews\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e掘金网站\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e这里也大概说下官网的实现\x3c\/h3\x3e\n\x3ch4\x3e项目目录\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22src\n├── components\n│   ├── Foo.vue\n│   ├── Bar.vue\n│   └── Baz.vue\n├── router\n│   └── index.js\n├── store\n│   └── index.js\n├── App.vue\n├── app.js # universal entry\n├── entry-client.js # 运行于客户端的项目入口\n└── entry-server.js # 运行于服务端的项目入口\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3esrc\n├── components\n│   ├── Foo.vue\n│   ├── \x3cspan class=\x22hljs-keyword\x22\x3eBar.vue\n\x3c\/span\x3e│   └── \x3cspan class=\x22hljs-keyword\x22\x3eBaz.vue\n\x3c\/span\x3e├── router\n│   └── index.\x3cspan class=\x22hljs-keyword\x22\x3ejs\n\x3c\/span\x3e├── store\n│   └── index.\x3cspan class=\x22hljs-keyword\x22\x3ejs\n\x3c\/span\x3e├── App.vue\n├── app.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e# universal entry\x3c\/span\x3e\n├── entry-client.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 运行于客户端的项目入口\x3c\/span\x3e\n└── entry-server.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 运行于服务端的项目入口\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e需要用到几个知识点\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3evuex\x3c\/code\x3e的使用，因为应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。所以会使用的\x3ccode\x3evuex\x3c\/code\x3e来作为 数据预取存储容器\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3easyncData\x3c\/code\x3e自定义函数（获取接口数据）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ctemplate\x3e\n  \x3cdiv\x3e\x22{{\x22 item.title \x22}}\x22\x3c\/div\x3e\n\x3c\/template\x3e\n\x3cscript\x3e\nexport default {\n  \/\/ 自定义获取数据的函数。\n  asyncData ({ store, route }) {\n    \/\/ 触发 action 后，会返回 Promise\n    return store.dispatch(\x27fetchItem\x27, route.params.id)\n  },\n  computed: {\n    \/\/ 从 store 的 state 对象中的获取 item。\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  }\n}\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs django\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22 item.title \x22}}\x22\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义获取数据的函数。\x3c\/span\x3e\n  asyncData ({ store, route }) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发 action 后，会返回 Promise\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e store.dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27fetchItem\x27\x3c\/span\x3e, route.params.id)\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3ecomputed\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从 store 的 state 对象中的获取 item。\x3c\/span\x3e\n    item () {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.state.items[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$route.params.id]\n    }\n  }\n}\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e避免状态单例：\x3cbr\x3e  当编写纯客户端(client-only)代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。\x3cbr\x3e  所以我们为每个请求创建一个新的根 Vue 实例\x3cbr\x3e  因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ router.js\nimport Vue from \x27vue\x27\nimport Router from \x27vue-router\x27\nVue.use(Router)\nexport function createRouter () {\n  return new Router({\n    mode: \x27history\x27,\n    routes: [\n      \/\/ ...\n    ]\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ router.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Router \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue-router\x27\x3c\/span\x3e\nVue.use(Router)\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateRouter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Router({\n    \x3cspan class=\x22hljs-attr\x22\x3emode\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eroutes\x3c\/span\x3e: [\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    ]\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ store.js\nimport Vue from \x27vue\x27\nimport Vuex from \x27vuex\x27\nVue.use(Vuex)\n\/\/ 假定我们有一个可以返回 Promise 的\n\/\/ 通用 API（请忽略此 API 具体实现细节）\nimport { fetchItem } from \x27.\/api\x27\nexport function createStore () {\n  return new Vuex.Store({\n    state: {\n      items: {}\n    },\n    actions: {\n      fetchItem ({ commit }, id) {\n        \/\/ `store.dispatch()` 会返回 Promise，\n        \/\/ 以便我们能够知道数据在何时更新\n        return fetchItem(id).then(item =\x3e {\n          commit(\x27setItem\x27, { id, item })\n        })\n      }\n    },\n    mutations: {\n      setItem (state, { id, item }) {\n        Vue.set(state.items, id, item)\n      }\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ store.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vuex \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex\x27\x3c\/span\x3e\nVue.use(Vuex)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 假定我们有一个可以返回 Promise 的\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通用 API（请忽略此 API 具体实现细节）\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { fetchItem } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/api\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateStore\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vuex.Store({\n    \x3cspan class=\x22hljs-attr\x22\x3estate\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3eitems\x3c\/span\x3e: {}\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eactions\x3c\/span\x3e: {\n      fetchItem ({ commit }, id) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ `store.dispatch()` 会返回 Promise，\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以便我们能够知道数据在何时更新\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetchItem(id).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          commit(\x3cspan class=\x22hljs-string\x22\x3e\x27setItem\x27\x3c\/span\x3e, { id, item })\n        })\n      }\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3emutations\x3c\/span\x3e: {\n      setItem (state, { id, item }) {\n        Vue.set(state.items, id, item)\n      }\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ app.js\nimport Vue from \x27vue\x27\nimport App from \x27.\/App.vue\x27\nimport { createRouter } from \x27.\/router\x27\nimport { createStore } from \x27.\/store\x27\nexport function createApp () {\n  \/\/ 创建 router 和 store 实例\n  const router = createRouter()\n  const store = createStore()\n  \/\/ 创建应用程序实例，将 router 和 store 注入\n  const app = new Vue({\n    router,\n    store,\n    render: h =\x3e h(App)\n  })\n  \/\/ 暴露 app, router 和 store。\n  return { app, router, store }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ app.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createRouter } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/router\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createStore } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateApp\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建 router 和 store 实例\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e router = createRouter()\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore()\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建应用程序实例，将 router 和 store 注入\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    router,\n    store,\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eh\x3c\/span\x3e =\x26gt;\x3c\/span\x3e h(App)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 暴露 app, router 和 store。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { app, router, store }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {createApp} from \x27.\/app\x27\nconst {app, router, store} = createApp()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {createApp} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {app, router, store} = createApp()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按照上面的步骤方法，为每个请求创建新的应用实例，就不会因为多个请求造成 交叉请求状态污染(cross-request state pollution) 了\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e实现步骤\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e首先,获取当前访问的路径,因为\x3ccode\x3erenderToString\x3c\/code\x3e支持传入一个上下文的渲染对象，所以我们传入一个context对象，包含当前的\x3ccode\x3eurl\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ server.js \nconst context = {\n    url: ctx.url\n}\nrenderer.renderToString(context, (err, html) =\x3e {\n    if (err) {\n        return reject(err)\n    }\n    console.log(html)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ server.js \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e context = {\n    url: ctx.url\n}\nrenderer.renderToString(context, (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e, html) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e reject(\x3cspan class=\x22hljs-keyword\x22\x3eerr\x3c\/span\x3e)\n    }\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(html)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e然后中间经过webpack等配置，能让服务端的项目入口\x3ccode\x3eentry-server.js\x3c\/code\x3e接收到context\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ entry-server.js\nimport {createApp} from \x27.\/app\x27\nexport default context =\x3e {\n    \/\/ 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise.\n    return new Promise((resolve, reject) =\x3e {\n        const { app, router, store } = createApp()\n\n        const { url } = context\n\n        \/\/ 设置服务器端 router 的位置\n        router.push(url)\n\n        \/\/ 等到 router 将可能的异步组件和钩子函数解析完\n        router.onReady(() =\x3e {\n\n            \/\/ 获取当前路径的组件\n            const matchedComponents = router.getMatchedComponents()\n\n            \/\/ 没有返回404\n            if (!matchedComponents.length) {\n                return reject({ code: 404 })\n            }\n\n            \/\/ 如果该路径存在，而且该路径存在需要调用接口来预取数据的情况，便等所有`asyncData`函数执行完毕.\n            \/\/ `asyncData`函数是组件自定义静态函数, 用来提前获取数据。\n            Promise.all(matchedComponents.map( ({asyncData}) =\x3e asyncData \x26amp;\x26amp; asyncData({\n                store,\n                route: router.currentRoute\n            }))).then( () =\x3e {\n                \/\/ 执行完毕后，因为获取到的数据都统一存入 vuex 中， 上方 `asyncData` 里面执行的方法就是调用 vuex 的 action, 然后把数据存入的 vuex 的 state 中\n                \/\/ 所以我们便 store 里面的 state 赋值给 `context.state`\n                \/\/ 然后 `renderToString` 解析 html 的时候会把 `context.state` 里面的数据 嵌入到 html 的 `window.__INITIAL_STATE__` 变量中 \n                \/\/ 这样我们到时候处理 客户端 的时候，便可以把客户端中 vuex 中的state 替换成 `window.__INITIAL_STATE__` 中的数据,来完成客户端与服务端的数据统一\n                context.state = store.state\n                resolve(app)\n            }).catch(reject)\n        })\n    })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ entry-server.js\nimport {createApp} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x27.\/app\x27\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e context =\x26gt; {\n    \/\/ 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise.\n    return new Promise((resolve, reject) =\x26gt; {\n        const { app, router, store } = createApp()\n\n        const { url } = context\n\n        \/\/ 设置服务器端 router 的位置\n        router.push(url)\n\n        \/\/ 等到 router 将可能的异步组件和钩子函数解析完\n        router.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3eReady(() =\x26gt; {\n\n            \/\/ 获取当前路径的组件\n            const matchedComponents = router.getMatchedComponents()\n\n            \/\/ 没有返回\x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e\n            if (!matchedComponents.length) {\n                return reject({ code: \x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e })\n            }\n\n            \/\/ 如果该路径存在，而且该路径存在需要调用接口来预取数据的情况，便等所有`asyncData`函数执行完毕.\n            \/\/ `asyncData`函数是组件自定义静态函数, 用来提前获取数据。\n            Promise.\x3cspan class=\x22hljs-literal\x22\x3eall\x3c\/span\x3e(matchedComponents.map( ({asyncData}) =\x26gt; asyncData \x26amp;\x26amp; asyncData({\n                store,\n                route: router.currentRoute\n            }))).then( () =\x26gt; {\n                \/\/ 执行完毕后，因为获取到的数据都统一存入 vuex 中， 上方 `asyncData` 里面执行的方法就是调用 vuex 的 action, 然后把数据存入的 vuex 的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 中\n                \/\/ 所以我们便 store 里面的 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 赋值给 `context.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e`\n                \/\/ 然后 `renderToString` 解析 html 的时候会把 `context.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e` 里面的数据 嵌入到 html 的 `window.__INITIAL_STATE__` 变量中 \n                \/\/ 这样我们到时候处理 客户端 的时候，便可以把客户端中 vuex 中的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 替换成 `window.__INITIAL_STATE__` 中的数据,来完成客户端与服务端的数据统一\n                context.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = store.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n                resolve(app)\n            }).catch(reject)\n        })\n    })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e上面把我们当前访问路径的组件解析完成返回给客户端，客户端激活这些静态的html，因为我们服务端生成 html 获取数据是通过 \x3ccode\x3easyncData\x3c\/code\x3e 函数，但是我们只有第一次请求服务端需要渲染，以后再进行页面切换的时候不需要进行渲染的，但是 接口的调用 又放入了 \x3ccode\x3easyncData\x3c\/code\x3e 函数中，所以页面切换的时候，我们客户都需要处理 \x3ccode\x3easyncData\x3c\/code\x3e 函数，以前我们一般把数据放入 \x3ccode\x3ecreated\x3c\/code\x3e 钩子函数中，现在放入的时\x3ccode\x3easyncData\x3c\/code\x3e里面，所以我们进行客户端切换的时候，需要执行它。获取数据\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {createApp} from \x27.\/app\x27\nconst {app, router, store} = createApp()\n\n\/\/ 把store中的state 替换成 window.__INITIAL_STATE__ 中的数据\nif (window.__INITIAL_STATE__) {\n    store.replaceState(window.__INITIAL_STATE__)\n}\n\nrouter.onReady(() =\x3e {\n    \/\/ 添加路由钩子函数，用于处理 asyncData.\n    \/\/ 在初始路由 resolve 后执行，\n    \/\/ 以便我们不会二次预取(double-fetch)已有的数据。\n    \/\/ 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。\n    router.beforeResolve((to, from, next) =\x3e {\n        const matched = router.getMatchedComponents(to)\n        const prevMatched = router.getMatchedComponents(from)\n\n        \/\/ 我们只关心之前没有渲染的组件\n        \/\/ 所以我们对比它们，找出两个匹配列表的差异组件\n        let diffed = false\n        const activated = matched.filter((c, i) =\x3e {\n            return diffed || (diffed = (prevMatched[i] !== c))\n        })\n\n        const asyncDataHooks = activated.map(c =\x3e c.asyncData).filter(_ =\x3e _)\n        if (!asyncDataHooks.length) {\n            return next()\n        }\n\n        \/\/ 这里如果有加载指示器(loading indicator)，就触发\n        Promise.all(asyncDataHooks.map(hook =\x3e hook({ store, route: to })))\n            .then(() =\x3e {\n                \/\/ 停止加载指示器(loading indicator)\n                next()\n            })\n            .catch(next)\n    })\n    \n    \/\/ 挂载到根节点上\n    app.$mount(\x27#app\x27)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {createApp} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {app, router, store} = createApp()\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把store中的state 替换成 window.__INITIAL_STATE__ 中的数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__INITIAL_STATE__) {\n    store.replaceState(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__INITIAL_STATE__)\n}\n\nrouter.onReady(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加路由钩子函数，用于处理 asyncData.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在初始路由 resolve 后执行，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以便我们不会二次预取(double-fetch)已有的数据。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。\x3c\/span\x3e\n    router.beforeResolve(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eto, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e, next\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e matched = router.getMatchedComponents(to)\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevMatched = router.getMatchedComponents(\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e)\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们只关心之前没有渲染的组件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所以我们对比它们，找出两个匹配列表的差异组件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e diffed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e activated = matched.filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ec, i\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e diffed || (diffed = (prevMatched[i] !== c))\n        })\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e asyncDataHooks = activated.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ec\x3c\/span\x3e =\x26gt;\x3c\/span\x3e c.asyncData).filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e_\x3c\/span\x3e =\x26gt;\x3c\/span\x3e _)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!asyncDataHooks.length) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next()\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里如果有加载指示器(loading indicator)，就触发\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(asyncDataHooks.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ehook\x3c\/span\x3e =\x26gt;\x3c\/span\x3e hook({ store, \x3cspan class=\x22hljs-attr\x22\x3eroute\x3c\/span\x3e: to })))\n            .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 停止加载指示器(loading indicator)\x3c\/span\x3e\n                next()\n            })\n            .catch(next)\n    })\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挂载到根节点上\x3c\/span\x3e\n    app.$mount(\x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e基本上这样就实现了\x3ccode\x3evue-ssr\x3c\/code\x3e的过程,具体源码及配置可以在我的 \x3ca href=\x22https:\/\/github.com\/cd-dongzi\/vue2-koa2-ssr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e 查看。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ewebpack4\x3c\/h3\x3e\n\x3cp\x3e最明显的点 是 \x3ccode\x3ewebpack4\x3c\/code\x3e 以后拥有默认值了，简单配置一下便能使用\x3cbr\x3e以下是默认值：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eentry 的默认值是 .\/src\x3c\/li\x3e\n\x3cli\x3eoutput.path 的默认值是 .\/dist\x3c\/li\x3e\n\x3cli\x3emode 的默认值是 production\x3c\/li\x3e\n\x3cli\x3eUglifyJs 插件默认开启 caches 和 parallizes\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在 mode 为 develoment 时：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e开启 output.pathinfo\x3c\/li\x3e\n\x3cli\x3e关闭 optimization.minimize\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在 mode 为 production 时：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e关闭 in-memory caching\x3c\/li\x3e\n\x3cli\x3e开启 NoEmitOnErrorsPlugin\x3c\/li\x3e\n\x3cli\x3e开启 ModuleConcatenationPlugin\x3c\/li\x3e\n\x3cli\x3e开启 optimization.minimize\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e因为给自己博客做\x3ccode\x3essr\x3c\/code\x3e的通知也升级了webpack,接下来便看下 迁移至 \x3ccode\x3ewebpack4\x3c\/code\x3e 需要修改的部分 \x3ccode\x3ewebpack\x3c\/code\x3e 配置\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e将CLI移入到 \x3ccode\x3ewebpack-cli\x3c\/code\x3e 中，需要安装 \x3ccode\x3ewebpack-cli\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e通过设置 \x3ccode\x3emode\x3c\/code\x3e 变量来确定当前模式, 不配置会有警告\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e命令行中配置 \x3ccode\x3ewebpack --mode development\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e文件中配置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n    mode: \x27development\x27,\n    entry: {\n      app: resolve(\x27src\x27)\n    },\n    ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.exports = {\n    mode: \x3cspan class=\x22hljs-string\x22\x3e\x27development\x27\x3c\/span\x3e,\n    entry: {\n      app: resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27src\x27\x3c\/span\x3e)\n    },\n    ...\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ewebpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3ewebpack4\x3c\/code\x3e不再提供 \x3ccode\x3ewebpack.optimize.CommonsChunkPlugin\x3c\/code\x3e 来分割代码，需要用到新的属性 \x3ccode\x3eoptimization.splitChunks\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n```\noutput: {\n  filename: assetsPath(\x27js\/[name].[chunkhash].min.js\x27),\n},\noptimization: {\n  runtimeChunk: {\n      name: \x26quot;manifest\x26quot;\n  },\n  splitChunks: {\n    chunks: \x26quot;initial\x26quot;,         \/\/ 必须三选一： \x26quot;initial\x26quot; | \x26quot;all\x26quot;(默认就是all) | \x26quot;async\x26quot;\n    minSize: 0,                \/\/ 最小尺寸，默认0\n    minChunks: 1,              \/\/ 最小 chunk ，默认1\n    maxAsyncRequests: 1,       \/\/ 最大异步请求数， 默认1\n    maxInitialRequests: 1,    \/\/ 最大初始化请求书，默认1\n    name: () =\x3e {},              \/\/ 名称，此选项课接收 function\n    cacheGroups: {                 \/\/ 这里开始设置缓存的 chunks\n      priority: \x26quot;0\x26quot;,                \/\/ 缓存组优先级 false | object |\n      vendor: {                   \/\/ key 为entry中定义的 入口名称\n        chunks: \x26quot;initial\x26quot;,        \/\/ 必须三选一： \x26quot;initial\x26quot; | \x26quot;all\x26quot; | \x26quot;async\x26quot;(默认就是异步)\n        test: \/react|lodash\/,     \/\/ 正则规则验证，如果符合就提取 chunk\n        name: \x26quot;vendor\x26quot;,           \/\/ 要缓存的 分隔出来的 chunk 名称\n        minSize: 0,\n        minChunks: 1,\n        enforce: true,\n        maxAsyncRequests: 1,       \/\/ 最大异步请求数， 默认1\n        maxInitialRequests: 1,    \/\/ 最大初始化请求书，默认1\n        reuseExistingChunk: true   \/\/ 可设置是否重用该chunk（查看源码没有发现默认值）\n      }\n    }\n  }\n},\n...\n```\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-string\x22\x3e```\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3eoutput:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  filename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eassetsPath(\x27js\/[name].[chunkhash].min.js\x27),\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3eoptimization:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  runtimeChunk:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22manifest\x22\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  splitChunks:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    chunks:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22initial\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e         \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e必须三选一：\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22initial\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e| \x22all\x22(默认就是all) | \x22async\x22\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e    minSize:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e                \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最小尺寸，默认0\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    minChunks:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e              \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最小\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3echunk\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e，默认1\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    maxAsyncRequests:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e       \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最大异步请求数，\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e默认1\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    maxInitialRequests:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e    \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最大初始化请求书，默认1\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e()\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{},\x3c\/span\x3e              \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e名称，此选项课接收\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3efunction\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    cacheGroups:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e                 \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e这里开始设置缓存的\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3echunks\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e      priority:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x220\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e                \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e缓存组优先级\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e| object |\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e      vendor:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e                   \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ekey\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e为entry中定义的\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e入口名称\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        chunks:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22initial\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e        \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e必须三选一：\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22initial\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e| \x22all\x22 | \x22async\x22(默认就是异步)\n\x3c\/span\x3e\x3cspan class=\x22hljs-attr\x22\x3e        test:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/react|lodash\/,\x3c\/span\x3e     \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e正则规则验证，如果符合就提取\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3echunk\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22vendor\x22\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e           \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e要缓存的\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e分隔出来的\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3echunk\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e名称\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        minSize:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        minChunks:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        enforce:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        maxAsyncRequests:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e       \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最大异步请求数，\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e默认1\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        maxInitialRequests:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e    \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e最大初始化请求书，默认1\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e        reuseExistingChunk:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e   \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e可设置是否重用该chunk（查看源码没有发现默认值）\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e...\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e```\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3ecompilation.mainTemplate.applyPluginsWaterfall is not a function\x3c\/code\x3e\x3cp\x3e解决方案： \x3ccode\x3eyarn add webpack-contrib\/html-webpack-plugin -D\x3c\/code\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eUse Chunks.groupsIterable and filter by instanceof Entrypoint instead:\x3c\/code\x3e\x3cp\x3e解决方案： \x3ccode\x3eyarn add extract-text-webpack-plugin@next -D\x3c\/code\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e升级\x3ccode\x3ewebpack4\x3c\/code\x3e也遇到了几个问题\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e设置 \x3ccode\x3eoptimization.splitChunks\x3c\/code\x3e 打包。分别会打包 \x3ccode\x3ejs\x3c\/code\x3e、\x3ccode\x3ecss\x3c\/code\x3e 各一份， 不知道啥情况。\x3c\/li\x3e\n\x3cli\x3e升级4以后，我用 \x3ccode\x3eDllPlugin\x3c\/code\x3e打包， 但是 verdon 打包出来还是一样大，并不会把 我指定的 模块提取出来。\x3c\/li\x3e\n\x3cli\x3eimport 做按需加载好像不生效。 例如：\x3ccode\x3econst _import_ = file =\x26gt; () =\x26gt; import(file \x2b \x27.vue\x27)\x3c\/code\x3e, 然后通过 \x3ccode\x3e_import_(\x27components\/Foo\x27)\x3c\/code\x3e 便能直接按需加载, 但是\x3ccode\x3ewebpack4\x3c\/code\x3e就没生效，都是一次性加载出来的。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e上面是我们升级4遇到的几个问题，可能是我配置方面出错了，但是\x3ccode\x3ewebpack4\x3c\/code\x3e 以前都是正常的。\x3cbr\x3e具体我这边的配置放到了 \x3ca href=\x22https:\/\/github.com\/cd-dongzi\/vue2-koa2-ssr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e 上。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e以上就是我这次\x3ca href=\x22http:\/\/dzblog.cn\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e个人博客\x3c\/a\x3e的 \x3ccode\x3eSSR\x3c\/code\x3e 之旅。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ca href=\x22https:\/\/github.com\/cd-dongzi\/vue2-koa2-ssr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e\x3cp\x3e\x3ca href=\x22http:\/\/dzblog.cn\/article\/5ab7ba453aa2533986893133\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e博客地址\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue2 + koa2 + webpack4 的SSR之旅</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013983061">https://segmentfault.com/a/1190000013983061</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/i29w2gqb0ib/" target="_blank">https://alili.tech/archive/i29w2gqb0ib/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>