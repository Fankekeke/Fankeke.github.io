<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="如何更好的编写async函数"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>如何更好的编写async函数 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ij1r28zenha/",
				"appid": "1613049289050283", 
				"title": "如何更好的编写async函数 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-01T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7rgz4kb5cci/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2gx1nts7zsj/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&text=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&text=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&title=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&is_video=false&description=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&title=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&title=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&title=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij1r28zenha%2f&title=%e5%a6%82%e4%bd%95%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bc%96%e5%86%99async%e5%87%bd%e6%95%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">如何更好的编写async函数</h1><div class="meta"><div class="postdate"><time datetime="2018-12-01" itemprop="datePublished">2018-12-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e2018年已经到了5月份，\x3ccode\x3enode\x3c\/code\x3e的\x3ccode\x3e4.x\x3c\/code\x3e版本也已经停止了维护  \x3cbr\x3e我司的某个服务也已经切到了\x3ccode\x3e8.x\x3c\/code\x3e，目前正在做\x3ccode\x3ekoa2.x\x3c\/code\x3e的迁移  \x3cbr\x3e将之前的\x3ccode\x3egenerator\x3c\/code\x3e全部替换为\x3ccode\x3easync\x3c\/code\x3e  \x3cbr\x3e但是，在替换的过程中，发现一些滥用\x3ccode\x3easync\x3c\/code\x3e导致的时间上的浪费\x3cbr\x3e所以来谈一下，如何优化\x3ccode\x3easync\x3c\/code\x3e代码，更充分的利用异步事件流 \x3cstrong\x3e杜绝滥用async\x3c\/strong\x3e\n\x3c\/blockquote\x3e\n\x3ch2\x3e首先，你需要了解Promise\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ePromise\x3c\/code\x3e是使用\x3ccode\x3easync\x3c\/code\x3e\/\x3ccode\x3eawait\x3c\/code\x3e的基础，所以你一定要先了解\x3ccode\x3ePromise\x3c\/code\x3e是做什么的   \x3cbr\x3e\x3ccode\x3ePromise\x3c\/code\x3e是帮助解决回调地狱的一个好东西，能够让异步流程变得更清晰。  \x3cbr\x3e一个简单的\x3ccode\x3eError-first-callback\x3c\/code\x3e转换为\x3ccode\x3ePromise\x3c\/code\x3e的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3econst fs = require(\x27fs\x27)\n\nfunction readFile (fileName) {\n  return new Promise((resolve, reject) =\x26gt; {\n    fs.readFile(fileName, (err, data) =\x26gt; {\n      if (err) reject(err)\n\n      resolve(data)\n    })\n  })\n}\n\nreadFile(\x27test.log\x27).then(data =\x26gt; {\n  console.log(\x27get data\x27)\n}, err =\x26gt; {\n  console.error(err)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们调用函数返回一个\x3ccode\x3ePromise\x3c\/code\x3e的实例，在实例化的过程中进行文件的读取，当文件读取的回调触发式，进行\x3ccode\x3ePromise\x3c\/code\x3e状态的变更，\x3ccode\x3eresolved\x3c\/code\x3e或者\x3ccode\x3erejected\x3c\/code\x3e  \x3cbr\x3e状态的变更我们使用\x3ccode\x3ethen\x3c\/code\x3e来监听，第一个回调为\x3ccode\x3eresolve\x3c\/code\x3e的处理，第二个回调为\x3ccode\x3ereject\x3c\/code\x3e的处理。\x3c\/p\x3e\n\x3ch2\x3easync与Promise的关系\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3easync\x3c\/code\x3e函数相当于一个简写的返回\x3ccode\x3ePromise\x3c\/code\x3e实例的函数，效果如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efunction getNumber () {\n  return new Promise((resolve, reject) =\x26gt; {\n    resolve(1)\n  })\n}\n\/\/ =\x26gt;\nasync function getNumber () {\n  return 1\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两者在使用上方式上完全一样，都可以在调用\x3ccode\x3egetNumber\x3c\/code\x3e函数后使用\x3ccode\x3ethen\x3c\/code\x3e进行监听返回值。\x3cbr\x3e以及与\x3ccode\x3easync\x3c\/code\x3e对应的\x3ccode\x3eawait\x3c\/code\x3e语法的使用方式：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3egetNumber().then(data =\x26gt; {\n  \/\/ got data\n})\n\/\/ =\x26gt;\nlet data = await getNumber()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eawait\x3c\/code\x3e的执行会获取表达式后边的\x3ccode\x3ePromise\x3c\/code\x3e执行结果，相当于我们调用\x3ccode\x3ethen\x3c\/code\x3e获取回调结果一样。\x3cbr\x3e\x3cem\x3eP.S. 在\x3ccode\x3easync\x3c\/code\x3e\/\x3ccode\x3eawait\x3c\/code\x3e支持度还不是很高的时候，大家都会选择使用\x3ccode\x3egenerator\x3c\/code\x3e\/\x3ccode\x3eyield\x3c\/code\x3e结合着一些类似于\x3ccode\x3eco\x3c\/code\x3e的库来实现类似的效果\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2\x3easync函数代码执行是同步的，结果返回是异步的\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3easync\x3c\/code\x3e函数总是会返回一个\x3ccode\x3ePromise\x3c\/code\x3e的实例 \x3cstrong\x3e这点儿很重要\x3c\/strong\x3e  \x3cbr\x3e所以说调用一个\x3ccode\x3easync\x3c\/code\x3e函数时，可以理解为里边的代码都是处于\x3ccode\x3enew Promise\x3c\/code\x3e中，所以是同步执行的  \x3cbr\x3e而最后\x3ccode\x3ereturn\x3c\/code\x3e的操作，则相当于在\x3ccode\x3ePromise\x3c\/code\x3e中调用\x3ccode\x3eresolve\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function getNumber () {\n  console.log(\x27call getNumber()\x27)\n\n  return 1\n}\n\ngetNumber().then(_ =\x26gt; console.log(\x27resolved\x27))\nconsole.log(\x27done\x27)\n\n\/\/ 输出顺序：\n\/\/ call getNumber()\n\/\/ done\n\/\/ resolved\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3ePromise内部的Promise会被消化\x3c\/h2\x3e\n\x3cp\x3e也就是说，如果我们有如下的代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efunction getNumber () {\n  return new Promise(resolve =\x26gt; {\n    resolve(Promise.resolve(1))\n  })\n}\n\ngetNumber().then(data =\x26gt; console.log(data)) \/\/ 1\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果按照上边说的话，我们在\x3ccode\x3ethen\x3c\/code\x3e里边获取到的\x3ccode\x3edata\x3c\/code\x3e应该是传入\x3ccode\x3eresolve\x3c\/code\x3e中的值  ，也就是另一个\x3ccode\x3ePromise\x3c\/code\x3e的实例。  \x3cbr\x3e但实际上，我们会直接获得返回值：\x3ccode\x3e1\x3c\/code\x3e，也就是说，如果在\x3ccode\x3ePromise\x3c\/code\x3e中返回一个\x3ccode\x3ePromise\x3c\/code\x3e，实际上程序会帮我们执行这个\x3ccode\x3ePromise\x3c\/code\x3e，并在内部的\x3ccode\x3ePromise\x3c\/code\x3e状态改变时触发\x3ccode\x3ethen\x3c\/code\x3e之类的回调。  \x3cbr\x3e一个有意思的事情：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efunction getNumber () {\n  return new Promise(resolve =\x26gt; {\n    resolve(Promise.reject(new Error(\x27Test\x27)))\n  })\n}\n\ngetNumber().catch(err =\x26gt; console.error(err)) \/\/ Error: Test\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们在\x3ccode\x3eresolve\x3c\/code\x3e中传入了一个\x3ccode\x3ereject\x3c\/code\x3e，则我们在外部则可以直接使用\x3ccode\x3ecatch\x3c\/code\x3e监听到。  \x3cbr\x3e\x3cstrong\x3e这种方式经常用于在\x3ccode\x3easync\x3c\/code\x3e函数中抛出异常\x3c\/strong\x3e\x3cbr\x3e如何在\x3ccode\x3easync\x3c\/code\x3e函数中抛出异常：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function getNumber () {\n  return Promise.reject(new Error(\x27Test\x27))\n}\ntry {\n  let number = await getNumber()\n} catch (e) {\n  console.error(e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e一定不要忘了await关键字\x3c\/h2\x3e\n\x3cp\x3e如果忘记添加\x3ccode\x3eawait\x3c\/code\x3e关键字，代码层面并不会报错，但是我们接收到的返回值却是一个\x3ccode\x3ePromise\x3c\/code\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3elet number = getNumber()\nconsole.log(number) \/\/ Promise\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以在使用时一定要切记\x3ccode\x3eawait\x3c\/code\x3e关键字\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3elet number = await getNumber()\nconsole.log(number) \/\/ 1\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e不是所有的地方都需要添加await\x3c\/h2\x3e\n\x3cp\x3e在代码的执行过程中，有时候，并不是所有的异步都要添加\x3ccode\x3eawait\x3c\/code\x3e的。\x3cbr\x3e比如下边的对文件的操作：  \x3cbr\x3e\x3cem\x3e我们假设\x3ccode\x3efs\x3c\/code\x3e所有的API都被我们转换为了\x3ccode\x3ePromise\x3c\/code\x3e版本\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function writeFile () {\n  let fd = await fs.open(\x27test.log\x27)\n  fs.write(fd, \x27hello\x27)\n  fs.write(fd, \x27world\x27)\n  return fs.close(fd)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cem\x3e就像上边说的，Promise内部的Promise会被消化，所以我们在最后的\x3ccode\x3eclose\x3c\/code\x3e也没有使用\x3ccode\x3eawait\x3c\/code\x3e\x3c\/em\x3e\x3cbr\x3e我们通过\x3ccode\x3eawait\x3c\/code\x3e打开一个文件，然后进行两次文件的写入。  \x3cbr\x3e但是注意了，在两次文件的写入操作前边，我们并没有添加\x3ccode\x3eawait\x3c\/code\x3e关键字。  \x3cbr\x3e因为这是多余的，我们只需要通知API，我要往这个文件里边写入一行文本，顺序自然会由\x3ccode\x3efs\x3c\/code\x3e来控制 。  \x3cbr\x3e最后再进行\x3ccode\x3eclose\x3c\/code\x3e，因为如果我们上边在执行写入的过程还没有完成时，\x3ccode\x3eclose\x3c\/code\x3e的回调是不会触发的，  \x3cbr\x3e也就是说，回调的触发就意味着上边两步的\x3ccode\x3ewrite\x3c\/code\x3e已经执行完成了。\x3c\/p\x3e\n\x3ch2\x3e合并多个不相干的async函数调用\x3c\/h2\x3e\n\x3cp\x3e如果我们现在要获取一个用户的头像和用户的详细信息（而这是两个接口 \x3cem\x3e虽说一般情况下不太会出现\x3c\/em\x3e）\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function getUser () {\n  let avatar = await getAvatar()\n  let userInfo = await getUserInfo()\n\n  return {\n    avatar,\n    userInfo\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的代码就造成了一个问题，我们获取用户信息的接口并不依赖于头像接口的返回值。  \x3cbr\x3e但是这样的代码却会在获取到头像以后才会去发送获取用户信息的请求。  \x3cbr\x3e所以我们对这种代码可以这样处理：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function getUser () {\n  let [avatar, userInfo] = await Promise.all([getAvatar(), getUserInfo()])\n\n  return {\n    avatar,\n    userInfo\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的修改就会让\x3ccode\x3egetAvatar\x3c\/code\x3e与\x3ccode\x3egetUserInfo\x3c\/code\x3e内部的代码同时执行，同时发送两个请求，在外层通过包一层\x3ccode\x3ePromise.all\x3c\/code\x3e来确保两者都返回结果。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e让相互没有依赖关系的异步函数同时执行\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2\x3e一些循环中的注意事项\x3c\/h2\x3e\n\x3ch3\x3eforEach\x3c\/h3\x3e\n\x3cp\x3e当我们调用这样的代码时：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3easync function getUsersInfo () {\n  [1, 2, 3].forEach(async uid =\x26gt; {\n    console.log(await getUserInfo(uid))\n  })\n}\n\nfunction getuserInfo (uid) {\n  return new Promise(resolve =\x26gt; {\n    setTimeout(_ =\x26gt; resolve(uid), 1000)\n  })\n}\n\nawait getUsersInfo()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的执行好像并没有什么问题，我们也会得到\x3ccode\x3e1\x3c\/code\x3e、\x3ccode\x3e2\x3c\/code\x3e、\x3ccode\x3e3\x3c\/code\x3e三条\x3ccode\x3elog\x3c\/code\x3e的输出，  \x3cbr\x3e但是当我们在\x3ccode\x3eawait getUsersInfo()\x3c\/code\x3e下边再添加一条\x3ccode\x3econsole.log(\x27done\x27)\x3c\/code\x3e的话，就会发现：  \x3cbr\x3e我们会先得到\x3ccode\x3edone\x3c\/code\x3e，然后才是三条\x3ccode\x3euid\x3c\/code\x3e的\x3ccode\x3elog\x3c\/code\x3e，也就是说，\x3ccode\x3egetUsersInfo\x3c\/code\x3e返回结果时，其实内部\x3ccode\x3ePromise\x3c\/code\x3e并没有执行完。  \x3cbr\x3e这是因为\x3ccode\x3eforEach\x3c\/code\x3e并不会关心回调函数的返回值是什么，它只是运行回调。\x3c\/p\x3e\n\x3ch3\x3e不要在普通的for、while循环中使用await\x3c\/h3\x3e\n\x3cp\x3e使用普通的\x3ccode\x3efor\x3c\/code\x3e、\x3ccode\x3ewhile\x3c\/code\x3e循环会导致程序变为串行：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efor (let uid of [1, 2, 3]) {\n  let result = await getUserInfo(uid)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的代码运行，会在拿到\x3ccode\x3euid: 1\x3c\/code\x3e的数据后才会去请求\x3ccode\x3euid: 2\x3c\/code\x3e的数据\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3\x3e关于这两种问题的解决方案：\x3c\/h3\x3e\n\x3cp\x3e目前最优的就是将其替换为\x3ccode\x3emap\x3c\/code\x3e结合着\x3ccode\x3ePromise.all\x3c\/code\x3e来实现：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3eawait Promise.all([1, 2, 3].map(async uid =\x26gt; await getUserInfo(uid)))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的代码实现会同时实例化三个\x3ccode\x3ePromise\x3c\/code\x3e，并请求\x3ccode\x3egetUserInfo\x3c\/code\x3e\x3c\/p\x3e\n\x3ch4\x3eP.S. 草案中有一个\x3ccode\x3eawait*\x3c\/code\x3e，可以省去\x3ccode\x3ePromise.all\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3eawait* [1, 2, 3].map(async uid =\x26gt; await getUserInfo(uid))\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eP.S. 为什么在使用\x3ccode\x3eGenerator\x3c\/code\x3e\x2b\x3ccode\x3eco\x3c\/code\x3e时没有这个问题\x3c\/h4\x3e\n\x3cp\x3e在使用\x3ccode\x3ekoa1.x\x3c\/code\x3e的时候，我们直接写\x3ccode\x3eyield [].map\x3c\/code\x3e是不会出现上述所说的串行问题的  \x3cbr\x3e看过\x3ccode\x3eco\x3c\/code\x3e源码的小伙伴应该都明白，里边有这么两个函数（删除了其余不相关的代码）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3efunction toPromise(obj) {\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  return obj;\n}\n\nfunction arrayToPromise(obj) {\n  return Promise.all(obj.map(toPromise, this));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eco\x3c\/code\x3e是帮助我们添加了\x3ccode\x3ePromise.all\x3c\/code\x3e的处理的（膜拜TJ大佬）。\x3c\/p\x3e\n\x3ch2\x3e总结\x3c\/h2\x3e\n\x3cp\x3e总结一下关于\x3ccode\x3easync\x3c\/code\x3e函数编写的几个小提示：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用\x3ccode\x3ereturn Promise.reject()\x3c\/code\x3e在\x3ccode\x3easync\x3c\/code\x3e函数中抛出异常\x3c\/li\x3e\n\x3cli\x3e让相互之间没有依赖关系的异步函数同时执行\x3c\/li\x3e\n\x3cli\x3e不要在循环的回调中\/\x3ccode\x3efor\x3c\/code\x3e、\x3ccode\x3ewhile\x3c\/code\x3e循环中使用\x3ccode\x3eawait\x3c\/code\x3e，用\x3ccode\x3emap\x3c\/code\x3e来代替它\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2\x3e参考资料\x3c\/h2\x3e\n\x3col\x3e\x3cli\x3e\x3ca href=\x22http:\/\/2ality.com\/2016\/10\/async-function-tips.html\x22 rel=\x22nofollow noreferrer\x22\x3easync-function-tips\x3c\/a\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cblockquote\x3e本人GitHub： \x3ca href=\x22https:\/\/github.com\/Jiasm\x22 rel=\x22nofollow noreferrer\x22\x3ejiasm\x3c\/a\x3e \x3cem\x3e欢迎小伙伴们follow、交流\x3c\/em\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>如何更好的编写async函数</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014836153">https://segmentfault.com/a/1190000014836153</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ij1r28zenha/" target="_blank">https://alili.tech/archive/ij1r28zenha/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>