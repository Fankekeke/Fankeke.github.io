<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅谈JavaScript面向对象"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅谈JavaScript面向对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/j04k6czqw7f/",
				"appid": "1613049289050283", 
				"title": "浅谈JavaScript面向对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-28T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7v0zhpnqnmh/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/s383xr0h49d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&text=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&text=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&title=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&is_video=false&description=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&title=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&title=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&title=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj04k6czqw7f%2f&title=%e6%b5%85%e8%b0%88JavaScript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅谈JavaScript面向对象</h1><div class="meta"><div class="postdate"><time datetime="2018-12-28" itemprop="datePublished">2018-12-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e对象(Object)应该算是js中最为重要的部分，也是js中非常难懂晦涩的一部分。更是面试以及框架设计中各出没。写这篇文章，主要参考与JavaScript红宝书（JavaScript高级程序设计 第六章章节）以及各大博主博客。\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/Nealyang\/YOU-SHOULD-KNOW-JS\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文地址:https:\/\/github.com\/Nealyang\/YOU-SHOULD-KNOW-JS\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e谈谈对象属性的特性\x3c\/h2\x3e\n\x3cp\x3e毕竟是面向对象编程，我们在讨论如何面向对象之前先讨论讨论对象具有哪些属性和特性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e属性类型\x3c\/h3\x3e\n\x3cp\x3e简单的说，对象拥有四个属性:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e Configurable \x3c\/code\x3e:是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e Enumerable \x3c\/code\x3e:枚举性，表示是否可以通过for-in循环返回\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e Writable \x3c\/code\x3e:可写性：是否可以修改属性的值\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e Value \x3c\/code\x3e:包含属性的值，也就是对应的可读性。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上四个对象的属性的属性类型默认值分别为：true,true,true,undefined。\x3c\/p\x3e\n\x3cp\x3e如果要修改属性默认的特性，必须通过Object.defineProperty()方法。大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var animal = {};\nObject.defineProperty(animal,\x26quot;name\x26quot;,{\n    writable:false,\n    value: \x27dog\x27;\n});\nconsole.log(animal.name);\/\/dog\nanimal.name = \x27cat\x27;\nconsole.log(animal.name);\/\/dog\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3evar animal = {};\nObject.defineProperty(animal,\x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e,{\n    writable:\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    value: \x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e;\n});\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(animal.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/dog\x3c\/span\x3e\nanimal.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e;\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(animal.\x3cspan class=\x22hljs-built_in\x22\x3ename\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/dog\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的实例大家也能看出，在调用Object.defineProperty()方法后，如果不指定 configurable、enumerable、writable 特性的值时，默认为FALSE。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e访问器属性\x3c\/h3\x3e\n\x3cp\x3e访问器属性不包含数据值，但是包含getter和setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效值。在写入访问器属性时，回到用setter函数并传入新值。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eConfigurable\x3c\/code\x3e:表示是否可以通过delete删除。默认为TRUE\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eEnumerable\x3c\/code\x3e:同上面介绍的Enumerable一样，默认为true\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eGet\x3c\/code\x3e:读取数据时候调用的方法。默认为undefined\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eSet\x3c\/code\x3e:在写入属性值得时候默认调用的方法。默认为undefined\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里不做过多解释，直接看例子吧（来自js红宝书）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var book = {\n    _year:2012,\n    edition:1\n};\nObject.defineProperty(book, \x27year\x27,{\n    get:function(){\n        return this._year\n    },\n    set:function(value){\n        if(value\x3e2012){\n            this._year = value,\n            this.edition\x2b\x2b\n        }\n    }\n});\n\nbook.year = 2013;\nconsole.log(book.edition);\/\/2\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e book = {\n    _year:\x3cspan class=\x22hljs-number\x22\x3e2012\x3c\/span\x3e,\n    edition:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n};\nObject.defineProperty(book, \x3cspan class=\x22hljs-string\x22\x3e\x27year\x27\x3c\/span\x3e,{\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._year\n    },\n    \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(value)\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(value\x26gt;\x3cspan class=\x22hljs-number\x22\x3e2012\x3c\/span\x3e){\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._year = value,\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edition\x2b\x2b\n        }\n    }\n});\n\nbook.year = \x3cspan class=\x22hljs-number\x22\x3e2013\x3c\/span\x3e;\nconsole.log(book.edition);\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实对于多个属性的定义，我们可以使用Object.defineProperties方法。然后对于读取属性的特性我们可以使用Object.getOwnPropertyDescriptor()方法。大家自行查看哈。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e创建对象\x3c\/h2\x3e\n\x3cp\x3e创建对象，我们不是直接可以通过Object的构造函数或者对象字面量的方法来实现对象的创建嘛？当然，这些方法是可以的，但是有一个明显的缺点：使用同一个接口创建很多对象，产生大量重复的代码。所以这里，我们使用如下的一些骚操作\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e工厂模式\x3c\/h3\x3e\n\x3cp\x3e一种很基础的设计模式，简而言之就是用函数来封装以特定接口创建对象的细节。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createAnimal(name,type){\n    var o = new Object();\n    o.name = name;\n    o.type = type;\n    o.sayName = function(){\n        alert(this.name)\n    }\n    return o;\n}\nvar cat = createAnimal(\x27小猫\x27,\x27cat\x27);\nvar dog = createAnimal(\x27小?\x27,\x27dog\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,type\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\n    o.name = name;\n    o.type = type;\n    o.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e o;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cat = createAnimal(\x3cspan class=\x22hljs-string\x22\x3e\x27小猫\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dog = createAnimal(\x3cspan class=\x22hljs-string\x22\x3e\x27小?\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e优点：可以无数次的调用这个函数，来创建相似对象。\x3cbr\x3e缺点：不能解决对象识别的问题。也就是说，我不知道你是谁家的b孩子\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e构造函数模式\x3c\/h3\x3e\n\x3cp\x3eECMAScript中的构造函数可以用来创建特定类型的对象。在运行时会自动出现在执行环境中（这句话后面讲解this的时候还是会说到）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name,type){\n    this.name = name;\n    this.type = type;\n    this.say = function(){\n        alert(this.name);\n    }\n}\n\nvar cat = new Animal(\x27小猫\x27,\x27cat\x27);\nvar dog = new Animal(\x27小?\x27,\x27dog\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,type)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x27小猫\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dog = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x27小?\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意上面我们没有显示的return过一个对象出来，为什么？因为this（后面会讲this的）。\x3c\/p\x3e\n\x3cp\x3e关于构造函数惯例首字母大写就不啰嗦了。强调构造函数一定要使用关键字new来调用。为什么使用new呢？因为你使用了new，他会\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e创建一个新的对象\x3c\/li\x3e\n\x3cli\x3e将构造函数的作用域赋值给新对象（this执行新的对象）\x3c\/li\x3e\n\x3cli\x3e执行构造函数的代码\x3c\/li\x3e\n\x3cli\x3e返回新的对象\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那么解决了工厂模式的诟病了么？当然~\x3c\/p\x3e\n\x3cp\x3e在实例对象中，都有一个constructor属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat.constructor == Animal \/\/true\ndog.constructor == Animal \/\/true\ncat instanceof Animal \/\/true\ndog instanceof Animal \/\/true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ecat\x3cspan class=\x22hljs-selector-class\x22\x3e.constructor\x3c\/span\x3e == Animal \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\ndog\x3cspan class=\x22hljs-selector-class\x22\x3e.constructor\x3c\/span\x3e == Animal \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\ncat instanceof Animal \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\ndog instanceof Animal \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数模式的优点如上所说，但是缺点还是有的，比如说\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cat.sayName == dog.sayName \/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ecat.sayName == dog.sayName \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说，他创建了两个功能一样的函数，这样是很没有必要的，当然，我们可以把sayName放到构造函数外面，然后通过this.sayName=sayName来操作，但是这样的话，又会导致全局变量的污染。肿么办？？？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e原型模式\x3c\/h3\x3e\n\x3cp\x3e我们在创建每一个函数的时候都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象。而这个对象的用途就是包含由特定类型的所有实例共享的属性和方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal() {}\nAnimal.prototype.name = \x27毛毛\x27;\nAnimal.prototype.type = \x27dog\x27;\nAnimal.prototype.sayName = function() {\n  alert(this.name);\n}\nvar cat = new Animal();\nvar dog = new Animal();\nalert(cat.sayName == dog.sayName)\/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\nAnimal.prototype.name = \x3cspan class=\x22hljs-string\x22\x3e\x27毛毛\x27\x3c\/span\x3e;\nAnimal.prototype.type = \x3cspan class=\x22hljs-string\x22\x3e\x27dog\x27\x3c\/span\x3e;\nAnimal.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dog = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal();\nalert(cat.sayName == dog.sayName)\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型模式的好处就是可以让所有的对象实例共享他的属性和方法。不必在构造函数中定义对象实例的信息。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person() {}\nPerson.prototype.name = \x27Nealyang\x27;\nPerson.prototype.age = 24;\nPerson.prototype.sayName = function(){\n  alert(this.name);\n}\nvar neal = new Person();\nconsole.log(neal.name)\/\/\x27Nealyang\x27 -\x3e 来自原型\nneal.name = \x27Neal\x27;\nconsole.log(neal.name)\/\/ Neal -\x3e 来自实例\n\ndelete neal.name;\nconsole.log(neal.name)\/\/\x27Nealyang\x27 -\x3e 来自原型\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\nPerson.prototype.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Nealyang\x27\x3c\/span\x3e;\nPerson.prototype.age = \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e;\nPerson.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e neal = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(neal.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27Nealyang\x27 -\x26gt; 来自原型\x3c\/span\x3e\nneal.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Neal\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(neal.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Neal -\x26gt; 来自实例\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e neal.name;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(neal.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27Nealyang\x27 -\x26gt; 来自原型\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子说明两点\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e原型中的对象属性可以被实例所覆盖重写\x3c\/li\x3e\n\x3cli\x3e通过delete可以删除实例中的属性，但是删除不了对象上的\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e我们可以通过hasOwnProperty()方法来确定一个属性是在原型上还是在实例上。person1.hasOwnProperty(\x27name\x27),如果name为实例属性，则返回true。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我们也可以通过 \x27name\x27 in person1 来确定，person1上是否有name这个属性。\x3c\/p\x3e\n\x3cp\x3e上面大家可能已将发现，这种原型模式的写法非常的繁琐，有了大量的XXX.prototype. 这里有一种简写的形式。\x3cbr\x3e参照具体说明参照\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2010\/05\/object-oriented_javascript_inheritance.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮神的博客 面向对象第二篇\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\nPerson.prototype = {\n    constructor:Person,\n    name:\x26quot;Neal\x26quot;,\n    age:24,\n    job:\x27Software Engineer\x27,\n    sayName:function(){\n        alert(this.name);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e:Person,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22Neal\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27Software Engineer\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码特意添加了一个constructor属性，因为每创建一个函数，就会自动创建他的prototype对象，这个对象会自动获取contractor属性。而我们这中写法，本质上重写了默认的prototype对象，因此，constructor属性也就变成新的对象的constructor属性了（指向Object构造函数），所以这里的简写方式，一定要加上constructor。\x3c\/p\x3e\n\x3cp\x3e下面我们再谈一谈原型模式的优缺点。\x3c\/p\x3e\n\x3cp\x3e优点，正如上面我们说到的，可以省略为构造函数传递出实话参数这个环节，并且很多实例可以共享属性和方法。正是因为原型中所有的属性是被所有的实例所共享的，这个特性在方法中非常实用，但是对于包含引用类型的属性来说问题就比较突出了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){};\n\nPerson.prototype = {\n    constructor:Person,\n    name:\x26quot;neal\x26quot;,\n    friends:[\x27xiaohong\x27,\x27xiaoming\x27],\n    sayName:function(){\n        alert(this.name);\n    }\n}\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\x27xiaohua\x27);\n\nalert(person1.friends);\/\/\x27xiaohong\x27,\x27xiaoming\x27,\x27xiaohua\x27\nalert(person2.friends);\/\/\x27xiaohong\x27,\x27xiaoming\x27,\x27xiaohua\x27\nalert(person1.friends == person2.friends)\/\/true\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};\n\nPerson.prototype = {\n    constructor:Person,\n    name:\x3cspan class=\x22hljs-string\x22\x3e\x22neal\x22\x3c\/span\x3e,\n    friends:[\x3cspan class=\x22hljs-string\x22\x3e\x27xiaohong\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27xiaoming\x27\x3c\/span\x3e],\n    sayName:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nperson1.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x27xiaohua\x27\x3c\/span\x3e);\n\nalert(person1.friends);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27xiaohong\x27,\x27xiaoming\x27,\x27xiaohua\x27\x3c\/span\x3e\nalert(person2.friends);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27xiaohong\x27,\x27xiaoming\x27,\x27xiaohua\x27\x3c\/span\x3e\nalert(person1.friends == person2.friends)\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于friends数组存在于Person.prototype上，并不是person1上面，所以当我们修改的时候，其实修改的是所有实例所共享的那个值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e组合使用构造函数和原型模式\x3c\/h3\x3e\n\x3cp\x3e这是创建自定义类型最常见的一种方式。就是组合使用构造函数和原型模式.构造函数模式用于定义实力属性，原型模式用于定义方法和共享的属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name,age){\n    this.name = name,\n    this.age = age\n}\n\nPerson.prototype = {\n    constructor:Person,\n    sayName:function(){\n        alert(this.name);\n    }\n}\n\nvar person1 = new Person(\x27Neal\x27,24);\nvar person2 = new Person(\x27Yang\x27,23);\n...\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,age)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name,\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age\n}\n\nPerson.prototype = {\n    constructor:Person,\n    sayName:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27Neal\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27Yang\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e);\n...\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子中，实例所有的属性都是在构造函数中定义，而实例所有共享的属性和方法都是在原型中定义。这种构造函数和原型模式混合的模式，是目前ECMAScript中使用最为广泛的一种方法。\x3c\/p\x3e\n\x3cp\x3e当然，有些人会觉得独立的构造函数和原型非常的难受，所以也有推出所谓的动态原型构造模式的这么一说。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name,age){\n    this.name = name,\n    this.age = age,\n    if(typeof this.sayName != \x27function\x27){\n        Person.prototype.sayName = function(){\n            console.log(this.name)\n        }\n    }\n}\n...\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name,\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age,\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sayName != \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n        Person.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n        }\n    }\n}\n...\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意上面的代码，之后在sayName不存在的时候，才会在原型上给他添加相应的方法。因为对原型的修改，能够立即在所有的实例中得到反应。所以这中做法确实也是非常的完美。\x3c\/p\x3e\n\x3cp\x3e关于javaScript高程中说到的别的寄生构造函数模式和稳妥构造函数模式大家可以自行查看哈～这里就不做过多介绍了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e继承\x3c\/h2\x3e\n\x3cp\x3e说到面向对象，当然得说到继承。说到继承当然得说到原型。说到原型，这里我们摘自\x3ca href=\x22https:\/\/www.ibm.com\/developerworks\/cn\/web\/1304_zengyz_jsoo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e网上一篇博客里的段落\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e为了说明javascript是一门面向对象的语言，首先有必要从面相对象的概念入手1、一切事物皆对象。2、对象具有封装和继承特性。3、对象与对象之间使用消息通信，各自存在信息隐秘 。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3ejavascript语言是通过一种叫做原型(prototype) 的方式来实现面向对象编程的。当然，还有比如java就是基于类来实现面向对象编程的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e基于类的面向对象和基于原型的面向对象方式比价\x3c\/h3\x3e\n\x3cp\x3e对于基于类的面向对象的方式中，对象依靠class类来产生。而在基于原型的面向对象方式中，对象则是依靠构造器(constructor)利用原型(prototype)构造出来的。举个客观世界的例子来说，例如工厂造一辆汽车一方面，工人必须参照一张工程图纸，设计规定这辆车如何制造，这里的工程图纸就好比语言中的类class。而车就是按照这个类制造出来的。另一方面，工人和机器相当于contractor，利用各种零部件(prototype)将汽车造出来。\x3c\/p\x3e\n\x3cp\x3e当然，对于上面的例子两种思维各种说法。当然，笔者更加倾向于基于原型的面向对象编程，毕竟我是前端出生（咳咳，真相了），正当理由如下：\x3c\/p\x3e\n\x3cp\x3e首先，客观世界中的对象的产生都是其他实物对象构造的世界，而抽象的图纸是不能产生出汽车的。也就是说，类，是一个抽象概念的而非实体，而对象的产生是一个实体的产生。其次，按照一切事物皆对象的这饿极本的面向对象的法则来说，类本身并不是一个对象，然而原型方式的构造函数和原型本身也是个对象。再次，在类的面向对象语言中，对象的状态又对象的实例所持有，对象的行为方法则由申明该对象的类所持有，并且只有对象的构造和方法能够被继承。而在原型的面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e原型链\x3c\/h3\x3e\n\x3cp\x3eECMAScript描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。\x3c\/p\x3e\n\x3cp\x3e实现原型链有一种基本模式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType(){\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType (){\n    this.subproperty = false;\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubValue = function(){\n    return this.subproperty;\n}\n\nvar instance = new SubType();\n\nalert(instance.getSuperValue());\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.property = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\nSuperType.prototype.getSuperValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.property;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subproperty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\nSubType.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SuperType();\n\nSubType.prototype.getSubValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subproperty;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType();\n\nalert(instance.getSuperValue());\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新的原型，这个新原型就是SuperType的实例。于是，新原型不仅具有所谓一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType的原型。最终结果是这样的：instance指向subtype的原型，subtype的原型又指向SuperType的原型。\x3c\/p\x3e\n\x3cp\x3e通过实现原型链，本质上是扩展了原型搜索机制。\x3c\/p\x3e\n\x3cp\x3e虽然如上，我们已经实现了javascript中的继承。但是依旧存在一些问题：最主要的问题来自包含引用类型的原型。第二个问题就是在创建子类型的实例时，不能向超类型的构造函数中传递参数。这两个问题上面也都有说到，这里就不做过多介绍，直接看解决办法！\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e借用构造函数\x3c\/h3\x3e\n\x3cp\x3e在解决原型中包含引用类型的数据时，我们可以在子类型构造函数内部调用超类型的构造函数。直接看代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType(name){\n    this.colors = [\x27red\x27,\x27yellow\x27];\n    this.name = name;\n}\n\nfunction SubType(name){\n    \/\/继承了Super\n    SuperType.call(this,name)\n}\n\nvar instance1 = new SubType(\x27Neal\x27);\nalert(instance1.name)\ninstance1.colors.push(\x27black\x27);\nalert(instance1.colors);\/\/\x27red\x27,\x27yellow\x27,\x27black\x27\n\nvar instance2 = new SubType(\x27yang\x27);\nalert(instance2.colors);\/\/\x27red\x27,\x27yellow\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27yellow\x27\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承了Super\x3c\/span\x3e\n    SuperType.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x27Neal\x27\x3c\/span\x3e);\nalert(instance1.name)\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e);\nalert(instance1.colors);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27red\x27,\x27yellow\x27,\x27black\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x27yang\x27\x3c\/span\x3e);\nalert(instance2.colors);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27red\x27,\x27yellow\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e毕竟函数只不过是在特定环境中执行代码的对象，因此可以通过call活着apply方法在新创建的对象上执行构造函数。而且如上代码也解决了子类构造函数中向超类构造函数传递参数的问题\x3c\/p\x3e\n\x3cp\x3e但是，这样问题就来了，类似我们之前讨论创建的对象那种构造函数的问题：如果都是使用构造函数，那么，也就避免不了方法都在构造函数中定义，然后就会产生大量重复的代码了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e组合继承\x3c\/h3\x3e\n\x3cp\x3e因为考虑到上述的缺点，所以这里又使用了组合继承的方式，历史总是惊人的相似。直接看代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType(name){\n    this.name = name;\n    this.colors = [\x27red\x27,\x27yellow\x27];\n}\n\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\n\nfunction SubType(name,age){\n    \/\/继承属性\n    SuperType.call(this,name);\n\n    this.age = age;\n}\n\n\/\/继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){\n    alert(this.age);\n}\n\nvar instance1 = new SubType(\x27Nealyang\x27,24);\ninstance1.colors.push(\x27white\x27);\ninstance1.sayName();\/\/Nealyang\ninstance1.sayAge();\/\/ 24\n\nvar instance2 = new SubType(\x27Neal\x27,21);\nalert(instance2.colors);\/\/\x27red\x27,\x27yellow\x27\ninstance2.sayName();\/\/Neal\ninstance2.sayAge();\/\/21\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27yellow\x27\x3c\/span\x3e];\n}\n\nSuperType.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,age)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承属性\x3c\/span\x3e\n    SuperType.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/继承方法\x3c\/span\x3e\nSubType.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x27Nealyang\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e);\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e);\ninstance1.sayName();\x3cspan class=\x22hljs-comment\x22\x3e\/\/Nealyang\x3c\/span\x3e\ninstance1.sayAge();\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 24\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x27Neal\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e);\nalert(instance2.colors);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27red\x27,\x27yellow\x27\x3c\/span\x3e\ninstance2.sayName();\x3cspan class=\x22hljs-comment\x22\x3e\/\/Neal\x3c\/span\x3e\ninstance2.sayAge();\x3cspan class=\x22hljs-comment\x22\x3e\/\/21\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的例子中，SuperType构造函数定义了两个属性，name和colors，SuperType的原型中定义了一个方法sayName，subtype的构造函数中调用SuperType构造函数并且传入name，然后将SuperType的实例赋值给subtype的原型。然后又在新的原型中定义了sayAge的方法。这样一来，就可以让两个不同的SubType实例既分别拥有自己的属性，包括colors，又可以使用相同的方法了。\x3c\/p\x3e\n\x3cp\x3e组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点。成为javascript中最为常见的继承模式。而且instanceof和isPrototypeOf方法也能用于识别组合模式创建的对象。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e别的继承模式\x3c\/h3\x3e\n\x3cp\x3e继承模式是有很多，上面只是说到我们经常使用到的继承模式。包括还有原型式继承、寄生式继承、寄生组合式继承等，其实，只要理解了原型、原型链、构造函数等对象的基本概念，理解起来这中模式都是非常容易的。后续如果有时间，再给大家总结吧～\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e交流\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e扫码关注我的个人微信公众号，分享更多原创文章。点击交流学习加我微信、qq群。一起学习，一起进步\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011708896?w=430\x26amp;h=430\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011708896?w=430\x26amp;h=430\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e欢迎兄弟们加入：\x3c\/p\x3e\n\x3cp\x3eNode.js技术交流群：209530601 \x3c\/p\x3e\n\x3cp\x3eReact技术栈：398240621\x3c\/p\x3e\n\x3cp\x3e前端技术杂谈：604953717 (新建)\x3c\/p\x3e\n\x3chr\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅谈JavaScript面向对象</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011708891">https://segmentfault.com/a/1190000011708891</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/j04k6czqw7f/" target="_blank">https://alili.tech/archive/j04k6czqw7f/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>