<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从零开始实现一个React（三）：diff算法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从零开始实现一个React（三）：diff算法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/j88v2tayp3/",
				"appid": "1613049289050283", 
				"title": "从零开始实现一个React（三）：diff算法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-06T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/eyebhyhrekl/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1cem9n8aypf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&is_video=false&description=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj88v2tayp3%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9adiff%e7%ae%97%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从零开始实现一个React（三）：diff算法</h1><div class="meta"><div class="postdate"><time datetime="2018-12-06" itemprop="datePublished">2018-12-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e在\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上一篇文章\x3c\/a\x3e，我们已经实现了React的组件功能，从功能的角度来说已经实现了React的核心功能了。\x3c\/p\x3e\n\x3cp\x3e但是我们的实现方式有很大的问题：每次更新都重新渲染整个应用或者整个组件，DOM操作十分昂贵，这样性能损耗非常大。\x3c\/p\x3e\n\x3cp\x3e为了减少DOM更新，我们需要找渲染前后真正变化的部分，只更新这一部分DOM。而对比变化，找出需要更新部分的算法我们称之为\x3cstrong\x3ediff算法\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e对比策略\x3c\/h1\x3e\n\x3cp\x3e在前面两篇文章后，我们实现了一个render方法，它能将虚拟DOM渲染成真正的DOM，我们现在就需要改进它，让它不要再傻乎乎地重新渲染整个DOM树，而是找出真正变化的部分。\x3c\/p\x3e\n\x3cp\x3e这部分很多类React框架实现方式都不太一样，有的框架会选择保存上次渲染的虚拟DOM，然后对比虚拟DOM前后的变化，得到一系列更新的数据，然后再将这些更新应用到真正的DOM上。\x3c\/p\x3e\n\x3cp\x3e但也有一些框架会选择直接对比虚拟DOM和真实DOM，这样就不需要额外保存上一次渲染的虚拟DOM，并且能够一边对比一边更新，这也是我们选择的方式。\x3c\/p\x3e\n\x3cp\x3e不管是DOM还是虚拟DOM，它们的结构都是一棵树，完全对比两棵树变化的算法时间复杂度是O(n^3)，但是考虑到我们很少会跨层级移动DOM，所以我们只需要对比同一层级的变化。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVZtTx?w=377\x26amp;h=199\x22 src=\x22https:\/\/static.alili.tech\/img\/bVZtTx?w=377\x26amp;h=199\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e只需要对比同一颜色框内的节点\x3c\/p\x3e\n\x3cp\x3e总而言之，我们的diff算法有两个原则：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e对比当前真实的DOM和虚拟DOM，在对比过程中直接更新真实DOM\x3c\/li\x3e\n\x3cli\x3e只对比同一层级的变化\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e实现\x3c\/h1\x3e\n\x3cp\x3e我们需要实现一个diff方法，它的作用是对比真实DOM和虚拟DOM，最后返回更新后的DOM\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * @param {HTMLElement} dom 真实DOM\n * @param {vnode} vnode 虚拟DOM\n * @returns {HTMLElement} 更新后的DOM\n *\/\nfunction diff( dom, vnode ) {\n    \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * @param {HTMLElement} dom 真实DOM\n * @param {vnode} vnode 虚拟DOM\n * @returns {HTMLElement} 更新后的DOM\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediff\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e dom, vnode \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来就要实现这个方法。\x3cbr\x3e在这之前先来回忆一下我们虚拟DOM的结构:\x3cbr\x3e虚拟DOM的结构可以分为三种，分别表示文本、原生DOM节点以及组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 原生DOM节点的vnode\n{\n    tag: \x27div\x27,\n    attrs: {\n        className: \x27container\x27\n    },\n    children: []\n}\n\n\/\/ 文本节点的vnode\n\x26quot;hello,world\x26quot;\n\n\/\/ 组件的vnode\n{\n    tag: ComponentConstrucotr,\n    attrs: {\n        className: \x27container\x27\n    },\n    children: []\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原生DOM节点的vnode\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3etag\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eattrs\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27container\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: []\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文本节点的vnode\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x22hello,world\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 组件的vnode\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3etag\x3c\/span\x3e: ComponentConstrucotr,\n    \x3cspan class=\x22hljs-attr\x22\x3eattrs\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27container\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: []\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e对比文本节点\x3c\/h2\x3e\n\x3cp\x3e首先考虑最简单的文本节点，如果当前的DOM就是文本节点，则直接更新内容，否则就新建一个文本节点，并移除掉原来的DOM。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ diff text node\nif ( typeof vnode === \x27string\x27 ) {\n\n    \/\/ 如果当前的DOM就是文本节点，则直接更新内容\n    if ( dom \x26amp;\x26amp; dom.nodeType === 3 ) {    \/\/ nodeType: https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Node\/nodeType\n        if ( dom.textContent !== vnode ) {\n            dom.textContent = vnode;\n        }\n    \/\/ 如果DOM不是文本节点，则新建一个文本节点DOM，并移除掉原来的\n    } else {\n        out = document.createTextNode( vnode );\n        if ( dom \x26amp;\x26amp; dom.parentNode ) {\n            dom.parentNode.replaceChild( out, dom );\n        }\n    }\n\n    return out;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ diff text node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e vnode === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e ) {\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前的DOM就是文本节点，则直接更新内容\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( dom \x26amp;\x26amp; dom.nodeType === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e ) {    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nodeType: https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Node\/nodeType\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( dom.textContent !== vnode ) {\n            dom.textContent = vnode;\n        }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果DOM不是文本节点，则新建一个文本节点DOM，并移除掉原来的\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        out = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode( vnode );\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( dom \x26amp;\x26amp; dom.parentNode ) {\n            dom.parentNode.replaceChild( out, dom );\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e out;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e文本节点十分简单，它没有属性，也没有子元素，所以这一步结束后就可以直接返回结果了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e对比非文本DOM节点\x3c\/h2\x3e\n\x3cp\x3e如果vnode表示的是一个非文本的DOM节点，那就要分几种情况了：\x3cbr\x3e如果真实DOM和虚拟DOM的类型不同，例如当前真实DOM是一个div，而vnode的tag的值是\x27button\x27，那么原来的div就没有利用价值了，直接新建一个button元素，并将div的所有子节点移到button下，然后用replaceChild方法将div替换成button。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if ( !dom || dom.nodeName.toLowerCase() !== vnode.tag.toLowerCase() ) {\n    out = document.createElement( vnode.tag );\n\n    if ( dom ) {\n        [ ...dom.childNodes ].map( out.appendChild );    \/\/ 将原来的子节点移到新节点下\n\n        if ( dom.parentNode ) {\n            dom.parentNode.replaceChild( out, dom );    \/\/ 移除掉原来的DOM对象\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !dom || dom.nodeName.toLowerCase() !== vnode.tag.toLowerCase() ) {\n    out = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement( vnode.tag );\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( dom ) {\n        [ ...dom.childNodes ].map( out.appendChild );    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将原来的子节点移到新节点下\x3c\/span\x3e\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( dom.parentNode ) {\n            dom.parentNode.replaceChild( out, dom );    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除掉原来的DOM对象\x3c\/span\x3e\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果真实DOM和虚拟DOM是同一类型的，那我们暂时不需要做别的，只需要等待后面对比属性和对比子节点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e对比属性\x3c\/h2\x3e\n\x3cp\x3e实际上diff算法不仅仅是找出节点类型的变化，它还要找出来节点的属性以及事件监听的变化。我们将对比属性单独拿出来作为一个方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function diffAttributes( dom, vnode ) {\n\n    const old = dom.attributes;    \/\/ 当前DOM的属性\n    const attrs = vnode.attrs;     \/\/ 虚拟DOM的属性\n\n    \/\/ 如果原来的属性不在新的属性当中，则将其移除掉（属性值设为undefined）\n    for ( let name in old ) {\n\n        if ( !( name in attrs ) ) {\n            setAttribute( dom, name, undefined );\n        }\n\n    }\n\n    \/\/ 更新新的属性值\n    for ( let name in attrs ) {\n\n        if ( old[ name ] !== attrs[ name ] ) {\n            setAttribute( dom, name, attrs[ name ] );\n        }\n\n    }\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediffAttributes\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e dom, vnode \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e old = dom.attributes;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前DOM的属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e attrs = vnode.attrs;     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 虚拟DOM的属性\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果原来的属性不在新的属性当中，则将其移除掉（属性值设为undefined）\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e old ) {\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !( name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e attrs ) ) {\n            setAttribute( dom, name, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e );\n        }\n\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新新的属性值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e attrs ) {\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( old[ name ] !== attrs[ name ] ) {\n            setAttribute( dom, name, attrs[ name ] );\n        }\n\n    }\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esetAttribute方法的实现参见\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第一篇文章\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e对比子节点\x3c\/h2\x3e\n\x3cp\x3e节点本身对比完成了，接下来就是对比它的子节点。\x3cbr\x3e这里会面临一个问题，前面我们实现的不同diff方法，都是明确知道哪一个真实DOM和虚拟DOM对比，但是子节点是一个数组，它们可能改变了顺序，或者数量有所变化，我们很难确定要和虚拟DOM对比的是哪一个。\x3cbr\x3e为了简化逻辑，我们可以让用户提供一些线索：给节点设一个key值，重新渲染时对比key值相同的节点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ diff方法\nif ( vnode.children \x26amp;\x26amp; vnode.children.length \x3e 0 || ( out.childNodes \x26amp;\x26amp; out.childNodes.length \x3e 0 ) ) {\n    diffChildren( out, vnode.children );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ diff方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vnode.children \x26amp;\x26amp; vnode.children.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e || ( out.childNodes \x26amp;\x26amp; out.childNodes.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) ) {\n    diffChildren( out, vnode.children );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function diffChildren( dom, vchildren ) {\n\n    const domChildren = dom.childNodes;\n    const children = [];\n\n    const keyed = {};\n\n    \/\/ 将有key的节点和没有key的节点分开\n    if ( domChildren.length \x3e 0 ) {\n        for ( let i = 0; i \x3c domChildren.length; i\x2b\x2b ) {\n            const child = domChildren[ i ];\n            const key = child.key;\n            if ( key ) {\n                keyedLen\x2b\x2b;\n                keyed[ key ] = child;\n            } else {\n                children.push( child );\n            }\n        }\n    }\n\n    if ( vchildren \x26amp;\x26amp; vchildren.length \x3e 0 ) {\n\n        let min = 0;\n        let childrenLen = children.length;\n\n        for ( let i = 0; i \x3c vchildren.length; i\x2b\x2b ) {\n\n            const vchild = vchildren[ i ];\n            const key = vchild.key;\n            let child;\n\n            \/\/ 如果有key，找到对应key值的节点\n            if ( key ) {\n\n                if ( keyed[ key ] ) {\n                    child = keyed[ key ];\n                    keyed[ key ] = undefined;\n                }\n\n            \/\/ 如果没有key，则优先找类型相同的节点\n            } else if ( min \x3c childrenLen ) {\n\n                for ( let j = min; j \x3c childrenLen; j\x2b\x2b ) {\n\n                    let c = children[ j ];\n\n                    if ( c \x26amp;\x26amp; isSameNodeType( c, vchild ) ) {\n\n                        child = c;\n                        children[ j ] = undefined;\n\n                        if ( j === childrenLen - 1 ) childrenLen--;\n                        if ( j === min ) min\x2b\x2b;\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            \/\/ 对比\n            child = diff( child, vchild );\n\n            \/\/ 更新DOM\n            const f = domChildren[ i ];\n            if ( child \x26amp;\x26amp; child !== dom \x26amp;\x26amp; child !== f ) {\n                if ( !f ) {\n                    dom.appendChild(child);\n                } else if ( child === f.nextSibling ) {\n                    removeNode( f );\n                } else {\n                    dom.insertBefore( child, f );\n                }\n            }\n\n        }\n    }\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediffChildren\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e dom, vchildren \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e domChildren = dom.childNodes;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e children = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keyed = {};\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将有key的节点和没有key的节点分开\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( domChildren.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; domChildren.length; i\x2b\x2b ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e child = domChildren[ i ];\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key = child.key;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( key ) {\n                keyedLen\x2b\x2b;\n                keyed[ key ] = child;\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                children.push( child );\n            }\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vchildren \x26amp;\x26amp; vchildren.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) {\n\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e min = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childrenLen = children.length;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; vchildren.length; i\x2b\x2b ) {\n\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vchild = vchildren[ i ];\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key = vchild.key;\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e child;\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果有key，找到对应key值的节点\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( key ) {\n\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( keyed[ key ] ) {\n                    child = keyed[ key ];\n                    keyed[ key ] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;\n                }\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有key，则优先找类型相同的节点\x3c\/span\x3e\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( min \x26lt; childrenLen ) {\n\n                \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e j = min; j \x26lt; childrenLen; j\x2b\x2b ) {\n\n                    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e c = children[ j ];\n\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( c \x26amp;\x26amp; isSameNodeType( c, vchild ) ) {\n\n                        child = c;\n                        children[ j ] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;\n\n                        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( j === childrenLen - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ) childrenLen--;\n                        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( j === min ) min\x2b\x2b;\n                        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n\n                    }\n\n                }\n\n            }\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对比\x3c\/span\x3e\n            child = diff( child, vchild );\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新DOM\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e f = domChildren[ i ];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( child \x26amp;\x26amp; child !== dom \x26amp;\x26amp; child !== f ) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !f ) {\n                    dom.appendChild(child);\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( child === f.nextSibling ) {\n                    removeNode( f );\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                    dom.insertBefore( child, f );\n                }\n            }\n\n        }\n    }\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e对比组件\x3c\/h2\x3e\n\x3cp\x3e如果vnode是一个组件，我们也单独拿出来作为一个方法:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function diffComponent( dom, vnode ) {\n\n    let c = dom \x26amp;\x26amp; dom._component;\n    let oldDom = dom;\n\n    \/\/ 如果组件类型没有变化，则重新set props\n    if ( c \x26amp;\x26amp; c.constructor === vnode.tag ) {\n        setComponentProps( c, vnode.attrs );\n        dom = c.base;\n    \/\/ 如果组件类型变化，则移除掉原来组件，并渲染新的组件\n    } else {\n\n        if ( c ) {\n            unmountComponent( c );\n            oldDom = null;\n        }\n\n        c = createComponent( vnode.tag, vnode.attrs );\n\n        setComponentProps( c, vnode.attrs );\n        dom = c.base;\n\n        if ( oldDom \x26amp;\x26amp; dom !== oldDom ) {\n            oldDom._component = null;\n            removeNode( oldDom );\n        }\n\n    }\n\n    return dom;\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ediffComponent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e dom, vnode \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e c = dom \x26amp;\x26amp; dom._component;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldDom = dom;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果组件类型没有变化，则重新set props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( c \x26amp;\x26amp; c.constructor === vnode.tag ) {\n        setComponentProps( c, vnode.attrs );\n        dom = c.base;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果组件类型变化，则移除掉原来组件，并渲染新的组件\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( c ) {\n            unmountComponent( c );\n            oldDom = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n\n        c = createComponent( vnode.tag, vnode.attrs );\n\n        setComponentProps( c, vnode.attrs );\n        dom = c.base;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( oldDom \x26amp;\x26amp; dom !== oldDom ) {\n            oldDom._component = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            removeNode( oldDom );\n        }\n\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dom;\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面是相关的工具方法的实现，和\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上一篇文章\x3c\/a\x3e的实现相比，只需要修改renderComponent方法其中的一行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function renderComponent( component ) {\n    \n    \/\/ ...\n\n    \/\/ base = base = _render( renderer );          \/\/ 将_render改成diff\n    base = diff( component.base, renderer );\n\n    \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderComponent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e component \x3c\/span\x3e) \x3c\/span\x3e{\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ base = base = _render( renderer );          \/\/ 将_render改成diff\x3c\/span\x3e\n    base = diff( component.base, renderer );\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完整diff实现看\x3ca href=\x22https:\/\/github.com\/hujiulong\/simple-react\/blob\/chapter-3\/src\/react-dom\/diff.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这个文件\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e渲染\x3c\/h1\x3e\n\x3cp\x3e现在我们实现了diff方法，我们尝试渲染\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上一篇文章\x3c\/a\x3e中定义的Counter组件，来感受一下有无diff方法的不同。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Counter extends React.Component {\n    constructor( props ) {\n        super( props );\n        this.state = {\n            num: 1\n        }\n    }\n\n    onClick() {\n        this.setState( { num: this.state.num \x2b 1 } );\n    }\n\n    render() {\n        return (\n            \x3cdiv\x3e\n                \x3ch1\x3ecount: { this.state.num }\x3c\/h1\x3e\n                \x3cbutton onClick={ () =\x3e this.onClick()}\x3eadd\x3c\/button\x3e\n            \x3c\/div\x3e\n        );\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode class=\x22jsx\x22\x3eclass Counter extends React.Component {\n    constructor( props ) {\n        super( props );\n        this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {\n            num: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3eClick() {\n        this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState( { num: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.num \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e } );\n    }\n\n    render() {\n        return (\n            \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;h1\x26gt;\x3c\/span\x3ecount: { this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.num }\x26lt;\/h1\x26gt;\n                \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;button onClick={ () =\x26gt;\x3c\/span\x3e this.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3eClick()}\x26gt;add\x26lt;\/button\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e不使用diff\x3c\/h2\x3e\n\x3cp\x3e使用上一篇文章的实现，从chrome的调试工具中可以看到，闪烁的部分是每次更新的部分，每次点击按钮，都会重新渲染整个组件。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV7YLh?w=488\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/bV7YLh?w=488\x26amp;h=328\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e使用diff\x3c\/h2\x3e\n\x3cp\x3e而实现了diff方法后，每次点击按钮，都只会重新渲染变化的部分。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV7YLg?w=488\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/bV7YLg?w=488\x26amp;h=328\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader11\x22\x3e后话\x3c\/h1\x3e\n\x3cp\x3e在这篇文章中我们实现了diff算法，通过它做到了每次只更新需要更新的部分，极大地减少了DOM操作。React实现远比这个要复杂，特别是在React 16之后还引入了Fiber架构，但是主要的思想是一致的。\x3c\/p\x3e\n\x3cp\x3e实现diff算法可以说性能有了很大的提升，但是在别的地方仍然后很多改进的空间：每次调用setState后会立即调用renderComponent重新渲染组件，但现实情况是，我们可能会在极短的时间内多次调用setState。\x3cbr\x3e假设我们在上文的Counter组件中写出了这种代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22onClick() {\n    for ( let i = 0; i \x3c 100; i\x2b\x2b ) {\n        this.setState( { num: this.state.num \x2b 1 } );\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eonClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e; i\x2b\x2b ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState( { \x3cspan class=\x22hljs-attr\x22\x3enum\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.num \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e } );\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那以目前的实现，每次点击都会渲染100次组件，对性能肯定有很大的影响。\x3cbr\x3e下一篇文章我们就要来改进setState方法\x3c\/p\x3e\n\x3cp\x3e这篇文章的代码：\x3ca href=\x22https:\/\/github.com\/hujiulong\/simple-react\/tree\/chapter-3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hujiulong\/...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader12\x22\x3e从零开始实现React系列\x3c\/h1\x3e\n\x3cp\x3eReact是前端最受欢迎的框架之一，解读其源码的文章非常多，但是我想从另一个角度去解读React：从零开始实现一个React，从API层面实现React的大部分功能，在这个过程中去探索为什么有虚拟DOM、diff、为什么setState这样设计等问题。\x3c\/p\x3e\n\x3cp\x3e整个系列大概会有四篇，我每周会更新一到两篇，我会第一时间在github上更新，有问题需要探讨也请在github上回复我~\x3c\/p\x3e\n\x3cblockquote\x3e博客地址: \x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hujiulong\/...\x3c\/a\x3e\x3cbr\x3e关注点star，订阅点watch\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e上一篇文章\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从零开始实现一个React（二）：组件和生命周期 \x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从零开始实现一个React（三）：diff算法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014307795">https://segmentfault.com/a/1190000014307795</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/j88v2tayp3/" target="_blank">https://alili.tech/archive/j88v2tayp3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>