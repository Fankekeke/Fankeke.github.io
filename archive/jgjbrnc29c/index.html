<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="你不知道的前端SDK开发技巧"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>你不知道的前端SDK开发技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jgjbrnc29c/",
				"appid": "1613049289050283", 
				"title": "你不知道的前端SDK开发技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-23T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/f93l2wylvht/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4pczvpxa0dp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&text=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&text=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&title=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&is_video=false&description=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&title=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&title=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&title=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjgjbrnc29c%2f&title=%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e5%89%8d%e7%ab%afSDK%e5%bc%80%e5%8f%91%e6%8a%80%e5%b7%a7"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">你不知道的前端SDK开发技巧</h1><div class="meta"><div class="postdate"><time datetime="2018-12-23" itemprop="datePublished">2018-12-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\n\x3cp\x3e作者：陈达孚\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e香港中文大学研究生,《移动Web前端高效开发实战》作者之一，《前端开发者指南2017》译者之一，在中国前端开发者大会,中生代技术大会等技术会议发表过主题演讲, 专注于新技术的调研和使用.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e本文为原创文章，转载请注明作者及出处\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e最近在做公司内部的一个的一个SDK的重构，这里总结一些经验分享给大家。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e类型检查和智能提示\x3c\/h3\x3e\n\x3cp\x3e作为一个SDK，我们的目标是让使用者能够减少查看文档的时间，所以我们需要提供一些类型的检查和智能提示，一般我们的做法是提供JsDoc，大部分编辑器可以提供快捷生成JsDoc的方式，我们比较常用的vscode可以使用\x3ca href=\x22https:\/\/marketplace.visualstudio.com\/items?itemName=joelday.docthis\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDocument This\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012307849?w=1422\x26amp;h=1078\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012307849?w=1422\x26amp;h=1078\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e另一种做法是使用Flow或者TypeScript，选择TypeScript的主要原因是自动生成的JsDoc比较原始，我们仍然需要在上面进行编辑，所以JsDoc维护和代码开发是脱离的，往往会出现代码更新了，JsDoc忘记更新的情况。\x3c\/p\x3e\n\x3cp\x3e除此之外开发过程中我们无法享受到类型检查等对SDK开发比较重要的特性，TypeScript可以让我们减少犯错，减少调试的时间，另一方面这次开发的SDK在提供出去的时候就会进行一次相对简单的压缩，保证引入后的体积，所以会希望压缩掉JsDoc,而TypeScript可以通过在tsconfig.json中将declaration设置为true单独的d.ts文件。\x3c\/p\x3e\n\x3cp\x3e一个带提示的SDK：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012307850\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012307850\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e最后,对于开发同学来说，就算不使用TypeScript，也强烈建议使用vscode提供\x3ccode\x3e\/\/@ts-check\x3c\/code\x3e 注解，它会通过一些类型推导来检查你的代码的正确性，可以减少很多开发过程中的bug。\x3c\/p\x3e\n\x3cp\x3e还有一个小技巧，如果你使用的库没有提供智能提示，你可以通过\x3ccode\x3eNPM\/yarn\x3c\/code\x3e的\x3ccode\x3e-D\x3c\/code\x3e安装\x3ccode\x3e@types\/{pkgname}\x3c\/code\x3e，这样你开发过程中就能够享受到vscode提供的智能提示，而\x3ccode\x3e-D\x3c\/code\x3e安装到\x3ccode\x3edevDependencies\x3c\/code\x3e中，也不会增加你在构建时的代码体积。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e接口\x3c\/h3\x3e\n\x3cp\x3e既然提到了TypeScript，就提一下TypeScript的语法，基础类型没有必要赘述，而一些曾经的高级语法现在ES6也都能支持，这里提几点常用但是JavaScript开发者不太习惯使用的语法。\x3c\/p\x3e\n\x3cp\x3e很多人在开始使用TypeScript的时候，会很迷恋使用any或者默认的any，推荐在开发中打开tsconfig中的strict和noImplicitAny来保证尽量少的any使用，要知道，滥用any就等于你的类型检查并没有实质效果。\x3c\/p\x3e\n\x3cp\x3e对一些暂时不能确定内容的对象的类型,可以使用\x3ccode\x3e{[key: string]: any}\x3c\/code\x3e，而不要直接使用any，后期可以慢慢扩展这个接口直到完全消除any，同时TypeScript的类型支持继承，在开发过程中，可以拆解接口，利用组合继承的方式减少重复定义。\x3c\/p\x3e\n\x3cp\x3e但是接口也会带来一个小痛点，目前vscode的智能提醒不能很好的对应到接口，当你输入到对应变量的时候，虽然会高亮，但是高亮的也只是一个定义了名字的接口。没有办法直接看到接口里定义了什么。但是当你输入了接口里面定义的key的部分时，vscode会给你完整key的提示。虽然这对开发过程中有一点不够友好，但是vscode开发团队表示这是他们故意设计的，所以在API参数上可以选择将一些必要（重要）参数用基础类型直接使用，而将一些配置放入一个定义为接口的对象中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e枚举\x3c\/h3\x3e\n\x3cp\x3e你有在代码中使用过:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Platform = {\n    ios: 0,\n      android: 1\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Platform = {\n    \x3cspan class=\x22hljs-attr\x22\x3eios\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eandroid\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那你在TypeScript中就应该使用枚举：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22enum Platform {\n  ios,\n  android\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eenum\x3c\/span\x3e Platform {\n  ios,\n  android\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样在函数中你就可以为某个参数设置类型为number，然后传入\x3ccode\x3ePlatform.ios\x3c\/code\x3e这样，枚举可以增加代码的维护性，它可以利用智能提示保证你输入的正确，不再会出现魔数（magic number）。相对于对象，它保证了输入的类型（你定义的对象可能某一天不再只有number类型的value），不再需要额外的类型判断。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e装饰器\x3c\/h3\x3e\n\x3cp\x3e对于装饰器其实很多开发者既熟悉又陌生,在redux,mobx比较流行的现在,在代码中出现装饰器的调用已经很普遍,但是大多数开发者并没有将自己代码逻辑抽成装饰器的习惯。\x3c\/p\x3e\n\x3cp\x3e比如在这个SDK的开发中,我们需要提供一些facade来兼容不同的平台(iOS, Android或者Web)，而这个facade会通过插件的形式让开发者自己注册，SDK会维护一个注入后的对象，常规的使用方法是到了使用函数后判断环境再判断对象中有没有想有的插件，有就使用插件。\x3c\/p\x3e\n\x3cp\x3e实际来看，插件就是一个拦截器，我们只要阻止真正的函数运行就可以，大概的逻辑是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function facade(env: number) {\n  return function(\n    target: object,\n    name: string,\n    descriptor: TypedPropertyDescriptor\x3cany\x3e\n  ) {\n    let originalMethod = descriptor.value;\n    let method;\n\n    return {\n      ...descriptor,\n      value(...args: any[]): any {\n        let [arg] = args;\n        let { param, success, failure, polyfill } = arg;   \/\/ 这部分可以自定义\n        if ((method = polyfill[env])) {\n          method.use(param, success, failure);\n          return;\n        }\n        originalMethod.apply(this, args);\n      }\n    };\n  };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efacade\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eenv: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    target: object,\n    name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e,\n    descriptor: TypedPropertyDescriptor\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;\n  \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e originalMethod = descriptor.value;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e method;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      ...descriptor,\n      value(...args: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[]): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e [arg] = args;\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e { param, success, failure, polyfill } = arg;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这部分可以自定义\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((method = polyfill[env])) {\n          method.use(param, success, failure);\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n        originalMethod.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n      }\n    };\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在SDK的开发过程中另一个常会遇到的就是很多参数的校验和再封装，我们也可以使用装饰器去完成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function snakeParam(\n  target: object,\n  name: string,\n  descriptor: TypedPropertyDescriptor\x3cany\x3e\n) {\n  let callback = descriptor.value!;\n\n  return {\n    ...descriptor,\n    value(...args: any[]): any {\n      let [arg, ...other] = args;\n      arg = convertObjectName(arg, ConvertNameMode.toSnake);\n      callback.apply(this, [arg, ...other]);\n    }\n  };\n}÷\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esnakeParam\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n  target: object,\n  name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e,\n  descriptor: TypedPropertyDescriptor\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;\n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e callback = descriptor.value!;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    ...descriptor,\n    value(...args: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[]): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e [arg, ...other] = args;\n      arg = convertObjectName(arg, ConvertNameMode.toSnake);\n      callback.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, [arg, ...other]);\n    }\n  };\n}÷\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e泛形\x3c\/h3\x3e\n\x3cp\x3e泛形可以根据用户的输入决定输出，最简单的例子是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function identity\x3cT\x3e(arg: T): T {\n    return arg;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eidentity\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-title\x22\x3eT\x3c\/span\x3e\x26gt;(\x3cspan class=\x22hljs-params\x22\x3earg: T\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eT\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arg;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然它没有什么特别的意义，但是它表明了返回是根据arg的类型，在一般开发过程中，你逃不开范型的是Promise或者前面的TypedPropertyDescriptor这种内建的需要类型输入的地方，不要草率的使用any，如果你的后端返回是一个标准结构体类似：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export interface IRes {\n  status: number;\n  message: string;\n  data?: object;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e IRes {\n  status: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;\n  message: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n  data?: object;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么你可以这样使用Promise：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function example(): Promise\x3cIRes\x3e {\n    return new Promise ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eexample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-title\x22\x3eIRes\x3c\/span\x3e\x26gt; \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然泛形有很多高级应用，例如泛形约束，泛型创建工厂函数，已经超出了本文的范围，可以去官方文档了解。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e构建\x3c\/h3\x3e\n\x3cp\x3e如果你的构建工具是Webpack，在SDK的开发中，尽量使用node方式调用（即webpack.run执行），因为SDK的构建往往会应对很多不同的参数变化，node方式相比纯配置方式可以更加灵活的调整输入输出的参数，也可以考虑使用rollup，rollup的构建代码更加面向编程方式。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，在Webpack3和rollup中构建中可以使用ES6模块化的方式构建，这样业务代码引入你的SDK后，可以通过解构引入的方式减少最终业务代码的体积，如果你只是提供了commonjs的包，那么构建工具的tree sharking是无法生效的，如果使用babel的话注意关闭module的编译。\x3c\/p\x3e\n\x3cp\x3e另外一种减少单个包体积的方式，可以使用\x3ca href=\x22https:\/\/github.com\/lerna\/lerna\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elerna\x3c\/a\x3e在一个git仓库里构建多个NPM包，比起拆仓库可以更方便的使用公共部分的代码，但是也需要注意对公共部分代码的修改不要影响到别的包。\x3c\/p\x3e\n\x3cp\x3e其实对于大多数的SDK的来说，Webpack3和rollup使用感受是差不多的，比较常用的插件都有几乎同名的对应。不过rollup有两个优势，一个是rollup的构建更细化，rollup.rollup接受inputOptions生成bundle，还可以generate生成sourcemap，write生成output，在这个过程中我们可以做一些细致的工作。\x3c\/p\x3e\n\x3cp\x3e第二点是rollup.rollup会返回一个promise，也就意味着我们可以使用async的方式来写构建代码，而webpack.run还是使用的回调函数，虽然开发者可以封装成promise，但是个人觉得还是rollup的写法还是更爽一点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e单元测试\x3c\/h3\x3e\n\x3cp\x3e上周我同事做了一个在线的分享，我发现很多同学都对单测很感兴趣也很疑惑，在前端开发中，对涉及UI的业务代码开发单测试比较困难的，但是对于SDK，单元测试肯定是准出的一个充要条件。当然其实我也很不喜欢写单测，因为单测往往比较枯燥，但是不写单测肯定会被老司机们“教育”的~_~。\x3c\/p\x3e\n\x3cp\x3e一般的单测使用\x3ca href=\x22https:\/\/github.com\/mochajs\/mocha\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emocha\x3c\/a\x3e作为测试框架，\x3ca href=\x22https:\/\/github.com\/mjackson\/expect\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eexpect\x3c\/a\x3e作为断言库，使用\x3ca href=\x22https:\/\/github.com\/istanbuljs\/nyc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enyc\x3c\/a\x3e提供单测报告，一个大概的单测如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22describe(\x27xxx api test\x27, function() {            \/\/ 注意如果要用this调用mocha，不要用箭头函数\n  this.timeout(6000);\n  it(\x27xxx\x27, done =\x3e {\n    SDK.file\n      .chooseImage({\n        count: 10,\n        cancel: () =\x3e {\n          console.log(\x27选择图片取消----\x27);\n        }\n      })\n      .then(res =\x3e {\n        console.dir(res);\n        expect(res).to.be.an(\x27object\x27);\n        expect(res).to.have.keys(\x27ids\x27);\n        expect(res.ids).to.be.an(\x27array\x27);\n        expect(res.ids).to.have.length.above(0);\n        uploadImg(res.ids);\n        done();\n      });\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3edescribe(\x3cspan class=\x22hljs-string\x22\x3e\x27xxx api test\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意如果要用this调用mocha，不要用箭头函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.timeout(\x3cspan class=\x22hljs-number\x22\x3e6000\x3c\/span\x3e);\n  it(\x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edone\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    SDK.file\n      .chooseImage({\n        count: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n        cancel: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27选择图片取消----\x27\x3c\/span\x3e);\n        }\n      })\n      .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.dir(res);\n        expect(res).to.be.an(\x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e);\n        expect(res).to.have.keys(\x3cspan class=\x22hljs-string\x22\x3e\x27ids\x27\x3c\/span\x3e);\n        expect(res.ids).to.be.an(\x3cspan class=\x22hljs-string\x22\x3e\x27array\x27\x3c\/span\x3e);\n        expect(res.ids).to.have.length.above(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        uploadImg(res.ids);\n        done();\n      });\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样你可以用TypeScript写单测，当然在执行过程中，不需要再编译了，我们可以直接给mocha注册ts-node来直接执行，具体方式可以参考\x3ca href=\x22https:\/\/journal.artfuldev.com\/write-tests-for-typescript-projects-with-mocha-and-chai-in-typescript-86e053bdb2b6\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWrite tests for TypeScript projects with mocha and chai — in TypeScript!\x3c\/a\x3e。但是有一点需要提醒你，写单测的时候尽量依赖文档而不是智能提示，因为你的代码出错，可能会导致你的智能提示也是错误的，你根据错误的智能提示写的单测肯定也是。。。\x3c\/p\x3e\n\x3cp\x3e对于网络请求的模拟可以使用\x3ca href=\x22https:\/\/github.com\/node-nock\/nock\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enock\x3c\/a\x3e这个库，需要在it之前增加一个\x3ccode\x3ebeforeEach\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22describe(\x27proxy\x27, () =\x3e {\n  beforeEach(() =\x3e {\n    nock(\x27http:\/\/test.com\x27)\n      .post(\x27\/test1\x27)\n      .delay(200)\n      .reply(200, {            \/\/ body\n        test1: 1,\n        test2: 2\n      }, {\n        \x27server-id\x27: \x27test\x27 \/\/ header\n      });\n  });\n  it(...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3edescribe(\x3cspan class=\x22hljs-string\x22\x3e\x27proxy\x27\x3c\/span\x3e, () =\x26gt; {\n  beforeEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    nock(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/test.com\x27\x3c\/span\x3e)\n      .post(\x3cspan class=\x22hljs-string\x22\x3e\x27\/test1\x27\x3c\/span\x3e)\n      .delay(\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e)\n      .reply(\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e, {            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ body\x3c\/span\x3e\n        test1: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etest2\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-string\x22\x3e\x27server-id\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ header\x3c\/span\x3e\n      });\n  });\n  it(...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后我们用一个npm script加上nyc在mocha前面，就可以获得我们的单测报告了。\x3c\/p\x3e\n\x3cp\x3e这里我还提了几个TypeScript使用中的小tips给大家参考。\x3c\/p\x3e\n\x3ch4\x3etips: 如何在非发包情况下给内部库添加声明\x3c\/h4\x3e\n\x3cp\x3e这个SDK在开发过程会依赖一个内部NPM包,为了让这个NPM支持TypeScript调用,我们有几种做法:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e给原包添加d.ts文件,然后发布.\x3c\/li\x3e\n\x3cli\x3e发布@types包,需要注意的是NPM不支持\x3ccode\x3e@types\/@scope\/{pkgname}\x3c\/code\x3e这种写如果是私库包,可以使用\x3ccode\x3e@types\/scope_{pkgname}\x3c\/code\x3e这种写法.\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e这次使用的标注一个文件夹存放对应的d.ts文件,这种方式适合开发中进行,如果你觉得你写的d.ts还不够完美,或者这个d.ts文件目前只有这个SDK有需要,可以这么使用,在tsconfig.json中修改:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;baseUrl\x26quot;: \x26quot;.\/\x26quot;,\n\x26quot;paths\x26quot;: {\n    \x26quot;*\x26quot;: [\x26quot;\/type\/*\x26quot;]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22baseUrl\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22.\/\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-string\x22\x3e\x22paths\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22*\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22\/type\/*\x22\x3c\/span\x3e]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3etips: 如何处理resolve和reject不同类型的promise回调\x3c\/h4\x3e\n\x3cp\x3e默认的reject返回的参数类型是any，不一定能满足我们的需要，这里给一个解决方案，并非最佳，作为抛砖引玉：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface IPromise\x3cT, U\x3e {\n  then\x3cTResult1 = T, TResult2 = never\x3e(\n    onfulfilled?:\n      | ((value: T) =\x3e TResult1 | PromiseLike\x3cTResult1\x3e)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: U) =\x3e TResult2 | PromiseLike\x3cTResult2\x3e)\n      | undefined\n      | null\n  ): IPromise\x3cTResult1 , TResult2\x3e;\n  catch\x3cTResult = never\x3e(\n    onrejected?:\n      | ((reason: U) =\x3e TResult | PromiseLike\x3cTResult\x3e)\n      | undefined\n      | null\n  ): Promise\x3cTResult\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e IPromise\x26lt;T, U\x26gt; {\n  then\x26lt;TResult1 = T, TResult2 = never\x26gt;(\n    onfulfilled?:\n      | \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue: T\x3c\/span\x3e) =\x26gt; TResult1 | PromiseLike\x26lt;TResult1\x26gt;\x3c\/span\x3e)\n      | \x3cspan class=\x22hljs-params\x22\x3eundefined\x3c\/span\x3e\n      | \x3cspan class=\x22hljs-params\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-params\x22\x3eonrejected\x3c\/span\x3e?:\n      | (\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereason: U\x3c\/span\x3e) =\x26gt; TResult2 | PromiseLike\x26lt;TResult2\x26gt;\x3c\/span\x3e)\n      | \x3cspan class=\x22hljs-params\x22\x3eundefined\x3c\/span\x3e\n      | \x3cspan class=\x22hljs-params\x22\x3enull\x3c\/span\x3e\n  ): \x3cspan class=\x22hljs-params\x22\x3eIPromise\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-params\x22\x3eTResult1\x3c\/span\x3e , \x3cspan class=\x22hljs-params\x22\x3eTResult2\x3c\/span\x3e\x26gt;;\n  \x3cspan class=\x22hljs-params\x22\x3ecatch\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-params\x22\x3eTResult\x3c\/span\x3e = \x3cspan class=\x22hljs-params\x22\x3enever\x3c\/span\x3e\x26gt;(\x3cspan class=\x22hljs-params\x22\x3e\n    onrejected?:\n      | (\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereason: U\x3c\/span\x3e) =\x26gt; TResult | PromiseLike\x26lt;TResult\x26gt;\x3c\/span\x3e)\n      | \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  \x3c\/span\x3e): \x3cspan class=\x22hljs-params\x22\x3ePromise\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-params\x22\x3eTResult\x3c\/span\x3e\x26gt;;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010953661\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010953661\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eiKcamp原创新书《移动Web前端高效开发实战》已在亚马逊、京东、当当开售。\x3c\/p\x3e\n\x3cp\x3eiKcamp官网：\x3ca href=\x22https:\/\/www.ikcamp.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.ikcamp.com\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e包含：文章、视频、源代码\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010887896\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010887896\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>你不知道的前端SDK开发技巧</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012307844">https://segmentfault.com/a/1190000012307844</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jgjbrnc29c/" target="_blank">https://alili.tech/archive/jgjbrnc29c/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>