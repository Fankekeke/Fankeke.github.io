<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从Vue.js源码角度再看数据绑定"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从Vue.js源码角度再看数据绑定 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jn993zgejf/",
				"appid": "1613049289050283", 
				"title": "从Vue.js源码角度再看数据绑定 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/1je2vgj58g3j/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/8lhmeamyell/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&text=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&text=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&title=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&is_video=false&description=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&title=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&title=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&title=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjn993zgejf%2f&title=%e4%bb%8eVue.js%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%86%8d%e7%9c%8b%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从Vue.js源码角度再看数据绑定</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h2\x3e\n\x3cp\x3e因为对Vue.js很感兴趣，而且平时工作的技术栈也是Vue.js，这几个月花了些时间研究学习了一下Vue.js源码，并做了总结与输出。\x3cbr\x3e文章的原地址：\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\x3c\/a\x3e。\x3cbr\x3e在学习过程中，为Vue加上了中文的注释\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\x3c\/a\x3e，希望可以对其他想学习Vue源码的小伙伴有所帮助。\x3cbr\x3e可能会有理解存在偏差的地方，欢迎提issue指出，共同学习，共同进步。\x3c\/p\x3e\n\x3cp\x3e阅读数据绑定源码之前建议先了解一下\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《响应式原理》\x3c\/a\x3e以及\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《依赖收集》\x3c\/a\x3e，可以更好地理解Vue.js数据双向绑定的整个过程。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e数据绑定原理\x3c\/h2\x3e\n\x3cp\x3e前面已经讲过Vue数据绑定的原理了，现在从源码来看一下数据绑定在Vue中是如何实现的。\x3c\/p\x3e\n\x3cp\x3e首先看一下Vue.js官网介绍响应式原理的这张图。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011017713\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011017713\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅着，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。\x3c\/p\x3e\n\x3cp\x3eVue在初始化组件数据时，在生命周期的\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/instance\/init.js#L55\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebeforeCreate\x3c\/a\x3e与\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/instance\/init.js#L59\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecreated\x3c\/a\x3e钩子函数之间实现了对\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/instance\/state.js#L43\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edata、props、computed、methods、events以及watch\x3c\/a\x3e的处理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3einitData\x3c\/h2\x3e\n\x3cp\x3e这里来讲一下\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/instance\/state.js#L107\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3einitData\x3c\/a\x3e，可以参考源码instance下的state.js文件，下面所有的中文注释都是我加的，英文注释是尤大加的，请不要忽略英文注释，英文注释都讲到了比较关键或者晦涩难懂的点。\x3c\/p\x3e\n\x3cp\x3e加注释版的vue源码也可以直接通过\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/tree\/master\/vue-src\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e传送门\x3c\/a\x3e查看，这些是我在阅读Vue源码过程中加的注释，持续更新中。\x3c\/p\x3e\n\x3cp\x3einitData主要是初始化data中的数据，将数据进行Oberver，监听数据的变化，其他的监视原理一致，这里以data为例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initData (vm: Component) {\n\n  \/*得到data数据*\/\n  let data = vm.$options.data\n  data = vm._data = typeof data === \x27function\x27\n    ? getData(data, vm)\n    : data || {}\n\n  \/*判断是否是对象*\/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n      \x27data functions should return an object:\\n\x27 \x2b\n      \x27https:\/\/vuejs.org\/v2\/guide\/components.html#data-Must-Be-a-Function\x27,\n      vm\n    )\n  }\n\n  \/\/ proxy data on instance\n  \/*遍历data对象*\/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n\n  \/\/遍历data中的数据\n  while (i--) {\n    \/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*\/\n    if (props \x26amp;\x26amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n        `The data property \x26quot;${keys[i]}\x26quot; is already declared as a prop. ` \x2b\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(keys[i])) {\n      \/*判断是否是保留字段*\/\n\n      \/*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*\/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n\n  \/\/ observe data\n  \/*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*\/\n  observe(data, true \/* asRootData *\/)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*得到data数据*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = vm.$options.data\n  data = vm._data = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e data === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n    ? getData(data, vm)\n    : data || {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*判断是否是对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27data functions should return an object:\\n\x27\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/vuejs.org\/v2\/guide\/components.html#data-Must-Be-a-Function\x27\x3c\/span\x3e,\n      vm\n    )\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ proxy data on instance\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*遍历data对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(data)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e props = vm.$options.props\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = keys.length\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/遍历data中的数据\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (props \x26amp;\x26amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n        \x3cspan class=\x22hljs-string\x22\x3e`The data property \x22\x3cspan class=\x22hljs-subst\x22\x3e${keys[i]}\x3c\/span\x3e\x22 is already declared as a prop. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`Use prop default value instead.`\x3c\/span\x3e,\n        vm\n      )\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isReserved(keys[i])) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*判断是否是保留字段*\/\x3c\/span\x3e\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*\/\x3c\/span\x3e\n      proxy(vm, \x3cspan class=\x22hljs-string\x22\x3e`_data`\x3c\/span\x3e, keys[i])\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ observe data\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*\/\x3c\/span\x3e\n  observe(data, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据变成observable。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eproxy\x3c\/h2\x3e\n\x3cp\x3e接下来看一下proxy代理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*添加代理*\/\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*添加代理*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxy\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etarget: Object, sourceKey: string, key: string\x3c\/span\x3e) \x3c\/span\x3e{\n  sharedPropertyDefinition.get = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxyGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxySetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[sourceKey][key] = val\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, key, sharedPropertyDefinition)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里比较好理解，通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eobserve\x3c\/h2\x3e\n\x3cp\x3e接下来是\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/index.js#L106\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eobserve\x3c\/a\x3e，这个函数定义在core文件下oberver的index.js文件中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\/\n \/*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n *\/\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  \/*判断是否是一个对象*\/\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n\n  \/*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*\/\n  if (hasOwn(value, \x27__ob__\x27) \x26amp;\x26amp; value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n\n    \/*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*\/\n    observerState.shouldConvert \x26amp;\x26amp;\n    !isServerRendering() \x26amp;\x26amp;\n    (Array.isArray(value) || isPlainObject(value)) \x26amp;\x26amp;\n    Object.isExtensible(value) \x26amp;\x26amp;\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData \x26amp;\x26amp; ob) {\n\n    \/*如果是根数据则计数，后面Observer中的observe的asRootData非true*\/\n    ob.vmCount\x2b\x2b\n  }\n  return ob\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\/\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobserve\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evalue: any, asRootData: ?boolean\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e | \x3cspan class=\x22hljs-title\x22\x3evoid\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*判断是否是一个对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isObject(value)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ob: Observer | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasOwn(value, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e) \x26amp;\x26amp; value.__ob__ \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Observer) {\n    ob = value.__ob__\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*\/\x3c\/span\x3e\n    observerState.shouldConvert \x26amp;\x26amp;\n    !isServerRendering() \x26amp;\x26amp;\n    (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value) || isPlainObject(value)) \x26amp;\x26amp;\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.isExtensible(value) \x26amp;\x26amp;\n    !value._isVue\n  ) {\n    ob = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer(value)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (asRootData \x26amp;\x26amp; ob) {\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*如果是根数据则计数，后面Observer中的observe的asRootData非true*\/\x3c\/span\x3e\n    ob.vmCount\x2b\x2b\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ob\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eObserver\x3c\/h2\x3e\n\x3cp\x3e接下来看一下新建的\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/index.js#L34\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObserver\x3c\/a\x3e。Observer的作用就是遍历对象的所有属性将其进行双向绑定。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object\x27s property keys into getter\/setters that\n * collect dependencies and dispatches updates.\n *\/\nexport class  {\n  value: any;\n  dep: Dep;\n  vmCount: number; \/\/ number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n\n    \/* \n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/util\/lang.js#L16 \n    *\/\n    def(value, \x27__ob__\x27, this)\n    if (Array.isArray(value)) {\n\n      \/*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      *\/\n      const augment = hasProto\n        ? protoAugment  \/*直接覆盖原型的方法来修改目标对象*\/\n        : copyAugment   \/*定义（覆盖）目标对象或数组的某一个方法*\/\n      augment(value, arrayMethods, arrayKeys)\n\n      \/*如果是数组则需要遍历数组的每一个成员进行observe*\/\n      this.observeArray(value)\n    } else {\n\n      \/*如果是对象则直接walk进行绑定*\/\n      this.walk(value)\n    }\n  }\n\n  \/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n\n    \/*walk方法会遍历对象的每一个属性进行defineReactive绑定*\/\n    for (let i = 0; i \x3c keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \/**\n   * Observe a list of Array items.\n   *\/\n  observeArray (items: Array\x3cany\x3e) {\n\n    \/*数组需要便利每一个成员进行observe*\/\n    for (let i = 0, l = items.length; i \x3c l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object\x27s property keys into getter\/setters that\n * collect dependencies and dispatches updates.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e  \x3c\/span\x3e{\n  value: any;\n  dep: Dep;\n  vmCount: number; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ number of vms that has this object as root $data\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (value: any) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* \n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/util\/lang.js#L16 \n    *\/\x3c\/span\x3e\n    def(value, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e augment = hasProto\n        ? protoAugment  \x3cspan class=\x22hljs-comment\x22\x3e\/*直接覆盖原型的方法来修改目标对象*\/\x3c\/span\x3e\n        : copyAugment   \x3cspan class=\x22hljs-comment\x22\x3e\/*定义（覆盖）目标对象或数组的某一个方法*\/\x3c\/span\x3e\n      augment(value, arrayMethods, arrayKeys)\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果是数组则需要遍历数组的每一个成员进行observe*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果是对象则直接walk进行绑定*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(value)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\x3c\/span\x3e\n  walk (obj: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(obj)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*walk方法会遍历对象的每一个属性进行defineReactive绑定*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Observe a list of Array items.\n   *\/\x3c\/span\x3e\n  observeArray (items: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;any\x26gt;) {\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*数组需要便利每一个成员进行observe*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = items.length; i \x26lt; l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eObserver为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。\x3c\/p\x3e\n\x3cp\x3e如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\x3cbr\x3eVue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个\x3ca href=\x22http:\/\/v1-cn.vuejs.org\/guide\/list.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数组方法\x3c\/a\x3e。修改数组原型方法的代码可以参考\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/array.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eobserver\/array.js\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\n\nimport { def } from \x27..\/util\/index\x27\n\n\/*取得原生数组的原型*\/\nconst arrayProto = Array.prototype\n\/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*\/\nexport const arrayMethods = Object.create(arrayProto)\n\n\/**\n * Intercept mutating methods and emit events\n *\/\n \/*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*\/\n;[\n  \x27push\x27,\n  \x27pop\x27,\n  \x27shift\x27,\n  \x27unshift\x27,\n  \x27splice\x27,\n  \x27sort\x27,\n  \x27reverse\x27\n]\n.forEach(function (method) {\n  \/\/ cache original method\n  \/*将数组的原生方法缓存起来，后面要调用*\/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    \/\/ avoid leaking arguments:\n    \/\/ http:\/\/jsperf.com\/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    \/*调用原生的数组方法*\/\n    const result = original.apply(this, args)\n\n    \/*数组新插入的元素需要重新进行observe才能响应式*\/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case \x27push\x27:\n        inserted = args\n        break\n      case \x27unshift\x27:\n        inserted = args\n        break\n      case \x27splice\x27:\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    \/\/ notify change\n    \/*dep通知所有注册的观察者进行响应式处理*\/\n    ob.dep.notify()\n    return result\n  })\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * not type checking this file because flow doesn\x27t play well with\n * dynamically accessing methods on Array prototype\n *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { def } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/util\/index\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/*取得原生数组的原型*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayProto = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype\n\x3cspan class=\x22hljs-comment\x22\x3e\/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayMethods = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(arrayProto)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Intercept mutating methods and emit events\n *\/\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*\/\x3c\/span\x3e\n;[\n  \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27pop\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27shift\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27sort\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27reverse\x27\x3c\/span\x3e\n]\n.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*将数组的原生方法缓存起来，后面要调用*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e original = arrayProto[method]\n  def(arrayMethods, method, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emutator\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoid leaking arguments:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/jsperf.com\/closure-with-arguments\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e args = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(i)\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      args[i] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[i]\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*调用原生的数组方法*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = original.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*数组新插入的元素需要重新进行observe才能响应式*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__ob__\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e inserted\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (method) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e:\n        inserted = args\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e:\n        inserted = args\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e:\n        inserted = args.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inserted) ob.observeArray(inserted)\n      \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ notify change\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*dep通知所有注册的观察者进行响应式处理*\/\x3c\/span\x3e\n    ob.dep.notify()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n  })\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\x3cbr\x3e在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\x3cbr\x3e但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了\x3ca href=\x22http:\/\/v1-cn.vuejs.org\/guide\/list.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e$set()及$remove()方法\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eWatcher\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/watcher.js#L24\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWatcher\x3c\/a\x3e是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array\x3cDep\x3e;\n  newDeps: Array\x3cDep\x3e;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    \/*_watchers存放订阅者实例*\/\n    vm._watchers.push(this)\n    \/\/ options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = \x2b\x2buid \/\/ uid for batching\n    this.active = true\n    this.dirty = this.lazy \/\/ for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== \x27production\x27\n      ? expOrFn.toString()\n      : \x27\x27\n    \/\/ parse expression for getter\n    \/*把表达式expOrFn解析成getter*\/\n    if (typeof expOrFn === \x27function\x27) {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; warn(\n          `Failed watching path: \x26quot;${expOrFn}\x26quot; ` \x2b\n          \x27Watcher only accepts simple dot-delimited paths. \x27 \x2b\n          \x27For full control, use a function instead.\x27,\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  \/**\n   * Evaluate the getter, and re-collect dependencies.\n   *\/\n   \/*获得getter的值并且重新进行依赖收集*\/\n  get () {\n    \/*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*\/\n    pushTarget(this)\n    let value\n    const vm = this.vm\n\n    \/*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    *\/\n    if (this.user) {\n      try {\n        value = this.getter.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \x26quot;${this.expression}\x26quot;`)\n      }\n    } else {\n      value = this.getter.call(vm, vm)\n    }\n    \/\/ \x26quot;touch\x26quot; every property so they are all tracked as\n    \/\/ dependencies for deep watching\n    \/*如果存在deep，则触发每个深层对象的依赖，追踪其变化*\/\n    if (this.deep) {\n      \/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*\/\n      traverse(value)\n    }\n\n    \/*将观察者实例从target栈中取出并设置给Dep.target*\/\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n\n  \/**\n   * Add a dependency to this directive.\n   *\/\n   \/*添加一个依赖关系到Deps集合中*\/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  \/**\n   * Clean up for dependency collection.\n   *\/\n   \/*清理依赖收集*\/\n  cleanupDeps () {\n    \/*移除所有观察者对象*\/\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  \/**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\/\n   \/*\n      调度者接口，当依赖发生改变的时候进行回调。\n   *\/\n  update () {\n    \/* istanbul ignore else *\/\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      \/*同步则执行run直接渲染视图*\/\n      this.run()\n    } else {\n      \/*异步推送到观察者队列中，由调度者调用。*\/\n      queueWatcher(this)\n    }\n  }\n\n  \/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   *\/\n   \/*\n      调度者工作接口，将被调度者回调。\n    *\/\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        \/\/ Deep watchers and watchers on Object\/Arrays should fire even\n        \/\/ when the value is the same, because the value may\n        \/\/ have mutated.\n        \/*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        *\/\n        isObject(value) ||\n        this.deep\n      ) {\n        \/\/ set new value\n        const oldValue = this.value\n        \/*设置新的值*\/\n        this.value = value\n\n        \/*触发回调渲染视图*\/\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \x26quot;${this.expression}\x26quot;`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  \/**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   *\/\n   \/*获取观察者的值*\/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  \/**\n   * Depend on all deps collected by this watcher.\n   *\/\n   \/*收集该watcher的所有deps依赖*\/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  \/**\n   * Remove self from all dependencies\x27 subscriber list.\n   *\/\n   \/*将自身从所有依赖收集订阅列表删除*\/\n  teardown () {\n    if (this.active) {\n      \/\/ remove self from vm\x27s watcher list\n      \/\/ this is a somewhat expensive operation so we skip it\n      \/\/ if the vm is being destroyed.\n      \/*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*\/\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e \x3c\/span\x3e{\n  vm: Component;\n  expression: string;\n  cb: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Dep\x26gt;;\n  newDeps: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Dep\x26gt;;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  value: any;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*_watchers存放订阅者实例*\/\x3c\/span\x3e\n    vm._watchers.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = !!options.deep\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = !!options.user\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = !!options.lazy\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = !!options.sync\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = \x2b\x2buid \x3cspan class=\x22hljs-comment\x22\x3e\/\/ uid for batching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for lazy watchers\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps = []\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps = []\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression = process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n      ? expOrFn.toString()\n      : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parse expression for getter\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*把表达式expOrFn解析成getter*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e expOrFn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = expOrFn\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = parsePath(expOrFn)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n        process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n          \x3cspan class=\x22hljs-string\x22\x3e`Failed watching path: \x22\x3cspan class=\x22hljs-subst\x22\x3e${expOrFn}\x3c\/span\x3e\x22 `\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27Watcher only accepts simple dot-delimited paths. \x27\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27For full control, use a function instead.\x27\x3c\/span\x3e,\n          vm\n        )\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy\n      ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Evaluate the getter, and re-collect dependencies.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*获得getter的值并且重新进行依赖收集*\/\x3c\/span\x3e\n  get () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*\/\x3c\/span\x3e\n    pushTarget(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e value\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user) {\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(vm, vm)\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n        handleError(e, vm, \x3cspan class=\x22hljs-string\x22\x3e`getter for watcher \x22\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(vm, vm)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22touch\x22 every property so they are all tracked as\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dependencies for deep watching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*如果存在deep，则触发每个深层对象的依赖，追踪其变化*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*\/\x3c\/span\x3e\n      traverse(value)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*将观察者实例从target栈中取出并设置给Dep.target*\/\x3c\/span\x3e\n    popTarget()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cleanupDeps()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Add a dependency to this directive.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*添加一个依赖关系到Deps集合中*\/\x3c\/span\x3e\n  addDep (dep: Dep) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e id = dep.id\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.has(id)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.add(id)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps.push(dep)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds.has(id)) {\n        dep.addSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Clean up for dependency collection.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*清理依赖收集*\/\x3c\/span\x3e\n  cleanupDeps () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*移除所有观察者对象*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i]\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.has(dep.id)) {\n        dep.removeSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds = tmp\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.clear()\n    tmp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps = tmp\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*\n      调度者接口，当依赖发生改变的时候进行回调。\n   *\/\x3c\/span\x3e\n  update () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*同步则执行run直接渲染视图*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run()\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*异步推送到观察者队列中，由调度者调用。*\/\x3c\/span\x3e\n      queueWatcher(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*\n      调度者工作接口，将被调度者回调。\n    *\/\x3c\/span\x3e\n  run () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n        value !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value ||\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Deep watchers and watchers on Object\/Arrays should fire even\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ when the value is the same, because the value may\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ have mutated.\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        *\/\x3c\/span\x3e\n        isObject(value) ||\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep\n      ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set new value\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldValue = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*设置新的值*\/\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*触发回调渲染视图*\/\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user) {\n          \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, value, oldValue)\n          } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n            handleError(e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, \x3cspan class=\x22hljs-string\x22\x3e`callback for watcher \x22\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n          }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*获取观察者的值*\/\x3c\/span\x3e\n  evaluate () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Depend on all deps collected by this watcher.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*收集该watcher的所有deps依赖*\/\x3c\/span\x3e\n  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i].depend()\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Remove self from all dependencies\x27 subscriber list.\n   *\/\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/*将自身从所有依赖收集订阅列表删除*\/\x3c\/span\x3e\n  teardown () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ remove self from vm\x27s watcher list\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is a somewhat expensive operation so we skip it\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if the vm is being destroyed.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._isBeingDestroyed) {\n        remove(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._watchers, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps.length\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deps[i].removeSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eDep\x3c\/h2\x3e\n\x3cp\x3e来看看\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/dep.js#L12\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDep\x3c\/a\x3e类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array\x3cWatcher\x3e;\n\n  constructor () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\n\n  \/*添加一个观察者对象*\/\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  \/*移除一个观察者对象*\/\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  \/*依赖收集，当存在Dep.target的时候添加观察者对象*\/\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  \/*通知所有订阅者*\/\n  notify () {\n    \/\/ stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i \x3c l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\n\n\/\/ the current target watcher being evaluated.\n\/\/ this is globally unique because there could be only one\n\/\/ watcher being evaluated at any time.\nDep.target = null\n\/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e target: ?Watcher;\n  id: number;\n  subs: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;Watcher\x26gt;;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid\x2b\x2b\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = []\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*添加一个观察者对象*\/\x3c\/span\x3e\n  addSub (sub: Watcher) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.push(sub)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*移除一个观察者对象*\/\x3c\/span\x3e\n  removeSub (sub: Watcher) {\n    remove(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs, sub)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*依赖收集，当存在Dep.target的时候添加观察者对象*\/\x3c\/span\x3e\n  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n      Dep.target.addDep(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*通知所有订阅者*\/\x3c\/span\x3e\n  notify () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stabilize the subscriber list first\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e subs = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.slice()\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = subs.length; i \x26lt; l; i\x2b\x2b) {\n      subs[i].update()\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the current target watcher being evaluated.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is globally unique because there could be only one\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ watcher being evaluated at any time.\x3c\/span\x3e\nDep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3edefineReactive\x3c\/h2\x3e\n\x3cp\x3e接下来是\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/observer\/index.js#L131\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edefineReactive\x3c\/a\x3e。defineReactive的作用是通过Object.defineProperty为数据定义上gettersetter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Define a reactive property on an Object.\n *\/\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  \/*在闭包中定义一个dep对象*\/\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property \x26amp;\x26amp; property.configurable === false) {\n    return\n  }\n\n  \/*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter\/setter中会将其执行，保证不会覆盖之前已经定义的getter\/setter。*\/\n  \/\/ cater for pre-defined getter\/setters\n  const getter = property \x26amp;\x26amp; property.get\n  const setter = property \x26amp;\x26amp; property.set\n\n  \/*对象的子对象递归进行observe并返回子节点的Observer对象*\/\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n\n      \/*如果原本对象拥有getter方法则执行*\/\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n\n        \/*进行依赖收集*\/\n        dep.depend()\n        if (childOb) {\n\n          \/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*\/\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n\n          \/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*\/\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n\n      \/*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*\/\n      const value = getter ? getter.call(obj) : val\n      \/* eslint-disable no-self-compare *\/\n      if (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        return\n      }\n      \/* eslint-enable no-self-compare *\/\n      if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; customSetter) {\n        customSetter()\n      }\n      if (setter) {\n\n        \/*如果原本对象拥有setter方法则执行setter*\/\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n\n      \/*新的值需要重新进行observe，保证数据响应式*\/\n      childOb = observe(newVal)\n\n      \/*dep对象通知所有的观察者*\/\n      dep.notify()\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Define a reactive property on an Object.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*在闭包中定义一个dep对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e property = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(obj, key)\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (property \x26amp;\x26amp; property.configurable === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter\/setter中会将其执行，保证不会覆盖之前已经定义的getter\/setter。*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cater for pre-defined getter\/setters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getter = property \x26amp;\x26amp; property.get\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setter = property \x26amp;\x26amp; property.set\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*对象的子对象递归进行observe并返回子节点的Observer对象*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childOb = observe(val)\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*如果原本对象拥有getter方法则执行*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*进行依赖收集*\/\x3c\/span\x3e\n        dep.depend()\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n\n          \x3cspan class=\x22hljs-comment\x22\x3e\/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*\/\x3c\/span\x3e\n          childOb.dep.depend()\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n\n          \x3cspan class=\x22hljs-comment\x22\x3e\/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*\/\x3c\/span\x3e\n          dependArray(value)\n        }\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable no-self-compare *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-enable no-self-compare *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; customSetter) {\n        customSetter()\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*如果原本对象拥有setter方法则执行setter*\/\x3c\/span\x3e\n        setter.call(obj, newVal)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        val = newVal\n      }\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*新的值需要重新进行observe，保证数据响应式*\/\x3c\/span\x3e\n      childOb = observe(newVal)\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/*dep对象通知所有的观察者*\/\x3c\/span\x3e\n      dep.notify()\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在再来看这张图是不是更清晰了呢？\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011017713\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011017713\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e关于\x3c\/h2\x3e\n\x3cp\x3e作者：染陌 \x3c\/p\x3e\n\x3cp\x3eEmail：answershuto@gmail.com  or  answershuto@126.com\x3c\/p\x3e\n\x3cp\x3eGithub:  \x3ca href=\x22https:\/\/github.com\/answershuto\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershuto\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eBlog：\x3ca href=\x22http:\/\/answershuto.github.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/answershuto.github.io\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e知乎专栏：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/ranmo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/zhuanlan.zhihu.com\/ranmo\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e掘金： \x3ca href=\x22https:\/\/juejin.im\/user\/58f87ae844d9040069ca7507\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/juejin.im\/user\/58f87ae844d9040069ca7507\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eosChina：\x3ca href=\x22https:\/\/my.oschina.net\/u\/3161824\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/my.oschina.net\/u\/3161824\/blog\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e转载请注明出处，谢谢。\x3c\/p\x3e\n\x3cp\x3e欢迎关注我的公众号\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011204170\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011204170\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从Vue.js源码角度再看数据绑定</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011017708">https://segmentfault.com/a/1190000011017708</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jn993zgejf/" target="_blank">https://alili.tech/archive/jn993zgejf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>