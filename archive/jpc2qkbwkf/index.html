<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JS 数组循环遍历方法的对比"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JS 数组循环遍历方法的对比 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jpc2qkbwkf/",
				"appid": "1613049289050283", 
				"title": "JS 数组循环遍历方法的对比 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-15T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9e4rwwq20d5/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vt7m705dqch/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&text=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&text=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&title=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&is_video=false&description=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&title=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&title=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&title=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjpc2qkbwkf%2f&title=JS%20%e6%95%b0%e7%bb%84%e5%be%aa%e7%8e%af%e9%81%8d%e5%8e%86%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JS 数组循环遍历方法的对比</h1><div class="meta"><div class="postdate"><time datetime="2018-12-15" itemprop="datePublished">2018-12-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QTD?w=1600\x26amp;h=500\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QTD?w=1600\x26amp;h=500\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3eJavaScript 发展至今已经发展出多种数组的循环遍历的方法,不同的遍历方法运行起来那个比较快,不同循环方法使用在那些场景,下面将进行比较:\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e各种数组遍历的方法\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\n\x3cstrong\x3e\x3ccode\x3efor\x3c\/code\x3e\x3c\/strong\x3e 语句\x3c\/h3\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,2,4,6]\nfor(var i = 0, len = arr.length; i \x3c len; i\x2b\x2b){\n    console.log(arr[i])\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = arr.length; i \x26lt; len; i\x2b\x2b){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr[i])\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是标准for循环的写法也是最传统的语句，字符串也支持，定义一个变量i作为索引，以跟踪访问的位置，len是数组的长度，条件就是i不能超过len。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\n\x3cstrong\x3e\x3ccode\x3eforEach\x3c\/code\x3e\x3c\/strong\x3e 语句\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eforEach\x3c\/code\x3e 方法对数组的每个元素执行一次提供的CALLBACK函数,forEach是一个数组方法，可以用来把一个函数套用在一个数组中的每个元素上，\x3ccode\x3eforEach\x3c\/code\x3e为每个数组元素执行callback函数只可用于数组.遍历一个数组让数组每个元素做一件事情.那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上)；不像map() 或者reduce() ，它总是返回 undefined值，并且不可链式调用。典型用例是在一个链的最后执行副作用。\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,5,8,9]\narr.forEach(function(item) {\n    console.log(item);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e]\narr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(item);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\n\x3cstrong\x3e\x3ccode\x3efor-in\x3c\/code\x3e\x3c\/strong\x3e 语句\x3c\/h3\x3e\n\x3cp\x3e一般会使用\x3ccode\x3efor-in\x3c\/code\x3e来遍历对象的属性的,不过属性需要 \x3cstrong\x3e\x3ccode\x3eenumerable\x3c\/code\x3e\x3c\/strong\x3e,才能被读取到.\x3cbr\x3e\x3ccode\x3efor-in\x3c\/code\x3e 循环只遍历可枚举属性。一般常用来遍历对象，包括非整数类型的名称和继承的那些原型链上面的属性也能被遍历。像 Array和 Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性就不能遍历了.\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj = {\n    name: \x27test\x27,\n    color: \x27red\x27,\n    day: \x27sunday\x27,\n    number: 5\n}\nfor (var key in obj) {\n    console.log(obj[key])\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eday\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sunday\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3enumber\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e obj) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj[key])\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\n\x3cstrong\x3e\x3ccode\x3efor-of\x3c\/code\x3e\x3c\/strong\x3e 语句 (ES 6)\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3efor-of\x3c\/code\x3e语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。只要是一个iterable的对象,就可以通过\x3ccode\x3efor-of\x3c\/code\x3e来迭代.\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [{name:\x27bb\x27},5,\x27test\x27]\nfor (item of arr) {\n    console.log(item)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [{\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27bb\x27\x3c\/span\x3e},\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (item \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e arr) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(item)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\n\x3ccode\x3efor-of\x3c\/code\x3e 和 \x3ccode\x3efor-in\x3c\/code\x3e 的区别\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3efor-in\x3c\/code\x3e 语句以原始插入顺序迭代对象的可枚举属性。\x3ccode\x3efor-in\x3c\/code\x3e会把继承链的对象属性都会遍历一遍,所以会更花时间.\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3efor-of\x3c\/code\x3e 语句只遍历可迭代对象的数据。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eOther 循环方法\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e\n\x3cstrong\x3e\x3ccode\x3emap\x3c\/code\x3e\x3c\/strong\x3e 方法 (不改变原数组)\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emap\x3c\/code\x3e 方法会给原数组中的每个元素都按顺序调用一次  callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。让数组通过某种计算产生一个新数组,影射成一个新的数组,\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,2,3]\nvar firearr = arr.map(current =\x3e current * 5)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e firearr = arr.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecurrent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e current * \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e\n\x3cstrong\x3e\x3ccode\x3ereduce\x3c\/code\x3e\x3c\/strong\x3e 方法\x3c\/h3\x3e\n\x3cp\x3e让数组中的前项和后项做某种计算,并累计最终值,\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var wallets = [4,7.8,3]\nvar totalMoney = wallets.reduce( function (countedMoney, wallet) {\n    return countedMoney \x2b wallet.money;\n}, 0)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e wallets = [\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e7.8\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e totalMoney = wallets.reduce( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecountedMoney, wallet\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e countedMoney \x2b wallet.money;\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e\n\x3cstrong\x3e\x3ccode\x3efilter\x3c\/code\x3e\x3c\/strong\x3e 方法 (不改变原数组)\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3efilter\x3c\/code\x3e 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。筛选出过滤出数组中符合条件的项,组成新数组.\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [2,3,4,5,6]\nvar morearr = arr.filter(function (number) {\n    return number \x3e 3\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e morearr = arr.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enumber\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e number \x26gt; \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e\n\x3cstrong\x3e\x3ccode\x3eevery\x3c\/code\x3e\x3c\/strong\x3e 方法\x3c\/h3\x3e\n\x3cp\x3eevery 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。检测数组中的每一项是否符合条件,如果每一项都符合条件,就会返回true,否则返回false,有点像遍历数组且操作callback。只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,2,3,4,5]\nvar result = arr.every(function (item, index) {\n    return item \x3e 0\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = arr.every(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eitem, index\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e item \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e\n\x3cstrong\x3e\x3ccode\x3esome\x3c\/code\x3e\x3c\/strong\x3e 方法\x3c\/h3\x3e\n\x3cp\x3esome 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。检查数组中是否有某些项符号条件,如果有一项就返回true,否则返回false,有点像遍历数组或者操作.\x3c\/p\x3e\n\x3cp\x3e代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,2,3,4,5]\nvar result = arr.some(function (item,index) {\n    return item \x3e 3\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = arr.some(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eitem,index\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e item \x26gt; \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e对比遍历速度\x3c\/h2\x3e\n\x3cp\x3e对比这里我使用了\x3ca href=\x22https:\/\/jsperf.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejsPerf平台\x3c\/a\x3e进行测试.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eJavaScritp loop 对比\x3c\/h3\x3e\n\x3cp\x3e我创建了两个数组进行对比,为什么要这样区别呢,因为不同类型的数组在javascript内存中保存的地址格式不一样,遍历的时候编辑器会根椐数组元素的类型长度计算,比如说如果数组里面全是Number类的,循环起来会比数组里面包含Number,String,Object混合型的会快,所以创建了两个数组,一个是全undefined数组,一个是混合型数组.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 一个是空数组\nvar nullarr = new Array(10000) \/\/ [undefined,undefined,...undefined]\n\n\/\/ 另一个带不同类型的数据的数组\nvar dataarr = []\nfor(var i = 0; i \x3c 10000; i\x2b\x2b){\n    if (i % 2 ===0) {\n        dataarr[i] = i.toString()\n    } else {\n        dataarr[i = i\n    }\n}\ndataarr \/\/ [1,\x272\x27,3...,10000]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个是空数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nullarr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [undefined,undefined,...undefined]\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 另一个带不同类型的数据的数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dataarr = []\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e; i\x2b\x2b){\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (i % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e ===\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        dataarr[i] = i.toString()\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        dataarr[i = i\n    }\n}\ndataarr \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1,\x272\x27,3...,10000]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e测试后发现有点奇怪直接检索空数组还是会比数据数组慢这是为什么呢奇怪?为了对比循环的一致性我只选其中带数据的数组\x3ccode\x3edataarr\x3c\/code\x3e进行测试.\x3c\/p\x3e\n\x3cp\x3e那我们对比一下 \x3ccode\x3efor\x3c\/code\x3e \x3ccode\x3efor len\x3c\/code\x3e \x3ccode\x3eforEach\x3c\/code\x3e \x3ccode\x3efor-in\x3c\/code\x3e \x3ccode\x3efor-of\x3c\/code\x3e \x3ccode\x3emap\x3c\/code\x3e \x3ccode\x3efilter\x3c\/code\x3e 循环的速度\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QTQ?w=1982\x26amp;h=1582\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QTQ?w=1982\x26amp;h=1582\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到 \x3ccode\x3efor\x3c\/code\x3e循环的速度是最快的,是最老的循环,也是优化得最好的,其次是\x3ccode\x3efor-of\x3c\/code\x3e这个是es6才新增的循环非常好用,最慢是\x3ccode\x3efor-in\x3c\/code\x3e我们可以作一下速度排序\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3efor\x3c\/code\x3e \x26gt; \x3ccode\x3efor-of\x3c\/code\x3e \x26gt; \x3ccode\x3eforEach\x3c\/code\x3e \x26gt; \x3ccode\x3efilter\x3c\/code\x3e \x26gt; \x3ccode\x3emap\x3c\/code\x3e \x26gt; \x3ccode\x3efor-in\x3c\/code\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这很明显处理大量循环数据的时候还是要使用古老\x3ccode\x3efor\x3c\/code\x3e循环效率最好,但也不是不使用\x3ccode\x3efor-in\x3c\/code\x3e,其实很多时候都要根据实际应该场景的,\x3ccode\x3efor-in\x3c\/code\x3e更多使用在遍历对象属性上面,\x3ccode\x3efor-in\x3c\/code\x3e在遍历的过程中还会遍历继承链,所以这就是它效率比较慢的原因,比如\x3ccode\x3emap\x3c\/code\x3e 速率不高,不过处理在Es6实现数组功能上面非常好用方便,轻松影射创建新数组.或者例如使用\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/iterator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cstrong\x3eIterator\x3c\/strong\x3e\x3c\/a\x3e属性也是行的,所以每个循环都有合适使用的地方.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e\n\x3ccode\x3eevery\x3c\/code\x3e 和 \x3ccode\x3esome\x3c\/code\x3e 不完全属于数组操作方法\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eevery\x3c\/code\x3e 和 \x3ccode\x3esome\x3c\/code\x3e 都是判断条件直接返回整个数组Boolean类型的方法.\x3ccode\x3eevery\x3c\/code\x3e速度会比\x3ccode\x3esome\x3c\/code\x3e快很多.\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QTY?w=2028\x26amp;h=794\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QTY?w=2028\x26amp;h=794\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e干货\x3c\/h3\x3e\n\x3cp\x3e一张图展示JavaScript数组方法 \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2QUd?w=1728\x26amp;h=1091\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2QUd?w=1728\x26amp;h=1091\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e最后\x3c\/h3\x3e\n\x3cp\x3e最后不同浏览器内核我相信会有些许差别,有兴趣的朋友可以去测试一下,有任何问题欢迎给博主留言.更多好文章请到我博客\x3ca href=\x22https:\/\/fe2x.cc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e 浏览哈。\x3c\/p\x3e\n\x3cp\x3e最后附上上面循环测试的 \x3ca href=\x22https:\/\/jsperf.com\/js-loop-compare\/1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e延伸阅读\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e迭代器(iterator) \x3ca href=\x22https:\/\/github.com\/sunyongjian\/blog\/issues\/18\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eJS几种数组遍历方式以及性能分析对比 \x3ca href=\x22https:\/\/dailc.github.io\/2016\/11\/25\/baseKnowlenge_javascript_jsarrayGoThrough\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e如何形象地解释 JavaScript 中 map、foreach、reduce 间的区别？ \x3ca href=\x22https:\/\/www.zhihu.com\/question\/24927450\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eFor-each over an array in JavaScript? \x3ca href=\x22https:\/\/stackoverflow.com\/questions\/9329446\/for-each-over-an-array-in-javascript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eJavaScript for循环性能比较 \x3ca href=\x22http:\/\/blog.mingsixue.com\/it\/JS-for-performance-compare.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e地址\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JS 数组循环遍历方法的对比</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013034098">https://segmentfault.com/a/1190000013034098</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jpc2qkbwkf/" target="_blank">https://alili.tech/archive/jpc2qkbwkf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>