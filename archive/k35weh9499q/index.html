<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Webpack原理-编写Plugin"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Webpack原理-编写Plugin | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/k35weh9499q/",
				"appid": "1613049289050283", 
				"title": "Webpack原理-编写Plugin | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-17T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zx48desk9ik/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/y2tlgaaylbf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&text=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&text=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&title=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&is_video=false&description=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&title=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&title=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&title=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk35weh9499q%2f&title=Webpack%e5%8e%9f%e7%90%86-%e7%bc%96%e5%86%99Plugin"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Webpack原理-编写Plugin</h1><div class="meta"><div class="postdate"><time datetime="2018-12-17" itemprop="datePublished">2018-12-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eWebpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。\x3cbr\x3e在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\x3c\/p\x3e\n\x3cp\x3e一个最基础的 Plugin 的代码是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class BasicPlugin{\n  \/\/ 在构造函数中获取用户给该插件传入的配置\n  constructor(options){\n  }\n  \n  \/\/ Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler){\n    compiler.plugin(\x27compilation\x27,function(compilation) {\n    })\n  }\n}\n\n\/\/ 导出 Plugin\nmodule.exports = BasicPlugin;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBasicPlugin\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在构造函数中获取用户给该插件传入的配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(options){\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\x3c\/span\x3e\n  apply(compiler){\n    compiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27compilation\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompilation\x3c\/span\x3e) \x3c\/span\x3e{\n    })\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出 Plugin\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = BasicPlugin;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在使用这个 Plugin 时，相关配置代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const BasicPlugin = require(\x27.\/BasicPlugin.js\x27);\nmodule.export = {\n  plugins:[\n    new BasicPlugin(options),\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e BasicPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/BasicPlugin.js\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.export = {\n  \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e:[\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e BasicPlugin(options),\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWebpack 启动后，在读取配置的过程中会先执行 \x3ccode\x3enew BasicPlugin(options)\x3c\/code\x3e 初始化一个 BasicPlugin 获得其实例。\x3cbr\x3e在初始化 compiler 对象后，再调用 \x3ccode\x3ebasicPlugin.apply(compiler)\x3c\/code\x3e 给插件实例传入 compiler 对象。\x3cbr\x3e插件实例在获取到 compiler 对象后，就可以通过 \x3ccode\x3ecompiler.plugin(事件名称, 回调函数)\x3c\/code\x3e 监听到 Webpack 广播出来的事件。\x3cbr\x3e并且可以通过 compiler 对象去操作 Webpack。\x3c\/p\x3e\n\x3cp\x3e通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eCompiler 和 Compilation\x3c\/h2\x3e\n\x3cp\x3e在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。\x3cbr\x3eCompiler 和 Compilation 的含义如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCompiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；\x3c\/li\x3e\n\x3cli\x3eCompilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eCompiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e事件流\x3c\/h2\x3e\n\x3cp\x3eWebpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。\x3cbr\x3e这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。\x3cbr\x3e插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。\x3c\/p\x3e\n\x3cp\x3eWebpack 通过 \x3ca href=\x22https:\/\/github.com\/webpack\/tapable\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTapable\x3c\/a\x3e 来组织这条复杂的生产线。\x3cbr\x3eWebpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。\x3cbr\x3eWebpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。\x3c\/p\x3e\n\x3cp\x3eWebpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。\x3cbr\x3eCompiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n* 广播出事件\n* event-name 为事件名称，注意不要和现有的事件重名\n* params 为附带的参数\n*\/\ncompiler.apply(\x27event-name\x27,params);\n\n\/**\n* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。\n* 同时函数中的 params 参数为广播事件时附带的参数。\n*\/\ncompiler.plugin(\x27event-name\x27,function(params) {\n  \n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n* 广播出事件\n* event-name 为事件名称，注意不要和现有的事件重名\n* params 为附带的参数\n*\/\x3c\/span\x3e\ncompiler.apply(\x3cspan class=\x22hljs-string\x22\x3e\x27event-name\x27\x3c\/span\x3e,params);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。\n* 同时函数中的 params 参数为广播事件时附带的参数。\n*\/\x3c\/span\x3e\ncompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27event-name\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparams\x3c\/span\x3e) \x3c\/span\x3e{\n  \n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同理，compilation.apply 和 compilation.plugin 使用方法和上面一致。\x3c\/p\x3e\n\x3cp\x3e在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。\x3c\/p\x3e\n\x3cp\x3e在开发插件时，还需要注意以下两点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。\x3c\/li\x3e\n\x3cli\x3e传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22compiler.plugin(\x27emit\x27,function(compilation, callback) {\n  \/\/ 支持处理逻辑\n\n  \/\/ 处理完毕后执行 callback 以通知 Webpack \n  \/\/ 如果不执行 callback，运行流程将会一直卡在这不往下执行 \n  callback();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27emit\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompilation, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 支持处理逻辑\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理完毕后执行 callback 以通知 Webpack \x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不执行 callback，运行流程将会一直卡在这不往下执行 \x3c\/span\x3e\n  callback();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e常用 API\x3c\/h2\x3e\n\x3cp\x3e插件可以用来修改输出文件、增加输出文件、甚至可以提升 Webpack 性能、等等，总之插件通过调用 Webpack 提供的 API 能完成很多事情。\x3cbr\x3e由于 Webpack 提供的 API 非常多，有很多 API 很少用的上，又加上篇幅有限，下面来介绍一些常用的 API。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e读取输出资源、代码块、模块及其依赖\x3c\/h3\x3e\n\x3cp\x3e有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eemit\x3c\/code\x3e 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。\x3cbr\x3e插件代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Plugin {\n  apply(compiler) {\n    compiler.plugin(\x27emit\x27, function (compilation, callback) {\n      \/\/ compilation.chunks 存放所有代码块，是一个数组\n      compilation.chunks.forEach(function (chunk) {\n        \/\/ chunk 代表一个代码块\n        \/\/ 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块\n        chunk.forEachModule(function (module) {\n          \/\/ module 代表一个模块\n          \/\/ module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组\n          module.fileDependencies.forEach(function (filepath) {\n          });\n        });\n\n        \/\/ Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件\n        \/\/ 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，\n        \/\/ 该 Chunk 就会生成 .js 和 .css 两个文件\n        chunk.files.forEach(function (filename) {\n          \/\/ compilation.assets 存放当前所有即将输出的资源\n          \/\/ 调用一个输出资源的 source() 方法能获取到输出资源的内容\n          let source = compilation.assets[filename].source();\n        });\n      });\n\n      \/\/ 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。\n      \/\/ 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。\n      callback();\n    })\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePlugin\x3c\/span\x3e \x3c\/span\x3e{\n  apply(compiler) {\n    compiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27emit\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecompilation, callback\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ compilation.chunks 存放所有代码块，是一个数组\x3c\/span\x3e\n      compilation.chunks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3echunk\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ chunk 代表一个代码块\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块\x3c\/span\x3e\n        chunk.forEachModule(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emodule\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ module 代表一个模块\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组\x3c\/span\x3e\n          \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.fileDependencies.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efilepath\x3c\/span\x3e) \x3c\/span\x3e{\n          });\n        });\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该 Chunk 就会生成 .js 和 .css 两个文件\x3c\/span\x3e\n        chunk.files.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efilename\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ compilation.assets 存放当前所有即将输出的资源\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用一个输出资源的 source() 方法能获取到输出资源的内容\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e source = compilation.assets[filename].source();\n        });\n      });\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。\x3c\/span\x3e\n      callback();\n    })\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e监听文件变化\x3c\/h3\x3e\n\x3cp\x3e在\x3ca\x3e4-5使用自动刷新\x3c\/a\x3e 中介绍过 Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时，\x3cbr\x3e就会触发一次新的 Compilation。\x3c\/p\x3e\n\x3cp\x3e在开发插件时经常需要知道是哪个文件发生变化导致了新的 Compilation，为此可以使用如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当依赖的文件发生变化时会触发 watch-run 事件\ncompiler.plugin(\x27watch-run\x27, (watching, callback) =\x3e {\n    \/\/ 获取发生变化的文件列表\n    const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;\n    \/\/ changedFiles 格式为键值对，键为发生变化的文件路径。\n    if (changedFiles[filePath] !== undefined) {\n      \/\/ filePath 对应的文件发生了变化\n    }\n    callback();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当依赖的文件发生变化时会触发 watch-run 事件\x3c\/span\x3e\ncompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27watch-run\x27\x3c\/span\x3e, (watching, callback) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取发生变化的文件列表\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ changedFiles 格式为键值对，键为发生变化的文件路径。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (changedFiles[filePath] !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ filePath 对应的文件发生了变化\x3c\/span\x3e\n    }\n    callback();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。\x3cbr\x3e由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。\x3cbr\x3e为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22compiler.plugin(\x27after-compile\x27, (compilation, callback) =\x3e {\n  \/\/ 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译\n    compilation.fileDependencies.push(filePath);\n    callback();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27after-compile\x27\x3c\/span\x3e, (compilation, callback) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译\x3c\/span\x3e\n    compilation.fileDependencies.push(filePath);\n    callback();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e修改输出资源\x3c\/h3\x3e\n\x3cp\x3e有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 \x3ccode\x3eemit\x3c\/code\x3e 事件，因为发生 \x3ccode\x3eemit\x3c\/code\x3e 事件时所有模块的转换和代码块对应的文件已经生成好，\x3cbr\x3e需要输出的资源即将输出，因此 \x3ccode\x3eemit\x3c\/code\x3e 事件是修改 Webpack 输出资源的最后时机。\x3c\/p\x3e\n\x3cp\x3e所有需要输出的资源会存放在 \x3ccode\x3ecompilation.assets\x3c\/code\x3e 中，\x3ccode\x3ecompilation.assets\x3c\/code\x3e 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。\x3c\/p\x3e\n\x3cp\x3e设置 \x3ccode\x3ecompilation.assets\x3c\/code\x3e 的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22compiler.plugin(\x27emit\x27, (compilation, callback) =\x3e {\n  \/\/ 设置名称为 fileName 的输出资源\n  compilation.assets[fileName] = {\n    \/\/ 返回文件内容\n    source: () =\x3e {\n      \/\/ fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer\n      return fileContent;\n      },\n    \/\/ 返回文件大小\n      size: () =\x3e {\n      return Buffer.byteLength(fileContent, \x27utf8\x27);\n    }\n  };\n  callback();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27emit\x27\x3c\/span\x3e, (compilation, callback) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置名称为 fileName 的输出资源\x3c\/span\x3e\n  compilation.assets[fileName] = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回文件内容\x3c\/span\x3e\n    source: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fileContent;\n      },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回文件大小\x3c\/span\x3e\n      size: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Buffer.byteLength(fileContent, \x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e);\n    }\n  };\n  callback();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e读取 \x3ccode\x3ecompilation.assets\x3c\/code\x3e 的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22compiler.plugin(\x27emit\x27, (compilation, callback) =\x3e {\n  \/\/ 读取名称为 fileName 的输出资源\n  const asset = compilation.assets[fileName];\n  \/\/ 获取输出资源的内容\n  asset.source();\n  \/\/ 获取输出资源的文件大小\n  asset.size();\n  callback();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecompiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27emit\x27\x3c\/span\x3e, (compilation, callback) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取名称为 fileName 的输出资源\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e asset = compilation.assets[fileName];\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取输出资源的内容\x3c\/span\x3e\n  asset.source();\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取输出资源的文件大小\x3c\/span\x3e\n  asset.size();\n  callback();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e判断 Webpack 使用了哪些插件\x3c\/h3\x3e\n\x3cp\x3e在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。\x3cbr\x3e以判断当前是否使用了 ExtractTextPlugin 为例，可以使用如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 判断当前配置使用使用了 ExtractTextPlugin，\n\/\/ compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数\nfunction hasExtractTextPlugin(compiler) {\n  \/\/ 当前配置所有使用的插件列表\n  const plugins = compiler.options.plugins;\n  \/\/ 去 plugins 中寻找有没有 ExtractTextPlugin 的实例\n  return plugins.find(plugin=\x3eplugin.__proto__.constructor === ExtractTextPlugin) != null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断当前配置使用使用了 ExtractTextPlugin，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehasExtractTextPlugin\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompiler\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前配置所有使用的插件列表\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e plugins = compiler.options.plugins;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去 plugins 中寻找有没有 ExtractTextPlugin 的实例\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e plugins.find(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eplugin\x3c\/span\x3e=\x26gt;\x3c\/span\x3eplugin.__proto__.constructor === ExtractTextPlugin) != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e实战\x3c\/h2\x3e\n\x3cp\x3e下面我们举一个实际的例子，带你一步步去实现一个插件。\x3c\/p\x3e\n\x3cp\x3e该插件的名称取名叫 EndWebpackPlugin，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。\x3cbr\x3e同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  plugins:[\n    \/\/ 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；\n    new EndWebpackPlugin(() =\x3e {\n      \/\/ Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作\n    }, (err) =\x3e {\n      \/\/ Webpack 构建失败，err 是导致错误的原因\n      console.error(err);        \n    })\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e:[\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EndWebpackPlugin(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作\x3c\/span\x3e\n    }, (err) =\x26gt; {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Webpack 构建失败，err 是导致错误的原因\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err);        \n    })\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e要实现该插件，需要借助两个事件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3edone\x3c\/strong\x3e：在成功构建并且输出了文件后，Webpack 即将退出时发生；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3efailed\x3c\/strong\x3e：在构建出现异常导致构建失败，Webpack 即将退出时发生；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实现该插件非常简单，完整代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class EndWebpackPlugin {\n\n  constructor(doneCallback, failCallback) {\n    \/\/ 存下在构造函数中传入的回调函数\n    this.doneCallback = doneCallback;\n    this.failCallback = failCallback;\n  }\n\n  apply(compiler) {\n    compiler.plugin(\x27done\x27, (stats) =\x3e {\n        \/\/ 在 done 事件中回调 doneCallback\n        this.doneCallback(stats);\n    });\n    compiler.plugin(\x27failed\x27, (err) =\x3e {\n        \/\/ 在 failed 事件中回调 failCallback\n        this.failCallback(err);\n    });\n  }\n}\n\/\/ 导出插件 \nmodule.exports = EndWebpackPlugin;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEndWebpackPlugin\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(doneCallback, failCallback) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 存下在构造函数中传入的回调函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doneCallback = doneCallback;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.failCallback = failCallback;\n  }\n\n  apply(compiler) {\n    compiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27done\x27\x3c\/span\x3e, (stats) =\x26gt; {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 done 事件中回调 doneCallback\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doneCallback(stats);\n    });\n    compiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x27failed\x27\x3c\/span\x3e, (err) =\x26gt; {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 failed 事件中回调 failCallback\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.failCallback(err);\n    });\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导出插件 \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = EndWebpackPlugin;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从开发这个插件可以看出，找到合适的事件点去完成功能在开发插件时显得尤为重要。\x3cbr\x3e在 \x3ca\x3e5-1工作原理概括\x3c\/a\x3e 中详细介绍过 Webpack 在运行过程中广播出常用事件，你可以从中找到你需要的事件。\x3c\/p\x3e\n\x3cblockquote\x3e本实例\x3ca href=\x22https:\/\/github.com\/gwuhaolin\/end-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e提供项目完整代码\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012544051?w=1348\x26amp;h=845\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012544051?w=1348\x26amp;h=845\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《深入浅出Webpack》全书在线阅读链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/5%E5%8E%9F%E7%90%86\/5-4%E7%BC%96%E5%86%99Plugin.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阅读原文\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Webpack原理-编写Plugin</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012840742">https://segmentfault.com/a/1190000012840742</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/k35weh9499q/" target="_blank">https://alili.tech/archive/k35weh9499q/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>