<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="HTTP面试指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>HTTP面试指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/kic4dva1cme/",
				"appid": "1613049289050283", 
				"title": "HTTP面试指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-03T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/yb53pyijqpg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2v0tq4tlwiy/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&text=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&text=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&title=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&is_video=false&description=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&title=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&title=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&title=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkic4dva1cme%2f&title=HTTP%e9%9d%a2%e8%af%95%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">HTTP面试指南</h1><div class="meta"><div class="postdate"><time datetime="2018-12-03" itemprop="datePublished">2018-12-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2\x3e前言\x3c\/h2\x3e\n\x3chr\x3e\n\x3cp\x3e或许你在面试时遇到过这样的问题：从输入URL到浏览器显示页面发生了什么？\x3cbr\x3e简单的回答就是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eDNS解析\x3c\/li\x3e\n\x3cli\x3eTCP建立连接\x3c\/li\x3e\n\x3cli\x3e发送HTTP请求\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e服务器处理请求\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果有缓存直接读缓存\x3c\/li\x3e\n\x3cli\x3e没有缓存返回响应内容\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3eTCP断开连接\x3c\/li\x3e\n\x3cli\x3e浏览器解析渲染页面\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如果你觉得这样回答过于简单，不如来深入了解一下吧。\x3c\/p\x3e\n\x3ch2\x3e网络基础\x3c\/h2\x3e\n\x3chr\x3e\n\x3cp\x3e在此之前，先了解一下TCP\/IP基础知识。\x3c\/p\x3e\n\x3ch3\x3eTCP\/IP参考模型\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579251?w=587\x26amp;h=314\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579251?w=587\x26amp;h=314\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e早期的TCP\/IP模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层，后来将网络接口层划分为了物理层和数据链路层\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e应用层(Application)提供网络与用户应用软件之间的接口服务\x3c\/li\x3e\n\x3cli\x3e传输层(Transimission)提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)    \x3cbr\x3e传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）\x3c\/li\x3e\n\x3cli\x3e网络层(Network)处理网络间路由，确保数据及时传送(路由器)\x3c\/li\x3e\n\x3cli\x3e数据链路层(DataLink)负责无错传输数据，确认帧、发错重传等(交换机)\x3c\/li\x3e\n\x3cli\x3e物理层(Physics)提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3\x3e各层常用协议\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579252?w=648\x26amp;h=455\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579252?w=648\x26amp;h=455\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里可以看到HTTP协议是构建于TCP之上，属于\x3cstrong\x3e应用层协议\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2\x3e具体过程\x3c\/h2\x3e\n\x3ch3\x3e1. DNS解析\x3c\/h3\x3e\n\x3cp\x3eDNS服务是和HTTP协议一样位于应用层的协议，提供域名到IP地址的解析服务。\x3c\/p\x3e\n\x3cp\x3e得到IP地址后就可以建立连接了，这里还有两个知识需要了解：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e持久连接\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e持久连接（也称为HTTP keep-alive）的特点是，只要任意一段没有提出断开连接，就保持TCP连接状态。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579253?w=598\x26amp;h=473\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579253?w=598\x26amp;h=473\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e管线化\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e持久连接建立后就可以使用管线化发送了，可以同时并发多个请求，不用等待一个接一个的响应。（在这里我想到了流的pipe方法。）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579254?w=587\x26amp;h=242\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579254?w=587\x26amp;h=242\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3\x3e2. TCP连接与断开\x3c\/h3\x3e\n\x3ch4\x3e2.1 TCP报文格式\x3c\/h4\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579255?w=559\x26amp;h=290\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579255?w=559\x26amp;h=290\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3cbr\x3e大致说一下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e计算机通过端口号识别访问哪个服务，比如http；源端口号进行随机端口，目的端口决定哪个程序进行接收\x3c\/li\x3e\n\x3cli\x3e数据序号和确认序号用于保障传输数据的完整性和顺序\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e需要注意的是TCP的连接、传输和断开都受六个控制位的指挥（比如三次握手和四次挥手）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ePSH（push急迫位）缓存区将满，立刻速度传输\x3c\/li\x3e\n\x3cli\x3eRST（reset重置位）连接断了重新连接\x3c\/li\x3e\n\x3cli\x3eURG（urgent紧急位）紧急信号\x3c\/li\x3e\n\x3cli\x3eACK（acknowlegement确认）\x3cstrong\x3e为1就表示确认号\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3eSYN（synchronous建立联机）\x3cstrong\x3e同步序号位 TCP建立连接时将这个值设为1\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e用户数据存储了应用层生成的HTTP报文\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e了解了这些，那么开始讲重点\x3c\/p\x3e\n\x3ch4\x3e2.2 TCP三次握手和四次挥手\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e三次握手\x3c\/strong\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579256?w=503\x26amp;h=376\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579256?w=503\x26amp;h=376\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e客户端先发送一个带SYN标志的数据包给服务器端\x3c\/li\x3e\n\x3cli\x3e服务器收到后，回传一个带有SYN\/ACK标志的数据包表示确认收到\x3c\/li\x3e\n\x3cli\x3e客户端再发送一个带SYN\/ACK标志的数据包，代表握手结束\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e四次挥手\x3c\/strong\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579257?w=353\x26amp;h=496\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579257?w=353\x26amp;h=496\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e客户端向服务器发出了FIN报文段\x3c\/li\x3e\n\x3cli\x3e服务器收到后，回复一个ACK应答\x3c\/li\x3e\n\x3cli\x3e服务器也向客户端发送一个FIN报文段，随后关闭了服务器端的连接\x3c\/li\x3e\n\x3cli\x3e客户端收到之后，又向服务器回复一个ACK应答，\x3cstrong\x3e过了一段计时等待\x3c\/strong\x3e，客户端也关闭了连接（计时等待是为了确认服务器端已正常关闭）\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e四次挥手并不是必然的，当服务器已经没有内容发给客户端了，就直接发送FIN报文段，这样就变成了三次挥手。\x3c\/blockquote\x3e\n\x3ch3\x3e3. HTTP请求\/响应\x3c\/h3\x3e\n\x3ch4\x3e3.1 HTTP报文\x3c\/h4\x3e\n\x3cp\x3eHTTP报文大致可分为报文首部和报文主体两块，两者由空行（就相当于用了两个换行符rnrn）来划分。报文主体并不是一定要有的。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579258?w=558\x26amp;h=163\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579258?w=558\x26amp;h=163\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e3.1.1 请求报文\x3c\/h4\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579259?w=594\x26amp;h=285\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579259?w=594\x26amp;h=285\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e常用请求行方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eGET 获取资源\x3c\/li\x3e\n\x3cli\x3ePOST 向服务器端发送数据，传输实体主体\x3c\/li\x3e\n\x3cli\x3ePUT 传输文件\x3c\/li\x3e\n\x3cli\x3eHEAD 获取报文首部\x3c\/li\x3e\n\x3cli\x3eDELETE 删除文件\x3c\/li\x3e\n\x3cli\x3eOPTIONS 询问支持的方法\x3c\/li\x3e\n\x3cli\x3eTRACE 追踪路径\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e3.1.2 响应报文\x3c\/h4\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579260?w=503\x26amp;h=270\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579260?w=503\x26amp;h=270\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e说到响应报文，就必要谈到状态码：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e2XX 成功\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e200(OK) 客户端发过来的数据被正常处理\x3c\/li\x3e\n\x3cli\x3e204(Not Content) 正常响应，没有实体\x3c\/li\x3e\n\x3cli\x3e206(Partial Content) 范围请求，返回部分数据，响应报文中由Content-Range指定实体内容\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e3XX 重定向\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e301(Moved Permanently) 永久重定向\x3c\/li\x3e\n\x3cli\x3e302(Found) 临时重定向，规范要求方法名不变，但是都会改变\x3c\/li\x3e\n\x3cli\x3e303(See Other) 和302类似，但必须用GET方法\x3c\/li\x3e\n\x3cli\x3e304(Not Modified) 状态未改变 配合(If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since)  (通常缓存会返回304状态码)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e4XX 客户端错误\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e400(Bad Request) 请求报文语法错误\x3c\/li\x3e\n\x3cli\x3e401 (unauthorized) 需要认证\x3c\/li\x3e\n\x3cli\x3e403(Forbidden) 服务器拒绝访问对应的资源\x3c\/li\x3e\n\x3cli\x3e404(Not Found) 服务器上无法找到资源\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e5XX 服务器端错误\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e500(Internal Server Error) 服务器故障\x3c\/li\x3e\n\x3cli\x3e503(Service Unavailable) 服务器处于超负载或正在停机维护\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e3.1.3 首部\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e通用首部\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3cth\x3e首部字段名\x3c\/th\x3e\n        \x3cth\x3e说明\x3c\/th\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eCache-Control\x3c\/td\x3e\n        \x3ctd\x3e控制缓存行为\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eConnection\x3c\/td\x3e\n        \x3ctd\x3e连接的管理\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eDate\x3c\/td\x3e\n        \x3ctd\x3e报文日期\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ePragma\x3c\/td\x3e\n        \x3ctd\x3e报文指令\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eTrailer\x3c\/td\x3e\n        \x3ctd\x3e报文尾部的首部\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eTrasfer-Encoding\x3c\/td\x3e\n        \x3ctd\x3e指定报文主体的传输编码方式\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eUpgrade\x3c\/td\x3e\n        \x3ctd\x3e升级为其他协议\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eVia\x3c\/td\x3e\n        \x3ctd\x3e代理服务器信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eWarning\x3c\/td\x3e\n        \x3ctd\x3e错误通知\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3c\/tbody\x3e\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e请求首部\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3cth\x3e首部字段名\x3c\/th\x3e\n        \x3cth\x3e说明\x3c\/th\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAccept\x3c\/td\x3e\n        \x3ctd\x3e用户代理可处理的媒体类型\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAccept-Charset\x3c\/td\x3e\n        \x3ctd\x3e优先的字符集\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAccept-Encoding\x3c\/td\x3e\n        \x3ctd\x3e优先的编码\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAccept-Langulage\x3c\/td\x3e\n        \x3ctd\x3e优先的语言\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAuthorization\x3c\/td\x3e\n        \x3ctd\x3eWeb认证信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eExpect\x3c\/td\x3e\n        \x3ctd\x3e期待服务器的特定行为\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eFrom\x3c\/td\x3e\n        \x3ctd\x3e用户的电子邮箱地址\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eHost\x3c\/td\x3e\n        \x3ctd\x3e请求资源所在的服务器\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eIf-Match\x3c\/td\x3e\n        \x3ctd\x3e比较实体标记\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eIf-Modified-Since\x3c\/td\x3e\n        \x3ctd\x3e比较资源的更新时间\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eIf-None-Match\x3c\/td\x3e\n        \x3ctd\x3e比较实体标记\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eIf-Range\x3c\/td\x3e\n        \x3ctd\x3e资源未更新时发送实体Byte的范围请求\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eIf-Unmodified-Since\x3c\/td\x3e\n        \x3ctd\x3e比较资源的更新时间(和If-Modified-Since相反)\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eMax-Forwards\x3c\/td\x3e\n        \x3ctd\x3e最大传输条数\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eProxy-Authorization\x3c\/td\x3e\n        \x3ctd\x3e代理服务器需要客户端认证\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eRange\x3c\/td\x3e\n        \x3ctd\x3e实体字节范围请求\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eReferer\x3c\/td\x3e\n        \x3ctd\x3e请求中的URI的原始获取方\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eTE\x3c\/td\x3e\n        \x3ctd\x3e传输编码的优先级\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eUser-Agent\x3c\/td\x3e\n        \x3ctd\x3eHTTP客户端程序的信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3c\/tbody\x3e\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e响应首部\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3cth\x3e首部字段名\x3c\/th\x3e\n        \x3cth\x3e说明\x3c\/th\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAccept-Ranges\x3c\/td\x3e\n        \x3ctd\x3e是否接受字节范围\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAge\x3c\/td\x3e\n        \x3ctd\x3e资源的创建时间\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eETag\x3c\/td\x3e\n        \x3ctd\x3e资源的匹配信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eLocation\x3c\/td\x3e\n        \x3ctd\x3e客户端重定向至指定的URI\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eProxy-Authenticate\x3c\/td\x3e\n        \x3ctd\x3e代理服务器对客户端的认证信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eRetry-After\x3c\/td\x3e\n        \x3ctd\x3e再次发送请求的时机\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eServer\x3c\/td\x3e\n        \x3ctd\x3e服务器的信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eVary\x3c\/td\x3e\n        \x3ctd\x3e代理服务器缓存的管理信息\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ewww-Authenticate\x3c\/td\x3e\n        \x3ctd\x3e服务器对客户端的认证\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3c\/tbody\x3e\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e实体首部\x3c\/strong\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3cth\x3e首部字段名\x3c\/th\x3e\n        \x3cth\x3e说明\x3c\/th\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eAllow\x3c\/td\x3e\n        \x3ctd\x3e资源可支持的HTTP方法\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Encoding\x3c\/td\x3e\n        \x3ctd\x3e实体的编码方式\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Language\x3c\/td\x3e\n        \x3ctd\x3e实体的自然语言\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Length\x3c\/td\x3e\n        \x3ctd\x3e实体的内容大小(字节为单位)\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Location\x3c\/td\x3e\n        \x3ctd\x3e替代对应资源的URI\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-MD5\x3c\/td\x3e\n        \x3ctd\x3e实体的报文摘要\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Range\x3c\/td\x3e\n        \x3ctd\x3e实体的位置范围\n\n\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eContent-Type\x3c\/td\x3e\n        \x3ctd\x3e实体主体的媒体类型\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eExpires\x3c\/td\x3e\n        \x3ctd\x3e实体过期时间\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eLast-Modified\x3c\/td\x3e\n        \x3ctd\x3e资源的最后修改时间\x3c\/td\x3e\n    \x3c\/tr\x3e\n\x3c\/tbody\x3e\x3c\/table\x3e\n\x3ch4\x3e3.2 实现客户端访问服务端\x3c\/h4\x3e\n\x3cp\x3e创建HTTP服务端\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3elet http = require(\x27http\x27);\nlet app = http.createServer((req, res) =\x26gt; {\/\/ req是可读流\/res是可写流\n    \/\/ 获取请求报文信息\n    let method = req.method;\/\/ 方法\n    let httpVersion = req.httpVersion;\/\/ HTTP版本\n    let url = req.url;\n    let headers = req.headers;\n    console.log(method, httpVersion, url, headers);\n    \/\/ 获取请求体（如果请求体的数据大于64k，data事件会被触发多次）\n    let buffers = [];\n    req.on(\x27data\x27, data =\x26gt; {\n        buffers.push(data);\n    })\n    req.on(\x27end\x27, () =\x26gt; {\n        console.log(Buffer.concat(buffers).toString());\n        res.write(\x27hello\x27);\n        res.end(\x27world\x27);\n    })\n})\n\/\/ 监听服务器事件\napp.on(\x27connection\x27, socket =\x26gt; {\n    console.log(\x27建立连接\x27);\n});\napp.on(\x27close\x27, () =\x26gt; {\n    console.log(\x27服务器关闭\x27)\n});\napp.on(\x27error\x27, err =\x26gt; {\n    console.log(err);\n});\napp.listen(3000, () =\x26gt; {\n    console.log(\x27server is starting on port 3000\x27);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建客户端\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3elet http = require(\x27http\x27);\nlet options = {\n    hostname: \x27localhost\x27,\n    port: 3000,\n    path: \x27\/\x27,\n    method: \x27GET\x27,\n    \/\/ 设置实体首部 告诉服务端我当前要给你发什么样的数据\n    headers: {\n        \x27content-Type\x27: \x27application\/x-www-form-urlencoded\x27,\n        \x27Content-Length\x27: 15\n    }\n}\nlet req = http.request(options);\nreq.on(\x27response\x27, res =\x26gt; {\n    res.on(\x27data\x27, chunk =\x26gt; {\n        console.log(chunk.toString());\n    });\n});\nreq.end(\x27name=js\x26amp;\x26amp;age=22\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后使用node运行我们的客户端\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579261?w=654\x26amp;h=297\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579261?w=654\x26amp;h=297\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e说了这么多，你可能已经大致了解了   \x3cbr\x3e从输入URL到浏览器显示页面发生了什么，不用多说，我们再来看一下\x3cstrong\x3e缓存\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3\x3e4. 缓存\x3c\/h3\x3e\n\x3ch4\x3e4.1 缓存作用\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e减少了冗余的数据传输，节省了网费。\x3c\/li\x3e\n\x3cli\x3e减少了服务器的负担， 大大提高了网站的性能\x3c\/li\x3e\n\x3cli\x3e加快了客户端加载网页的速度\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e4.2 缓存分类\x3c\/h4\x3e\n\x3ch5\x3e强制缓存\x3c\/h5\x3e\n\x3cp\x3e强制缓存：说白了就是第一次请求数据时，服务端将数据和缓存规则一并返回，下一次请求时浏览器直接根据缓存规则进行判断，有就直接读缓存数据库，不用连接服务器；没有，再去找服务器。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579262?w=865\x26amp;h=332\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579262?w=865\x26amp;h=332\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch5\x3e对比缓存\x3c\/h5\x3e\n\x3cul\x3e\n\x3cli\x3e对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。\x3c\/li\x3e\n\x3cli\x3e浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。\x3c\/li\x3e\n\x3cli\x3e再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知* 客户端比较成功，可以使用缓存数据。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579263?w=947\x26amp;h=340\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579263?w=947\x26amp;h=340\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e4.3 请求流程\x3c\/h4\x3e\n\x3ch5\x3e第一次请求，此时没有缓存\x3c\/h5\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579264?w=501\x26amp;h=412\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579264?w=501\x26amp;h=412\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch5\x3e第二次请求\x3c\/h5\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014579265?w=1112\x26amp;h=663\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014579265?w=1112\x26amp;h=663\x22 alt=\x22\x22 title=\x22\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从上张图我们可以看到，判断缓存是否可用，有两种方式\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eETag是实体标签的缩写，根据实体内容生成的一段hash字符串,可以标识资源的状态。当资源发生改变时，ETag也随之发生变化。ETag是Web服务端产生的，然后发给浏览器客户端。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eLast-Modified是此资源的最后修改时间，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果客户端在请求到的资源中发现实体首部里有Last-Modified声明，再次请求就会在头里带上if-Modified-Since字段\x3c\/li\x3e\n\x3cli\x3e服务端收到请求后发现if-Modified-Since字段则与被请求资源的最后修改时间进行对比\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e说了这么多，不如直接来实现一下缓存\x3cbr\x3e\x3cbr\x3e\x3cstrong\x3e通过最后修改时间来判断缓存是否可用\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3elet http = require(\x27http\x27);\nlet url = require(\x27url\x27);\nlet path = require(\x27path\x27);\nlet fs = require(\x27fs\x27);\nlet mime = require(\x27mime\x27);\nlet app = http.createServer((req, res) =\x26gt; {\n    \/\/ 根据url获取客户端要请求的文件路径\n    let { parsename } = url.parse(req.url);\n    let p = path.join(__dirname, \x27public\x27, \x27.\x27 \x2b pathname);\n    \/\/ fs.stat()用来读取文件信息，文件最后修改时间就是stat.ctime\n    fs.stat(p, (err, stat) =\x26gt; {\n        if (!err) {\n            let since = req.headers[\x27if-modified-since\x27];\/\/客户端发来的文件最后修改时间\n            if (since) {\n                if (since === stat.ctime.toUTCString()) {\/\/最后修改时间相等，读缓存\n                    res.statusCode = 304;\n                    res.end();\n                } else {\n                    sendFile(req, res, p, stat);\/\/最后修改时间不相等，返回新内容\n                }\n            } else {\n                sendError(res);\n            }\n        }\n    })\n})\nfunction sendError(res) {\n    res.statusCode = 404;\n    res.end();\n}\nfunction sendFile(req, res, p, stat) {\n    res.setHeader(\x27Cache-Control\x27, \x27no-cache\x27);\/\/ 设置通用首部字段 控制缓存行为\n    res.setHeader(\x27Last-Modified\x27, stat.ctime.toUTCString());\/\/ 实体首部字段 资源最后修改时间\n    res.setHeader(\x27Content-Type\x27, mime.getType(p) \x2b \x27;charset=utf8\x27)\n    fs.createReadStream(p).pipe(res);\n}\napp.listen(3000, () =\x26gt; {\n    console.log(\x27server is starting on port 3000\x27);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e最后修改时间存在问题:\x3c\/strong\x3e\x3cbr\x3e1. 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。\x3cbr\x3e2. 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。\x3cbr\x3e3. 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。\x3cbr\x3e4. 如果同样的一个文件位于多个CDN服务器上的时候内容虽然一样，修改时间不一样。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e通过ETag来判断缓存是否可用\x3c\/strong\x3e\x3cbr\x3e\x3cbr\x3eETag就是根据文件内容来判断，说白了就是采用MD5（md5并不叫加密算法，它不可逆，应该叫摘要算法）产生信息摘要，用摘要来进行比对。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3elet http = require(\x27http\x27);\nlet url = require(\x27url\x27);\nlet path = require(\x27path\x27);\nlet fs = require(\x27fs\x27);\nlet mime = require(\x27mime\x27);\n\/\/ crypto是node.js中实现加密和解密的模块 具体详解请自行了解\nlet crypto = require(\x27crypto\x27);\nlet app = http.createServer((req, res) =\x26gt; {\n    \/\/ 根据url获取客户端要请求的文件路径\n    let { parsename } = url.parse(req.url);\n    let p = path.join(__dirname, \x27public\x27, \x27.\x27 \x2b pathname);\n    \/\/ fs.stat()用来读取文件信息，文件最后修改时间就是stat.ctime\n    fs.stat(p, (err, stat) =\x26gt; {\n        let md5 = crypto.createHash(\x27md5\x27);\/\/创建md5对象\n        let rs = fs.createReadStream(p);\n        rs.on(\x27data\x27, function (data) {\n            md5.update(data);\n        });\n        rs.on(\x27end\x27, () =\x26gt; {\n            let r = md5.digest(\x27hex\x27); \/\/ 对文件进行md5加密\n            \/\/ 下次就拿最新文件的加密值 和客户端请求来比较\n            let ifNoneMatch = req.headers[\x27if-none-match\x27];\n            if (ifNoneMatch) {\n                if (ifNoneMatch === r) {\n                    res.statusCode = 304;\n                    res.end();\n                } else {\n                    sendFile(req, res, p, r);\n                }\n            } else {\n                sendFile(req, res, p, r);\n            }\n        });\n    })\n});\nfunction sendError(res) {\n    res.statusCode = 404;\n    res.end();\n}\nfunction sendFile(req, res, p, stat) {\n    res.setHeader(\x27Cache-Control\x27, \x27no-cache\x27);\/\/ 设置通用首部字段 控制缓存行为\n    res.setHeader(\x27Etag\x27, r);\/\/ 响应首部字段 资源的匹配信息\n    res.setHeader(\x27Content-Type\x27, mime.getType(p) \x2b \x27;charset=utf8\x27)\n    fs.createReadStream(p).pipe(res);\n}\napp.listen(3000, () =\x26gt; {\n    console.log(\x27server is starting on port 3000\x27);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e最后\x3c\/h2\x3e\n\x3cp\x3e想深入学习http的同学，我推荐一本书\x3ca href=\x22https:\/\/book.douban.com\/subject\/25863515\/\x22 rel=\x22nofollow noreferrer\x22\x3e《图解HTTP》\x3c\/a\x3e。\x3cbr\x3e本人水平有限，有不足之处，望大家指出改正。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>HTTP面试指南</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014579248">https://segmentfault.com/a/1190000014579248</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/kic4dva1cme/" target="_blank">https://alili.tech/archive/kic4dva1cme/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>