<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="漫谈 React 组件库开发（一）：多层嵌套弹层组件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>漫谈 React 组件库开发（一）：多层嵌套弹层组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/kn9lo2v6ay/",
				"appid": "1613049289050283", 
				"title": "漫谈 React 组件库开发（一）：多层嵌套弹层组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zijyzbgbiu/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4jc207ky6iq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&text=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&text=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&title=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&is_video=false&description=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&title=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&title=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&title=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkn9lo2v6ay%2f&title=%e6%bc%ab%e8%b0%88%20React%20%e7%bb%84%e4%bb%b6%e5%ba%93%e5%bc%80%e5%8f%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a4%9a%e5%b1%82%e5%b5%8c%e5%a5%97%e5%bc%b9%e5%b1%82%e7%bb%84%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">漫谈 React 组件库开发（一）：多层嵌套弹层组件</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e引言\x3c\/h2\x3e\n\x3cp\x3eUI 组件中有很多弹出式组件，常见的如 \x3ccode\x3eDialog\x3c\/code\x3e，\x3ccode\x3eTooltip\x3c\/code\x3e 以及 \x3ccode\x3eSelect\x3c\/code\x3e 等。这些组件都有一个特点，它们的弹出层通常不是渲染在当前的 DOM 树中，而是直接插入在 \x3ccode\x3ebody\x3c\/code\x3e （或者其它类似的地方）上的。这么做的主要目的是方便控制这些弹出层的 \x3ccode\x3ez-index\x3c\/code\x3e ，确保它们能够处于合适的层级上，不至于被遮挡。\x3c\/p\x3e\n\x3cp\x3e我们都知道 React App 的顶层某个地方肯定有这么一行代码：\x3ccode\x3eReactDOM.render(\x26lt;App \/\x26gt;, mountNode)\x3c\/code\x3e，这个 API 调用的作用是在 \x3ccode\x3emountNode\x3c\/code\x3e 的位置创建一棵 React 的渲染树，React 会接管 \x3ccode\x3emountNode\x3c\/code\x3e 开始的这棵 DOM 树。\x3c\/p\x3e\n\x3cp\x3e在 React 的这种管理模式下，会发现使用弹层似乎不太方便，因为组件树是逐层往下生长的，但React 的 API 中并没有直接提供跳出这棵组件树的方法\x3cem\x3e[注1]\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e所以，为了实现弹层组件，我们需要先实现一个 \x3ccode\x3ePortal\x3c\/code\x3e 组件（玩游戏的都知道，这是传送门的意思），这个组件只做一件事：将组件树中某些节点移出当前的DOM 树，并且渲染到指定的 DOM 节点中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ePortal 组件\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ePortal\x3c\/code\x3e 组件的要做的事情很简单，\x3ccode\x3erender\x3c\/code\x3e 函数因为不需要在当前位置输出任何东西，所以直接返回 \x3ccode\x3enull\x3c\/code\x3e 就可以了，剩下的就是在组件的生命周期中去手动管理要渲染到指定位置的那些组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 简化的 Portal 实现\nclass Portal extends Component {\n  static propTypes = {\n    children: PropTypes.node.isRequired,\n    container: PropTypes.object.isRequired\n  };\n\n  render() {\n    return null;\n  }\n\n  componentDidMount() {\n    const { children, container } = this.props;\n    mountChildrenAtNode(children, container);\n  }\n\n  componentWillUnmount() {\n    const { container } = this.props;\n    unmountChildrenAtNode(container);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 简化的 Portal 实现\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePortal\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  static propTypes = {\n    children: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.node.isRequired,\n    container: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eobject\x3c\/span\x3e.isRequired\n  };\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n\n  componentDidMount() {\n    const { children, container } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    mountChildrenAtNode(children, container);\n  }\n\n  componentWillUnmount() {\n    const { container } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    unmountChildrenAtNode(container);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e剩下唯一的问题是  \x3ccode\x3emountChildrenAtNode\x3c\/code\x3e 这个函数怎么实现？仔细的同学应该已经发现了，这个函数和 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 非常像，仔细一想，其实它们做的事情就是一样的。所以我们直接用 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 去替换 \x3ccode\x3emountChildrenAtNode\x3c\/code\x3e 就可以了。\x3c\/p\x3e\n\x3cp\x3e那么真的这么简单吗？\x3c\/p\x3e\n\x3cp\x3e是，但也不是。\x3c\/p\x3e\n\x3cp\x3e说是，是因为逻辑上这代码并没有什么问题，而且大部分场景下是确实可以完美工作。\x3c\/p\x3e\n\x3cp\x3e说不是，是因为剩下的小部分场景下这段代码确实存在很严重的问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e那么问题是什么呢？\x3c\/h3\x3e\n\x3cp\x3e别急，我们先聊点别的。\x3c\/p\x3e\n\x3cp\x3e相信大部分 React 开发者都用过 redux（至少听过吧），\x3ccode\x3ereact-redux\x3c\/code\x3e 这个 binding 库提供了连接 React 和 redux 的一个桥梁。\x3ccode\x3ereact-redux\x3c\/code\x3e 的实现依赖 React 很有用的一个功能\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/context.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eContext\x3c\/code\x3e\x3c\/a\x3e，简单来说 \x3ccode\x3econtext\x3c\/code\x3e 就是提供了一个方便的跨越层级往下传递数据的方式。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eReactDOM.render\x3c\/code\x3e 的问题正是在于这个 \x3ccode\x3econtext\x3c\/code\x3e 的功能，它无法连接两棵 React 组件树的 \x3ccode\x3econtext\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eReactDOM.render\x3c\/code\x3e 的函数原型中并没有当前组件树的信息，而 \x3ccode\x3econtext\x3c\/code\x3e 是跟组件树有关的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ReactDOM.render(\n  element,\n  container,\n  [callback]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReactDOM\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.render\x3c\/span\x3e(\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eelement\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-tag\x22\x3econtainer\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[callback]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解决这个问题的方法也很简单，这里也不卖关子了，React 提供了另一个非公开 API：\x3ccode\x3eReactDOM.unstable_renderSubtreeIntoContainer\x3c\/code\x3e。这个 API 多了一个参数，这个参数就是用来指定新的 React 组件树根节点的父组件的，有了这个参数，两棵本来互不相干的 React 组件树就被联系起来了，同时它们的 \x3ccode\x3econtext\x3c\/code\x3e 也连接了起来。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ReactDOM.unstable_renderSubtreeIntoContainer(\n  parentComponent,\n  element,\n  container,\n  [callback]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReactDOM\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.unstable_renderSubtreeIntoContainer\x3c\/span\x3e(\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eparentComponent\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eelement\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-tag\x22\x3econtainer\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[callback]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e想更好的了解  \x3ccode\x3eContext\x3c\/code\x3e  的同学可以自己 Google，这不是本文重点，这里不做展开了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3ePortal 组件的可扩展性\x3c\/h2\x3e\n\x3cp\x3e不同的 UI 组件对弹层可能会有不同的功能需求，举个例子， \x3ccode\x3eDialog\x3c\/code\x3e 组件需要在弹出的时候禁止页面滚动，同时有些场景下需要支持点击背景部分关闭，或者按 ESC 键关闭。\x3c\/p\x3e\n\x3cp\x3e这些很细节的功能点往往会出现需要不同组合的使用场景，例如只需要禁止滚动，或者同时需要禁止滚动和 ESC 键关闭。\x3c\/p\x3e\n\x3cp\x3e一个很自然的想法是在 \x3ccode\x3ePortal\x3c\/code\x3e 组件上加几个可配置的 props 来控制这些功能。这么做有个问题，不管用户需不需要，代码都在那里。\x3c\/p\x3e\n\x3cp\x3e更好的方式是通过高阶组件(HOC)的方式让使用者自己去组合这些功能，这样子没有用到的功能并不会出现在最终的代码中。\x3c\/p\x3e\n\x3cp\x3e说了这么多关于 \x3ccode\x3ePortal\x3c\/code\x3e 组件的实现细节，有兴趣的同学可以去看看有赞的组件库 \x3ca href=\x22https:\/\/github.com\/youzan\/zent\/tree\/master\/packages\/zent\/src\/portal\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 里面的 \x3ccode\x3ePortal\x3c\/code\x3e 是如何实现的，大体上就是按上面说的那些方案做的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e弹层组件\x3c\/h2\x3e\n\x3cp\x3e有了 \x3ccode\x3ePortal\x3c\/code\x3e 组件之后，基本上所有弹层组件都可以基于 \x3ccode\x3ePortal\x3c\/code\x3e 去实现。例如 \x3ccode\x3eDialog\x3c\/code\x3e 无非就是在 \x3ccode\x3ePortal\x3c\/code\x3e 组件的基础上加了一些 CSS 样式。复杂一点的组件例如 \x3ccode\x3eSelect\x3c\/code\x3e，需要实现一些触发逻辑来控制弹层的打开和关闭，比如 \x3ccode\x3eclick\x3c\/code\x3e 打开或者 \x3ccode\x3ehover\x3c\/code\x3e  打开。我们接下来要讨论的弹层组件正是特指类似 \x3ccode\x3eSelect\x3c\/code\x3e 中的这些弹层。\x3c\/p\x3e\n\x3cp\x3e在 \x3ca href=\x22https:\/\/github.com\/youzan\/zent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 里面有一个叫 \x3ccode\x3ePopover\x3c\/code\x3e 的组件来处理这些复杂的弹层场景，\x3ccode\x3ePopover\x3c\/code\x3e 封装了常用的触发逻辑，例如 \x3ccode\x3eclick\x3c\/code\x3e, \x3ccode\x3ehover\x3c\/code\x3e, \x3ccode\x3efocus\x3c\/code\x3e，同时 \x3ccode\x3ePopover\x3c\/code\x3e 的触发机制是可扩展的，使用者可以实现自己的触发逻辑。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ePopover\x3c\/code\x3e 组件提供的另外一个重要功能是弹层的定位能力，也就是相对于 Trigger 的一个定位功能。除了内置的十几种定位算法，使用者可以实现自己的定位算法来实现特殊场景下的需求。\x3c\/p\x3e\n\x3cp\x3e有了 \x3ccode\x3ePopover\x3c\/code\x3e 组件提供的触发逻辑以及弹层定位这两个功能之后，类似 \x3ccode\x3eTooltip\x3c\/code\x3e , \x3ccode\x3eSelect\x3c\/code\x3e 这样的组件在实现时就完全不需要关心弹层的事了，只需要实现弹层内的组件逻辑就行了。\x3c\/p\x3e\n\x3cp\x3e这里已经能够看出一个层次化的弹层组件设计了：\x3ccode\x3ePortal\x3c\/code\x3e 负责脱离组件树，\x3ccode\x3ePopover\x3c\/code\x3e 在 \x3ccode\x3ePortal\x3c\/code\x3e 的基础上提供了更丰富的功能逻辑，其它组件又在 \x3ccode\x3ePopover\x3c\/code\x3e 的基础上去做封装。这样一种层次结构在实践中大大降低了各类弹层组件的实现和维护成本。\x3c\/p\x3e\n\x3cp\x3e在组件库的设计中，这种对能力的抽象封装是很重要的，在提高开发效率的同时也保证了各个组件行为的一致性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e干货：弹层组件的嵌套处理\x3c\/h2\x3e\n\x3cp\x3e上面介绍的弹层组件实现细节上并没有特别之处，成熟的组件库基本都是用类似方式实现的。但是 \x3ca href=\x22https:\/\/github.com\/youzan\/zent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 的 \x3ccode\x3ePopover\x3c\/code\x3e 组件实现了一个大多数 React 组件库都没有实现的功能：弹层的嵌套处理。\x3c\/p\x3e\n\x3cp\x3e如果你还没有明白这里的弹层嵌套是什么意思，没关系，给你举个例子就明白了。\x3c\/p\x3e\n\x3cp\x3e如下图，点击按钮之后会弹出一个气泡，这个气泡中又有一个时间选择器，所谓的弹层嵌套指的就是这种弹层之中又嵌了弹层的场景。正常的操作逻辑是鼠标点击位置1的时候气泡和时间选择器同时关闭，但是点击位置2的时候应该只有时间选择器关闭。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011059709\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011059709\x22 alt=\x22popover overlap\x22 title=\x22popover overlap\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面提到的点击两个不同位置的不同行为其实就是弹层嵌套最主要的问题：上级的弹层组件应该知道哪个区域是属于下级弹层组件的。\x3c\/p\x3e\n\x3cp\x3e由于弹层组件的特殊性，它们在 DOM 树中的位置跟它们实际的层次以及包含关系是没有必然联系的，上图中的两个弹层是\x3ccode\x3ebody\x3c\/code\x3e 下面的两个兄弟节点，但从弹层的角度看它们是有层次关系的，并不是并列的。\x3c\/p\x3e\n\x3cp\x3e通常来说，弹层的层次结构也是一个树状结构，那么处理嵌套问题最直接的想法就是每个弹层组件都各自维护一个子弹层的列表。当需要判断点击是否在弹层外面时，不光要考虑当前弹层对应的 DOM 节点，还要考虑它的下级弹层对应的 DOM 节点。\x3c\/p\x3e\n\x3cp\x3e这种方式处理的话需要手动维护这棵弹层的层级关系树，包括树中节点的插入／删除，这些操作都不是很难。这个方法最大的问题在于，在 React 的体系内一个弹层组件很难跟不是它直接孩子(direct child)的子弹层交互。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/youzan\/zent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 的 \x3ccode\x3ePopover\x3c\/code\x3e 组件并没有直接去维护这棵层级关系树，而是利用了 React 中 \x3ccode\x3econtext\x3c\/code\x3e 的层级关系来避免自己去维护这棵树。使用 \x3ccode\x3econtext\x3c\/code\x3e 的另一个附带好处是，和非直接孩子的交互也不再是问题，因为 \x3ccode\x3econtext\x3c\/code\x3e 本身就是可以跨层级传递信息的。\x3ccode\x3ePopover\x3c\/code\x3e 的层级管理结构示意图如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 *                context                       context\n *                ------\x3e                       ------\x3e\n * Popover Root               Popover child                    Popover grand-child     ......\n *                \x3c------                       \x3c------\n *             isOutsideQuery                isOutsideQuery\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e *                context                       context\n *                ------\x26gt;                       ------\x26gt;\n * Popover Root               Popover child                    Popover grand-child     ......\n *                \x26lt;------                       \x26lt;------\n *             isOutsideQuery                isOutsideQuery\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就是这么一个很简单的设计解决了 \x3ca href=\x22https:\/\/github.com\/youzan\/zent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 中弹层组件的层级嵌套问题，想了解实现细节的同学可以看 \x3ca href=\x22https:\/\/github.com\/youzan\/zent\/blob\/master\/packages\/zent\/src\/popover\/Popover.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3ePopover\x3c\/code\x3e 的源码\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e弹层组件是 UI 组件库中很重要的部分，一个逐层抽象的结构可以极大简化这些组件的开发和维护成本。\x3c\/p\x3e\n\x3cp\x3e合理利用 React 的 \x3ccode\x3econtext\x3c\/code\x3e 功能可以很方便地解决一些像嵌套弹层一样看似很麻烦的问题。\x3c\/p\x3e\n\x3cp\x3e如果觉得有所收获，请给  \x3ca href=\x22https:\/\/github.com\/youzan\/zent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZent\x3c\/a\x3e 点个 star 吧。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e*注1: React Fiber 中提供了一个新的 API：\x3ccode\x3eReactDOM. unstable_createPortal\x3c\/code\x3e ，这个 API 可以将一个组件渲染到指定的 DOM 节点内。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e本文由 李晨 首发于 \x3ca href=\x22http:\/\/tech.youzan.com\/nested-popup-in-react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e有赞技术博客\x3c\/a\x3e。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>漫谈 React 组件库开发（一）：多层嵌套弹层组件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011059704">https://segmentfault.com/a/1190000011059704</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/kn9lo2v6ay/" target="_blank">https://alili.tech/archive/kn9lo2v6ay/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>