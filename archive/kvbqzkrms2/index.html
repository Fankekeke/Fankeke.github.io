<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React项目实战：react-redux-router基本原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React项目实战：react-redux-router基本原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/kvbqzkrms2/",
				"appid": "1613049289050283", 
				"title": "React项目实战：react-redux-router基本原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-24T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/w33bnr6hed/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/81nyove1ci7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&text=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&text=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&title=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&is_video=false&description=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&title=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&title=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&title=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkvbqzkrms2%2f&title=React%e9%a1%b9%e7%9b%ae%e5%ae%9e%e6%88%98%ef%bc%9areact-redux-router%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React项目实战：react-redux-router基本原理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-24" itemprop="datePublished">2018-12-24</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eReact相关\x3c\/h1\x3e\n\x3cp\x3eReact 是一个采用声明式，高效而且灵活的用来构建用户界面的框架。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eJSX\x3c\/h2\x3e\n\x3cp\x3e本质上来讲，JSX 只是为\x3ccode\x3eReact.createElement(component, props, ...children)\x3c\/code\x3e方法提供的语法糖。比如下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = (\n  \x3ch1 className=\x26quot;greeting\x26quot;\x3e\n    Hello, world!\n  \x3c\/h1\x3e\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e element = (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22greeting\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    Hello, world!\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e编译为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = React.createElement(\n  \x27h1\x27,\n  {className: \x27greeting\x27},\n  \x27Hello, world!\x27\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ebnf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst element\x3c\/span\x3e = React.createElement(\n  \x3cspan class=\x22hljs-string\x22\x3e\x27h1\x27\x3c\/span\x3e,\n  {className: \x3cspan class=\x22hljs-string\x22\x3e\x27greeting\x27\x3c\/span\x3e},\n  \x3cspan class=\x22hljs-string\x22\x3e\x27Hello, world!\x27\x3c\/span\x3e\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eReact.createElement()\x3c\/code\x3e这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = {\n  type: \x27h1\x27,\n  props: {\n    className: \x27greeting\x27,\n    children: \x27Hello, world\x27\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode\x3econst \x3cspan class=\x22hljs-literal\x22\x3eelement\x3c\/span\x3e = {\n  type: \x3cspan class=\x22hljs-string\x22\x3e\x27h1\x27\x3c\/span\x3e,\n  props: {\n    className: \x3cspan class=\x22hljs-string\x22\x3e\x27greeting\x27\x3c\/span\x3e,\n    children: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello, world\x27\x3c\/span\x3e\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的对象被称为\x3ccode\x3eReact元素\x3c\/code\x3e，它代表所有你在屏幕上看到的东西。\x3cbr\x3e我们用 React 开发应用时一般只会定义一个根节点。要将 React 元素渲染到根DOM节点中，我们通过把它们都传递给\x3ccode\x3eReactDOM.render()\x3c\/code\x3e的方法来将其渲染到页面上：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ReactDOM.render(\n  element,\n  document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3eReactDOM.render(\n  element,\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每当 React 元素发生变化时，\x3ccode\x3eReactDOM\x3c\/code\x3e首先会比较元素内容先后的不同，然后操作浏览器DOM更新改变了的部分。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e组件 \x26amp; Props\x3c\/h2\x3e\n\x3cp\x3e当 React 遇到的元素是用户自定义的组件，它会将 JSX 属性作为单个对象传递给该组件,这个对象称之为\x3ccode\x3eprops\x3c\/code\x3e。无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props 。\x3cbr\x3e例如,这段代码会在页面上渲染出\x3ccode\x3eHello,Sara\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/使用 ES6 class 来定义一个组件，组件名称必须以大写字母开头。\nclass Welcome extends React.Component {\n  render() {\n    return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n  }\n}\n\nconst element = \x3cWelcome name=\x26quot;Sara\x26quot; \/\x3e;\nReactDOM.render(\n  element,\n  document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用 ES6 class 来定义一个组件，组件名称必须以大写字母开头。\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e, {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name}\x26lt;\/h1\x26gt;;\n  }\n}\n\nconst element = \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWelcome\x3c\/span\x3e name=\x3cspan class=\x22hljs-string\x22\x3e\x22Sara\x22\x3c\/span\x3e \/\x26gt;;\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\n  element,\n  document.getElementById(\x3cspan class=\x22hljs-symbol\x22\x3e\x27roo\x3c\/span\x3et\x27)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们来回顾一下在这个例子中发生了什么：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e我们对\x3ccode\x3e\x26lt;Welcome name=\x22Sara\x22 \/\x26gt;\x3c\/code\x3e元素调用了\x3ccode\x3eReactDOM.render()\x3c\/code\x3e方法。\x3c\/li\x3e\n\x3cli\x3eReact 将\x3ccode\x3e{name: \x27Sara\x27}\x3c\/code\x3e作为\x3ccode\x3eprops\x3c\/code\x3e传入并调用 Welcome 组件。\x3c\/li\x3e\n\x3cli\x3eWelcome 组件将\x3ccode\x3e\x26lt;h1\x26gt;Hello, Sara\x26lt;\/h1\x26gt;\x3c\/code\x3e元素作为结果返回。\x3c\/li\x3e\n\x3cli\x3eReactDOM 将DOM更新为\x3ccode\x3e\x26lt;h1\x26gt;Hello, Sara\x26lt;\/h1\x26gt;\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eState \x26amp; 生命周期\x3c\/h2\x3e\n\x3cp\x3e组件的通过\x3ccode\x3eprops\x3c\/code\x3e获取属性，且其不能修改；当我们需要修改当前组件的状态时，要用到\x3ccode\x3estate\x3c\/code\x3e来设置局部状态，需要通过\x3ccode\x3ethis.setState()\x3c\/code\x3e来更新组件局部状态：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Toggle extends React.Component {\n  constructor(props) {\n    super(props);    \/\/初始化this，并赋值this.props\n    this.state = {isToggleOn: true};    \/\/初始化this.state\n    this.handleClick = this.handleClick.bind(this);    \/\/为this.handleClick绑定this对象\n  }\n\n  handleClick() {\n    this.setState(prevState =\x3e ({\n      isToggleOn: !prevState.isToggleOn\n    }));    \/\/用this.setState()更新this.state\n  }\n\n  render() {\n    return (\n      \x3cbutton onClick={this.handleClick}\x3e\n        {this.state.isToggleOn ? \x27ON\x27 : \x27OFF\x27}\n      \x3c\/button\x3e\n    );\n  }\n}\n\nReactDOM.render(\n  \x3cToggle \/\x3e,\n  document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eToggle\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化this，并赋值this.props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {isToggleOn: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e};    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化this.state\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/为this.handleClick绑定this对象\x3c\/span\x3e\n  }\n\n  handleClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(prevState =\x26gt; ({\n      isToggleOn: !prevState.isToggleOn\n    }));    \x3cspan class=\x22hljs-comment\x22\x3e\/\/用this.setState()更新this.state\x3c\/span\x3e\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;button onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.isToggleOn ? \x3cspan class=\x22hljs-symbol\x22\x3e\x27O\x3c\/span\x3eN\x27 : \x3cspan class=\x22hljs-symbol\x22\x3e\x27OF\x3c\/span\x3eF\x27}\n      \x26lt;\/button\x26gt;\n    );\n  }\n}\n\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\n  \x26lt;\x3cspan class=\x22hljs-type\x22\x3eToggle\x3c\/span\x3e \/\x26gt;,\n  document.getElementById(\x3cspan class=\x22hljs-symbol\x22\x3e\x27roo\x3c\/span\x3et\x27)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每一个组件都有几个你可以重写以让代码在处理环节的特定时期运行的“生命周期方法”。方法中带有前缀\x3ccode\x3ewill\x3c\/code\x3e的在特定环节之前被调用，而带有前缀\x3ccode\x3edid\x3c\/code\x3e的方法则会在特定环节之后被调用。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e装配\x3c\/strong\x3e：这些方法会在组件实例被创建和插入DOM中时被调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- constructor(`props`)\n- componentWillMount()\n- render()\n- componentDidMount()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e- \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(`props`)\x3c\/span\x3e\n- \x3cspan class=\x22hljs-title\x22\x3ecomponentWillMount\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n- \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n- \x3cspan class=\x22hljs-title\x22\x3ecomponentDidMount\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e更新\x3c\/strong\x3e：属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- componentWillReceiveProps(`nextProps`)\n- shouldComponentUpdate(`nextProps`, `nextState`)\n- componentWillUpdate(`nextProps`, `nextState`)\n- render()\n- componentDidUpdate(`prevProps`, `prevState`)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillReceiveProps(\x3cspan class=\x22hljs-string\x22\x3e`nextProps`\x3c\/span\x3e)\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e shouldComponentUpdate(\x3cspan class=\x22hljs-string\x22\x3e`nextProps`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`nextState`\x3c\/span\x3e)\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillUpdate(\x3cspan class=\x22hljs-string\x22\x3e`nextProps`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`nextState`\x3c\/span\x3e)\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e render()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentDidUpdate(\x3cspan class=\x22hljs-string\x22\x3e`prevProps`\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`prevState`\x3c\/span\x3e)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e卸载\x3c\/strong\x3e：当一个组件被从DOM中移除时，该方法被调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- componentWillUnmount()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillUnmount()\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当项目视图交互复杂且频繁的时候，依旧采用 state 进行状态更改会显得异常繁琐和不可预测。\x3cbr\x3e这时我们就需要借助 Redux 框架，将状态数据全部转交给 Redux 处理，React 专一负责视图显示，这样会让项目逻辑变得简单而清晰。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3eRedux相关\x3c\/h1\x3e\n\x3cp\x3e三大原则：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个\x3ccode\x3estore\x3c\/code\x3e中。\x3c\/li\x3e\n\x3cli\x3e惟一改变 state 的方法就是触发\x3ccode\x3eaction\x3c\/code\x3e，action 是一个用于描述事件的普通对象。\x3c\/li\x3e\n\x3cli\x3e为了描述 action 如何改变 state tree ，你需要编写\x3ccode\x3ereducers\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eAction\x3c\/h2\x3e\n\x3cp\x3eAction 是把数据从项目传到 store 的有效载荷。它是 store 数据的唯一来源。通常你会通过\x3ccode\x3estore.dispatch()\x3c\/code\x3e将 action 传到 store。\x3c\/p\x3e\n\x3cp\x3eAction 本质上是 JavaScript 普通对象，添加新 todo 任务的 action 是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  type: \x27ADD_TODO\x27,\n  text: \x27Build my first Redux app\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27ADD_TODO\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Build my first Redux app\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eAction 创建函数\x3c\/code\x3e就是生成 action 的方法。在 Redux 中的 action 创建函数只是简单的返回一个 action:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function addTodo(text) {\n  return {\n    type: \x27ADD_TODO\x27,\n    text: text\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddTodo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27ADD_TODO\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: text\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样做将使 action 创建函数更容易被移植和测试。只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22dispatch(addTodo(text));\n\n\/\/或者创建一个 被绑定的 action 创建函数 来自动 dispatch：\nconst boundAddTodo = (text) =\x3e dispatch(addTodo(text));\nboundAddTodo(text);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3edispatch(addTodo(\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/或者创建一个 被绑定的 action 创建函数 来自动 dispatch：\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e boundAddTodo = (\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e) =\x26gt; dispatch(addTodo(\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e));\nboundAddTodo(\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3estore 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的\x3ccode\x3econnect()\x3c\/code\x3e帮助器来调用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eReducer\x3c\/h2\x3e\n\x3cp\x3eAction 只是描述了有事情发生了这一事实，而\x3ccode\x3ereducer\x3c\/code\x3e要做的事情正是指明应用如何更新 state 。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(previousState, action) =\x3e newState\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e(previousState, action) =\x26gt; newState\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e修改传入参数；\x3c\/li\x3e\n\x3cli\x3e执行有副作用的操作，如 API 请求和路由跳转；\x3c\/li\x3e\n\x3cli\x3e调用非纯函数，如 Date.now() 或 Math.random()。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 undefined，此时我们可借机设置并返回应用的初始 state：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const initialState = {};    \/\/初始化state\n\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case \x27ADD_TODO\x27:\n      return Object.assign({}, state, {\n        text: action.text\n      })\n    default:\n      return state    \/\/在 default 情况下返回旧的 state\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e initialState = {};    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化state\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etodoApp\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = initialState, action\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (action.type) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27ADD_TODO\x27\x3c\/span\x3e:\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, state, {\n        \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: action.text\n      })\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e state    \x3cspan class=\x22hljs-comment\x22\x3e\/\/在 default 情况下返回旧的 state\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecombineReducers()\x3c\/code\x3e所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { combineReducers } from \x27redux\x27;\n\nconst todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n\nexport default todoApp;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { combineReducers } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e todoApp;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意上面的写法和下面完全等价：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function todoApp(state = {}, action) {\n  return {\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action),\n    todos: todos(state.todos, action)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etodoApp\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = {}, action\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3evisibilityFilter\x3c\/span\x3e: visibilityFilter(state.visibilityFilter, action),\n    \x3cspan class=\x22hljs-attr\x22\x3etodos\x3c\/span\x3e: todos(state.todos, action)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3ecombineReducers 接收一个对象，可以把所有顶级的 reducer 放到一个独立的文件中，通过 export 暴露出每个 reducer 函数，然后使用 import * as reducers 得到一个以它们名字作为 key 的 object：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { combineReducers } from \x27redux\x27\nimport * as reducers from \x27.\/reducers\x27\n\nconst todoApp = combineReducers(reducers)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { combineReducers } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e * \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e reducers \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/reducers\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e todoApp = combineReducers(reducers)\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eStore\x3c\/h2\x3e\n\x3cp\x3eaction 描述发生了什么，reducers 根据 action 更新 state，\x3ccode\x3eStore\x3c\/code\x3e就是把它们联系到一起的对象。Store 有以下职责：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e维持应用的 state；\x3c\/li\x3e\n\x3cli\x3e提供\x3ccode\x3egetState()\x3c\/code\x3e方法获取 state；\x3c\/li\x3e\n\x3cli\x3e提供\x3ccode\x3edispatch(action)\x3c\/code\x3e方法更新state；\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3esubscribe(listener)\x3c\/code\x3e注册监听器;\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3esubscribe(listener)\x3c\/code\x3e返回的函数注销监听器。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们使用 combineReducers() 将多个 reducer 合并成为一个。现在我们将其导入，并传递 \x3ccode\x3ecreateStore()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { createStore } from \x27redux\x27\nimport todoApp from \x27.\/reducers\x27\nlet store = createStore(todoApp)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createStore } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e todoApp \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/reducers\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e store = createStore(todoApp)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecreateStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let store = createStore(todoApp, window.STATE_FROM_SERVER);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e store = createStore(todoApp, \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.STATE_FROM_SERVER);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e数据流\x3c\/h2\x3e\n\x3cp\x3eRedux 应用中数据的生命周期遵循下面 4 个步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e调用 store.dispatch(action)。\x3c\/li\x3e\n\x3cli\x3eRedux store 调用传入的 reducer 函数。\x3c\/li\x3e\n\x3cli\x3e根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。\x3c\/li\x3e\n\x3cli\x3eRedux store 保存了根 reducer 返回的完整 state 树。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3eRouter相关\x3c\/h1\x3e\n\x3cp\x3e直接使用整合后的\x3ccode\x3ereact-router-redux\x3c\/code\x3e，后面抽时间再详细讲一下，具体使用的话模仿官方案例吧，\x3ca href=\x22https:\/\/github.com\/ReactTraining\/react-router\/tree\/master\/packages\/react-router-redux#readme\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e容器组件 和 展示组件\x3c\/h1\x3e\n\x3cp\x3eRedux 的 React 绑定库包含了 容器组件和展示组件相分离 的开发思想。\x3c\/p\x3e\n\x3cp\x3e明智的做法是只在最顶层组件（如路由操作）里使用 Redux。其余内部组件仅仅是展示性的，所有数据都通过 props 传入。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVZefu?w=964\x26amp;h=297\x22 src=\x22https:\/\/static.alili.tech\/img\/bVZefu?w=964\x26amp;h=297\x22 alt=\x22组件分离\x22 title=\x22组件分离\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader11\x22\x3e系列目录\x3c\/h1\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/sfau.lt\/b5Y87d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端大统一时代即将来临？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/sfau.lt\/b5ZcHH\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact项目实战：环境搭建\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/sfau.lt\/b5Zefv\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact项目实战：react-redux-router基本原理\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3eReact项目实战：登录页面（编辑中）\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React项目实战：react-redux-router基本原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012170435">https://segmentfault.com/a/1190000012170435</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/kvbqzkrms2/" target="_blank">https://alili.tech/archive/kvbqzkrms2/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>