<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入React知识点整理（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入React知识点整理（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/l0quwnpk1oh/",
				"appid": "1613049289050283", 
				"title": "深入React知识点整理（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-22T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/x2r5p5tvkq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cyi6oc58okq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&text=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&text=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&title=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&is_video=false&description=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&title=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&title=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&title=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl0quwnpk1oh%2f&title=%e6%b7%b1%e5%85%a5React%e7%9f%a5%e8%af%86%e7%82%b9%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入React知识点整理（一）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-22" itemprop="datePublished">2018-12-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e使用React也满一年了，从刚刚会使用到逐渐探究其底层实现，以便学习几招奇技淫巧从而在自己的代码中使用，写出高效的代码。下面整理一些知识点，算是React看书，使用，感悟的一些总结：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e函数式编程\x3c\/li\x3e\n\x3cli\x3eReact事件系统\x3c\/li\x3e\n\x3cli\x3e高阶组件\x3c\/li\x3e\n\x3cli\x3e组件性能优化\x3c\/li\x3e\n\x3cli\x3eReact源码初探\x3c\/li\x3e\n\x3cli\x3eVirtualDOM 模型\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. 函数式编程\x3c\/h2\x3e\n\x3cp\x3e函数式编程是一种如何编写程序的方法论，与之对应的就是\x3cstrong\x3e命令式编程\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e以我自己的理解，函数式编程就是以函数为中心，将大段过程拆成一个个函数，组合嵌套使用。这个思想在JavaScript中很常见。举个阮一峰老师的例子：\x3c\/p\x3e\n\x3cp\x3e我们有一个数学表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(1 \x2b 2) * 3 - 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) * \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将上述表达式不假思索的转换成代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const a = 1 \x2b 2;\nconst b = a * 3;\nconst c = b - 4;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a * \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e c = b - \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以函数式编程思想：将运算过程定义成不同的函数，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const result = substract(multiply(add(1, 2), 3), 4);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = substract(multiply(add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是感觉很高端但又一脸懵逼。没错，函数式编程在处理大段过程中就显得很容易理解，但是简单逻辑中就显得复杂，因为封装起来的函数需要时间去阅读。\x3c\/p\x3e\n\x3cp\x3e对上述表达式进行变形：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22　add(1,2).multiply(3).subtract(4);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e　add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e).multiply(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e).subtract(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是也很熟悉。函数式编程在JavaScript中应用确实很普遍。\x3c\/p\x3e\n\x3cblockquote\x3e目前最当红的Python、Ruby、Javascript，对函数式编程的支持都很强，就连老牌的面向对象的Java、面向过程的PHP，都忙不迭地加入对匿名函数的支持。越来越多的迹象表明，函数式编程已经不再是学术界的最爱，开始大踏步地在业界投入实用。\x3cp\x3e也许继\x22面向对象编程\x22之后，\x22函数式编程\x22会成为下一个编程的主流范式（paradigm）。未来的程序员恐怕或多或少都必须懂一点。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这里不做多介绍，有兴趣可以看看：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2012\/04\/functional_programming.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e函数式编程初探\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.zhihu.com\/question\/28292740\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e什么是函数式编程思维？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/coolshell.cn\/articles\/10822.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e函数式编程\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2.React事件系统\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eReact事件与DOM事件\x3c\/h3\x3e\n\x3cblockquote\x3eReact 基于 Virtual DOM 实现了一个 SyntheticEvent （合成事件）层，我们所定义的事件处理器会接收到一个 SyntheticEvent 对象的实例，它完全符合 W3C 标准，不会存在任何 IE 标准的兼容性问题。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我们可以使用 stopPropagation() 和 preventDefault() 来中断它。\x3cp\x3e所有事件都自动绑定到最外层上。如果需要访问原生事件对象，可以使用 nativeEvent 属性。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e使用React的时候都知道，React有一套自己的事件系统，典型的特征就是元素绑定事件都要使用\x3ca href=\x22https:\/\/reactjs.org\/docs\/handling-events.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact提供的事件接口\x3c\/a\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ in html\n\x3cbutton onclick=\x26quot;activateLasers()\x26quot;\x3e\n  Activate Lasers\n\x3c\/button\x3e\n\n\/\/ in React\n\x3cbutton onClick={activateLasers}\x3e\n  Activate Lasers\n\x3c\/button\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ in html\x3c\/span\x3e\n\x26lt;button onclick=\x3cspan class=\x22hljs-string\x22\x3e\x22activateLasers()\x22\x3c\/span\x3e\x26gt;\n  Activate Lasers\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ in React\n\x26lt;button onClick={activateLasers}\x26gt;\n  Activate Lasers\n\x26lt;\/\x3c\/span\x3ebutton\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact的合成事件实际上是做了一层事件委托（事件代理）：\x3c\/p\x3e\n\x3cblockquote\x3e它并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率\x3cbr\x3e也有很大提升。\x3c\/blockquote\x3e\n\x3cp\x3e也就是说React使用了一个事件代理，所有事件绑定都只是事件代理保存了一个映射，事件发生的时候，调用处理函数，并没有真正的使用原生事件。我们来看一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentDidMount () {\n    document.querySelector(\x27#testEvent\x27).addEventListener(\x27click\x27, (e)=\x3e{\n        console.log(\x27dom event\x27);\n        console.log(e);\n    })\n}\ncomponentDidUnMount () {\n    document.querySelector(\x27#testEvent\x27).removeEventListener(\x27click\x27);\n}\nhandleClick (e) {\n    console.log(\x27react event\x27);\n    console.log(e);\n}\nrender () {\n    return (\n        \x3cdiv\x3e\n              \x3cdiv onClick={::this.handleClick}\x3eTest React Event\x3c\/div\x3e\n              \x3cdiv id=\x27testEvent\x27\x3eTest dom Event\x3c\/div\x3e\n        \x3c\/div\x3e\n    );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ecomponentDidMount () {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27#testEvent\x27\x3c\/span\x3e).addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, (e)=\x26gt;{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27dom event\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n    })\n}\ncomponentDidUnMount () {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27#testEvent\x27\x3c\/span\x3e).removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e);\n}\nhandleClick (e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27react event\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n}\nrender () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n              \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{::this.handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eTest React Event\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n              \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27testEvent\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eTest dom Event\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有两个div，使用React绑定事件和原生DOM事件，两种事件绑定方法不同导致相同的效果，完全不同的原理。\x3c\/p\x3e\n\x3cp\x3e使用原生DOM绑定打印的事件就是原生的，React事件打印出来的事件：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0kip?w=594\x26amp;h=86\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0kip?w=594\x26amp;h=86\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到是个Proxy对象，里面有触发事件的target和处理事件的handler，这就是React的合成事件。\x3c\/p\x3e\n\x3cp\x3e另外如果在react中绑定原生事件，组件卸载的时候记得解除绑定，避免内存泄漏。\x3c\/p\x3e\n\x3cp\x3eReact的合成事件还有一个优点在于不需要处理浏览器事件兼容性，方便操作。\x3c\/p\x3e\n\x3cblockquote\x3e原生事件分成三个部分：事件捕获，目标事件处理，事件冒泡。IE9以下不支持事件捕获，所以React没有实现它，仅支持事件冒泡。\x3cp\x3e有些事件React没有实现，window.resize事件。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e所以，请尽量避免在 React 中混用合成事件和原生 DOM 事件。\x3c\/strong\x3e因为两者是不同的事件系统，阻止 React 事件冒泡的行为只能用于 React 合成事件系统中，且没办法阻止原生事件的冒泡。反之，在原生事件中的阻止冒泡行为，却可以阻止 React 合成事件的传播。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e3.高阶组件\x3c\/h2\x3e\n\x3cp\x3e高阶组件是React中比较有特点的一类问题，\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000012232867\x22\x3e高阶组件(High Order Component)\x3c\/a\x3e文章里单独进行了详细介绍。\x3c\/p\x3e\n\x3cp\x3e这里只是补一张图：组合式组件开发实践\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0kiv?w=1314\x26amp;h=474\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0kiv?w=1314\x26amp;h=474\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e4.组件性能优化\x3c\/h2\x3e\n\x3cblockquote\x3e从过往的经验与实践中，我们都知道影响网页性能最大的因素是浏览器的重绘（reflow）和重排版（repaint）。React 背后的 Virtual DOM 就是尽可能地减少浏览器的重绘与重排版。\x3c\/blockquote\x3e\n\x3cp\x3e关于浏览器重绘和重排版问题，请看我之前的文章：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010298038\x22 target=\x22_blank\x22\x3e浏览器渲染页面过程与页面优化\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这里要介绍的就是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e多使用纯函数：无依赖；相同输入相同输出；重复使用。\x3c\/li\x3e\n\x3cli\x3ePureComponent：本质上讲，PureComponent就是重写了\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，对\x3ccode\x3enextProps\x3c\/code\x3e和\x3ccode\x3enextState\x3c\/code\x3e与当前state和props做浅比较，性能上优化。\x3c\/li\x3e\n\x3cli\x3eImmutable：使用\x3ccode\x3eImmutable\x3c\/code\x3e共享数据节点，节省渲染。\x3c\/li\x3e\n\x3cli\x3ekey：列表渲染指定key，相同key不渲染；尽量不要使用index当key，最好是id。\x3c\/li\x3e\n\x3cli\x3ereact-addons-pref：插件量化性能优化效果。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e对这块有兴趣的，推荐几篇文章：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/younth.github.io\/2017\/04\/07\/react-perf\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact组件性能调优\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007811296\x22\x3eReact性能优化总结\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/taobaofed.org\/blog\/2016\/08\/12\/optimized-react-components\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e高性能 React 组件\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e5.React源码初探\x3c\/h2\x3e\n\x3cp\x3eReact项目目录构成如下图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0kiO?w=1104\x26amp;h=810\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0kiO?w=1104\x26amp;h=810\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eaddons：工具方法插件：\x3ccode\x3ePureRenderMixin\x3c\/code\x3e、\x3ccode\x3eCSSTransitionGrouo\x3c\/code\x3e、\x3ccode\x3eFragment\x3c\/code\x3e、\x3ccode\x3eLinkedStateMixin\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3eisomorphic：包含一系列同构方法。\x3c\/li\x3e\n\x3cli\x3eshared：公用方法和常用方法。\x3c\/li\x3e\n\x3cli\x3etest：测试方法。\x3c\/li\x3e\n\x3cli\x3ecore\/tests：边界错误的测试用例。\x3c\/li\x3e\n\x3cli\x3erenderers：React的核心代码，包含大部分功能实现，因此进行单独分析。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3erenderers包包含内容：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0ki5?w=1060\x26amp;h=476\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0ki5?w=1060\x26amp;h=476\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3edom：包含client，server和shared。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eclient：包含DOM操作方法（findDOMNode，setInnerHTML，setTextContent等）以及事件方法。这里的事件方法主要是一些非底层的实用性事件方法，\x3cbr\x3e如事件监听（ReactEventListener）、常用事件方法（TapEventPlugin、EnterLeaveEventPlugin）以及一些合成事件（SyntheticEvents\x3cbr\x3e等）。\x3c\/li\x3e\n\x3cli\x3eserver：主要包含服务端渲染的实现和方法（如 ReactServerRendering、ReactServerRenderingTransaction\x3cbr\x3e等）。\x3c\/li\x3e\n\x3cli\x3eshared：包含文本组件（ReactDOMTextComponent）、标签组件（ReactDOMComponent）、\x3cbr\x3eDOM 属性操作（DOMProperty、DOMPropertyOperations）、CSS 属性操作（CSSProperty、\x3cbr\x3eCSSPropertyOperations）等。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eshared：包含event和reconciler。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eevent：包含一些更为底层的事件方法，如事件插件中心（EventPluginHub）、事件注册\x3cbr\x3e（EventPluginRegistry）、事件传播（EventPropagators）以及一些事件通用方法。\x3cbr\x3eReact 自定义了一套通用事件的插件系统，该系统包含事件监听器、事件发射器、事\x3cbr\x3e件插件中心、点击事件、进\/出事件、简单事件、合成事件以及一些事件方法。\x3c\/li\x3e\n\x3cli\x3ereconciler：称为协调器，它是最为核心的部分，包含 React 中自定义组件的实现\x3cbr\x3e（ReactCompositeComponent）、组件生命周期机制、setState 机制（ReactUpdates、\x3cbr\x3eReactUpdateQueue）、DOM diff 算法（ReactMultiChild）等重要的特性方法。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0kji?w=1158\x26amp;h=688\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0kji?w=1158\x26amp;h=688\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里简单介绍React目录构成以及每块的功能，大致了解，需要的时候找到对应位置深入研究。\x3c\/p\x3e\n\x3cblockquote\x3eReact 也能够实现 Virtual DOM 的批处理更新，当操作 Virtual DOM 时, 不会马上生成真实的DOM，而是会将一个事件循环（event loop）内的两次数据更新进行合并，这样就使得 React 能够在事件循环的结束之前完全不用操作真实的 DOM。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e6.VirtualDOM 模型\x3c\/h2\x3e\n\x3cp\x3eVirtualDOM是React的一个核心，也是React一个著名的特点，之前我有篇文章对此有过简单的介绍，以及如何简单实现根据VirtualDOM渲染页面：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009516273\x22\x3eReact学习报告\x3c\/a\x3e，可以做基本入门查看。\x3c\/p\x3e\n\x3cp\x3eVirtualDOM与真实DOM的关系很简单：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e真实DOM可以理解为是xml格式存储DOM，VirtualDOM可以理解为json格式的存储DOM。\x3c\/li\x3e\n\x3cli\x3e只需要存储节点的关键信息：类型，id，class，属性，style，事件，嵌套关系等即可，按照一定的转换规则将json转成DOM。\x3c\/li\x3e\n\x3cli\x3e流程关系：jsx语法-\x26gt;识别jsx语法生成VirtualDOM树-\x26gt;根据渲染规则生成真实DOM-\x26gt;HTML。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3eVirtual DOM中的节点成为ReactNode，分成ReactELement，ReactFragment，ReactText。ReactElement又分成ReactComponentElemnt和ReactDOMElement。\x3c\/blockquote\x3e\n\x3cp\x3e下面是 ReactNode 中不同类型节点所需要的基础元素：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type ReactNode = ReactElement | ReactFragment | ReactText;\ntype ReactElement = ReactComponentElement | ReactDOMElement;\ntype ReactDOMElement = {\n type : string,\n props : {\n children : ReactNodeList,\n className : string,\n etc.\n },\n key : string | boolean | number | null,\n ref : string | null\n};\ntype ReactComponentElement\x3cTProps\x3e = {\n type : ReactClass\x3cTProps\x3e,\n props : TProps,\n key : string | boolean | number | null,\n ref : string | null\n};\ntype ReactFragment = Array\x3cReactNode | ReactEmpty\x3e;\ntype ReactNodeList = ReactNode | ReactEmpty;\ntype ReactText = string | number;\ntype ReactEmpty = null | undefined | boolean; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3etype ReactNode = ReactElement | ReactFragment | ReactText;\ntype ReactElement = ReactComponentElement | ReactDOMElement;\ntype ReactDOMElement = {\n \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e : string,\n \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e : {\n \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e : ReactNodeList,\n \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e : string,\n etc.\n },\n \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e : string | boolean | number | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e : string | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n};\ntype ReactComponentElement\x26lt;TProps\x26gt; = {\n \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e : ReactClass\x26lt;TProps\x26gt;,\n \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e : TProps,\n \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e : string | boolean | number | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e : string | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n};\ntype ReactFragment = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;ReactNode | ReactEmpty\x26gt;;\ntype ReactNodeList = ReactNode | ReactEmpty;\ntype ReactText = string | number;\ntype ReactEmpty = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e | \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e | boolean; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里以DOM标签（ReactDOMComponent）为例，介绍VirtualDOM模型如何创建节点：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e属性更新\x3c\/h3\x3e\n\x3cblockquote\x3e当执行 mountComponent 方法时，ReactDOMComponent 首先会生成标记和标签，通过 this.createOpenTagMarkupAndPutListeners(transaction) 来处理 DOM 节点的属性和事件。\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e如果节点绑定了事件，则针对当前的节点添加代理，调用\x3ccode\x3eenqueuePutListener(this,propKey, propValue, transaction)\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e存在样式的话，样式合并\x3ccode\x3eObject.assign({}, props.style)\x3c\/code\x3e，然后通过\x3ccode\x3eCSSPropertyOperations.createMarkupForStyles(propValue, this)\x3c\/code\x3e创建样式。\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3eDOMPropertyOperations.createMarkupForProperty(propKey, propValue)\x3c\/code\x3e创建属性。\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3eDOMPropertyOperations.createMarkupForID(this._domID)\x3c\/code\x3e创建唯一标识。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e其实，早有开发者向 React 官方提过问题，建议去掉这个鸡肋的属性标识（data-reactid）这终于在 React 15.0版本上实现了。据官方宣称，去除 data-reactid 使得 React 性能有了 10% 的提升。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e更新子节点\x3c\/h3\x3e\n\x3cblockquote\x3e当执行 mountComponent 方法时，ReactDOMComponent 会通过 this._createContentMarkup(transaction, props, context) 来处理 DOM 节点的内容。\x3c\/blockquote\x3e\n\x3cp\x3e先是删除不需要的子节点和内容。如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行方法 this.updateChildren(null, transaction, context)；如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法 this.updateTextContent(\x27\x27)。\x3c\/p\x3e\n\x3cp\x3e再是更新子节点和内容。如果新子节点存在，则更新其子节点，此时执行方法 \x3ccode\x3ethis.updateChildren(nextChildren,transaction, context)\x3c\/code\x3e；如果新的内容存在，则更新内容，此时执行方法 \x3ccode\x3ethis.updateTextContent(\x27\x27 \x2b nextContent)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当卸载组件时，ReactDOMComponent 会进行一系列的操作，如卸载子节点、清除事件监听、清空标识等。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0kjJ?w=1194\x26amp;h=812\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0kjJ?w=1194\x26amp;h=812\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入React知识点整理（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012432236">https://segmentfault.com/a/1190000012432236</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/l0quwnpk1oh/" target="_blank">https://alili.tech/archive/l0quwnpk1oh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>