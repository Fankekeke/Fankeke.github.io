<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端知识点总结——JS高级（持续更新中）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端知识点总结——JS高级（持续更新中） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/l5ufbepn1wn/",
				"appid": "1613049289050283", 
				"title": "前端知识点总结——JS高级（持续更新中） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8ow8wfvxo46/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/edcyi907f56/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&text=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&text=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5ufbepn1wn%2f&title=%e5%89%8d%e7%ab%af%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93%e2%80%94%e2%80%94JS%e9%ab%98%e7%ba%a7%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端知识点总结——JS高级（持续更新中）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e前端知识点总结——JS高级（持续更新中）\x3c\/strong\x3e\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e1.字符串\x3c\/h2\x3e\n\x3cp\x3e什么是: 连续存储多个字符的字符数组\x3cbr\x3e 相同: 1. 下标 2. .length  3. 遍历\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  4. 选取: slice(starti[, endi])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs accesslog\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e. 选取: slice(starti\x3cspan class=\x22hljs-string\x22\x3e[, endi]\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不同: 类型不同 API不通用\x3cbr\x3eAPI: 所有字符串API都无权修改原字符串，总是返回新字符串\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e大小写转换:\x3cbr\x3e 统一转大写: str=str.toUpperCase()\x3cbr\x3e 统一转小写: str=str.toLowerCase()\x3cbr\x3e 何时: 不区分大小写时，都需要先转为一致的大小写，再比较。\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e说明: 验证码本不该客户端做，应该由服务器端完成\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e2.获取指定位置的字符:\x3c\/h2\x3e\n\x3cp\x3estr.charAt(i)  =\x26gt; str[i]\x3cbr\x3e  获取指定位置字符的unicode号\x3cbr\x3e  str.charCodeAt(i)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  将unicode号转为汉字: String.fromCharCode(unicode)\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vbnet\x22\x3e\x3ccode\x3e  将\x3cspan class=\x22hljs-keyword\x22\x3eunicode\x3c\/span\x3e号转为汉字: \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e.fromCharCode(\x3cspan class=\x22hljs-keyword\x22\x3eunicode\x3c\/span\x3e)\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e3.获取子字符串:\x3c\/h2\x3e\n\x3cp\x3estr.slice(starti,endi\x2b1)\x3cbr\x3e   强调: 如果一个API，两个参数都是下标，则后一个参数\x2b1（含头不含尾）\x3cbr\x3e  str.substring(starti,endi\x2b1) 用法和slice完全一样\x3cbr\x3e   强调: 不支持负数参数\x3cbr\x3e  str.subStr(starti,n) 从starti开始，取n个\x3cbr\x3e   强调: 第二个参数不是下标，所以，不用考虑含头不含尾\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e4.查找: 4种:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e查找一个固定的关键词出现的位置:\x3cbr\x3e var i=str.indexOf(\x22关键词\x22[,fromi])\x3cbr\x3e 在str中，fromi位置后，找下一个\x22关键词\x22出现的位置\x3cbr\x3e  如果找到，返回关键词第一个字的下标位置\x3cbr\x3e  如果没找到，返回-1\x3cbr\x3e 说明: fromi可省略，默认从0开始\x3cp\x3evar i=str.lastIndexOf(\x22关键词\x22);\x3cbr\x3e 在str中，查找\x22关键词\x22最后出现的位置\x3c\/p\x3e\n\x3cp\x3e问题: 只能查找一个固定的关键词\x3cbr\x3e  卧我草\/操\/艹\/槽\x3cbr\x3e  微 信  w x  wei xin\x3cbr\x3e 解决: 用正则查找:\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e判断是否包含关键词:\x3cbr\x3e var i=str.search(\/正则\/)\x3cbr\x3e 返回值: 如果找到，返回关键词的位置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     如果没找到，返回-1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e     如果没找到，返回\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题: 默认，所有正则都区分大小写\x3cbr\x3e 解决: 在第二个\/后加i  ignore 忽略\x3cbr\x3e 问题: 只能获得位置，无法获得本次找到的敏感词的内容\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e获得关键词的内容: \x3cbr\x3e var arr=str.match(\/正则\/i);\x3cbr\x3e 2种情况:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e不加g的情况: 只能返回第一个找到的关键词内容和位置: [ 0: \x22关键词内容\x22, index: 位置 ]\x3c\/li\x3e\n\x3cli\x3e加g: 返回所有找到的敏感词的内容，保存在数组中。g: global\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e强调: 如果找不到，返回null\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 警告: 凡是一个函数可能返回null！都要先判断不是null，才能用！\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e 警告: 凡是一个函数可能返回\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e！都要先判断不是\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e，才能用！\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题: 只能获得关键词内容，无法获得位置\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e即找每个关键词内容，又找每个关键词位置: \x3cbr\x3e reg.exec()\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e5.替换:\x3c\/h2\x3e\n\x3cp\x3e什么是: 将找到的关键词替换为指定的内容\x3cbr\x3e  如何: 2种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e简单替换: 将所有敏感词无差别的替换为统一的新值\x3cbr\x3e  str=str.replace(\/正则\/,\x22替换值\x22)\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e高级替换: 根据每个敏感词的不同，分别替换不同的值\x3cbr\x3e  str=str.replace(\/正则\/,function(kw){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/\/kw: 会自动获得本次找到的一个关键词\n return  根据kw的不同，动态生成不同的替换值\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/kw: 会自动获得本次找到的一个关键词\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e  根据kw的不同，动态生成不同的替换值\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e衍生: 删除关键词:\x3cbr\x3e   str=str.replace(\/正则\/,\x22\x22)\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e6.正则表达式: Regular Expression\x3c\/h2\x3e\n\x3cp\x3e什么是: 描述一个字符串中字符出现规律的规则的表达式\x3cbr\x3e何时: 2种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e查找关键词:\x3c\/li\x3e\n\x3cli\x3e验证:\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如何: 正则表达式语法:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e最简单的正则其实是关键词原文:\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e7.字符集:\x3c\/h2\x3e\n\x3cp\x3e什么是: 规定一位字符，备选字符列表的集合\x3cbr\x3e  何时: 只要一位字符，有多种备选字时\x3cbr\x3e  如何: [备选字符列表]\x3cbr\x3e   强调: 一个[]只能匹配一位字符\x3cbr\x3e   简写: 如果备选字符列表中部分字符连续\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22可简写为: [x-x]  用-省略中间字符\n 比如: [0-9] 一位数字\n      [a-z] 一位小写字符\n      [A-Z] 一位大写字母\n      [A-Za-z] 一位字符\n      [0-9A-Za-z] 一位字母或数字\n      [\\u4e00-\\u9fa5] 一位汉字\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs accesslog\x22\x3e\x3ccode\x3e可简写为: \x3cspan class=\x22hljs-string\x22\x3e[x-x]\x3c\/span\x3e  用-省略中间字符\n 比如: \x3cspan class=\x22hljs-string\x22\x3e[0-9]\x3c\/span\x3e 一位数字\n      \x3cspan class=\x22hljs-string\x22\x3e[a-z]\x3c\/span\x3e 一位小写字符\n      \x3cspan class=\x22hljs-string\x22\x3e[A-Z]\x3c\/span\x3e 一位大写字母\n      \x3cspan class=\x22hljs-string\x22\x3e[A-Za-z]\x3c\/span\x3e 一位字符\n      \x3cspan class=\x22hljs-string\x22\x3e[0-9A-Za-z]\x3c\/span\x3e 一位字母或数字\n      \x3cspan class=\x22hljs-string\x22\x3e[\\u4e00-\\u9fa5]\x3c\/span\x3e 一位汉字\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e反选: \x3csup id=\x22fnref-1\x22\x3e\x3ca href=\x22#fn-1\x22 class=\x22footnote-ref\x22\x3e1\x3c\/a\x3e\x3c\/sup\x3e 除了4和7都行\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e8.预定义字符集: 4种:\x3c\/h2\x3e\n\x3cp\x3ed  一位数字  [0-9]\x3cbr\x3e  w  一位数字，字母或下划线  [0-9A-Za-z_]\x3cbr\x3e   强调: 只有100%匹配时，才使用w，如果不允许有_，则使用自定义字符集\x3cbr\x3e  s  一位空字符，比如: 空格，Tab，...\x3cbr\x3e  .   通配符\x3cbr\x3e 问题: 字符集只能规定字符的内容，无法灵活规定字符的个数\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e9.量词:\x3c\/h2\x3e\n\x3cp\x3e什么是: 专门规定一个字符集出现次数的规则\x3cbr\x3e  何时: 只要规定字符集出现的次数，都用量词\x3cbr\x3e  如何: 字符集量词\x3cbr\x3e   强调: 量词默认只修饰相邻的前一个字符集\x3cbr\x3e   包括: 2大类:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 有明确数量边界:\n {6,8}  最少6次，最多8次\n {6,}   最少6次，多了不限\n {6}    必须6次，不能多也不能少\n2. 没有明确数量边界:\n ?     可有可无，最多1次\n *     可有可无，多了不限\n \x2b     至少1次，多了不限\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e1. 有明确数量边界:\n \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{6,8}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e  最少6次，最多8次\n \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{6,}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e   最少6次，多了不限\n \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{6}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e    必须6次，不能多也不能少\n2. 没有明确数量边界:\n ?     可有可无，最多1次\n *     可有可无，多了不限\n \x2b     至少1次，多了不限\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e10.选择和分组:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e选择: 或\x3cbr\x3e  规则1|规则2\x3cbr\x3e  何时: 只要在两个规则中任选其一匹配\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e分组: (规则1规则2...)\x3cbr\x3e  何时: 如果希望一个量词同时修饰多个规则时，都要先将多个规则分为一组，再用量词修饰分组。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22比如: 车牌号: [\\u4e00-\\u9fa5][A-Z]•[0-9A-Z]{5}\n比如: 手机号规则: \n\\\x2b86或0086  可有可无，最多1次\n空字符      可有可无，多了不限\n 1\n 在3,4,5,7,8中选一个\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e比如: 车牌号: [\x3cspan class=\x22hljs-string\x22\x3e\\u4e00-\\u9fa5\x3c\/span\x3e][\x3cspan class=\x22hljs-symbol\x22\x3eA-Z\x3c\/span\x3e]•[0-9A-Z]{5}\n比如: 手机号规则: \n\\\x2b86或0086  可有可无，最多1次\n空字符      可有可无，多了不限\n 1\n 在3,4,5,7,8中选一个\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e9位数字\x3cbr\x3e  (\x2b86|0086)?s*1[34578]d{9}\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 比如: 身份证号:\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e 比如: 身份证号:\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e15位数字 2位数字 一位数字或X\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22可有可无，最多一次\n\\d{15}(\\d{2}[0-9X])?\n比如: 电子邮件: 鄙视\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs tex\x22\x3e\x3ccode\x3e可有可无，最多一次\n\x3cspan class=\x22hljs-tag\x22\x3e\\\x3cspan class=\x22hljs-name\x22\x3ed\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e{15}\x3c\/span\x3e\x3c\/span\x3e(\x3cspan class=\x22hljs-tag\x22\x3e\\\x3cspan class=\x22hljs-name\x22\x3ed\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e{2}\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e[0-9X]\x3c\/span\x3e\x3c\/span\x3e)?\n比如: 电子邮件: 鄙视\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\/^([a-zA-Z0-9_-])\x2b@([a-zA-Z0-9_-])\x2b(.[a-zA-Z0-9_-])\x2b\/ \x3cbr\x3e   比如: url: \x3cbr\x3e   (https?|ftp|file):\/\/[-A-Za-z0-9\x2b\x26amp;@#\/%?=~_|!:,.;]\x2b[-A-Za-z0-9\x2b\x26amp;@#\/%=~_|]\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e11.匹配特殊位置: 3个:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e字符串开头: ^\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e字符串结尾: $\x3cbr\x3e 比如: 开头的空字符: ^s\x2b\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 结尾的空字符: \\s\x2b$\n 开头或结尾的空字符: ^\\s\x2b|\\s\x2b$\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs taggerscript\x22\x3e\x3ccode\x3e 结尾的空字符: \x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\x2b$\n 开头或结尾的空字符: ^\x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\x2b|\x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\x2b$\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.单词边界: b  包括开头，结尾，空字符，标点符号\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22比如: 单词首字母: \\b[a-z]\n匹配单词: \\bxxx\\b\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e比如: 单词首字母: \\\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e[a-z]\n匹配单词: \\bxxx\\\x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e12.String:\x3c\/h2\x3e\n\x3cp\x3e替换: 2种: 如果关键词是固定的: \x3cbr\x3e   str=str.replace(\x22关键词\x22,\x22替换值\x22);\x3cbr\x3e   如果关键词变化\x3cbr\x3e   str=str.replace(\/正则\/ig,\x22替换值\x22)；\x3cbr\x3e 切割: 2种: 如果分隔符是固定的:\x3cbr\x3e   var substrs=str.split(\x22分隔符\x22)\x3cbr\x3e   如果分隔符不是固定的\x3cbr\x3e   var substrs=str.split(\/正则\/i)\x3cbr\x3e   固定套路: 将字符串打散为字符数组\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var chars=str.split(\x26quot;\x26quot;)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3e var \x3cspan class=\x22hljs-keyword\x22\x3echars\x3c\/span\x3e=str.\x3cspan class=\x22hljs-built_in\x22\x3esplit\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e13.RegExp:\x3c\/h2\x3e\n\x3cp\x3e什么是: 保存一条正则表达式，并提供用正则表达式执行验证和查找的API\x3cbr\x3e何时: 只要用正则查找关键词或验证字符串格式时\x3cbr\x3e如何: \x3cbr\x3e 创建: 2种：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e直接量: var reg=\/正则\/ig\x3cbr\x3e  何时: 只要正则表达式的规则是固定不变的。\x3cbr\x3e  问题: 正则表达式时固定不变的，不支持动态生成\x3c\/li\x3e\n\x3cli\x3enew:  var reg=new RegExp(\x22正则\x22,\x22ig\x22);\x3cbr\x3e  何时: 只要需要动态生成正则表达式\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eAPI: 2个:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e验证: var bool=reg.test(str)\x3cbr\x3e 问题: 默认，只要找到匹配的内容，就返回true，不要求完整匹配!\x3cbr\x3e 解决: 今后，凡是验证必须前加^，后加$\x3c\/li\x3e\n\x3cli\x3e查找: 即找每个关键词位置，又获得每个关键词内容\x3cbr\x3e var arr=reg.exec(str)\x3cbr\x3e 在str中查找下一个关键词的位置和内容\x3cbr\x3e 返回值: arr:[ 0: 内容,  index: 位置 ]\x3cbr\x3e   如果找不到，返回null\x3cbr\x3e 如果找所有: 只要用while反复调用reg.exec即可，exec可自动跳到下一个查找位置\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e14.Math\x3c\/h2\x3e\n\x3cp\x3e什么是: 保存数学计算的常量和API的对象\x3cbr\x3e何时: 进行算术计算\x3cbr\x3e如何: \x3cbr\x3e 创建: 不用创建，所有API都用Math直接调用\x3cbr\x3e API:\x3c\/p\x3e\n\x3cli\x3e\x3col\x3e\x3cli\x3e取整: \x3cbr\x3e 上取整: Math.ceil(num)\x3cbr\x3e 下取整: \x3cbr\x3e  Math.floor(num)\x3cbr\x3e  parseInt(str) 去掉字符串结尾非数字字符(单位)\x3cbr\x3e 四舍五入取整: \x3cbr\x3e  Math.round(num)\x3cbr\x3e   优: 返回数字类型，可直接计算\x3cbr\x3e   缺: 不能随意指定小数位数\x3cbr\x3e  n.toFixed(d) \x3cbr\x3e   优: 可随意指定小数位数\x3cbr\x3e   缺: 返回字符串类型，不能直接做加法\x3cbr\x3e 自定义round\x3c\/li\x3e\x3c\/ol\x3e\x3c\/li\x3e\n\x3col\x3e\n\x3cli\x3e乘方和开平方:\x3cbr\x3e Math.pow(底数,幂)\x3cbr\x3e Math.sqrt(num)\x3c\/li\x3e\n\x3cli\x3e最大值和最小值\x3cbr\x3e Math.max(值1, 值2,...)\x3cbr\x3e Math.min(值1, 值2,...)\x3cbr\x3e 问题: 不支持数组\x3cbr\x3e 解决: Math.max(...arr)\x3c\/li\x3e\n\x3cli\x3e随机数: \x3cbr\x3e Math.random()   0~1 随机小数\x3cbr\x3e 公式: 在min到max之间取一个随机整数\x3cbr\x3e  parseInt(Math.random()*(max-min\x2b1)\x2bmin)\x3cbr\x3e  简写: 在0~max之间取一个随机整数\x3cbr\x3e  parseInt(Math.random()*(max\x2b1))\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e三角函数: \x3cbr\x3e 已知角度，求边长，用三角函数: sin    cos    tan\x3cbr\x3e 已知边长，求角度，用反三角函数: asin  acos   atan\x3cbr\x3e 仅以atan: \x3cbr\x3e  var 弧度=Math.atan(对边长\/邻边长)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22360角度=2π弧度\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e360\x3c\/span\x3e角度=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3eπ弧度\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题: atan无法区分角度的象限\x3cbr\x3e  解决: Math.atan2(对边长, 邻边长);\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e15.Date:\x3c\/h2\x3e\n\x3cp\x3e什么是: 保存一个时间，提供操作时间的API\x3cbr\x3e何时: 只要在程序中存储时间或操作时间，都用date\x3cbr\x3e如何: \x3cbr\x3e 创建: 4种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建日期对象，并自动获得客户端当前系统时间\x3cbr\x3e  var now=new Date();\x3c\/li\x3e\n\x3cli\x3e创建日期对象，保存自定义时间\x3cbr\x3e  var now=new Date(\x22yyyy\/MM\/dd hh:mm:ss\x22);\x3c\/li\x3e\n\x3cli\x3e用毫秒数创建日期对象:\x3cbr\x3e  var date=new Date(ms)\x3c\/li\x3e\n\x3cli\x3e复制一个日期对象: \x3cbr\x3e  问题: 日期的计算都是直接修改原日期对象\x3cbr\x3e  解决: 如果希望同时保留计算前后的开始和结束时间，都要先复制开始时间，再用副本计算结束时间\x3cbr\x3e  var date2=new Date(date1)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e本质: 起始日期对象内部保存的是一个巨大的毫秒数:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221970年1月1日至今的毫秒数\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e1970\x3c\/span\x3e年\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e月\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e日至今的毫秒数\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e文字存储日期的问题:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 有时区问题:\n2. 不便于计算:\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e有时区问题:\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e不便于计算:\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e毫秒数存储日期:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 不受时区的干扰: \n2. 便于计算: \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e不受时区的干扰: \n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e便于计算: \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总结: 将来在网络中传输或在数据库中存储时间，都用毫秒数\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e16.API:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e8个单位: \x3cbr\x3e FullYear   Month   Date   Day\x3cbr\x3e Hours    Minutes  Seconds  Milliseconds\x3c\/li\x3e\n\x3cli\x3e每个单位上都有一对儿get\/set方法:\x3cbr\x3e getXXX() 负责获得单位的值\x3cbr\x3e setXXX() 负责修改单位的值\x3cbr\x3e 特例: Day 不能修改，没有setDay()\x3c\/li\x3e\n\x3cli\x3e取值范围: \x3cbr\x3e Month: 0~11 计算机中的月份总是比现实中小1\x3cbr\x3e Date: 1~31 \x3cbr\x3e Day: 0~6 \x3cbr\x3e Hours: 0~23 \x3cbr\x3e Minutes\/Seconds: 0~59\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e日期计算:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e两日期相减: 得到的是毫秒差\x3cbr\x3e 何时: 计算时间段或计算倒计时\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对任意单位做加减: 3步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e获得单位的当前值\x3c\/li\x3e\n\x3cli\x3e做加减\x3c\/li\x3e\n\x3cli\x3e将计算后的结果set回去\x3cbr\x3e  setXXX()可自动调整时间进制\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可简化为: date.setXXX(date.getXXX()\x2bn)\x3cbr\x3e   问题: setXXX()直接修改原日期\x3cbr\x3e   解决: 如果同时保存计算前后的开始和结束时间，应该先复制副本，再用副本计算。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e17.Date:\x3c\/h2\x3e\n\x3cp\x3e日期格式化: \x3cbr\x3e  date.toString() 默认当地时间的完整版格式\x3cbr\x3e  date.toLocaleString() 转为当地时间的简化版格式\x3cbr\x3e  date.toLocaleDateString() 仅保留日期部分  \x3cbr\x3e  date.toLocaleTimeString() 仅保留时间部分\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e18.Error:\x3c\/h2\x3e\n\x3cp\x3e什么是错误: 程序执行过程中，遇到的无法继续执行的异常情况\x3cbr\x3e程序出错，都会强行中断退出。\x3cbr\x3e什么是错误处理: 即使程序出错！也保证不会中断退出\x3cbr\x3e何时: 如果希望程序，即使出错，也不会强行中断退出\x3cbr\x3e如何: \x3cbr\x3e try{\x3cbr\x3e  可能出错的正常代码\x3cbr\x3e }catch(err){\x3cbr\x3e  \/\/err: 错误对象, 自动保存了错误的信息\x3cbr\x3e  只有出错才执行的错误处理代码:\x3cbr\x3e  提示错误信息, 记录日志, 释放资源\x3cbr\x3e }\x3cbr\x3e 问题: 效率略低\x3cbr\x3e 解决: 多数try catch，都能用if...else代替\x3c\/p\x3e\n\x3cp\x3e主动抛出错误: \x3cbr\x3e throw new Error(\x22错误信息\x22)\x3cbr\x3e鄙视: js中共有几种错误类型: 6种:\x3cbr\x3e SyntaxError  语法错误\x3cbr\x3e ReferenceError 引用错误\x3cbr\x3e TypeError 类型错误\x3cbr\x3e RangeError 范围错误  参数超范围\x3c\/p\x3e\n\x3cp\x3eEvalError   URIError\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e19.Function:\x3c\/h2\x3e\n\x3cp\x3e什么是函数: 保存一段代码段的对象，再起一个名字。\x3cbr\x3e为什么: 代码重用\x3cbr\x3e何时: 只要一段代码可能被重复使用时！\x3cbr\x3e如何: \x3cbr\x3e 创建: 3种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e声明: function 函数名(参数列表){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      函数体;\n      return 返回值;\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e      函数体\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n      return 返回值\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e参数: 调用函数时，接收传入函数的数据的变量\x3cbr\x3e   何时: 如果函数自身必须某些数据才能正常执行时，就必须定义参数，从外部接收必须的数据\x3cbr\x3e  返回值: 函数的执行结果\x3cbr\x3e   何时: 如果调用者需要获得函数的执行结果时\x3cbr\x3e  调用: var 返回值=函数名(参数值列表);\x3cbr\x3e 问题: 声明提前: 在程序开始执行前，先将var声明的变量和function声明的函数，提前到当前作用域的顶部集中创建。赋值留在原地。\x3cbr\x3e 解决:\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e直接量: var 函数名=function (参数列表){\x3cbr\x3e 特点: 不会被声明提前\x3cbr\x3e 揭示: 函数名其实只是一个变量\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  函数其实是一个保存代码段的对象\n  函数名通过对象地址引用函数对象\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e  函数其实是一个保存代码段的对象\n  函数名通过对象地址引用函数对象\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3enew : \x3cbr\x3e var 函数名=\x3cbr\x3e  new Function(\x22参数1\x22,\x22参数2\x22,...,\x22函数体\x22)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3e20.重载overload:\x3c\/h2\x3e\n\x3cp\x3e什么是: 多个相同函数名，不同参数列表的函数，在调用时，可根据传入的参数不同，自动执行不同的操作。\x3cbr\x3e 为什么: 为了减少API的数量，减轻调用者的负担\x3cbr\x3e   何时: 只要一项任务，可能根据传入参数的不同，执行不同的流程时。\x3cbr\x3e   如何: js语法默认不支持重载!\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 因为: js中不允许多个同名函数，同时存在。最后一个函数会覆盖之前的。\n变通实现: arguments\n 什么是: 每个函数中，自动包含的，接收所有传入函数的参数值的类数组对象\n   类数组对象: 长得像数组的对象\n     vs 数组: 相同: 1. 下标, 2. .length, 3. 遍历\n             不同: 类型不同, API不通用\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e 因为: js中不允许多个同名函数，同时存在。最后一个函数会覆盖之前的。\n变通实现: arguments\n 什么是: 每个函数中，自动包含的，接收所有传入函数的参数值的类数组对象\n   类数组对象: 长得像数组的对象\n     vs 数组: 相同: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. 下标, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. \x3cspan class=\x22hljs-selector-class\x22\x3e.length\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. 遍历\n             不同: 类型不同, API不通用\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader21\x22\x3e21.匿名函数:\x3c\/h2\x3e\n\x3cp\x3e什么是: 定义函数时，不指定函数名\x3cbr\x3e为什么: 节约内存 或 划分临时作用域\x3cbr\x3e  何时:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e只要一个函数，希望调用后，立刻自动释放！\x3c\/li\x3e\n\x3cli\x3e划分临时作用域:\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e回调: 定义函数后，自己不调用，而是传递给另一个函数去调用\x3c\/li\x3e\n\x3cli\x3e自调: 定义函数后，立刻调用自己。\x3cbr\x3e  何时: 今后所有js代码必须都放在匿名函数自调中，避免全局污染。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader22\x22\x3e22.垃圾回收:\x3c\/h2\x3e\n\x3cp\x3e什么是垃圾: 一个不再被任何变量使用的对象\x3cbr\x3e什么是垃圾回收: js引擎会自动回收不再被使用的对象的空间。\x3cbr\x3e为什么: 内存空间都是有限的！\x3cbr\x3e垃圾回收器: 专门负责回收垃圾对象的小程序——js引擎自带\x3cbr\x3e如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e程序执行时，垃圾回收器伴随主程序执行而执行。\x3c\/li\x3e\n\x3cli\x3e每创建一个对象，垃圾回收器就会记录对象被几个变量引用着.\x3c\/li\x3e\n\x3cli\x3e如果发现一个对象不再被任何变量应用，则自动回收该对象的存储空间。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e好的习惯: 只要一个对象不再使用，就要赋值为null\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3e23.作用域和作用域链\x3c\/h2\x3e\n\x3cp\x3e作用域(scope): 一个变量的可用范围\x3cbr\x3e 为什么: 避免内部的变量影响外部\x3cbr\x3e 本质: 是一个存储变量的对象\x3cbr\x3e 包括: 2种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e全局作用域: window\x3cbr\x3e  保存全局变量: 随处可用，可反复使用\x3c\/li\x3e\n\x3cli\x3e函数作用域: ?\x3cbr\x3e  保存局部变量: 仅在函数内可用，且不可重用!\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader24\x22\x3e24.函数生命周期:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e程序开始执行前\x3cbr\x3e  在内存中创建执行环境栈(数组): 用于保存正在调用的函数任务。\x3cbr\x3e  在执行环境站中添加第一条记录: 调用浏览器主程序\x3cbr\x3e  创建全局作用域对象window: 2个作用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 保存浏览器自己需要的数据和对象\n2. 作为程序的全局作用域对象，保存全局变量\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e保存浏览器自己需要的数据和对象\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e作为程序的全局作用域对象，保存全局变量\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e定义函数时:\x3cbr\x3e  在window中定义函数名变量\x3cbr\x3e  创建函数对象保存函数定义\x3cbr\x3e  函数名变量引用函数对象\x3cbr\x3e  函数对象的scope属性，又指回了函数创建时的作用域\x3c\/li\x3e\n\x3cli\x3e调用函数时\x3cbr\x3e  在执行环境栈中添加了本次函数调用的记录\x3cbr\x3e  创建本次函数调用的函数作用域对象AO\x3cbr\x3e  在AO中添加函数的局部变量\x3cbr\x3e  设置AO的parent指向函数的scope\x3cbr\x3e  执行环境栈中的函数调用记录，引用AO\x3cbr\x3e  变量的使用顺序: 先用局部，再用全局\x3c\/li\x3e\n\x3cli\x3e函数调用后\x3cbr\x3e  本次函数调用的记录从执行环境栈中出栈\x3cbr\x3e  导致AO被释放, 导致所有局部变量都释放\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader25\x22\x3e25.作用域链:\x3c\/h2\x3e\n\x3cp\x3e什么是: 由多级作用域对象，逐级引用形成的链式结构\x3cbr\x3e2个作用:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e保存所有变量\x3c\/li\x3e\n\x3cli\x3e控制着变量的使用顺序！\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader26\x22\x3e26.闭包closure:\x3c\/h2\x3e\n\x3cp\x3e什么是: 即重用一个变量，又保护变量不被污染的一种机制\x3cbr\x3e为什么: 全局变量和局部变量都具有不可兼得的优缺点:\x3cbr\x3e 全局变量: 优: 可重用, 缺: 易被污染\x3cbr\x3e 局部变量: 优: 仅函数内可用，不会被污染\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22       缺: 不可重用!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs erlang-repl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e       缺: 不可重用!\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e何时: 只要一个变量，可能被重用，又不想被篡改\x3cbr\x3e如何: 3步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用外层函数包裹要保护的变量和内层函数\x3c\/li\x3e\n\x3cli\x3e外层函数将内层函数返回到外部\x3c\/li\x3e\n\x3cli\x3e调用外层函数，获得内层函数的对象，保存在外部的变量中——形成了闭包\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e闭包形成的原因: 外层函数调用后，外层函数的函数作用域对象无法释放\x3cbr\x3e主动使用闭包: 为一个函数绑定一个专属的变量\x3cbr\x3e鄙视: 画简图\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e找受保护的变量，并确定其最终值\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e找内层函数对象\x3cbr\x3e 外层函数向外返回内层函数对象: 3种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3ereturn function(){}\x3c\/li\x3e\n\x3cli\x3e全局变量=function(){}\x3c\/li\x3e\n\x3cli\x3ereturn arr\/obj{function(){...\x22}}\x22\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader27\x22\x3e27.OOP\x3c\/h2\x3e\n\x3cp\x3e什么是对象: 内存中存储多个数据的独立存储空间都称为一个对象。\x3cbr\x3e什么是面向对象: 程序中都是用对象结构来描述现实中一个具体事物。\x3cbr\x3e为什么: 为了便于大量数据的维护和查找\x3cbr\x3e何时: 几乎所有js程序，都使用面向对象的方式开发\x3cbr\x3e如何: 三大特点: 封装，继承，多态\x3cbr\x3e 封装: 用对象来集中描述现实中一个具体事物的属性和功能\x3cbr\x3e  为什么: 便于维护和查找\x3cbr\x3e  何时: 今后只要使用面向对象的方式开发，都要先封装对象，再按需使用对象的属性和功能。\x3cbr\x3e  如何: 3种:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e用{}: \x3cbr\x3e  var obj={\x3cbr\x3e   属性名:值,\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  ... : ... ,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  ... : ... ,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\/\/方法名:function(){...},\x3cbr\x3e   方法名 (){...},\x3cbr\x3e  }\x3cbr\x3e  其中: 事物的属性值会成为对象的属性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    对象的属性本质是保存在对象中的一个变量\n 事物的功能会成为对象的方法!\n    方法的本质是保存在对象中的一个函数\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs erlang-repl\x22\x3e\x3ccode\x3e    对象的属性本质是保存在对象中的一个变量\n 事物的功能会成为对象的方法!\n    方法的本质是保存在对象中的一个函数\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如何访问对象的成员: \x3cbr\x3e  访问对象的属性: 对象.属性名\x3cbr\x3e  调用对象的方法: 对象.方法名()\x3cbr\x3e 问题: 对象自己的方法中要使用对象自己的属性\x3cbr\x3e  错误: 直接用属性名,报错: 找不到变量\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22为什么: 默认，不加.就使用的变量，只能在作用域链中查找，无法自动进入对象中\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e为什么: 默认，不加.就使用的变量，只能在作用域链中查找，无法自动进入对象中\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解决一: 对象名.属性名\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22问题: 对象名仅是一个普通的变量名，可能发生变化。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e问题: 对象名仅是一个普通的变量名，可能发生变化。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正确解决: this.属性名\x3cbr\x3e   this: 自动指正在调用当前方法的.前的对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22为什么: 不受对象名变量的影响\n何时: 只要对象自己的方法向访问对象自己的属性时，都必须加this.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e为什么: 不受对象名变量的影响\n何时: 只要对象自己的方法向访问对象自己的属性时，都必须加\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3ejs中对象的本质，其实就是一个关联数组\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e用new: \x3cbr\x3e var obj=new Object(); \/\/创建空对象 等效于{}\x3cbr\x3e obj.属性名=值;\x3cbr\x3e obj.方法名=function(){\x3cbr\x3e   ... this.属性名 ...\x3cbr\x3e }\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e和关联数组一样，js中的对象也可随时添加新属性和方法。\x3cbr\x3e   问题: 反复创建多个相同结构的对象时，重复代码太多，导致不便于维护\x3cbr\x3e   解决:\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e用构造函数:\x3cbr\x3e 构造函数: 描述一类对象统一结构的函数\x3cbr\x3e 为什么: 为了重用结构代码!\x3cbr\x3e 何时: 只要反复创建相同结构的多个对象时，都用构造函数\x3cbr\x3e 如何: 2步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e定义构造函数\x3cbr\x3e function 类型名(属性参数列表){\x3cbr\x3e  this.属性名=属性参数;\x3cbr\x3e  this. ... = 属性参数;\x3cbr\x3e  this.方法名=function(){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.xxx\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.xxx\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e }\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e调用构造函数创建新对象\x3cbr\x3e var obj=new 类型名(属性值列表)\x3cbr\x3e new: 1. 创建新的空对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 2. 设置新对象继承构造函数的原型对象\n 3. 用新对象调用构造函数\n   将构造函数中的this都指向新对象\n 4. 返回新对象的地址\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e 设置新对象继承构造函数的原型对象\n \x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e 用新对象调用构造函数\n   将构造函数中的this都指向新对象\n \x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e 返回新对象的地址\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e问题: 构造函数只能重用代码，无法节约内存!\x3cbr\x3e  解决: 继承:\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader28\x22\x3e28.继承:\x3c\/h2\x3e\n\x3cp\x3e什么是: 父对象的成员，子对象无需创建，就可直接使用\x3cbr\x3e  为什么: 代码重用，节约内存\x3cbr\x3e   何时: 只要多个子对象，拥有相同的成员时，都应只在父对象中定义一份，所有子对象共用即可！\x3cbr\x3e   如何: js中继承都是通过原型对象实现的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22什么是原型对象: 集中存储同一类型的所有子对象，共用成员的父对象\n何时: 只要继承，必然原型对象\n如何: \n 创建: 不用创建，买一赠一\n   每创建一个构造函数，都附赠一个原型对象 \n 继承: 在创建子对象时，new的第2步自动设置子对象继承构造函数的原型对象\n 访问成员: 优先访问自有成员\n          自己没有，就去父对象(原型对象)中查找\n 将成员添加到原型对象中: \n  构造函数.prototype.成员=值\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e什么是原型对象: 集中存储同一类型的所有子对象，共用成员的父对象\n何时: 只要继承，必然原型对象\n如何: \n 创建: 不用创建，买一赠一\n   每创建一个构造函数，都附赠一个原型对象 \n 继承: 在创建子对象时，new的第\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e步自动设置子对象继承构造函数的原型对象\n 访问成员: 优先访问自有成员\n          自己没有，就去父对象(原型对象)中查找\n 将成员添加到原型对象中: \n  构造函数.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.成员=值\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e自有属性和共有属性: \x3cbr\x3e   自有属性: 保存在当前对象本地,仅归当前对象独有的属性\x3cbr\x3e   共有属性: 保存在父对象中，所有子对象共有的属性\x3cbr\x3e   读取属性值: 子对象.属性\x3cbr\x3e   修改属性值: 自有属性，必须通过子对象自己修改\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22           共有属性，只能用原型对象修改！\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e           共有属性，只能用原型对象修改！\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e内置对象的原型对象: \x3cbr\x3e   鄙视: 内置对象: 11个:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String Number Boolean ——包装类型对象\nArray Date RegExp Math\nError\nFunction  Object\nGlobal (在浏览器中，被window代替)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e ——包装类型对象\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e\nGlobal (在浏览器中，被\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e代替)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e鄙视: 包装类型的理解\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22什么是: 保存一个原始类型的值，并提供操作原始类型值的API\n为什么: 原始类型的值本身不具有任何功能\n何时: 只要试图对原始类型的值调用API时，都会自动使用包装类型对象来帮助原始类型的值执行操作。\n如何: \n 1. 内存中已经预置了三大包装类型的对象:\n   String  Number  Boolean\n 2. 在试图对原始类型的值调用API时，自动检测原始类型的值的类型名\n   var n=345.678;\n     typeof n =\x3e number\n 3. 根据类型名实例化对应的包装类型对象，调用其API\n   new Number(n).toFixed(2) =\x3e 345.68\n 4. 执行后，包装类型对象自动释放\n   new Number释放！\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e什么是: 保存一个原始类型的值，并提供操作原始类型值的API\n为什么: 原始类型的值本身不具有任何功能\n何时: 只要试图对原始类型的值调用API时，都会自动使用包装类型对象来帮助原始类型的值执行操作。\n如何: \n \x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e 内存中已经预置了三大包装类型的对象:\n   \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e\n \x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e 在试图对原始类型的值调用API时，自动检测原始类型的值的类型名\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n=\x3cspan class=\x22hljs-number\x22\x3e345.678\x3c\/span\x3e;\n     \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e n =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\n \x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e 根据类型名实例化对应的包装类型对象，调用其API\n   \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(n).toFixed(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) =\x26gt; \x3cspan class=\x22hljs-number\x22\x3e345.68\x3c\/span\x3e\n \x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e 执行后，包装类型对象自动释放\n   \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e释放！\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader29\x22\x3e29.OOP\x3c\/h2\x3e\n\x3cp\x3e面向对象三大特点: 封装，继承，多态\x3cbr\x3e继承:\x3cbr\x3e 原型对象:\x3cbr\x3e  内置类型的原型对象: \x3cbr\x3e   一种类型: 包含两部分:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 构造函数: 创建该类型的子对象\n2. 原型对象: 保存所有子对象的共有成员\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e构造函数: 创建该类型的子对象\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e原型对象: 保存所有子对象的共有成员\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解决浏览器兼容性问题: 旧浏览器无法使用新API\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 判断当前浏览器对应类型的原型对象中是否包含该API\n2. 如果不包含，则自定义该API，添加到对应类型的原型对象中\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e判断当前浏览器对应类型的原型对象中是否包含该API\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e如果不包含，则自定义该API，添加到对应类型的原型对象中\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader30\x22\x3e30.原型链:\x3c\/h2\x3e\n\x3cp\x3e什么是: 由多级父对象，逐级继承形成的链式结构\x3cbr\x3e  保存着: 所有对象的属性\x3cbr\x3e  控制着: 对象属性的使用顺序:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22先自有，再共有\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e先自有，再共有\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e鄙视: 如何判断一个对象是数组类型? 有几种方法\x3cbr\x3e  错误: typeof : 只能区分原始类型，函数，无法进一步区分引用类型对象的具体类型名\x3cbr\x3e  正确: 4种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e判断原型对象: \x3cbr\x3e obj.__proto__==Array.prototype\x3cbr\x3e Array.prototype.isPrototypeOf(obj)\x3c\/li\x3e\n\x3cli\x3e判断构造函数:\x3cbr\x3e obj.constructor==Array\x3cbr\x3e obj instanceof Array\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e问题: 不严格, 不但检查直接父对象，且检查整个原型链\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e判断对象内部的class属性\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eclass属性: 对象内部的专门记录对象创建时的类型名的属性\x3cbr\x3e   问题1: class属性是内部属性，无法用.直接访问\x3cbr\x3e   解决: 唯一的办法: Object.prototype.toString()\x3cbr\x3e   问题2: 每种类型的原型对象都重写了各自不同的toString()方法，子对象无法调用到Object.prototype.toString()\x3cbr\x3e   解决: fun.call(obj)  让obj强行调用任何一个fun\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.prototype.toString.call(obj)\n  在执行的一瞬间: obj.toString()\n  结果:\x26quot;[object Class]\x26quot;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eObject\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.toString\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.call\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3eobj\x3c\/span\x3e)\n  在执行的一瞬间: \x3cspan class=\x22hljs-selector-tag\x22\x3eobj\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.toString\x3c\/span\x3e()\n  结果\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:\x22\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[object Class]\x3c\/span\x3e\x22\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e鄙视: 何时将方法定义在原型对象中，何时将方法定义在构造函数上\x3cbr\x3e 实例方法和静态方法: \x3cbr\x3e  实例方法: 必须该类型的子对象才能调用的方法\x3cbr\x3e   比如: arr.sort()  arr.push()\x3cbr\x3e   何时: 只要要求必须该类型的子对象才能调用\x3cbr\x3e   如何: 所有放在原型对象中的方法都是实例方法\x3cbr\x3e  静态方法: 不需要创建该类型的子对象，任何对象都可使用的方法。\x3cbr\x3e   比如: Array.isArray(fun)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    Array.isArray(date)\n    Array.isArray(obj)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vbscript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eisArray\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edate\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eisArray\x3c\/span\x3e(obj)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e何时: 不确定将来调用该函数的对象类型时\x3cbr\x3e   如何: 添加到构造函数对象上的方法都是静态方法。可通过构造函数.静态方法方式直接调用！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader31\x22\x3e31.多态:\x3c\/h2\x3e\n\x3cp\x3e什么是: 一个方法在不同情况下表现出不同的状态\x3cbr\x3e包括:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e重载overload:\x3c\/li\x3e\n\x3cli\x3e重写override: \x3cbr\x3e 什么是: 如果子对象觉得从父对象继承来的成员不好用，可在本地定义同名的自有成员，覆盖父对象的成员\x3cbr\x3e 为什么: 觉得从父对象继承来的成员不好用\x3cbr\x3e 何时: 只要觉得从父对象继承来的成员不好用\x3cbr\x3e 如何: 在本地定义同名的自有成员\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader32\x22\x3e32.自定义继承:\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e只修改一个对象的父对象\x3cbr\x3eobj.__proto__=father\x3cbr\x3eObject.setPrototypeOf(obj,father)\x3c\/li\x3e\n\x3cli\x3e修改所有子对象的父对象:\x3cbr\x3e构造函数.prototype=father\x3cbr\x3e时机: 在创建子对象之前换!\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e两种类型间的继承: \x3cbr\x3e何时: 发现多个类型之间拥有部分相同的属性结构和方法定义时，都要抽象父类型出来\x3cbr\x3e如何: 2步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e定义抽象父类型: 2步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e定义构造函数保存公共的属性结构\x3c\/li\x3e\n\x3cli\x3e定义原型对象保存公共的方法\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e让子类型继承父类型: 2步:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在子类型构造函数中借用父类型构造函数\x3cbr\x3e 错误: 直接调用: Flyer(fname,speed)\x3cbr\x3e   原因: Flyer不用.不用new调用，其中的this默认指window,Flyer中所有属性泄露到全局\x3cbr\x3e 正确: 用call将正确的this注入到Flyer中，代替错误的this\x3cbr\x3e   如何: Flyer.call(正确的this, fname,speed)\x3c\/li\x3e\n\x3cli\x3e让子类型原型对象继承父类型原型对象\x3cbr\x3e  Object.setPrototypeOf(子类型原型,父类型原型)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader33\x22\x3e33.ECMAScript6\x3c\/h2\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e严格模式:\x3cbr\x3e什么是: 比普通js运行机制要求更严格的模式\x3cbr\x3e为什么: 普通的js运行机制有很多广受诟病的缺陷\x3cbr\x3e何时: 今后所有项目必须运行在严格模式下\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果新项目，整个js文件启用严格模式\x3c\/li\x3e\n\x3cli\x3e旧项目，逐个函数启用严格模式\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在script或整个js文件顶部，添加\x22use strict\x22;\x3c\/li\x3e\n\x3cli\x3e在函数内顶部，添加\x22use strict\x22;\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e规则: 4个:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e禁止给未声明的变量赋值\x3c\/li\x3e\n\x3cli\x3e将静默失败升级为错误\x3c\/li\x3e\n\x3cli\x3e普通函数或匿名函数自调中的this默认不再指向window，而是undefined\x3c\/li\x3e\n\x3cli\x3e禁止使用arguments, arguments.callee,...\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e补: arguments.callee 自动获得当前正在调用的函数本身\x3cbr\x3e  禁用，说明强烈不推荐使用递归！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader34\x22\x3e34.保护对象:\x3c\/h2\x3e\n\x3cp\x3e保护对象的属性:\x3cbr\x3eES5将对象属性分为:\x3cbr\x3e 命名属性: 可用.直接访问到的属性\x3cbr\x3e  数据属性: 直接存储属性值的属性\x3cbr\x3e   保护数据属性: 4大特性:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22一个属性包含四大特性:{\n  value: 实际保存属性值,\n  writable: true\/false, \/\/只读\n  enumerable: true\/false, \/\/不可遍历\n    \/\/不是彻底隐藏，用.依然可访问！\n  configurable:true\/false \/\/1. 禁止删除\n                     \/\/2. 禁止修改其它特性\n                     \/\/一旦改为false，不可逆\n}\n获取一个属性的四大特性:\nvar attrs=Object.getOwnPropertyDescriptor(obj,\x26quot;属性\x26quot;)\n修改四大特性:\nObject.defineProperty(obj,\x26quot;属性\x26quot;,{\n  四大特性:值\n})\n简写: Object.defineProperties(obj,{\n       属性名:{\n         特性:值,\n         特性:值,\n       },\n       属性名:{\n         ... : ...\n       }\n     })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e一个属性包含四大特性:{\n  value: 实际保存属性值,\n  writable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/只读\x3c\/span\x3e\n  enumerable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/不可遍历\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/不是彻底隐藏，用.依然可访问！\x3c\/span\x3e\n  configurable:\x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/1. 禁止删除\x3c\/span\x3e\n                     \x3cspan class=\x22hljs-comment\x22\x3e\/\/2. 禁止修改其它特性\x3c\/span\x3e\n                     \x3cspan class=\x22hljs-comment\x22\x3e\/\/一旦改为false，不可逆\x3c\/span\x3e\n}\n获取一个属性的四大特性:\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e attrs=\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(obj,\x3cspan class=\x22hljs-string\x22\x3e\x22属性\x22\x3c\/span\x3e)\n修改四大特性:\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj,\x3cspan class=\x22hljs-string\x22\x3e\x22属性\x22\x3c\/span\x3e,{\n  四大特性:值\n})\n简写: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(obj,{\n       属性名:{\n         特性:值,\n         特性:值,\n       },\n       属性名:{\n         ... : ...\n       }\n     })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e访问器属性: 不直接存储属性值，仅提供对另一个数据属性的保护\x3cbr\x3e   何时: 只要对一个属性提供自定义规则的保护\x3cbr\x3e   如何:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22添加: 只能用Object.defineProperty和defineProperties添加\n四大特性: {\n  get(){ return this.数据属性 }\n  set(val){ \n    如果验证val通过\n      this.数据属性=val\n    否则\n      报错\n  }\n  enumerable:\n  configurable:\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e添加: 只能用Object.defineProperty和defineProperties添加\n四大特性: {\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(){ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.数据属性 }\n  \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e){ \n    如果验证\x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e通过\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.数据属性=\x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e\n    否则\n      报错\n  }\n  enumerable:\n  configurable:\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如何使用: 同普通的数据属性用法一样!\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 在取值时，自动调用访问器属性内部的get\n 在赋值时，自动调用访问器属性内部的set方法，同时将等号右边的新值，交给val参数\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e 在取值时，自动调用访问器属性内部的\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e\n 在赋值时，自动调用访问器属性内部的\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e方法，同时将等号右边的新值，交给\x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e参数\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题: enumerable只能防住for in,防不住.，依然可用.直接修改被保护的数据属性\x3cbr\x3e   解决: \x3cbr\x3e 内部属性: 不能用.直接访问到的属性\x3cbr\x3e  比如: class  \x3cstrong\x3eproto\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e保护对象的结构: 3种\x3c\/p\x3e\n\x3cli\x3e\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e防扩展: 禁止给对象添加新属性\x3cbr\x3eObject.preventExtensions(obj)\x3cbr\x3e原理: 内部属性: extensible:true\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  preventExtensions将extensible改为false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  preventExtensions将extensible改为\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e密封: 在防扩展同时，禁止删除现有属性\x3cbr\x3eObject.seal(obj)\x3cbr\x3e原理: 1. 将extensible改为false，禁止扩展\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 2. 自动将所有属性的configurable都改为false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e \x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e 自动将所有属性的configurable都改为\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e冻结: 在密封的同时，禁止修改一切属性值\x3cbr\x3eObject.freeze(obj)\x3cbr\x3e原理: 1. 兼具密封的所有功能\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 2. 又将每个属性的writable自动改为false！\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e 又将每个属性的writable自动改为\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e！\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/li\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3eObject.create()\x3cbr\x3e仅用父对象，就可创建子对象, \x3cbr\x3e同时还可为子对象扩展自有属性\x3cbr\x3evar child=Object.create(father,{\x3cbr\x3e  \/\/Object.defineProperties\x3cbr\x3e  属性名:{\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22特性:值,\n特性:值,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e特性:值,\n特性:值,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3cbr\x3e鄙视: 描述Object.create的执行原理\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建空对象child\x3c\/li\x3e\n\x3cli\x3e自动设置child的__proto__为father\x3c\/li\x3e\n\x3cli\x3e为child扩展新的自有属性\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader35\x22\x3e35.call\/apply\/bind\x3c\/h2\x3e\n\x3cp\x3e替换函数中不想要的this！\x3cbr\x3e call\/apply: 立刻调用函数，并临时替换中的this为指定对象\x3cbr\x3e  何时: 只要调用函数时，函数中的this不是想要的就用call换成想要的\x3cbr\x3e  如果传入函数的参数，是以数组形式，整体传入\x3cbr\x3e  就用.apply(obj,arr)\x3cbr\x3e bind: 基于原函数，创建一个新函数，并永久绑定this为指定对象\x3cbr\x3e  何时: 不会立刻调用的函数(回调函数)中的this，不是想要的，就可用bind创建一个新函数，并永久绑定this！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader36\x22\x3e36.数组API:\x3c\/h2\x3e\n\x3cp\x3e判断:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e判断数组中所有元素是否都符合条件\x3cbr\x3e  arr.every(function(elem,i,arr){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/elem: 当前元素值\n\/\/i: 当前位置 \n\/\/arr: 当前数组对象\nreturn 判断条件\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/elem: 当前元素值\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/i: 当前位置 \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/arr: 当前数组对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e 判断条件\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e判断数组中是否包含符合条件的元素\x3cbr\x3e  arr.some(function(elem,i,arr){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return 判断条件\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e 判断条件\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e遍历:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eforEach: 对原数组中每个元素执行相同的操作\x3cbr\x3e arr.forEach(function(elem,i,arr){\x3cbr\x3e   arr[i]=新值\x3cbr\x3e })\x3c\/li\x3e\n\x3cli\x3emap: 依次取出原数组中每个元素执行相同操作后，放入新数组。原数组不变\x3cbr\x3e arr.map(function(elem,i,arr){\x3cbr\x3e   return 新值\x3cbr\x3e })\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e过滤和汇总:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e过滤: 复制出原数组中符合条件的元素，放入新数组返回\x3cbr\x3e var subs=arr.filter(function(elem,i,arr){\x3cbr\x3e   return 判断条件\x3cbr\x3e })\x3c\/li\x3e\n\x3cli\x3e汇总: 将原数组中所有值统计出一个最终结论\x3cbr\x3e var result=arr.reduce(function(prev,elem,i,arr){\x3cbr\x3e   \/\/prev: 截止到目前，之前的临时汇总值\x3cbr\x3e   return prev\x2belem;\x3cbr\x3e })\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader37\x22\x3e37.let: 代替var\x3c\/h2\x3e\n\x3cp\x3e为什么\x3cbr\x3e 问题1: 声明提前, 破坏程序原有执行顺序\x3cbr\x3e 解决: let禁止在声明之前，提前使用该变量\x3cbr\x3e 问题2: js没有块级作用域, 块内的变量，会污染到块外\x3cbr\x3e 解决: let会将当前所在if\/for\/while...(){}变成块级作用域\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  后果: 块内的let出的变量不会影响外部！\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs bash\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  后果: 块内的\x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e出的变量不会影响外部！\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原理: 其实let就是匿名函数自调！\x3cbr\x3elet与for循环，可形成闭包的效果\x3cbr\x3e强调: 原来块内外都可使用的变量，出了块，就不能用了！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader38\x22\x3e38.参数增强:\x3c\/h2\x3e\n\x3cp\x3e默认值: function fun(参数1, 参数2,...,参数n=默认值)\x3cbr\x3e  强调: 带默认值的参数必须定义在列表末尾\x3cbr\x3e  原理: 参数n=参数n||默认值;\x3cbr\x3erest: 代替了arguments\x3cbr\x3e 何时: 当函数，不确定参数个数时——重载\x3cbr\x3e 为什么: arguments的缺点:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e类数组对象，不是数组\x3c\/li\x3e\n\x3cli\x3e只能后去全部，不能有选择的分段获取\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如何: 定义函数时: function fun(参数1,参数2,...,  ...数组名)\x3cbr\x3e   数组名, 是一个纯正的数组，且可有选择的分段获取\x3cbr\x3e 原理: var arr=[].slice.call(arguments[,starti]);\/\/将类数组对象转为数组\x3cbr\x3espread: 代替apply\x3cbr\x3e 为什么: apply虽然可打散数组类型参数为单个值，但是必须和替换this的操作捆绑使用\x3cbr\x3e 何时: 只要仅需要打散数组类型参数为单个值时\x3cbr\x3e 如何: 调用时: fun(参数值1,参数值2,...数组)\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e箭头函数: 代替回调函数中的function\x3c\/li\x3e\x3c\/ol\x3e\n\x3chr\x3e\n\x3cp\x3e何时: 只要回调函数，都不再使用function，而是使用箭头函数\x3cbr\x3e 如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e去function改=\x26gt;\x3c\/li\x3e\n\x3cli\x3e如果只有一个参数，可省略()\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果函数体只有一句话，则{}可省略\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22更简化: 如果仅有的一句话还是return，可省略return\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e更简化: 如果仅有的一句话还是\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e，可省略\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e特点: 内外共用同一个this ——代替bind\x3cbr\x3e  问题: 如果反而希望内外this不通用时，就不能用箭头函数\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader39\x22\x3e40.模板字符串: 代替\x2b号拼接字符串\x3c\/h2\x3e\n\x3cp\x3eESLint规定，不允许使用\x2b拼接字符串\x3cbr\x3e 如何:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e定义模板: 左右模板内容都必须放在``中\x3c\/li\x3e\n\x3cli\x3e在模板中嵌入变量或表达式，动态生成内容:\x3cbr\x3e  模板内，可用${...}嵌入任何合法的js变量或语句\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader40\x22\x3e41.解构: 简化批量赋值\x3c\/h2\x3e\n\x3cp\x3e什么是: 将一个对象\/数组中的成员和元素，分别提取出来，单独使用。\x3cbr\x3e 为什么: 避免反复使用对象名\/数组名\x3cbr\x3e 何时: 只要希望将一个大的对象或数组中的每个成员单独取出使用时\x3cbr\x3e 如何: 3种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e数组解构: 下标对下标\x3c\/li\x3e\n\x3cli\x3e对象解构: 属性对属性\x3c\/li\x3e\n\x3cli\x3e参数解构: 属性对属性\x3cbr\x3e 定义函数时: \x3cbr\x3e  问题: 普通函数的参数列表的顺序和个数是固定的\x3cbr\x3e  解决: 使用对象语法定义参数列表\x3cbr\x3e   优点: 将来传入的参数个数，顺序与对象列表无关\x3cbr\x3e 调用函数: 也用对象语法传入参数\x3cbr\x3e 赋值过程中，采用对象结构的方式，为参数变量赋值\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader41\x22\x3e42.for...of 在特定情况下，代替for循环\x3c\/h2\x3e\n\x3cp\x3e什么是: 依次遍历数组\/类数组对象中每个元素的值\x3cbr\x3e  vs for...in: 依次遍历关联数组\/对象中每个成员的属性名\x3cbr\x3e 何时: 如果希望从头到尾遍历整个数组或类数组对象\x3cbr\x3e 如何: for(var elem of arr){\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    elem\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eelem\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e局限: 无法获得当前位置; 无法控制遍历的进度\/顺序; 无法有选择的遍历部分\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader42\x22\x3e43.class: 代替传统的封装，继承，多态的语法\x3c\/h2\x3e\n\x3cp\x3e封装: \x3cbr\x3e  class Student {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  constructor(sname,sage){\n    ... ...\n  }\n  intr (){\/\/Student.prototype.intr\n    \n  } \n  fun (){\n\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(sname,sage)\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n    ... ...\n  }\x3c\/span\x3e\n  \x3cspan class=\x22hljs-title\x22\x3eintr\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\/\/Student.prototype.intr\n    \n  }\x3c\/span\x3e \n  \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n\n  }\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e 继承: \x3cbr\x3e  class Flyer {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(fname,speed){\n  ... ...\n}\nfly (){\n  ... ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fname,speed)\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  ... ...\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3efly\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  ... ...\n}\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e  class Plane extends Flyer{\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(fname,speed,score){\n  \/\/super指向父类型构造函数，且自动替换this\n  super(fname,speed)\n  ... ...\n}\ngetScore (){\n  ... ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fname,speed,score)\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  \/\/super指向父类型构造函数，且自动替换this\n  super(fname,speed)\n  ... ...\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3egetScore\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  ... ...\n}\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3c\/p\x3e\n\x3cp\x3e静态方法: \x3cbr\x3e  class User{\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(uname,upwd){\n  this.uname=uname;\n  this.upwd=upwd;\n}\nsave(){\/\/保存在User.prototype中的实例方法\n  console.log(\x26quot;保存当前对象\x26quot;);\n}\nstatic  findOne(){\/\/静态方法，定义在构造函数上\n  return new User();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(uname,upwd)\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  this.uname=uname;\n  this.upwd=upwd;\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3esave\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\/\/保存在User.prototype中的实例方法\n  console.log(\x22保存当前对象\x22);\n}\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3estatic\x3c\/span\x3e  \x3cspan class=\x22hljs-title\x22\x3efindOne\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\/\/静态方法，定义在构造函数上\n  return new User();\n}\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e  var user=new User(...);\x3cbr\x3e  user.save();\/\/调用实例方法\x3cbr\x3e  User.findOne();\/\/调用静态方法\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader43\x22\x3e44.Promise: 解决: 回调地狱\x3c\/h2\x3e\n\x3cp\x3e什么是callback hell: 由于使用参数传递回调函数，导致步骤多时，参数的嵌套层级很深。\x3cbr\x3e 何时: 只要异步调用，可能发生延迟时，都要用Promise代替传统参数callback\x3cbr\x3e 如何: 定义时\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  function 第一件事(){\n    return new Promise(fn=\x3e{\n      第一件事的内容\n      fn()\n    })\n  }\n  function 第二件事(){\n    return new Promise(fn=\x3e{\n      第二件事的内容\n      fn()\n    })\n  }\n  function 第三件事(){\n    第三件事的内容\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e 第一件事(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      第一件事的内容\n      fn()\n    })\n  }\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e 第二件事(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      第二件事的内容\n      fn()\n    })\n  }\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e 第三件事(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    第三件事的内容\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e调用时:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22第一件事()\/\/return Promise(fn)\n  .then(第二件事)\/\/return Promise(fn)\n  .then(第三件事)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e第一件事()\/\/\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Promise(fn)\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(第二件事)\/\/\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Promise(fn)\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(第三件事)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e鄙视题:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e将类数组对象复制为数组:\x3cbr\x3e var arr2=Array.prototype.slice.call(arguments)\x3cbr\x3e 将类数组对象复制为数组，并选取指定位置的剩余元素\x3cbr\x3e var arr2= Array.prototype.slice.call(arguments,starti)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     相当于arguments.slice(starti)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e     相当于\x3cspan class=\x22hljs-selector-tag\x22\x3earguments\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.slice\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3estarti\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实更简单的: var arr2= [].slice.call(arguments,starti)\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3epromise中的错误处理:\x3cbr\x3e 其实: new Promise(可接收2件事)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22       .then(   )  .catch(    )\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e       .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(   )  .\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(    )\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3enew Promise((正常函数,出错函数)=\x26gt;{\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22如果顺利执行:\n  调用正常()\n否则\n  调用出错()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gcode\x22\x3e\x3ccode\x3e如果顺利执行:\n  调用正常\x3cspan class=\x22hljs-comment\x22\x3e()\x3c\/span\x3e\n否则\n  调用出错\x3cspan class=\x22hljs-comment\x22\x3e()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e})\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e等待多个任务完成\x3cbr\x3e前提: 每个任务都必须都返回Promise\x3cbr\x3e如何: Promise.all([\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   task1(), task2(),...\n ]).then(()=\x3e{所有任务完成后才执行的任务})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e   task1(), task2(),...\n ]).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{所有任务完成后才执行的任务})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3chr\x3e\n\x3col\x3e\x3cli id=\x22fn-1\x22\x3e47 \x3ca href=\x22#fnref-1\x22 class=\x22footnote-backref\x22\x3e↩\x3c\/a\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端知识点总结——JS高级（持续更新中）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014155746">https://segmentfault.com/a/1190000014155746</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/l5ufbepn1wn/" target="_blank">https://alili.tech/archive/l5ufbepn1wn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>