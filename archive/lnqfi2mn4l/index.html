<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] 关于 `ExpressionChangedAfterItHasBeenCheckedError` 错误你所需要知道的事情"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] 关于 `ExpressionChangedAfterItHasBeenCheckedError` 错误你所需要知道的事情 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/lnqfi2mn4l/",
				"appid": "1613049289050283", 
				"title": "[译] 关于 `ExpressionChangedAfterItHasBeenCheckedError` 错误你所需要知道的事情 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wc8j3gd6ozn/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vqn88kdx55k/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&text=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&text=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&title=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&is_video=false&description=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&title=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&title=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&title=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flnqfi2mn4l%2f&title=%5b%e8%af%91%5d%20%e5%85%b3%e4%ba%8e%20%60ExpressionChangedAfterItHasBeenCheckedError%60%20%e9%94%99%e8%af%af%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%e6%83%85"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] 关于 `ExpressionChangedAfterItHasBeenCheckedError` 错误你所需要知道的事情</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e原文链接：\x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angularindepth.com\/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEverything you need to know about the \x3ccode\x3eExpressionChangedAfterItHasBeenCheckedError\x3c\/code\x3e error\x3c\/a\x3e\x3c\/strong\x3e\n\x3c\/blockquote\x3e\n\x3cblockquote\x3e关于 \x3ccode\x3eExpressionChangedAfterItHasBeenCheckedError\x3c\/code\x3e，还可以参考这篇文章，并且文中有 \x3ccode\x3eyoutube\x3c\/code\x3e 视频讲解：\x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angular-university.io\/angular-debugging\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular Debugging \x22Expression has changed after it was checked\x22: Simple Explanation (and Fix)\x3c\/a\x3e\x3c\/strong\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e最近 stackoverflow 上几乎每天都有人提到 Angular 抛出的一个错误：\x3ccode\x3eExpressionChangedAfterItHasBeenCheckedError\x3c\/code\x3e，通常提出这个问题的 Angular 开发者都不理解变更检测（change detection）的原理，不理解为何产生这个错误的数据更新检查是必须的，甚至很多开发者认为这是 Angular 框架的一个 bug（译者注：Angular 提供变更检测功能，包括自动触发和手动触发，自动触发是默认的，手动触发是在使用 \x3ccode\x3eChangeDetectionStrategy.OnPush\x3c\/code\x3e 关闭自动触发的情况下生效。如何手动触发，参考 \x3cstrong\x3e\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/34827334\/triggering-change-detection-manually-in-angular\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTriggering change detection manually in Angular\x3c\/a\x3e\x3c\/strong\x3e）。当然不是了！其实这是 Angular 的警告机制，防止由于模型数据（model data）与视图 UI 不一致，导致页面上存在错误或过时的数据展示给用户。\x3c\/p\x3e\n\x3cp\x3e本文将解释引起这个错误的内在原因，检测机制的内部原理，提供导致这个错误的共同行为，并给出修复这个错误的解决方案。最后章节解释为什么数据更新检查是如此重要。\x3c\/p\x3e\n\x3cp\x3eIt seems that the more links to the sources I put in the article the less likely people are to recommend it ?. That’s why there will be no reference to the sources in this article.（译者注：这是作者的吐槽，不翻译）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e相关变更检测行为\x3c\/h2\x3e\n\x3cp\x3e一个运行的 Angular 程序其实是一个组件树，在变更检测期间，Angular 会按照以下顺序检查每一个组件（译者注：这个列表称为列表 1）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/hackernoon.com\/the-mechanics-of-property-bindings-update-in-angular-39c0812bc4ce\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e更新所有子组件\/指令的绑定属性\x3c\/a\x3e\x3c\/strong\x3e\x3c\/li\x3e\n\x3cli\x3e调用所有子组件\/指令的三个生命周期钩子：\x3ccode\x3engOnInit\x3c\/code\x3e，\x3ccode\x3eOnChanges\x3c\/code\x3e，\x3ccode\x3engDoCheck\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/hackernoon.com\/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e更新当前组件的 DOM\x3c\/a\x3e\x3c\/strong\x3e\x3c\/li\x3e\n\x3cli\x3e为子组件执行变更检测（译者注：在子组件上重复上面三个步骤，依次递归下去）\x3c\/li\x3e\n\x3cli\x3e为所有子组件\/指令调用当前组件的 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 生命周期钩子\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在变更检测期间还会有其他操作，可以参考我写的文章：\x3cstrong\x3e\x3ca href=\x22https:\/\/hackernoon.com\/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Everything you need to know about change detection in Angular》\x3c\/a\x3e\x3c\/strong\x3e 。\x3c\/p\x3e\n\x3cp\x3e在每一次操作后，Angular 会记下执行当前操作所需要的值，并存放在组件视图的 \x3ccode\x3eoldValues\x3c\/code\x3e 属性里（译者注：Angular Compiler 会把每一个组件编译为对应的 view class，即组件视图类）。在所有组件的检查更新操作完成后，Angular 并不是马上接着执行上面列表中的操作，而是会开始下一次 \x3cstrong\x3e\x3ca href=\x22https:\/\/hackernoon.com\/angulars-digest-is-reborn-in-the-newer-version-of-angular-718a961ebd3e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edigest cycle\x3c\/a\x3e\x3c\/strong\x3e，即 Angular 会把来自上一次 digest cycle 的值与当前值比较（译者注：这个列表称为列表 2）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e检查已经传给子组件用来更新其属性的值，是否与当前将要传入的值相同\x3c\/li\x3e\n\x3cli\x3e检查已经传给当前组件用来更新 DOM 值，是否与当前将要传入的值相同\x3c\/li\x3e\n\x3cli\x3e针对每一个子组件执行相同的检查（译者注：就是如果子组件还有子组件，子组件会继续执行上面两步的操作，依次递归下去。）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e记住这个检查只在开发环境下执行，我会在后文解释原因。\x3c\/p\x3e\n\x3cp\x3e让我们一起看一个简单示例，假设你有一个父组件 \x3ccode\x3eA\x3c\/code\x3e 和一个子组件 \x3ccode\x3eB\x3c\/code\x3e，而 \x3ccode\x3eA\x3c\/code\x3e 组件有 \x3ccode\x3ename\x3c\/code\x3e 和 \x3ccode\x3etext\x3c\/code\x3e 属性，在 \x3ccode\x3eA\x3c\/code\x3e 组件模板里使用 \x3ccode\x3ename\x3c\/code\x3e 属性的模板表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22template: \x27\x3cspan\x3e\x22{{\x22name\x22}}\x22\x3c\/span\x3e\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3etemplate: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;span\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/span\x26gt;\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同时，还有一个 \x3ccode\x3eB\x3c\/code\x3e 子组件，并将 \x3ccode\x3eA\x3c\/code\x3e 父组件的 \x3ccode\x3etext\x3c\/code\x3e 属性以输入属性绑定方式传给 \x3ccode\x3eB\x3c\/code\x3e 子组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27a-comp\x27,\n    template: `\n        \x3cspan\x3e\x22{{\x22name\x22}}\x22\x3c\/span\x3e\n        \x3cb-comp [text]=\x26quot;text\x26quot;\x3e\x3c\/b-comp\x3e\n    `\n})\nexport class AComponent {\n    name = \x27I am A component\x27;\n    text = \x27A message for the child component`;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n    selector: \x3cspan class=\x22hljs-string\x22\x3e\x27a-comp\x27\x3c\/span\x3e,\n    template: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;span\x26gt;\x22{{\x22name\x22}}\x22\x26lt;\/span\x26gt;\n        \x26lt;b-comp [text]=\x22text\x22\x26gt;\x26lt;\/b-comp\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AComponent {\n    name = \x3cspan class=\x22hljs-string\x22\x3e\x27I am A component\x27\x3c\/span\x3e;\n    text = \x3cspan class=\x22hljs-string\x22\x3e\x27A message for the child component`;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么当 Angular 执行变更检测的时候会发生什么呢？首先是从检查父组件 \x3ccode\x3eA\x3c\/code\x3e 开始，根据上面列表 1 列出的行为，第一步是\x3ccode\x3e更新所有子组件\/指令的绑定属性（binding property）\x3c\/code\x3e，所以 Angular 会计算 \x3ccode\x3etext\x3c\/code\x3e 表达式的值为 \x3ccode\x3eA message for the child component\x3c\/code\x3e，并将值向下传给子组件 \x3ccode\x3eB\x3c\/code\x3e，同时，Angular 还会在当前组件视图中存储这个值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22view.oldValues[0] = \x27A message for the child component\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eview.oldValues[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27A message for the child component\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二步是执行上面列表 1 列出的执行几个生命周期钩子。（译者注：即调用子组件 \x3ccode\x3eB\x3c\/code\x3e 的 \x3ccode\x3engOnInit\x3c\/code\x3e，\x3ccode\x3eOnChanges\x3c\/code\x3e，\x3ccode\x3engDoCheck\x3c\/code\x3e 这三个生命周期钩子。）\x3c\/p\x3e\n\x3cp\x3e第三步是计算模板表达式 \x3ccode\x3e\x22{{\x22name\x22}}\x22\x3c\/code\x3e 的值为 \x3ccode\x3eI am A component\x3c\/code\x3e，然后更新当前组件 \x3ccode\x3eA\x3c\/code\x3e 的 DOM，同时，Angular 还会在当前组件视图中存储这个值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22view.oldValues[1] = \x27I am A component\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs prolog\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eview.oldValues[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27I am A component\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第四步是为子组件 \x3ccode\x3eB\x3c\/code\x3e 执行以上第一步到第三步的相同操作，一旦 \x3ccode\x3eB\x3c\/code\x3e 组件检查完毕，那本次 digest loop 结束。（译者注：我们知道 Angular 程序是由组件树构成的，当前父组件 \x3ccode\x3eA\x3c\/code\x3e 组件做了第一二三步，完事后子组件 \x3ccode\x3eB\x3c\/code\x3e 同样会去做第一二三步，如果 \x3ccode\x3eB\x3c\/code\x3e 组件还有子组件 \x3ccode\x3eC\x3c\/code\x3e，同样 \x3ccode\x3eC\x3c\/code\x3e 也会做第一二三步，一直递归下去，直到当前树枝的最末端，即最后一个组件没有子组件为止。这一次过程称为 digest loop。）\x3c\/p\x3e\n\x3cp\x3e如果处于开发者模式，Angular 还会执行上面列表 2 列出的 digest cycle 循环核查。现在假设当 \x3ccode\x3eA\x3c\/code\x3e 组件已经把 \x3ccode\x3etext\x3c\/code\x3e 属性值向下传入给 \x3ccode\x3eB\x3c\/code\x3e 组件并保存该值后，这时 \x3ccode\x3etext\x3c\/code\x3e 值突变为 \x3ccode\x3eupdated text\x3c\/code\x3e，这样在 Angular 运行 digest cycle 循环核查时，会执行列表 2 中第一步操作，即检查当前digest cycle 的 text 属性值与上一次时的 text 属性值是否发生变化：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22AComponentView.instance.text === view.oldValues[0]; \/\/ false\n\x27A message for the child component\x27 === \x27updated text\x27; \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3eAComponentView.instance.text === view.oldValues[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27A message for the child component\x27\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27updated text\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果是发生变化，这时 Angular 会抛出 \x3ccode\x3eExpressionChangedAfterItHasBeenCheckedError\x3c\/code\x3e 错误。\x3c\/p\x3e\n\x3cp\x3e列表 1 中第三步操作也同样会执行 digest cycle 循环检查，如果 \x3ccode\x3ename\x3c\/code\x3e 属性已经在 DOM 中被渲染，并且在组件视图中已经被存储了，那这时 \x3ccode\x3ename\x3c\/code\x3e 属性值突变同样会有同样错误：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22AComponentView.instance.name === view.oldValues[1]; \/\/ false\n\x27I am A component\x27 === \x27updated name\x27; \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3eAComponentView.instance.name === view.oldValues[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]; \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27I am A component\x27\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可能会问上面提到的 \x3ccode\x3etext\x3c\/code\x3e 或 \x3ccode\x3ename\x3c\/code\x3e 属性值发生突变，这会发生么？让我们一起往下看。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e属性值突变的原因\x3c\/h2\x3e\n\x3cp\x3e属性值突变的罪魁祸首是子组件或指令，一起看一个简单证明示例吧。我会先使用最简单的例子，然后举个更贴近现实的例子。你可能知道子组件或指令可以注入它们的父组件，假设子组件 \x3ccode\x3eB\x3c\/code\x3e 注入它的父组件 \x3ccode\x3eA\x3c\/code\x3e，然后更新绑定属性 \x3ccode\x3etext\x3c\/code\x3e。我们在子组件 \x3ccode\x3eB\x3c\/code\x3e 的 \x3ccode\x3engOnInit\x3c\/code\x3e 生命周期钩子中更新父组件 \x3ccode\x3eA\x3c\/code\x3e 的属性，这是因为 \x3ccode\x3engOnInit\x3c\/code\x3e 生命周期钩子会在属性绑定完成后触发（译者注：参考列表 1，第一二步操作）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class BComponent {\n    @Input() text;\n\n    constructor(private parent: AppComponent) {}\n\n    ngOnInit() {\n        this.parent.text = \x27updated text\x27;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e BComponent {\n    \x3cspan class=\x22hljs-meta\x22\x3e@Input\x3c\/span\x3e() text;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e parent: AppComponent\x3c\/span\x3e) {}\n\n    ngOnInit() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.text = \x3cspan class=\x22hljs-string\x22\x3e\x27updated text\x27\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e果然会报错：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: \x27A message for the child component\x27. Current value: \x27updated text\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: \x3cspan class=\x22hljs-string\x22\x3e\x27A message for the child component\x27\x3c\/span\x3e. Current value: \x3cspan class=\x22hljs-string\x22\x3e\x27updated text\x27\x3c\/span\x3e.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们再同样改变父组件 \x3ccode\x3eA\x3c\/code\x3e 的 \x3ccode\x3ename\x3c\/code\x3e 属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ngOnInit() {\n    this.parent.name = \x27updated name\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3engOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.name = \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e纳尼，居然没有报错！！！怎么可能？\x3c\/p\x3e\n\x3cp\x3e如果你往上翻看列表 1 的操作执行顺序，你会发现 \x3ccode\x3engOnInit\x3c\/code\x3e 生命周期钩子会在 DOM 更新操作执行前触发，所以不会报错。为了有报错，看来我们需要换一个生命周期钩子，\x3ccode\x3engAfterViewInit\x3c\/code\x3e 是个不错的选项：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class BComponent {\n    @Input() text;\n\n    constructor(private parent: AppComponent) {}\n\n    ngAfterViewInit() {\n        this.parent.name = \x27updated name\x27;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e BComponent {\n    \x3cspan class=\x22hljs-meta\x22\x3e@Input\x3c\/span\x3e() text;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e parent: AppComponent\x3c\/span\x3e) {}\n\n    ngAfterViewInit() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.name = \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还好，终于有报错了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22AppComponent.ngfactory.js:8 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: \x27I am A component\x27. Current value: \x27updated name\x27.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eAppComponent.ngfactory.\x3cspan class=\x22hljs-string\x22\x3ejs:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e ERROR \x3cspan class=\x22hljs-string\x22\x3eError:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eExpressionChangedAfterItHasBeenCheckedError:\x3c\/span\x3e Expression has changed after it was checked. Previous \x3cspan class=\x22hljs-string\x22\x3evalue:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27I am A component\x27\x3c\/span\x3e. Current \x3cspan class=\x22hljs-string\x22\x3evalue:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然，真实世界的例子会更加复杂，改变父组件属性从而引发 DOM 渲染，通常间接是因为使用服务（services）或可观察者（observables）引发的，不过根本原因还是一样的。\x3c\/p\x3e\n\x3cp\x3e现在让我们看看真实世界的案例吧。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e共享服务（Shared service）\x3c\/h3\x3e\n\x3cp\x3e这个模式案例可查看代码 \x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/VtcGEuBpAC3mQ0MFPcbU?p=preview\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eplunker\x3c\/a\x3e\x3c\/strong\x3e。这个程序设计为父子组件有个共享的服务，子组件修改了共享服务的某个属性值，响应式地导致父组件的属性值发生改变。我把它称为非直接父组件属性更新，因为不像上面的示例，它明显不是子组件立刻改变父组件属性值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e同步事件广播\x3c\/h3\x3e\n\x3cp\x3e这个模式案例可查看代码 \x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/VtcGEuBpAC3mQ0MFPcbU?p=preview\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eplunker\x3c\/a\x3e\x3c\/strong\x3e。这个程序设计为子组件抛出一个事件，而父组件监听这个事件，而这个事件会引起父组件属性值发生改变。同时这些属性值又被父组件作为输入属性绑定传给子组件。这也是非直接父组件属性更新。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e动态组件实例化\x3c\/h3\x3e\n\x3cp\x3e这个模式有点不同于前面两个影响的是输入属性绑定，它引起的是 DOM 更新从而抛出错误，可查看代码 \x3cstrong\x3e\x3ca href=\x22https:\/\/plnkr.co\/edit\/lehon0WU14LxDIZFZcmp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eplunker\x3c\/a\x3e\x3c\/strong\x3e。这个程序设计为父组件在 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 生命周期钩子动态添加子组件。因为添加子组件会触发 DOM 修改，并且 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 生命周期钩子也是在 DOM 更新后触发的，所以同样会抛出错误。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e解决方案\x3c\/h2\x3e\n\x3cp\x3e如果你仔细查看错误描述的最后部分：\x3c\/p\x3e\n\x3cblockquote\x3eExpression has changed after it was checked. Previous value:… Has it been created\x26nbsp;\x3cstrong\x3ein a change detection hook\x3c\/strong\x3e\x26nbsp;?\x3c\/blockquote\x3e\n\x3cp\x3e根据上面描述，通常的解决方案是使用正确的生命周期钩子来创建动态组件。例如上面创建动态组件的示例，其解决方案就是把组件创建代码移到 \x3ccode\x3engOnInit\x3c\/code\x3e 生命周期钩子里。尽管官方文档说 \x3ccode\x3eViewChild\x3c\/code\x3e 只有在 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 钩子后才有效，但是当创建视图时它就已经填入了子组件，所以在早期阶段就可用。（译者注：Angular 官网说的是 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/core\/ViewChild#description\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eView queries are set before the\x26nbsp;ngAfterViewInit\x26nbsp;callback is called\x3c\/code\x3e\x3c\/a\x3e\x3c\/strong\x3e，就已经说明了 \x3ccode\x3eViewChild\x3c\/code\x3e 是在 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 钩子前生效，不明白作者为啥要说之后才能生效。）\x3c\/p\x3e\n\x3cp\x3e如果你 google 下就知道解决这个错误一般有两种方式：异步更新属性和手动强迫变更检测。尽管我列出这两个解决方案，但不建议这么去做，我将会解释原因。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e异步更新\x3c\/h3\x3e\n\x3cp\x3e这里需要注意的事情是变更检测和核查循环（verification digests）都是同步的，这意味着如果我们在核查循环（verification loop）运行时去异步更新属性值，会导致错误，测试下吧：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class BComponent {\n    name = \x27I am B component\x27;\n    @Input() text;\n\n    constructor(private parent: AppComponent) {}\n\n    ngOnInit() {\n        setTimeout(() =\x3e {\n            this.parent.text = \x27updated text\x27;\n        });\n    }\n\n    ngAfterViewInit() {\n        setTimeout(() =\x3e {\n            this.parent.name = \x27updated name\x27;\n        });\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e BComponent {\n    name = \x3cspan class=\x22hljs-string\x22\x3e\x27I am B component\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-meta\x22\x3e@Input\x3c\/span\x3e() text;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e parent: AppComponent\x3c\/span\x3e) {}\n\n    ngOnInit() {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.text = \x3cspan class=\x22hljs-string\x22\x3e\x27updated text\x27\x3c\/span\x3e;\n        });\n    }\n\n    ngAfterViewInit() {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.name = \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e;\n        });\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实际上没有抛出错误（译者注：耍我呢！），这是因为 \x3ccode\x3esetTimeout()\x3c\/code\x3e 函数会让回调在下一个 VM turn 中作为宏观任务（macrotask）被执行。如果使用 \x3ccode\x3ePromise.then\x3c\/code\x3e 回调来包装，也可能在当前 VM turn 中执行完同步代码后，紧接着在当前 VM turn 继续执行回调：（译者注：VM turn 就是 Virtual Machine Turn，等于 \x3cstrong\x3e\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/38783544\/angular2-understanding-vm-turns-and-events\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebrowser task\x3c\/a\x3e\x3c\/strong\x3e，这涉及到 JS 引擎如何执行 JS 代码的知识，这又是一块大知识，不详述，有兴趣可以参考这篇经典文章 \x3cstrong\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/tasks-microtasks-queues-and-schedules\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTasks, microtasks, queues and schedules\x3c\/a\x3e\x3c\/strong\x3e ，或者这篇详细描述的文档 \x3cstrong\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5a6547d0f265da3e283a1df7\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理\x3c\/a\x3e\x3c\/strong\x3e 。）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.resolve(null).then(() =\x3e this.parent.name = \x27updated name\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent.name = \x3cspan class=\x22hljs-string\x22\x3e\x27updated name\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e与宏观任务（macrotask）不同，\x3ccode\x3ePromise.then\x3c\/code\x3e 会把回调构造成微观任务（microtask），微观任务会在当前同步代码执行完后再紧接着被执行，所以在核查之后会紧接着更新属性值。想要更多学习 Angular 的宏观任务和围观任务，可以查看我写的 \x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angularindepth.com\/i-reverse-engineered-zones-zone-js-and-here-is-what-ive-found-1f48dc87659b\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x26nbsp;I reverse-engineered Zones (zone.js) and here is what I’ve found\x3c\/a\x3e\x3c\/strong\x3e 。\x3c\/p\x3e\n\x3cp\x3e如果你使用 \x3ccode\x3eEventEmitter\x3c\/code\x3e 你可以传入 \x3ccode\x3etrue\x3c\/code\x3e 参数实现异步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new EventEmitter(true);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EventEmitter(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e强迫式变更检测\x3c\/h3\x3e\n\x3cp\x3e另一种解决方案是在第一次变更检测和核查循环阶段之间，再一次迫使 Angular 执行父组件 \x3ccode\x3eA\x3c\/code\x3e 的变更检测（译者注：由于 Angular 先是变更检测，然后核查循环，所以这段意思是变更检测完后，再去变更检测）。最佳时期是在 \x3ccode\x3engAfterViewInit\x3c\/code\x3e 钩子里去触发父组件 \x3ccode\x3eA\x3c\/code\x3e 的变更检测，因为这个父组件的钩子函数会在所有子组件已经执行完它们自己的变更检测后被触发，而恰恰是子组件做它们自己的变更检测时可能会改变父组件属性值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class AppComponent {\n    name = \x27I am A component\x27;\n    text = \x27A message for the child component\x27;\n\n    constructor(private cd: ChangeDetectorRef) {\n    }\n\n    ngAfterViewInit() {\n        this.cd.detectChanges();\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22ts\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent {\n    name = \x3cspan class=\x22hljs-string\x22\x3e\x27I am A component\x27\x3c\/span\x3e;\n    text = \x3cspan class=\x22hljs-string\x22\x3e\x27A message for the child component\x27\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e cd: ChangeDetectorRef\x3c\/span\x3e) {\n    }\n\n    ngAfterViewInit() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cd.detectChanges();\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很好，没有报错，不过这个解决方案仍然有个问题。如果我们为父组件 \x3ccode\x3eA\x3c\/code\x3e 触发变更检测，Angular 仍然会触发它的所有子组件变更检测，这可能重新会导致父组件属性值发生改变。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e为何需要循环核查（verification loop）\x3c\/h2\x3e\n\x3cp\x3eAngular 实行的是\x3cstrong\x3e从上到下的单向数据流\x3c\/strong\x3e，当父组件改变值已经被同步后（译者注：即父组件模型和视图已经同步后），不允许子组件去更新父组件的属性，这样确保在第一次 digest loop 后，整个组件树是稳定的。如果属性值发生改变，那么依赖于这些属性的消费者（译者注：即子组件）就需要同步，这会导致组件树不稳定。在我们的示例中，子组件 \x3ccode\x3eB\x3c\/code\x3e 依赖于父组件的 \x3ccode\x3etext\x3c\/code\x3e 属性，每当 \x3ccode\x3etext\x3c\/code\x3e 属性改变时，除非它已经被传给 \x3ccode\x3eB\x3c\/code\x3e 组件，否则整个组件树是不稳定的。对于父组件 \x3ccode\x3eA\x3c\/code\x3e 中的 DOM 模板也同样道理，它是 \x3ccode\x3eA\x3c\/code\x3e 模型中属性的消费者，并在 UI 中渲染出这些数据，如果这些属性没有被及时同步，那么用户将会在页面上看到错误的数据信息。\x3c\/p\x3e\n\x3cp\x3e数据同步过程是在变更检测期间发生的，特别是列表 1 中的操作。所以如果当同步操作执行完毕后，在子组件中去更新父组件属性时，会发生什么呢？你将会得到不稳定的组件树，这样的状态是不可测的，大多数时候你将会给用户展现错误的信息，并且很难调试。\x3c\/p\x3e\n\x3cp\x3e那为何不等到组件树稳定了再去执行变更检测呢？答案很简答，因为它可能永远不会稳定。如果把子组件更新了父组件的属性，作为该属性改变时的响应，那将会无限循环下去。当然，正如我之前说的，不管是直接更新还是依赖的情况，这都不是重点，但是在现实世界中，更新还是依赖一般都是非直接的。\x3c\/p\x3e\n\x3cp\x3e有趣的是，AngularJS 并没有\x3cstrong\x3e单向数据流\x3c\/strong\x3e，所以它会试图想办法去让组件树稳定。但是它会经常导致那个著名的错误 \x3ccode\x3e10 $digest() iterations reached. Aborting!\x3c\/code\x3e，去谷歌这个错误，你会惊讶发现关于这个错误的问题有很多。\x3c\/p\x3e\n\x3cp\x3e最后一个问题你可能会问为什么只有在开发模式下会执行 digest cycle 呢？我猜可能因为相比于一个运行错误，不稳定的模型并不是个大问题，毕竟它可能在下一次循环检查数据同步后变得稳定。然而，最好能在开发阶段注意可能发生的错误，总比在生产环境去调试错误要好得多。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] 关于 <code>ExpressionChangedAfterItHasBeenCheckedError</code> 错误你所需要知道的事情</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013972657">https://segmentfault.com/a/1190000013972657</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/lnqfi2mn4l/" target="_blank">https://alili.tech/archive/lnqfi2mn4l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>