<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="jQuery源码解析Deferred异步对象"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>jQuery源码解析Deferred异步对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/lq5clwedoni/",
				"appid": "1613049289050283", 
				"title": "jQuery源码解析Deferred异步对象 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-28T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bs5vdp88f56/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qzpfeltbqm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&text=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&text=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&title=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&is_video=false&description=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&title=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&title=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&title=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flq5clwedoni%2f&title=jQuery%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90Deferred%e5%bc%82%e6%ad%a5%e5%af%b9%e8%b1%a1"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">jQuery源码解析Deferred异步对象</h1><div class="meta"><div class="postdate"><time datetime="2018-12-28" itemprop="datePublished">2018-12-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在工作中我们可能会把\x3ccode\x3ejQuery\x3c\/code\x3e选择做自己项目的基础库，因为其提供了简便的\x3ccode\x3eDOM\x3c\/code\x3e选择器以及封装了很多实用的方法，比如\x3ccode\x3e$.ajax()\x3c\/code\x3e，它使得我们不用操作\x3ccode\x3exhr\x3c\/code\x3e和\x3ccode\x3exdr\x3c\/code\x3e对象，直接书写我们的代码逻辑即可。更为丰富的是它在\x3ccode\x3eES6\x3c\/code\x3e没有原生支持的那段时间，提供了\x3ccode\x3eDeferred\x3c\/code\x3e对象，类似于\x3ccode\x3ePromise\x3c\/code\x3e对象，支持\x3ccode\x3edone\/fail\/progress\/always\x3c\/code\x3e方法和\x3ccode\x3ewhen\x3c\/code\x3e批处理方法，这可能在项目上帮助过你。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eES6\x3c\/code\x3e提供了\x3ccode\x3ePromise\x3c\/code\x3e对象，但由于它是内置\x3ccode\x3eC\x2b\x2b\x3c\/code\x3e实现的，所以你也没法看它的设计。不如我们通过\x3ccode\x3ejQuery\x3c\/code\x3e的源码来探究其设计思路，并比较一下两者的区别。本文采用\x3ccode\x3ejquey-3.1.2.js\x3c\/code\x3e版本，其中英文注释为原版，中文注释为我添加。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e\n\x3ccode\x3ejQuery\x3c\/code\x3e的\x3ccode\x3eajax\x3c\/code\x3e总体设计\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ejQuery\x3c\/code\x3e在内部设置了全局的\x3ccode\x3eajax\x3c\/code\x3e参数，在每一个\x3ccode\x3eajax\x3c\/code\x3e请求初始化时，用传递的参数与默认的全局参数进行混合，并构建一个\x3ccode\x3ejqXHR\x3c\/code\x3e对象（提供比原生\x3ccode\x3eXHR\x3c\/code\x3e更为丰富的方法，同时实现其原生方法），通过传递的参数，来判断其是否跨域、传递的参数类型等，设置好相关头部信息。同时其被初始化为一个内置\x3ccode\x3eDeferred\x3c\/code\x3e对象用于异步操作（后面讲到），添加\x3ccode\x3edone\/fail\x3c\/code\x3e方法作为回调。同时我们也封装了\x3ccode\x3e$.get\/$.post\x3c\/code\x3e方法来快捷调用\x3ccode\x3e$.ajax\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e上面提到的\x3ccode\x3eDeferred\x3c\/code\x3e对象，与ES6的\x3ccode\x3ePromise\x3c\/code\x3e对象类似，用于更为方便的异步操作，多种回调以及更好的书写方式。提供\x3ccode\x3eprogress\/fail\/done\x3c\/code\x3e方法，并分别用该对象的\x3ccode\x3enotify\/reject\/resolve\x3c\/code\x3e方法触发，可以使用\x3ccode\x3ethen\x3c\/code\x3e方法快速设置三个方法，使用\x3ccode\x3ealways\x3c\/code\x3e添加都会执行的回调，并且提供\x3ccode\x3ewhen\x3c\/code\x3e方法支持多个异步操作合并回调。可以追加不同的回调列表，其回调列表是使用内部\x3ccode\x3eCallbacks\x3c\/code\x3e对象，更方便的按照队列的方式来进行执行。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eCallbacks\x3c\/code\x3e回调队列对象，用于构建易于操作的回调函数集合，在操作完成后进行执行。支持四种初始化的方式\x3ccode\x3eonce\/unique\/memory\/stopOnFalse\x3c\/code\x3e，分别代表只执行依次、去重、缓存结果、链式调用支持终止。提供\x3ccode\x3efired\/locked\/disabled\x3c\/code\x3e状态值，代表是否执行过、上锁、禁用。提供\x3ccode\x3eadd\/remove\/empty\/fire\/lock\/disable\x3c\/code\x3e方法操作回调函数队列。\x3c\/p\x3e\n\x3cp\x3e主要涉及到的概念就是这三个，不再做延伸，三个对象的设计代码行数在1200行左右，断断续续看了我一周 \x3cem\x3e(´ཀ`」 ∠)\x3c\/em\x3e 。我们从这三个倒序开始入手剖析其设计。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\n\x3ccode\x3ejQuery.Callbacks\x3c\/code\x3e对象\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/api.jquery.com\/jQuery.Callbacks\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eCallbacks\x3c\/code\x3e对象\x3c\/a\x3e，用于管理回调函数的多用途列表。它提供了六个主要方法：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eadd\x3c\/code\x3e: 向列表中添加回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eremove\x3c\/code\x3e: 移除列表中的回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eempty\x3c\/code\x3e: 清空列表中的回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3efire\x3c\/code\x3e: 依次执行列表中的回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3elock\x3c\/code\x3e: 对列表上锁，禁止一切操作，清除数据，但保留缓存的环境变量（只在\x3ccode\x3ememory\x3c\/code\x3e参数时有用）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3edisable\x3c\/code\x3e: 禁用该回调列表，所有数据清空\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在初始化时，支持四个参数，用空格分割：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3eonce\x3c\/code\x3e: 该回调列表只执行依次\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ememory\x3c\/code\x3e: 缓存执行环境，在添加新回调时执行先执行一次\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eunique\x3c\/code\x3e: 去重，每一个函数均不同（指的是引用地址）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3estopOnFalse\x3c\/code\x3e: 在调用中，如果前一个函数返回\x3ccode\x3efalse\x3c\/code\x3e，中断列表的后续执行\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们来看下其实例使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let cl = $.Callbacks(\x27once memory unique stopOnFalse\x27);\nfn1 = function (data) {\n    console.log(data);\n};\nfn2 = function (data) {\n    console.log(\x27fn2 say:\x27, data);\n    return false;\n};\ncl.add(fn1);\ncl.fire(\x27Nicholas\x27);    \/\/ Nicholas\n\/\/ 由于我们使用memory参数，保存了执行环境，在添加新的函数时自动执行一次\ncl.add(fn2);    \/\/ fn2 say: Nicholas\n\/\/ 由于我们使用once参数，所以只能执行（fire）一次，此处无任何输出\ncl.fire(\x27Lee\x27);\n\n\/\/ 后面我们假设这里没有传入once参数，每次fire都可以执行\n\ncl.fire(\x27Lee\x27);    \/\/ Lee    fn2 say: Lee\n\/\/ 清空列表\ncl.empty();\ncl.add(fn2, fn1);\n\/\/ 由于我们设置了stopOnFalse，而fn2返回了false，则后添加的fn1不会执行\ncl.fire(\x27Nicholas\x27);    \/\/ fn2 say: Nicholas\n\/\/ 上锁cl，禁用其操作，清除数据，但是我们添加了memory参数，它依然会对后续添加的执行一次\ncl.lock();\n\/\/ 无响应\ncl.fire();\ncl.add(fn2);    \/\/ fn2 say: Nicholas\n\/\/ 禁用cl，禁止一切操作，清除数据\ncl.disable();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cl = $.Callbacks(\x3cspan class=\x22hljs-string\x22\x3e\x27once memory unique stopOnFalse\x27\x3c\/span\x3e);\nfn1 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n};\nfn2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27fn2 say:\x27\x3c\/span\x3e, data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n};\ncl.add(fn1);\ncl.fire(\x3cspan class=\x22hljs-string\x22\x3e\x27Nicholas\x27\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Nicholas\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于我们使用memory参数，保存了执行环境，在添加新的函数时自动执行一次\x3c\/span\x3e\ncl.add(fn2);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fn2 say: Nicholas\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于我们使用once参数，所以只能执行（fire）一次，此处无任何输出\x3c\/span\x3e\ncl.fire(\x3cspan class=\x22hljs-string\x22\x3e\x27Lee\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后面我们假设这里没有传入once参数，每次fire都可以执行\x3c\/span\x3e\n\ncl.fire(\x3cspan class=\x22hljs-string\x22\x3e\x27Lee\x27\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Lee    fn2 say: Lee\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 清空列表\x3c\/span\x3e\ncl.empty();\ncl.add(fn2, fn1);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于我们设置了stopOnFalse，而fn2返回了false，则后添加的fn1不会执行\x3c\/span\x3e\ncl.fire(\x3cspan class=\x22hljs-string\x22\x3e\x27Nicholas\x27\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fn2 say: Nicholas\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上锁cl，禁用其操作，清除数据，但是我们添加了memory参数，它依然会对后续添加的执行一次\x3c\/span\x3e\ncl.lock();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 无响应\x3c\/span\x3e\ncl.fire();\ncl.add(fn2);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fn2 say: Nicholas\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 禁用cl，禁止一切操作，清除数据\x3c\/span\x3e\ncl.disable();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了上面所说的主要功能，还提供\x3ccode\x3ehas\/locked\/disabled\/fireWith\/fired\x3c\/code\x3e等辅助函数。\x3c\/p\x3e\n\x3cp\x3e其所有源码实现及注释为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22jQuery.Callbacks = function( options ) {\n    options = typeof options === \x26quot;string\x26quot; ?\n        \/\/ 将字符串中空格分割的子串，转换为值全为true的对象属性\n        createOptions( options ) :\n        jQuery.extend( {}, options );\n\n    var \/\/ Flag to know if list is currently firing\n        firing,\n\n        \/\/ Last fire value for non-forgettable lists\n        memory,\n\n        \/\/ Flag to know if list was already fired\n        fired,\n\n        \/\/ Flag to prevent firing\n        locked,\n\n        \/\/ Actual callback list\n        list = [],\n\n        \/\/ Queue of execution data for repeatable lists\n        queue = [],\n\n        \/\/ Index of currently firing callback (modified by add\/remove as needed)\n        firingIndex = -1,\n\n        \/\/ Fire callbacks\n        fire = function() {\n\n            \/\/ Enforce single-firing\n            locked = locked || options.once;\n\n            \/\/ Execute callbacks for all pending executions,\n            \/\/ respecting firingIndex overrides and runtime changes\n            fired = firing = true;\n            \/\/ 为quene队列中不同的[context, args]执行list回调列表，执行过程中会判断stopOnFalse中间中断\n            for ( ; queue.length; firingIndex = -1 ) {\n                memory = queue.shift();\n                while ( \x2b\x2bfiringIndex \x3c list.length ) {\n\n                    \/\/ Run callback and check for early termination\n                    if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false \x26amp;\x26amp;\n                        options.stopOnFalse ) {\n\n                        \/\/ Jump to end and forget the data so .add doesn\x27t re-fire\n                        firingIndex = list.length;\n                        memory = false;\n                    }\n                }\n            }\n\n            \/\/ Forget the data if we\x27re done with it\n            if ( !options.memory ) {\n                memory = false;\n            }\n\n            firing = false;\n\n            \/\/ Clean up if we\x27re done firing for good\n            \/\/ 如果不再执行了，就将保存回调的list清空，对内存更好\n            if ( locked ) {\n\n                \/\/ Keep an empty list if we have data for future add calls\n                if ( memory ) {\n                    list = [];\n\n                \/\/ Otherwise, this object is spent\n                } else {\n                    list = \x26quot;\x26quot;;\n                }\n            }\n        },\n\n        \/\/ Actual Callbacks object\n        self = {\n\n            \/\/ Add a callback or a collection of callbacks to the list\n            add: function() {\n                if ( list ) {\n\n                    \/\/ If we have memory from a past run, we should fire after adding\n                    \/\/ 如果我们选择缓存执行环境，会在新添加回调时执行一次保存的环境\n                    if ( memory \x26amp;\x26amp; !firing ) {\n                        firingIndex = list.length - 1;\n                        queue.push( memory );\n                    }\n\n                    ( function add( args ) {\n                        jQuery.each( args, function( _, arg ) {\n                            \/\/ 如果是函数，则判断是否去重，如果为类数组，则递归执行该内部函数\n                            if ( jQuery.isFunction( arg ) ) {\n                                if ( !options.unique || !self.has( arg ) ) {\n                                    list.push( arg );\n                                }\n                            } else if ( arg \x26amp;\x26amp; arg.length \x26amp;\x26amp; jQuery.type( arg ) !== \x26quot;string\x26quot; ) {\n\n                                \/\/ Inspect recursively\n                                add( arg );\n                            }\n                        } );\n                    } )( arguments );\n\n                    if ( memory \x26amp;\x26amp; !firing ) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n\n            \/\/ Remove a callback from the list\n            \/\/ 移除所有的相同回调，并同步将firingIndex-1\n            remove: function() {\n                jQuery.each( arguments, function( _, arg ) {\n                    var index;\n                    while ( ( index = jQuery.inArray( arg, list, index ) ) \x3e -1 ) {\n                        list.splice( index, 1 );\n\n                        \/\/ Handle firing indexes\n                        if ( index \x3c= firingIndex ) {\n                            firingIndex--;\n                        }\n                    }\n                } );\n                return this;\n            },\n\n            \/\/ Check if a given callback is in the list.\n            \/\/ If no argument is given, return whether or not list has callbacks attached.\n            \/\/ 检查是否存在该函数，如果不传递参数，则返回是否有回调函数\n            has: function( fn ) {\n                return fn ?\n                    jQuery.inArray( fn, list ) \x3e -1 :\n                    list.length \x3e 0;\n            },\n\n            \/\/ Remove all callbacks from the list\n            empty: function() {\n                if ( list ) {\n                    list = [];\n                }\n                return this;\n            },\n\n            \/\/ Disable .fire and .add\n            \/\/ Abort any current\/pending executions\n            \/\/ Clear all callbacks and values\n            \/\/ 置locked为[],即!![] === true，同时将队列和列表都清空，即禁用了该回调集合\n            disable: function() {\n                locked = queue = [];\n                list = memory = \x26quot;\x26quot;;\n                return this;\n            },\n            disabled: function() {\n                return !list;\n            },\n\n            \/\/ Disable .fire\n            \/\/ Also disable .add unless we have memory (since it would have no effect)\n            \/\/ Abort any pending executions\n            \/\/ 不允许执行，但如果有缓存，则我们允许添加后在缓存的环境下执行新添加的回调\n            lock: function() {\n                locked = queue = [];\n                if ( !memory \x26amp;\x26amp; !firing ) {\n                    list = memory = \x26quot;\x26quot;;\n                }\n                return this;\n            },\n            locked: function() {\n                return !!locked;\n            },\n\n            \/\/ Call all callbacks with the given context and arguments\n            \/\/ 为fire附带了一个上下文来调用fire函数，\n            fireWith: function( context, args ) {\n                if ( !locked ) {\n                    args = args || [];\n                    args = [ context, args.slice ? args.slice() : args ];\n                    queue.push( args );\n                    if ( !firing ) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n\n            \/\/ Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith( this, arguments );\n                return this;\n            },\n\n            \/\/ To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n\n    return self;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3ejQuery.Callbacks = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e options \x3c\/span\x3e) \x3c\/span\x3e{\n    options = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e options === \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e ?\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将字符串中空格分割的子串，转换为值全为true的对象属性\x3c\/span\x3e\n        createOptions( options ) :\n        jQuery.extend( {}, options );\n\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flag to know if list is currently firing\x3c\/span\x3e\n        firing,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Last fire value for non-forgettable lists\x3c\/span\x3e\n        memory,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flag to know if list was already fired\x3c\/span\x3e\n        fired,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flag to prevent firing\x3c\/span\x3e\n        locked,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Actual callback list\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = [],\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Queue of execution data for repeatable lists\x3c\/span\x3e\n        queue = [],\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Index of currently firing callback (modified by add\/remove as needed)\x3c\/span\x3e\n        firingIndex = \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e,\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Fire callbacks\x3c\/span\x3e\n        fire = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Enforce single-firing\x3c\/span\x3e\n            locked = locked || options.once;\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Execute callbacks for all pending executions,\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ respecting firingIndex overrides and runtime changes\x3c\/span\x3e\n            fired = firing = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为quene队列中不同的[context, args]执行list回调列表，执行过程中会判断stopOnFalse中间中断\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( ; queue.length; firingIndex = \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e ) {\n                memory = queue.shift();\n                \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ( \x2b\x2bfiringIndex \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.length ) {\n\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Run callback and check for early termination\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e[ firingIndex ].apply( memory[ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ], memory[ \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ] ) === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x26amp;\x26amp;\n                        options.stopOnFalse ) {\n\n                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Jump to end and forget the data so .add doesn\x27t re-fire\x3c\/span\x3e\n                        firingIndex = \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.length;\n                        memory = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n                    }\n                }\n            }\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Forget the data if we\x27re done with it\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !options.memory ) {\n                memory = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n            }\n\n            firing = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Clean up if we\x27re done firing for good\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不再执行了，就将保存回调的list清空，对内存更好\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( locked ) {\n\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Keep an empty list if we have data for future add calls\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( memory ) {\n                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = [];\n\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Otherwise, this object is spent\x3c\/span\x3e\n                } \x3cspan class=\x22hljs-title\x22\x3eelse\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e;\n                }\n            }\n        },\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Actual Callbacks object\x3c\/span\x3e\n        self = {\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Add a callback or a collection of callbacks to the list\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3eadd\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e ) {\n\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If we have memory from a past run, we should fire after adding\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果我们选择缓存执行环境，会在新添加回调时执行一次保存的环境\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( memory \x26amp;\x26amp; !firing ) {\n                        firingIndex = \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n                        queue.push( memory );\n                    }\n\n                    ( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e args \x3c\/span\x3e) \x3c\/span\x3e{\n                        jQuery.each( args, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e _, arg \x3c\/span\x3e) \x3c\/span\x3e{\n                            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是函数，则判断是否去重，如果为类数组，则递归执行该内部函数\x3c\/span\x3e\n                            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( jQuery.isFunction( arg ) ) {\n                                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !options.unique || !self.has( arg ) ) {\n                                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.push( arg );\n                                }\n                            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( arg \x26amp;\x26amp; arg.length \x26amp;\x26amp; jQuery.type( arg ) !== \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e ) {\n\n                                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Inspect recursively\x3c\/span\x3e\n                                add( arg );\n                            }\n                        } );\n                    } )( \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e );\n\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( memory \x26amp;\x26amp; !firing ) {\n                        fire();\n                    }\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Remove a callback from the list\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除所有的相同回调，并同步将firingIndex-1\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3eremove\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                jQuery.each( \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e _, arg \x3c\/span\x3e) \x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e index;\n                    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ( ( index = jQuery.inArray( arg, \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e, index ) ) \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e ) {\n                        \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.splice( index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e );\n\n                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Handle firing indexes\x3c\/span\x3e\n                        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( index \x26lt;= firingIndex ) {\n                            firingIndex--;\n                        }\n                    }\n                } );\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Check if a given callback is in the list.\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If no argument is given, return whether or not list has callbacks attached.\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查是否存在该函数，如果不传递参数，则返回是否有回调函数\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3ehas\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e fn \x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn ?\n                    jQuery.inArray( fn, \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e ) \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e :\n                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Remove all callbacks from the list\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3eempty\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e ) {\n                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = [];\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Disable .fire and .add\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Abort any current\/pending executions\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Clear all callbacks and values\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 置locked为[],即!![] === true，同时将队列和列表都清空，即禁用了该回调集合\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3edisable\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                locked = queue = [];\n                \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = memory = \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n            \x3cspan class=\x22hljs-attribute\x22\x3edisabled\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !\x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Disable .fire\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Also disable .add unless we have memory (since it would have no effect)\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Abort any pending executions\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不允许执行，但如果有缓存，则我们允许添加后在缓存的环境下执行新添加的回调\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3elock\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                locked = queue = [];\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !memory \x26amp;\x26amp; !firing ) {\n                    \x3cspan class=\x22hljs-built_in\x22\x3elist\x3c\/span\x3e = memory = \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e;\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n            \x3cspan class=\x22hljs-attribute\x22\x3elocked\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!locked;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Call all callbacks with the given context and arguments\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为fire附带了一个上下文来调用fire函数，\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3efireWith\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e context, args \x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !locked ) {\n                    args = args || [];\n                    args = [ context, args.slice ? args.slice() : args ];\n                    queue.push( args );\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !firing ) {\n                        fire();\n                    }\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Call all the callbacks with the given arguments\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3efire\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                self.fireWith( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e );\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n            },\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ To know if the callbacks have already been called at least once\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3efired\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!fired;\n            }\n        };\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e self;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\n\x3ccode\x3ejQuery.Deferred\x3c\/code\x3e对象\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ejQuery.Deferred\x3c\/code\x3e\x3ca href=\x22http:\/\/api.jquery.com\/jQuery.Deferred\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对象\x3c\/a\x3e是一个工厂函数，返回一个用于异步或同步调用的\x3ccode\x3edeferred\x3c\/code\x3e对象，支持链式调用、回调函数队列，并且能针对返回的状态不同执行不同的回调。它类似于\x3ccode\x3eES6\x3c\/code\x3e提供的\x3ccode\x3ePromise\x3c\/code\x3e对象，提供9个主要的方法：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3edone\x3c\/code\x3e: 操作成功响应时的回调函数（同步或异步，以下相同）\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3efail\x3c\/code\x3e: 操作失败响应时的回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eprogress\x3c\/code\x3e: 操作处理过程中的回调函数\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eresolve\x3c\/code\x3e: 通过该方法解析该操作为成功状态，调用done\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ereject\x3c\/code\x3e: 通过该方法解析该操作为失败状态，调用fail\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3enotify\x3c\/code\x3e: 通过该方法解析该操作为执行过程中，调用progress\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethen\x3c\/code\x3e: 设置回调的简写，接收三个参数，分别是done\/fail\/progress\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ealways\x3c\/code\x3e: 设置必须执行的回调，无论是done还是fail\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epromise\x3c\/code\x3e: 返回一个受限制的Deferred对象，不允许外部直接改变完成状态\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e它的实现思想是创建一个对象，包含不同状态下回调函数的队列，并在状态为失败或成功后不允许再次改变。通过返回的\x3ccode\x3eDeferred\x3c\/code\x3e对象进行手动调用\x3ccode\x3eresolve\/reject\/notify\x3c\/code\x3e方法来控制流程。\x3c\/p\x3e\n\x3cp\x3e看一个实例（纯属胡扯，不要当真）。我们需要从间谍卫星返回的数据用不同的算法来进行解析，如果解析结果信号强度大于90%，则证明该数据有效，可以被解析；如果强度小于10%，则证明只是宇宙噪音；否则，证明数据可能有效，换一种算法解析：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 我们封装Deferred产生一个promise对象，其不能被外部手动解析，只能内部确定最终状态\nasynPromise = function () {\n    let d = $.Deferred();\n    (function timer() {\n        setTimeout(function () {\n            \/\/ 产生随机数，代替解析结果，来确定本次的状态\n            let num = Math.random();\n            if (num \x3e 0.9) {\n                d.resolve();    \/\/ 解析成功\n            } else if (num \x3c 0.1) {\n                d.reject();    \/\/ 解析失败\n            } else {\n                d.notify();    \/\/ 解析过程中\n            }\n            setTimeout(timer, 1000);    \/\/ 持续不断的解析数据\n        }, 1000);\n    })();\n    \/\/ 如果不返回promise对象，则可以被外部手动调整解析状态\n    return d.promise();\n};\n\n\/\/ then方法的三个参数分别代表完成、失败、过程中的回调函数\nasynPromise().then(function () {\n    console.log(\x27resolve success\x27);\n}, function () {\n    console.log(\x27reject fail\x27);\n}, function () {\n    console.log(\x27notify progress\x27);\n});\n\n\/\/ 本地执行结果（每个人的不一样，随机分布，但最后一个一定是success或fail）\nnotify progress\nnotify progress\nnotify progress\nnotify progress\nnotify progress\nreject fail    \/\/ 后面不会再有输出，因为一旦解析状态为success或fail，则不会再改变\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们封装Deferred产生一个promise对象，其不能被外部手动解析，只能内部确定最终状态\x3c\/span\x3e\nasynPromise = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e d = $.Deferred();\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 产生随机数，代替解析结果，来确定本次的状态\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e num = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random();\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (num \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0.9\x3c\/span\x3e) {\n                d.resolve();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析成功\x3c\/span\x3e\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (num \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0.1\x3c\/span\x3e) {\n                d.reject();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析失败\x3c\/span\x3e\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                d.notify();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析过程中\x3c\/span\x3e\n            }\n            setTimeout(timer, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 持续不断的解析数据\x3c\/span\x3e\n        }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    })();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不返回promise对象，则可以被外部手动调整解析状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e d.promise();\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ then方法的三个参数分别代表完成、失败、过程中的回调函数\x3c\/span\x3e\nasynPromise().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27resolve success\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27reject fail\x27\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27notify progress\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 本地执行结果（每个人的不一样，随机分布，但最后一个一定是success或fail）\x3c\/span\x3e\nnotify progress\nnotify progress\nnotify progress\nnotify progress\nnotify progress\nreject fail    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后面不会再有输出，因为一旦解析状态为success或fail，则不会再改变\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了上面的主要功能，还提供了\x3ccode\x3enotifyWith\/resolveWith\/rejectWith\/state\x3c\/code\x3e辅助方法。\x3c\/p\x3e\n\x3cp\x3e其所有的源码实现和注释为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Deferred: function( func ) {\n        var tuples = [\n                \/\/ action, add listener, callbacks,\n                \/\/ ... .then handlers, argument index, [final state]\n                \/\/ 用于后面进行第一个参数绑定调用第二个参数，第三个和第四个参数分别是其不同的回调函数队列\n                [ \x26quot;notify\x26quot;, \x26quot;progress\x26quot;, jQuery.Callbacks( \x26quot;memory\x26quot; ),\n                    jQuery.Callbacks( \x26quot;memory\x26quot; ), 2 ],\n                [ \x26quot;resolve\x26quot;, \x26quot;done\x26quot;, jQuery.Callbacks( \x26quot;once memory\x26quot; ),\n                    jQuery.Callbacks( \x26quot;once memory\x26quot; ), 0, \x26quot;resolved\x26quot; ],\n                [ \x26quot;reject\x26quot;, \x26quot;fail\x26quot;, jQuery.Callbacks( \x26quot;once memory\x26quot; ),\n                    jQuery.Callbacks( \x26quot;once memory\x26quot; ), 1, \x26quot;rejected\x26quot; ]\n            ],\n            state = \x26quot;pending\x26quot;,\n            promise = {\n                state: function() {\n                    return state;\n                },\n                \/\/ 同时添加done和fail句柄\n                always: function() {\n                    deferred.done( arguments ).fail( arguments );\n                    return this;\n                },\n                \x26quot;catch\x26quot;: function( fn ) {\n                    return promise.then( null, fn );\n                },\n                then: function( onFulfilled, onRejected, onProgress ) {\n                    var maxDepth = 0;\n                    function resolve( depth, deferred, handler, special ) {\n                        return function() {\n                            var that = this,\n                                args = arguments,\n                                mightThrow = function() {\n                                    var returned, then;\n\n                                    \/\/ Support: Promises\/A\x2b section 2.3.3.3.3\n                                    \/\/ https:\/\/promisesaplus.com\/#point-59\n                                    \/\/ Ignore double-resolution attempts\n                                    if ( depth \x3c maxDepth ) {\n                                        return;\n                                    }\n\n                                    returned = handler.apply( that, args );\n\n                                    \/\/ Support: Promises\/A\x2b section 2.3.1\n                                    \/\/ https:\/\/promisesaplus.com\/#point-48\n                                    if ( returned === deferred.promise() ) {\n                                        throw new TypeError( \x26quot;Thenable self-resolution\x26quot; );\n                                    }\n\n                                    \/\/ Support: Promises\/A\x2b sections 2.3.3.1, 3.5\n                                    \/\/ https:\/\/promisesaplus.com\/#point-54\n                                    \/\/ https:\/\/promisesaplus.com\/#point-75\n                                    \/\/ Retrieve `then` only once\n                                    then = returned \x26amp;\x26amp;\n\n                                        \/\/ Support: Promises\/A\x2b section 2.3.4\n                                        \/\/ https:\/\/promisesaplus.com\/#point-64\n                                        \/\/ Only check objects and functions for thenability\n                                        ( typeof returned === \x26quot;object\x26quot; ||\n                                            typeof returned === \x26quot;function\x26quot; ) \x26amp;\x26amp;\n                                        returned.then;\n\n                                    \/\/ Handle a returned thenable\n                                    if ( jQuery.isFunction( then ) ) {\n\n                                        \/\/ Special processors (notify) just wait for resolution\n                                        if ( special ) {\n                                            then.call(\n                                                returned,\n                                                resolve( maxDepth, deferred, Identity, special ),\n                                                resolve( maxDepth, deferred, Thrower, special )\n                                            );\n\n                                        \/\/ Normal processors (resolve) also hook into progress\n                                        } else {\n\n                                            \/\/ ...and disregard older resolution values\n                                            maxDepth\x2b\x2b;\n\n                                            then.call(\n                                                returned,\n                                                resolve( maxDepth, deferred, Identity, special ),\n                                                resolve( maxDepth, deferred, Thrower, special ),\n                                                resolve( maxDepth, deferred, Identity,\n                                                    deferred.notifyWith )\n                                            );\n                                        }\n\n                                    \/\/ Handle all other returned values\n                                    } else {\n\n                                        \/\/ Only substitute handlers pass on context\n                                        \/\/ and multiple values (non-spec behavior)\n                                        if ( handler !== Identity ) {\n                                            that = undefined;\n                                            args = [ returned ];\n                                        }\n\n                                        \/\/ Process the value(s)\n                                        \/\/ Default process is resolve\n                                        ( special || deferred.resolveWith )( that, args );\n                                    }\n                                },\n\n                                \/\/ Only normal processors (resolve) catch and reject exceptions\n                                \/\/ 只有普通的process能处理异常，其余的要进行捕获，这里不是特别明白，应该是因为没有改最终的状态吧\n                                process = special ?\n                                    mightThrow :\n                                    function() {\n                                        try {\n                                            mightThrow();\n                                        } catch ( e ) {\n\n                                            if ( jQuery.Deferred.exceptionHook ) {\n                                                jQuery.Deferred.exceptionHook( e,\n                                                    process.stackTrace );\n                                            }\n\n                                            \/\/ Support: Promises\/A\x2b section 2.3.3.3.4.1\n                                            \/\/ https:\/\/promisesaplus.com\/#point-61\n                                            \/\/ Ignore post-resolution exceptions\n                                            if ( depth \x2b 1 \x3e= maxDepth ) {\n\n                                                \/\/ Only substitute handlers pass on context\n                                                \/\/ and multiple values (non-spec behavior)\n                                                if ( handler !== Thrower ) {\n                                                    that = undefined;\n                                                    args = [ e ];\n                                                }\n\n                                                deferred.rejectWith( that, args );\n                                            }\n                                        }\n                                    };\n\n                            \/\/ Support: Promises\/A\x2b section 2.3.3.3.1\n                            \/\/ https:\/\/promisesaplus.com\/#point-57\n                            \/\/ Re-resolve promises immediately to dodge false rejection from\n                            \/\/ subsequent errors\n                            if ( depth ) {\n                                process();\n                            } else {\n\n                                \/\/ Call an optional hook to record the stack, in case of exception\n                                \/\/ since it\x27s otherwise lost when execution goes async\n                                if ( jQuery.Deferred.getStackHook ) {\n                                    process.stackTrace = jQuery.Deferred.getStackHook();\n                                }\n                                window.setTimeout( process );\n                            }\n                        };\n                    }\n\n                    return jQuery.Deferred( function( newDefer ) {\n\n                        \/\/ progress_handlers.add( ... )\n                        tuples[ 0 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onProgress ) ?\n                                    onProgress :\n                                    Identity,\n                                newDefer.notifyWith\n                            )\n                        );\n\n                        \/\/ fulfilled_handlers.add( ... )\n                        tuples[ 1 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onFulfilled ) ?\n                                    onFulfilled :\n                                    Identity\n                            )\n                        );\n\n                        \/\/ rejected_handlers.add( ... )\n                        tuples[ 2 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onRejected ) ?\n                                    onRejected :\n                                    Thrower\n                            )\n                        );\n                    } ).promise();\n                },\n\n                \/\/ Get a promise for this deferred\n                \/\/ If obj is provided, the promise aspect is added to the object\n                \/\/ 通过该promise对象返回一个新的扩展promise对象或自身\n                promise: function( obj ) {\n                    return obj != null ? jQuery.extend( obj, promise ) : promise;\n                }\n            },\n            deferred = {};\n\n        \/\/ Add list-specific methods\n        \/\/ 给promise添加done\/fail\/progress事件，并添加互相的影响关系，并为deferred对象添加3个事件函数notify\/resolve\/reject\n        jQuery.each( tuples, function( i, tuple ) {\n            var list = tuple[ 2 ],\n                stateString = tuple[ 5 ];\n\n            \/\/ promise.progress = list.add\n            \/\/ promise.done = list.add\n            \/\/ promise.fail = list.add\n            promise[ tuple[ 1 ] ] = list.add;\n\n            \/\/ Handle state\n            \/\/ 只有done和fail有resolved和rejected状态字段，给两个事件添加回调，禁止再次done或者fail，锁住progress不允许执行回调\n            if ( stateString ) {\n                list.add(\n                    function() {\n\n                        \/\/ state = \x26quot;resolved\x26quot; (i.e., fulfilled)\n                        \/\/ state = \x26quot;rejected\x26quot;\n                        state = stateString;\n                    },\n\n                    \/\/ rejected_callbacks.disable\n                    \/\/ fulfilled_callbacks.disable\n                    tuples[ 3 - i ][ 2 ].disable,\n\n                    \/\/ progress_callbacks.lock\n                    tuples[ 0 ][ 2 ].lock\n                );\n            }\n\n            \/\/ progress_handlers.fire\n            \/\/ fulfilled_handlers.fire\n            \/\/ rejected_handlers.fire\n            \/\/ 执行第二个回调列表\n            list.add( tuple[ 3 ].fire );\n\n            \/\/ deferred.notify = function() { deferred.notifyWith(...) }\n            \/\/ deferred.resolve = function() { deferred.resolveWith(...) }\n            \/\/ deferred.reject = function() { deferred.rejectWith(...) }\n            \/\/ 绑定notify\/resolve\/reject的事件，实际执行的函数体为加入上下文的With函数\n            deferred[ tuple[ 0 ] ] = function() {\n                deferred[ tuple[ 0 ] \x2b \x26quot;With\x26quot; ]( this === deferred ? undefined : this, arguments );\n                return this;\n            };\n\n            \/\/ deferred.notifyWith = list.fireWith\n            \/\/ deferred.resolveWith = list.fireWith\n            \/\/ deferred.rejectWith = list.fireWith\n            deferred[ tuple[ 0 ] \x2b \x26quot;With\x26quot; ] = list.fireWith;\n        } );\n\n        \/\/ Make the deferred a promise\n        \/\/ 将deferred扩展为一个promise对象\n        promise.promise( deferred );\n\n        \/\/ Call given func if any\n        \/\/ 在创建前执行传入的回调函数进行修改\n        if ( func ) {\n            func.call( deferred, deferred );\n        }\n\n        \/\/ All done!\n        return deferred;\n    },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode\x3eDeferred: function( func ) {\n        var tuples = [\n                \/\/ action, add listener, callbacks,\n                \/\/ ... .then handlers, argument index, [final state]\n                \/\/ 用于后面进行第一个参数绑定调用第二个参数，第三个和第四个参数分别是其不同的回调函数队列\n                [ \x22notify\x22, \x22progress\x22, jQuery.Callbacks( \x22memory\x22 ),\n                    jQuery.Callbacks( \x22memory\x22 ), 2 ],\n                [ \x22resolve\x22, \x22done\x22, jQuery.Callbacks( \x22once memory\x22 ),\n                    jQuery.Callbacks( \x22once memory\x22 ), 0, \x22resolved\x22 ],\n                [ \x22reject\x22, \x22fail\x22, jQuery.Callbacks( \x22once memory\x22 ),\n                    jQuery.Callbacks( \x22once memory\x22 ), 1, \x22rejected\x22 ]\n            ],\n            state = \x22pending\x22,\n            promise = {\n                state: function() {\n                    return state;\n                },\n                \/\/ 同时添加done和fail句柄\n                always: function() {\n                    deferred.done( arguments ).fail( arguments );\n                    return this;\n                },\n                \x22catch\x22: function( fn ) {\n                    return promise.then( null, fn );\n                },\n                then: function( onFulfilled, onRejected, onProgress ) {\n                    var maxDepth = 0;\n                    function resolve( depth, deferred, handler, special ) {\n                        return function() {\n                            var that = this,\n                                args = arguments,\n                                mightThrow = function() {\n                                    var returned, then;\n\n                                    \/\/ Support: Promises\/A\x2b section 2.3.3.3.3\n                                    \/\/ https:\/\/promisesaplus.com\/#point-59\n                                    \/\/ Ignore double-resolution attempts\n                                    if ( depth \x26lt; maxDepth ) {\n                                        return;\n                                    }\n\n                                    returned = handler.apply( that, args );\n\n                                    \/\/ Support: Promises\/A\x2b section 2.3.1\n                                    \/\/ https:\/\/promisesaplus.com\/#point-48\n                                    if ( returned === deferred.promise() ) {\n                                        throw new TypeError( \x22Thenable self-resolution\x22 );\n                                    }\n\n                                    \/\/ Support: Promises\/A\x2b sections 2.3.3.1, 3.5\n                                    \/\/ https:\/\/promisesaplus.com\/#point-54\n                                    \/\/ https:\/\/promisesaplus.com\/#point-75\n                                    \/\/ Retrieve `then` only once\n                                    then = returned \x26amp;\x26amp;\n\n                                        \/\/ Support: Promises\/A\x2b section 2.3.4\n                                        \/\/ https:\/\/promisesaplus.com\/#point-64\n                                        \/\/ Only check objects and functions for thenability\n                                        ( typeof returned === \x22object\x22 ||\n                                            typeof returned === \x22function\x22 ) \x26amp;\x26amp;\n                                        returned.then;\n\n                                    \/\/ Handle a returned thenable\n                                    if ( jQuery.isFunction( then ) ) {\n\n                                        \/\/ Special processors (notify) just wait for resolution\n                                        if ( special ) {\n                                            then.call(\n                                                returned,\n                                                resolve( maxDepth, deferred, Identity, special ),\n                                                resolve( maxDepth, deferred, Thrower, special )\n                                            );\n\n                                        \/\/ Normal processors (resolve) also hook into progress\n                                        } else {\n\n                                            \/\/ ...and disregard older resolution values\n                                            maxDepth\x2b\x2b;\n\n                                            then.call(\n                                                returned,\n                                                resolve( maxDepth, deferred, Identity, special ),\n                                                resolve( maxDepth, deferred, Thrower, special ),\n                                                resolve( maxDepth, deferred, Identity,\n                                                    deferred.notifyWith )\n                                            );\n                                        }\n\n                                    \/\/ Handle all other returned values\n                                    } else {\n\n                                        \/\/ Only substitute handlers pass on context\n                                        \/\/ and multiple values (non-spec behavior)\n                                        if ( handler !== Identity ) {\n                                            that = undefined;\n                                            args = [ returned ];\n                                        }\n\n                                        \/\/ Process the value(s)\n                                        \/\/ Default process is resolve\n                                        ( special || deferred.resolveWith )( that, args );\n                                    }\n                                },\n\n                                \/\/ Only normal processors (resolve) catch and reject exceptions\n                                \/\/ 只有普通的process能处理异常，其余的要进行捕获，这里不是特别明白，应该是因为没有改最终的状态吧\n                                process = special ?\n                                    mightThrow :\n                                    function() {\n                                        try {\n                                            mightThrow();\n                                        } catch ( e ) {\n\n                                            if ( jQuery.Deferred.exceptionHook ) {\n                                                jQuery.Deferred.exceptionHook( e,\n                                                    process.stackTrace );\n                                            }\n\n                                            \/\/ Support: Promises\/A\x2b section 2.3.3.3.4.1\n                                            \/\/ https:\/\/promisesaplus.com\/#point-61\n                                            \/\/ Ignore post-resolution exceptions\n                                            if ( depth \x2b 1 \x26gt;= maxDepth ) {\n\n                                                \/\/ Only substitute handlers pass on context\n                                                \/\/ and multiple values (non-spec behavior)\n                                                if ( handler !== Thrower ) {\n                                                    that = undefined;\n                                                    args = [ e ];\n                                                }\n\n                                                deferred.rejectWith( that, args );\n                                            }\n                                        }\n                                    };\n\n                            \/\/ Support: Promises\/A\x2b section 2.3.3.3.1\n                            \/\/ https:\/\/promisesaplus.com\/#point-57\n                            \/\/ Re-resolve promises immediately to dodge false rejection from\n                            \/\/ subsequent errors\n                            if ( depth ) {\n                                process();\n                            } else {\n\n                                \/\/ Call an optional hook to record the stack, in case of exception\n                                \/\/ since it\x27s otherwise lost when execution goes async\n                                if ( jQuery.Deferred.getStackHook ) {\n                                    process.stackTrace = jQuery.Deferred.getStackHook();\n                                }\n                                window.setTimeout( process );\n                            }\n                        };\n                    }\n\n                    return jQuery.Deferred( function( newDefer ) {\n\n                        \/\/ progress_handlers.add( ... )\n                        tuples[ 0 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onProgress ) ?\n                                    onProgress :\n                                    Identity,\n                                newDefer.notifyWith\n                            )\n                        );\n\n                        \/\/ fulfilled_handlers.add( ... )\n                        tuples[ 1 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onFulfilled ) ?\n                                    onFulfilled :\n                                    Identity\n                            )\n                        );\n\n                        \/\/ rejected_handlers.add( ... )\n                        tuples[ 2 ][ 3 ].add(\n                            resolve(\n                                0,\n                                newDefer,\n                                jQuery.isFunction( onRejected ) ?\n                                    onRejected :\n                                    Thrower\n                            )\n                        );\n                    } ).promise();\n                },\n\n                \/\/ Get a promise for this deferred\n                \/\/ If obj is provided, the promise aspect is added to the object\n                \/\/ 通过该promise对象返回一个新的扩展promise对象或自身\n                promise: function( obj ) {\n                    return obj != null ? jQuery.extend( obj, promise ) : promise;\n                }\n            },\n            deferred = {};\n\n        \/\/ Add list-specific methods\n        \/\/ 给promise添加done\/fail\/progress事件，并添加互相的影响关系，并为deferred对象添加3个事件函数notify\/resolve\/reject\n        jQuery.each( tuples, function( i, tuple ) {\n            var list = tuple[ 2 ],\n                stateString = tuple[ 5 ];\n\n            \/\/ promise.progress = list.add\n            \/\/ promise.done = list.add\n            \/\/ promise.fail = list.add\n            promise[ tuple[ 1 ] ] = list.add;\n\n            \/\/ Handle state\n            \/\/ 只有done和fail有resolved和rejected状态字段，给两个事件添加回调，禁止再次done或者fail，锁住progress不允许执行回调\n            if ( stateString ) {\n                list.add(\n                    function() {\n\n                        \/\/ state = \x22resolved\x22 (i.e., fulfilled)\n                        \/\/ state = \x22rejected\x22\n                        state = stateString;\n                    },\n\n                    \/\/ rejected_callbacks.disable\n                    \/\/ fulfilled_callbacks.disable\n                    tuples[ 3 - i ][ 2 ].disable,\n\n                    \/\/ progress_callbacks.lock\n                    tuples[ 0 ][ 2 ].lock\n                );\n            }\n\n            \/\/ progress_handlers.fire\n            \/\/ fulfilled_handlers.fire\n            \/\/ rejected_handlers.fire\n            \/\/ 执行第二个回调列表\n            list.add( tuple[ 3 ].fire );\n\n            \/\/ deferred.notify = function() { deferred.notifyWith(...) }\n            \/\/ deferred.resolve = function() { deferred.resolveWith(...) }\n            \/\/ deferred.reject = function() { deferred.rejectWith(...) }\n            \/\/ 绑定notify\/resolve\/reject的事件，实际执行的函数体为加入上下文的With函数\n            deferred[ tuple[ 0 ] ] = function() {\n                deferred[ tuple[ 0 ] \x2b \x22With\x22 ]( this === deferred ? undefined : this, arguments );\n                return this;\n            };\n\n            \/\/ deferred.notifyWith = list.fireWith\n            \/\/ deferred.resolveWith = list.fireWith\n            \/\/ deferred.rejectWith = list.fireWith\n            deferred[ tuple[ 0 ] \x2b \x22With\x22 ] = list.fireWith;\n        } );\n\n        \/\/ Make the deferred a promise\n        \/\/ 将deferred扩展为一个promise对象\n        promise.promise( deferred );\n\n        \/\/ Call given func if any\n        \/\/ 在创建前执行传入的回调函数进行修改\n        if ( func ) {\n            func.call( deferred, deferred );\n        }\n\n        \/\/ All done!\n        return deferred;\n    },\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e\n\x3ccode\x3ejQuery.when\x3c\/code\x3e方法\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3e$.when()\x3c\/code\x3e提供一种\x3ca href=\x22http:\/\/www.jquery123.com\/jQuery.when\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e方法\x3c\/a\x3e执行一个或多个函数的回调函数。如果传入一个延迟对象，则返回该对象的Promise对象，可以继续绑定其余回调，在执行结束状态之后也同时调用其\x3ccode\x3ewhen\x3c\/code\x3e回调函数。如果传入多个延迟对象，则返回一个新的\x3ccode\x3emaster\x3c\/code\x3e延迟对象，跟踪所有的聚集状态，如果都成功解析完成，才调用其\x3ccode\x3ewhen\x3c\/code\x3e回调函数；如果有一个失败，则全部失败，执行错误回调。\x3c\/p\x3e\n\x3cp\x3e其使用方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.when($.ajax(\x26quot;\/page1.php\x26quot;), $.ajax(\x26quot;\/page2.php\x26quot;))\n  .then(myFunc, myFailure);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-variable\x22\x3e$.\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3ewhen\x3c\/span\x3e(\x3cspan class=\x22hljs-variable\x22\x3e$.\x3c\/span\x3eajax(\x3cspan class=\x22hljs-string\x22\x3e\x22\/page1.php\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-variable\x22\x3e$.\x3c\/span\x3eajax(\x3cspan class=\x22hljs-string\x22\x3e\x22\/page2.php\x22\x3c\/span\x3e))\n  .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(myFunc, myFailure);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其所有源码实现和注释为（能力有限，有些地方实在不能准确理解执行流程）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 给when传递的对象绑定master.resolve和master.reject，用于聚集多异步对象的状态\nfunction adoptValue( value, resolve, reject, noValue ) {\n    var method;\n    try {\n        \/\/ Check for promise aspect first to privilege synchronous behavior\n        \/\/ 如果when传入的参数promise方法可用，则封装promise并添加done和fail方法调用resolve和reject\n        if ( value \x26amp;\x26amp; jQuery.isFunction( ( method = value.promise ) ) ) {\n            method.call( value ).done( resolve ).fail( reject );\n\n        \/\/ Other thenables\n        \/\/ 否则，就判断传入参数的then方法是否可用，如果可用就传入resolve和reject方法\n        } else if ( value \x26amp;\x26amp; jQuery.isFunction( ( method = value.then ) ) ) {\n            method.call( value, resolve, reject );\n\n        \/\/ Other non-thenables\n        \/\/ 如果均不可用，则为非异步对象，直接resolve解析原值\n        } else {\n\n            \/\/ Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n            \/\/ * false: [ value ].slice( 0 ) =\x3e resolve( value )\n            \/\/ * true: [ value ].slice( 1 ) =\x3e resolve()\n            resolve.apply( undefined, [ value ].slice( noValue ) );\n        }\n\n    \/\/ For Promises\/A\x2b, convert exceptions into rejections\n    \/\/ Since jQuery.when doesn\x27t unwrap thenables, we can skip the extra checks appearing in\n    \/\/ Deferred#then to conditionally suppress rejection.\n    } catch ( value ) {\n\n        \/\/ Support: Android 4.0 only\n        \/\/ Strict mode functions invoked without .call\/.apply get global-object context\n        \/\/ 一个安卓4.0的bug，这里不做阐释\n        reject.apply( undefined, [ value ] );\n    }\n}\n\n\/\/ Deferred helper\n    when: function( singleValue ) {\n        var\n            \/\/ count of uncompleted subordinates\n            remaining = arguments.length,\n\n            \/\/ count of unprocessed arguments\n            i = remaining,\n\n            \/\/ subordinate fulfillment data\n            resolveContexts = Array( i ),\n            resolveValues = slice.call( arguments ),\n\n            \/\/ the master Deferred\n            master = jQuery.Deferred(),\n\n            \/\/ subordinate callback factory\n            \/\/ 将每一个响应的环境和值都保存到列表里，在全部完成后统一传给主Promise用于执行\n            updateFunc = function( i ) {\n                return function( value ) {\n                    resolveContexts[ i ] = this;\n                    resolveValues[ i ] = arguments.length \x3e 1 ? slice.call( arguments ) : value;\n                    if ( !( --remaining ) ) {\n                        master.resolveWith( resolveContexts, resolveValues );\n                    }\n                };\n            };\n\n        \/\/ Single- and empty arguments are adopted like Promise.resolve\n        \/\/ 如果只有一个参数，则直接将其作为master的回调\n        if ( remaining \x3c= 1 ) {\n            adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n                !remaining );\n\n            \/\/ Use .then() to unwrap secondary thenables (cf. gh-3000)\n            if ( master.state() === \x26quot;pending\x26quot; ||\n                jQuery.isFunction( resolveValues[ i ] \x26amp;\x26amp; resolveValues[ i ].then ) ) {\n\n                return master.then();\n            }\n        }\n\n        \/\/ Multiple arguments are aggregated like Promise.all array elements\n        \/\/ 多参数时，进行所有参数的解析状态聚合到master上\n        while ( i-- ) {\n            adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n        }\n\n        return master.promise();\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给when传递的对象绑定master.resolve和master.reject，用于聚集多异步对象的状态\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadoptValue\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e value, resolve, reject, noValue \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e method;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Check for promise aspect first to privilege synchronous behavior\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果when传入的参数promise方法可用，则封装promise并添加done和fail方法调用resolve和reject\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( value \x26amp;\x26amp; jQuery.isFunction( ( method = value.promise ) ) ) {\n            method.call( value ).done( resolve ).fail( reject );\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Other thenables\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则，就判断传入参数的then方法是否可用，如果可用就传入resolve和reject方法\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( value \x26amp;\x26amp; jQuery.isFunction( ( method = value.then ) ) ) {\n            method.call( value, resolve, reject );\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Other non-thenables\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果均不可用，则为非异步对象，直接resolve解析原值\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ * false: [ value ].slice( 0 ) =\x26gt; resolve( value )\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ * true: [ value ].slice( 1 ) =\x26gt; resolve()\x3c\/span\x3e\n            resolve.apply( \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, [ value ].slice( noValue ) );\n        }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ For Promises\/A\x2b, convert exceptions into rejections\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Since jQuery.when doesn\x27t unwrap thenables, we can skip the extra checks appearing in\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Deferred#then to conditionally suppress rejection.\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e ( value ) {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Support: Android 4.0 only\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Strict mode functions invoked without .call\/.apply get global-object context\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个安卓4.0的bug，这里不做阐释\x3c\/span\x3e\n        reject.apply( \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, [ value ] );\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Deferred helper\x3c\/span\x3e\n    when: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e singleValue \x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ count of uncompleted subordinates\x3c\/span\x3e\n            remaining = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length,\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ count of unprocessed arguments\x3c\/span\x3e\n            i = remaining,\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ subordinate fulfillment data\x3c\/span\x3e\n            resolveContexts = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e( i ),\n            resolveValues = slice.call( \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e ),\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the master Deferred\x3c\/span\x3e\n            master = jQuery.Deferred(),\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ subordinate callback factory\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将每一个响应的环境和值都保存到列表里，在全部完成后统一传给主Promise用于执行\x3c\/span\x3e\n            updateFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e i \x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e value \x3c\/span\x3e) \x3c\/span\x3e{\n                    resolveContexts[ i ] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n                    resolveValues[ i ] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? slice.call( \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e ) : value;\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !( --remaining ) ) {\n                        master.resolveWith( resolveContexts, resolveValues );\n                    }\n                };\n            };\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Single- and empty arguments are adopted like Promise.resolve\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果只有一个参数，则直接将其作为master的回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( remaining \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ) {\n            adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n                !remaining );\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use .then() to unwrap secondary thenables (cf. gh-3000)\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( master.state() === \x3cspan class=\x22hljs-string\x22\x3e\x22pending\x22\x3c\/span\x3e ||\n                jQuery.isFunction( resolveValues[ i ] \x26amp;\x26amp; resolveValues[ i ].then ) ) {\n\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e master.then();\n            }\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Multiple arguments are aggregated like Promise.all array elements\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 多参数时，进行所有参数的解析状态聚合到master上\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ( i-- ) {\n            adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e master.promise();\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e后续\x3c\/h2\x3e\n\x3cp\x3e本来想把\x3ccode\x3ejQuery.Deferred\x3c\/code\x3e和\x3ccode\x3ejQuery.ajax\x3c\/code\x3e以及\x3ccode\x3eES6\x3c\/code\x3e的\x3ccode\x3ePromise\x3c\/code\x3e对象给统一讲一下，结果发现牵涉的东西太多，每一个都可以单独写一篇文章，怕大家说太长不看，这里先写第一部分\x3ccode\x3ejQuery.Deferred\x3c\/code\x3e吧，后续再补充另外两篇。\x3c\/p\x3e\n\x3cp\x3e看\x3ccode\x3ejQuery\x3c\/code\x3e的文档很容易，使用也很方便，但其实真正想要讲好很复杂，更不要说写篇源码分析文章了。真的是努力理解设计者的思路，争取每行都能理解边界条件，但踩坑太少，应用场景太少，确实有很大的疏漏，希望大家能够理解，不要偏听一面之词。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e参考资料\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3ejQuery - Callbacks: \x3ca href=\x22http:\/\/api.jquery.com\/jQuery.Callbacks\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/api.jquery.com\/jQuery....\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3esegment - jQuery Callbacks: \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004331027\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3ejQuery-3.2.1版本\x3c\/li\x3e\n\x3cli\x3ejQuery - Deferred: \x3ca href=\x22http:\/\/api.jquery.com\/jQuery.Deferred\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/api.jquery.com\/jQuery....\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3ejQuery - when: \x3ca href=\x22http:\/\/www.jquery123.com\/jQuery.when\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.jquery123.com\/jQue...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3ecnblogs - 搞懂jQuery的Promise: \x3ca href=\x22http:\/\/www.cnblogs.com\/lvdabao\/p\/jquery-deferred.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cnblogs.com\/lvdaba...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3ePromise A\x2b 规范: \x3ca href=\x22http:\/\/malcolmyu.github.io\/malnote\/2015\/06\/12\/Promises-A-Plus\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/malcolmyu.github.io\/ma...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>jQuery源码解析Deferred异步对象</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011696453">https://segmentfault.com/a/1190000011696453</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/lq5clwedoni/" target="_blank">https://alili.tech/archive/lq5clwedoni/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>