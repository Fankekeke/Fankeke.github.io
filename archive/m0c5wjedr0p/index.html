<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Web 应用内存分析与内存泄漏定位"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Web 应用内存分析与内存泄漏定位 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/m0c5wjedr0p/",
				"appid": "1613049289050283", 
				"title": "Web 应用内存分析与内存泄漏定位 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-26T02:30:14"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h6t6j85bya/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bel0lilt1hg/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&text=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&text=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&title=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&is_video=false&description=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&title=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&title=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&title=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm0c5wjedr0p%2f&title=Web%20%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90%e4%b8%8e%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%ae%9a%e4%bd%8d"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Web 应用内存分析与内存泄漏定位</h1><div class="meta"><div class="postdate"><time datetime="2018-12-26" itemprop="datePublished">2018-12-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/parg.co\/Ucw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e内存分析与内存泄漏定位\x3c\/a\x3e是笔者\x3ca href=\x22https:\/\/parg.co\/Ubt\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e现代 Web 开发工程化实践之调试技巧\x3c\/a\x3e的一部分，主要介绍 Web 开发中需要了解的内存分析与内存泄露定位手段，本部分涉及的参考资料统一声明在\x3ca href=\x22https:\/\/parg.co\/UUl\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWeb 开发界面调试资料索引\x3c\/a\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e无论是分布式计算系统、服务端应用程序还是 iOS、Android 原生应用都会存在内存泄漏问题，Web 应用自然也不可避免地存在着类似的问题。虽然因为网页往往都是即用即走，较少地存在某个网页长期运行的问题，即使存在内存泄漏可能表现地也不明显；但是在某些数据展示型的，需要长期运行的页面上，如果不及时解决内存泄漏可能会导致网页占据过大地内存，不仅影响页面性能，还可能导致整个系统的崩溃。\x3ca href=\x22https:\/\/parg.co\/UHG\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端每周清单\x3c\/a\x3e推荐过的 \x3ca href=\x22https:\/\/parg.co\/bnw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHow JavaScript works\x3c\/a\x3e 就是非常不错地介绍 JavaScript 运行机制的系列文章，其也对内存管理与内存泄漏有过分析，本文部分图片与示例代码即来自此系列。\x3c\/p\x3e\n\x3cp\x3e类似于 C 这样的语言提供了 \x3ccode\x3emalloc()\x3c\/code\x3e 与 \x3ccode\x3efree()\x3c\/code\x3e 这样的底层内存管理原子操作，开发者需要显式手动地进行内存的申请与释放；而 Java 这样的语言则是提供了自动化的内存回收机制，笔者在\x3ca href=\x22https:\/\/parg.co\/UcF\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e垃圾回收算法与 JVM 垃圾回收器综述\x3c\/a\x3e一文中有过介绍。JavaScript 也是采用的自动化内存回收机制，无论是 Object、String 等都是由垃圾回收进程自动回收处理。自动化内存回收并不意味着我们就可以忽略内存管理的相关操作，反而可能会导致更不易发现的内存泄漏出现。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e内存分配与回收\x3c\/h1\x3e\n\x3cp\x3e笔者在 \x3ca href=\x22https:\/\/parg.co\/Ucj\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Event Loop 机制详解与 Vue.js 中实践应用\x3c\/a\x3e一文中介绍过 JavaScript 的内存模型，其主要也是由堆、栈、队列三方面组成：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842985?w=299\x26amp;h=275\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842985?w=299\x26amp;h=275\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中队列指的是消息队列、栈就是函数执行栈，其基本结构如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842986?w=800\x26amp;h=600\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842986?w=800\x26amp;h=600\x22 alt=\x22JavaScript 栈模型\x22 title=\x22JavaScript 栈模型\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而主要的用户创建的对象就存放在堆中，这也是我们内存分析与内存泄漏定位所需要关注的主要的区域。所谓内存，从硬件的角度来看，就是无数触发器的组合；每个触发器能够存放 1 bit 位的数据，不同的触发器由唯一的标识符定位，开发者可以根据该标识符读写该触发器。抽象来看，我们可以将内存当做比特数组，而数据就是在内存中顺序排布：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842987?w=800\x26amp;h=275\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842987?w=800\x26amp;h=275\x22 alt=\x221*W7L7JN5q4p7w2E7HbBYS3g\x22 title=\x221*W7L7JN5q4p7w2E7HbBYS3g\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eJavaScript 中开发者并不需要手动地为对象申请内存，只需要声明变量，JavaScript Runtime 即可以自动地分配内存：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var n = 374; \/\/ allocates memory for a number\nvar s = \x27sessionstack\x27; \/\/ allocates memory for a string \nvar o = {\n  a: 1,\n  b: null\n}; \/\/ allocates memory for an object and its contained values\nvar a = [1, null, \x27str\x27];  \/\/ (like object) allocates memory for the\n                           \/\/ array and its contained values\nfunction f(a) {\n  return a \x2b 3;\n} \/\/ allocates a function (which is a callable object)\n\/\/ function expressions also allocate an object\nsomeElement.addEventListener(\x27click\x27, function() {\n  someElement.style.backgroundColor = \x27blue\x27;\n}, false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e374\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ allocates memory for a number\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-string\x22\x3e\x27sessionstack\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ allocates memory for a string \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = {\n  \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ allocates memory for an object and its contained values\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27str\x27\x3c\/span\x3e];  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (like object) allocates memory for the\x3c\/span\x3e\n                           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ array and its contained values\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ allocates a function (which is a callable object)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ function expressions also allocate an object\x3c\/span\x3e\nsomeElement.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  someElement.style.backgroundColor = \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e;\n}, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e某个对象的内存生命周期分为了内存分配、内存使用与内存回收这三个步骤，当某个对象不再被需要时，它就应该被清除回收；所谓的垃圾回收器，Garbage Collector 即是负责追踪内存分配情况、判断某个被分配的内存是否有用，并且自动回收无用的内存。大部分的垃圾回收器是根据引用（Reference）来判断某个对象是否存活，所谓的引用即是某个对象是否依赖于其他对象，如果存在依赖关系即存在引用；譬如某个 JavaScript 对象引用了它的原型对象。最简单的垃圾回收算法即是引用计数（Reference Counting），即清除所有零引用的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var o1 = {\n  o2: {\n    x: 1\n  }\n};\n\/\/ 2 objects are created. \n\/\/ \x27o2\x27 is referenced by \x27o1\x27 object as one of its properties.\n\/\/ None can be garbage-collected\n\nvar o3 = o1; \/\/ the \x27o3\x27 variable is the second thing that \n            \/\/ has a reference to the object pointed by \x27o1\x27. \n                                                       \no1 = 1;      \/\/ now, the object that was originally in \x27o1\x27 has a         \n            \/\/ single reference, embodied by the \x27o3\x27 variable\n\nvar o4 = o3.o2; \/\/ reference to \x27o2\x27 property of the object.\n                \/\/ This object has now 2 references: one as\n                \/\/ a property. \n                \/\/ The other as the \x27o4\x27 variable\n\no3 = \x27374\x27; \/\/ The object that was originally in \x27o1\x27 has now zero\n            \/\/ references to it. \n            \/\/ It can be garbage-collected.\n            \/\/ However, what was its \x27o2\x27 property is still\n            \/\/ referenced by the \x27o4\x27 variable, so it cannot be\n            \/\/ freed.\n\no4 = null; \/\/ what was the \x27o2\x27 property of the object originally in\n           \/\/ \x27o1\x27 has zero references to it. \n           \/\/ It can be garbage collected.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o1 = {\n  \x3cspan class=\x22hljs-attr\x22\x3eo2\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  }\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2 objects are created. \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27o2\x27 is referenced by \x27o1\x27 object as one of its properties.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ None can be garbage-collected\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o3 = o1; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the \x27o3\x27 variable is the second thing that \x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ has a reference to the object pointed by \x27o1\x27. \x3c\/span\x3e\n                                                       \no1 = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ now, the object that was originally in \x27o1\x27 has a         \x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ single reference, embodied by the \x27o3\x27 variable\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o4 = o3.o2; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reference to \x27o2\x27 property of the object.\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This object has now 2 references: one as\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a property. \x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ The other as the \x27o4\x27 variable\x3c\/span\x3e\n\no3 = \x3cspan class=\x22hljs-string\x22\x3e\x27374\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ The object that was originally in \x27o1\x27 has now zero\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ references to it. \x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ It can be garbage-collected.\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ However, what was its \x27o2\x27 property is still\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ referenced by the \x27o4\x27 variable, so it cannot be\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ freed.\x3c\/span\x3e\n\no4 = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ what was the \x27o2\x27 property of the object originally in\x3c\/span\x3e\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27o1\x27 has zero references to it. \x3c\/span\x3e\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ It can be garbage collected.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过这种算法往往受制于循环引用问题，即两个无用的对象相互引用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f() {\n  var o1 = {};\n  var o2 = {};\n  o1.p = o2; \/\/ o1 references o2\n  o2.p = o1; \/\/ o2 references o1. This creates a cycle.\n}\n\nf();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o1 = {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o2 = {};\n  o1.p = o2; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ o1 references o2\x3c\/span\x3e\n  o2.p = o1; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ o2 references o1. This creates a cycle.\x3c\/span\x3e\n}\n\nf();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e稍为复杂的算法即是所谓的标记-清除（Mark-Sweep）算法，其根据某个对象是否可达来判断某个对象是否可用。标记-清除算法会从某个根元素开始，譬如 window 对象开始，沿着引用树向下遍历，标记所有可达的对象为可用，并且清除其他未被标记的对象。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842988?w=800\x26amp;h=423\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842988?w=800\x26amp;h=423\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e2012 年之后，几乎所有的主流浏览器都实践了基于标记-清除算法的垃圾回收器，并且各自也进行有针对性地优化。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e内存泄漏\x3c\/h1\x3e\n\x3cp\x3e所谓的内存泄漏，即是指某个对象被无意间添加了某条引用，导致虽然实际上并不需要了，但还是能一直被遍历可达，以致其内存始终无法回收。本部分我们简要讨论下 JavaScript 中常见的内存泄漏情境与处理方法。在新版本的 Chrome 中我们可以使用 Performance Monitor 来动态监测网页性能的变化：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842989?w=800\x26amp;h=460\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842989?w=800\x26amp;h=460\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图中各项指标的含义为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3eCPU usage -\x3c\/strong\x3e 当前站点的 CPU 使用量；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eJS heap size -\x3c\/strong\x3e 应用的内存占用量；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eDOM Nodes -\x3c\/strong\x3e 内存中 DOM 节点数目；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eJS event listeners-\x3c\/strong\x3e 当前页面上注册的 JavaScript 时间监听器数目;\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eDocuments -\x3c\/strong\x3e 当前页面中使用的样式或者脚本文件数目；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eFrames -\x3c\/strong\x3e 当前页面上的 Frames 数目，包括 iframe 与 workers；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eLayouts \/ sec -\x3c\/strong\x3e 每秒的 DOM 重布局数目；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eStyle recalcs \/ sec -\x3c\/strong\x3e 浏览器需要重新计算样式的频次；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当发现某个时间点可能存在内存泄漏时，我们可以使用 Memory 标签页将此时的堆分配情况打印下来：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842990?w=1070\x26amp;h=648\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842990?w=1070\x26amp;h=648\x22 alt=\x22Memory Snapshot Take heap snapshot\x22 title=\x22Memory Snapshot Take heap snapshot\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011842991?w=1924\x26amp;h=1210\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011842991?w=1924\x26amp;h=1210\x22 alt=\x22Memory Snapshot 结果\x22 title=\x22Memory Snapshot 结果\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e全局变量\x3c\/h2\x3e\n\x3cp\x3eJavaScript 会将所有的为声明的变量当做全局变量进行处理，即将其挂载到 global 对象上；浏览器中这里的 global 对象就是 window:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(arg) {\n    bar = \x26quot;some text\x26quot;;\n}\n\n\/\/ 等价于\n\nfunction foo(arg) {\n    window.bar = \x26quot;some text\x26quot;;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earg\x3c\/span\x3e) \x3c\/span\x3e{\n    bar = \x3cspan class=\x22hljs-string\x22\x3e\x22some text\x22\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等价于\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earg\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.bar = \x3cspan class=\x22hljs-string\x22\x3e\x22some text\x22\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另一种常见的创建全局变量的方式就是误用 \x3ccode\x3ethis\x3c\/code\x3e 指针：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    this.var1 = \x26quot;potential accidental global\x26quot;;\n}\n\/\/ Foo called on its own, this points to the global object (window)\n\/\/ rather than being undefined.\nfoo();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.var1 = \x3cspan class=\x22hljs-string\x22\x3e\x22potential accidental global\x22\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Foo called on its own, this points to the global object (window)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ rather than being undefined.\x3c\/span\x3e\nfoo();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一旦某个变量被挂载到了 window 对象，就意味着它永远是可达的。为了避免这种情况，我们应该尽可能地添加 \x3ccode\x3euse strict\x3c\/code\x3e 或者进行模块化编码（参考 \x3ca href=\x22https:\/\/parg.co\/Uc2\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript 模块演化简史\x3c\/a\x3e）。我们也可以扩展类似于下文的扫描函数，来检测出 window 对象的非原生属性，并加以判断：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function scan(o) {\n  Object.keys(o).forEach(function(key) {\n    var val = o[key];\n\n    \/\/ Stop if object was created in another window\n    if (\n      typeof val !== \x26quot;string\x26quot; \x26amp;\x26amp;\n      typeof val !== \x26quot;number\x26quot; \x26amp;\x26amp;\n      typeof val !== \x26quot;boolean\x26quot; \x26amp;\x26amp;\n      !(val instanceof Object)\n    ) {\n      debugger;\n      console.log(key);\n    }\n\n    \/\/ Traverse the nested object hierarchy\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3escan\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eo\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(o).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e val = o[key];\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Stop if object was created in another window\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val !== \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e \x26amp;\x26amp;\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val !== \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e \x26amp;\x26amp;\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val !== \x3cspan class=\x22hljs-string\x22\x3e\x22boolean\x22\x3c\/span\x3e \x26amp;\x26amp;\n      !(val \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e)\n    ) {\n      \x3cspan class=\x22hljs-keyword\x22\x3edebugger\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(key);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Traverse the nested object hierarchy\x3c\/span\x3e\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e定时器与闭包\x3c\/h2\x3e\n\x3cp\x3e我们经常会使用 \x3ccode\x3esetInterval\x3c\/code\x3e 来执行定时任务，很多的框架也提供了基于回调的异步执行机制；这可能会导致回调中声明了对于某个变量的依赖，譬如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var serverData = loadData();\nsetInterval(function() {\n    var renderer = document.getElementById(\x27renderer\x27);\n    if(renderer) {\n        renderer.innerHTML = JSON.stringify(serverData);\n    }\n}, 5000); \/\/This will be executed every ~5 seconds.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e serverData = loadData();\nsetInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e renderer = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27renderer\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(renderer) {\n        renderer.innerHTML = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(serverData);\n    }\n}, \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/This will be executed every ~5 seconds.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e定时器保有对于 serverData 变量的引用，如果我们不手动清除定时器话，那么该变量也就会一直可达，不被回收。而这里的 serverData 也是闭包形式被引入到 setInterval 的回调作用域中；闭包也是常见的可能导致内存泄漏的元凶之一：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var unused = function () {\n    if (originalThing) \/\/ a reference to \x27originalThing\x27\n      console.log(\x26quot;hi\x26quot;);\n  };\n  theThing = {\n    longStr: new Array(1000000).join(\x27*\x27),\n    someMethod: function () {\n      console.log(\x26quot;message\x26quot;);\n    }\n  };\n};\nsetInterval(replaceThing, 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e theThing = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e replaceThing = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e originalThing = theThing;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e unused = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (originalThing) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a reference to \x27originalThing\x27\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22hi\x22\x3c\/span\x3e);\n  };\n  theThing = {\n    \x3cspan class=\x22hljs-attr\x22\x3elongStr\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-attr\x22\x3esomeMethod\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e);\n    }\n  };\n};\nsetInterval(replaceThing, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中 replaceThing 会定期执行，并且创建大的数组与 someMethod 闭包赋值给 theThing。someMethod 作用域是与 unused 共享的，unused 又有一个指向 originalThing 的引用。尽管 unused 并未被实际使用，theThing 的 someMethod 方法却有可能会被外部使用，也就导致了 unused 始终处于可达状态。unused 又会反向依赖于 theThing，最终导致大数组始终无法被清除。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eDOM 引用与监听器\x3c\/h2\x3e\n\x3cp\x3e有时候我们可能会将 DOM 元素存放到数据结构中，譬如当我们需要频繁更新某个数据列表时，可能会将用到的数据列表存放在 JavaScript 数组中；这也就导致了每个 DOM 元素存在了两个引用，分别在 DOM 树与 JavaScript 数组中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var elements = {\n    button: document.getElementById(\x27button\x27),\n    image: document.getElementById(\x27image\x27)\n};\nfunction doStuff() {\n    elements.image.src = \x27http:\/\/example.com\/image_name.png\x27;\n}\nfunction removeImage() {\n    \/\/ The image is a direct child of the body element.\n    document.body.removeChild(document.getElementById(\x27image\x27));\n    \/\/ At this point, we still have a reference to #button in the\n    \/\/global elements object. In other words, the button element is\n    \/\/still in memory and cannot be collected by the GC.\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elements = {\n    \x3cspan class=\x22hljs-attr\x22\x3ebutton\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27button\x27\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-attr\x22\x3eimage\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27image\x27\x3c\/span\x3e)\n};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoStuff\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    elements.image.src = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/example.com\/image_name.png\x27\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eremoveImage\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ The image is a direct child of the body element.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.removeChild(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27image\x27\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ At this point, we still have a reference to #button in the\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/global elements object. In other words, the button element is\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/still in memory and cannot be collected by the GC.\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时我们就需要将 DOM 树与 JavaScript 数组中的引用皆删除，才能真实地清除该对象。类似的，在老版本的浏览器中，如果我们清除某个 DOM 元素，我们需要首先移除其监听器，否则浏览器并不会自动地帮我们清除该监听器，或者回收该监听器引用的对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var element = document.getElementById(\x27launch-button\x27);\nvar counter = 0;\nfunction onClick(event) {\n   counter\x2b\x2b;\n   element.innerHtml = \x27text \x27 \x2b counter;\n}\nelement.addEventListener(\x27click\x27, onClick);\n\/\/ Do stuff\nelement.removeEventListener(\x27click\x27, onClick);\nelement.parentNode.removeChild(element);\n\/\/ Now when element goes out of scope,\n\/\/ both element and onClick will be collected even in old browsers \/\/ that don\x27t handle cycles well.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27launch-button\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonClick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n   counter\x2b\x2b;\n   element.innerHtml = \x3cspan class=\x22hljs-string\x22\x3e\x27text \x27\x3c\/span\x3e \x2b counter;\n}\nelement.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do stuff\x3c\/span\x3e\nelement.removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, onClick);\nelement.parentNode.removeChild(element);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Now when element goes out of scope,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ both element and onClick will be collected even in old browsers \/\/ that don\x27t handle cycles well.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现代浏览器使用的现代垃圾回收器则会帮我们自动地检测这种循环依赖，并且予以清除；jQuery 等第三方库也会在清除元素之前首先移除其监听事件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eiframe\x3c\/h2\x3e\n\x3cp\x3eiframe 是常见的界面共享方式，不过如果我们在父界面或者子界面中添加了对于父界面某对象的引用，譬如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 子页面内\nwindow.top.innerObject = someInsideObject\nwindow.top.document.addEventLister(‘click’, function() { … });\n\n\/\/ 外部页面\n innerObject = iframeEl.contentWindow.someInsideObject\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 子页面内\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.top.innerObject = someInsideObject\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.top.document.addEventLister(‘click’, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ … });\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 外部页面\x3c\/span\x3e\n innerObject = iframeEl.contentWindow.someInsideObject\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就有可能导致 iframe 卸载（移除元素）之后仍然有部分对象保留下来，我们可以在移除 iframe 之前执行强制的页面重载：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca href=\x26quot;#\x26quot;\x3eRemove\x3c\/a\x3e\n\x3ciframe src=\x26quot;url\x26quot; \/\x3e​\n\n$(\x27a\x27).click(function(){\n    $(\x27iframe\x27)[0].contentWindow.location.reload();\n    \/\/ 线上环境实测重置 src 效果会更好\n    \/\/ $(\x27iframe\x27)[0].src = \x26quot;javascript:false\x26quot;;\n    setTimeout(function(){\n       $(\x27iframe\x27).remove();\n    }, 1000);\n});​\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;a href=\x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e\x26gt;Remove\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/a\x26gt;\n\x26lt;iframe src=\x22url\x22 \/\x3c\/span\x3e\x26gt;​\n\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e).click(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].contentWindow.location.reload();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 线上环境实测重置 src 效果会更好\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ $(\x27iframe\x27)[0].src = \x22javascript:false\x22;\x3c\/span\x3e\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n       $(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e).remove();\n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n});​\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者手动地执行页面清除操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.onbeforeunload = function(){\n    $(document).unbind().die();    \/\/remove listeners on document\n    $(document).find(\x27*\x27).unbind().die(); \/\/remove listeners on all nodes\n    \/\/clean up cookies\n    \/remove items from localStorage\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onbeforeunload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    $(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e).unbind().die();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/remove listeners on document\x3c\/span\x3e\n    $(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e).find(\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e).unbind().die(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/remove listeners on all nodes\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/clean up cookies\x3c\/span\x3e\n    \/remove items \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e localStorage\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eWeb Worker\x3c\/h2\x3e\n\x3cp\x3e现代浏览器中我们经常使用 Web Worker 来运行后台任务，不过有时候如果我们过于频繁且不加容错地在主线程与工作线程之间传递数据，可能会导致内存泄漏：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function send() {\n setInterval(function() { \n    const data = {\n     array1: get100Arrays(),\n     array2: get500Arrays()\n    };\n\n    let json = JSON.stringify( data );\n    let arbfr = str2ab (json);\n    worker.postMessage(arbfr, [arbfr]);\n  }, 10);\n}\n\n\nfunction str2ab(str) {\n   var buf = new ArrayBuffer(str.length*2); \/\/ 2 bytes for each char\n   var bufView = new Uint16Array(buf);\n   for (var i=0, strLen=str.length; i\x3cstrLen; i\x2b\x2b) {\n     bufView[i] = str.charCodeAt(i);\n   }\n   return buf;\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esend\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n setInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {\n     \x3cspan class=\x22hljs-attr\x22\x3earray1\x3c\/span\x3e: get100Arrays(),\n     \x3cspan class=\x22hljs-attr\x22\x3earray2\x3c\/span\x3e: get500Arrays()\n    };\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e json = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify( data );\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arbfr = str2ab (json);\n    worker.postMessage(arbfr, [arbfr]);\n  }, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\n}\n\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estr2ab\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estr\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e buf = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArrayBuffer\x3c\/span\x3e(str.length*\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2 bytes for each char\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bufView = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eUint16Array\x3c\/span\x3e(buf);\n   \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, strLen=str.length; i\x26lt;strLen; i\x2b\x2b) {\n     bufView[i] = str.charCodeAt(i);\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e buf;\n }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在实际的代码中我们应该检测 Transferable Objects 是否正常工作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let ab = new ArrayBuffer(1);\n\ntry {\n   worker.postMessage(ab, [ab]);\n\n   if (ab.byteLength) {\n      console.log(\x27TRANSFERABLE OBJECTS are not supported in your browser!\x27);\n   } \n   else {\n     console.log(\x27USING TRANSFERABLE OBJECTS\x27);\n   }\n} \ncatch(e) {\n  console.log(\x27TRANSFERABLE OBJECTS are not supported in your browser!\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ab = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArrayBuffer\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n   worker.postMessage(ab, [ab]);\n\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ab.byteLength) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27TRANSFERABLE OBJECTS are not supported in your browser!\x27\x3c\/span\x3e);\n   } \n   \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27USING TRANSFERABLE OBJECTS\x27\x3c\/span\x3e);\n   }\n} \n\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27TRANSFERABLE OBJECTS are not supported in your browser!\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Web 应用内存分析与内存泄漏定位</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011842980">https://segmentfault.com/a/1190000011842980</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/m0c5wjedr0p/" target="_blank">https://alili.tech/archive/m0c5wjedr0p/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>