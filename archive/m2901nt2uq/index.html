<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【用故事解读 MobX源码（三）】 shouldCompute"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【用故事解读 MobX源码（三）】 shouldCompute | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/m2901nt2uq/",
				"appid": "1613049289050283", 
				"title": "【用故事解读 MobX源码（三）】 shouldCompute | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-02T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h0wzwwb5gw/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/j2c6n6zopa9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&text=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&text=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&title=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&is_video=false&description=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&title=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&title=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&title=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm2901nt2uq%2f&title=%e3%80%90%e7%94%a8%e6%95%85%e4%ba%8b%e8%a7%a3%e8%af%bb%20MobX%e6%ba%90%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89%e3%80%91%20shouldCompute"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【用故事解读 MobX源码（三）】 shouldCompute</h1><div class="meta"><div class="postdate"><time datetime="2018-12-02" itemprop="datePublished">2018-12-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e================前言===================\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e初衷\x3c\/strong\x3e：以系列故事的方式展现 MobX 源码逻辑，尽可能以易懂的方式讲解源码；\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e本系列文章\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000013682735\x22\x3e【用故事解读 MobX源码（一）】 autorun\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014238836\x22 target=\x22_blank\x22\x3e【用故事解读 MobX源码（二）】 computed\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014726483\x22\x3e【用故事解读 MobX源码（三）】 shouldCompute\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000015481998\x22 target=\x22_blank\x22\x3e【用故事解读 MobX 源码（四）】装饰器 和 Enhancer\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000015875144\x22\x3e【用故事解读 MobX 源码（五）】 Observable\x3c\/a\x3e》\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e文章编排\x3c\/strong\x3e：每篇文章分成两大段，第一大段以简单的侦探系列故事的形式讲解（\x3cstrong\x3e所涉及人物、场景都以 MobX 中的概念为原型创建\x3c\/strong\x3e），第二大段则是源码讲解。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e本文基于 MobX 4 源码讲解\x3c\/strong\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e=======================================\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3eA. Story Time\x3c\/h1\x3e\n\x3cp\x3e宁静的早上，执行官 MobX 将自己的计算性能优化机制报告呈现给警署最高长官。\x3c\/p\x3e\n\x3cp\x3e在这份报告解说中，谈及部署成本最高的地方是在\x3cstrong\x3e执行任务部分\x3c\/strong\x3e。因此优化这部分任务执行机制，也就相当于优化性能。\x3c\/p\x3e\n\x3cp\x3e警署最高长官浏览了报告前言部分，大致总结以下 2 点核心思想：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e有\x3cstrong\x3e两组人\x3c\/strong\x3e会涉及到任务的执行：\x3cstrong\x3e执行组\x3c\/strong\x3e（探长） 和 \x3cstrong\x3e计算组\x3c\/strong\x3e（会计师）\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e言外之意，\x3cstrong\x3e观察组\x3c\/strong\x3e（观察员）不在优化机制里，他们的行为仍旧按部就班，该汇报的时候就汇报，该提供数据的时候提供数据。\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e由于\x3cstrong\x3e执行任务的比较消耗资源\x3c\/strong\x3e，因此执行人员对每一次任务的执行都要问一个”为什么“，最核心的一点是：如果下级人员的\x3cstrong\x3e数据不是最新\x3c\/strong\x3e的时候，上级人员就不应该执行任务。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbfdF1?w=549\x26amp;h=511\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbfdF1?w=549\x26amp;h=511\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那么，执行人员依据什么样的规则来决定是否执行呢？\x3c\/p\x3e\n\x3cp\x3e警署最高长官继续往下阅读，找到了解答该问题的详细解说。简言之，为了解决该问题执行官 MobX 给出了\x3cstrong\x3e状态调整策略\x3c\/strong\x3e，并在这套策略之上指定的\x3cstrong\x3e任务执行规则\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e由于专业性较强，行文解释里多处使用代码。为了更生动形象地解释这套行为规范，执行官 MobX 在报告里采用 \x3cstrong\x3e示例 \x2b 图示\x3c\/strong\x3e 的方式给出生动形象的解释。\x3c\/p\x3e\n\x3cp\x3e接下来我们在 \x3cstrong\x3eB. Source Code Time\x3c\/strong\x3e 部分详细阐述这份 \x3cstrong\x3e任务执行规则\x3c\/strong\x3e 的内容。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3eB. Source Code Time\x3c\/h1\x3e\n\x3cp\x3e执行人员（探长和会计师）依据什么样的规则来决定是否执行呢？\x3c\/p\x3e\n\x3cp\x3e答案是，执行官 MobX 提供了一个名为 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L76\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eshouldCompute\x3c\/a\x3e 的方法，每次执行人员（探长和会计师）需要执行之前都要调用该方法 —— 只有该方法返回 \x3ccode\x3etrue\x3c\/code\x3e 的时候才会执行任务（或计算）。\x3c\/p\x3e\n\x3cblockquote\x3e在源码里搜索一下关键字 \x3ccode\x3eshouldCompute\x3c\/code\x3e，就可以知道的确只有 \x3cstrong\x3ederivation\x3c\/strong\x3e（执行组，探长也属于执行组）、\x3cstrong\x3ereaction\x3c\/strong\x3e（探长）、\x3cstrong\x3ecomputeValue\x3c\/strong\x3e（会计师）这些有执行权力的人才能调用这个方法，而 \x3cstrong\x3eobserverable\x3c\/strong\x3e（观察员）并不在其中。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbfdF5?w=267\x26amp;h=400\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbfdF5?w=267\x26amp;h=400\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e也就说 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L76\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eshouldCompute\x3c\/a\x3e 就是\x3cstrong\x3e任务执行规则\x3c\/strong\x3e，\x3cstrong\x3e任务执行规则\x3c\/strong\x3e就是 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L76\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eshouldCompute\x3c\/a\x3e。而背后支撑 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L76\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eshouldCompute\x3c\/a\x3e 的则是一套 \x3cstrong\x3e状态调整策略\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e1、状态调整策略\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.1、\x3cstrong\x3eL 属性\x3c\/strong\x3e 和 \x3cstrong\x3eD 属性\x3c\/strong\x3e\n\x3c\/h3\x3e\n\x3cp\x3e翻开 \x3ccode\x3eshouldCompute\x3c\/code\x3e 源码， 将会看到 \x3ccode\x3edependenciesState\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbfdGa?w=600\x26amp;h=211\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbfdGa?w=600\x26amp;h=211\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其实这个 \x3ccode\x3edependenciesState\x3c\/code\x3e（以下简称 \x3cstrong\x3eD 属性\x3c\/strong\x3e） 属性还存在一个”孪生“属性\x3ccode\x3elowestObserverState\x3c\/code\x3e （以下简称 \x3cstrong\x3eL 属性\x3c\/strong\x3e）。这两个属性正是执行官 MobX 状态调整策略的核心。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eL 属性\x3c\/strong\x3e 和 \x3cstrong\x3eD 属性\x3c\/strong\x3e反映当前对象\x3cstrong\x3e所处的状态\x3c\/strong\x3e， 都是枚举值，且取值区间都是一致的，只能是以下 4 个值之一：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e-1\x3c\/strong\x3e： 即 \x3cstrong\x3eNOT_TRACKING\x3c\/strong\x3e，表示不在调整环节内（还未进入调整调整，或者已经退出调整环节）\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e0\x3c\/strong\x3e：即 \x3cstrong\x3eUP_TO_DATE\x3c\/strong\x3e，表示状态很稳定\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e1\x3c\/strong\x3e： 即 \x3cstrong\x3ePOSSIBLY_STALE\x3c\/strong\x3e，表示状态有可能不稳定\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2\x3c\/strong\x3e：即 \x3cstrong\x3eSTALE\x3c\/strong\x3e，表示状态不稳定\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上面的文字表述比较枯燥，我们来张图感受一下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbfdGm?w=400\x26amp;h=142\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbfdGm?w=400\x26amp;h=142\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们以 “阶梯” 来表示上述的状态值；\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3eUP_TO_DATE\x3c\/strong\x3e（0） 是地面（表示“非常稳定”）\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3ePOSSIBLY_STALE\x3c\/strong\x3e（1） 是第一个台阶\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eSTALE\x3c\/strong\x3e（2） 是第 2 个台阶，\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eNOT_TRACKING\x3c\/strong\x3e（-1）则到地下一层去了\x3c\/li\x3e\n\x3cli\x3e所谓 “高处不胜寒”，\x3cstrong\x3e距离地面越高，就代表越不稳定\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e状态值 \x3cstrong\x3eUP_TO_DATE\x3c\/strong\x3e（0）代表的含义是 \x3cstrong\x3e稳定的状态\x3c\/strong\x3e，是每个对象所倾向的状态值。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.2、调整策略\x3c\/h3\x3e\n\x3cp\x3e依托\x3cstrong\x3eL 属性\x3c\/strong\x3e 和 \x3cstrong\x3eD 属性\x3c\/strong\x3e，执行官 MobX 的调整策略应运而生：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e只有在 \x3cstrong\x3e观察值发生变化\x3c\/strong\x3e 的时候（比如修改了 \x3ccode\x3ebankUser.income\x3c\/code\x3e 属性值），才会启用这套机制；\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e下级成员拥有 \x3cstrong\x3eL 属性\x3c\/strong\x3e；而上级成员拥有 \x3cstrong\x3eD 属性\x3c\/strong\x3e，比如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e观察员 O1 只拥有 \x3cstrong\x3eL 属性\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3e探长 R1 只拥有 \x3cstrong\x3eD 属性\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3e会计师 C1 既拥有 \x3cstrong\x3eL 属性\x3c\/strong\x3e，也拥有 \x3cstrong\x3eD 属性\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e某下级成员调整属性时，调整的策略必须要满足：自身的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 永远不大于（≤）上级的 \x3cstrong\x3eL 属性\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3e某上级成员调整属性时，调整的策略必须要满足：其下级成员的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 永远不大于（≤）自身的 \x3cstrong\x3eL 属性\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3e观察值的变更会让成员的属性值 \x3cstrong\x3e上升\x3c\/strong\x3e（提高不稳定性），MobX 执行任务会让成员属性值 \x3cstrong\x3e降低\x3c\/strong\x3e（不稳定性降低）；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上述调整策略给我们的直观感受，\x3cstrong\x3e就是外界的影响导致 MobX 执行官的部署系统不稳定性上升，为了消除这些不稳定，MobX 会尽可能协调各方去执行任务，从而消除这些个不稳定性\x3c\/strong\x3e。\x3cbr\x3e（举个不甚恰当的例子，参考人类的免疫机制，病毒感冒后体温上升就是典型的免疫机制激活的外在表现，抵御完病毒之后体温又回归正常）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e2、执行任务规则\x3c\/h2\x3e\n\x3cp\x3e我们知道，只有上级成员（探长或者设计师）才有执行任务的权力；而一旦满足上面的调整策略，\x3cstrong\x3e在任何时刻\x3c\/strong\x3e，执行官 MobX 直接查阅该上级成员的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 就能断定该上级成员（探长或者设计师）是否需要执行任务了，非常简单方便。\x3c\/p\x3e\n\x3cp\x3e执行官 MobX 判断的依据都体现在 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.0\/src\/core\/derivation.ts#L76\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eshouldCompute\x3c\/a\x3e 方法中了。\x3c\/p\x3e\n\x3cblockquote\x3e本人窃认为这个 \x3ccode\x3eshouldCompute\x3c\/code\x3e 函数的名字太过于抽象，如果让我命名的话，我更倾向于使用 \x3ccode\x3eshouldExecuteTask\x3c\/code\x3e 这个单词。\x3c\/blockquote\x3e\n\x3cp\x3e依托\x3cstrong\x3eL 属性\x3c\/strong\x3e 和 \x3cstrong\x3eD 属性\x3c\/strong\x3e，执行任务规则（即 \x3ccode\x3eshouldCompute\x3c\/code\x3e）就出炉了：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果属性值为 \x3cstrong\x3eNOT_TRACKING\x3c\/strong\x3e（-1）或者 \x3cstrong\x3eSTALE\x3c\/strong\x3e（2），说明自己所依赖的下级数值陈旧了，是时候该重新执行任务（或重新计算）了；\x3c\/li\x3e\n\x3cli\x3e如果属性值为 \x3cstrong\x3eUP_TO_DATE\x3c\/strong\x3e（0），说明所依赖的下级的数值没有更改，是稳定的，不需要重新执行任务。\x3c\/li\x3e\n\x3cli\x3e如果属性值为 \x3cstrong\x3ePOSSIBLY_STALE\x3c\/strong\x3e（1），说明所依赖的值（一定是计算值，只有计算值的参与才会出现这种状态）有可能变更，需要让下级先确认完后再做进一步判断。这种情况可能不太好理解，后文会详细说明。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e执行任务规则看上去比较简单，但应用到执行官 MobX 自动化部署方案中情况就复杂了。下面将通过 3 个场景，从简单到复杂，一步一步来演示\x3cstrong\x3eL 属性\x3c\/strong\x3e和\x3cstrong\x3eD 属性\x3c\/strong\x3e 是如何巧妙地融合到已有的部署方案中，并以最小的成本实现性能优化的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e2.1、最简单的情况\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var bankUser = mobx.observable({\n  income: 3,\n  debit: 2\n});\n\nmobx.autorun(() =\x3e {\n  console.log(\x27张三的存贷：\x27, income);\n});\n\nbankUser.income = 4;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bankUser = mobx.observable({\n  \x3cspan class=\x22hljs-attr\x22\x3eincome\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edebit\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n});\n\nmobx.autorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27张三的存贷：\x27\x3c\/span\x3e, income);\n});\n\nbankUser.income = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们创建了 \x3ccode\x3eautorun\x3c\/code\x3e 实例 （探长 R1）、\x3ccode\x3eobservable\x3c\/code\x3e实例（观察员O1）\x3c\/p\x3e\n\x3cp\x3e这个示例和我们之前在首篇文章《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000013682735\x22\x3e【用故事解读 MobX源码（一）】 autorun\x3c\/a\x3e》中所用示例是一致的。\x3c\/p\x3e\n\x3cp\x3e当执行 \x3ccode\x3ebankUser.income = 4;\x3c\/code\x3e 语句的时候，观察员 O1 观察到的数值变化直接上报给探长 R1，然后探长就执行任务了。关系简单：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726492?w=331\x26amp;h=198\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726492?w=331\x26amp;h=198\x22 alt=\x22upstream\x22 title=\x22upstream\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从代码层面上来讲，该 \x3cstrong\x3e响应链\x3c\/strong\x3e 上的关键函数执行顺序如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(O1) reportChange \n    -\x3e (O1) propagateChanged \n    -\x3e (R1) onBecomeStale \n      -\x3e (R1) trackDerivedFunction \n         -\x3e fn(即执行 autorun 中的回调) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e(O1) reportChange \n    -\x26gt; (O1) propagateChanged \n    -\x26gt; (R1) onBecomeStale \n      -\x26gt; (R1) trackDerivedFunction \n         -\x26gt; fn(即执行 autorun 中的回调) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中涉及到 \x3cstrong\x3eL、D属性\x3c\/strong\x3e 更改的函数有 \x3ccode\x3epropagateChanged\x3c\/code\x3e 和 \x3ccode\x3etrack\x3c\/code\x3e 这两个。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 1\x3c\/strong\x3e：在 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.0\/src\/core\/observable.ts#L197\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateChanged\x3c\/a\x3e 方法执行时，让观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 0 → 2 ，按照上述的调整原则，探长 R1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 必须要高于观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e，所以其值也只能用从 0 → 2。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726493?w=829\x26amp;h=378\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726493?w=829\x26amp;h=378\x22 alt=\x22pagechagned\x22 title=\x22pagechagned\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 2\x3c\/strong\x3e：而随着 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L144\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etrackDerivedFunction\x3c\/a\x3e 方法的执行（即探长执行任务）后，观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 又从 2 → 0，同时也让探长 R1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 从 2 → 0；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726494?w=826\x26amp;h=376\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726494?w=826\x26amp;h=376\x22 alt=\x22track\x22 title=\x22track\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在这里我们已经可以明显感受到 \x3cstrong\x3e非稳态的上升\x3c\/strong\x3e 和 \x3cstrong\x3e削减\x3c\/strong\x3e 这两个阶段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的上升\x3c\/strong\x3e：外界更改 \x3ccode\x3ebankUser.income\x3c\/code\x3e 属性，触发 \x3ccode\x3epropagateChanged\x3c\/code\x3e 方法，从而让观察员的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 以及探长的 \x3cstrong\x3eD属性\x3c\/strong\x3e 都变成了 2 ，这是系统趋向不稳定的表现。从 层级上来看，是\x3cstrong\x3e自下而上\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的削减\x3c\/strong\x3e：随着变更的传递，将触发探长 R1 的 \x3ccode\x3eonBecameStale\x3c\/code\x3e 方法。执行期间 MobX 执行官查阅探长的 \x3cstrong\x3eD属性\x3c\/strong\x3e 是 2，依据 \x3ccode\x3eshouldCompute\x3c\/code\x3e 中的执行规定，同意让探长执行任务。执行完之后，观察员的 \x3cstrong\x3eL 属性\x3c\/strong\x3e、探长的 \x3cstrong\x3eD属性\x3c\/strong\x3e 都下降为 0，表示系统又重新回到稳定状态。从 层级上来看，是\x3cstrong\x3e自上而下\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.2、有单个会计师的情况\x3c\/h3\x3e\n\x3cp\x3e上面介绍了最简单的情况，只有一个探长 R1（\x3ccode\x3eautorun\x3c\/code\x3e）和一个观察员 O1（\x3ccode\x3eincome\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cp\x3e现在我们将环境稍微弄复杂一些，新增一个 \x3cstrong\x3e会计师 C1\x3c\/strong\x3e（\x3ccode\x3edivisor\x3c\/code\x3e） ，此时再来看看上述的变更原则是如何在系统运转时起作用的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var bankUser = mobx.observable({\n  income: 3,\n  debit: 2\n});\n\nvar divisor = mobx.computed(() =\x3e {\n  return bankUser.income \/ bankUser.debit;\n});\n\nmobx.autorun(() =\x3e {\n  console.log(\x27张三的 divisor：\x27, divisor);\n});\n\nbankUser.income = 4;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bankUser = mobx.observable({\n  \x3cspan class=\x22hljs-attr\x22\x3eincome\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edebit\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e divisor = mobx.computed(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bankUser.income \/ bankUser.debit;\n});\n\nmobx.autorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27张三的 divisor：\x27\x3c\/span\x3e, divisor);\n});\n\nbankUser.income = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个示例和我们之前在首篇文章《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014238836\x22\x3e【用故事解读 MobX源码（二）】 computed \x3c\/a\x3e》中所用示例是一致的。\x3c\/p\x3e\n\x3cp\x3e当我们执行 \x3ccode\x3ebankUser.income = 4;\x3c\/code\x3e 语句的时候，观察员 O1 先上报给会计师 C1，接着会计师 C1 会重新执行计算任务后，上报给探长，探长R1 再重新执行任务。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726495?w=351\x26amp;h=276\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726495?w=351\x26amp;h=276\x22 alt=\x22c1 upstream\x22 title=\x22c1 upstream\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面描述起来比较简单，但从代码层面上来讲还是有些绕，先列出该 \x3cstrong\x3e响应链\x3c\/strong\x3e 上的关键函数执行顺序如下（很明显比上面的示例要稍微复杂一些）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(O1) reportChange \n    -\x3e (O1) propagateChanged\n      -\x3e (C1) propagateMaybeChanged\n      -\x3e (R1) onBecomeStale（这里并不会让探长 `runReaction`）\n-\x3e (O1) endBatch\n    -\x3e (R1) runReaction（到这里才让探长执行 `runReaction`）\n      -\x3e (C1) reportObserved\n      -\x3e (C1) shouldCompute\n         -\x3e (C1) trackAndCompute \n         -\x3e (C1) propagateChangeConfirmed\n      -\x3e (R1) trackDerivedFunction\n         -\x3e fn(即执行 autorun 中的回调) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e(O1) reportChange \n    -\x26gt; (O1) propagateChanged\n      -\x26gt; (C1) propagateMaybeChanged\n      -\x26gt; (R1) onBecomeStale（这里并不会让探长 \x3cspan class=\x22hljs-string\x22\x3e`runReaction`\x3c\/span\x3e）\n-\x26gt; (O1) endBatch\n    -\x26gt; (R1) runReaction（到这里才让探长执行 \x3cspan class=\x22hljs-string\x22\x3e`runReaction`\x3c\/span\x3e）\n      -\x26gt; (C1) reportObserved\n      -\x26gt; (C1) shouldCompute\n         -\x26gt; (C1) trackAndCompute \n         -\x26gt; (C1) propagateChangeConfirmed\n      -\x26gt; (R1) trackDerivedFunction\n         -\x26gt; fn(即执行 autorun 中的回调) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e注：这里还需要啰嗦一句，虽然这里会触发探长 R1 的 \x3ccode\x3eonBecomeStale\x3c\/code\x3e 方法，但 MobX 并不会直接让探长执行任务，这也是 MobX 优化的一种手段体现，详细分析请移步《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014238836\x22 target=\x22_blank\x22\x3e【用故事解读 MobX源码（二）】 computed \x3c\/a\x3e》。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 1\x3c\/strong\x3e：在 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.0\/src\/core\/observable.ts#L197\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateChanged\x3c\/a\x3e 方法执行时，让观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 -1 → 2 ，按照上述的调整原则，其直接上级 C1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 必须要高于观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e，所以其值也只能用从 0 → 2；\x3c\/p\x3e\n\x3cp\x3e和上述简单示例中最大的不同，\x3cstrong\x3e在于该期间还涉及到会计师 C1 的状态更改\x3c\/strong\x3e，具体表现就是调用 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/observable.ts#L238\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateMaybeChanged\x3c\/a\x3e ，在该方法执行后让会计师 C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 0 → 1 ，其直接上级 R1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 必须要高于会计师 C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e，所以其值也从 0 → 1；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726496?w=1220\x26amp;h=385\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726496?w=1220\x26amp;h=385\x22 alt=\x22maybechanged\x22 title=\x22maybechanged\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e注：虽然观察员 O1 的状态更改 \x3cstrong\x3e不能直接\x3c\/strong\x3e 触发探长 R1 的状态更改，却可以凭借会计师 C1 \x3cstrong\x3e间接\x3c\/strong\x3e 地让 探长 R1 的状态发生更改。\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eStep 2\x3c\/strong\x3e：此步骤是以 \x3cstrong\x3e会计师\x3c\/strong\x3e 状态变更为中心演变过程，上一个案例并不存在会计师，所以并不会有该步骤。通过 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/computedvalue.ts#L189\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etrackAndCompute\x3c\/a\x3e 方法，会计师 C1 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 又从 2 → 0，同时也让观察员 O1 的 \x3cstrong\x3eL属性\x3c\/strong\x3e 从 2 → 0；这个过程表明会计师 C1 的计算值已经更新了。\x3c\/p\x3e\n\x3cp\x3e随后在 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/observable.ts#L218\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateChangeConfirmed\x3c\/a\x3e 中让探长 R1 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 从 1 （下级数值可能有更新）→ 2 （确定下级数值确定有更新），同时也让会计师 C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 1（告知上级自己的值可能有更新）→ 2 （告知上级自己的值的确有更新）；表明探长 R1 和 会计师 C1 的稳态还未达成，需要 \x3cstrong\x3eStep 3\x3c\/strong\x3e 的执行去消除非稳态。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726497?w=1227\x26amp;h=379\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726497?w=1227\x26amp;h=379\x22 alt=\x22trackAndCompute\x22 title=\x22trackAndCompute\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 3\x3c\/strong\x3e：会计师的计算值 C1 更新完毕之后，探长才执行任务。通过 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L144\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etrackDerivedFunction\x3c\/a\x3e 方法的执行（即探长执行任务）后，会计师 C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 又从 2 → 0，同时也让探长 R1 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 从 2 → 0；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726498?w=853\x26amp;h=399\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726498?w=853\x26amp;h=399\x22 alt=\x22track\x22 title=\x22track\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e虽然这个示例中，状态的变更比上面的示例要复杂一些，不过我们依然可以从整体上感受到 \x3cstrong\x3e非稳态的上升\x3c\/strong\x3e 和 \x3cstrong\x3e削减\x3c\/strong\x3e 这两个阶段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的上升\x3c\/strong\x3e：外界更改 \x3ccode\x3ebankUser.income\x3c\/code\x3e 属性，触发 \x3ccode\x3epropagateChanged\x3c\/code\x3e 方法，从而让观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 以及会计师 C1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 都变成了 2 ，同时让会计师 C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 以及探长 R1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 都变成了 1 。这是系统趋向不稳定的表现。从 层级上来看，是\x3cstrong\x3e自下而上\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的削减\x3c\/strong\x3e：随着变更的传递，有两次削减非稳态的手段： ① 让会计师 C1 重新计算； ② 让探长执行任务。这两个阶段结束之后，所有成员的属性都下降为 0，表示系统又重新回到稳定状态。从 层级上来看，是\x3cstrong\x3e自上而下\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e2.3、有两个会计师的情况\x3c\/h3\x3e\n\x3cp\x3e我们继续在上一个示例上修改，再新增一个计算值 \x3ccode\x3eindication\x3c\/code\x3e（这个变量的创建没有特殊的含义，纯粹是为了做演示），由会计师 C2 了负责其进行计算。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var bankUser = mobx.observable({\n  income: 3,\n  debit: 2\n});\n\nvar divisor = mobx.computed(() =\x3e {\n  return bankUser.income \/ bankUser.debit;\n});\n\nvar indication = mobx.computed(() =\x3e {\n  return divisor \/ (bankUser.income \x2b 1);\n});\n\nmobx.autorun(() =\x3e {\n  console.log(\x27张三的 indication\x27, indication);\n});\n\nbankUser.debit = 4;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bankUser = mobx.observable({\n  \x3cspan class=\x22hljs-attr\x22\x3eincome\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edebit\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e divisor = mobx.computed(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bankUser.income \/ bankUser.debit;\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e indication = mobx.computed(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e divisor \/ (bankUser.income \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n});\n\nmobx.autorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27张三的 indication\x27\x3c\/span\x3e, indication);\n});\n\nbankUser.debit = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大体成员和之前的示例相差不大，只是这次我们修改 \x3ccode\x3ebankUser.debit\x3c\/code\x3e 变量（前面两个示例都是修改 \x3ccode\x3ebankUser.income\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cp\x3e这么做的目的是为了营造出下述的 \x3cstrong\x3e响应链\x3c\/strong\x3e 结构，我们通过修改 \x3ccode\x3ebankUser.debit\x3c\/code\x3e 变量，从而影响 会计师 C1，继而影响 会计师 C2，最终让探长 R1 执行任务。 \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726499?w=365\x26amp;h=305\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726499?w=365\x26amp;h=305\x22 alt=\x22two compute\x22 title=\x22two compute\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e同样的，我们从代码层面上来列出该 响应链 上的关键函数执行顺序，比上两个示例都复杂些，大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(O2) reportChange \n    -\x3e (O2) propagateChanged\n      -\x3e (C1) propagateMaybeChanged\n      -\x3e (C2) propagateMaybeChanged\n      -\x3e (R1) onBecomeStale（这里并不会让探长 `runReaction`）\n-\x3e (O2) endBatch\n    -\x3e (R1) runReaction（到这里才让探长执行 `runReaction`）\n      -\x3e (R1) shouldCompute\n         -\x3e (C2) shouldCompute\n           -\x3e (C1) shouldCompute\n           -\x3e (C1) trackAndCompute\n           -\x3e (C1) propagateChangeConfirmed\n         -\x3e (C2) trackAndCompute\n         -\x3e (C2) propagateChangeConfirmed\n      -\x3e trackDerivedFunction\n         -\x3e fn(即执行 autorun 中的回调) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e(O2) reportChange \n    -\x26gt; (O2) propagateChanged\n      -\x26gt; (C1) propagateMaybeChanged\n      -\x26gt; (C2) propagateMaybeChanged\n      -\x26gt; (R1) onBecomeStale（这里并不会让探长 \x3cspan class=\x22hljs-string\x22\x3e`runReaction`\x3c\/span\x3e）\n-\x26gt; (O2) endBatch\n    -\x26gt; (R1) runReaction（到这里才让探长执行 \x3cspan class=\x22hljs-string\x22\x3e`runReaction`\x3c\/span\x3e）\n      -\x26gt; (R1) shouldCompute\n         -\x26gt; (C2) shouldCompute\n           -\x26gt; (C1) shouldCompute\n           -\x26gt; (C1) trackAndCompute\n           -\x26gt; (C1) propagateChangeConfirmed\n         -\x26gt; (C2) trackAndCompute\n         -\x26gt; (C2) propagateChangeConfirmed\n      -\x26gt; trackDerivedFunction\n         -\x26gt; fn(即执行 autorun 中的回调) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eStep 1\x3c\/strong\x3e：在 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.0\/src\/core\/observable.ts#L197\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateChanged\x3c\/a\x3e 方法执行时，让观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 0 → 2 ，按照上述的调整原则，其直接上级 C1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 必须要高于观察员 O1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e，所以其值也只能用从 0 → 2；\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e该期间还涉及到会计师 C1、C2 的状态更改\x3c\/strong\x3e，具体表现就是调用 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/observable.ts#L238\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropagateMaybeChanged\x3c\/a\x3e ，在该方法执行后让会计师 C1、C2 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 从 0 → 1 ，他们各自的直接上级 C2、 R1 的 \x3cstrong\x3eD属性\x3c\/strong\x3e 值也从 0 → 1；\x3c\/p\x3e\n\x3cp\x3e描述起来比较复杂，其实无非就是多了一个 会计师 C2 的 \x3ccode\x3epropagateMaybeChanged\x3c\/code\x3e 方法过程，一图胜千言：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726500?w=1420\x26amp;h=316\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726500?w=1420\x26amp;h=316\x22 alt=\x22c2 upstream\x22 title=\x22c2 upstream\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 2\x3c\/strong\x3e：此步骤是以 \x3cstrong\x3e会计师\x3c\/strong\x3e 状态变更为中心演变过程，该步骤是上一个示例中 \x3cstrong\x3eStep 2\x3c\/strong\x3e 的“复数”版，多个人参与就复杂些，不过条理还是清晰明了的。上个示例中只有一个会计师，所以 \x3cstrong\x3etrackAndCompute -\x26gt;propagateChangeConfirmed\x3c\/strong\x3e 的过程只有一次，而这里有两个会计师，所以这个过程就有两次（下图中两个蓝框）；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726501?w=1847\x26amp;h=378\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726501?w=1847\x26amp;h=378\x22 alt=\x22c2 compute\x22 title=\x22c2 compute\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e经过该步骤之后会计师 O2、C1 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 又从 2 → 0，同时也让C1、C2 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 从 2 → 0；这个过程表明观察员 O1 和 会计师 C1 的计算值已经更新，达到稳态。\x3c\/p\x3e\n\x3cp\x3e而 C2 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 、探长 R1 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 又从 0 → 2，表明探长 R1 和 会计师 C2 的稳态还未达成，需要 \x3cstrong\x3eStep 3\x3c\/strong\x3e 的执行去消除非稳态。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStep 3\x3c\/strong\x3e：探长执行任务，通过 \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx\/blob\/4.1.1\/src\/core\/derivation.ts#L144\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etrackDerivedFunction\x3c\/a\x3e 方法的执行（即探长执行任务）后，会计师 C2 的 \x3cstrong\x3eL 属性\x3c\/strong\x3e 又从 2 → 0，同时也让探长 R1 的 \x3cstrong\x3eD 属性\x3c\/strong\x3e 从 2 → 0；这一步和上个示例中的 \x3cstrong\x3eStep 3\x3c\/strong\x3e 几乎相同。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726502?w=670\x26amp;h=321\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726502?w=670\x26amp;h=321\x22 alt=\x22c2 track\x22 title=\x22c2 track\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在这个示例中，状态的变更纵使比上面的示例要复杂得多，但我们还是很清晰地从整体上感受到 \x3cstrong\x3e非稳态的上升\x3c\/strong\x3e 和 \x3cstrong\x3e削减\x3c\/strong\x3e 这两个阶段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的上升\x3c\/strong\x3e：外界更改 \x3ccode\x3ebankUser.debit\x3c\/code\x3e 属性，触发 \x3ccode\x3epropagateChanged\x3c\/code\x3e 方法，从而让观察员 O1 开始，依次影响 会计师 C1、C2，以及探长 R1 的 \x3cstrong\x3eL、D 属性\x3c\/strong\x3e从 0 变成 1 或者 2，这是系统趋向不稳定的表现。从 层级上来看，是\x3cstrong\x3e自下而上\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e非稳态的削减\x3c\/strong\x3e：随着变更的传递，有两次削减非稳态的手段： ① 让会计师 C1 、C2 重新计算； ② 让探长 R1 执行任务。这两个阶段结束之后，所有成员的属性都下降为 0，表示系统又重新回到稳定状态。从 层级上来看，是\x3cstrong\x3e自上而下\x3c\/strong\x3e的过程。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2.4、一点点总结\x3c\/h3\x3e\n\x3cp\x3e通过上面三个从简单逐步到复杂的示例，我们简单总结归纳一下 MobX 在处理状态变更过程中所采取执行机制以及其背后的调整策略：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e先是自下而上传递非稳态\x3c\/strong\x3e：这是一个自下而上的过程，由观察员发起这个过程，在这个过程中依次将外界的变更层层向上传递，改变每个相关成员的 \x3cstrong\x3eL、D属性\x3c\/strong\x3e。 这个期间会拒绝一切成员任务执行的申请（比如探长执行任务、会计师执行计算任务等等）。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e其次自上而下消解非稳态\x3c\/strong\x3e：这是一个自上而下的过程。当非稳态到达顶层后，由顶层人员（一般是探长类）开始做决策执行任务，在执行任务中凡是遇到有非稳态的成员（比如会计师、观察员），责令他们更新状态，消除非稳态，逐层逐层地消除非稳态。等整个任务执行完之后，每个成员都处于稳态状态，开始下一个变更的到来。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e3、状态图\x3c\/h2\x3e\n\x3cp\x3e在软件设计中，为了更好地显示这种状态变更和事件之间的关系，常常使用 \x3cstrong\x3e状态图\x3c\/strong\x3e 来展现（没错，就是 UML建模中的那个状态图）\x3c\/p\x3e\n\x3cblockquote\x3e如果不太熟悉，这里给个参考文章 \x3ca href=\x22http:\/\/www.cnblogs.com\/ywqu\/archive\/2009\/12\/17\/1626043.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUML建模之状态图（Statechart Diagram）\x3c\/a\x3e 方便查阅。\x3c\/blockquote\x3e\n\x3cp\x3e挨个总结上述 3 个案例中 \x3cstrong\x3eL、D属性\x3c\/strong\x3e，我们将其中的事件和属性改变抽离出来，就能获取状态图了，方便我们从另外一个角度理解和体会。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e3.1、L 属性\x3c\/h3\x3e\n\x3cp\x3eObservable（观察员）、ComputeValue（会计师）这两种类型拥有 \x3cstrong\x3eL 属性\x3c\/strong\x3e ：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726503?w=1376\x26amp;h=624\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726503?w=1376\x26amp;h=624\x22 alt=\x22L attr\x22 title=\x22L attr\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e3.2、D 属性\x3c\/h3\x3e\n\x3cp\x3eReaction（探长）、ComputeValue（会计师）这两种类型拥有 \x3cstrong\x3eD 属性\x3c\/strong\x3e：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014726504?w=1297\x26amp;h=608\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014726504?w=1297\x26amp;h=608\x22 alt=\x22D attr\x22 title=\x22D attr\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e所以，会计师同时拥有 \x3cstrong\x3eL属性\x3c\/strong\x3e 和 \x3cstrong\x3eD 属性\x3c\/strong\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e4、小测试\x3c\/h2\x3e\n\x3cp\x3e如果我们将 \x3cstrong\x3e2.3、有两个会计师的情况\x3c\/strong\x3e 示例中的 \x3ccode\x3ebankUser.debit = 4;\x3c\/code\x3e 修改成 \x3ccode\x3ebankUser.income = 6;\x3c\/code\x3e 的话，那各个成员对象的 \x3cstrong\x3eD 属性\x3c\/strong\x3e、\x3cstrong\x3eL 属性\x3c\/strong\x3e 的变化情况又是怎么样的？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e5、本文总结\x3c\/h2\x3e\n\x3cp\x3e如何在复杂的场景下兼顾计算性能？\x3c\/p\x3e\n\x3cp\x3eMobX 提供了 \x3ccode\x3eshouldCompute\x3c\/code\x3e 方法用于直接判断是否执行计算（或任务），判断的依据非常简单，只要根据对象的 \x3ccode\x3edependenciesState\x3c\/code\x3e 属性是否为 \x3ccode\x3etrue\x3c\/code\x3e 就能直接作出判断。\x3c\/p\x3e\n\x3cp\x3e而其背后的支持则是 \x3ccode\x3edependenciesState\x3c\/code\x3e 属性（上文中的 \x3cstrong\x3eD 属性\x3c\/strong\x3e）和 \x3ccode\x3elowestObserverState\x3c\/code\x3e （上文中的 \x3cstrong\x3eL 属性\x3c\/strong\x3e），这两个属性依托 MobX 中自动化机制在适当时机（搭”顺风车“）进行变更。因此，\x3cstrong\x3e无论多么复杂的场景下 MobX 能以低廉的成本兼顾性能方面的治理，充分运用惰性求值思想减少计算开销\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e初看 MobX 源码，它往往给你一种 ”杂项丛生“的感觉（调试这段代码的时候真是心里苦啊），但其实在这背后运转着一套清晰的 \x3cstrong\x3e非稳态传递\x3c\/strong\x3e 和 \x3cstrong\x3e非稳态削减\x3c\/strong\x3e 的固定模式，一旦掌握这套模式之后，MobX 自动化响应体系的脉络已清晰可见，这将为你更好理解 MobX 的运行机制打下扎实的基础。\x3c\/p\x3e\n\x3cp\x3e到本篇为止，我们已经耗费 3 篇文章来解释 MobX 的（绝大部分）自动化响应机制。经过这 3 篇文章，读者应该对 MobX 的整个运转机制有了一个比较清晰明了的理解。后续的文章中将逐渐缩减”故事“成分，将讲解重心转移到 MobX 本身概念（比如 \x3ccode\x3eObservable\x3c\/code\x3e、\x3ccode\x3edecorator\x3c\/code\x3e、\x3ccode\x3eAtom\x3c\/code\x3e等）源码的解读上，相信有了这三篇文章的作为打底，理解其余部分更多的是在语法层面，阅读起来将更加游刃有余。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【用故事解读 MobX源码（三）】 shouldCompute</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014726483">https://segmentfault.com/a/1190000014726483</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/m2901nt2uq/" target="_blank">https://alili.tech/archive/m2901nt2uq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>