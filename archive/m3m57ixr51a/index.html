<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入解析js中的函数"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入解析js中的函数 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/m3m57ixr51a/",
				"appid": "1613049289050283", 
				"title": "深入解析js中的函数 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-18T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ryfouggec39/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/pp0s0b5egqc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&text=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&text=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fm3m57ixr51a%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90js%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入解析js中的函数</h1><div class="meta"><div class="postdate"><time datetime="2018-12-18" itemprop="datePublished">2018-12-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h1\x3e\n\x3cp\x3e由于词语匮乏，本文继续沿用\x22深入解析xxx\x22这个俗套的命名，但是是真的很深入(你要信我啊)。如果本文对你有用，欢迎收藏，如果喜欢我的文章，欢迎点赞和关注专栏。\x3cbr\x3e函数可以说是js的基础，无处不在，功能又十分强大，本文将简单介绍函数的特点并且重点介绍各种各样的用法。废话不多说，开车~\x3cbr\x3e\x3cem\x3e友情提示，由于本文涵盖的内容比较全面，不免篇幅稍长，中途请注意休息。\x3c\/em\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e函数简介\x3c\/h1\x3e\n\x3cp\x3e但是其实，函数的本质就是\x3cstrong\x3e对象\x3c\/strong\x3e。确切一点来说，其实是第一类对象(first-class object)。关于第一类对象，wiki解释如下：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e第一类对象又称第一类公民，在编程语言中指的是一个具有以下特性的实体：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e能够作为参数被传递\x3c\/li\x3e\n\x3cli\x3e能够从一个函数结果中返回\x3c\/li\x3e\n\x3cli\x3e能够被修改和赋值给变量\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e虽然看起来高大上，但是我们只要先记住，\x3cstrong\x3e在js里函数也是对象，可以拥有自己的属性和方法，而它和一般js对象的区别是：可以被调用，也就是可执行\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e当然，函数还有一个明显的特点就是，提供\x3cstrong\x3e作用域\x3c\/strong\x3e：在函数作用域内的变量都是局部变量，对外部不可见。由于js中其他代码块，比如\x3ccode\x3efor\x3c\/code\x3e和\x3ccode\x3ewhile\x3c\/code\x3e循环等并不提供作用域，所以有很多地方会利用函数来控制作用域。在后面会一一提到。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e预备知识\x3c\/h1\x3e\n\x3cp\x3e这一块在之前讲闭包的时候其实提到了一些，但是还是简单介绍下。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e函数作用域\x3c\/h2\x3e\n\x3cp\x3e在类似C语言的编程语言中，花括号\x3ccode\x3e{}\x3c\/code\x3e表示一个作用域：在作用域内的变量对外不可见，这个称为\x3ccode\x3e块级作用域\x3c\/code\x3e,但是在js中没有块级作用域，只有函数作用域:\x3cstrong\x3e在函数体内声明的变量，在整个函数体内有定义\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun(){\n    for(var j =1;j\x3c10;j\x2b\x2b){\n        \n    }\n    console.log(j)\/\/10\n}\nconsole.log(j)\/\/undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j =\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;j\x26lt;\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;j\x2b\x2b){\n        \n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(j)\x3cspan class=\x22hljs-comment\x22\x3e\/\/10\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(j)\x3cspan class=\x22hljs-comment\x22\x3e\/\/undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中变量\x3ccode\x3ej\x3c\/code\x3e定义在函数体中，那么在函数体内可以访问，在外部则无法访问。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e作用域链\x3c\/h2\x3e\n\x3cp\x3e作用域链，就是一个类似链表的解构，它表示\x3cstrong\x3e当前代码有权访问的作用域的访问顺序\x3c\/strong\x3e。举个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = 1;\nfunction fun(){\n    var a = 2\n    console.log(a)\n}\nfun()\/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\nfunction \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    console.log(a)\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这里，执行\x3ccode\x3efun()\x3c\/code\x3e时，作用域链上有2个作用域，第一个是\x3ccode\x3efun\x3c\/code\x3e，第二个是全局环境，按照顺序，首先访问内容的作用域，找到了\x3ccode\x3ea\x3c\/code\x3e变量，那么就不继续寻找，如果这里没有\x3ccode\x3evar a = 2\x3c\/code\x3e，那么会继续向外寻找，最终输出的就是\x3ccode\x3e1\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e只要记住，作用域链都是\x3cstrong\x3e从当前函数作用域向外\x3c\/strong\x3e一层层延伸的，所以内部作用域可以访问外部变量，反之则不行。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e声明提升\x3c\/h2\x3e\n\x3cp\x3e看下这个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun(){\n    console.log(a)\n    var a = 1;\n}\nfun();\/\/underfined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crystal\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-title\x22\x3econsole\x3c\/span\x3e\x3c\/span\x3e.log(a)\n    var a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e();\x3cspan class=\x22hljs-title\x22\x3e\/\x3c\/span\x3e\x3c\/span\x3e\/underfined\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是觉得很奇怪，这里既没有未定义报错，也没有输出1，因为这里的代码其实相当于这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun(){\n    var a;\n    console.log(a)\n    a = 1;\n}\nfun();\/\/underfined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crystal\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e\x3c\/span\x3e a;\n    console.log(a)\n    a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e();\x3cspan class=\x22hljs-title\x22\x3e\/\x3c\/span\x3e\x3c\/span\x3e\/underfined\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，其实变量\x3ccode\x3ea\x3c\/code\x3e的声明，相当于\x3cstrong\x3e被提前到当前函数作用域的顶部\x3c\/strong\x3e，这就是所谓的\x3cstrong\x3e声明提升\x3c\/strong\x3e，但是要注意，声明虽然提升了，赋值\x3ccode\x3ea=1\x3c\/code\x3e并没有被提升，否则这个例子应该直接输出\x3ccode\x3e1\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e接下来再举1个例子回顾下这一阶段的知识：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = 1;\nvar b = 4;\nfunction fun (){\n    console.log(a);\n    var a = 2;\n    var b = 3;\n    console.log(b);\n}\nfun ();\nconsole.log(b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\nfunction \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    console.log(a);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n    console.log(b);\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\nconsole.log(b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e具体结果大家可以跑跑看。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e函数的创建\x3c\/h1\x3e\n\x3cp\x3e通常来说，有2种创建函数的方式：函数表达式、函数声明。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e函数表达式\x3c\/h2\x3e\n\x3cp\x3e函数表达式通常具有如下形式:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var funA = function funName(param1,param2){\n    \/\/函数体\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e funA = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunName\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(param1,param2)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数体\x3c\/span\x3e\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然，更常见来说这里的\x3ccode\x3efunName\x3c\/code\x3e是不写的，写与不写的区别是，在不同浏览器中，获得的函数对象中\x3ccode\x3ename\x3c\/code\x3e属性的值会被处理成不行的形式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/这个例子可以在ie firefox webkit内核的浏览器分别跑一下看看结果 \nvar fun1 = function(){}\nvar fun2 = function funName(){}\nconsole.log(fun1)\nconsole.log(fun2)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这个例子可以在ie firefox webkit内核的浏览器分别跑一下看看结果 \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun1 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunName\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(fun1)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(fun2)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e写函数名字有个比较好用的地方是在递归的时候，可以很方便使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/阶乘函数\nvar fun1 = function recu(x){\n    if(x\x3c=1)\n        return 1;\n    else\n        return x*recu(x-1)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/阶乘函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun1 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erecu\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(x)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(x\x26lt;=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x*recu(x\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e函数声明\x3c\/h2\x3e\n\x3cp\x3e函数声明形式一般如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function funName(){\n    \/\/函数体\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunName\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数体\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个和函数表达式的区别就是，使用函数声明的方式在js里会有\x22提升\x22，而使用表达式方式写没有提升所以函数表达式定义的函数无法提前使用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fun1();\/\/fun1\nfun2();\/\/报错\nfunction fun1 (){\n    console.log(\x26quot;fun1\x26quot;)\n}\nvar fun2 = function(){\n     console.log(\x26quot;fun2\x26quot;)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3efun1();\x3cspan class=\x22hljs-comment\x22\x3e\/\/fun1\x3c\/span\x3e\nfun2();\x3cspan class=\x22hljs-comment\x22\x3e\/\/报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22fun1\x22\x3c\/span\x3e)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22fun2\x22\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为前面说过，\x3cstrong\x3e赋值部分不会提升\x3c\/strong\x3e，而函数表达式的写法本质上也是一个变量声明和赋值,形如\x3ccode\x3evar x = function...\x3c\/code\x3e，\x3ccode\x3ex\x3c\/code\x3e的声明被提升，但是右边的赋值部分要等待代码执行到这句的时候才生效。\x3c\/p\x3e\n\x3cp\x3e举个更容易理解的例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(fun2)\/\/underfined\nfun2();\/\/报错\nvar fun2 = function(){\n     console.log(\x26quot;fun2\x26quot;)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(fun2)\x3cspan class=\x22hljs-comment\x22\x3e\/\/underfined\x3c\/span\x3e\nfun2();\x3cspan class=\x22hljs-comment\x22\x3e\/\/报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22fun2\x22\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同理，变量\x3ccode\x3efun2\x3c\/code\x3e已声明，但未赋值。所以这里\x3ccode\x3econsole.log\x3c\/code\x3e的时候不报错，运行的时候才报错。看不懂请再回顾下预备知识的\x3ccode\x3e声明提升\x3c\/code\x3e部分。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e函数参数\x3c\/h1\x3e\n\x3cp\x3e函数的参数一般分成形参和实参，\x3cstrong\x3e形参是函数定义时预期传入的参数，实参是函数调用时实际传入参数。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e参数数量不对等情况和\x3ccode\x3earguments\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript没有在函数调用时对实参做任何检查。\x3c\/strong\x3e 所以可能出现以下情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e当传入的实参比形参个数要少的时候，剩下的形参会被自动设置为\x3ccode\x3eunderfined\x3c\/code\x3e\x3c\/strong\x3e，所以在写函数的时候，我们经常要注意是否\x3cstrong\x3e要给参数一些默认值\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun(a){\n    var a = a || \x26quot;\x26quot; \/\/如果传入a就使用a,否则a设置为空字符串\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = a || \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果传入a就使用a,否则a设置为空字符串\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们的函数使用了可选参数，那么可选参数的位置必须放在最后，否则，使用者调用时候，就要显式传入\x3ccode\x3eunderfind\x3c\/code\x3e，比如\x3ccode\x3efun(underfined,a)\x3c\/code\x3e表示第一个参数不传入。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e当传入的实参比形参个数要多的时候，我们可以通过标识符\x3ccode\x3earguments\x3c\/code\x3e对象来获得参数\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function fun(a){ if(arguments.length\x3e1)console.log(arguments[1])};\n    var a=1,b=2;\n    fun(a,b);\/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e])};\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,b=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n    fun(a,b);\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中，通过\x3ccode\x3earguments\x3c\/code\x3e输出了实参\x3ccode\x3eb\x3c\/code\x3e的值。值得一提的是，\x3cstrong\x3e\x3ccode\x3earguments\x3c\/code\x3e并不是数组，而是一个对象，只是恰好使用数字为索引\x3c\/strong\x3e\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e\n\x3ccode\x3ecallee\x3c\/code\x3e 和 \x3ccode\x3ecaller\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3ees5的非严格模式下，我们可以使用\x3ccode\x3ecallee\x3c\/code\x3e 和 \x3ccode\x3ecaller\x3c\/code\x3e这两个属性，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ecallee\x3c\/code\x3e 表示当前正在执行的函数，通常用法是在匿名函数中写递归调用\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecaller\x3c\/code\x3e 表示调用当前正在执行函数的函数，可以用来访问调用栈，这个属性是非标准的，但是大部分的浏览器都实现。更详细的用法可以查看MDN。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader12\x22\x3e函数的模式\x3c\/h1\x3e\n\x3cp\x3e模式其实就是函数的各种应用方式，也是本文的重点\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3eapi模式\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eapi\x3c\/code\x3e模式主要是给函数提供更好的接口。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e回调模式\x3c\/h3\x3e\n\x3cp\x3e最前面已经提到，函数是对象，并且可以被作为参数传递给其他的函数。\x3c\/p\x3e\n\x3cp\x3e当我们把函数A传递给函数B，并且让B能够在某一时刻执行A，这种情况我们称\x3ccode\x3e函数A\x3c\/code\x3e是回调函数(\x3ccode\x3ecallback function\x3c\/code\x3e)，简称回调。\x3c\/p\x3e\n\x3cp\x3e举个例子，假设这样一个背景：假设现在我们需要处理一批dom节点，处理大概分2步，第一步，筛选出符合要求的一部分节点，第二步，对这部分数据做一些css样式修改。那我们一般会先想到这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/筛选函数\nfunction filterNodes(nodes){\n    var  i = 0;\n    var result = [];\n    for(i = 0; i\x3cnodes.length;i\x2b\x2b){\n        \/\/根据条件筛选\n        if(...){\n            result.push()\n        }\n    }\n    return result\n}\n\n\/\/操作函数\nfunction operte(nodes){\n    var  i = 0;\n    for(i = 0; i\x3cnode.length;i\x2b\x2b){\n        \/\/ 样式操作\n        node[i].style...\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/筛选函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efilterNodes\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(nodes)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;nodes.length;i\x2b\x2b){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据条件筛选\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(...){\n            result.push()\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/操作函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperte\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(nodes)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;node.length;i\x2b\x2b){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 样式操作\x3c\/span\x3e\n        node[i].style...\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按照上面定义的2个函数，先用\x3ccode\x3efilterNodes\x3c\/code\x3e筛选符合要求额节点，然后将结果作为\x3ccode\x3eoperate\x3c\/code\x3e函数的参数，这样逻辑上是完全没问题的，只是有一个地方：\x3cstrong\x3e其实我们已经2次遍历了符合要求的节点：第一次是在筛选时，第二次是在样式操作时。这里有办法优化吗？\x3c\/strong\x3e，如果我们直接把样式操作直接写到\x3ccode\x3eresult.push()\x3c\/code\x3e后面，是可以减少一次遍历的，但是这样\x3ccode\x3efilterNodes\x3c\/code\x3e函数就不是一个纯粹的筛选节点的数了。所以我们可以使用回调模式来解决，只需稍微修改下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/筛选函数\nfunction filterNodes(nodes,callback){\n    var  i = 0;\n    var result = [];\n    for(i = 0; i\x3cnodes.length;i\x2b\x2b){\n        \/\/根据条件筛选\n        if(...){\n            result.push()\n            \n            \/\/在这里判断是否传递了样式操作函数，如果有，就执行样式操作\n            if(callback){\n                callback(nodes[i])\n            }\n        }\n    }\n    return result\n}\n\nfunction operte(node){\n    \/\/这里就不必再次循环了\n    \/\/ 样式操作\n    node[i].style...\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/筛选函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efilterNodes\x3c\/span\x3e\x3c\/span\x3e(nodes,\x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;nodes.length;i\x2b\x2b){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据条件筛选\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(...){\n            result.push()\n            \n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/在这里判断是否传递了样式操作函数，如果有，就执行样式操作\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e){\n                \x3cspan class=\x22hljs-keyword\x22\x3ecallback\x3c\/span\x3e(nodes[i])\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperte\x3c\/span\x3e\x3c\/span\x3e(node){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里就不必再次循环了\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 样式操作\x3c\/span\x3e\n    node[i].style...\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样改造之后，2个函数依然各自拥有自己的逻辑，而且我们可以通过调用\x3ccode\x3efilterNodes\x3c\/code\x3e时，传递不同参数的办法，来控制我们想要的功能。\x3c\/p\x3e\n\x3cp\x3e回调函数还有很多的常见用途：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e异步事件监听\x3cbr\x3e最常见的例子莫过于我们为文档添加监听事件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 document.addEventListener(\x26quot;click\x26quot;,[回调函数],false)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e,[回调函数],\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了回调模式以后，程序可以以异步的模式运行：只有用户触发了某些交互行为，才会调用到我们指定的函数。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e超时方法 \x3ccode\x3esetTimeout()\x3c\/code\x3e和 \x3ccode\x3esetTimeInterval()\x3c\/code\x3e\x3cbr\x3e这两个函数也一样接受回调函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout([回调函数],200)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3esetTimeout\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e([回调函数],\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e软件库设计\x3cbr\x3e设计一个库的时候，很重要的就是设计通用性和复用性的代码，因为无法提前预测到需要的每一个功能，而且用户也不会总是需要用到所有的功能，利用回调模式，很容易设计出\x3cstrong\x3e具有核心功能有同时提供自选项的函数\x3c\/strong\x3e(比如前面提到的节点筛选函数，核心功能是筛选，又能根据需要插入后续操作)。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e返回函数\x3c\/h3\x3e\n\x3cp\x3e刚刚在回调函数部分，说的是函数作为另一个函数的参数传递，接下来说说函数作为另一边函数的结果返回。看下面一个计时器例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var counter = function(){\n    var count = 0;\n    return function(){\n        return count\x2b\x2b\n    }\n}\nvar f = counter();\nf();\/\/1\nf();\/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e count\x2b\x2b\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f = counter();\nf();\x3cspan class=\x22hljs-comment\x22\x3e\/\/1\x3c\/span\x3e\nf();\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实这里就是一个闭包的实例，关于闭包，在我的另一篇文章里有更详细的描述\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007376061\x22\x3e点击前往\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e配置对象\x3c\/h3\x3e\n\x3cp\x3e配置对象模式其实就是让用对象作为函数的参数。\x3cbr\x3e这种模式经常用在建立一个库，或者写的函数要提供给外部调用时。因为它能提供很简洁的接口。假设这样一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function operate(para1,para2){}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(para1,para2)\x3c\/span\x3e\x3c\/span\x3e{}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们正在写一个库函数，一开始我们预料到的参数只会有\x3ccode\x3epara1\x3c\/code\x3e,\x3ccode\x3epara2\x3c\/code\x3e，但是随着不断拓展，后来参数变多了，而且出现了一些可选参数\x3ccode\x3epara3,para4\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function operate(para1,para2,para3,para4...)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lua\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(para1,para2,para3,para4...)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时我们需要很小心的把可选参数放在后面，使用者在调用的时候还必须很小心的对上位置，比如说：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22operate(p1,p2,null,p4)\/\/这里的null不可省略\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eoperate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(p1,p2,null,p4)\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里的null不可省略\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时，参数数量太多，使用起来需要很小心记住参数顺序，很不方便。所以就要采用配置对象的写法，即把参数写成一个对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function operate(config){}\nvar conf = {\n    para1:...,\n    para2:...,\n    para4:..., \n}\n operate(con)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(config)\x3c\/span\x3e\x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e conf = {\n    para1:...,\n    para2:...,\n    para4:..., \n}\n operate(con)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的写法\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e优点是：使用者不需要记住参数顺序，代码也显得更简洁，\x3c\/li\x3e\n\x3cli\x3e缺点是：使用时要严格记住参数的名称，并且属性名称无法被压缩\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通常在操作\x3ccode\x3edom\x3c\/code\x3e对象的\x3ccode\x3ecss\x3c\/code\x3e样式时候会用这样的写法，因为\x3ccode\x3ecss\x3c\/code\x3e样式有很多，但是名称很容易记住,比如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var style ={\n    color:\x26quot;...\x26quot;\n    border:\x26quot;...\x26quot;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e ={\n    \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22...\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eborder\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22...\x22\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e柯里化\x3c\/h3\x3e\n\x3cp\x3e\x3cem\x3estart18\/08\/08编辑\x3c\/em\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e柯里化内容已添加，\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000015929416\x22 target=\x22_blank\x22\x3e传送门\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cem\x3eend18\/08\/08编辑\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e柯里化的内容比较长，难度也稍大，后续另开一篇来写吧~~。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e初始化模式\x3c\/h2\x3e\n\x3cp\x3e初始化模式的主要作用是不污染全局命名空间，使用临时变量来完成初始化任务，使任务更加简洁\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e即时函数\x3c\/h3\x3e\n\x3cblockquote\x3e即时函数模式（immeddiate Function pattern），是一种支持在定义函数后立即执行该函数的语法。也叫作自调用和自执行函数\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(){\n    \/\/函数内容\n}())\n\/\/也可以这样写\n(function(){\n    \/\/函数内容\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数内容\x3c\/span\x3e\n}())\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/也可以这样写\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数内容\x3c\/span\x3e\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里给出了即时函数的两种写法，它的作用是可以给初始化的代码提供一个存放的空间：比如在页面初始化时，\x3cstrong\x3e需要一些临时变量来完成一次初始化，但是这些工作只需要执行一次，执行之后就不再需要这些临时变量\x3c\/strong\x3e，那么我们就不必浪费全局变量来创建这些变量，此时使用即时函数，可以把所有代码打包起来，并且不会泄露到全局作用域。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(){\n    var initName = \x26quot;\x26quot;\n    alert(initName)\n}());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clojure\x22\x3e\x3ccode\x3e(\x3cspan class=\x22hljs-name\x22\x3efunction\x3c\/span\x3e(){\n    var initName = \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e\n    alert(\x3cspan class=\x22hljs-name\x22\x3einitName\x3c\/span\x3e)\n}())\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然，即时函数也可以传递参数，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(initName){\n    alert(initName)\n}(\x26quot;hello\x26quot;));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clojure\x22\x3e\x3ccode\x3e(\x3cspan class=\x22hljs-name\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-name\x22\x3einitName\x3c\/span\x3e){\n    alert(\x3cspan class=\x22hljs-name\x22\x3einitName\x3c\/span\x3e)\n}(\x3cspan class=\x22hljs-string\x22\x3e\x22hello\x22\x3c\/span\x3e))\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样也可以有返回值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = (function(){\n  return 1\n}());\nconsole.log(result)\/\/1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs oxygene\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eresult\x3c\/span\x3e = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e{\n  return 1\n}\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e);\x3c\/span\x3e\nconsole.log(\x3cspan class=\x22hljs-keyword\x22\x3eresult\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e即时函数经常用在写一些自包含模块，这样的好处是可以确保页面在有无该模块的情况下都能良好运行，很方便的可以分离出来，用于测试或者实现，或者根据需要实现“禁用”功能。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/moudle1.js\n(function(){\n    \/\/模块代码\n}\/\/)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/moudle1.js\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/模块代码\x3c\/span\x3e\n}\x3cspan class=\x22hljs-comment\x22\x3e\/\/)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按照这一的形式写模块。可以根据需要加载模块。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3e即时对象初始化\x3c\/h3\x3e\n\x3cp\x3e这个模式和即使函数模式很相似，区别在于我们的函数写在一个对象的方法上。通常我们在一个对象上写上\x3ccode\x3einit\x3c\/code\x3e方法，并且在创建对象之后立即执行该方法。如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22({\n    \/\/初始化的属性和配置\n    name:\x27Mike\x27,\n    age:\x2712\x27,\n    \/\/其他方法\n    ...\n    \/\/初始化\n    init:function(){\n        ...\n    }\n}).init();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e({\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化的属性和配置\x3c\/span\x3e\n    name:\x3cspan class=\x22hljs-string\x22\x3e\x27Mike\x27\x3c\/span\x3e,\n    age:\x3cspan class=\x22hljs-string\x22\x3e\x2712\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/其他方法\x3c\/span\x3e\n    ...\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化\x3c\/span\x3e\n    init:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        ...\n    }\n}).init();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个语法其实相当于在创建一个普通的对象并且，然后在创建之后立刻调用\x3ccode\x3einit\x3c\/code\x3e方法。这种做法和即时函数的目的是一致的：\x3cstrong\x3e在执行一次性初始化任务时保护全局命名空间\x3c\/strong\x3e。但是可以写出更加复杂的结构，比如私有方法等，而在即时函数里面只能把所有的方法都写成函数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e初始化时分支\x3c\/h3\x3e\n\x3cp\x3e初始化时分支经常用在某个生命周期中做一次性测试的情境中。所谓的一次性测试就是：在本次生命周期中，某些属性不可能改变，比如浏览器内核等。典型的例子是\x3cstrong\x3e浏览器嗅探\x3c\/strong\x3e.\x3c\/p\x3e\n\x3cp\x3e看过\x3ccode\x3ejavacscript\x3c\/code\x3e高级程序设计的话，对这个例子一定很眼熟：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var utils = {\n        addListener:function(el,type,fn){\n            if(typeof window.addEvenrtListener === \x27function\x27){\n                el.addEventerListener(type,fn,false);\n            }\n            else if(typeof window.attachEvent === \x27function\x27){\n                \/\/ie\n                el.attachEvent(\x27on\x27 \x2b type,fn)\n            }\n            else{\n                \/\/其他浏览器\n                 el.[\x27on\x27\x2b type] = fn\n            }\n        }\n        ...\/\/删除方法类似\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e utils = {\n        addListener:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel,\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e,fn\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEvenrtListener === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n                el.addEventerListener(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e,fn,\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.attachEvent === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ie\x3c\/span\x3e\n                el.attachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e,fn)\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/其他浏览器\x3c\/span\x3e\n                 el.[\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e\x2b \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e] = fn\n            }\n        }\n        ...\x3cspan class=\x22hljs-comment\x22\x3e\/\/删除方法类似\x3c\/span\x3e\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子是为了写一个能够支持跨浏览器处理事件的方法，但是有个缺点：每次在处理事件时都要检测一次浏览器的类型。我们知道，\x3cstrong\x3e其实在一次页面的生命周期里，其实只需要检测一次就够了\x3c\/strong\x3e，所以可以利用初始化分支来这样改写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var utils = {\n    addListener:null\n}\nif(typeof window.addEvenrtListener === \x27function\x27){\n    utils.addListener = function(el,type,fn){\n        el.addEventerListener(type,fn,false);   \n    }\n}\nelse if(typeof window.attachEvent === \x27function\x27){\n    \/\/ie\n    utils.addListener = function(el,type,fn){\n        el.attachEvent(\x27on\x27 \x2b type,fn)\n    }\n}\nelse{\n    \/\/其他浏览器\n     utils.addListener = function(el,type,fn){\n        el.[\x27on\x27\x2b type] = fn\n     }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e utils = {\n    \x3cspan class=\x22hljs-attr\x22\x3eaddListener\x3c\/span\x3e:\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEvenrtListener === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n    utils.addListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel,type,fn\x3c\/span\x3e)\x3c\/span\x3e{\n        el.addEventerListener(type,fn,\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);   \n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.attachEvent === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ie\x3c\/span\x3e\n    utils.addListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel,type,fn\x3c\/span\x3e)\x3c\/span\x3e{\n        el.attachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b type,fn)\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/其他浏览器\x3c\/span\x3e\n     utils.addListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel,type,fn\x3c\/span\x3e)\x3c\/span\x3e{\n        el.[\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e\x2b type] = fn\n     }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的话就可以在加载时完成一次嗅探。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader22\x22\x3e性能模式\x3c\/h2\x3e\n\x3cp\x3e性能模式，主要是在某些情况下加快代码的运行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3e备忘模式\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e备忘模式的核心是使用函数属性，缓存能计算结果。以便后续调用时可以不必重新计算。\x3c\/strong\x3e\x3cbr\x3e这么做的基础主要是之前提到过的，函数本质还是对象（这句话已经重复n次了），既然是对象自然可以拥有属性和方法，例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fun = function(key){\n    if(!fun.cache[key]){\n        \/\/不存在对应缓存，那么计算\n        var result = {}\n        ...\/\/计算过程\n        fun.cache[key] = result\n    }\n    return fun.cache[key] \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(key)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e.cache[key]){\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/不存在对应缓存，那么计算\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = {}\n        ...\x3cspan class=\x22hljs-comment\x22\x3e\/\/计算过程\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e.cache[key] = result\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e.cache[key] \x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里举了一个比较简单的例子，在获取对应数据的时候，先判断有无缓存，有的话直接获取；没有的话计算一次并缓存到对应位置。之后便无需重复计算。\x3c\/p\x3e\n\x3cp\x3e当然，这里的\x3ccode\x3ekey\x3c\/code\x3e我们假设是基本类型的值，如果是复杂类型的值，需要先序列化。\x3cbr\x3e另外，在函数内的\x3ccode\x3efun\x3c\/code\x3e可以通过前面提到的\x3ccode\x3earguments.callee\x3c\/code\x3e来代替，只要不在es5的严格模式下就行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3e自定义模式\x3c\/h3\x3e\n\x3cp\x3e自定义函数的原理很简单：\x3cstrong\x3e首先创建一个函数并保存到一个变量\x3ccode\x3ef\x3c\/code\x3e。然后在创建一个新函数，也保存在这个变量\x3ccode\x3ef\x3c\/code\x3e，那么\x3ccode\x3ef\x3c\/code\x3e最终指向的应该是新的函数。那么如果我们让这个过程发生在旧的函数内部，那么就实现了惰性函数\x3c\/strong\x3e。话不多说，看例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fun = function(){\n  console.log(\x26quot;在这里执行一些初始化工作\x26quot;)\n  fun = function(){\n       console.log(\x26quot;在这里执行正常工作时需要执行的工作\x26quot;)\n  }\n}\nfun();\/\/在这里执行一些初始化工作\nfun();\/\/在这里执行正常工作时需要执行的工作\nfun();\/\/在这里执行正常工作时需要执行的工作\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22在这里执行一些初始化工作\x22\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n       console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22在这里执行正常工作时需要执行的工作\x22\x3c\/span\x3e)\n  }\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/在这里执行一些初始化工作\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/在这里执行正常工作时需要执行的工作\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/在这里执行正常工作时需要执行的工作\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这里我们执行了一次初始化任务以后，函数就变成了正常的函数，之后的执行就可以减少工作。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader25\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3e这是2018年写的第一篇长文（其实一共就写了2篇，哈哈哈）希望今年自己可以好好努力，把“深入”系列贯彻到底。也希望大家都有所进步。\x3cbr\x3e然后依然是每次都一样的结尾，如果内容有错误的地方欢迎指出；如果对你有帮助，欢迎点赞和收藏，转载请征得同意后著明出处，如果有问题也欢迎私信交流，主页添加了邮箱地址~溜了\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入解析js中的函数</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012802855">https://segmentfault.com/a/1190000012802855</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/m3m57ixr51a/" target="_blank">https://alili.tech/archive/m3m57ixr51a/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>