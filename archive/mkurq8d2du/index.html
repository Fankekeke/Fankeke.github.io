<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue-cli#4.7项目结构分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue-cli#4.7项目结构分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mkurq8d2du/",
				"appid": "1613049289050283", 
				"title": "vue-cli#4.7项目结构分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-01T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bmsz1r08vwf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4hmemfodt0k/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&text=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&text=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&title=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&is_video=false&description=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&title=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&title=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&title=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmkurq8d2du%2f&title=vue-cli%234.7%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue-cli#4.7项目结构分析</h1><div class="meta"><div class="postdate"><time datetime="2018-12-01" itemprop="datePublished">2018-12-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3\x3e前言\x3c\/h3\x3e\n\x3cp\x3e使用过 vue 进行项目开发的同学，一定知道或者使用过 vue-cli 脚手架，他能够很好的搭建项目结构和工程，让我们能够把足够的精力放在业务开发上。也正是因为这样，很多时候我们会因为项目工期短等原因来不及或则不会刻意去了解项目工程配置，我们今天不去介绍脚手架的使用，我们去了解下脚手架为我们创建好的打包工程是怎么做的。\x3c\/p\x3e\n\x3ch3\x3e项目结构\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3e\x3c\/code\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e    ├── build --------------------------------- webpack相关配置文件\n    │   ├── build.js --------------------------webpack打包配置文件\n    │   ├── check-versions.js ------------------------------ 检查npm,nodejs版本\n    │   ├── logo.png ---------------------------------- 项目 logo\n    │   ├── utils.js --------------------------------------- 配置资源路径，配置css加载器\n    │   ├── vue-loader.conf.js ----------------------------- 配置css加载器等\n    │   ├── webpack.base.conf.js --------------------------- webpack基本配置\n    │   ├── webpack.dev.conf.js ---------------------------- 用于开发的webpack设置\n    │   ├── webpack.prod.conf.js --------------------------- 用于打包的webpack设置\n    ├── config ---------------------------------- 配置文件\n           ├── index.js ------------------------------ 开发和生产环境配置文件\n    ├── node_modules ---------------------------- 存放依赖的目录\n    ├── src ------------------------------------- 源码\n    │   ├── assets ------------------------------ 静态文件\n    │   ├── components -------------------------- 组件\n    │   ├── main.js ----------------------------- 主js\n    │   ├── App.vue ----------------------------- 项目入口组件\n    │   ├── router ------------------------------ 路由\n    ├── package.json ---------------------------- node配置文件\n    ├── .babelrc--------------------------------- babel配置文件\n    ├── .editorconfig---------------------------- 编辑器配置\n    ├── .gitignore------------------------------- 配置git可忽略的文件\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3c\/p\x3e\n\x3ch3\x3ewebpack配置划重点\x3c\/h3\x3e\n\x3cblockquote\x3e在看项目配置文件之前，我们先了解下 webpack 几个常用的工具和插件，如果你已经十分熟悉，你可以跳过这一小节，直接去看，配置文件解析\x3c\/blockquote\x3e\n\x3ch4\x3e1. path模块\x3c\/h4\x3e\n\x3cp\x3epath 是 node.js 中的一个模块，用于处理目录的对象，提高开发效\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e常用方法：\npath.join(): 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix 系统是 ”\/“，Windows系统是 ”\\“\npath.resolve() 用于将相对路径转为绝对路径\n\n常使用的文件路径\n__dirname: 总是返回被执行的 js 所在文件夹的绝对路径\n__filename: 总是返回被执行的 js 的绝对路径\nprocess.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2.process\x3c\/h4\x3e\n\x3cp\x3eprocess对象是Node的一个全局对象，提供当前Node进程的信息。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eprocess 对象提供一系列属性，用于返回系统信息\nprocess.argv：返回当前进程的命令行参数数组。\nprocess.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME\nprocess.pid：当前进程的进程号\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e3.Source map\x3c\/h4\x3e\n\x3cp\x3e简单说，\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2013\/01\/javascript_source_map.html\x22 rel=\x22nofollow noreferrer\x22\x3eSource map\x3c\/a\x3e就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，debug 工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。\x3ca href=\x22https:\/\/juejin.im\/post\/58293502a0bb9f005767ba2f\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack 的 devtool里有 7种 SourceMap 模式\x3c\/a\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e模式\x3c\/th\x3e\n\x3cth\x3e解释\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eeval\x3c\/td\x3e\n\x3ctd\x3e每个 module 会封装到 eval 里包裹起来执行，并且会在末尾追加注释 \/\/@ sourceURL\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3esource-map\x3c\/td\x3e\n\x3ctd\x3e生成一个 SourceMap 文件.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ehidden-source-map\x3c\/td\x3e\n\x3ctd\x3e和 source-map 一样，但不会在 bundle 末尾追加注释.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3einline-source-map\x3c\/td\x3e\n\x3ctd\x3e生成一个 DataUrl 形式的 SourceMap 文件.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eeval-source-map\x3c\/td\x3e\n\x3ctd\x3e每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3echeap-source-map\x3c\/td\x3e\n\x3ctd\x3e生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3echeap-module-source-map\x3c\/td\x3e\n\x3ctd\x3e生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch4\x3e4. webpack-merge\x3c\/h4\x3e\n\x3cp\x3e开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。通用的配置部分，我们抽象出一个公共文件，通过 \x3ca href=\x22https:\/\/doc.webpack-china.org\/guides\/production\/\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack-merge\x3c\/a\x3e 工具的“通用”配置，我们不必在环境特定的配置中重复代码。\x3c\/p\x3e\n\x3ch4\x3e5. ExtractTextWebpackPlugin\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/plugins\/extract-text-webpack-plugin\/\x22 rel=\x22nofollow noreferrer\x22\x3eExtractTextWebpackPlugin\x3c\/a\x3e 插件通常用来做样式文件的分离，被分离的文件不会被内嵌到  JS bundle 中，而会被放到一个单独的文件中，在样式文件比较大的时候，能够提前样式的加载,配置示例如下\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3econst ExtractTextPlugin = require(\x22extract-text-webpack-plugin\x22);\nmodule.exports = {\n   module: {\n      rules: [\n      {\n         test: \/\\.css$\/,\n         use: ExtractTextPlugin.extract({\n         fallback: \x22style-loader\x22,\n         use: \x22css-loader\x22\n      })\n   }]\n},\n    plugins: [\n        new ExtractTextPlugin(\x22styles.css\x22),\n    ]\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。\x3c\/p\x3e\n\x3ch4\x3e6.html-webpack-plugin\x3c\/h4\x3e\n\x3cp\x3e如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。如果你有任何 CSS assets 在 webpack 的输出中（例如， 利用ExtractTextPlugin提取CSS）， 那么这些将被包含在HTML head中的\x26lt;link\x26gt;标签内。通常在开发中，我们为了避免 CDN 和浏览器的缓存通常会个输出文件 bundle.js 加上一个hash 值例如 \x3ccode\x3e[hash].bundle.js\x3c\/code\x3e，使用 \x3ca href=\x22https:\/\/doc.webpack-china.org\/plugins\/html-webpack-plugin\/\x22 rel=\x22nofollow noreferrer\x22\x3ehtml-webpack-plugin\x3c\/a\x3e 能够在创建新的 html 文件的时候将我们把带有哈希值的 bundle.js 引用到 html 文件.\x3c\/p\x3e\n\x3ch4\x3e7.optimize-css-assets-webpack-plugin\x3c\/h4\x3e\n\x3cp\x3e用来优化从脚本里提炼出来的 css ，配置示例如下\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3evar OptimizeCssAssetsPlugin = require(\x27optimize-css-assets-webpack-plugin\x27);\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.css$\/,\n        loader: ExtractTextPlugin.extract(\x27style-loader\x27, \x27css-loader\x27)\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin(\x27styles.css\x27),\n    new OptimizeCssAssetsPlugin({\n      assetNameRegExp: \/\\.optimize\\.css$\/g,\n      cssProcessor: require(\x27cssnano\x27),\n      cssProcessorOptions: { discardComments: { removeAll: true } },\n      canPrint: true\n    })\n  ]\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e8.CopyWebpackPlugin\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/plugins\/copy-webpack-plugin\/\x22 rel=\x22nofollow noreferrer\x22\x3eCopyWebpackPlugin\x3c\/a\x3e从插件名称上我们不难看出他的作用，通常用来拷贝资源，对项目文件进行归类整合\x3c\/p\x3e\n\x3ch4\x3e9.friendly-errors-webpack-plugin\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/www.npmjs.com\/package\/friendly-errors-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22\x3efriendly-errors-webpack-plugin\x3c\/a\x3e能够更好在终端看到webapck运行的警告和错误，提高开发体验\x3c\/p\x3e\n\x3ch4\x3e10.UglifyjsWebpackPlugin\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/plugins\/uglifyjs-webpack-plugin\/\x22 rel=\x22nofollow noreferrer\x22\x3eUglifyjsWebpackPlugin\x3c\/a\x3e用来压缩 js 代码\x3c\/p\x3e\n\x3ch4\x3e11.开发中 Server(DevServer)\x3c\/h4\x3e\n\x3cp\x3ewebpack 项目服务，我们通常会在开发阶段用来配置项目的热刷新，服务压缩，项目代理等，常用的几个配置参数介绍如下\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3econst config = require(\x27..\/config\x27)\n\n\/\/ config 文件里做了用户自定的服务参数配置\n\ndevServer: {\n    clientLogLevel: \x27warning\x27,  \/\/ 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 \x22none\x22 来进行关闭\n     historyApiFallback: { \/\/ 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html\n        rewrites: [\n           { from: \/.*\/, to: path.posix.join(config.dev.assetsPublicPath, \x27index.html\x27) },\n        ],\n     },\n     hot: true,   \/\/启用项目的热刷新，即模块热替换特性\n     contentBase: false,   \/\/ 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用\n     compress: true,\n     host: HOST || config.dev.host,   \/\/指定使用一个域名。默认是 localhost\n     port: PORT || config.dev.port,   \/\/指定要监听请求的端口号：\n     open: config.dev.autoOpenBrowser, \/\/open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器\n     overlay: config.dev.errorOverlay   \/\/当有错误或则警告的时候在页面上显示一个全屏的遮罩提示\n         ? { warnings: false, errors: true }\n         : false,\n     publicPath: config.dev.assetsPublicPath, \/\/此路径下的打包文件可在浏览器中访问\n     proxy: config.dev.proxyTable,           \/\/代理API的请求\n     quiet: true,       \/\/启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候\n     watchOptions: {   \/\/与监视文件相关的控制选项。是否使用轮询\n           poll: config.dev.poll,\n     }\n},\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e配置文件解析\x3c\/h3\x3e\n\x3cblockquote\x3e通过了解了上面的配置，我们应该对 webpack 的常用插件和工具有了一定了解，我们来看下 vue-cli 脚手架给我们生成的配置情况\x3c\/blockquote\x3e\n\x3ch4\x3econfig.js\x3c\/h4\x3e\n\x3cp\x3e\x27use strict\x27\x3c\/p\x3e\n\x3cp\x3econst path = require(\x27path\x27) \/\/ 引用项目的 path 模块\x3c\/p\x3e\n\x3cp\x3emodule.exports = {\x3cbr\x3e  dev: {\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ 路径配置\nassetsSubDirectory: \x27static\x27,\nassetsPublicPath: \x27\/\x27,\nproxyTable: {},\n\n\/\/ 各种开发服务配置\nhost: \x27localhost\x27, \/\/ 开发环境域名 可以被 node 全局变量process.env.HOST 重写\nport: 8080, \/\/配置开发服务端口，可以被 node 全局变量 process.env.PORT 重写, 需要使用未被占用的端口\nautoOpenBrowser: false, \/\/服务启动是否自动代开浏览器\nerrorOverlay: true,   \/\/是否在发生错误的时候，在页面整屏增加一个错误遮罩\nnotifyOnErrors: true,  \/\/是否通知错误 ，在我们的项目配置中和 friendly-errors-webpack-plugin 结合使用\npoll: false, \/\/ 服务监听是否轮询操作\n\n\/\/ 配饰是否使用 Eslint Loader 进行语法检测\n\/\/ 如果使用，在开发构建阶段，会对你的代码会进行检测\n\/\/ 检测出来的警告和错误会白展示在开发工具的控制台\n\nuseEslint: true,  \/\/进行语法检测\n\n\/\/ 配置是否将 eslint 语法检测的警告和错误展示在页面整屏的遮罩上\n\nshowEslintErrorsInOverlay: false,  \/\/ 语法检测的警告和错误不展示在遮罩上\n\n\/**\n * Source Maps\n *\/\n\n\/\/ https:\/\/webpack.js.org\/configuration\/devtool\/#development\n\/\/ 在上面的介绍中，我们知道 source map 是用来将我们构建后被转化的代码对应构建前的代码，便于 debug\n\/\/ cheap-module-eval-source-map 和我们介绍的 cheap-module-source-map 很类似，但是 SourceMap 会被作为数据添加到包中\ndevtool: \x27cheap-module-eval-source-map\x27,\n\n\/\/ 如果你的开发工具不能进行 vue-files 的 debug ，可以将以下设置设置成 false\n\ncacheBusting: true,\n\ncssSourceMap: true\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e},\x3c\/p\x3e\n\x3cp\x3ebuild: {\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/ index.html 文件模板\nindex: path.resolve(__dirname, \x27..\/dist\/index.html\x27),\n\n\/\/ 打包路径配置\nassetsRoot: path.resolve(__dirname, \x27..\/dist\x27),\nassetsSubDirectory: \x27static\x27,\nassetsPublicPath: \x27\/\x27,\n\n\/**\n * Source Maps\n *\/\n\n\/\/生产环境 source map 配置\n\nproductionSourceMap: true,\ndevtool: \x27#source-map\x27,\n\n\/\/ 因为很多的主流服务都会 通过 gzip 压缩过你的所有静态资源，我们的配置默认不开启 gzip\n\/\/ 如果要设置成开启,请先确保已经安装好 compression-webpack-plugin 插件\nproductionGzip: false,\nproductionGzipExtensions: [\x27js\x27, \x27css\x27],\n\n\/\/ 启动 build 命令的时候，额外添加一个参数，打包后会自动生成一个分析报告文件，例如 npm run build --report ，可以通过配置 true ，false 来关闭\nbundleAnalyzerReport: process.env.npm_config_report\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e}\x3c\/p\x3e\n\x3ch4\x3echeck-versions.js\x3c\/h4\x3e\n\x3cp\x3e这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\x27use strict\x27\nconst chalk = require(\x27chalk\x27)  \/\/ 改变命令行中的字体颜色，大致这样用chalk.blue(\x27Hello world\x27)\nconst semver = require(\x27semver\x27)  \/\/是用来对特定的版本号做判断的\n\nconst packageConfig = require(\x27..\/package.json\x27)  \/\/ 项目 npm 配置文件，获取依赖及版本信息，requrie返回的就是json对象\nconst shell = require(\x27shelljs\x27) \/\/用来执行Unix系统命令，调用系统命令更加方便\n\n\/\/把cmd这个参数传递的值转化成前后没有空格的字符串，也就是版本号\nfunction exec (cmd) {\n  return require(\x27child_process\x27).execSync(cmd).toString().trim()\n}\n\n\nconst versionRequirements = [\n  {\n    name: \x27node\x27,\n    currentVersion: semver.clean(process.version),  \/\/ 提取进程版本信息转化成规定格式，也就是 \x27  =v1.2.3  \x27 -\x26gt; \x271.2.3\x27 这种功能\n    versionRequirement: packageConfig.engines.node \/\/ package.json 的 node 的版本信息\n  }\n]\n\nif (shell.which(\x27npm\x27)) {\n  versionRequirements.push({\n    name: \x27npm\x27,\n    currentVersion: exec(\x27npm --version\x27),   \/\/当前的版本信息\n    versionRequirement: packageConfig.engines.npm \/\/package.json 的 node 的版本信息\n  })\n}\n\nmodule.exports = function () {\n  const warnings = []\n\n  for (let i = 0; i \x26lt; versionRequirements.length; i\x2b\x2b) {\n    const mod = versionRequirements[i]\n\n    \/\/ 如果当前版本号不符合 package.json 要求的版本号，红色表示当前版本信息，绿色表示要求的版本信息，添加到 warnings 待输出\n    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {\n      warnings.push(mod.name \x2b \x27: \x27 \x2b\n        chalk.red(mod.currentVersion) \x2b \x27 should be \x27 \x2b\n        chalk.green(mod.versionRequirement)\n      )\n    }\n  }\n\n  \/\/输出版本号不相符的提示 warnings\n  if (warnings.length) {\n    console.log(\x27\x27)\n    console.log(chalk.yellow(\x27To use this template, you must update following to modules:\x27))\n    console.log()\n\n    for (let i = 0; i \x26lt; warnings.length; i\x2b\x2b) {\n      const warning = warnings[i]\n      console.log(\x27  \x27 \x2b warning)\n    }\n\n    console.log()\n    process.exit(1)\n  }\n}\n\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ebuild.js\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode\x3e\x27use strict\x27\n\n\/\/打包前判断当先开发环境的 node 和 npm 版本和 package.json 要求的时候一样\nrequire(\x27.\/check-versions\x27)()\n\nprocess.env.NODE_ENV = \x27production\x27\n\nconst ora = require(\x27ora\x27)  \/\/ 在用户打包的时候能够让用户知道正在进行，一个加载中的样式，转啊转\nconst rm = require(\x27rimraf\x27) \/\/这个模块是用来清除之前的打的包，因为在vue-cli中每次打包会生成不同的hash\nconst path = require(\x27path\x27) \/\/node 路径模块，便于我们操作文件路径\nconst chalk = require(\x27chalk\x27) \/\/带颜色的输出模块，能在控制台中输出不同的样色\nconst webpack = require(\x27webpack\x27) \/\/webpack 不解释\nconst config = require(\x27..\/config\x27) \/\/ 项目中的配置文件，👆上面已经进行了配置介绍\nconst webpackConfig = require(\x27.\/webpack.prod.conf\x27) \/\/ 生产环境的配置文件\n\n\nconst spinner = ora(\x27building for production...\x27)\/\/ 实例一个打包加载中实例\nspinner.start() \/\/开始转圈，营造一个正在打包的场景\n\n\/\/ 删除上一次打包的文件，删除成功，开始按照生产环境配置进行打包\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =\x26gt; {\n  if (err) throw err\n\n\n    \/\/开始打包，打包结束停止 spinner 转圈，有报错则在控制台输出\n  webpack(webpackConfig, (err, stats) =\x26gt; {\n    spinner.stop()\n    if (err) throw err\n\n    \/\/ node 环境里的输出配置，process.stdout.write 你可以理解成 js 里的 console\n    process.stdout.write(stats.toString({\n      colors: true, \/\/让打包的时候有颜色。\n      modules: false,  \/\/去掉内置模块信息\n      children: false, \/\/ 去掉子模块,如果你使用了 ts-loader，设置成 true 会在打包构建阶段展示错误信息\n      chunks: false, \/\/ 增加包信息（设置为 false 能允许较少的冗长输出）\n      chunkModules: false \/\/去除包里内置模块的信息\n    }) \x2b \x27\\n\\n\x27)\n\n\n     \/\/打包出错在控制台输出 Build failed with errors ，退出打包程序\n    if (stats.hasErrors()) {\n      console.log(chalk.red(\x27  Build failed with errors.\\n\x27))\n      process.exit(1)\n    }\n\n    \/\/打包成功则输出 Build complete 结束打包\n    console.log(chalk.cyan(\x27  Build complete.\\n\x27))\n    console.log(chalk.yellow(\n      \x27  Tip: built files are meant to be served over an HTTP server.\\n\x27 \x2b\n      \x27  Opening index.html over file:\/\/ won\\\x27t work.\\n\x27\n    ))\n  })\n})\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ewebpack.base.conf.js\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode\x3e\x27use strict\x27\nconst path = require(\x27path\x27)  \/\/ node 路径模块\nconst utils = require(\x27.\/utils\x27) \/\/node 内部常用的工具类，其中包括：格式化字符串、对象的序列化、实现对象继承等常用方法\nconst config = require(\x27..\/config\x27) \/\/👆上面我们介绍的，项目配置文件\nconst vueLoaderConfig = require(\x27.\/vue-loader.conf\x27) \/\/👆 上面我们介绍的 vue 加载器配置文件\n\n\/\/返回当前配置文件位置是 build ，该方法放回 build\/..\/dir 的相对路基\nfunction resolve (dir) {\n  return path.join(__dirname, \x27..\x27, dir)\n}\n\n\/\/ eslint 语法检测配置\nconst createLintingRule = () =\x26gt; ({\n  test: \/\\.(js|vue)$\/,\n  loader: \x27eslint-loader\x27,\n  enforce: \x27pre\x27,\n  include: [resolve(\x27src\x27), resolve(\x27test\x27)],\n  options: {\n    formatter: require(\x27eslint-friendly-formatter\x27),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})\n\n\/\/ webpack 通用配置内容\nmodule.exports = {\n  context: path.resolve(__dirname, \x27..\/\x27),  \/\/ 上下文，基础目录，用于从配置中解析入口起点和 loader\n  entry: {\n    app: \x27.\/src\/main.js\x27  \/\/起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。如果传递一个数组，那么数组的每一项都会执行。\n  },\n  output: {\n    path: config.build.assetsRoot,   \/\/输出 bundle 的路径\n    filename: \x27[name].js\x27,          \/\/输出 bundle 的名称\n    publicPath: process.env.NODE_ENV === \x27production\x27 \/\/ 指定资源文件引用的目录，例如图片\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: [\x27.js\x27, \x27.vue\x27, \x27.json\x27], \/\/配置模块如何解析,\n    alias: {                              \/\/ 创建应用的别名，\n      \x27vue$\x27: \x27vue\/dist\/vue.esm.js\x27,\n      \x27@\x27: resolve(\x27src\x27),\n    }\n  },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emodule: {\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3erules: [\n  \/\/判断配置中是否要是用 eslint 语法检测，如果使用，就将 createLintingRule 配置对象返回\n  ...(config.dev.useEslint ? [createLintingRule()] : []),\n\n \/\/👇是一些比较常用的加载器，及配置，不做详细介绍了\n  {\n    test: \/\\.vue$\/,\n    loader: \x27vue-loader\x27,\n    options: vueLoaderConfig\n  },\n  {\n    test: \/\\.js$\/,\n    loader: \x27babel-loader\x27,\n    include: [resolve(\x27src\x27), resolve(\x27test\x27), resolve(\x27node_modules\/webpack-dev-server\/client\x27)]\n  },\n  {\n    test: \/\\.(css | scss)$\/,\n    loader: \x27style-loader!css-loader!!sass-loader\x27\n  },\n  {\n    test: \/\\.(png|jpe?g|gif|svg)(\\?.*)?$\/,\n    loader: \x27url-loader\x27,\n    options: {\n      limit: 10000,\n      name: utils.assetsPath(\x27img\/[name].[hash:7].[ext]\x27)\n    }\n  },\n  {\n    test: \/\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$\/,\n    loader: \x27url-loader\x27,\n    options: {\n      limit: 10000,\n      name: utils.assetsPath(\x27media\/[name].[hash:7].[ext]\x27)\n    }\n  },\n  {\n    test: \/\\.(woff2?|eot|ttf|otf)(\\?.*)?$\/,\n    loader: \x27url-loader\x27,\n    options: {\n      limit: 10000,\n      name: utils.assetsPath(\x27fonts\/[name].[hash:7].[ext]\x27)\n    }\n  }\n]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e},\x3cbr\x3e  node: {\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e\/\/防止因为 vue 资源本身就自带的 无用的 node 注入，浏览器兼容处理\nsetImmediate: false,\ndgram: \x27empty\x27,\nfs: \x27empty\x27,\nnet: \x27empty\x27,\ntls: \x27empty\x27,\nchild_process: \x27empty\x27\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e}\x3c\/p\x3e\n\x3ch4\x3ewebpack.dev.conf.js\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode\x3e\x27use strict\x27\nconst utils = require(\x27.\/utils\x27)  \/\/node 工具模块\nconst webpack = require(\x27webpack\x27) \/\/webpack 不解释\nconst config = require(\x27..\/config\x27)\/\/👆提到的配置文件\nconst merge = require(\x27webpack-merge\x27) \/\/ merge 工具，用来合并生产和开发环境通用的基础 webpack 配置\nconst path = require(\x27path\x27)            \/\/node 的路径模块\nconst baseWebpackConfig = require(\x27.\/webpack.base.conf\x27) \/\/生产和开发环境通用的基础 webpack 配置\nconst CopyWebpackPlugin = require(\x27copy-webpack-plugin\x27) \/\/拷贝插件\nconst HtmlWebpackPlugin = require(\x27html-webpack-plugin\x27)  \/\/动态生成 html 插件\nconst FriendlyErrorsPlugin = require(\x27friendly-errors-webpack-plugin\x27) \/\/友好的错误输出插件\nconst portfinder = require(\x27portfinder\x27) \/\/能够获取一个可用的随机端口号\n\nconst HOST = process.env.HOST   \/\/node 全局环境变量的主机\nconst PORT = process.env.PORT \x26amp;\x26amp; Number(process.env.PORT)   \/\/node 全局环境变量的端口\n\n\/\/合并基础配置加载器的配置部分\nconst devWebpackConfig = merge(baseWebpackConfig, {\n\n  module: {\n    \/\/ 为 .vue 文件意外的独立样式文件配置加载器\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n\n  \/\/ cheap-module-eval-source-map 在开发环境中很快\n  devtool: config.dev.devtool,\n\n  \/\/ 开发服务配置，👆 已经细讲过，顺便回顾一下\n  devServer: {\n     clientLogLevel: \x27warning\x27,  \/\/ 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 \x22none\x22 来进行关闭\n     historyApiFallback: { \/\/ 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html\n        rewrites: [\n           { from: \/.*\/, to: path.posix.join(config.dev.assetsPublicPath, \x27index.html\x27) },\n        ],\n     },\n     hot: true,   \/\/启用项目的热刷新，即模块热替换特性\n     contentBase: false,   \/\/ 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用\n     compress: true,\n     host: HOST || config.dev.host,   \/\/指定使用一个域名。默认是 localhost\n     port: PORT || config.dev.port,   \/\/指定要监听请求的端口号：\n     open: config.dev.autoOpenBrowser, \/\/open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器\n     overlay: config.dev.errorOverlay   \/\/当有错误或则警告的时候在页面上显示一个全屏的遮罩提示\n           ? { warnings: false, errors: true }\n           : false,\n     publicPath: config.dev.assetsPublicPath, \/\/此路径下的打包文件可在浏览器中访问\n     proxy: config.dev.proxyTable,           \/\/代理API的请求\n     quiet: true,       \/\/启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候\n     watchOptions: {   \/\/与监视文件相关的控制选项。是否使用轮询\n           poll: config.dev.poll,\n     }\n   },\n\n  plugins: [\n    \/\/ DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用\n    new webpack.DefinePlugin({\n      \x27process.env\x27: require(\x27..\/config\/dev.env\x27)\n    }),\n    new webpack.HotModuleReplacementPlugin(), \/\/启用热替换模块(Hot Module Replacement)，也被称为 HMR\n    new webpack.NamedModulesPlugin(), \/\/ 当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境\n    new webpack.NoEmitOnErrorsPlugin(), 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段\n\n    \/\/HtmlWebpackPlugin简化了HTML文件的创建，以便为你的webpack包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用\n    new HtmlWebpackPlugin({\n      filename: \x27index.html\x27,\n      template: \x27index.html\x27,\n      inject: true\n    }),\n\n\n    \/\/ 拷贝自定义的静态资源文件\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, \x27..\/static\x27),\n        to: config.dev.assetsSubDirectory,\n        ignore: [\x27.*\x27]\n      }\n    ])\n  ]\n})\n\n\/\/ 实例一个异步对象，执行 devWebpackConfig 配置编译\nmodule.exports = new Promise((resolve, reject) =\x26gt; {\n  portfinder.basePort = process.env.PORT || config.dev.port  \/\/设置基础端口\n  portfinder.getPort((err, port) =\x26gt; {获取端口，输出构建新\n    if (err) {\n      reject(err)\n    } else {\n      \/\/ 如果进行 e2e 测试，需要发布新端口\n      process.env.PORT = port\n\n      \/\/ 更新 devServer 的端口\n      devWebpackConfig.devServer.port = port\n\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http:\/\/${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n       \/\/执行打包配置文件\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ewebpack.prod.conf.js\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode\x3e\x27use strict\x27\nconst path = require(\x27path\x27) \/\/ node 路径模块\nconst utils = require(\x27.\/utils\x27) \/\/小工具函数\nconst webpack = require(\x27webpack\x27) \/\/ webpack 不解释\nconst config = require(\x27..\/config\x27)\/\/👆提到的配置文件\nconst merge = require(\x27webpack-merge\x27) \/\/ merge 工具，用来合并生产和开发环境通用的基础 webpack 配置\nconst baseWebpackConfig = require(\x27.\/webpack.base.conf\x27)\/\/产和开发环境通用的基础 webpack 配置\nconst CopyWebpackPlugin = require(\x27copy-webpack-plugin\x27) \/\/拷贝插件\nconst HtmlWebpackPlugin = require(\x27html-webpack-plugin\x27)  \/\/动态生成 html 插件\nconst ExtractTextPlugin = require(\x27extract-text-webpack-plugin\x27)\/\/用来做文件分离的插件\nconst OptimizeCSSPlugin = require(\x27optimize-css-assets-webpack-plugin\x27)\/\/优化提炼出来的css\nconst UglifyJsPlugin = require(\x27uglifyjs-webpack-plugin\x27)\/\/ 压缩 js 文件插件\n\n\/\/生产环境配置\nconst env = require(\x27..\/config\/prod.env\x27)\n\n\/\/合并基础配置加载器的配置部分\nconst webpackConfig = merge(baseWebpackConfig, {\n\/\/为独立分离出来的样式配置加载器和source，map\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  \/\/配置线上的 source map 便于排查问题\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  \/\/配置输出，路径，文件名\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath(\x27js\/[name].[chunkhash].js\x27),\n    chunkFilename: utils.assetsPath(\x27js\/[id].[chunkhash].js\x27)\n  },\n  plugins: [\n    \/\/ DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用\n    new webpack.DefinePlugin({\n      \x27process.env\x27: env\n    }),\n\n    \/\/ 使用 UglifyJsPlugin 插件对 js 进行压缩\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      \/\/配置插件的source map\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    \/\/ 提取 css 到单独的文件，分离文件异步加载，提高加载速度\n    new ExtractTextPlugin({\n      filename: utils.assetsPath(\x27css\/[name].[contenthash].css\x27),\n\n      \/\/如果把 allChunks 参数设置陈 false ，就不会把css 从代码块中分离出来\n      \/\/代码块加载的时候 css 会被 styles-loader 动态的加载\n      allChunks: true,\n    }),\n\n    \/\/使用这个插件，从不同的组件中复制脱离出来，进行 css 压缩\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n\n    \/\/自动生成 html 文件，通常 index.html 文件都会带一个哈希值来清除缓存\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: \x27index.html\x27,\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n      },\n\n      chunksSortMode: \x27dependency\x27\n    }),\n    \/\/该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 渲染模块没有变化的时候，id 不会变。\n    new webpack.HashedModuleIdsPlugin(),\n\n    \/\/ 提升或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。\n    new webpack.optimize.ModuleConcatenationPlugin(),\n\n    \/\/ 分离渲染的js 到独立的文件中\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \x27vendor\x27,\n      minChunks (module) {\n        \/\/被引用到的包会从 node_modules 中提取出来\n        return (\n          module.resource \x26amp;\x26amp;\n          \/\\.js$\/.test(module.resource) \x26amp;\x26amp;\n          module.resource.indexOf(\n            path.join(__dirname, \x27..\/node_modules\x27)\n          ) === 0\n        )\n      }\n    }),\n\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \x27manifest\x27,\n      minChunks: Infinity\n    }),\n\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \x27app\x27,\n      async: \x27vendor-async\x27,\n      children: true,\n      minChunks: 3\n    }),\n\n    \/\/ 拷贝自定义的静态资源文件\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, \x27..\/static\x27),\n        to: config.build.assetsSubDirectory,\n        ignore: [\x27.*\x27]\n      }\n    ])\n  ]\n})\n\n\/\/判断如果配置了生产环境压缩，是则使用插件进行压缩\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require(\x27compression-webpack-plugin\x27)\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: \x27[path].gz[query]\x27,\n      algorithm: \x27gzip\x27,\n      test: new RegExp(\n        \x27\\\\.(\x27 \x2b\n        config.build.productionGzipExtensions.join(\x27|\x27) \x2b\n        \x27)$\x27\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\n\/\/是否要生成代码打包分析报告\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require(\x27webpack-bundle-analyzer\x27).BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e扩展\x3c\/h3\x3e\n\x3cp\x3e👆这篇文章详细的介绍了脚手架项目的 webpack 配置，但是只是 webpack 的一部分，还有很多内容值得我们去探究，如果你还感兴趣，可以阅读下面这些文章。也欢迎随时与我进行交流，微信号：646321933\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/guides\/production\/\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack指南 \x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/concepts\/\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack文档\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/configuration\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack配置 \x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5a31d210f265da431a43330e\x22 rel=\x22nofollow noreferrer\x22\x3e自己动手实现一个脚手架\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/plugins\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack 官方插件集合介绍文档 \x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007441374\x22\x3e《 使用vue-cli脚手架创建新项目》\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue-cli#4.7项目结构分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014828384">https://segmentfault.com/a/1190000014828384</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mkurq8d2du/" target="_blank">https://alili.tech/archive/mkurq8d2du/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>