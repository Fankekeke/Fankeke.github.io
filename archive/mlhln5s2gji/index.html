<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JS 装饰器，一篇就够"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JS 装饰器，一篇就够 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mlhln5s2gji/",
				"appid": "1613049289050283", 
				"title": "JS 装饰器，一篇就够 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/gdz9n6ek1b/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/v3mziy8c4e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&text=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&text=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&title=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&is_video=false&description=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&title=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&title=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&title=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmlhln5s2gji%2f&title=JS%20%e8%a3%85%e9%a5%b0%e5%99%a8%ef%bc%8c%e4%b8%80%e7%af%87%e5%b0%b1%e5%a4%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JS 装饰器，一篇就够</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e更多文章，请在\x3ca href=\x22https:\/\/github.com\/Pines-Cheng\/blog\/issues\x22 rel=\x22nofollow noreferrer\x22\x3eGithub blog\x3c\/a\x3e查看\x3c\/blockquote\x3e\n\x3cp\x3e在 ES6 中增加了对类对象的相关定义和操作（比如 class 和 extends ），这就使得我们在多个不同类之间共享或者扩展一些方法或者行为的时候，变得并不是那么优雅。这个时候，我们就需要一种更优雅的方法来帮助我们完成这些事情。\x3c\/p\x3e\n\x3ch2\x3e什么是装饰器\x3c\/h2\x3e\n\x3ch3\x3ePython 的装饰器\x3c\/h3\x3e\n\x3cp\x3e在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。\x3c\/p\x3e\n\x3cp\x3e如果你熟悉 python 的话，对它一定不会陌生。那么我们先来看一下 python 里的装饰器是什么样子的吧：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22python\x22\x3edef decorator(f):\n    print \x22my decorator\x22\n    return f\n@decorator\ndef myfunc():\n    print \x22my function\x22\nmyfunc()\n# my decorator\n# my function\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的 @decorator 就是我们说的装饰器。在上面的代码中，我们利用装饰器给我们的目标方法执行前打印出了一行文本，并且并没有对原方法做任何的修改。代码基本等同于：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22python\x22\x3edef decorator(f):\n    def wrapper():\n        print \x22my decorator\x22\n        return f()\n    return wrapper\ndef myfunc():\n    print \x22my function\x22\nmyfunc = decorator(myfuc)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过代码我们也不难看出，装饰器 decorator 接收一个参数，也就是我们被装饰的目标方法，处理完扩展的内容以后再返回一个方法，供以后调用，同时也失去了对原方法对象的访问。当我们对某个应用了装饰以后，其实就改变了被装饰方法的入口引用，使其重新指向了装饰器返回的方法的入口点，从而来实现我们对原函数的扩展、修改等操作。\x3c\/p\x3e\n\x3ch3\x3eES7 的装饰器\x3c\/h3\x3e\n\x3cp\x3eES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 方法 。\x3c\/p\x3e\n\x3ch2\x3eObject.defineProperty\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eObject.defineProperty() \x3c\/code\x3e方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\x3c\/p\x3e\n\x3cp\x3e该方法允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（for...in 或 Object.keys 方法）， 这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用 \x3ccode\x3eObject.defineProperty()\x3c\/code\x3e 添加的属性值是不可变的。\x3c\/p\x3e\n\x3ch3\x3e语法\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eObject.defineProperty(obj, prop, descriptor)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eobj\x3c\/code\x3e：要在其上定义属性的对象。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eprop\x3c\/code\x3e：要定义或修改的属性的名称。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3edescriptor\x3c\/code\x3e：将被定义或修改的属性描述符。\x3c\/li\x3e\n\x3cli\x3e返回值：被传递给函数的对象。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在ES6中，由于 Symbol类型 的特殊性，用 Symbol类型 的值来做对象的key与常规的定义或修改不同，而\x3ccode\x3eObject.defineProperty\x3c\/code\x3e 是定义 key为 Symbol 的属性的方法之一。\x3c\/p\x3e\n\x3ch3\x3e属性描述符\x3c\/h3\x3e\n\x3cp\x3e对象里目前存在的属性描述符有两种主要形式：\x3cstrong\x3e数据描述符\x3c\/strong\x3e和\x3cstrong\x3e存取描述符\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e数据描述符\x3c\/strong\x3e是一个具有值的属性，该值可能是可写的，也可能不是可写的。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e存取描述符\x3c\/strong\x3e是由 getter-setter 函数对描述的属性。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e描述符必须是这两种形式之一；不能同时是两者。\x3c\/p\x3e\n\x3cp\x3e数据描述符和存取描述符均具有以下可选键值：\x3c\/p\x3e\n\x3ch4\x3econfigurable\x3c\/h4\x3e\n\x3cp\x3e当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。\x3c\/p\x3e\n\x3ch4\x3eenumerable\x3c\/h4\x3e\n\x3cp\x3eenumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。\x3c\/p\x3e\n\x3cp\x3e当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。\x3cbr\x3e数据描述符同时具有以下可选键值：\x3c\/p\x3e\n\x3ch4\x3evalue\x3c\/h4\x3e\n\x3cp\x3e该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。\x3c\/p\x3e\n\x3ch4\x3ewritable\x3c\/h4\x3e\n\x3cp\x3e当且仅当该属性的 writable 为 true 时，value 才能被赋值运算符改变。默认为 false。\x3c\/p\x3e\n\x3cp\x3e存取描述符同时具有以下可选键值：\x3c\/p\x3e\n\x3ch4\x3eget\x3c\/h4\x3e\n\x3cp\x3e一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。\x3c\/p\x3e\n\x3ch4\x3eset\x3c\/h4\x3e\n\x3cp\x3e一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。\x3c\/p\x3e\n\x3cblockquote\x3e如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。\x3c\/blockquote\x3e\n\x3ch2\x3e用法\x3c\/h2\x3e\n\x3ch3\x3e类的装饰\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e@testable\nclass MyTestableClass {\n  \/\/ ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable \/\/ true\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，\x3ccode\x3e@testable\x3c\/code\x3e 就是一个装饰器。它修改了 MyTestableClass这 个类的行为，为它加上了静态属性isTestable。testable 函数的参数 target 是 MyTestableClass 类本身。\x3c\/p\x3e\n\x3cp\x3e基本上，装饰器的行为就是下面这样。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e@decorator\nclass A {}\n\n\/\/ 等同于\n\nclass A {}\nA = decorator(A) || A;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说，\x3cstrong\x3e装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3efunction testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable \/\/ true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable \/\/ false\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，装饰器 testable 可以接受参数，这就等于可以修改装饰器的行为。\x3c\/p\x3e\n\x3cp\x3e注意，\x3cstrong\x3e装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时\x3c\/strong\x3e。这意味着，装饰器能在编译阶段运行代码。也就是说，\x3cstrong\x3e装饰器本质就是编译时执行的函数\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作。\x3c\/p\x3e\n\x3cp\x3e下面是另外一个例子。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\/\/ mixins.js\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list)\n  }\n}\n\n\/\/ main.js\nimport { mixins } from \x27.\/mixins\x27\n\nconst Foo = {\n  foo() { console.log(\x27foo\x27) }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() \/\/ \x27foo\x27\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码通过装饰器 mixins，把Foo对象的方法添加到了 MyClass 的实例上面。\x3c\/p\x3e\n\x3ch3\x3e方法的装饰\x3c\/h3\x3e\n\x3cp\x3e装饰器不仅可以装饰类，还可以装饰类的属性。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eclass Person {\n  @readonly\n  name() { return `${this.first} ${this.last}` }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，装饰器 readonly 用来装饰“类”的name方法。\x3c\/p\x3e\n\x3cp\x3e装饰器函数 readonly 一共可以接受三个参数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3efunction readonly(target, name, descriptor){\n  \/\/ descriptor对象原来的值如下\n  \/\/ {\n  \/\/   value: specifiedFunction,\n  \/\/   enumerable: false,\n  \/\/   configurable: true,\n  \/\/   writable: true\n  \/\/ };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, \x27name\x27, descriptor);\n\/\/ 类似于\nObject.defineProperty(Person.prototype, \x27name\x27, descriptor);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e装饰器第一个参数是 \x3cstrong\x3e类的原型对象\x3c\/strong\x3e，上例是 Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（\x3cstrong\x3e这不同于类的装饰，那种情况时target参数指的是类本身\x3c\/strong\x3e）；\x3c\/li\x3e\n\x3cli\x3e第二个参数是 \x3cstrong\x3e所要装饰的属性名\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3cli\x3e第三个参数是 \x3cstrong\x3e该属性的描述对象\x3c\/strong\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外，上面代码说明，\x3ccode\x3e装饰器（readonly\x3c\/code\x3e）会修改属性的 \x3ccode\x3e描述对象（descriptor）\x3c\/code\x3e，然后被修改的描述对象再用来定义属性。\x3c\/p\x3e\n\x3ch3\x3e函数方法的装饰\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3efunction doSomething(name) {\n  console.log(\x27Hello, \x27 \x2b name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log(\x27Starting\x27);\n    const result = wrapped.apply(this, arguments);\n    console.log(\x27Finished\x27);\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3ecore-decorators.js\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/jayphelps\/core-decorators.js\x22 rel=\x22nofollow noreferrer\x22\x3ecore-decorators.js\x3c\/a\x3e是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。\x3c\/p\x3e\n\x3ch3\x3e@autobind\x3c\/h3\x3e\n\x3cp\x3eautobind 装饰器使得方法中的this对象，绑定原始对象。\x3c\/p\x3e\n\x3ch3\x3e@readonly\x3c\/h3\x3e\n\x3cp\x3ereadonly 装饰器使得属性或方法不可写。\x3c\/p\x3e\n\x3ch3\x3e@override\x3c\/h3\x3e\n\x3cp\x3eoverride 装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport { override } from \x27core-decorators\x27;\n\nclass Parent {\n  speak(first, second) {}\n}\n\nclass Child extends Parent {\n  @override\n  speak() {}\n  \/\/ SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\n}\n\n\/\/ or\n\nclass Child extends Parent {\n  @override\n  speaks() {}\n  \/\/ SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\n  \/\/\n  \/\/   Did you mean \x22speak\x22?\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e@deprecate (别名@deprecated)\x3c\/h3\x3e\n\x3cp\x3edeprecate 或 deprecated 装饰器在控制台显示一条警告，表示该方法将废除。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport { deprecate } from \x27core-decorators\x27;\n\nclass Person {\n  @deprecate\n  facepalm() {}\n\n  @deprecate(\x27We stopped facepalming\x27)\n  facepalmHard() {}\n\n  @deprecate(\x27We stopped facepalming\x27, { url: \x27http:\/\/knowyourmeme.com\/memes\/facepalm\x27 })\n  facepalmHarder() {}\n}\n\nlet person = new Person();\n\nperson.facepalm();\n\/\/ DEPRECATION Person#facepalm: This function will be removed in future versions.\n\nperson.facepalmHard();\n\/\/ DEPRECATION Person#facepalmHard: We stopped facepalming\n\nperson.facepalmHarder();\n\/\/ DEPRECATION Person#facepalmHarder: We stopped facepalming\n\/\/\n\/\/     See http:\/\/knowyourmeme.com\/memes\/facepalm for more details.\n\/\/\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e@suppressWarnings\x3c\/h3\x3e\n\x3cp\x3esuppressWarnings 装饰器抑制 deprecated 装饰器导致的 console.warn() 调用。但是，异步代码发出的调用除外。\x3c\/p\x3e\n\x3ch2\x3e使用场景\x3c\/h2\x3e\n\x3ch3\x3e装饰器有注释的作用\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e@testable\nclass Person {\n  @readonly\n  @nonenumerable\n  name() { return `${this.first} ${this.last}` }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。\x3c\/p\x3e\n\x3ch3\x3eReact 的 connect\x3c\/h3\x3e\n\x3cp\x3e实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eclass MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了装饰器，就可以改写上面的代码。装饰\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相对来说，后一种写法看上去更容易理解。\x3c\/p\x3e\n\x3ch3\x3e新功能提醒或权限\x3c\/h3\x3e\n\x3cp\x3e菜单点击时，进行事件拦截，若该菜单有新功能更新，则弹窗显示。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\/**\n * @description 在点击时，如果有新功能提醒，则弹窗显示\n * @param code 新功能的code\n * @returns {function(*, *, *)}\n *\/\n const checkRecommandFunc = (code) =\x26gt; (target, property, descriptor) =\x26gt; {\n    let desF = descriptor.value; \n    descriptor.value = function (...args) {\n      let recommandFuncModalData = SYSTEM.recommandFuncCodeMap[code];\n\n      if (recommandFuncModalData \x26amp;\x26amp; recommandFuncModalData.id) {\n        setTimeout(() =\x26gt; {\n          this.props.dispatch({type: \x27global\/setRecommandFuncModalData\x27, recommandFuncModalData});\n        }, 1000);\n      }\n      desF.apply(this, args);\n    };\n    return descriptor;\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3eloading\x3c\/h3\x3e\n\x3cp\x3e在 React 项目中，我们可能需要在向后台请求数据时，页面出现 loading 动画。这个时候，你就可以使用装饰器，优雅地实现功能。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e@autobind\n@loadingWrap(true)\nasync handleSelect(params) {\n  await this.props.dispatch({\n    type: \x27product_list\/setQuerypParams\x27,\n    querypParams: params\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eloadingWrap 函数如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eexport function loadingWrap(needHide) {\n\n  const defaultLoading = (\n    \x26lt;div className=\x22toast-loading\x22\x26gt;\n      \x26lt;Loading className=\x22loading-icon\x22\/\x26gt;\n      \x26lt;div\x26gt;加载中...\x26lt;\/div\x26gt;\n    \x26lt;\/div\x26gt;\n  );\n\n  return function (target, property, descriptor) {\n    const raw = descriptor.value;\n    \n    descriptor.value = function (...args) {\n      Toast.info(text || defaultLoading, 0, null, true);\n      const res = raw.apply(this, args);\n      \n      if (needHide) {\n        if (get(\x27finally\x27)(res)) {\n          res.finally(() =\x26gt; {\n            Toast.hide();\n          });\n        } else {\n          Toast.hide();\n        }\n      }\n    };\n    return descriptor;\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题：这里大家可以想想看，如果我们不希望每次请求数据时都出现 loading，而是要求只要后台请求时间大于 300ms 时，才显示loading，这里需要怎么改？\x3c\/p\x3e\n\x3ch2\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/defineProperty\x22 rel=\x22nofollow noreferrer\x22\x3eObject.defineProperty()\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.sitepoint.com\/javascript-decorators-what-they-are\/\x22 rel=\x22nofollow noreferrer\x22\x3eJavaScript Decorators: What They Are and When to Use Them\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/decorator#core-decorators-js\x22 rel=\x22nofollow noreferrer\x22\x3eECMAScript 6 入门\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JS 装饰器，一篇就够</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014495089">https://segmentfault.com/a/1190000014495089</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mlhln5s2gji/" target="_blank">https://alili.tech/archive/mlhln5s2gji/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>