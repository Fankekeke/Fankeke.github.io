<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="用 class 写法完整实现一个 Promise"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>用 class 写法完整实现一个 Promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mmxc79xi77j/",
				"appid": "1613049289050283", 
				"title": "用 class 写法完整实现一个 Promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-11-30T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pygdq72kpw/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/sgjyfk4idqa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&text=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&text=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&title=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&is_video=false&description=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&title=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&title=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&title=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmmxc79xi77j%2f&title=%e7%94%a8%20class%20%e5%86%99%e6%b3%95%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20Promise"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">用 class 写法完整实现一个 Promise</h1><div class="meta"><div class="postdate"><time datetime="2018-11-30" itemprop="datePublished">2018-11-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e1.前言\x3c\/h2\x3e\n\x3cblockquote\x3e本文分析 Promise 特性的了解，完整实现了 Promise 所有功能。没有参考原生 Promise 的写法，自己根据思路一步一步完成以及描述，每个构建模块由：1、Promise 特性描述；2、实现特性的完整思路(分析一波) 3、项目代码；4、功能测试代码 几个部分组成。大致用到的知识有： 1、变量私有化；2、订阅发布模式；3、eventloop 理解；4、Promise特性；5、class 特性；6、对象类型的判定... 算了不写了\x3cdel\x3e强行塞这么多我也是够拼的\x3c\/del\x3e\x3cp\x3e你可以\x3ca href=\x22https:\/\/github.com\/li2568261\/es6-record\/tree\/master\/class%2Bpromise\/code\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点我看源码\x3c\/a\x3e、\x3ca href=\x22https:\/\/github.com\/li2568261\/es6-record\/blob\/master\/class%2Bpromise\/class%2Bpromise.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点我看原文地址\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2.\x3cem\x3ePromise\x3c\/em\x3e 特征分析\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e 有三种状态： pending(执行中)、 fulfilled(成功执行)、settled(异常捕获);\x3c\/li\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e 可以通过 new 关键字创建一个 未完成的 \x3cem\x3ePromise\x3c\/em\x3e;\x3c\/li\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e 可以直接通过 \x3cem\x3ePromise\x3c\/em\x3e.resolve 创建一个成功完成的 \x3cem\x3ePromise\x3c\/em\x3e 对象;\x3c\/li\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e 可以直接通过 \x3cem\x3ePromise\x3c\/em\x3e.reject 创建一个异常状态的 \x3cem\x3ePromise\x3c\/em\x3e 对象;\x3c\/li\x3e\n\x3cli\x3e通过 new 关键字创建的 \x3cem\x3ePromise\x3c\/em\x3e 方法里如果出现错误，会被 \x3cem\x3ePromise\x3c\/em\x3e 的 reject 捕获;\x3c\/li\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e.resolve \/ \x3cem\x3ePromise\x3c\/em\x3e.reject 接收 thenable 对象和 \x3cem\x3ePromise\x3c\/em\x3e 对象的处理方式;\x3c\/li\x3e\n\x3cli\x3e当没有错误处理时的，全局的 \x3cem\x3ePromise\x3c\/em\x3e 拒绝处理;\x3c\/li\x3e\n\x3cli\x3e串联 \x3cem\x3ePromise\x3c\/em\x3e 以及 \x3cem\x3ePromise\x3c\/em\x3e 链返回值;\x3c\/li\x3e\n\x3cli\x3e\n\x3cem\x3ePromise\x3c\/em\x3e.all \x3cem\x3ePromise\x3c\/em\x3e.race;\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3.\x3cem\x3ePromise\x3c\/em\x3e 的实现\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e状态码私有化\x3c\/h3\x3e\n\x3cp\x3e开始之前讨论一波 class 私有属性的实现，个人想到的方案如下：\x3c\/p\x3e\n\x3cp\x3e1.通过闭包,将变量存放在 construct 方法里；弊端，所有的其他的对象方法必须在 construct 内定义(NO)。\x3c\/p\x3e\n\x3cp\x3e2.通过在定义 \x3cem\x3ePromise\x3c\/em\x3e 的环境下定义一个 Map，根据当前对象索引去获取相应的私有值；弊端，因为 Map 的 key 是强引用，当定义的 \x3cem\x3ePromise\x3c\/em\x3e 不用时也不会被内存回收(NO)；\x3c\/p\x3e\n\x3cp\x3e3.通过在定义 \x3cem\x3ePromise\x3c\/em\x3e 的环境下定义一个 WeakMap，根据当前对象索引去获取相应的私有值； 优势，木有以上两种劣势（不写点什么感觉难受）；\x3c\/p\x3e\n\x3cp\x3e说了这么多那么咱们要用第三种方法吗？NO，原生 [[PromiseState]] 是一个内部属性，不暴露在 \x3cem\x3ePromise\x3c\/em\x3e 上，但是通过浏览器的控制台可以看到，用第三种方式模仿并不能直观的在控制台看到，所以我决定还是不要作为私有变量出现，但是把枚举特性干掉了 \x3cem\x3e假装他是私有变量\x3c\/em\x3e \x3cdel\x3e心里好过一点\x3c\/del\x3e 因此你就能看到下面的代码;\x3c\/p\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst PENDDING = \x27pendding\x27;\/\/ 等待状态\nconst FULFILLED = \x27resolved\x27;\/\/ 成功操作状态\nconst REJECTED = \x27rejected\x27;\/\/ 捕获错误状态\n\nclass MyPromise{\n  \n  constructor(handler){\n    \/\/ 数据初始化\n    this.init();\n  }\n  \n  \/\/ 数据初始化\n  init(){\n    Object.defineProperties(this,{\n      \x27[[PromiseState]]\x27: {\n        value: PENDDING,\n        writable: true,\n        enumerable: false\n      },\n      \x27[[PromiseValue]]\x27: {\n        value: undefined,\n        writable: true,\n        enumerable: false\n      },\n      \x27thenQueue\x27:{\n        value: [],\n        writable: true,\n        enumerable: false\n      },\n      \x27catchQueue\x27:{\n        value: [],\n        writable: true,\n        enumerable: false\n      }\n    })\n  }\n  \/\/ 获取当前状态\n  getPromiseState (){\n    return this[\x27[[PromiseState]]\x27];\n  }\n  \/\/ 设置当前状态\n  setPromiseState (state) {\n    Object.defineProperty(this, \x27[[PromiseState]]\x27, {\n      value: state,\n      writable: false\n    })\n  }\n\n  \/\/ 获取当前值\n  getPromiseValue (){\n    return this[\x27[[PromiseValue]]\x27];\n  }\n  \/\/ 设置当前值\n  setPromiseValue (val) {\n    Object.defineProperty(this, \x27[[PromiseValue]]\x27, {\n      value: val\n    })\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PENDDING = \x3cspan class=\x22hljs-string\x22\x3e\x27pendding\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待状态\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e FULFILLED = \x3cspan class=\x22hljs-string\x22\x3e\x27resolved\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 成功操作状态\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e REJECTED = \x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 捕获错误状态\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyPromise\x3c\/span\x3e\x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(handler){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据初始化\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.init();\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据初始化\x3c\/span\x3e\n  init(){\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,{\n      \x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseState]]\x27\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: PENDDING,\n        \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseValue]]\x27\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-string\x22\x3e\x27thenQueue\x27\x3c\/span\x3e:{\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: [],\n        \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-string\x22\x3e\x27catchQueue\x27\x3c\/span\x3e:{\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: [],\n        \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      }\n    })\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取当前状态\x3c\/span\x3e\n  getPromiseState (){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseState]]\x27\x3c\/span\x3e];\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置当前状态\x3c\/span\x3e\n  setPromiseState (state) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseState]]\x27\x3c\/span\x3e, {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: state,\n      \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    })\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取当前值\x3c\/span\x3e\n  getPromiseValue (){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseValue]]\x27\x3c\/span\x3e];\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置当前值\x3c\/span\x3e\n  setPromiseValue (val) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27[[PromiseValue]]\x27\x3c\/span\x3e, {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: val\n    })\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e创建一个未完成状态的\x3cem\x3ePromise\x3c\/em\x3e\n\x3c\/h3\x3e\n\x3cp\x3e函数调用过程分析：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用者通过 new 关键字传入一个方法；\x3c\/li\x3e\n\x3cli\x3e方法有两个参数 \x3ccode\x3eresolve\x3c\/code\x3e 和 \x3ccode\x3ereject\x3c\/code\x3e 两个方法\x3c\/li\x3e\n\x3cli\x3e当传入的方法调用 \x3ccode\x3eresolve\x3c\/code\x3e 时，状态变为 fulfilled，有且只有接收一次 \x3ccode\x3eresolve\x3c\/code\x3e 里的方法里的值作为 \x3ccode\x3e[[PromiseValue]]\x3c\/code\x3e，供该 \x3cem\x3ePromise\x3c\/em\x3e 对象下的 \x3ccode\x3ethen\x3c\/code\x3e 方法使用；\x3c\/li\x3e\n\x3cli\x3e当传入的方法调用 \x3ccode\x3ereject\x3c\/code\x3e 时，状态变为 rejected，有且只有接收一次 \x3ccode\x3ereject\x3c\/code\x3e 里的方法里的值作为 \x3ccode\x3e[[PromiseValue]]\x3c\/code\x3e，供该 \x3cem\x3ePromise\x3c\/em\x3e 对象下的 \x3ccode\x3ecatch\x3c\/code\x3e 方法使用；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e代码思路：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e首先传入的函数应该在 construct 方法里进行调用；\x3c\/li\x3e\n\x3cli\x3e因具备一个存放待执行成功操作方法的队列，一个存放捕获异常方法的队列。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3eresolve\x3c\/code\x3e 方法下处理的问题是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221、判断当前状态是否是等待状态，如果不是则啥也不干，如果是走第二步\n\n2、修改```[[PromiseState]]```为FULFILLED;\n\n3、将 ```[[PromiseValue]]``` 赋值为方法传递进来的参数； \n\n4、成功操作方法的队列在 eventloop 结束后\x3csup\x3e①\x3c\/sup\x3e依次调用然后清空，捕获异常方法的队列清空；\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、判断当前状态是否是等待状态，如果不是则啥也不干，如果是走第二步\n\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、修改```[[PromiseState]]```为FULFILLED;\n\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、将 ```[[PromiseValue]]``` 赋值为方法传递进来的参数； \n\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e、成功操作方法的队列在 eventloop 结束后\x26lt;sup\x26gt;①\x26lt;\/sup\x26gt;依次调用然后清空，捕获异常方法的队列清空；\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ereject\x3c\/code\x3e 方法基本就不赘述啦......\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3ethen\x3c\/code\x3e 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221、 判断当前状态是否为等待，是等待进行第 2 步，否则进行第 3 步；\n\n2、 加入成功操作方法队列；\n\n3、 当前eventloop 结束异步调用；\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e、 判断当前状态是否为等待，是等待进行第 \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e 步，否则进行第 \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e 步；\n\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e、 加入成功操作方法队列；\n\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e、 当前eventloop 结束异步调用；\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ecatch\x3c\/code\x3e 方法不赘述\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eps: 注①因为无法将任务插入 microtask 中，就用 eventloop结束作为替代；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 事件循环最后执行\n  const eventLoopEndRun = function (handler){\n    setImmediate(()=\x3e{\n      handler()\n    })\n  }\n  \/\/ ...\n\n  class MyPromise{\n  \n    constructor(handler){\n      \/\/ ...\n      \n      \/\/ 方法传递，通过 bind 保持两个方法对当前对象的引用\n      handler(this.resolve.bind(this), this.reject.bind(this));\n    }\n\n    \/\/ ...\n\n    \/\/ 清空等待队列\n    clearQueue (currentState) {\n      \n      const doQueue = currentState === REJECTED ? this.catchQueue : this.thenQueue;\n      const promiseData = this.getPromiseValue();\n\n      doQueue.forEach(queueHandler=\x3equeueHandler(promiseData));\n      this.catchQueue = [];\n      this.thenQueue = []\n    }\n\n    \/\/ 状态改变方法\n    changeStateHandler (currentState, data){\n\n      this.setPromiseState(currentState);\n      this.setPromiseValue(data);\n      setImmediate(()=\x3e{this.clearQueue(currentState)});\n      \n      \/\/ 保持状态只能改变一次\n      this.changeStateHandler = null;\n      this.setPromiseState = null;\n      this.setPromiseValue = null;\n    }\n\n    \/\/ 不解释\n    resolve (data) {\n      this.changeStateHandler \x26amp;\x26amp; this.changeStateHandler(FULFILLED, data);\n    }\n    \/\/ 不解释\n    reject (err) {\n      this.changeStateHandler \x26amp;\x26amp; this.changeStateHandler(REJECTED, err);\n    }\n\n    \/\/ 不解释\n    then(thenHandler){\n      \n      const currentState = this.getPromiseState();\n      const promiseData = this.getPromiseValue();\n\n      if (currentState === FULFILLED) thenHandler(promiseData);\n      else if (currentState === PENDDING) this.thenQueue.push(thenHandler);\n    }\n\n    \/\/ 不解释\n    catch(catchHandler){\n      \n      const currentState = this.getPromiseState();\n      const promiseData = this.getPromiseValue();\n\n      if (currentState === REJECTED) catchHandler(promiseData);\n      else if (currentState === PENDDING) this.catchQueue.push(catchHandler);\n    }\n  }\n\n  \/\/ 测试方法\n\n\n  const test1 = new MyPromise((resolve,reject)=\x3e{\n    setTimeout(()=\x3e{\n      resolve(\x272s 后输出了我\x27);\n    }, 2000)\n  });\n\n  const test2 = new MyPromise((resolve,reject)=\x3e{\n    setTimeout(()=\x3e{\n      reject(\x27我出错啦！\x27)\n    }, 2000)\n  })\n\n  test1.then(data=\x3econsole.log(data));\n  test1.catch(err=\x3econsole.log(err));\n  test2.then(data=\x3econsole.log(data));\n  test2.catch(err=\x3econsole.log(err));\n  console.log(\x26quot;我是最早的\x26quot;);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件循环最后执行\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e eventLoopEndRun = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ehandler\x3c\/span\x3e)\x3c\/span\x3e{\n    setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      handler()\n    })\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyPromise\x3c\/span\x3e\x3c\/span\x3e{\n  \n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(handler){\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法传递，通过 bind 保持两个方法对当前对象的引用\x3c\/span\x3e\n      handler(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.resolve.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reject.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 清空等待队列\x3c\/span\x3e\n    clearQueue (currentState) {\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doQueue = currentState === REJECTED ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catchQueue : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.thenQueue;\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n\n      doQueue.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3equeueHandler\x3c\/span\x3e=\x26gt;\x3c\/span\x3equeueHandler(promiseData));\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catchQueue = [];\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.thenQueue = []\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 状态改变方法\x3c\/span\x3e\n    changeStateHandler (currentState, data){\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setPromiseState(currentState);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setPromiseValue(data);\n      setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.clearQueue(currentState)});\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保持状态只能改变一次\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setPromiseState = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setPromiseValue = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n    resolve (data) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler(FULFILLED, data);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n    reject (err) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler(REJECTED, err);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n    then(thenHandler){\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e currentState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseState();\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === FULFILLED) thenHandler(promiseData);\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === PENDDING) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.thenQueue.push(thenHandler);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(catchHandler){\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e currentState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseState();\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === REJECTED) catchHandler(promiseData);\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === PENDDING) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catchQueue.push(catchHandler);\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试方法\x3c\/span\x3e\n\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e test1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      resolve(\x3cspan class=\x22hljs-string\x22\x3e\x272s 后输出了我\x27\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e test2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      reject(\x3cspan class=\x22hljs-string\x22\x3e\x27我出错啦！\x27\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n  })\n\n  test1.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));\n  test1.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err));\n  test2.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));\n  test2.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22我是最早的\x22\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e创建一个完成状态的\x3cem\x3ePromise\x3c\/em\x3e\n\x3c\/h3\x3e\n\x3cp\x3e通过 \x3cem\x3ePromise\x3c\/em\x3e.resolve() 创建一个成功操作的 \x3cem\x3ePromise\x3c\/em\x3e 对象； \x3cem\x3ePromise\x3c\/em\x3e.reject() 创建一个捕获错误的 \x3cem\x3ePromise\x3c\/em\x3e 对象，new 关键字传入的方法体有报错，会直接被 reject 捕获；\x3c\/p\x3e\n\x3cp\x3e分析一波：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e能直接调用的方法，妥妥应该的是一个静态方法；\x3c\/li\x3e\n\x3cli\x3e调用之后要生成一个新的 \x3cem\x3ePromise\x3c\/em\x3e 对象；\x3c\/li\x3e\n\x3cli\x3e所以咱们就要分两步走 1，创建一个 \x3cem\x3ePromise\x3c\/em\x3e 对象，然后调用其 resolve 方法.\x3c\/li\x3e\n\x3cli\x3e因为实例化的对象不能获取寄几的 static 方法\x3c\/li\x3e\n\x3cli\x3e通过 try\x2bcatch 捕获 handler 异常，并通过 reject 进行抛出；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n  \/\/ ...\n  \/\/ construct 方法新增一个类型，当 new 关键字进来传递的不是一个函数，咱们同样在 eventLoop 结束抛出一个错误\n  if(Object.prototype.toString.call(handler) !== \x26quot;[object Function]\x26quot;){\n    eventLoopEndRun(()=\x3e{\n      throw new Error(`MyPromise resolver ${typeof handler} is not a function`)\n    })\n  } else {\n    \/\/ 方法传递，this指向会变，通过 bind 保持两个方法对当前对象的引用\n    \/\/ 当然也可以这么玩：data=\x3ethis.resolve(data)\n    try{\n      handler(this.resolve.bind(this), this.reject.bind(this));\n    } catch(err) {\n      this.reject(err);\n    }\n  }\n\n  \/\/ ...\n  \/\/ 不解释\n  static resolve (data) {\n    return new MyPromise(resolve=\x3eresolve(data));\n  }\n  \/\/ 不解释\n  static reject (err) {\n    return new MyPromise((resolve, reject)=\x3e{reject(err)});\n  }\n\n  \/\/ 测试方法\n  var resolvePromise =  MyPromise.resolve(111);\n\n  resolvePromise.then(data=\x3econsole.log(data));\n\n  var rejectPromise =  MyPromise.reject(\x27这个错了\x27);\n\n  rejectPromise.catch(data=\x3econsole.log(data));\n\n  new MyPromise();\n\n  var errPromise = new MyPromise(()=\x3e{throw new Error(\x26quot;我错了\x26quot;)});\n  errPromise.catch(data=\x3econsole.log(data.message));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ construct 方法新增一个类型，当 new 关键字进来传递的不是一个函数，咱们同样在 eventLoop 结束抛出一个错误\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(handler) !== \x3cspan class=\x22hljs-string\x22\x3e\x22[object Function]\x22\x3c\/span\x3e){\n    eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`MyPromise resolver \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e handler}\x3c\/span\x3e is not a function`\x3c\/span\x3e)\n    })\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法传递，this指向会变，通过 bind 保持两个方法对当前对象的引用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当然也可以这么玩：data=\x26gt;this.resolve(data)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n      handler(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.resolve.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reject.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.reject(err);\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e resolve (data) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(data));\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e reject (err) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{reject(err)});\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e resolvePromise =  MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e111\x3c\/span\x3e);\n\n  resolvePromise.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rejectPromise =  MyPromise.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27这个错了\x27\x3c\/span\x3e);\n\n  rejectPromise.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));\n\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise();\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e errPromise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22我错了\x22\x3c\/span\x3e)});\n  errPromise.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data.message));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ethenable 对象 \x2b 全局错误监听\x3c\/h3\x3e\n\x3cp\x3ethenable 对象是啥？就是有个属性为 then 方法的对象，then 方法里有两个参数，resolve、reject 至于 resolve 和 reject 的作用，就不赘述啦 \x3cdel\x3e好像还是打了很多字\x3c\/del\x3e。\x3c\/p\x3e\n\x3cp\x3e全局错误监听，监听分为两种（书上的说法是）: 一个触发是当前事件循环结束前没有catch 当前错误 \x3cem\x3ePromise\x3c\/em\x3e --- unhandledRejection；一个触发是当前事件循环后，当 \x3cem\x3ePromise\x3c\/em\x3e 被拒绝，并且没有 catch 程序，就会被触发 --- rejectionHandled。经过 node 环境下测试(在 Chrome 控制台测试好像无论如何都不会被触发)感觉是 rejectionHandled 触发实在新的时间循环添加 catch 程序后才会被触发，大致流程图如下。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014888359?w=1078\x26amp;h=986\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014888359?w=1078\x26amp;h=986\x22 alt=\x22流程图\x22 title=\x22流程图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nlet rejected;\n\nprocess.on(\x27unhandledRejection\x27,function(event){\n  console.log(\x27onunhandledrejection\x27);\n})\n\nprocess.on(\x27rejectionHandled\x27,function(event){\n  console.log(\x27onrejectionhandled\x27);\n})\n\nrejected = Promise.reject(new Error(\x27xx\x27))\n\neventLoopEndRun(()=\x3e{\n  console.log(123);\n  rejected.catch(err=\x3e{\n    console.log(err.message)\n  })\n  rejected.catch(err=\x3e{\n    console.log(err.message)\n  })\n}) \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rejected;\n\nprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27unhandledRejection\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27onunhandledrejection\x27\x3c\/span\x3e);\n})\n\nprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27rejectionHandled\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27onrejectionhandled\x27\x3c\/span\x3e);\n})\n\nrejected = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27xx\x27\x3c\/span\x3e))\n\neventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e);\n  rejected.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err.message)\n  })\n  rejected.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err.message)\n  })\n}) \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e分析一波：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e在 reject 阶段进行订阅 \x3ccode\x3eunhanlderReject\x3c\/code\x3e 事件；\x3c\/li\x3e\n\x3cli\x3ecatch 函数中移除当前 \x3cem\x3ePromise\x3c\/em\x3e 对 \x3ccode\x3eunhandledRejection\x3c\/code\x3e 事件的订阅，执行传入 catch 前发布当前 \x3cem\x3ePromise\x3c\/em\x3e 的 \x3ccode\x3erejectionHandled\x3c\/code\x3e 事件。\x3c\/li\x3e\n\x3cli\x3e当前事件循环结束，我们需要优先对 \x3ccode\x3eunhanlderReject\x3c\/code\x3e 事件进行发布，所以我们需要调整eventLoopEndRun 函数；当\x3cem\x3ePromise\x3c\/em\x3e没有 catch 程序,且没有全局没有 \x3ccode\x3eunhanlderReject\x3c\/code\x3e 监听，我们就要抛出相应的错误。\x3c\/li\x3e\n\x3cli\x3e我们需要自定义这个 订阅发布者，然后能通过当前 \x3cem\x3ePromise\x3c\/em\x3e 使得事件触发绑定相应的回调。\x3c\/li\x3e\n\x3cli\x3e这个发布订阅者具有备的功能有： 1、新增监听回调；2、订阅和取消订阅；3、相应的事件发布后，将对应 map 中 \x3cem\x3ePromise\x3c\/em\x3e 修改状态。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e于是乎代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ PromiseSubscribePublish.js\n  const UNHANDLEDREJECTION = \x27UNHANDLEDREJECTION\x27; \/\/ 当前事件循环，无 catch 函数状态；\n  const REJECTIONHANDLED = \x27REJECTIONHANDLED\x27; \/\/ 事件循环后，无 catch 函数状态；\n\n  class PromiseSubscribePublish{\n\n    constructor(){\n      this.subscribeUnhandler = new Map();\n      this.subscribeHandler = new Map();\n      this.errFuc = {}\n    }\n\n    \/\/ 监听事件绑定\n    bindLisener (type, cb){\n      console.log(type.toUpperCase(), UNHANDLEDREJECTION)\n      if(type.toUpperCase() !== UNHANDLEDREJECTION \x26amp;\x26amp; type.toUpperCase() !== REJECTIONHANDLED) throw Error(\x27type toUpperCase must be UNHANDLEDREJECTION or REJECTIONHANDLED\x27);\n      if(Object.prototype.toString.call(cb) !== \x26quot;[object Function]\x26quot;) throw Error(\x27callback is not function\x27);\n      this.errFuc[type.toUpperCase()] = cb;\n    }\n\n    subscribe(promise, err){\n      \/\/ 订阅一波，以当前 Promise 为 key，err 为参数,加入 unhandler map 中\n      this.subscribeUnhandler.set(promise, err)\n    }\n\n    quitSubscribe(promise){\n      this.subscribeUnhandler.delete(promise);\n    }\n\n    publish (type, promise) {\n      \n      let changgeStateFuc; \/\/ 定义当前状态变换操作\n      const errFuc = this.errFuc[type]; \/\/ 当前绑定的监听函数\n\n\n      \n      if(type === UNHANDLEDREJECTION){\n        \/\/ 没有订阅事件的 promise 则啥也不干\n        if (!this.subscribeUnhandler.size) return;\n        \/\/ 根据当前事件类型，选择处理函数\n        changgeStateFuc = (err, promise)=\x3e{\n          this.subscribeHandler.set(promise);\n          this.subscribeUnhandler.delete(promise, err);\n        }\n        \/\/ 不论如何当前时间循环下的等待队列状态全部需要变更\n        if(errFuc){\n          this.subscribeUnhandler.forEach((err, promise)=\x3e{\n            errFuc(err, promise)\n            changgeStateFuc(err, promise)\n          })\n        } else {\n          this.subscribeUnhandler.forEach((err, promise)=\x3e{\n            changgeStateFuc(err, promise)\n          })\n          console.error(\x27Uncaught (in promise)\x27, err);\n        }\n\n      } else {\n        \/\/ 如果该 promise 没有进行订阅\n        if(!this.subscribeHandler.has(promise)) return;\n        \/\/ 哪个 promise 发布 catch 函数，就根据当前 Promise 执行相应方法，并将其从 Handler 订阅者里删除\n        \n        errFuc \x26amp;\x26amp; errFuc(promise);\n        this.subscribeHandler.delete(promise);\n\n      } \n\n    }\n  }\n\n  \/\/ 定义一些静态成员变量 默认不可写\n  Object.defineProperties(PromiseSubscribePublish, {\n    [UNHANDLEDREJECTION]:{\n      value: UNHANDLEDREJECTION\n    },\n    [REJECTIONHANDLED]:{\n      value: REJECTIONHANDLED\n    }\n  })\n\n  module.exports = PromiseSubscribePublish;\n\n  \/\/ MyPromise.js\n  \/\/ ..\n  const PromiseSubscribePublish = require(\x27.\/PromiseSubscribePublish\x27);\n\n  const promiseSubscribePublish = new PromiseSubscribePublish();\n\n  \/\/ 事件循环最后执行\n  const eventLoopEndRun = (()=\x3e{\n    let unhandledPub;\n    let timer;\n    const queueHandler = [];\n    \/\/ 激活事件循环最后执行\n    const activateRun = ()=\x3e{\n      \/\/ 截流\n      timer \x26amp;\x26amp; clearTimeout(timer);\n      timer = setTimeout(()=\x3e{\n        unhandledPub \x26amp;\x26amp; unhandledPub();\n        let handler = queueHandler.shift();\n        while(handler){\n          handler();\n          handler = queueHandler.shift();\n        }\n      },0);\n    }\n    \n    \/\/ 设置 unhanldedReject 优先级最高 ， 直接加入队列\n    return (handler,immediate)=\x3e {\n      immediate ? unhandledPub = handler : queueHandler.push(handler);\n      activateRun();\n    }\n  })()\n  \n  \/\/...\n  reject (err) {\n    this.changeStateHandler \x26amp;\x26amp; this.changeStateHandler(REJECTED, err);\n    promiseSubscribePublish.subscribe(this, err);\n    \/\/ 存在 reject ，事件循环结束发布 UNHANDLEDREJECTION\n    eventLoopEndRun(()=\x3e\n      promiseSubscribePublish.publish(PromiseSubscribePublish.UNHANDLEDREJECTION, this),\n      true\n    );\n  }\n\n  \/\/...\n\n  static unhandledRejectionLisener(cb){\n    promiseSubscribePublish.bindLisener(PromiseSubscribePublish.UNHANDLEDREJECTION ,cb)\n  }\n\n  static rejectionHandledLisener(cb){\n    promiseSubscribePublish.bindLisener(PromiseSubscribePublish.REJECTIONHANDLED ,cb)\n  }\n\n  \/\/ ...\n  catch(catchHandler){\n    \n    const currentState = this.getPromiseState();\n    const promiseData = this.getPromiseValue();\n\n    \/\/ 取消当前事件循环下 reject 状态未 catch 事件订阅;\n    promiseSubscribePublish.quitSubscribe(this);\n    \n    if (currentState === REJECTED) {\n      \n      eventLoopEndRun(()=\x3e{\n        \/\/ 发布 catch 处理\n        promiseSubscribePublish.publish(PromiseSubscribePublish.REJECTIONHANDLED, this);\n        catchHandler(promiseData);\n      });\n\n    }\n    else if (currentState === PENDDING) this.catchQueue.push(catchHandler);\n  }\n\n\n  \/\/ 测试代码\n\n  MyPromise.unhandledRejectionLisener((err,promise)=\x3e{\n    console.log(err, promise);\n  }) \n  MyPromise.rejectionHandledLisener((err,promise)=\x3e{\n    console.log(err, promise);\n  }) \n  var myPromise = MyPromise.reject(11);\n  \/\/ myPromise.catch(()=\x3e{console.log(\x27catch\x27)});\n  setTimeout(()=\x3e{\n    myPromise.catch(()=\x3e{console.log(\x27catch\x27)});\n  },1000)\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ PromiseSubscribePublish.js\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e UNHANDLEDREJECTION = \x3cspan class=\x22hljs-string\x22\x3e\x27UNHANDLEDREJECTION\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前事件循环，无 catch 函数状态；\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e REJECTIONHANDLED = \x3cspan class=\x22hljs-string\x22\x3e\x27REJECTIONHANDLED\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件循环后，无 catch 函数状态；\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromiseSubscribePublish\x3c\/span\x3e\x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e();\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeHandler = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e();\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.errFuc = {}\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听事件绑定\x3c\/span\x3e\n    bindLisener (type, cb){\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(type.toUpperCase(), UNHANDLEDREJECTION)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(type.toUpperCase() !== UNHANDLEDREJECTION \x26amp;\x26amp; type.toUpperCase() !== REJECTIONHANDLED) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27type toUpperCase must be UNHANDLEDREJECTION or REJECTIONHANDLED\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(cb) !== \x3cspan class=\x22hljs-string\x22\x3e\x22[object Function]\x22\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27callback is not function\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.errFuc[type.toUpperCase()] = cb;\n    }\n\n    subscribe(promise, err){\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅一波，以当前 Promise 为 key，err 为参数,加入 unhandler map 中\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.set(promise, err)\n    }\n\n    quitSubscribe(promise){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.delete(promise);\n    }\n\n    publish (type, promise) {\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e changgeStateFuc; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义当前状态变换操作\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e errFuc = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.errFuc[type]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前绑定的监听函数\x3c\/span\x3e\n\n\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(type === UNHANDLEDREJECTION){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 没有订阅事件的 promise 则啥也不干\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.size) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据当前事件类型，选择处理函数\x3c\/span\x3e\n        changgeStateFuc = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, promise\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeHandler.set(promise);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.delete(promise, err);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不论如何当前时间循环下的等待队列状态全部需要变更\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(errFuc){\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, promise\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n            errFuc(err, promise)\n            changgeStateFuc(err, promise)\n          })\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeUnhandler.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, promise\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n            changgeStateFuc(err, promise)\n          })\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27Uncaught (in promise)\x27\x3c\/span\x3e, err);\n        }\n\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果该 promise 没有进行订阅\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeHandler.has(promise)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 哪个 promise 发布 catch 函数，就根据当前 Promise 执行相应方法，并将其从 Handler 订阅者里删除\x3c\/span\x3e\n        \n        errFuc \x26amp;\x26amp; errFuc(promise);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscribeHandler.delete(promise);\n\n      } \n\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一些静态成员变量 默认不可写\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(PromiseSubscribePublish, {\n    [UNHANDLEDREJECTION]:{\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: UNHANDLEDREJECTION\n    },\n    [REJECTIONHANDLED]:{\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: REJECTIONHANDLED\n    }\n  })\n\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = PromiseSubscribePublish;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ MyPromise.js\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ..\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PromiseSubscribePublish = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/PromiseSubscribePublish\x27\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseSubscribePublish = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e PromiseSubscribePublish();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件循环最后执行\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e eventLoopEndRun = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e(\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e unhandledPub;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e timer;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e queueHandler = [];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 激活事件循环最后执行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e activateRun = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 截流\x3c\/span\x3e\n      timer \x26amp;\x26amp; clearTimeout(timer);\n      timer = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        unhandledPub \x26amp;\x26amp; unhandledPub();\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e handler = queueHandler.shift();\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(handler){\n          handler();\n          handler = queueHandler.shift();\n        }\n      },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置 unhanldedReject 优先级最高 ， 直接加入队列\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ehandler,immediate\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e {\n      immediate ? unhandledPub = handler : queueHandler.push(handler);\n      activateRun();\n    }\n  })()\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n  reject (err) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler(REJECTED, err);\n    promiseSubscribePublish.subscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, err);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 存在 reject ，事件循环结束发布 UNHANDLEDREJECTION\x3c\/span\x3e\n    eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\n      promiseSubscribePublish.publish(PromiseSubscribePublish.UNHANDLEDREJECTION, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e),\n      \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    );\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e unhandledRejectionLisener(cb){\n    promiseSubscribePublish.bindLisener(PromiseSubscribePublish.UNHANDLEDREJECTION ,cb)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e rejectionHandledLisener(cb){\n    promiseSubscribePublish.bindLisener(PromiseSubscribePublish.REJECTIONHANDLED ,cb)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(catchHandler){\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e currentState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseState();\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取消当前事件循环下 reject 状态未 catch 事件订阅;\x3c\/span\x3e\n    promiseSubscribePublish.quitSubscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === REJECTED) {\n      \n      eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布 catch 处理\x3c\/span\x3e\n        promiseSubscribePublish.publish(PromiseSubscribePublish.REJECTIONHANDLED, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        catchHandler(promiseData);\n      });\n\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === PENDDING) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catchQueue.push(catchHandler);\n  }\n\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试代码\x3c\/span\x3e\n\n  MyPromise.unhandledRejectionLisener(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,promise\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err, promise);\n  }) \n  MyPromise.rejectionHandledLisener(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,promise\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err, promise);\n  }) \n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e myPromise = MyPromise.reject(\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ myPromise.catch(()=\x26gt;{console.log(\x27catch\x27)});\x3c\/span\x3e\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    myPromise.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27catch\x27\x3c\/span\x3e)});\n  },\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e串联 \x3cem\x3ePromise\x3c\/em\x3e 以及 \x3cem\x3ePromise\x3c\/em\x3e 链返回值\x3c\/h3\x3e\n\x3cp\x3e看到链式，首先想到的是 jquery 调用。jquery 返回的是 jquery 对象本体。而 \x3cem\x3ePromise\x3c\/em\x3e 根据状态判断：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e当是操作成功状态时，调用 catch 会返回和当前 \x3cem\x3ePromise\x3c\/em\x3e 的 \x3ccode\x3e[[PromiseStatus]]\x3c\/code\x3e 和 \x3ccode\x3e[[PromiseValues]]\x3c\/code\x3e 状态相同新构建的 \x3cem\x3ePromise\x3c\/em\x3e；调用 then 方法时，返回和当前 \x3cem\x3ePromise\x3c\/em\x3e 的 \x3ccode\x3e[[PromiseStatus]]\x3c\/code\x3e 相同的，\x3ccode\x3e[[PromiseValues]]\x3c\/code\x3e 值为 then 方法返回值的 新构建的 \x3cem\x3ePromise\x3c\/em\x3e；\x3c\/li\x3e\n\x3cli\x3e当是捕获错误状态时，调用 then 会返回和当前 \x3cem\x3ePromise\x3c\/em\x3e 的 \x3ccode\x3e[[PromiseStatus]]\x3c\/code\x3e 和 \x3ccode\x3e[[PromiseValues]]\x3c\/code\x3e 状态相同新构建的 \x3cem\x3ePromise\x3c\/em\x3e；调用 catch 方法时， 返回操作成功的新构建的 \x3cem\x3ePromise\x3c\/em\x3e ，\x3ccode\x3e[[PromiseValues]]\x3c\/code\x3e 值为 catch 方法返回值；\x3c\/li\x3e\n\x3cli\x3e当执行 catch 或 then 方法体内有报错，直接返回一个新构建捕获错误的 \x3cem\x3ePromise\x3c\/em\x3e ，\x3ccode\x3e[[PromiseValues]]\x3c\/code\x3e  为那个错误；\x3c\/li\x3e\n\x3cli\x3e如果 \x3cem\x3ePromise\x3c\/em\x3e 中有一环出现错误，而链中没有 catch 方法，则抛出错误，否则把链上的所有 Promise 都从 \x3ccode\x3eunhandledRejuect\x3c\/code\x3e 订阅中去除。\x3c\/li\x3e\n\x3cli\x3e因为 then 和 catch 回调方法是当前事件循环结束时才执行，而 catch 去除  \x3cem\x3ePromise\x3c\/em\x3e 链上 \x3ccode\x3eunhandledRejuect\x3c\/code\x3e 订阅是当前事件循环，如果链上有方法报错，\x3ccode\x3eunhandledRejuect\x3c\/code\x3e 订阅会再次发生，这样会造成哪怕当前报错 \x3cem\x3ePromise\x3c\/em\x3e 后有 catch，也会抛出错误，因此需要给当前 \x3cem\x3ePromise\x3c\/em\x3e 加一个属性，以标志链后有 catch，使得其不订阅 \x3ccode\x3eunhandledRejuect\x3c\/code\x3e 事件。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e分析一波：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 要在实例方法中，创建另一个当前类的实例时，必须用到当前类的构造函数。当咱们的类被继承出一个派生类，咱们希望返回的是那个派生类，于是不能直接 new MyPromise 去创建,而要使用一个 Symbol.species\n2. 新建 *Promise* 和之前的 *Promise* 存在关联,所以当前 *Promise* 的状态决定新 *Promise* 状态，构建新 *Promise* 的过程中当前 *Promise* 的捕获函数不能将其订阅从 unhandledReject 中移除，所以需要一个标志位来标识 then 函数属性。\n3. *Promise* 链上如果出现 catch 函数，链上 catch 函数之前的所有 *Promise* 都将从订阅 unhandledReject Map 中移除，因此 *Promise* 需要记录链上的上一级 *Promise*；\n4. *Promise* then 或 catch 方法体内报错将构建一个捕获错误状态的 *Promise*，因此需要一个函数去捕获可能发生的错误；\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e 要在实例方法中，创建另一个当前类的实例时，必须用到当前类的构造函数。当咱们的类被继承出一个派生类，咱们希望返回的是那个派生类，于是不能直接 \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise 去创建,而要使用一个 \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.species\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e 新建 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 和之前的 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 存在关联,所以当前 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 的状态决定新 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 状态，构建新 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 的过程中当前 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 的捕获函数不能将其订阅从 unhandledReject 中移除，所以需要一个标志位来标识 then 函数属性。\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 链上如果出现 \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e 函数，链上 \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e 函数之前的所有 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 都将从订阅 unhandledReject \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e 中移除，因此 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* 需要记录链上的上一级 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e*；\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e* then 或 \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e 方法体内报错将构建一个捕获错误状态的 *\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e*，因此需要一个函数去捕获可能发生的错误；\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n  \/\/... MyPromise.js\n\n\n  const runFucMaybeError = handler =\x3e {\n    try {\n      return handler();\n    } catch(err) {\n      return {\n        iserror: FUCERROR,\n        err\n      };\n    }\n  }\n\n  const clearLinksSubscribe = linkPrePromise=\x3e{\n    while(linkPrePromise \x26amp;\x26amp; !linkPrePromise.hascatch){\n      linkPrePromise.hascatch = true;\n      promiseSubscribePublish.quitSubscribe(linkPrePromise);\n      linkPrePromise = linkPrePromise.linkPrePromise;\n    }\n  }\n  \/\/ 不解释\n  then(thenHandler, quitReturn){\n    \n    const currentState = this.getPromiseState();\n    const promiseData = this.getPromiseValue();\n    let nextPromiseData;\n    if (currentState === FULFILLED) eventLoopEndRun(()=\x3e{\n      nextPromiseData = runFucMaybeError(()=\x3ethenHandler(promiseData))\n    });\n    else if (currentState === PENDDING) this.thenQueue.push(data=\x3e{\n      nextPromiseData = runFucMaybeError(()=\x3ethenHandler(data))\n    });\n\n    if(!quitReturn){\n      const nextPromise = new this.constructor[Symbol.species]((resolve,reject)=\x3e{\n        \n        this.catch(err=\x3e{\n          reject(err);\n        }, true);\n        \/\/ 根据队列原则，执行肯定在当前 then 后，保证能正确拿到前一个 Promise 的返回值\n        this.then(()=\x3e{\n          nextPromiseData \x26amp;\x26amp; nextPromiseData.iserror === FUCERROR \n            ? reject(nextPromiseData.err) \n              : resolve(nextPromiseData)\n        }, true)\n      })\n      nextPromise.linkPrePromise = this;\n      return nextPromise;\n    };\n\n  }\n\n  catch(catchHandler, quitReturn){\n    \n    const currentState = this.getPromiseState();\n    const promiseData = this.getPromiseValue();\n    let nextPromiseData;\n    \/\/ 取消当前事件循环下 reject 状态未 catch 事件订阅;\n    \/\/ 当是实例内部调用时,不能将当前 Promise 从 unhandledReject 队列中移除；\n    \/\/ 否则顺着生成链依次将 Promise 移除；\n    if(!quitReturn)clearLinksSubscribe(this)\n    if (currentState === REJECTED) {\n      \n      eventLoopEndRun(()=\x3e{\n        \/\/ 发布 catch 处理\n        promiseSubscribePublish.publish(PromiseSubscribePublish.REJECTIONHANDLED, this);\n        nextPromiseData = runFucMaybeError(()=\x3ecatchHandler(promiseData));\n      });\n\n    }\n    else if (currentState === PENDDING) this.catchQueue.push(data=\x3e{\n      nextPromiseData = runFucMaybeError(()=\x3e{catchHandler(data)})\n    });\n\n    if(!quitReturn){\n      \n      const nextPromise = new this.constructor[Symbol.species]((resolve,reject)=\x3e{\n        \/\/ 根据队列原则，执行肯定在当前 then 后，保证能正确拿到报错的 Promise 的返回值\n        this.catch(()=\x3e{\n          nextPromiseData \x26amp;\x26amp; nextPromiseData.iserror === FUCERROR \n          ? reject(nextPromiseData.err) \n            : resolve(nextPromiseData)\n        }, true);\n        this.then(data=\x3eresolve(data), true)\n      })\n      nextPromise.linkPrePromise = this;\n      return nextPromise;\n    }\n\n  }\n\n  \/\/ 测试代码\n  const test1 = new MyPromise((resolve,reject)=\x3e{\n    setTimeout(()=\x3e{\n      resolve(\x272s 后输出了我\x27);\n    }, 2000)\n  });\n\n\n  test1.then(data=\x3e{\n    console.log(data);\n    return \x27你好\x27\n  }).then(data=\x3e{\n    console.log(data);\n    return \x27不好\x27\n  }).then(data=\x3e{\n    console.log(data);\n  });\n\n  test1.catch(err=\x3econsole.log(err)).then(data=\x3e{\n    console.log(data);\n    return \x27gggg\x27\n  }).then(data=\x3e{\n    console.log(data);\n  });\n\n  const test2 = new MyPromise((resolve,reject)=\x3e{\n    throw new Error(\x27xx\x27);\n  })\n\n  test2.then(data=\x3econsole.log(data)).catch(err=\x3econsole.log(err));\n\n  test2.catch(err=\x3econsole.log(err)).then(data=\x3e{\n    console.log(data);\n    return \x27你好\x27\n  }).then(data=\x3e{\n    console.log(data);\n    return \x27不好\x27\n  }).then(data=\x3e{\n    console.log(data);\n  });\n  var a = MyPromise.resolve(1);\n  var b = a.then(data=\x3e{throw new Error(\x2711\x27)}).catch(err=\x3e{console.log(err.message)})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/... MyPromise.js\x3c\/span\x3e\n\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e runFucMaybeError = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ehandler\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e handler();\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3eiserror\x3c\/span\x3e: FUCERROR,\n        err\n      };\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clearLinksSubscribe = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3elinkPrePromise\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(linkPrePromise \x26amp;\x26amp; !linkPrePromise.hascatch){\n      linkPrePromise.hascatch = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      promiseSubscribePublish.quitSubscribe(linkPrePromise);\n      linkPrePromise = linkPrePromise.linkPrePromise;\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不解释\x3c\/span\x3e\n  then(thenHandler, quitReturn){\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e currentState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseState();\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e nextPromiseData;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === FULFILLED) eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      nextPromiseData = runFucMaybeError(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ethenHandler(promiseData))\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === PENDDING) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.thenQueue.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      nextPromiseData = runFucMaybeError(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ethenHandler(data))\n    });\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!quitReturn){\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nextPromise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.species](\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        \n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n          reject(err);\n        }, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据队列原则，执行肯定在当前 then 后，保证能正确拿到前一个 Promise 的返回值\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n          nextPromiseData \x26amp;\x26amp; nextPromiseData.iserror === FUCERROR \n            ? reject(nextPromiseData.err) \n              : resolve(nextPromiseData)\n        }, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n      })\n      nextPromise.linkPrePromise = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nextPromise;\n    };\n\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(catchHandler, quitReturn){\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e currentState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseState();\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promiseData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getPromiseValue();\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e nextPromiseData;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取消当前事件循环下 reject 状态未 catch 事件订阅;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当是实例内部调用时,不能将当前 Promise 从 unhandledReject 队列中移除；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则顺着生成链依次将 Promise 移除；\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!quitReturn)clearLinksSubscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === REJECTED) {\n      \n      eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布 catch 处理\x3c\/span\x3e\n        promiseSubscribePublish.publish(PromiseSubscribePublish.REJECTIONHANDLED, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        nextPromiseData = runFucMaybeError(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ecatchHandler(promiseData));\n      });\n\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState === PENDDING) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catchQueue.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      nextPromiseData = runFucMaybeError(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{catchHandler(data)})\n    });\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!quitReturn){\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nextPromise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.species](\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据队列原则，执行肯定在当前 then 后，保证能正确拿到报错的 Promise 的返回值\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n          nextPromiseData \x26amp;\x26amp; nextPromiseData.iserror === FUCERROR \n          ? reject(nextPromiseData.err) \n            : resolve(nextPromiseData)\n        }, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(data), \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n      })\n      nextPromise.linkPrePromise = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nextPromise;\n    }\n\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试代码\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e test1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      resolve(\x3cspan class=\x22hljs-string\x22\x3e\x272s 后输出了我\x27\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n  });\n\n\n  test1.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27你好\x27\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27不好\x27\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n  });\n\n  test1.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27gggg\x27\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e test2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27xx\x27\x3c\/span\x3e);\n  })\n\n  test2.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err));\n\n  test2.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27你好\x27\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27不好\x27\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n  });\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = a.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x2711\x27\x3c\/span\x3e)}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err.message)})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e\n\x3cem\x3ePromise\x3c\/em\x3e.all \x2b \x3cem\x3ePromise\x3c\/em\x3e.race;\x3c\/h3\x3e\n\x3cp\x3e\x3cem\x3ePromise\x3c\/em\x3e.all 有如下特性: 1、接收一个具有[Symbol.iterator]函数的数据， 返回一个 \x3cem\x3ePromise\x3c\/em\x3e，该 \x3cem\x3ePromise\x3c\/em\x3e 成功操作，then 方法传入一个数组，数组数据位置和迭代器迭代返回的顺序相关联，该 \x3cem\x3ePromise\x3c\/em\x3e 捕获错误 catch 里的传入捕获的错误; 2、 迭代器遍历结果如果是 \x3cem\x3ePromise\x3c\/em\x3e , 则将其 PromiseValue 作为值，插入传入数组对应的位置，当遍历结果不是 \x3cem\x3ePromise\x3c\/em\x3e 直接插入数组对应位置，当遇到捕获错误，或者 \x3cem\x3ePromise\x3c\/em\x3e 出现错误时直接将状态转变为 rejected 状态 ，从 catch 拿到相应错误的值；总结就是有错马上抛，要不等所有数据处理完才改变状态；\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3ePromise\x3c\/em\x3e.race 就不赘述：记住几点，传入参数要求和 .all 相同，数据处理方式是，先到先得，率先处理完的数据直接修改状态。\x3c\/p\x3e\n\x3cp\x3e在分析一波之前，调整几个之前的没有考虑到的问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e将状态改变函数覆盖操作移至 resolve 和 reject 函数中。\x3c\/li\x3e\n\x3cli\x3ereject 方法体执行全都由是否能改变状态决定。\x3c\/li\x3e\n\x3cli\x3ereject 新增一个参数，表示不订阅 \x3ccode\x3eunhandledReject\x3c\/code\x3e 事件，因为 then 方法也会生成新的 \x3cem\x3ePromise\x3c\/em\x3e，而 then 链前有捕获异常状态的 \x3cem\x3ePromise\x3c\/em\x3e 会造成重复报错，catch 无所谓,因为本身会Promise 链队列。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 开头的 \x27-\x27 标示移除，\x27\x2b\x27 表示新增\n  \/\/ ... changeStateHandler 方法\n  -  this.changeStateHandler = null;\n\n  resolve (data) {\n    if(this.changeStateHandler){\n      this.changeStateHandler(FULFILLED, data);\n      \/\/ 保持状态只能改变一次\n      this.changeStateHandler = null;\n    }\n  }\n\n  reject (err, noSubscribe) {\n    if(this.changeStateHandler){ \n      this.changeStateHandler(REJECTED, err);\n      !noSubscribe \x26amp;\x26amp; !this.hascatch \x26amp;\x26amp; promiseSubscribePublish.subscribe(this, err);\n      \/\/ 存在 reject ，事件循环结束发布 UNHANDLEDREJECTION\n      eventLoopEndRun(()=\x3e\n        promiseSubscribePublish.publish(PromiseSubscribePublish.UNHANDLEDREJECTION, this),\n        true\n      );\n      \/\/ 保持状态只能改变一次\n      this.changeStateHandler = null;\n    }\n  }\n\n  \/\/ then 方法\n  - this.catch(err=\x3e{\n    reject(err)\n  }, true);\n  \n  \x2b this.catch(err=\x3ereject(err, true), true);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开头的 \x27-\x27 标示移除，\x27\x2b\x27 表示新增\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... changeStateHandler 方法\x3c\/span\x3e\n  -  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  resolve (data) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler(FULFILLED, data);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保持状态只能改变一次\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n  }\n\n  reject (err, noSubscribe) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler){ \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler(REJECTED, err);\n      !noSubscribe \x26amp;\x26amp; !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hascatch \x26amp;\x26amp; promiseSubscribePublish.subscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, err);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 存在 reject ，事件循环结束发布 UNHANDLEDREJECTION\x3c\/span\x3e\n      eventLoopEndRun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\n        promiseSubscribePublish.publish(PromiseSubscribePublish.UNHANDLEDREJECTION, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e),\n        \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      );\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保持状态只能改变一次\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeStateHandler = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ then 方法\x3c\/span\x3e\n  - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    reject(err)\n  }, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n  \n  \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3ereject(err, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e), \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来开始分析一波：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e首先咱们的判断，传入的是否具有 \x3ccode\x3eSymbol.iterator\x3c\/code\x3e，没有就直接抛错（\x3cem\x3ePromise\x3c\/em\x3e 状态会直接变为 reject，就不往下说了）；\x3c\/li\x3e\n\x3cli\x3e因为咱们定义的 MyPromise 所以判断类型应该是 MyPromise，如果想要通过 \x3ccode\x3eObject.prototype.toString.call\x3c\/code\x3e 去判断，咱们需要给咱们的类加一个 tag\x3c\/li\x3e\n\x3cli\x3e.all 处理完一波数据插入结果值对应的位置，判断是否数据完全处理完，如果全部处理完才改变状态。.race 处理完那个直接改变状态，忽略后面、忽略后面、忽略后面(重要的事情哔哔3次)。\x3c\/li\x3e\n\x3cli\x3e两边如果有传入的 \x3cem\x3ePromise\x3c\/em\x3e 状态出现捕获异常,返回的 \x3cem\x3ePromise\x3c\/em\x3e 状态即变为异常，catch 得到的值即为传入 \x3cem\x3ePromise\x3c\/em\x3e 异常的那个异常 \x3cdel\x3e绕死你\x3c\/del\x3e。\x3c\/li\x3e\n\x3cli\x3e因为是静态方法所以不能用 Symbol.species 构建实例。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ MyPromise.js 最后头\n  MyPromise.prototype[Symbol.toStringTag] = \x26quot;MyPromise\x26quot;;\n\n\n  static all (promiseArr){\n    \n    \n    \n    \/\/ 因为是静态方法 无法获取 this 所以不能使用实例内部方法构建方式去构建新对象\n    return new MyPromise((resolve,reject)=\x3e{\n      const iterator = isIterator(promiseArr);\n      \n      if(typeof iterator === \x27string\x27){\n        console.error(iterator);\n        throw new Error(iterator);\n      }\n\n      let data = iterator.next();\n      const result = [];\n      let index = -1; \/\/ Promise 应存放返回数组的位置；\n      let waitPromiseNum = 0; \/\/ 统计未完成的 Promise；\n      \n      let checkAllEnd = () =\x3e {\n        return waitPromiseNum === 0;\n      }\n\n      while (data) {\n        if(data.done) break;\n        index \x2b\x2b;\n        if(Object.prototype.toString.call(data.value) !== \x26quot;[object MyPromise]\x26quot;){\n          result[index] = data.value;\n        } else {\n\n          (index=\x3e{\n            const promise = data.value; \n            waitPromiseNum\x2b\x2b;\n            promise.then(data=\x3e{\n              result[index] = data;\n              waitPromiseNum--;\n              \/\/ 看是否 Promise 全部完成\n              if(checkAllEnd())resolve(result);\n            }).catch(data=\x3ereject(data));\n          })(index)\n\n        }\n        data = iterator.next();\n      }\n\n      if(checkAllEnd())resolve(result);\n    })\n  }\n\n  static race (promiseArr){\n    \n    \/\/ 因为是静态方法 无法获取 this 所以不能使用实例内部方法构建方式去构建新对象\n    return new MyPromise((resolve,reject)=\x3e{\n      const iterator = isIterator(promiseArr);\n\n      if(typeof iterator === \x27string\x27){\n        console.error(iterator);\n        throw new Error(iterator);\n      }\n\n      let data = iterator.next();\n      while (data) {\n        if(data.done) break;\n        if(Object.prototype.toString.call(data.value) !== \x26quot;[object MyPromise]\x26quot;){\n          return resolve(data.value);\n        } else {\n          data.value\n            .then(data=\x3eresolve(data))\n            .catch(data=\x3ereject(data));\n        }\n        data = iterator.next();\n      }\n\n    })\n  }\n\n  \/\/ 测试方法\n\n  MyPromise.all(\n    [\n      MyPromise.resolve(1),\n      new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n      MyPromise.resolve(3)\n    ]).then(data=\x3e{console.log(data)});\n\n  MyPromise.all([\n    1,\n    new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n    MyPromise.resolve(3)\n    ]).then(data=\x3e{console.log(data)});\n\n  MyPromise.all([\n    MyPromise.resolve(1),\n    new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n    MyPromise.reject(3)\n    ]).then(data=\x3e{console.log(data)});\n\n\n  MyPromise.race([\n    MyPromise.resolve(1),\n    new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n    MyPromise.resolve(3)\n    ]).then(data=\x3e{console.log(data)});\n\n  MyPromise.race([\n    1,\n    new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n    MyPromise.resolve(3)\n    ]).then(data=\x3e{console.log(data)});\n    \n  MyPromise.race([\n    MyPromise.resolve(1),\n    new MyPromise(resolve=\x3esetTimeout(()=\x3eresolve(2), 1000)),\n    MyPromise.reject(3)\n    ]).then(data=\x3e{console.log(data)});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ MyPromise.js 最后头\x3c\/span\x3e\n  MyPromise.prototype[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag] = \x3cspan class=\x22hljs-string\x22\x3e\x22MyPromise\x22\x3c\/span\x3e;\n\n\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e all (promiseArr){\n    \n    \n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为是静态方法 无法获取 this 所以不能使用实例内部方法构建方式去构建新对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e iterator = isIterator(promiseArr);\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e iterator === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e){\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(iterator);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(iterator);\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = iterator.next();\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = [];\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Promise 应存放返回数组的位置；\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e waitPromiseNum = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 统计未完成的 Promise；\x3c\/span\x3e\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e checkAllEnd = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e waitPromiseNum === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (data) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data.done) \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        index \x2b\x2b;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(data.value) !== \x3cspan class=\x22hljs-string\x22\x3e\x22[object MyPromise]\x22\x3c\/span\x3e){\n          result[index] = data.value;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n\n          (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eindex\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promise = data.value; \n            waitPromiseNum\x2b\x2b;\n            promise.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n              result[index] = data;\n              waitPromiseNum--;\n              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 看是否 Promise 全部完成\x3c\/span\x3e\n              \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(checkAllEnd())resolve(result);\n            }).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3ereject(data));\n          })(index)\n\n        }\n        data = iterator.next();\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(checkAllEnd())resolve(result);\n    })\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e race (promiseArr){\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为是静态方法 无法获取 this 所以不能使用实例内部方法构建方式去构建新对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e iterator = isIterator(promiseArr);\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e iterator === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e){\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(iterator);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(iterator);\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = iterator.next();\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (data) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data.done) \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(data.value) !== \x3cspan class=\x22hljs-string\x22\x3e\x22[object MyPromise]\x22\x3c\/span\x3e){\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e resolve(data.value);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          data.value\n            .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(data))\n            .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3ereject(data));\n        }\n        data = iterator.next();\n      }\n\n    })\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试方法\x3c\/span\x3e\n\n  MyPromise.all(\n    [\n      MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e),\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n      MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\n\n  MyPromise.all([\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\n\n  MyPromise.all([\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n    MyPromise.reject(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\n\n\n  MyPromise.race([\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\n\n  MyPromise.race([\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\n    \n  MyPromise.race([\n    MyPromise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyPromise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)),\n    MyPromise.reject(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n    ]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e结束\x3c\/h2\x3e\n\x3cblockquote\x3e如果发现过程遇到什么问题，欢迎及时提出。\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>用 class 写法完整实现一个 Promise</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014888354">https://segmentfault.com/a/1190000014888354</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mmxc79xi77j/" target="_blank">https://alili.tech/archive/mmxc79xi77j/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>