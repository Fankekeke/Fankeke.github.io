<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="axios源码解读之请求与拦截器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>axios源码解读之请求与拦截器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mp1naz3t8ah/",
				"appid": "1613049289050283", 
				"title": "axios源码解读之请求与拦截器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/36wz8xwth1c/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xlffks8nyt/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&text=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&text=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&title=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&is_video=false&description=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&title=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&title=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&title=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp1naz3t8ah%2f&title=axios%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8b%a6%e6%88%aa%e5%99%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">axios源码解读之请求与拦截器</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2\x3e前言\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eaxios\x3c\/code\x3e 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。这里将会从功能出发，分析源码，深入了解 axios 是怎么实现这些功能的。\x3c\/p\x3e\n\x3ch3\x3e准备\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eIDE:\x3c\/strong\x3e WebStorm\x3cbr\x3e\x3cstrong\x3eGit地址:\x3c\/strong\x3e  \x3ca href=\x22https:\/\/github.com\/cookhot\/axios\/tree\/analysis\x22 rel=\x22nofollow noreferrer\x22\x3ehttps:\/\/github.com\/cookhot\/ax...\x3c\/a\x3e    注意\x3ccode\x3eanalysis\x3c\/code\x3e分支\x3cbr\x3e\x3cstrong\x3e中文文档:\x3c\/strong\x3e  \x3ca href=\x22https:\/\/www.kancloud.cn\/yunye\/axios\/234845\x22 rel=\x22nofollow noreferrer\x22\x3ehttps:\/\/www.kancloud.cn\/yunye...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2\x3eaxios 请求\x3c\/h2\x3e\n\x3cp\x3e项目的入口是\x3ccode\x3eaxios.js\x3c\/code\x3e, 当\x3ccode\x3eaxios\x3c\/code\x3e在被引入项目中的时候，导入的其实是一个方法，可以直接调用此方法发起请求。\x3c\/p\x3e\n\x3ch4\x3e例子如下:\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport axios from \x27.\/axios\x27\nconsole.log(typeof axios); \/\/ function\naxios({\n  url: \x27http:\/\/localhost:8088\/index\x27\n}).then((res) =\x26gt; {\n  console.log(res)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e源码如下:\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3eaxios.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\x27use strict\x27;\n\nvar utils = require(\x27.\/utils\x27);\nvar bind = require(\x27.\/helpers\/bind\x27);\nvar Axios = require(\x27.\/core\/Axios\x27);\nvar defaults = require(\x27.\/defaults\x27);\n\n\/**\n * 创建 Axios 的一个实例\n * Create an instance of Axios\n * \n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n *\/\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n\n  \/\/ instance 是一个方法, 实际上就是 Axios.prorotype.request， 方法的 this =\x26gt; context\n  var instance = bind(Axios.prototype.request, context);\n\n  \/\/ 把 Axios 原型上面的属性(方法)复制到 instance 上面，保证被复制的方法中 this =\x26gt; context\n  \/\/ 注意 utils.extend 和 utils.merge的区别，两者是不同的\n  utils.extend(instance, Axios.prototype, context);\n\n  \/\/ Copy context to instance\n  \/\/ context 上面的属性都复制到 instance，context.defaults 和 context.interceptors 通过instance能够访问\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n\/\/ Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n\/\/ Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n\/\/ Factory for creating new instances\n\/\/ 创建 Axios 实例\naxios.create = function create(instanceConfig) {\n  \/\/ instanceConfig 是开发者提供的配置属性，将会和 Axios 提供的默认配置属性合并，\n  \/\/ 形成的新的配置属性将会是实例请求的默认属性 (很常用的设计方法)\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n\/\/ Expose Cancel \x26amp; CancelToken\n\/\/ 请求取消\naxios.Cancel = require(\x27.\/cancel\/Cancel\x27);\naxios.CancelToken = require(\x27.\/cancel\/CancelToken\x27);\naxios.isCancel = require(\x27.\/cancel\/isCancel\x27);\n\n\/\/ Expose all\/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require(\x27.\/helpers\/spread\x27);\n\n\/\/ 输出Axios\nmodule.exports = axios;\n\n\/\/ Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的源码中，能够看到\x3ccode\x3eaxios\x3c\/code\x3e其实就是调用的\x3ccode\x3eAxios.prototype.request\x3c\/code\x3e方法，为了防止在运行时候this指向异常，显示的绑定上了context。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\/\/ ...... bind 的实现\nmodule.exports = function bind(fn, thisArg) {\n   \/\/ 使用闭包 和 apply 改变 fn 的 this 指向\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i \x26lt; args.length; i\x2b\x2b) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了能够让开发人员更好的调用get、post、...... 等等方法， 于是把\x3ccode\x3eAxios.prototype\x3c\/code\x3e上面的方法都复制到axios上面。 相应的为了防止这些\x3cstrong\x3e方法\x3c\/strong\x3e中this指向异常，也显示的绑定context, 具体的实现逻辑请看下面 ⤵️ \x3cstrong\x3e对象的复制\x3c\/strong\x3e。 后面的 \x3ccode\x3eutils.extend(instance, context)\x3c\/code\x3e 这行代码是为了帮助我们能够通过axios 访问到 context 上面的属性， context里面包含拦截器(interceptors)以及配置属性值(defaults)。\x3c\/p\x3e\n\x3ch4\x3e对象的复制\x3c\/h4\x3e\n\x3cp\x3eaxios提供了两种的方式来处理对象的合并, 分别是 merge 与 extend。代码被放在utils.js\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\/\/ utils.js\n\/\/ .......\n\/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If \x27obj\x27 is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\/\nfunction forEach(obj, fn) {\n  \/\/ Don\x27t bother if no value provided\n  if (obj === null || typeof obj === \x27undefined\x27) {\n    return;\n  }\n\n  \/\/ Force an array if not already something iterable\n  if (typeof obj !== \x27object\x27) {\n    \/*eslint no-param-reassign:0*\/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    \/\/ Iterate over array values\n    for (var i = 0, l = obj.length; i \x26lt; l; i\x2b\x2b) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    \/\/ Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n\/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); \/\/ outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n *\/\nfunction merge(\/* obj1, obj2, obj3, ... *\/) {\n  \/\/ 使用新的对象，这样就能防止传入的对象在合并的时候被改变\n  var result = {};\n  function assignValue(val, key) {\n   \/\/ 对象的属性复制的时候，当两个属性都是都是对象的时候，就对此属性对象中子属性再进行在复制。\n    \/\/ 作用应该是为了防止前属性对象的属性全被覆盖掉\n    if (typeof result[key] === \x27object\x27 \x26amp;\x26amp; typeof val === \x27object\x27) {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i \x26lt; l; i\x2b\x2b) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n\/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * 这里考虑了复制函数时候的 this 指向问题，设计的很好，以后可以借鉴\n * @param {Object} a The object to be extended    \n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n *\/\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg \x26amp;\x26amp; typeof val === \x27function\x27) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emerge\x3c\/code\x3e 类似于我们经常使用的对象浅拷贝，但是又不全是浅拷贝。在拷贝的时候，发现进行拷贝的两个属性都是都是对象的时候，就对此属性对象中子属性再进行在复制。用于防止前面一个属性对象中的子属性值被全覆盖掉。\x3cbr\x3e\x3ccode\x3eextend\x3c\/code\x3e 也是对象的浅拷贝，不过在拷贝方法的时候，会显示指定方法的\x3cstrong\x3ethis\x3c\/strong\x3e，用于防止this指向异常。\x3c\/p\x3e\n\x3ch4\x3eall以及cancel\x3c\/h4\x3e\n\x3cp\x3eaxios创建请求后会返回一个Promise的实例，\x3ccode\x3ePromise.all\x3c\/code\x3e所返回的promise实例会在传入的promise实例状态都发生变化，才变更状态。所以 \x3ccode\x3eaxios.all\x3c\/code\x3e其实就是调用\x3ccode\x3ePromise.all\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eaxios.all = function all(promises) {\n  return Promise.all(promises);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3ecancel\x3c\/strong\x3e 这里暂时不讨论，后面通过结合 XMLHttpRequest 与 node 的 http 会说的明白的更加清楚。\x3c\/p\x3e\n\x3ch2\x3e请求复用与拦截器\x3c\/h2\x3e\n\x3cp\x3e在看完\x3ccode\x3eaxios.js\x3c\/code\x3e以后，就需要开始了解\x3ccode\x3eAxios\x3c\/code\x3e构造函数的实现了。\x3c\/p\x3e\n\x3ch4\x3e源码如下:\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3eAxios.js\x3c\/strong\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\x27use strict\x27;\n\nvar defaults = require(\x27.\/..\/defaults\x27);\nvar utils = require(\x27.\/..\/utils\x27);\nvar InterceptorManager = require(\x27.\/InterceptorManager\x27);\nvar dispatchRequest = require(\x27.\/dispatchRequest\x27);\n\n\/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\/\nfunction Axios(instanceConfig) {\n  \/\/ instanceConfig =\x26gt; 创建对象的设置的默认值\n  \/\/ Axios 中 defaults 分为三个层次, Axios 默认的defaults \x26lt; 创建实例传入的defaults \x26lt; 调用方法时候传入的defaults\n  \/\/ 个人感觉使用 this.defaults = utils.merge(defaults, instanceConfig) 会更好，当后面使用request发起请求的时候，代码变化如下:\n \/*\n    config = utils.merge(defaults, this.defaults, config); 老代码\n    config = utils.merge(this.defaults, config); \/\/ 新代码\n  *\/\n  this.defaults = instanceConfig;\n  \/\/ 拦截器\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n\/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n *\/\nAxios.prototype.request = function request(config) {\n  \/*eslint no-param-reassign:0*\/\n  \/\/ Allow for axios(\x27example\/url\x27[, config]) a la fetch API\n  \/\/ 重载 request(url, config)\n  \/\/ 可以支持request (config) 也可以支持 request(url, config)\n  if (typeof config === \x27string\x27) {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  \/\/ Hook up interceptors middleware\n  \/\/ 拦截器设计处理\n  \/\/ chain 是一个数组\n  var chain = [dispatchRequest, undefined];\n  \/\/ promise 是调用头，状态已经改变为 resolved\n  var promise = Promise.resolve(config);\n\n  \/\/ 使用 use 添加 fulfilled 与 rejected 添加到队列中\n  \/\/ 添加 request 拦截函数的时候使用的是unshift， 这样会导致 use 后添加的先执行，先添加的后执行\n  \/*\n  axios.interceptors.request.use(function resolve(config) {\n    console.log(\x221\x22);\n  });\n\n  axios.interceptors.request.use(function resolve(config) {\n    console.log(\x222\x22)\n  })\n  \/\/ 结果 2 1\n   *\/\n\n  \/\/ 考虑到后面 是使用 promise的链式调用， 所以在 拦截器的回调方法中 必须要返回一个 config 对象\n  \/\/ 如果不返回 config， 会导致后续请求执行异常\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  \/\/ response 使用的push 添加 拦截函数，这里是添加先执行，后添加后执行\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  \/\/ promise 的初始化状态就是 resolved，这里形成了promise调用链，执行流程过程如下\n\n  \/\/ chain  [fulfilled, rejected, ... dispatchRequest, undefined ....,fulfilled, rejected]\n  \/\/ 这里补充一下 fulfilled, rejected 都是肯定是成对出现的， 具体原因可看 InterceptorManager.prototype.use\n  \/\/ promise.then(undefined, undefined) 中当传递的不是function时，会发生值穿。也就是说 use 中可以传入非function，\n  \/\/ 或者传入单个function\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n\/\/ Provide aliases for supported request methods\n\/\/ 复用request 实现了 delete， get, head, options\nutils.forEach([\x27delete\x27, \x27get\x27, \x27head\x27, \x27options\x27], function forEachMethodNoData(method) {\n  \/*eslint func-names:0*\/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\n\/\/ 复用request 实现了 post， put, patch\nutils.forEach([\x27post\x27, \x27put\x27, \x27patch\x27], function forEachMethodWithData(method) {\n  \/*eslint func-names:0*\/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eAxios.js\x3c\/code\x3e主要处理了两个部分，复用请求方法、实现拦截器。\x3c\/p\x3e\n\x3cp\x3e当我们使用 Axios 的实例去发送请求，使用的方法get、post等都是复用了request方法，在request方法中通过 arguments 获取传入的参数，实现了传入参数的重载。\x3c\/p\x3e\n\x3cp\x3e拦截器是axios的一大特色，它的实现原理其实不复杂，核心就是promise的链式调用。 \x3cbr\x3e原理可以参考下图:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV9dFQ?w=1085\x26amp;h=514\x22 src=\x22https:\/\/static.alili.tech\/img\/bV9dFQ?w=1085\x26amp;h=514\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22\x3e\x3c\/span\x3e\x3cbr\x3e然后附上\x3ccode\x3eInterceptorManager.js\x3c\/code\x3e的源码，但是个人觉得这里没有什么好说的，其实就是对一个数组的操作。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\x27use strict\x27;\n\nvar utils = require(\x27.\/..\/utils\x27);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n\/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n *\/\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  \/\/ fulfilled =\x26gt; 成功方法\n  \/\/ rejected =\x26gt; 失败方法\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n\/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n *\/\n\/\/ 把数组中 对象设置为 null\nInterceptorManager.prototype.reject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n\/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n *\/\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  \/\/ 遍历运行数组\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你看完上面的源码解读，能够清楚的明白下面这段代码执行顺序，那么就说明你掌握axios拦截器的实现了\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e  \/\/ 拦截器的执行顺序\n  \/*\n  axios.interceptors.request.use(function resolve(config) {\n    console.log(\x22request\x22);\n    return config;\n  });\n\n  axios.interceptors.response.use(function resolve(res) {\n    console.log(\x27response\x27)\n    return res\n  });\n\n  axios.get(\x27http:\/\/localhost:3000\/index\x27).then(function resolve(res) {\n      console.log(\x27ajax\x27);\n      return res\n  }).then(function(){\n    console.log(\x27end\x27)\n  })\n   *\/\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e第一篇总算是写完了，后续还有关于\x3ccode\x3eaxios\x3c\/code\x3e3篇的源码解读，如果大家觉得写的还行的话，麻烦给一个赞?，鼓励鼓励，谢谢了\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>axios源码解读之请求与拦截器</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014551905">https://segmentfault.com/a/1190000014551905</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mp1naz3t8ah/" target="_blank">https://alili.tech/archive/mp1naz3t8ah/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>