<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【Vue源码】Vue中DOM的异步更新策略以及nextTick机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【Vue源码】Vue中DOM的异步更新策略以及nextTick机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mw3k1l3omtn/",
				"appid": "1613049289050283", 
				"title": "【Vue源码】Vue中DOM的异步更新策略以及nextTick机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hxhpm63xv8i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ppfplswksqh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&text=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&text=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&title=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&is_video=false&description=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&title=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&title=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&title=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw3k1l3omtn%2f&title=%e3%80%90Vue%e6%ba%90%e7%a0%81%e3%80%91Vue%e4%b8%adDOM%e7%9a%84%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8anextTick%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【Vue源码】Vue中DOM的异步更新策略以及nextTick机制</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e本篇文章主要是对\x3ccode\x3eVue\x3c\/code\x3e中的\x3ccode\x3eDOM\x3c\/code\x3e异步更新策略和\x3ccode\x3enextTick\x3c\/code\x3e机制的解析，需要读者有一定的\x3ccode\x3eVue\x3c\/code\x3e使用经验并且熟悉掌握JavaScript事件循环模型。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e引入：DOM的异步更新\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ctemplate\x3e\n  \x3cdiv\x3e\n    \x3cdiv ref=\x26quot;test\x26quot;\x3e\x22{{\x22test\x22}}\x22\x3c\/div\x3e\n    \x3cbutton @click=\x26quot;handleClick\x26quot;\x3etet\x3c\/button\x3e\n  \x3c\/div\x3e\n\x3c\/template\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22test\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x22{{\x22test\x22}}\x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22handleClick\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3etet\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default {\n    data () {\n        return {\n            test: \x27begin\x27\n        };\n    },\n    methods () {\n        handleClick () {\n            this.test = \x27end\x27;\n            console.log(this.$refs.test.innerText);\/\/打印“begin”\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n    data () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e\n        };\n    },\n    methods () {\n        handleClick () {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.test = \x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$refs.test.innerText);\x3cspan class=\x22hljs-comment\x22\x3e\/\/打印“begin”\x3c\/span\x3e\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e打印的结果是\x3ccode\x3ebegin\x3c\/code\x3e而不是我们设置的\x3ccode\x3eend\x3c\/code\x3e。这个结果足以说明\x3ccode\x3eVue\x3c\/code\x3e中\x3ccode\x3eDOM\x3c\/code\x3e的更新并非同步。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eVue\x3c\/code\x3e官方文档中是这样说明的：\x3c\/p\x3e\n\x3cblockquote\x3e可能你还没有注意到，\x3ccode\x3eVue\x3c\/code\x3e异步执行\x3ccode\x3eDOM\x3c\/code\x3e更新。只要观察到数据变化，\x3ccode\x3eVue\x3c\/code\x3e将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个\x3ccode\x3ewatcher\x3c\/code\x3e被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和\x3ccode\x3eDOM\x3c\/code\x3e操作上非常重要。然后，在下一个的事件循环“\x3ccode\x3etick\x3c\/code\x3e”中，\x3ccode\x3eVue\x3c\/code\x3e刷新队列并执行实际 (已去重的) 工作。\x3c\/blockquote\x3e\n\x3cp\x3e简而言之，就是在一个事件循环中发生的所有数据改变都会在下一个事件循环的\x3ccode\x3eTick\x3c\/code\x3e中来触发视图更新，这也是一个“批处理”的过程。（注意下一个事件循环的\x3ccode\x3eTick\x3c\/code\x3e有可能是在当前的\x3ccode\x3eTick\x3c\/code\x3e微任务执行阶段执行，也可能是在下一个\x3ccode\x3eTick\x3c\/code\x3e执行，主要取决于\x3ccode\x3enextTick\x3c\/code\x3e函数到底是使用\x3ccode\x3ePromise\/MutationObserver\x3c\/code\x3e还是\x3ccode\x3esetTimeout\x3c\/code\x3e）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eWatcher队列\x3c\/h3\x3e\n\x3cp\x3e在\x3ccode\x3eWatcher\x3c\/code\x3e的源码中，我们发现\x3ccode\x3ewatcher\x3c\/code\x3e的\x3ccode\x3eupdate\x3c\/code\x3e其实是异步的。（注：\x3ccode\x3esync\x3c\/code\x3e属性默认为\x3ccode\x3efalse\x3c\/code\x3e，也就是异步）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22update () {\n    \/* istanbul ignore else *\/\n    if (this.lazy) {\n        this.dirty = true\n    } else if (this.sync) {\n        \/*同步则执行run直接渲染视图*\/\n        this.run()\n    } else {\n        \/*异步推送到观察者队列中，下一个tick时调用。*\/\n        queueWatcher(this)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eupdate () {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*同步则执行run直接渲染视图*\/\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run()\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*异步推送到观察者队列中，下一个tick时调用。*\/\x3c\/span\x3e\n        queueWatcher(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3equeueWatcher(this)\x3c\/code\x3e函数的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*\/\nexport function queueWatcher (watcher: Watcher) {\n    \/*获取watcher的id*\/\n    const id = watcher.id\n    \/*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*\/\n    if (has[id] == null) {\n        has[id] = true\n        if (!flushing) {\n            \/*如果没有flush掉，直接push到队列中即可*\/\n            queue.push(watcher)\n        } else {\n        ...\n        }\n        \/\/ queue the flush\n        if (!waiting) {\n            waiting = true\n            nextTick(flushSchedulerQueue)\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3equeueWatcher\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ewatcher: Watcher\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*获取watcher的id*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e id = watcher.id\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (has[id] == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        has[id] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!flushing) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/*如果没有flush掉，直接push到队列中即可*\/\x3c\/span\x3e\n            queue.push(watcher)\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        ...\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ queue the flush\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!waiting) {\n            waiting = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n            nextTick(flushSchedulerQueue)\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段源码有几个需要注意的地方：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e首先需要知道的是\x3ccode\x3ewatcher\x3c\/code\x3e执行\x3ccode\x3eupdate\x3c\/code\x3e的时候，默认情况下肯定是异步的，它会做以下的两件事：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e判断\x3ccode\x3ehas\x3c\/code\x3e数组中是否有这个\x3ccode\x3ewatcher\x3c\/code\x3e的\x3ccode\x3eid\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e如果有的话是不需要把\x3ccode\x3ewatcher\x3c\/code\x3e加入\x3ccode\x3equeue\x3c\/code\x3e中的，否则不做任何处理。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e这里面的\x3ccode\x3enextTick(flushSchedulerQueue)\x3c\/code\x3e中，\x3ccode\x3eflushScheduleQueue\x3c\/code\x3e函数的作用主要是执行视图更新的操作，它会把\x3ccode\x3equeue\x3c\/code\x3e中所有的\x3ccode\x3ewatcher\x3c\/code\x3e取出来并执行相应的视图更新。\x3c\/li\x3e\n\x3cli\x3e核心其实是\x3ccode\x3enextTick\x3c\/code\x3e函数了，下面我们具体看一下\x3ccode\x3enextTick\x3c\/code\x3e到底有什么用。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3enextTick\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3enextTick\x3c\/code\x3e函数其实做了两件事情，一是生成一个\x3ccode\x3etimerFunc\x3c\/code\x3e，把回调作为\x3ccode\x3emicroTask\x3c\/code\x3e或\x3ccode\x3emacroTask\x3c\/code\x3e参与到事件循环中来。二是把回调函数放入一个\x3ccode\x3ecallbacks\x3c\/code\x3e队列，等待适当的时机执行。（这个时机和\x3ccode\x3etimerFunc\x3c\/code\x3e不同的实现有关）\x3c\/p\x3e\n\x3cp\x3e首先我们先来看它是怎么生成一个\x3ccode\x3etimerFunc\x3c\/code\x3e把回调作为\x3ccode\x3emicroTask\x3c\/code\x3e或\x3ccode\x3emacroTask\x3c\/code\x3e的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (typeof Promise !== \x27undefined\x27 \x26amp;\x26amp; isNative(Promise)) {\n    \/*使用Promise*\/\n    var p = Promise.resolve()\n    var logError = err =\x3e { console.error(err) }\n    timerFunc = () =\x3e {\n        p.then(nextTickHandler).catch(logError)\n        \/\/ in problematic UIWebViews, Promise.then doesn\x27t completely break, but\n        \/\/ it can get stuck in a weird state where callbacks are pushed into the\n        \/\/ microTask queue but the queue isn\x27t being flushed, until the browser\n        \/\/ needs to do some other work, e.g. handle a timer. Therefore we can\n        \/\/ \x26quot;force\x26quot; the microTask queue to be flushed by adding an empty timer.\n        if (isIOS) setTimeout(noop)\n    }\n} else if (typeof MutationObserver !== \x27undefined\x27 \x26amp;\x26amp; (\n    isNative(MutationObserver) ||\n    \/\/ PhantomJS and iOS 7.x\n    MutationObserver.toString() === \x27[object MutationObserverConstructor]\x27\n    )) {\n    \/\/ use MutationObserver where native Promise is not available,\n    \/\/ e.g. PhantomJS IE11, iOS7, Android 4.4\n    \/*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*\/\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(String(counter))\n    observer.observe(textNode, {\n        characterData: true\n    })\n    timerFunc = () =\x3e {\n        counter = (counter \x2b 1) % 2\n        textNode.data = String(counter)\n    }\n} else {\n    \/\/ fallback to setTimeout\n    \/* istanbul ignore next *\/\n    \/*使用setTimeout将回调推入任务队列尾部*\/\n    timerFunc = () =\x3e {\n        setTimeout(nextTickHandler, 0)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; isNative(\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*使用Promise*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve()\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e logError = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err) }\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        p.then(nextTickHandler).catch(logError)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in problematic UIWebViews, Promise.then doesn\x27t completely break, but\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ it can get stuck in a weird state where callbacks are pushed into the\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ microTask queue but the queue isn\x27t being flushed, until the browser\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ needs to do some other work, e.g. handle a timer. Therefore we can\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22force\x22 the microTask queue to be flushed by adding an empty timer.\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isIOS) setTimeout(noop)\n    }\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e MutationObserver !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; (\n    isNative(MutationObserver) ||\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ PhantomJS and iOS 7.x\x3c\/span\x3e\n    MutationObserver.toString() === \x3cspan class=\x22hljs-string\x22\x3e\x27[object MutationObserverConstructor]\x27\x3c\/span\x3e\n    )) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use MutationObserver where native Promise is not available,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ e.g. PhantomJS IE11, iOS7, Android 4.4\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(nextTickHandler)\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e textNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter))\n    observer.observe(textNode, {\n        \x3cspan class=\x22hljs-attr\x22\x3echaracterData\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    })\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        counter = (counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n        textNode.data = \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter)\n    }\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fallback to setTimeout\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore next *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*使用setTimeout将回调推入任务队列尾部*\/\x3c\/span\x3e\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        setTimeout(nextTickHandler, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e值得注意的是，它会按照\x3ccode\x3ePromise\x3c\/code\x3e、\x3ccode\x3eMutationObserver\x3c\/code\x3e、\x3ccode\x3esetTimeout\x3c\/code\x3e优先级去调用传入的回调函数。前两者会生成一个\x3ccode\x3emicroTask\x3c\/code\x3e任务，而后者会生成一个\x3ccode\x3emacroTask\x3c\/code\x3e。（微任务和宏任务）\x3c\/p\x3e\n\x3cp\x3e之所以会设置这样的优先级，主要是考虑到浏览器之间的兼容性（\x3ccode\x3eIE\x3c\/code\x3e没有内置\x3ccode\x3ePromise\x3c\/code\x3e）。另外，设置\x3ccode\x3ePromise\x3c\/code\x3e最优先是因为\x3ccode\x3ePromise.resolve().then\x3c\/code\x3e回调函数属于一个\x3cstrong\x3e微任务\x3c\/strong\x3e，浏览器在一个\x3ccode\x3eTick\x3c\/code\x3e中执行完\x3ccode\x3emacroTask\x3c\/code\x3e后会清空当前\x3ccode\x3eTick\x3c\/code\x3e所有的\x3ccode\x3emicroTask\x3c\/code\x3e再进行\x3ccode\x3eUI\x3c\/code\x3e渲染，把\x3ccode\x3eDOM\x3c\/code\x3e更新的操作放在\x3ccode\x3eTick\x3c\/code\x3e执行\x3ccode\x3emicroTask\x3c\/code\x3e的阶段来完成，相比使用\x3ccode\x3esetTimeout\x3c\/code\x3e生成的一个\x3ccode\x3emacroTask\x3c\/code\x3e会少一次\x3ccode\x3eUI\x3c\/code\x3e的渲染。\x3c\/p\x3e\n\x3cp\x3e而\x3ccode\x3enextTickHandler\x3c\/code\x3e函数，其实才是我们真正要执行的函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function nextTickHandler () {\n    pending = false\n    \/*执行所有callback*\/\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i \x3c copies.length; i\x2b\x2b) {\n        copies[i]()\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enextTickHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    pending = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*执行所有callback*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e copies = callbacks.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n    callbacks.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; copies.length; i\x2b\x2b) {\n        copies[i]()\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的\x3ccode\x3ecallbacks\x3c\/code\x3e变量供\x3ccode\x3enextTickHandler\x3c\/code\x3e消费。而前面我们所说的\x3ccode\x3enextTick\x3c\/code\x3e函数第二点功能中“等待适当的时机执行”，其实就是因为\x3ccode\x3etimerFunc\x3c\/code\x3e的实现方式有差异，如果是\x3ccode\x3ePromise\\MutationObserver\x3c\/code\x3e则\x3ccode\x3enextTickHandler\x3c\/code\x3e回调是一个\x3ccode\x3emicroTask\x3c\/code\x3e，它会在当前\x3ccode\x3eTick\x3c\/code\x3e的末尾来执行。如果是\x3ccode\x3esetTiemout\x3c\/code\x3e则\x3ccode\x3enextTickHandler\x3c\/code\x3e回调是一个\x3ccode\x3emacroTask\x3c\/code\x3e，它会在下一个\x3ccode\x3eTick\x3c\/code\x3e来执行。\x3c\/p\x3e\n\x3cp\x3e还有就是\x3ccode\x3ecallbacks\x3c\/code\x3e中的成员是如何被\x3ccode\x3epush\x3c\/code\x3e进来的？从源码中我们可以知道，\x3ccode\x3enextTick\x3c\/code\x3e是一个自执行的函数，一旦执行是\x3ccode\x3ereturn\x3c\/code\x3e了一个\x3ccode\x3equeueNextTick\x3c\/code\x3e，所以我们在调用\x3ccode\x3enextTick\x3c\/code\x3e其实就是在调用\x3ccode\x3equeueNextTick\x3c\/code\x3e这个函数。它的源代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return function queueNextTick (cb?: Function, ctx?: Object) {\n    let _resolve\n    \/*cb存到callbacks中*\/\n    callbacks.push(() =\x3e {\n        if (cb) {\n            try {\n            cb.call(ctx)\n            } catch (e) {\n            handleError(e, ctx, \x27nextTick\x27)\n            }\n        } else if (_resolve) {\n            _resolve(ctx)\n        }\n    })\n    if (!pending) {\n        pending = true\n        timerFunc()\n    }\n    if (!cb \x26amp;\x26amp; typeof Promise !== \x27undefined\x27) {\n        return new Promise((resolve, reject) =\x3e {\n            _resolve = resolve\n        })\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3equeueNextTick\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecb?: Function, ctx?: Object\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e _resolve\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*cb存到callbacks中*\/\x3c\/span\x3e\n    callbacks.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb) {\n            \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            cb.call(ctx)\n            } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n            handleError(e, ctx, \x3cspan class=\x22hljs-string\x22\x3e\x27nextTick\x27\x3c\/span\x3e)\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_resolve) {\n            _resolve(ctx)\n        }\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!pending) {\n        pending = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        timerFunc()\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!cb \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            _resolve = resolve\n        })\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，一旦调用\x3ccode\x3enextTick\x3c\/code\x3e函数时候，传入的\x3ccode\x3efunction\x3c\/code\x3e就会被存放到\x3ccode\x3ecallbacks\x3c\/code\x3e闭包中，然后这个\x3ccode\x3ecallbacks\x3c\/code\x3e由\x3ccode\x3enextTickHandler\x3c\/code\x3e消费，而\x3ccode\x3enextTickHandler\x3c\/code\x3e的执行时间又是由\x3ccode\x3etimerFunc\x3c\/code\x3e来决定。\x3c\/p\x3e\n\x3cp\x3e我们再回来看\x3ccode\x3eWatcher\x3c\/code\x3e中的一段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*\/\nexport function queueWatcher (watcher: Watcher) {\n  \/*获取watcher的id*\/\n  const id = watcher.id\n  \/*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*\/\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n        \/*如果没有flush掉，直接push到队列中即可*\/\n        queue.push(watcher)\n    } else {\n      ...\n    }\n    \/\/ queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3equeueWatcher\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ewatcher: Watcher\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*获取watcher的id*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e id = watcher.id\n  \x3cspan class=\x22hljs-comment\x22\x3e\/*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (has[id] == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    has[id] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!flushing) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*如果没有flush掉，直接push到队列中即可*\/\x3c\/span\x3e\n        queue.push(watcher)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      ...\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ queue the flush\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!waiting) {\n      waiting = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里面的\x3ccode\x3enextTick(flushSchedulerQueue)\x3c\/code\x3e中的\x3ccode\x3eflushSchedulerQueue\x3c\/code\x3e函数其实就是\x3ccode\x3ewatcher\x3c\/code\x3e的视图更新。调用的时候会把它\x3ccode\x3epush\x3c\/code\x3e到\x3ccode\x3ecallbacks\x3c\/code\x3e中来异步执行。\x3c\/p\x3e\n\x3cp\x3e另外，关于\x3ccode\x3ewaiting\x3c\/code\x3e变量，这是很重要的一个标志位，它保证\x3ccode\x3eflushSchedulerQueue\x3c\/code\x3e回调只允许被置入\x3ccode\x3ecallbacks\x3c\/code\x3e一次。\x3c\/p\x3e\n\x3cp\x3e也就是说，默认\x3ccode\x3ewaiting\x3c\/code\x3e变量为\x3ccode\x3efalse\x3c\/code\x3e，执行一次后\x3ccode\x3ewaiting\x3c\/code\x3e为\x3ccode\x3etrue\x3c\/code\x3e，后续的\x3ccode\x3ethis.xxx\x3c\/code\x3e不会再次触发\x3ccode\x3enextTick\x3c\/code\x3e的执行，而是把\x3ccode\x3ethis.xxx\x3c\/code\x3e相对应的\x3ccode\x3ewatcher\x3c\/code\x3e推入\x3ccode\x3eflushSchedulerQueue\x3c\/code\x3e的\x3ccode\x3equeue\x3c\/code\x3e队列中。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e所以，也就是说\x3ccode\x3eDOM\x3c\/code\x3e确实是异步更新，但是具体是在下一个\x3ccode\x3eTick\x3c\/code\x3e更新还是在当前\x3ccode\x3eTick\x3c\/code\x3e执行\x3ccode\x3emicroTask\x3c\/code\x3e的时候更新，具体要看\x3ccode\x3enextTcik\x3c\/code\x3e的实现方式，也就是具体跑的是\x3ccode\x3ePromise\/MutationObserver\x3c\/code\x3e还是\x3ccode\x3esetTimeout\x3c\/code\x3e。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e附：\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown#nexttick\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3enextTick\x3c\/code\x3e源码带注释\x3c\/a\x3e，有兴趣可以观摩一下。\x3c\/p\x3e\n\x3cp\x3e这里面使用\x3ccode\x3ePromise\x3c\/code\x3e和\x3ccode\x3esetTimeout\x3c\/code\x3e来执行异步任务的方式都很好理解，比较巧妙的地方是利用\x3ccode\x3eMutationObserver\x3c\/code\x3e执行异步任务。\x3ccode\x3eMutationObserver\x3c\/code\x3e是\x3ccode\x3eH5\x3c\/code\x3e的新特性，它能够监听指定范围内的\x3ccode\x3eDOM\x3c\/code\x3e变化并执行其回调，它的回调会被当作\x3ccode\x3emicroTask\x3c\/code\x3e来执行，具体参考\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/MutationObserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eMDN\x3c\/code\x3e\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var counter = 1\nvar observer = new MutationObserver(nextTickHandler)\nvar textNode = document.createTextNode(String(counter))\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () =\x3e {\n    counter = (counter \x2b 1) % 2\n    textNode.data = String(counter)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(nextTickHandler)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e textNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter))\nobserver.observe(textNode, {\n    \x3cspan class=\x22hljs-attr\x22\x3echaracterData\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n})\ntimerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    counter = (counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    textNode.data = \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，通过借用\x3ccode\x3eMutationObserver\x3c\/code\x3e来创建一个\x3ccode\x3emicroTask\x3c\/code\x3e。\x3ccode\x3enextTickHandler\x3c\/code\x3e作为回调传入\x3ccode\x3eMutationObserver\x3c\/code\x3e中。  \x3cbr\x3e这里面创建了一个\x3ccode\x3etextNode\x3c\/code\x3e作为观测的对象，当\x3ccode\x3etimerFunc\x3c\/code\x3e执行的时候，\x3ccode\x3etextNode.data\x3c\/code\x3e会发生改变，便会触发\x3ccode\x3eMutatinObservers\x3c\/code\x3e的回调函数，而这个函数才是我们真正要执行的任务，它是一个\x3ccode\x3emicroTask\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e注：\x3ccode\x3e2.5\x2b\x3c\/code\x3e版本的\x3ccode\x3eVue\x3c\/code\x3e对\x3ccode\x3enextTick\x3c\/code\x3e进行了修改，具体参考下面“版本升级”一节。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e关于Vue暴露的全局\x3ccode\x3enextTick\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e继续来看下面的这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;example\x26quot;\x3e\n    \x3cdiv ref=\x26quot;test\x26quot;\x3e\x22{{\x22test\x22}}\x22\x3c\/div\x3e\n    \x3cbutton @click=\x26quot;handleClick\x26quot;\x3etet\x3c\/button\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22example\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22test\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x22{{\x22test\x22}}\x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22handleClick\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3etet\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vm = new Vue({\n    el: \x27#example\x27,\n    data: {\n        test: \x27begin\x27,\n    },\n    methods: {\n        handleClick() {\n            this.test = \x27end\x27;\n            console.log(\x271\x27)\n            setTimeout(() =\x3e { \/\/ macroTask\n                console.log(\x273\x27)\n            }, 0);\n            Promise.resolve().then(function() { \/\/microTask\n                console.log(\x27promise!\x27)\n            })\n            this.$nextTick(function () {\n                console.log(\x272\x27)\n            })\n        }\n    }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#example\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e,\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n        handleClick() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.test = \x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e)\n            setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ macroTask\x3c\/span\x3e\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e)\n            }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/microTask\x3c\/span\x3e\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise!\x27\x3c\/span\x3e)\n            })\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e)\n            })\n        }\n    }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3eChrome\x3c\/code\x3e下，这段代码执行的顺序的\x3ccode\x3e1、2、promise、3\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e可能有同学会以为这是\x3ccode\x3e1、promise、2、3\x3c\/code\x3e，其实是忽略了一个标志位\x3ccode\x3epending\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e我们回到\x3ccode\x3enextTick\x3c\/code\x3e函数\x3ccode\x3ereturn\x3c\/code\x3e的\x3ccode\x3equeueNextTick\x3c\/code\x3e可以发现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return function queueNextTick (cb?: Function, ctx?: Object) {\n    let _resolve\n    \/*cb存到callbacks中*\/\n    callbacks.push(() =\x3e {\n        if (cb) {\n        try {\n            cb.call(ctx)\n        } catch (e) {\n            handleError(e, ctx, \x27nextTick\x27)\n        }\n        } else if (_resolve) {\n        _resolve(ctx)\n        }\n    })\n    if (!pending) {\n        pending = true\n        timerFunc()\n    }\n    if (!cb \x26amp;\x26amp; typeof Promise !== \x27undefined\x27) {\n        return new Promise((resolve, reject) =\x3e {\n        _resolve = resolve\n        })\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3equeueNextTick\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecb?: Function, ctx?: Object\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e _resolve\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*cb存到callbacks中*\/\x3c\/span\x3e\n    callbacks.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb) {\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n            cb.call(ctx)\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n            handleError(e, ctx, \x3cspan class=\x22hljs-string\x22\x3e\x27nextTick\x27\x3c\/span\x3e)\n        }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_resolve) {\n        _resolve(ctx)\n        }\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!pending) {\n        pending = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        timerFunc()\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!cb \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        _resolve = resolve\n        })\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里面通过对\x3ccode\x3epending\x3c\/code\x3e的判断来检测是否已经有\x3ccode\x3etimerFunc\x3c\/code\x3e这个函数在事件循环的任务队列等待被执行。如果存在的话，那么是不会再重复执行的。\x3c\/p\x3e\n\x3cp\x3e最后异步执行\x3ccode\x3enextTickHandler\x3c\/code\x3e时又会把\x3ccode\x3epending\x3c\/code\x3e置为\x3ccode\x3efalse\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function nextTickHandler () {\n    pending = false\n    \/*执行所有callback*\/\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i \x3c copies.length; i\x2b\x2b) {\n        copies[i]()\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enextTickHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    pending = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*执行所有callback*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e copies = callbacks.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n    callbacks.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; copies.length; i\x2b\x2b) {\n        copies[i]()\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以回到我们的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22handleClick() {\n    this.test = \x27end\x27;\n    console.log(\x271\x27)\n    setTimeout(() =\x3e { \/\/ macroTask\n        console.log(\x273\x27)\n    }, 0);\n    Promise.resolve().then(function() { \/\/microTask\n        console.log(\x27promise!\x27)\n    });\n    this.$nextTick(function () {\n        console.log(\x272\x27)\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ehandleClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.test = \x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e)\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ macroTask\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/microTask\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise!\x27\x3c\/span\x3e)\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e)\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码中，\x3ccode\x3ethis.test = \x27end\x27\x3c\/code\x3e必然会触发\x3ccode\x3ewatcher\x3c\/code\x3e进行视图的重新渲染，而我们在文章的\x3ccode\x3eWatcher\x3c\/code\x3e一节中就已经有提到会调用\x3ccode\x3enextTick\x3c\/code\x3e函数，一开始\x3ccode\x3epending\x3c\/code\x3e变量肯定就是\x3ccode\x3efalse\x3c\/code\x3e，因此它会被修改为\x3ccode\x3etrue\x3c\/code\x3e并且执行\x3ccode\x3etimerFunc\x3c\/code\x3e。之后执行\x3ccode\x3ethis.$nextTick\x3c\/code\x3e其实还是调用的\x3ccode\x3enextTick\x3c\/code\x3e函数，只不过此时的\x3ccode\x3epending\x3c\/code\x3e为\x3ccode\x3etrue\x3c\/code\x3e说明\x3ccode\x3etimerFunc\x3c\/code\x3e已经被生成，所以\x3ccode\x3ethis.$nextTick(fn)\x3c\/code\x3e只是把传入的\x3ccode\x3efn\x3c\/code\x3e置入\x3ccode\x3ecallbacks\x3c\/code\x3e之中。此时的\x3ccode\x3ecallbacks\x3c\/code\x3e有两个\x3ccode\x3efunction\x3c\/code\x3e成员，一个是\x3ccode\x3eflushSchedulerQueue\x3c\/code\x3e，另外一个就是\x3ccode\x3ethis.$nextTick()\x3c\/code\x3e的回调。\x3c\/p\x3e\n\x3cp\x3e因此，上面这段代码中，在\x3ccode\x3eChrome\x3c\/code\x3e下，有一个\x3ccode\x3emacroTask\x3c\/code\x3e和两个\x3ccode\x3emicroTask\x3c\/code\x3e。一个\x3ccode\x3emacroTask\x3c\/code\x3e就是\x3ccode\x3esetTimeout\x3c\/code\x3e，两个\x3ccode\x3emicroTask\x3c\/code\x3e：分别是\x3ccode\x3eVue\x3c\/code\x3e的\x3ccode\x3etimerFunc\x3c\/code\x3e（其中先后执行\x3ccode\x3eflushSchedulerQueue\x3c\/code\x3e和\x3ccode\x3efunction() {console.log(\x272\x27)}\x3c\/code\x3e）、代码中的\x3ccode\x3ePromise.resolve().then()\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e版本升级带来的变化\x3c\/h3\x3e\n\x3cp\x3e上面讨论的\x3ccode\x3enextTick\x3c\/code\x3e实现是\x3ccode\x3e2.4\x3c\/code\x3e版本以下的实现，\x3ccode\x3e2.5\x3c\/code\x3e以上版本对于\x3ccode\x3enextTick\x3c\/code\x3e的内部实现进行了大量的修改。\x3c\/p\x3e\n\x3ch4\x3e独立文件\x3c\/h4\x3e\n\x3cp\x3e首先是从\x3ccode\x3eVue 2.5\x2b\x3c\/code\x3e开始，抽出来了一个单独的文件\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/util\/next-tick.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3enext-tick.js\x3c\/code\x3e\x3c\/a\x3e来执行它。\x3c\/p\x3e\n\x3ch4\x3emicroTask与macroTask\x3c\/h4\x3e\n\x3cp\x3e在代码中，有这么一段注释：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013314898?w=857\x26amp;h=248\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013314898?w=857\x26amp;h=248\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其大概的意思就是：在\x3ccode\x3eVue 2.4\x3c\/code\x3e之前的版本中，\x3ccode\x3enextTick\x3c\/code\x3e几乎都是基于\x3ccode\x3emicroTask\x3c\/code\x3e实现的（具体可以看文章\x3ccode\x3enextTick\x3c\/code\x3e一节），但是由于\x3ccode\x3emicroTask\x3c\/code\x3e的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，就会导致一些诡异的问题；但是如果全部都改成\x3ccode\x3emacroTask\x3c\/code\x3e，对一些有重绘和动画的场景也会有性能的影响。\x3cstrong\x3e所以最终\x3ccode\x3enextTick\x3c\/code\x3e采取的策略是默认走\x3ccode\x3emicroTask\x3c\/code\x3e，对于一些\x3ccode\x3eDOM\x3c\/code\x3e的交互事件，如\x3ccode\x3ev-on\x3c\/code\x3e绑定的事件回调处理函数的处理，会强制走\x3ccode\x3emacroTask\x3c\/code\x3e。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e具体做法就是，在\x3ccode\x3eVue\x3c\/code\x3e执行绑定的\x3ccode\x3eDOM\x3c\/code\x3e事件时，默认会给回调的\x3ccode\x3ehandler\x3c\/code\x3e函数调用\x3ccode\x3ewithMacroTask\x3c\/code\x3e方法做一层包装，它保证整个回调函数的执行过程中，遇到数据状态的改变，这些改变而导致的视图更新（\x3ccode\x3eDOM\x3c\/code\x3e更新）的任务都会被推到\x3ccode\x3emacroTask\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add$1 (event, handler, once$$1, capture, passive) {\n    handler = withMacroTask(handler);\n    if (once$$1) { handler = createOnceHandler(handler, event, capture); }\n    target$1.addEventListener(\n        event,\n        handler,\n        supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n}\n\n\/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a Task instead of a MicroTask.\n *\/\nfunction withMacroTask (fn) {\n    return fn._withTask || (fn._withTask = function () {\n        useMacroTask = true;\n        var res = fn.apply(null, arguments);\n        useMacroTask = false;\n        return res\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd$1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent, handler, once$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, capture, passive\x3c\/span\x3e) \x3c\/span\x3e{\n    handler = withMacroTask(handler);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (once$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) { handler = createOnceHandler(handler, event, capture); }\n    target$\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3eaddEventListener(\n        event,\n        handler,\n        supportsPassive\n        ? { \x3cspan class=\x22hljs-attr\x22\x3ecapture\x3c\/span\x3e: capture, \x3cspan class=\x22hljs-attr\x22\x3epassive\x3c\/span\x3e: passive }\n        : capture\n    );\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a Task instead of a MicroTask.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewithMacroTask\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn._withTask || (fn._withTask = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        useMacroTask = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = fn.apply(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n        useMacroTask = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而对于\x3ccode\x3emacroTask\x3c\/code\x3e的执行，\x3ccode\x3eVue\x3c\/code\x3e优先检测是否支持原生\x3ccode\x3esetImmediate\x3c\/code\x3e（高版本IE和Edge支持），不支持的话再去检测是否支持原生\x3ccode\x3eMessageChannel\x3c\/code\x3e，如果还不支持的话为\x3ccode\x3esetTimeout(fn, 0)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e最后，写一段demo来测试一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;example\x26quot;\x3e\n    \x3cspan\x3e\x22{{\x22test\x22}}\x22\x3c\/span\x3e\n    \x3cbutton @click=\x26quot;handleClick\x26quot;\x3echange\x3c\/button\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22example\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x22{{\x22test\x22}}\x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22handleClick\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3echange\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vm = new Vue({\n    el: \x27#example\x27,\n    data: {\n        test: \x27begin\x27,\n    },\n    methods: {\n        handleClick: function() {\n            this.test = end;\n            console.log(\x27script\x27)\n            this.$nextTick(function () { \n                console.log(\x27nextTick\x27)\n            })\n            Promise.resolve().then(function () {\n                console.log(\x27promise\x27)\n            })\n        }\n    }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#example\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e,\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3ehandleClick\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.test = end;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27script\x27\x3c\/span\x3e)\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27nextTick\x27\x3c\/span\x3e)\n            })\n            \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise\x27\x3c\/span\x3e)\n            })\n        }\n    }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3eVue 2.5\x2b\x3c\/code\x3e中，这段代码的输出顺序是\x3ccode\x3escript\x3c\/code\x3e、\x3ccode\x3epromise\x3c\/code\x3e、\x3ccode\x3enextTick\x3c\/code\x3e，而\x3ccode\x3eVue 2.4\x3c\/code\x3e输出\x3ccode\x3escript\x3c\/code\x3e、\x3ccode\x3enextTick\x3c\/code\x3e、\x3ccode\x3epromise\x3c\/code\x3e。\x3ccode\x3enextTick\x3c\/code\x3e执行顺序的差异正好说明了上面的改变。\x3c\/p\x3e\n\x3ch4\x3eMessageChannel\x3c\/h4\x3e\n\x3cp\x3e在\x3ccode\x3eVue 2.4\x3c\/code\x3e版本以前使用的\x3ccode\x3eMutationObserver\x3c\/code\x3e来模拟异步任务。而\x3ccode\x3eVue 2.5\x3c\/code\x3e版本以后，由于兼容性弃用了\x3ccode\x3eMutationObserver\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eVue 2.5\x2b\x3c\/code\x3e版本使用了\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/MessageChannel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eMessageChannel\x3c\/code\x3e\x3c\/a\x3e来模拟\x3ccode\x3emacroTask\x3c\/code\x3e。除了\x3ccode\x3eIE\x3c\/code\x3e以外，\x3ccode\x3emessageChannel\x3c\/code\x3e的兼容性还是比较可观的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const channel = new MessageChannel()\nconst port = channel.port2\nchannel.port1.onmessage = flushCallbacks\nmacroTimerFunc = () =\x3e {\nport.postMessage(1)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e channel = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MessageChannel()\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e port = channel.port2\nchannel.port1.onmessage = flushCallbacks\nmacroTimerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\nport.postMessage(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可见，新建一个\x3ccode\x3eMessageChannel\x3c\/code\x3e对象，该对象通过\x3ccode\x3eport1\x3c\/code\x3e来检测信息，\x3ccode\x3eport2\x3c\/code\x3e发送信息。通过\x3ccode\x3eport2\x3c\/code\x3e的主动\x3ccode\x3epostMessage\x3c\/code\x3e来触发\x3ccode\x3eport1\x3c\/code\x3e的\x3ccode\x3eonmessage\x3c\/code\x3e事件，进而把回调函数\x3ccode\x3eflushCallbacks\x3c\/code\x3e作为\x3ccode\x3emacroTask\x3c\/code\x3e参与事件循环。\x3c\/p\x3e\n\x3ch4\x3eMessageChannel VS setTimeout\x3c\/h4\x3e\n\x3cp\x3e为什么要优先\x3ccode\x3eMessageChannel\x3c\/code\x3e创建\x3ccode\x3emacroTask\x3c\/code\x3e而不是\x3ccode\x3esetTimeout\x3c\/code\x3e？\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eHTML5\x3c\/code\x3e中规定\x3ccode\x3esetTimeout\x3c\/code\x3e的最小时间延迟是\x3ccode\x3e4ms\x3c\/code\x3e，也就是说理想环境下异步回调最快也是\x3ccode\x3e4ms\x3c\/code\x3e才能触发。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e使用这么多函数来模拟异步任务，其目的只有一个，就是\x3cstrong\x3e让回调异步且尽早调用\x3c\/strong\x3e。而\x3ccode\x3eMessageChannel\x3c\/code\x3e的延迟明显是小于\x3ccode\x3esetTimeout\x3c\/code\x3e的。\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/18826570\/settimeout0-vs-window-postmessage-vs-messageport-postmessage\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对比传送门\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e为什么要异步更新视图\x3c\/h3\x3e\n\x3cp\x3e看下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ctemplate\x3e\n  \x3cdiv\x3e\n    \x3cdiv\x3e\x22{{\x22test\x22}}\x22\x3c\/div\x3e\n  \x3c\/div\x3e\n\x3c\/template\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x22{{\x22test\x22}}\x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default {\n    data () {\n        return {\n            test: 0\n        };\n    },\n    mounted () {\n      for(let i = 0; i \x3c 1000; i\x2b\x2b) {\n        this.test\x2b\x2b;\n      }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n    data () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        };\n    },\n    mounted () {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.test\x2b\x2b;\n      }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在有这样的一种情况，\x3ccode\x3emounted\x3c\/code\x3e的时候\x3ccode\x3etest\x3c\/code\x3e的值会被\x3ccode\x3e\x2b\x2b\x3c\/code\x3e循环执行\x3ccode\x3e1000\x3c\/code\x3e次。 每次\x3ccode\x3e\x2b\x2b\x3c\/code\x3e时，都会根据响应式触发\x3ccode\x3esetter-\x26gt;Dep-\x26gt;Watcher-\x26gt;update-\x26gt;run\x3c\/code\x3e。 如果这时候没有异步更新视图，那么每次\x3ccode\x3e\x2b\x2b\x3c\/code\x3e都会直接操作\x3ccode\x3eDOM\x3c\/code\x3e更新视图，这是非常消耗性能的。 所以\x3ccode\x3eVue\x3c\/code\x3e实现了一个\x3ccode\x3equeue\x3c\/code\x3e队列，在下一个\x3ccode\x3eTick\x3c\/code\x3e（或者是当前\x3ccode\x3eTick\x3c\/code\x3e的微任务阶段）的时候会统一执行\x3ccode\x3equeue\x3c\/code\x3e中\x3ccode\x3eWatcher\x3c\/code\x3e的\x3ccode\x3erun\x3c\/code\x3e。同时，拥有相同\x3ccode\x3eid\x3c\/code\x3e的\x3ccode\x3eWatcher\x3c\/code\x3e不会被重复加入到该\x3ccode\x3equeue\x3c\/code\x3e中去，所以不会执行\x3ccode\x3e1000\x3c\/code\x3e次\x3ccode\x3eWatcher\x3c\/code\x3e的\x3ccode\x3erun\x3c\/code\x3e。最终更新视图只会直接将\x3ccode\x3etest\x3c\/code\x3e对应的\x3ccode\x3eDOM\x3c\/code\x3e的\x3ccode\x3e0\x3c\/code\x3e变成\x3ccode\x3e1000\x3c\/code\x3e。 保证更新视图操作\x3ccode\x3eDOM\x3c\/code\x3e的动作是在当前栈执行完以后下一个\x3ccode\x3eTick\x3c\/code\x3e（或者是当前\x3ccode\x3eTick\x3c\/code\x3e的微任务阶段）的时候调用，大大优化了性能。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e应用场景\x3c\/h3\x3e\n\x3cp\x3e在操作\x3ccode\x3eDOM\x3c\/code\x3e节点无效的时候，就要考虑操作的实际\x3ccode\x3eDOM\x3c\/code\x3e节点是否存在，或者相应的\x3ccode\x3eDOM\x3c\/code\x3e是否被更新完毕。\x3c\/p\x3e\n\x3cp\x3e比如说，在\x3ccode\x3ecreated\x3c\/code\x3e钩子中涉及\x3ccode\x3eDOM\x3c\/code\x3e节点的操作肯定是无效的，因为此时还没有完成相关\x3ccode\x3eDOM\x3c\/code\x3e的挂载。解决的方法就是在\x3ccode\x3enextTick\x3c\/code\x3e函数中去处理\x3ccode\x3eDOM\x3c\/code\x3e，这样才能保证\x3ccode\x3eDOM\x3c\/code\x3e被成功挂载而有效操作。\x3c\/p\x3e\n\x3cp\x3e还有就是在数据变化之后要执行某个操作，而这个操作需要使用随数据改变而改变的\x3ccode\x3eDOM\x3c\/code\x3e时，这个操作应该放进\x3ccode\x3eVue.nextTick\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e之前在做慕课网音乐\x3ccode\x3ewebApp\x3c\/code\x3e的时候关于播放器内核的开发就涉及到了这个问题。下面我把问题简化：\x3c\/p\x3e\n\x3cp\x3e现在我们要实现一个需求是点击按钮变换\x3ccode\x3eaudio\x3c\/code\x3e标签的\x3ccode\x3esrc\x3c\/code\x3e属性来实现切换歌曲。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;example\x26quot;\x3e\n    \x3caudio ref=\x26quot;audio\x26quot;\n           :src=\x26quot;url\x26quot;\x3e\x3c\/audio\x3e\n    \x3cspan ref=\x26quot;url\x26quot;\x3e\x3c\/span\x3e\n    \x3cbutton @click=\x26quot;changeUrl\x26quot;\x3eclick me\x3c\/button\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22example\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eaudio\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22audio\x22\x3c\/span\x3e\n           \x3cspan class=\x22hljs-attr\x22\x3e:src\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22url\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eaudio\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22url\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22changeUrl\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eclick me\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const musicList = [\n    \x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112003137.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27,\n    \x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112002493.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27,\n    \x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112004168.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27\n];\nvar vm = new Vue({\n    el: \x27#example\x27,\n    data: {\n        index: 0,\n        url: \x27\x27\n    },\n    methods: {\n        changeUrl() {\n            this.index = (this.index \x2b 1) % musicList.length\n            this.url = musicList[this.index];\n            this.$refs.audio.play();\n        }\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e musicList = [\n    \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112003137.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112002493.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/sc1.111ttt.cn:8282\/2017\/1\/11m\/11\/304112004168.m4a?tflag=1519095601\x26amp;pin=6cd414115fdb9a950d827487b16b5f97#.mp3\x27\x3c\/span\x3e\n];\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#example\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3eindex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n        changeUrl() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.index = (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.index \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) % musicList.length\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.url = musicList[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.index];\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$refs.audio.play();\n        }\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e毫无悬念，这样肯定是会报错的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Uncaught (in promise) DOMException: The element has no supported sources.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eUncaught (\x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e promise) DOMException: The element has no supported sources.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原因就在于\x3ccode\x3eaudio.play()\x3c\/code\x3e是同步的，而这个时候\x3ccode\x3eDOM\x3c\/code\x3e更新是异步的，\x3ccode\x3esrc\x3c\/code\x3e属性还没有被更新，结果播放的时候\x3ccode\x3esrc\x3c\/code\x3e属性为空，就报错了。\x3c\/p\x3e\n\x3cp\x3e解决办法就是在\x3ccode\x3eplay\x3c\/code\x3e的操作加上\x3ccode\x3ethis.$nextTick()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.$nextTick(function() {\n    this.$refs.audio.play();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$refs.audio.play();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e参考链接\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/youngwind\/blog\/issues\/88\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/youngwind\/...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/answershuto\/learnVue\/blob\/master\/docs\/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/answershut...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5a1af88f5188254a701ec230\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/juejin.im\/post\/5a1af8...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【Vue源码】Vue中DOM的异步更新策略以及nextTick机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013314893">https://segmentfault.com/a/1190000013314893</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mw3k1l3omtn/" target="_blank">https://alili.tech/archive/mw3k1l3omtn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>