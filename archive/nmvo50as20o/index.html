<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="组件复用那些事儿 - React 实现按需加载轮子"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>组件复用那些事儿 - React 实现按需加载轮子 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/nmvo50as20o/",
				"appid": "1613049289050283", 
				"title": "组件复用那些事儿 - React 实现按需加载轮子 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9150dq89z85/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dcrg18ypxw7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&text=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&text=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&title=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&is_video=false&description=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&title=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&title=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&title=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnmvo50as20o%2f&title=%e7%bb%84%e4%bb%b6%e5%a4%8d%e7%94%a8%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20React%20%e5%ae%9e%e7%8e%b0%e6%8c%89%e9%9c%80%e5%8a%a0%e8%bd%bd%e8%bd%ae%e5%ad%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">组件复用那些事儿 - React 实现按需加载轮子</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e组件化在当今前端开发领域中是一个非常重要的概念。著名的前端类库，比如 React、Vue 等对此概念都倍加推崇。确实，组件化复用性（reusability）和模块性（modularization）的优点对于复杂场景需求具有先天优势。组件就如同乐高积木、建筑石块一般，一点点拼接构成了我们的应用。\x3c\/p\x3e\n\x3cp\x3e同时，懒加载（Lazy-loading）／按需加载概念至关重要。它对于页面性能优化，用户体验提升提供了新思路。在必要情况下，我们请求的资源更少、解析的脚本更少、执行的内容更少，达到效果也就越好。\x3c\/p\x3e\n\x3cp\x3e这篇文章将从懒加载时机、组件复用手段、代码实例三方面来分析，happy reading!\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e按需加载场景设计分析\x3c\/h2\x3e\n\x3cp\x3e一个典型的页面如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014434036\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014434036\x22 alt=\x22页面构成\x22 title=\x22页面构成\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e它包含了以下几个区块：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e一个头部 header；\x3c\/li\x3e\n\x3cli\x3e图片展示区；\x3c\/li\x3e\n\x3cli\x3e地图展现区；\x3c\/li\x3e\n\x3cli\x3e页面 footer。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对应代码示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Page = () =\x3e {\n  \x3cdiv\x3e\n    \x3cHeader \/\x3e\n    \x3cGallery \/\x3e\n    \x3cMap \/\x3e\n    \x3cFooter \/\x3e\n  \x3c\/div\x3e\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Page = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x26lt;div\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eGallery\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMap\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eFooter\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当用户来访时，如果不滚动页面，只能看见头部区域。但在很多场景下，我们都会加载所有的 JavaScript 脚本、 CSS 资源以及其他资源，进而渲染了完整页面。这明显是不必要的，消耗了更多带宽，延迟了页面 load 时间。为此，前端历史上做过很多懒加载探索，很多大公司的开源作品应势而出：比如 Yahoo 的 \x3ca href=\x22https:\/\/yuilibrary.com\/yui\/docs\/yui\/loader.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eYUI Loader\x3c\/a\x3e，Facebook 的 \x3ca href=\x22https:\/\/jmperezperez.com\/facebook-frontend-javascript\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHaste, Bootloader and Primer\x3c\/a\x3e等。时至今日，这些实现懒加载脚本的代码仍有学习意义。这里不再展开。\x3c\/p\x3e\n\x3cp\x3e如下图，在正常逻辑情况下，代码覆盖率层面，我们看到 1.1MB\/1.5MB (76%) 的代码并没有应用到。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014434037\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014434037\x22 alt=\x22代码覆盖率\x22 title=\x22代码覆盖率\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e另外，并不是所有资源都需要进行懒加载，我们在设计层面上需要考虑以下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e不要按需加载首屏内容\x3c\/strong\x3e。这很好理解，首屏时间至关重要，用户能够越早看到越好。那么如何定义首屏内容？这需要结合用户终端，站点布局来考虑；\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e预先懒加载\x3c\/strong\x3e。我们应该避免给用户呈现空白内容，因此预先懒加载，提前执行脚本对于用户体验的提升非常明显。比如下图，在图片出现在屏幕 100px 时，提前进行图片请求和渲染；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014434038\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014434038\x22 alt=\x22预先加载\x22 title=\x22预先加载\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cstrong\x3e懒加载对 SEO 的影响\x3c\/strong\x3e。这里面涉及到内容较多，需要开发者了解搜索引擎爬虫机制。以 Googlebot 为例，它支持 IntersectionObserver，但是也仅仅对视口里内容起作用。这里不再详细展开，感兴趣的读者可以通过\x3ca href=\x22https:\/\/jmperezperez.com\/lazy-load\/89b6f20e1d79e9fb902242ab84217b12.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e测试页面\x3c\/a\x3e以及\x3ca href=\x22https:\/\/github.com\/JMPerez\/lazy-load\/blob\/master\/text-above-fold.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e测试页面源码\x3c\/a\x3e，并结合 Google 站长工具：Fetch as Google 进行试验。\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eReact 组件复用技术\x3c\/h2\x3e\n\x3cp\x3e提到组件复用，大多开发者应该对高阶组件并不陌生。这类组件接受其他组件，进行功能增强，并最终返回一个组件进行消费。React-redux 的 connect 即是一个 currying 化的典型应用，代码示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const MyComponent = props =\x3e (\n  \x3cdiv\x3e\n    {props.id} - {props.name}\n  \x3c\/div\x3e\n);\n\/\/ ...\nconst ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)( MyComponent );\n\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MyComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    {props.id} - {props.name}\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)( MyComponent );\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样，Function as Child Component 或者称为 Render Callback 技术也较为常用。很多 React 类库比如 react-media 和 unstated 都有广泛使用。以 react-media 为例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const MyComponent = () =\x3e (\n  \x3cMedia query=\x26quot;(max-width: 599px)\x26quot;\x3e\n    {matches =\x3e\n      matches ? (\n        \x3cp\x3eThe document is less than 600px wide.\x3c\/p\x3e\n      ) : ( \x3cp\x3eThe document is at least 600px wide.\x3c\/p\x3e\n      )\n    }\n  \x3c\/Media\x3e\n);\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MyComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMedia\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3equery\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22(max-width: 599px)\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    {matches =\x26gt;\n      matches ? (\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eThe document is less than 600px wide.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      ) : ( \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eThe document is at least 600px wide.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      )\n    }\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eMedia\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n);\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eMedia 组件将会调用其 children 进行渲染，核心逻辑为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Media extends React.Component {\n    ...\n    render() {\n        React.Children.only(children)\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMedia\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n    render() {\n        \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eChildren\x3c\/span\x3e.only(children)\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，子组件并不需要感知 media query 逻辑，进而完成复用。\x3c\/p\x3e\n\x3cp\x3e除此之外，还有很多组件复用技巧，比如 render props 等，这里不再一一分析。\x3cstrong\x3e感兴趣的读者可以在我的新书中找到相关内容。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e代码实战\x3c\/h2\x3e\n\x3cp\x3e下面让我们动手实现一个按需加载轮子。首先需要设计一个 Observer 组件，这个组件将会去检测目标区块是否在视口之中可见。为了简化不必要的逻辑，我们使用 \x3ca href=\x22https:\/\/developer.mozilla.org\/docs\/Web\/API\/Intersection_Observer_API\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIntersection Observer API\x3c\/a\x3e，这个方法异步观察目标元素的可视状态。其兼容性可以参考\x3ca href=\x22https:\/\/caniuse.com\/#search=intersectionobserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Observer extends Component {\n  constructor() {\n    super();\n    this.state = { isVisible: false };\n    this.io = null;\n    this.container = null;\n  }\n  componentDidMount() {\n    this.io = new IntersectionObserver([entry] =\x3e {\n      this.setState({ isVisible: entry.isIntersecting });\n    }, {});\n    this.io.observe(this.container);\n  }\n  componentWillUnmount() {\n    if (this.io) {\n      this.io.disconnect();\n    }\n  }\n  render() {\n    return (\n      \/\/ 这里也可以使用 findDOMNode 实现，但是不建议\n      \x3cdiv\n        ref={div =\x3e {\n          this.container = div;\n        \x22}}\x22\n      \x3e\n        {Array.isArray(this.props.children)\n          ? this.props.children.map(child =\x3e child(this.state.isVisible))\n          : this.props.children(this.state.isVisible)}\n      \x3c\/div\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { isVisible: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = new IntersectionObserver([entry] =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ isVisible: entry.isIntersecting });\n    }, {});\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.observe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container);\n  }\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.disconnect();\n    }\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里也可以使用 findDOMNode 实现，但是不建议\x3c\/span\x3e\n      \x26lt;div\n        ref={div =\x26gt; {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = div;\n        \x22}}\x22\n      \x26gt;\n        {Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children)\n          ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children.map(child =\x26gt; child(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.isVisible))\n          : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.isVisible)}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上，该组件具有 isVisible 状态，表示目标元素是否可见。this.io 表示当前 IntersectionObserver 实例；this.container 表示当前观察元素，它通过 ref 来完成目标元素的获取。\x3c\/p\x3e\n\x3cp\x3ecomponentDidMount 方法中，我们进行 this.setState.isVisible 状态的切换；在 componentWillUnmount 方法中，进行垃圾回收。\x3c\/p\x3e\n\x3cp\x3e很明显，这种复用方式为前文提到的 Function as Child Component。\x3c\/p\x3e\n\x3cp\x3e注意，对于上述基本实现，我们完全可以进行自定义的个性化设置。IntersectionObserver 支持 margins 或者 thresholds 的选项。我们可以在 constructor 里实现配置项目初始化，在 componentWillReceiveProps 生命周期函数中进行更新。\x3c\/p\x3e\n\x3cp\x3e这样一来，针对前文页面内容，我们可以进行 Gallery 组件和 Map 组件懒加载处理：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Page = () =\x3e {\n    \x3cdiv\x3e\n        \x3cHeader \/\x3e\n        \x3cObserver\x3e\n          {isVisible =\x3e \x3cGallery isVisible \/\x3e}\n        \x3c\/Observer\x3e\n        \x3cObserver\x3e\n          {isVisible =\x3e \x3cMap isVisible \/\x3e}\n        \x3c\/Observer\x3e\n        \x3cFooter \/\x3e\n    \x3c\/div\x3e\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3econst Page = () =\x26gt; {\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHeader\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eObserver\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          {isVisible =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eGallery\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eisVisible\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eObserver\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eObserver\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          {isVisible =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMap\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eisVisible\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eObserver\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eFooter\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将 isVisible 状态进行传递。相应消费组件可以根据 isVisible 进行选择性渲染。具体实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Map extends Component {\n  constructor() {\n    super();\n    this.state = { initialized: false };\n    this.map = null;\n  }\ninitializeMap() {\n    this.setState({ initialized: true });\n    \/\/ 加载第三方 Google map\n    loadScript(\x26quot;https:\/\/maps.google.com\/maps\/api\/js?key=\x3cyour_key\x3e\x26quot;, () =\x3e {\n      const latlng = new google.maps.LatLng(38.34, -0.48);\n      const myOptions = { zoom: 15, center: latlng };\n      const map = new google.maps.Map(this.map, myOptions);\n    });\n  }\ncomponentDidMount() {\n    if (this.props.isVisible) {\n      this.initializeMap();\n    }\n  }\ncomponentWillReceiveProps(nextProps) {\n    if (!this.state.initialized \x26amp;\x26amp; nextProps.isVisible) {\n      this.initializeMap();\n    }\n  }\nrender() {\n    return (\n      \x3cdiv\n        ref={div =\x3e {\n          this.map = div;\n        \x22}}\x22\n      \/\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMap\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { initialized: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.map = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\ninitializeMap() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ initialized: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载第三方 Google map\x3c\/span\x3e\n    loadScript(\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/maps.google.com\/maps\/api\/js?key=\x26lt;your_key\x26gt;\x22\x3c\/span\x3e, () =\x26gt; {\n      const latlng = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e google.maps.\x3cspan class=\x22hljs-type\x22\x3eLatLng\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e38.34\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-0.48\x3c\/span\x3e);\n      const myOptions = { zoom: \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, center: latlng };\n      const map = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e google.maps.\x3cspan class=\x22hljs-type\x22\x3eMap\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.map, myOptions);\n    });\n  }\ncomponentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isVisible) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initializeMap();\n    }\n  }\ncomponentWillReceiveProps(nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.initialized \x26amp;\x26amp; nextProps.isVisible) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initializeMap();\n    }\n  }\nrender() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\n        ref={div =\x26gt; {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.map = div;\n        \x22}}\x22\n      \/\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e只有当 Map 组件对应的 container 出现在视口时，我们再去进行第三方资源的加载。\x3c\/p\x3e\n\x3cp\x3e同样，对于 Gallery 组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Gallery extends Component {\n  constructor() {\n    super();\n    this.state = { hasBeenVisible: false };\n  }\n  componentDidMount() {\n    if (this.props.isVisible) {\n      this.setState({ hasBeenVisible: true });\n    }\n  }\n  componentWillReceiveProps(nextProps) {\n    if (!this.state.hasBeenVisible \x26amp;\x26amp; nextProps.isVisible) {\n      this.setState({ hasBeenVisible: true });\n    }\n  }\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3ch1\x3eSome pictures\x3c\/h1\x3e\n        Picture 1\n        {this.state.hasBeenVisible ? (\n          \x3cimg src=\x26quot;http:\/\/example.com\/image01.jpg\x26quot; width=\x26quot;300\x26quot; height=\x26quot;300\x26quot; \/\x3e\n        ) : (\n          \x3cdiv className=\x26quot;placeholder\x26quot; \/\x3e\n        )}\n        Picture 2\n        {this.state.hasBeenVisible ? (\n          \x3cimg src=\x26quot;http:\/\/example.com\/image02.jpg\x26quot; width=\x26quot;300\x26quot; height=\x26quot;300\x26quot; \/\x3e\n        ) : (\n          \x3cdiv className=\x26quot;placeholder\x26quot; \/\x3e\n        )}\n      \x3c\/div\x3e\n    );\n  }\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGallery\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { hasBeenVisible: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e };\n  }\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isVisible) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ hasBeenVisible: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n    }\n  }\n  componentWillReceiveProps(nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasBeenVisible \x26amp;\x26amp; nextProps.isVisible) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ hasBeenVisible: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n    }\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eSome\x3c\/span\x3e pictures\x26lt;\/h1\x26gt;\n        \x3cspan class=\x22hljs-type\x22\x3ePicture\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasBeenVisible ? (\n          \x26lt;img src=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/example.com\/image01.jpg\x22\x3c\/span\x3e width=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e height=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e \/\x26gt;\n        ) : (\n          \x26lt;div className=\x3cspan class=\x22hljs-string\x22\x3e\x22placeholder\x22\x3c\/span\x3e \/\x26gt;\n        )}\n        \x3cspan class=\x22hljs-type\x22\x3ePicture\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasBeenVisible ? (\n          \x26lt;img src=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/example.com\/image02.jpg\x22\x3c\/span\x3e width=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e height=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e \/\x26gt;\n        ) : (\n          \x26lt;div className=\x3cspan class=\x22hljs-string\x22\x3e\x22placeholder\x22\x3c\/span\x3e \/\x26gt;\n        )}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也可以使用无状态组件／函数式组件实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Gallery = ({ isVisible }) =\x3e (\n  \x3cdiv\x3e\n    \x3ch1\x3eSome pictures\x3c\/h1\x3e\n    Picture 1\n    {isVisible ? (\n      \x3cimg src=\x26quot;http:\/\/example.com\/image01.jpg\x26quot; width=\x26quot;300\x26quot; height=\x26quot;300\x26quot; \/\x3e\n    ) : (\n      \x3cdiv className=\x26quot;placeholder\x26quot; \/\x3e\n    )}\n    Picture 2\n    {isVisible ? (\n      \x3cimg src=\x26quot;http:\/\/example.com\/image02.jpg\x26quot; width=\x26quot;300\x26quot; height=\x26quot;300\x26quot; \/\x3e\n    ) : (\n      \x3cdiv className=\x26quot;placeholder\x26quot; \/\x3e\n    )}\n  \x3c\/div\x3e\n);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lisp\x22\x3e\x3ccode\x3econst Gallery = ({ isVisible }) =\x26gt; (\n  \x3cspan class=\x22hljs-name\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n    \x26lt;h1\x26gt;Some pictures\x26lt;\/h1\x26gt;\n    Picture \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    {isVisible ? (\n      \x3cspan class=\x22hljs-name\x22\x3e\x26lt;img\x3c\/span\x3e src=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/example.com\/image01.jpg\x22\x3c\/span\x3e width=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e height=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e \/\x26gt;\n    ) : (\n      \x3cspan class=\x22hljs-name\x22\x3e\x26lt;div\x3c\/span\x3e className=\x3cspan class=\x22hljs-string\x22\x3e\x22placeholder\x22\x3c\/span\x3e \/\x26gt;\n    )}\n    Picture \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    {isVisible ? (\n      \x3cspan class=\x22hljs-name\x22\x3e\x26lt;img\x3c\/span\x3e src=\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/example.com\/image02.jpg\x22\x3c\/span\x3e width=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e height=\x3cspan class=\x22hljs-string\x22\x3e\x22300\x22\x3c\/span\x3e \/\x26gt;\n    ) : (\n      \x3cspan class=\x22hljs-name\x22\x3e\x26lt;div\x3c\/span\x3e className=\x3cspan class=\x22hljs-string\x22\x3e\x22placeholder\x22\x3c\/span\x3e \/\x26gt;\n    )}\n  \x26lt;\/div\x26gt;\n)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样无疑更加简洁。但是当元素移出视口时，相应图片不会再继续展现，而是复现了 placeholder。\x3c\/p\x3e\n\x3cp\x3e如果我们需要懒加载的内容只在页面生命周期中记录一次，可以设置 hasBeenVisible 参数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Page = () =\x3e {\n  ...\n  \x3cObserver\x3e\n    {(isVisible, hasBeenVisible) =\x3e\n      \x3cGallery hasBeenVisible \/\x3e \/\/ Gallery can be now stateless\n    }\n  \x3c\/Observer\x3e\n  ...\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Page = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  ...\n  \x26lt;Observer\x26gt;\n    {(isVisible, hasBeenVisible) =\x26gt;\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eGallery\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehasBeenVisible\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e \/\/ Gallery can be now stateless\n    }\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eObserver\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  ...\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者直接实现 ObserverOnce 组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ObserverOnce extends Component {\n  constructor() {\n    super();\n    this.state = { hasBeenVisible: false };\n    this.io = null;\n    this.container = null;\n  }\n  componentDidMount() {\n    this.io = new IntersectionObserver(entries =\x3e {\n      entries.forEach(entry =\x3e {\n        if (entry.isIntersecting) {\n          this.setState({ hasBeenVisible: true });\n          this.io.disconnect();\n        }\n      });\n    }, {});\n    this.io.observe(this.container);\n  }\n  componentWillUnmount() {\n    if (this.io) {\n      this.io.disconnect();\n    }\n  }\n  render() {\n    return (\n      \x3cdiv\n        ref={div =\x3e {\n          this.container = div;\n        \x22}}\x22\n      \x3e\n        {Array.isArray(this.props.children)\n          ? this.props.children.map(child =\x3e child(this.state.hasBeenVisible))\n          : this.props.children(this.state.hasBeenVisible)}\n      \x3c\/div\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserverOnce\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { hasBeenVisible: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = new IntersectionObserver(entries =\x26gt; {\n      entries.forEach(entry =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (entry.isIntersecting) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ hasBeenVisible: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.disconnect();\n        }\n      });\n    }, {});\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.observe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container);\n  }\n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.disconnect();\n    }\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\n        ref={div =\x26gt; {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = div;\n        \x22}}\x22\n      \x26gt;\n        {Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children)\n          ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children.map(child =\x26gt; child(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasBeenVisible))\n          : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.hasBeenVisible)}\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e更多场景\x3c\/h2\x3e\n\x3cp\x3e上面我们使用了 Observer 组件去加载资源。包括了 Google Map 第三方内容和图片。我们同样可以完成“当组件出现在视口时，才展现元素动画”的需求。\x3c\/p\x3e\n\x3cp\x3e仿照 React Alicante 网站，我们实现了类似的按需执行动画需求。具体可见 \x3ca href=\x22https:\/\/codepen.io\/jmperez\/pen\/LQXjYv\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecodepen 地址。\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22jmperez\/pen\/LQXjYv\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eIntersectionObserver polyfilling\x3c\/h2\x3e\n\x3cp\x3e前面提到了 IntersectionObserver API 的兼容性，这自然就绕不开 polyfill 话题。\x3c\/p\x3e\n\x3cp\x3e一种处理兼容性的选项是“渐进增强”（progressive enhancement），即只有在支持的场景下实现按需加载，否则永远设置 isVisible 状态为 true:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Observer extends Component {\n  constructor() {\n    super();\n    this.state = { isVisible: !(window.IntersectionObserver) };\n    this.io = null;\n    this.container = null;\n  }\n  componentDidMount() {\n    if (window.IntersectionObserver) {\n      this.io = new IntersectionObserver(entries =\x3e {\n        ...\n      }\n    }\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { isVisible: !(window.\x3cspan class=\x22hljs-type\x22\x3eIntersectionObserver\x3c\/span\x3e) };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (window.\x3cspan class=\x22hljs-type\x22\x3eIntersectionObserver\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eIntersectionObserver\x3c\/span\x3e(entries =\x26gt; {\n        ...\n      }\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样显然不能实现按需的目的，我更加推荐 w3c 的 \x3ca href=\x22https:\/\/github.com\/w3c\/IntersectionObserver\/tree\/master\/polyfill\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIntersectionObserver polyfill\x3c\/a\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Observer extends Component {\n  ...\n  componentDidMount() {\n    (window.IntersectionObserver\n      ? Promise.resolve()\n      : import(\x27intersection-observer\x27)\n    ).then(() =\x3e {\n      this.io = new window.IntersectionObserver(entries =\x3e {\n        entries.forEach(entry =\x3e {\n          this.setState({ isVisible: entry.isIntersecting });\n        });\n      }, {});\n      this.io.observe(this.container);\n    });\n  }\n  ...\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  ...\n  componentDidMount() {\n    (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.IntersectionObserver\n      ? \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve()\n      : \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27intersection-observer\x27\x3c\/span\x3e)\n    ).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.IntersectionObserver(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eentries\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        entries.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eentry\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3eisVisible\x3c\/span\x3e: entry.isIntersecting });\n        });\n      }, {});\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.io.observe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container);\n    });\n  }\n  ...\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当浏览器不支持 IntersectionObserver 时，我们动态 import 进来 polyfill，这就需要支持 dynamic import，此为另外话题，这里不再展开。\x3c\/p\x3e\n\x3cp\x3e最后试验一下，在不支持的 Safari 浏览器下，我们看到 Network 时间线如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014434039\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014434039\x22 alt=\x22时间线\x22 title=\x22时间线\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e这篇文章介绍涉及到组件复用、按需加载（懒加载）实现内容。更多相关知识，可以关注作者新书。\x3cbr\x3e同时这篇文章截取于 \x3ca href=\x22https:\/\/medium.freecodecamp.org\/@jmperezperez?source=post_header_lockup\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJosé M. Pérez\x3c\/a\x3e 的 Improve the Performance of your Site with Lazy-Loading and Code-Splitting，部分内容有所改动。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e广告时间：\x3c\/strong\x3e\x3cbr\x3e如果你对前端发展，尤其对 React 技术栈感兴趣：我的新书中，也许有你想看到的内容。关注作者 \x3ca href=\x22https:\/\/www.zhihu.com\/people\/lucas-hc\/activities\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLucas HC\x3c\/a\x3e，新书出版将会有送书活动。\x3c\/p\x3e\n\x3cp\x3eHappy Coding!\x3c\/p\x3e\n\x3cp\x3ePS: 作者\x26nbsp;\x3ca href=\x22http:\/\/link.zhihu.com\/?target=https%3A\/\/github.com\/HOUCe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub仓库\x3c\/a\x3e\x26nbsp;和\x26nbsp;\x3ca href=\x22https:\/\/www.zhihu.com\/people\/lucas-hc\/answers\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e知乎问答链接\x3c\/a\x3e\x26nbsp;欢迎各种形式交流。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>组件复用那些事儿 - React 实现按需加载轮子</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014434030">https://segmentfault.com/a/1190000014434030</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/nmvo50as20o/" target="_blank">https://alili.tech/archive/nmvo50as20o/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>