<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="玩转 React（五）- 组件的内部状态和生命周期"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>玩转 React（五）- 组件的内部状态和生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/nuae8gc8ve/",
				"appid": "1613049289050283", 
				"title": "玩转 React（五）- 组件的内部状态和生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-27T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/kmizakochtb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/930y1ayqice/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&text=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&text=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&is_video=false&description=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnuae8gc8ve%2f&title=%e7%8e%a9%e8%bd%ac%20React%ef%bc%88%e4%ba%94%ef%bc%89-%20%e7%bb%84%e4%bb%b6%e7%9a%84%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">玩转 React（五）- 组件的内部状态和生命周期</h1><div class="meta"><div class="postdate"><time datetime="2018-12-27" itemprop="datePublished">2018-12-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e文章标题总算是可以正常一点了……\x3c\/p\x3e\n\x3cp\x3e通过之前的文章我们已经知道：在 React 体系中所谓的 \x22在 JavaScript 中编写 HTML 代码\x22 指的是 React 扩展了 JavaScript 的语法，也就是 JSX。JSX 语法中可以以类似 HTML 语法的方式使用 React 组件，从而编写 React 组件就有一种创造一个新的 HTML 标签的体验。\x3c\/p\x3e\n\x3cp\x3e上一篇文章\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000011502742\x22\x3e《玩转 React（四）- 创造一个新的 HTML 标签》\x3c\/a\x3e介绍了如何来创建一个 React 组件，以及组件的属性。了解到组件的视图是属性的映射，通过改变组件属性可以触发组件重新渲染，从而改变组件的视图。其实组件的视图并不仅仅是由属性映射来的，本篇将介绍另一种可以触发组件重新渲染的方式，即组件的内部状态（state），严格来说组件的视图是由属性和内部状态映射而来的，即：\x3ccode\x3eview = f(props, state)\x3c\/code\x3e，跟属性类似，状态的改变也会触发组件重新渲染，只不过状态是组件内部基于自身逻辑或者用户事件自己维护的，而不是由外部输入的。\x3c\/p\x3e\n\x3cp\x3e另外本文中会介绍一个通过类继承方式定义的组件的生命周期，以及在各个生命周期函数中能做什么，不能或尽量不要做什么。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e内容摘要\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eReactDOM.render\x3c\/code\x3e 在一个单页面 web 应用中通常只调用一次。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件可以通过 \x3ccode\x3esetState\x3c\/code\x3e 改变内部状态 \x3ccode\x3estate\x3c\/code\x3e 来更新视图。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3esetState\x3c\/code\x3e \x3cstrong\x3e多数情况下\x3c\/strong\x3e是异步的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要直接使用当前 \x3ccode\x3estate\x3c\/code\x3e 的值生成下一个 \x3ccode\x3estate\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要直接通过 \x3ccode\x3ethis.state\x3c\/code\x3e 修改 \x3ccode\x3estate\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件生命周期流程图。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e各个生命周期函数介绍及使用经验。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上是本文的内容摘要，如果你已经知道我要说的是什么，那么就没有必要继续看下去了，节约时间。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e组件的内部状态\x3c\/h2\x3e\n\x3cp\x3e此前，我们已经了解到可以通过 \x3ccode\x3eReactDOM.render(\x26lt;HelloMessage name=\x22Lucy\x22 \/\x26gt;, container)\x3c\/code\x3e 的方式，将带有特定属性的组件渲染到页面的某个 DOM 节点中（container），这样页面上会展示出 “Hello Lucy”，当我们希望页面上展示 “Hello Tom” 的时候，我们可以将组件的 name 属性改为 Tom 后再次调用 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 方法，这样组件就会以新的属性重新渲染，从而更新组件的视图。\x3c\/p\x3e\n\x3cp\x3e下面是官方文档中一个展示时钟的例子，我简单改造了下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/codepen.io\/Sarike\/pen\/Lzvzgv\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/Sarike\/pen...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22Sarike\/pen\/Lzvzgv\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cp\x3e例子中定义了一个 \x3ccode\x3eClock\x3c\/code\x3e 组件，组件接收一个 \x3ccode\x3etime\x3c\/code\x3e 属性，在组件外部通过 \x3ccode\x3esetInterval\x3c\/code\x3e 周期性地调用 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 不断更新 \x3ccode\x3eClock\x3c\/code\x3e 的属性并重新渲染。\x3c\/p\x3e\n\x3cp\x3e然而在很多实际场景中，对于一个时钟组件，我们希望它有更好的封装性和复用性，也就是说我们希望只调用一次 \x3ccode\x3eReactDOM.render(\x26lt;Clock \/\x26gt;, container)\x3c\/code\x3e 然后它可以自己更新自己的视图，这样我们就更容易在页面上放置多个时钟了，即复用性更好了。\x3c\/p\x3e\n\x3cp\x3e要达到这个目的，就需要组件的内部状态来支持。组件有一个特殊的属性 \x3ccode\x3estate\x3c\/code\x3e 用来保存组件的内部状态。用户可以通过 \x3ccode\x3ethis.setState(statePatch)\x3c\/code\x3e 来更新组件的状态，组件的状态更新后会重新执行 \x3ccode\x3erender\x3c\/code\x3e 方法来更新视图，上面的例子使用内部状态改造后：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/codepen.io\/Sarike\/pen\/oGOVRz\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/Sarike\/pen...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22Sarike\/pen\/oGOVRz\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cp\x3e这样 \x3ccode\x3eClock\x3c\/code\x3e 作为一个完整的时钟组件就可以自己来更新自己了，上篇文中也有提到过，如果想要使用组件的内部状态，那组件必须以类继承的方式来定义，而不能使用函数式组件。所以说，函数式组件经常也被称作是无状态组件（stateless）。\x3c\/p\x3e\n\x3cp\x3e上面例子中有用到 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 和 \x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e 两个函数，它们是组件的生命周期函数，本文的后半部分将会介绍，这俩函数分别在组件挂载到页面上和组件将要从页面上移除时调用。\x3c\/p\x3e\n\x3cp\x3e改造后的例子，我们只需要调用一次 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 即可，在实际的项目中，一个完整的单页面 web 应用，也只需要调用一次 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 方法把根组件挂载到页面中即可，剩下的工作就都放心地交给 React 就行了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e初始化组件内部状态\x3c\/h3\x3e\n\x3cp\x3e在创建一个拥有内部状态的组件时，我们需要对内部状态进行初始化，即设置组件最初的状态是什么。做法很简单，就是在构造函数 \x3ccode\x3econstructor\x3c\/code\x3e 中设置 \x3ccode\x3estate\x3c\/code\x3e 属性就可以了。如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyComponent extends React.Component {\n    constructor(props) {\n        super(props); \/\/ 这行代码不能少哦\n        this.state = {\n            name: \x26quot;Lucy\x26quot;\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这行代码不能少哦\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            name: \x3cspan class=\x22hljs-string\x22\x3e\x22Lucy\x22\x3c\/span\x3e\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3esetState 大多数情况下是异步的\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3esetState\x3c\/code\x3e 多数情况下是异步的，异步意味着通过 \x3ccode\x3esetState\x3c\/code\x3e 更新组件状态后，不能立刻通过 \x3ccode\x3ethis.state\x3c\/code\x3e 来获取到更新之后的值，另外当连续多次调用 \x3ccode\x3esetState\x3c\/code\x3e 来更新同一个字段时，只有最后一次更新才会生效。如下示例：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/codepen.io\/Sarike\/pen\/QqPPdP\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/Sarike\/pen...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22Sarike\/pen\/QqPPdP\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cp\x3e如果希望上面示例代码正常工作，你需要通过回调函数的方式来生成下一个 state，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState(preState =\x3e ({value: preState.value \x2b 1}));\nthis.setState(preState =\x3e ({value: preState.value \x2b 2}));\nthis.setState(preState =\x3e ({value: preState.value \x2b 3}));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(preState =\x26gt; ({\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: preState.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}));\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(preState =\x26gt; ({\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: preState.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}));\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(preState =\x26gt; ({\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e: preState.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e}));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，直接基于当前 \x3ccode\x3estate\x3c\/code\x3e 的值，生成一下个 \x3ccode\x3estate\x3c\/code\x3e 是不靠谱的，但是很多不清楚这一点的同学基本上都是这么做的，因为写起来简单嘛，而且貌似也没有什么问题。这是因为很多情况下，业务逻辑没有那么复杂，基本不会频繁调用 \x3ccode\x3esetState\x3c\/code\x3e 。但是这确实是一个隐患，如果在项目初期不注意规避，等项目复杂到一定程度以后，可能会出现难以排查的BUG。\x3c\/p\x3e\n\x3cp\x3e那为什么说多数情况下是异步的呢？难道有些情况下不是异步的吗？是的，实际上只有在 React 能控制的事件处理过程中调用的 \x3ccode\x3esetState\x3c\/code\x3e 才是异步的，如：生命周期函数，React 内置的如 button，input 等组件的事件处理函数。在多数的情况下我们只需要在这些地方控制我们的组件就够了，所以说大多数情况下 \x3ccode\x3esetState\x3c\/code\x3e 是异步的。\x3c\/p\x3e\n\x3cp\x3e在某些特殊的组件中，可能需要通过 \x3ccode\x3eaddEventListener\x3c\/code\x3e 来设置某些 DOM 的事件处理函数，在这种通过原生的 JS API 来设置的事件处理过程调用 \x3ccode\x3esetState\x3c\/code\x3e 就是同步的，会立即更新 \x3ccode\x3ethis.state\x3c\/code\x3e。另外还有 \x3ccode\x3esetInterval\x3c\/code\x3e、\x3ccode\x3esetTimeout\x3c\/code\x3e 等原生 API 的回调函数也是如此。\x3c\/p\x3e\n\x3cp\x3e参考：\x3ca href=\x22https:\/\/www.zhihu.com\/question\/66749082\/answer\/246217812\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.zhihu.com\/questio...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e不要直接通过 this.state 来更新组件状态\x3c\/h3\x3e\n\x3cp\x3e这一点跟属性类似，直接通过 \x3ccode\x3ethis.state\x3c\/code\x3e 修改组件状态，组件状态被修改了，但并不会触发组件的重新渲染。这样就会导致组件视图与状态不一致。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e生命周期函数\x3c\/h2\x3e\n\x3cp\x3e一个组件被我们创造到这个世界上之后，在使用它时，它的每个实例都是有一定生命周期的，下面这张图说明了一个组件实例的生命周期：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXwnT?w=1558\x26amp;h=1270\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXwnT?w=1558\x26amp;h=1270\x22 alt=\x22生命周期\x22 title=\x22生命周期\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e图片来源：\x3ca href=\x22https:\/\/tylermcginnis.com\/an-introduction-to-life-cycle-events-in-react-js\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/tylermcginnis.com\/an-...\x3c\/a\x3e，这张图略微有点老，不过结合下文来看也没什么问题。\x3c\/p\x3e\n\x3cp\x3e下面我们来解释一下上面这张图。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e组件初始化：constructor\x3c\/h3\x3e\n\x3cp\x3e我们定义的每一个组件，都是一个类（class），这些类被实例化后才能作为 React DOM 中的一个节点渲染到页面上。所以，当我们通过 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 或者在某个组件中通过 JSX 表达式将一个组件\x3cstrong\x3e第一次\x3c\/strong\x3e渲染到页面上时，组件首先要做的就是对组件进行实例化。\x3c\/p\x3e\n\x3cp\x3e实例化主要做的事情：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e创建一个组件的实例对象（也就是 Element，通常对应一个JSX表达式，如：\x3ccode\x3e\x26lt;MyComponent \/\x26gt;\x3c\/code\x3e）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e获取组件的默认属性。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e获取组件的初始内部状态（在 \x3ccode\x3econstructor\x3c\/code\x3e 中 \x3ccode\x3ethis.state = xxxx;\x3c\/code\x3e）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3ecomponentWillMount\x3c\/h3\x3e\n\x3cp\x3e在组件被渲染到页面上之前执行，在组件的整个生命周期内只执行一次。在这里可以调用 \x3ccode\x3esetState\x3c\/code\x3e 更新内部状态，但是更推荐将这里的状态更新操作放到 \x3ccode\x3econstructor\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e该函数执行完后会立马执行 \x3ccode\x3erender\x3c\/code\x3e 方法并将组件渲染到页面上。所以，在这里执行 setState 不会触发额外的渲染过程，因为这是没有必要的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecomponentDidMount\x3c\/h3\x3e\n\x3cp\x3e组件被渲染到页面上后立马执行，在组件的整个生命周期内只执行一次。这个时候是做如下操作的好时机：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e某些依赖组件 DOM 节点的操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e发起网络请求。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e设置 \x3ccode\x3esetInterval\x3c\/code\x3e、\x3ccode\x3esetTimeout\x3c\/code\x3e 等计时器操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在这里可以调用 \x3ccode\x3esetState\x3c\/code\x3e 更新组件内部状态，且会触发一个重新渲染的过程，即会重新执行 \x3ccode\x3erender\x3c\/code\x3e 方法并更新视图。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3ecomponentWillReceiveProps\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentWillReceiveProps(nextProps)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ecomponentWillReceiveProps\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(nextProps)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该声明周期函数可能在两种情况下被调用：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e组件接收到了新的属性。新的属性会通过 \x3ccode\x3enextProps\x3c\/code\x3e 获取到。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件没有收到新的属性，但是由于父组件重新渲染导致当前组件也被重新渲染。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e你只要知道，\x3cstrong\x3e当该函数被调用时，并不一定是因为属性发生了变化\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e在这里也可以调用 \x3ccode\x3esetState\x3c\/code\x3e 更新组件的内部状态，同样也不会触发额外的重新渲染操作，React 会聪明地用更新后的属性和内部状态进行一次重新渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eshouldComponentUpdate\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate(nextProps, nextState)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eshouldComponentUpdate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(nextProps, nextState)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是一个询问式的生命周期函数，所以该函数需要一个返回值 \x3ccode\x3etrue\/false\x3c\/code\x3e，如果为 \x3ccode\x3etrue\x3c\/code\x3e，组件将触发重新渲染过程，如果为 \x3ccode\x3efalse\x3c\/code\x3e 组件将不会触发重新渲染。因此，合理地利用该函数可以一定程度节省开销，提高系统的性能。\x3c\/p\x3e\n\x3cp\x3e此处不能调用 \x3ccode\x3esetState\x3c\/code\x3e 更新组件的状态。\x3c\/p\x3e\n\x3cp\x3e由于组件属性或者内部状态被改变时都触发组件重新渲染，所以该函数接受两个参数：新的属性（nextProps）、新的状态（nextState）。\x3c\/p\x3e\n\x3cp\x3e在处理该声明周期函数时，切记要兼顾属性和状态，不能只顾其一，不然很容易踩坑。例如：某位同学只依据属性来判断是否触发重新渲染，而忽略了内部状态，这样就导致你无论如何 \x3ccode\x3esetState\x3c\/code\x3e，组件视图都不能正常更新。\x3c\/p\x3e\n\x3cp\x3e在上篇文章中我们提到类继承方式定义组件时说到，React 提供了两个基类，一个是 \x3ccode\x3eComponent\x3c\/code\x3e，另一个是 \x3ccode\x3ePureComponent\x3c\/code\x3e，两者的差别就在于后者已经帮我们简单实现了一下 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 函数，当属性和状态都没有发生变化时返回 \x3ccode\x3efalse\x3c\/code\x3e 以避免额外的开销。\x3c\/p\x3e\n\x3cp\x3e但是比对过程出于性能考虑，只是进行浅比对，也就是只比对对象的第一级字段，而且是否发生变化是通过 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/is\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObject.is\x3c\/a\x3e 方法类判断的。所以会导致有时候发生变化了组件没有更新，没有变化却触发了重新渲染过程。这个在这里不再赘述，想深入探讨可以扫描问候的二维码加我微信好友（我的微信：leobaba88）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ecomponentWillUpdate\x3c\/h3\x3e\n\x3cp\x3e当组件 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 返回 \x3ccode\x3etrue\x3c\/code\x3e 或者调用 \x3ccode\x3eforceUpdate\x3c\/code\x3e 时将触发此函数。\x3c\/p\x3e\n\x3cp\x3e该函数中不能调用 \x3ccode\x3esetState\x3c\/code\x3e 更新组件状态，当你想这么做的时候，你可以考虑将它移到 \x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e 函数里。\x3c\/p\x3e\n\x3cp\x3e该函数在函数第一次渲染的时候不会执行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3ecomponentDidUpdate\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentDidUpdate(prevProps, prevState)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ecomponentDidUpdate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(prevProps, prevState)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在组件重新渲染过程中，重新执行 \x3ccode\x3erender\x3c\/code\x3e 方法并更新组件视图后立即执行该函数。类似组件第一次渲染过程中的 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e，该函数在第一次渲染时不会执行。\x3c\/p\x3e\n\x3cp\x3e在此处是做这些事情的好时机：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e执行依赖新 DOM 节点的操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e依据新的属性发起新的网络请求。（但是此处一定要格外谨慎，一定要在确认属性变化后再发起网络请求，不然极有可能进入死循环：didUpdate -\x26gt; ajax -\x26gt; changeProps -\x26gt; didUpdate -\x26gt; ...）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ecomponentWillUnmount\x3c\/h3\x3e\n\x3cp\x3e当组件被从页面中移除之前调用，此时是清理战场的好时机，如清理定时器、终止网络请求等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3ecomponentDidCatch\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentDidCatch(error, info)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ecomponentDidCatch\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(error, info)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是 React 16 新加入的一个生命周期函数。定义该生命周期函数的组件将会成为一个\x3cstrong\x3e错误边界\x3c\/strong\x3e，错误边界这个词非常形象，它可以有效地将错误限制在一个有限的范围内，而不会导致整个应用崩溃，防止一颗耗子屎坏了一锅汤。\x3c\/p\x3e\n\x3cp\x3e错误边界组件，可以捕获其整个子组件树内发生的任何异常，但是却不能捕获自身的异常。\x3c\/p\x3e\n\x3cp\x3e下面是官方的一个示例，大家感受下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/codepen.io\/gaearon\/pen\/wqvxGa\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/gaearon\/pe...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22gaearon\/pen\/wqvxGa\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e最后（微信群）\x3c\/h2\x3e\n\x3cp\x3e这篇文章来的有点慢，非常抱歉。\x3c\/p\x3e\n\x3cp\x3e另外为了方便大家阅读，我将所有文章的链接更新到第一篇文章 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000011336838\x22\x3e《玩转React（一）- 前言》\x3c\/a\x3e 中。\x3c\/p\x3e\n\x3cp\x3e文字的表现范围毕竟有限，为了方便大家交流，我建了一个微信群，对 React 感兴趣的同学可以进群一起交流、学习，由于微信群邀请的时间限制，大家可以先扫描下面二维码，加我好友，我拉大家进群：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXzqs?w=430\x26amp;h=430\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXzqs?w=430\x26amp;h=430\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我的微信：\x3ccode\x3eleobaba88\x3c\/code\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>玩转 React（五）- 组件的内部状态和生命周期</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011776013">https://segmentfault.com/a/1190000011776013</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/nuae8gc8ve/" target="_blank">https://alili.tech/archive/nuae8gc8ve/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>