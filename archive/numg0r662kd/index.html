<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="用 ES6 写全屏滚动插件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>用 ES6 写全屏滚动插件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/numg0r662kd/",
				"appid": "1613049289050283", 
				"title": "用 ES6 写全屏滚动插件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-02T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/27y7qd61mhg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/54rrfvz2zql/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&text=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&text=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&title=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&is_video=false&description=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&title=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&title=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&title=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnumg0r662kd%2f&title=%e7%94%a8%20ES6%20%e5%86%99%e5%85%a8%e5%b1%8f%e6%bb%9a%e5%8a%a8%e6%8f%92%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">用 ES6 写全屏滚动插件</h1><div class="meta"><div class="postdate"><time datetime="2018-12-02" itemprop="datePublished">2018-12-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e这篇文章将介绍如何使用原生 JS （主要使用 ES6 语法）实现全屏滚动插件，兼容 IE 10\x2b、手机触屏，Mac 触摸板优化，支持自定义页面动画，压缩后 gzip 文件只有 2.15KB。完整源码在这 \x3ca href=\x22https:\/\/github.com\/xiaogliu\/pure_full_page\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epure_full_page\x3c\/a\x3e，点这查看 \x3ca href=\x22https:\/\/xiaogliu.github.io\/pure_full_page\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edemo\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1）前面的话\x3c\/h2\x3e\n\x3cp\x3e现在已经有很多全屏滚动插件了，比如著名的 \x3ca href=\x22https:\/\/github.com\/alvarotrigo\/fullPage.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efullPage\x3c\/a\x3e，那为什么还要自己造轮子呢？\x3c\/p\x3e\n\x3cp\x3e现有轮子有以下问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e首先，最大的问题是最流行的几个插件都依赖 jQuery，这意味着在使用 React 或者 Vue 的项目中使用他们是一件十分蛋疼的事：我只需要一个全屏滚动功能，却还需要把 jQuery 引入，有种杀鸡使用宰牛刀的感觉；\x3c\/li\x3e\n\x3cli\x3e其次，现有的很多全屏滚动插件功能往往都十分丰富，这在前几年是优势，但现在（2018-5）可以看作是劣势：前端开发已经发生了很大变化，其中很重要的一个变化是 ES6 原生支持模块化开发，模块化开发最大的特点是一个模块最好只专注做好一件事，然后再拼成一个完整的系统，从这个角度看，大而全的插件有悖模块化开发的原则。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对比之下，通过原生语言造轮子有以下好处：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用原生语言编写的插件，自身不会受依赖的插件的使用场景而影响自身的使用（现在依赖 jQuery 的插件非常不适合开发单页面应用），所以使用上更加灵活；\x3c\/li\x3e\n\x3cli\x3e搭配模块化开发，使用原生语言开发的插件可以只专注一个功能，所以代码量可以很少；\x3c\/li\x3e\n\x3cli\x3e最后，随着 JS\/CSS\/HTML 的发展以及浏览器不断迭代更新，现在使用原生语言编写插件的开发成本越来越低，那为什么不呢？\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2）实现原理及代码架构\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e2.1 实现原理\x3c\/h3\x3e\n\x3cp\x3e实现原理见下图：容器及容器内的页面取当前可视区高度，同时容器的父级元素 \x3ccode\x3eoverflow\x3c\/code\x3e 属性值设为 \x3ccode\x3ehidden\x3c\/code\x3e，通过更改容器 \x3ccode\x3etop\x3c\/code\x3e 值实现全屏滚动效果。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014684363?w=562\x26amp;h=559\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014684363?w=562\x26amp;h=559\x22 alt=\x22全屏滚动实现原理\x22 title=\x22全屏滚动实现原理\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2.2 代码架构\x3c\/h3\x3e\n\x3cp\x3e代码编写的思路是通过 class 定义全屏滚动类，使用时通过 \x3ccode\x3enew PureFullPage().init()\x3c\/code\x3e 使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 全屏滚动类\n *\/\nclass PureFullPage {\n  \/\/ 构造函数\n  constructor() {}\n\n  \/\/ 原型方法\n  methods() {}\n\n  \/\/ 初始化函数\n  init() {}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 全屏滚动类\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePureFullPage\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原型方法\x3c\/span\x3e\n  methods() {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化函数\x3c\/span\x3e\n  init() {}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e3）html 结构\x3c\/h2\x3e\n\x3cp\x3e鉴于上述实现原理，对于 html 的结构有特定要求，如下：页面容器为 \x3ccode\x3e#pureFullPageContainer\x3c\/code\x3e，所有的页面为其直接子元素，这里为了方便，直接取 \x3ccode\x3ebody\x3c\/code\x3e 为其直接父元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbody\x3e\n  \x3cdiv id=\x26quot;pureFullPageContainer\x26quot;\x3e\n    \x3cdiv class=\x26quot;page\x26quot;\x3e\x3c\/div\x3e\n    \x3cdiv class=\x26quot;page\x26quot;\x3e\x3c\/div\x3e\n    \x3cdiv class=\x26quot;page\x26quot;\x3e\x3c\/div\x3e\n  \x3c\/div\x3e\n\x3c\/body\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22pureFullPageContainer\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22page\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22page\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22page\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e4）css 设置\x3c\/h2\x3e\n\x3cp\x3e首先，容器及容器内的页面取当前可视区高度，为每次切换都显示一个完整的页面做准备；\x3c\/p\x3e\n\x3cp\x3e第二，容器的父级元素（此处是 \x3ccode\x3ebody\x3c\/code\x3e） \x3ccode\x3eoverflow\x3c\/code\x3e 属性值定为 \x3ccode\x3ehidden\x3c\/code\x3e，这样可以保证每次只会显示一个页面，其他页面被隐藏。\x3c\/p\x3e\n\x3cp\x3e经过上述设置，对容器 \x3ccode\x3etop\x3c\/code\x3e 值，每次更改一个可视区高度的距离，便实现了页面间的切换，部分代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22body {\n  \/* body 为容器直接的父元素 *\/\n  overflow: hidden;\n}\n\n#pureFullPage {\n  \/* 只有当 position 的值不是 static 时，top 值才有效 *\/\n  position: relative;\n  \/* 设置初始值 *\/\n  top: 0;\n}\n.page {\n  \/* 此处不能为 100vh，后面详述 *\/\n  \/* 其父元素，也就是 #pureFullPage 的高度，通过 js 动态设置*\/\n  height: 100%;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22css hljs\x22\x3e\x3ccode class=\x22css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ebody\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* body 为容器直接的父元素 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3eoverflow\x3c\/span\x3e: hidden;\n}\n\n\x3cspan class=\x22hljs-selector-id\x22\x3e#pureFullPage\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 只有当 position 的值不是 static 时，top 值才有效 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3eposition\x3c\/span\x3e: relative;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 设置初始值 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3etop\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-selector-class\x22\x3e.page\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 此处不能为 100vh，后面详述 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 其父元素，也就是 #pureFullPage 的高度，通过 js 动态设置*\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100%\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eNotice：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e容器的 \x3ccode\x3eposition\x3c\/code\x3e 属性值需要设置为 \x3ccode\x3erelative\x3c\/code\x3e，因为 \x3ccode\x3etop\x3c\/code\x3e 只有在 \x3ccode\x3eposition\x3c\/code\x3e 属性值不为 \x3ccode\x3estatic\x3c\/code\x3e 时才有效；\x3c\/li\x3e\n\x3cli\x3e页面高度需设置为当前可视区高度，但不能直接设置为 \x3ccode\x3e100vh\x3c\/code\x3e，因为 safari 手机浏览器把地址栏算进去计算 \x3ccode\x3e100vh\x3c\/code\x3e，但地址栏下面的不应该算做“可视区”，毕竟实际上是“看不见”的区域。这会导致 \x3ccode\x3e100vh\x3c\/code\x3e 对应的像素值比 \x3ccode\x3edocument.documentElement.clientHeight\x3c\/code\x3e 获取的像素值大。这样在切换 \x3ccode\x3etop\x3c\/code\x3e 值时就不是全屏切换了，实际上，这种情况下切换的高度小于页面的高度。\x3c\/li\x3e\n\x3cli\x3e解决 safari 手机浏览器可视区高度问题：既然通过 js 获取的 \x3ccode\x3edocument.documentElement.clientHeight\x3c\/code\x3e 值是符合预期的可视区高度（不包括顶部地址栏和底部工具栏），那就\x3cstrong\x3e将该值通过 js 设置为容器的高度，同时，容器内的页面高度设置为 \x3ccode\x3e100%\x3c\/code\x3e\x3c\/strong\x3e，这样就可以保证容器及页面的高度和切换 \x3ccode\x3etop\x3c\/code\x3e 值相同了，也就保证了全屏切换。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 伪代码\n\x27#pureFullPage\x27.style.height = document.documentElement.clientHeight \x2b \x27px\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 伪代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27#pureFullPage\x27\x3c\/span\x3e.style.height = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.clientHeight \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27px\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e5）监控滚动\/滑动事件\x3c\/h2\x3e\n\x3cp\x3e这里的滚动\/滑动事件包括鼠标滚动、触摸板滑动以及手机屏幕上下滑动。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e5.1 PC 端\x3c\/h3\x3e\n\x3cp\x3ePC 端主要解决的问题是获取鼠标滚动或触摸板滑动方向，触摸板上下滑动和鼠标滚动绑定的是同一个事件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3efirefox 是 \x3ccode\x3eDOMMouseScroll\x3c\/code\x3e 事件，对应的滚轮信息（向前滚还是向后滚）存储在 \x3ccode\x3edetail\x3c\/code\x3e 属性中，向前滚，这个属性值是 3 的倍数，反之，是 -3 的倍数；\x3c\/li\x3e\n\x3cli\x3efirefox 之外的其他浏览器是 \x3ccode\x3emousewheel\x3c\/code\x3e 事件，对应的滚轮信息存储在 \x3ccode\x3ewheelDelta\x3c\/code\x3e 属性中，向前滚，这个属性值是 -120 的倍数，反之， 120 的倍数。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3emacOS 如此，windows 相反？\x3c\/blockquote\x3e\n\x3cp\x3e所以，可以通过 \x3ccode\x3edetail\x3c\/code\x3e 或 \x3ccode\x3ewheelDelta\x3c\/code\x3e 的值判断鼠标的滚动方向，进而控制页面是向上还是向下滚动。在这里我们只关心正负，不关心具体值的大小，为了便于使用，下面基于这两个事件封装了一个函数：如果鼠标往前滚动，返回负数，反之，返回正数，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 鼠标滚轮事件\ngetWheelDelta(event) {\n  if (event.wheelDelta) {\n    return event.wheelDelta;\n  } else {\n    \/\/ 兼容火狐\n    return -event.detail;\n  }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 鼠标滚轮事件\x3c\/span\x3e\ngetWheelDelta(event) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (event.wheelDelta) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e event.wheelDelta;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 兼容火狐\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e -event.detail;\n  }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了滚动事件，就可以据此编写页面向上或者向下滚动的回调函数了，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 鼠标滚动逻辑（全屏滚动关键逻辑）\nscrollMouse(event) {\n  let delta = utils.getWheelDelta(event);\n  \/\/ delta \x3c 0，鼠标往前滚动，页面向下滚动\n  if (delta \x3c 0) {\n    this.goDown();\n  } else {\n    this.goUp();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 鼠标滚动逻辑（全屏滚动关键逻辑）\x3c\/span\x3e\nscrollMouse(event) {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e delta = utils.getWheelDelta(event);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ delta \x26lt; 0，鼠标往前滚动，页面向下滚动\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (delta \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.goDown();\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.goUp();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3egoDown\x3c\/code\x3e、\x3ccode\x3egoUp\x3c\/code\x3e 是页面滚动的逻辑代码，需要特别说明的是必须 \x3cstrong\x3e判断滚动边界，保证容器中显示的始终是页面内容\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e上边界容易确定，为 1 个页面（也即可视区）的高度，即如果容器当前的上外边框距离整个页面顶部的距离（这里此值正是容器的 \x3ccode\x3eoffsetTop\x3c\/code\x3e 值的绝对值，因为它父元素的 \x3ccode\x3eoffsetTop\x3c\/code\x3e 值都是 \x3ccode\x3e0\x3c\/code\x3e）大于等于当前可视区高度时，才允许向上滚动，不然，就证明上面已经没有页面了，不允许继续向上滚动；\x3c\/li\x3e\n\x3cli\x3e下边界为 \x3ccode\x3en - 2\x3c\/code\x3e（n 表示全屏滚动的页面数） 个可视区的高度，当容器的 \x3ccode\x3eoffsetTop\x3c\/code\x3e 值的绝对值小于等于 \x3ccode\x3en - 2\x3c\/code\x3e 个可视区的高度时，表示还可以向下滚动一个页面。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e具体代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22goUp() {\n  \/\/ 只有页面顶部还有页面时页面向上滚动\n  if (-this.container.offsetTop \x3e= this.viewHeight) {\n    \/\/ 重新指定当前页面距视图顶部的距离 currentPosition，实现全屏滚动，\n    \/\/ currentPosition 为负值，越大表示超出顶部部分越少\n    this.currentPosition = this.currentPosition \x2b this.viewHeight;\n\n    this.turnPage(this.currentPosition);\n  }\n}\ngoDown() {\n  \/\/ 只有页面底部还有页面时页面向下滚动\n  if (-this.container.offsetTop \x3c= this.viewHeight * (this.pagesNum - 2)) {\n    \/\/ 重新指定当前页面距视图顶部的距离 currentPosition，实现全屏滚动，\n    \/\/ currentPosition 为负值，越小表示超出顶部部分越多\n    this.currentPosition = this.currentPosition - this.viewHeight;\n\n    this.turnPage(this.currentPosition);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3egoUp() {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有页面顶部还有页面时页面向上滚动\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (-\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.offsetTop \x26gt;= \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新指定当前页面距视图顶部的距离 currentPosition，实现全屏滚动，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ currentPosition 为负值，越大表示超出顶部部分越少\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.turnPage(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition);\n  }\n}\ngoDown() {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有页面底部还有页面时页面向下滚动\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (-\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.offsetTop \x26lt;= \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight * (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pagesNum - \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新指定当前页面距视图顶部的距离 currentPosition，实现全屏滚动，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ currentPosition 为负值，越小表示超出顶部部分越多\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.turnPage(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后添加滚动事件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 鼠标滚轮监听，火狐鼠标滚动事件不同其他\nif (navigator.userAgent.toLowerCase().indexOf(\x27firefox\x27) === -1) {\n  document.addEventListener(\x27mousewheel\x27, scrollMouse);\n} else {\n  document.addEventListener(\x27DOMMouseScroll\x27, scrollMouse);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 鼠标滚轮监听，火狐鼠标滚动事件不同其他\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (navigator.userAgent.toLowerCase().indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27firefox\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27mousewheel\x27\x3c\/span\x3e, scrollMouse);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMMouseScroll\x27\x3c\/span\x3e, scrollMouse);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e5.2 移动端\x3c\/h3\x3e\n\x3cp\x3e移动端需要判断是向上还是向下滑动，可以结合 \x3ccode\x3etouchstart\x3c\/code\x3e（手指开始接触屏幕时触发） 和 \x3ccode\x3etouchend\x3c\/code\x3e（手指离开屏幕时触发） 两个事件实现判断：分别获取两个事件开始触发时的 \x3ccode\x3epageY\x3c\/code\x3e 值，如果触摸结束时的 \x3ccode\x3epageY\x3c\/code\x3e 大于触摸开始时的 \x3ccode\x3epageY\x3c\/code\x3e，表示手指向下滑动，对应页面向上滚动，反之亦然。\x3c\/p\x3e\n\x3cp\x3e此处我们需要触摸事件跟踪触摸的属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3etouches\x3c\/code\x3e：当前跟踪的触摸操作的 Touch 对象的数组，用于获取触摸开始时的 \x3ccode\x3epageY\x3c\/code\x3e 值；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3echangeTouches\x3c\/code\x3e：自上次触摸以来发生了改变的 Touch 对象的数组，用于获取触摸触摸结束时的 \x3ccode\x3epageY\x3c\/code\x3e 值。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e相关代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 手指接触屏幕\ndocument.addEventListener(\x27touchstart\x27, event =\x3e {\n  this.startY = event.touches[0].pageY;\n});\n\/\/手指离开屏幕\ndocument.addEventListener(\x27touchend\x27, event =\x3e {\n  let endY = event.changedTouches[0].pageY;\n  if (endY - this.startY \x3c 0) {\n    \/\/ 手指向上滑动，对应页面向下滚动\n    this.goDown();\n  } else {\n    \/\/ 手指向下滑动，对应页面向上滚动\n    this.goUp();\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 手指接触屏幕\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchstart\x27\x3c\/span\x3e, event =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startY = event.touches[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].pageY;\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/手指离开屏幕\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchend\x27\x3c\/span\x3e, event =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e endY = event.changedTouches[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].pageY;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (endY - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startY \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 手指向上滑动，对应页面向下滚动\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.goDown();\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 手指向下滑动，对应页面向上滚动\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.goUp();\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了避免下拉刷新，可以阻止 \x3ccode\x3etouchmove\x3c\/code\x3e 事件的默认行为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 阻止 touchmove 下拉刷新\ndocument.addEventListener(\x27touchmove\x27, event =\x3e {\n  event.preventDefault();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 阻止 touchmove 下拉刷新\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchmove\x27\x3c\/span\x3e, event =\x26gt; {\n  event.preventDefault();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e6）PC 端滚动事件性能优化\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e6.1 防抖函数和截流函数介绍\x3c\/h3\x3e\n\x3cp\x3e优化主要从两方便入手：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e更改页面大小时，通过防抖动（debounce）函数限制 \x3ccode\x3eresize\x3c\/code\x3e 事件触发频率；\x3c\/li\x3e\n\x3cli\x3e滚动\/滑动事件触发时，通过截流（throttle）函数限制滚动\/滑动事件触发频率。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e既然都是限制触发频率（都通过定时器实现），那这两者有什么区别？\x3c\/p\x3e\n\x3cp\x3e首先，防抖动函数工作时，如果在指定的延迟时间内，某个事件连续触发，那么绑定在这个事件上的回调函数永远不会触发，只有在延迟时间内，这个事件没再触发，对应的回调函数才会执行。防抖动函数非常适合改变窗口大小这一事件，这也符合 \x3cem\x3e拖动到位以后再触发事件，如果一直拖个不停，始终不触发事件\x3c\/em\x3e 这一直觉。\x3c\/p\x3e\n\x3cp\x3e而截流函数是在延迟时间内，绑定到事件上的回调函数能且只能触发一次，这和截流函数不同，即便是在延迟时间内连续触发事件，也不会阻止在延迟时间内有一个回调函数执行。并且截流函数允许我们指定回调函数是在延迟时间开始时还是结束时执行。\x3c\/p\x3e\n\x3cp\x3e鉴于截流函数的上述两个特性，尤其适合优化滚动\/滑动事件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e可以限制频率；\x3c\/li\x3e\n\x3cli\x3e不会因为滚动\/滑动事件太灵敏（在延迟时间内不断触发）导致注册在事件上的回调函数无法执行；\x3c\/li\x3e\n\x3cli\x3e可以设置在延迟时间开始时触发回调函数，从而避免用户感到操作之后的短暂延时。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里不介绍防抖动函数和截流函数的实现原理，感兴趣的可以看\x3ca href=\x22https:\/\/codeburst.io\/throttling-and-debouncing-in-javascript-b01cad5c8edf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThrottling and Debouncing in JavaScript\x3c\/a\x3e，下面是实现的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 防抖动函数，method 回调函数，context 上下文，event 传入的时间，delay 延迟函数\ndebounce(method, context, event, delay) {\n  clearTimeout(method.tId);\n  method.tId = setTimeout(() =\x3e {\n    method.call(context, event);\n  }, delay);\n},\n\n\/\/ 截流函数，method 回调函数，context 上下文，delay 延迟函数，\n\/\/ 这里没有提供是在延迟时间开始还是结束的时候执行回调函数的选项，\n\/\/ 直接在延迟时间开始的时候执行回调\nthrottle(method, context, delay) {\n  let wait = false;\n  return function() {\n    if (!wait) {\n      method.apply(context, arguments);\n      wait = true;\n      setTimeout(() =\x3e {\n        wait = false;\n      }, delay);\n    }\n  };\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 防抖动函数，method 回调函数，context 上下文，event 传入的时间，delay 延迟函数\x3c\/span\x3e\ndebounce(method, context, event, delay) {\n  clearTimeout(method.tId);\n  method.tId = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    method.call(context, event);\n  }, delay);\n},\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 截流函数，method 回调函数，context 上下文，delay 延迟函数，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里没有提供是在延迟时间开始还是结束的时候执行回调函数的选项，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直接在延迟时间开始的时候执行回调\x3c\/span\x3e\nthrottle(method, context, delay) {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e wait = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!wait) {\n      method.apply(context, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n      wait = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        wait = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      }, delay);\n    }\n  };\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e《JavaScript 高级程序设计 - 第三版》 22.33.3 节中介绍的 throttle 函数和此处定义的不同，高程中定义的 throttle 函数对应此处的 debounce 函数，但网上大多数文章都和高程中的不同，比如 lodash 中定义的 \x3ca href=\x22https:\/\/lodash.com\/docs\/4.17.10#debounce\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edebounce\x3c\/a\x3e。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e6.2 改造 PC 端滚动事件\x3c\/h3\x3e\n\x3cp\x3e通过上述说明，我们已经知道截流函数可以通过限定滚动事件触发频率提升性能，同时，设置在\x3cstrong\x3e延迟时间开始阶段立即调用滚动事件的回调函数\x3c\/strong\x3e并不会牺牲用户体验。\x3c\/p\x3e\n\x3cp\x3e截流函数上文已经定义好，使用起来就很简单了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 设置截流函数\nlet handleMouseWheel = utils.throttle(this.scrollMouse, this, this.DELAY, true);\n\n\/\/ 鼠标滚轮监听，火狐鼠标滚动事件不同其他\nif (navigator.userAgent.toLowerCase().indexOf(\x27firefox\x27) === -1) {\n  document.addEventListener(\x27mousewheel\x27, handleMouseWheel);\n} else {\n  document.addEventListener(\x27DOMMouseScroll\x27, handleMouseWheel);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置截流函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e handleMouseWheel = utils.throttle(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollMouse, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.DELAY, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 鼠标滚轮监听，火狐鼠标滚动事件不同其他\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (navigator.userAgent.toLowerCase().indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27firefox\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27mousewheel\x27\x3c\/span\x3e, handleMouseWheel);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMMouseScroll\x27\x3c\/span\x3e, handleMouseWheel);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这部分代码是写在 class 的 \x3ccode\x3einit\x3c\/code\x3e 方法中，所以截流函数的上下文（context）传入的是 \x3ccode\x3ethis\x3c\/code\x3e，表示当前 class 实例。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e7）其他\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e7.1 导航按钮\x3c\/h3\x3e\n\x3cp\x3e为了简化 html 结构，导航按钮通过 js 创建。这里的难点在于\x3cstrong\x3e如何实现点击不同按钮实现对应页面的跳转并更新对应按钮的样式\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e解决的思路是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e页面跳转：页面个数和导航按钮的个数一致，所以点击第 i 个按钮也就是跳转到第 i 个页面，而第 i 个页面对应的容器 \x3ccode\x3etop\x3c\/code\x3e 值恰好是 \x3ccode\x3e-(i * this.viewHeight)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e更改样式：更改样式即先删除所有按钮的选中样式，然后给当前点击的按钮添加选中样式。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建右侧点式导航\ncreateNav() {\n  const nav = document.createElement(\x27div\x27);\n  nav.className = \x27nav\x27;\n  this.container.appendChild(nav);\n  \/\/ 有几页，显示几个点\n  for (let i = 0; i \x3c this.pagesNum; i\x2b\x2b) {\n    nav.innerHTML \x2b= \x27\x3cp class=\x26quot;nav-dot\x26quot;\x3e\x3cspan\x3e\x3c\/span\x3e\x3c\/p\x3e\x27;\n  }\n  const navDots = document.querySelectorAll(\x27.nav-dot\x27);\n  this.navDots = Array.prototype.slice.call(navDots);\n  \/\/ 添加初始样式\n  this.navDots[0].classList.add(\x27active\x27);\n  \/\/ 添加点式导航点击事件\n  this.navDots.forEach((el, i) =\x3e {\n    el.addEventListener(\x27click\x27, event =\x3e {\n      \/\/ 页面跳转\n      this.currentPosition = -(i * this.viewHeight);\n      this.turnPage(this.currentPosition);\n      \/\/ 更改样式\n      this.navDots.forEach(el =\x3e {\n        utils.deleteClassName(el, \x27active\x27);\n      });\n      event.target.classList.add(\x27active\x27);\n    });\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建右侧点式导航\x3c\/span\x3e\ncreateNav() {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nav = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e);\n  nav.className = \x3cspan class=\x22hljs-string\x22\x3e\x27nav\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.appendChild(nav);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有几页，显示几个点\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pagesNum; i\x2b\x2b) {\n    nav.innerHTML \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p class=\x22nav-dot\x22\x26gt;\x26lt;span\x26gt;\x26lt;\/span\x26gt;\x26lt;\/p\x26gt;\x27\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e navDots = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x27.nav-dot\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.navDots = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(navDots);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加初始样式\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.navDots[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].classList.add(\x3cspan class=\x22hljs-string\x22\x3e\x27active\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加点式导航点击事件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.navDots.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eel, i\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    el.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, event =\x26gt; {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面跳转\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition = -(i * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.turnPage(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更改样式\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.navDots.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        utils.deleteClassName(el, \x3cspan class=\x22hljs-string\x22\x3e\x27active\x27\x3c\/span\x3e);\n      });\n      event.target.classList.add(\x3cspan class=\x22hljs-string\x22\x3e\x27active\x27\x3c\/span\x3e);\n    });\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e7.2 自定义参数\x3c\/h3\x3e\n\x3cp\x3e得当的自定义参数可以增加插件的灵活性。\x3c\/p\x3e\n\x3cp\x3e参数通过构造函数传入，并通过 \x3ccode\x3eObject.assign()\x3c\/code\x3e 进行参数合并：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(options) {\n  \/\/ 默认配置\n  const defaultOptions = {\n    isShowNav: true,\n    delay: 150,\n    definePages: () =\x3e {},\n  };\n  \/\/ 合并自定义配置\n  this.options = Object.assign(defaultOptions, options);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(options) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultOptions = {\n    \x3cspan class=\x22hljs-attr\x22\x3eisShowNav\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edelay\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e150\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edefinePages\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {},\n  };\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 合并自定义配置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(defaultOptions, options);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e7.3 窗口尺寸改变时更新数据\x3c\/h3\x3e\n\x3cp\x3e浏览器窗口尺寸改变的时候，需要重新获取可视区、页面元素高度，并重新确定容器当前的 \x3ccode\x3etop\x3c\/code\x3e 值。\x3c\/p\x3e\n\x3cp\x3e同时，为了避免不必要的性能开支，这里使用了防抖动函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ window resize 时重新获取位置\ngetNewPosition() {\n  this.viewHeight = document.documentElement.clientHeight;\n  this.container.style.height = this.viewHeight \x2b \x27px\x27;\n  let activeNavIndex;\n  this.navDots.forEach((e, i) =\x3e {\n    if (e.classList.contains(\x27active\x27)) {\n      activeNavIndex = i;\n    }\n  });\n  this.currentPosition = -(activeNavIndex * this.viewHeight);\n  this.turnPage(this.currentPosition);\n}\n\nhandleWindowResize(event) {\n  \/\/ 设置防抖动函数\n  utils.debounce(this.getNewPosition, this, event, this.DELAY);\n}\n\n\/\/ 窗口尺寸变化时重置位置\nwindow.addEventListener(\x27resize\x27, this.handleWindowResize.bind(this));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ window resize 时重新获取位置\x3c\/span\x3e\ngetNewPosition() {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.clientHeight;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.container.style.height = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27px\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e activeNavIndex;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.navDots.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee, i\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.classList.contains(\x3cspan class=\x22hljs-string\x22\x3e\x27active\x27\x3c\/span\x3e)) {\n      activeNavIndex = i;\n    }\n  });\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition = -(activeNavIndex * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.viewHeight);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.turnPage(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentPosition);\n}\n\nhandleWindowResize(event) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置防抖动函数\x3c\/span\x3e\n  utils.debounce(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getNewPosition, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, event, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.DELAY);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 窗口尺寸变化时重置位置\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27resize\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleWindowResize.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e7.4 兼容性\x3c\/h3\x3e\n\x3cp\x3e这里的兼容性主要指两个方面：一是不同浏览器对同一行为定义了不同 API，比如上文提到的获取鼠标滚动信息的 API Firefox 和其他浏览器不一样；第二点就是 ES6 新语法、新 API 的兼容处理。\x3c\/p\x3e\n\x3cp\x3e对于 class、箭头函数这类新语法的转换，通过 babel 就可完成，鉴于本插件代码量很小，都处于可控的状态，并没有引入 babel 提供的 polyfill 方案，因为新 API 只有 \x3ccode\x3eObject.assign()\x3c\/code\x3e 需要做兼容处理，单独写个 polyfill 就好，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ polyfill Object.assign\npolyfill() {\n  if (typeof Object.assign != \x27function\x27) {\n    Object.defineProperty(Object, \x27assign\x27, {\n      value: function assign(target, varArgs) {\n        if (target == null) {\n          throw new TypeError(\x27Cannot convert undefined or null to object\x27);\n        }\n        let to = Object(target);\n        for (let index = 1; index \x3c arguments.length; index\x2b\x2b) {\n          let nextSource = arguments[index];\n          if (nextSource != null) {\n            for (let nextKey in nextSource) {\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n        return to;\n      },\n      writable: true,\n      configurable: true,\n    });\n  }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ polyfill Object.assign\x3c\/span\x3e\npolyfill() {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign != \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27assign\x27\x3c\/span\x3e, {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eassign\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, varArgs\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (target == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot convert undefined or null to object\x27\x3c\/span\x3e);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e to = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e(target);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; index \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length; index\x2b\x2b) {\n          \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e nextSource = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[index];\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextSource != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e nextKey \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e nextSource) {\n              \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e to;\n      },\n      \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    });\n  }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e引用自：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/assign#Polyfill\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN-Object.assign()\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e因为本插件只兼容到 IE10，所以不打算对事件做兼容处理，毕竟 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/EventTarget\/addEventListener#Browser_compatibility\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIE9 都支持\x3c\/a\x3e \x3ccode\x3eaddEventListener\x3c\/code\x3e 了。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e7.5 通过惰性载入进一步优化性能\x3c\/h3\x3e\n\x3cp\x3e在 5.1 中写的 \x3ccode\x3egetWheelDelta\x3c\/code\x3e 函数每次执行都需要检测是否支持 \x3ccode\x3eevent.wheelDelta\x3c\/code\x3e，实际上，浏览器只需在第一次加载时检测，如果支持，接下来都会支持，再做检测是没必要的。\x3c\/p\x3e\n\x3cp\x3e并且这个检测在页面的生命周期中会执行很多次，这种情况下可以通过 \x3cem\x3e惰性载入\x3c\/em\x3e 技巧进行优化，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22getWheelDelta(event) {\n  if (event.wheelDelta) {\n    \/\/ 第一次调用之后惰性载入，无需再做检测\n    this.getWheelDelta = event =\x3e event.wheelDelta;\n    \/\/ 第一次调用使用\n    return event.wheelDelta;\n  } else {\n    \/\/ 兼容火狐\n    this.getWheelDelta = event =\x3e -event.detail;\n    return -event.detail;\n  }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3egetWheelDelta(event) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (event.wheelDelta) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一次调用之后惰性载入，无需再做检测\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getWheelDelta = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e event.wheelDelta;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一次调用使用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e event.wheelDelta;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 兼容火狐\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getWheelDelta = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e -event.detail;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e -event.detail;\n  }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完整源码在这 \x3ca href=\x22https:\/\/github.com\/xiaogliu\/pure_full_page\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epure_full_page\x3c\/a\x3e，点这查看 \x3ca href=\x22https:\/\/xiaogliu.github.io\/pure_full_page\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edemo\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e参考资料\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/blog.csdn.net\/tangdou5682\/article\/details\/52351404\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e纯 JS 全屏滚动 \/ 整屏翻页\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/codeburst.io\/throttling-and-debouncing-in-javascript-b01cad5c8edf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThrottling and Debouncing in JavaScript\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/css-tricks.com\/debouncing-throttling-explained-examples\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDebouncing and Throttling Explained Through Examples\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/davidwalsh.name\/javascript-debounce-function\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Debounce Function\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/27078285\/simple-throttle-in-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSimple throttle in js\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/jsfiddle.net\/jonathansampson\/m7G64\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSimple throttle in js - jsfiddle\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22jonathansampson\/m7G64\/\x22 data-typeid=\x220\x22\x3e点击预览\x3c\/button\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/nicolas-hoizey.com\/2015\/02\/viewport-height-is-taller-than-the-visible-part-of-the-document-in-some-mobile-browsers.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eViewport height is taller than the visible part of the document in some mobile browsers\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/assign#Polyfill\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN-Object.assign()\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/www.zhihu.com\/question\/49382420\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBabel 编译出来还是 ES 6？难道只能上 polyfill？- Henry 的回答\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>用 ES6 写全屏滚动插件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014683917">https://segmentfault.com/a/1190000014683917</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/numg0r662kd/" target="_blank">https://alili.tech/archive/numg0r662kd/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>