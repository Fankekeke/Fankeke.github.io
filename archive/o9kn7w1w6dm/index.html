<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript Event Loop 机制详解与 Vue.js 中实践应用"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript Event Loop 机制详解与 Vue.js 中实践应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/o9kn7w1w6dm/",
				"appid": "1613049289050283", 
				"title": "JavaScript Event Loop 机制详解与 Vue.js 中实践应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-01T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zmprp5g14of/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jmkgy46f5u/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&text=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&text=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&title=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&is_video=false&description=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&title=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&title=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&title=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fo9kn7w1w6dm%2f&title=JavaScript%20Event%20Loop%20%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%e4%b8%8e%20Vue.js%20%e4%b8%ad%e5%ae%9e%e8%b7%b5%e5%ba%94%e7%94%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript Event Loop 机制详解与 Vue.js 中实践应用</h1><div class="meta"><div class="postdate"><time datetime="2019-01-01" itemprop="datePublished">2019-01-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/28508795\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Event Loop 机制详解与 Vue.js 中实践应用\x3c\/a\x3e归纳于笔者的\x3ca href=\x22https:\/\/parg.co\/bjK\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e现代 JavaScript 开发：语法基础与实践技巧\x3c\/a\x3e系列文章。本文依次介绍了函数调用栈、MacroTask 与 MicroTask 执行顺序、浅析 Vue.js 中 nextTick 实现等内容；本文中引用的参考资料统一声明在 \x3ca href=\x22https:\/\/parg.co\/b2O\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript 学习与实践资料索引\x3c\/a\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e1. 事件循环机制详解与实践应用\x3c\/h1\x3e\n\x3cp\x3eJavaScript 是典型的单线程单并发语言，即表示在同一时间片内其只能执行单个任务或者部分代码片。换言之，我们可以认为某个同域浏览器上下中 JavaScript 主线程拥有一个函数调用栈以及一个任务队列（参考 \x3ca href=\x22https:\/\/html.spec.whatwg.org\/multipage\/webappapis.html#task-queue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewhatwg 规范\x3c\/a\x3e）；主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。当函数调用栈为空时，运行时即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行，执行的过程同样会进行函数帧的入栈出栈操作。每个线程有自己的事件循环，所以每个 Web Worker有自己的，所以它才可以独立执行。然而，所有同属一个 origin 的窗体都共享一个事件循环，所以它们可以同步交流。\x3c\/p\x3e\n\x3cp\x3eEvent Loop（事件循环）并不是 JavaScript 中独有的，其广泛应用于各个领域的异步编程实现中；所谓的 Event Loop 即是一系列回调函数的集合，在执行某个异步函数时，会将其回调压入队列中，JavaScript 引擎会在异步代码执行完毕后开始处理其关联的回调。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044247\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044247\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在 Web 开发中，我们常常会需要处理网络请求等相对较慢的操作，如果将这些操作全部以同步阻塞方式运行无疑会大大降低用户界面的体验。另一方面，我们点击某些按钮之后的响应事件可能会导致界面重渲染，如果因为响应事件的执行而阻塞了界面的渲染，同样会影响整体性能。实际开发中我们会采用异步回调来处理这些操作，这种调用者与响应之间的解耦保证了 JavaScript 能够在等待异步操作完成之前仍然能够执行其他的代码。Event Loop 正是负责执行队列中的回调并且将其压入到函数调用栈中，其基本的代码逻辑如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22while (queue.waitForMessage()) {\n  queue.processNextMessage();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.waitForMessage()) {\n  \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.processNextMessage();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完整的浏览器中 JavaScript 事件循环机制图解如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044248\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044248\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在 Web 浏览器中，任何时刻都有可能会有事件被触发，而仅有那些设置了回调的事件会将其相关的任务压入到任务队列中。回调函数被调用时即会在函数调用栈中创建初始帧，而直到整个函数调用栈清空之前任何产生的任务都会被压入到任务队列中延后执行；顺序的同步函数调用则会创建新的栈帧。总结而言，浏览器中的事件循环机制阐述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e浏览器内核会在其它线程中执行异步操作，当操作完成后，将操作结果以及事先定义的回调函数放入 JavaScript 主线程的任务队列中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJavaScript 主线程会在执行栈清空后，读取任务队列，读取到任务队列中的函数后，将该函数入栈，一直运行直到执行栈清空，再次去读取任务队列，不断循环。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当主线程阻塞时，任务队列仍然是能够被推入任务的。这也就是为什么当页面的 JavaScript 进程阻塞时，我们触发的点击等事件，会在进程恢复后依次执行。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e2. 函数调用栈与任务队列\x3c\/h1\x3e\n\x3cp\x3e在\x3ca href=\x22https:\/\/parg.co\/bT4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e变量作用域与提升\x3c\/a\x3e一节中我们介绍过所谓执行上下文（Execution Context）的概念，在 JavaScript 代码执行过程中，我们可能会拥有一个全局上下文，多个函数上下文或者块上下文；每个函数调用都会创造新的上下文与局部作用域。而这些执行上下文堆叠就形成了所谓的执行上下文栈（Execution Context Stack），便如上文介绍的 JavaScript 是单线程事件循环机制，同时刻仅会执行单个事件，而其他事件都在所谓的执行栈中排队等待：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044249\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044249\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及队列（Queue）等几个部分：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044250\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044250\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中的调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等压入栈中；在执行完毕后，会弹出栈首的元素。而堆则存放了大量的非结构化数据，譬如程序分配的变量与对象。队列则包含了一系列待处理的信息与相关联的回调函数，每个 JavaScript 运行时都必须包含一个任务队列。当调用栈为空时，运行时会从队列中取出某个消息并且执行其关联的函数（也就是创建栈帧的过程）；运行时会递归调用函数并创建调用栈，直到函数调用栈全部清空再从任务队列中取出消息。换言之，譬如按钮点击或者 HTTP 请求响应都会作为消息存放在任务队列中；需要注意的是，仅当这些事件的回调函数存在时才会被放入任务队列，否则会被直接忽略。\x3c\/p\x3e\n\x3cp\x3e譬如对于如下的代码块：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fire() {\n    const result = sumSqrt(3, 4)\n    console.log(result);\n}\nfunction sumSqrt(x, y) {\n    const s1 = square(x)\n    const s2 = square(y)\n    const sum = s1 \x2b s2;\n    return Math.sqrt(sum)\n}\nfunction square(x) {\n    return x * x;\n}\n\nfire()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efire\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = sumSqrt(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esumSqrt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s1 = square(x)\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s2 = square(y)\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sum = s1 \x2b s2;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.sqrt(sum)\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x * x;\n}\n\nfire()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其对应的函数调用图（整理自\x3ca href=\x22https:\/\/github.com\/ccforward\/cc\/issues\/47\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e）为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044251\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044251\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里还值得一提的是，Promise.then 是异步执行的，而创建 Promise 实例 （executor） 是同步执行的，譬如下述代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function test() {\n    setTimeout(function() {console.log(4)}, 0);\n    new Promise(function executor(resolve) {\n        console.log(1);\n        for( var i=0 ; i\x3c10000 ; i\x2b\x2b ) {\n            i == 9999 \x26amp;\x26amp; resolve();\n        }\n        console.log(2);\n    }).then(function() {\n        console.log(5);\n    });\n    console.log(3);\n})()\n\n\/\/ 输出结果为：\n\/\/ 1\n\/\/ 2\n\/\/ 3\n\/\/ 5\n\/\/ 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eexecutor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e( \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ; i\x26lt;\x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e ; i\x2b\x2b ) {\n            i == \x3cspan class=\x22hljs-number\x22\x3e9999\x3c\/span\x3e \x26amp;\x26amp; resolve();\n        }\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n    }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n    });\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n})()\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出结果为：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以参考 Promise 规范中有关于 promise.then 的部分：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22promise.then(onFulfilled, onRejected)\n\n2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1].\n\nHere “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3epromise.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(onFulfilled, onRejected)\n\n\x3cspan class=\x22hljs-number\x22\x3e2.2\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.4\x3c\/span\x3e onFulfilled \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e onRejected must \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e be called \x3cspan class=\x22hljs-keyword\x22\x3euntil\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e execution context stack \x3cspan class=\x22hljs-keyword\x22\x3econtains\x3c\/span\x3e only \x3cspan class=\x22hljs-built_in\x22\x3eplatform\x3c\/span\x3e code. [\x3cspan class=\x22hljs-number\x22\x3e3.1\x3c\/span\x3e].\n\nHere “\x3cspan class=\x22hljs-built_in\x22\x3eplatform\x3c\/span\x3e code” means engine, environment, \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e promise implementation code. In practice, this requirement ensures that onFulfilled \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e onRejected execute asynchronously, \x3cspan class=\x22hljs-keyword\x22\x3eafter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e event loop turn \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e which \x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e is called, \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e fresh stack. This can be implemented \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e either \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e “macro-task” mechanism such \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e setTimeout \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e setImmediate, \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e “micro-task” mechanism such \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e MutationObserver \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.nextTick. Since \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e promise implementation is considered \x3cspan class=\x22hljs-built_in\x22\x3eplatform\x3c\/span\x3e code, \x3cspan class=\x22hljs-keyword\x22\x3eit\x3c\/span\x3e may itself contain \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e task-scheduling queue \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e “trampoline” \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e which \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e handlers are called.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e规范要求，onFulfilled 必须在执行上下文栈（Execution Context Stack） 只包含 平台代码（platform code） 后才能执行。平台代码指引擎，环境，Promise 实现代码等。实践上来说，这个要求保证了 onFulfilled 的异步执行（以全新的栈），在 then 被调用的这个事件循环之后。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e3. MacroTask（Task） 与 MicroTask（Job）\x3c\/h1\x3e\n\x3cp\x3e在面试中我们常常会碰到如下的代码题，其主要就是考校 JavaScript 不同任务的执行先后顺序：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 测试代码\nconsole.log(\x27main1\x27);\n\n\/\/ 该函数仅在 Node.js 环境下可以使用\nprocess.nextTick(function() {\n    console.log(\x27process.nextTick1\x27);\n});\n\nsetTimeout(function() {\n    console.log(\x27setTimeout\x27);\n    process.nextTick(function() {\n        console.log(\x27process.nextTick2\x27);\n    });\n}, 0);\n\nnew Promise(function(resolve, reject) {\n    console.log(\x27promise\x27);\n    resolve();\n}).then(function() {\n    console.log(\x27promise then\x27);\n});\n\nconsole.log(\x27main2\x27);\n\n\/\/ 执行结果\nmain1\npromise\nmain2\nprocess.nextTick1\npromise then\nsetTimeout\nprocess.nextTick2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27main1\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该函数仅在 Node.js 环境下可以使用\x3c\/span\x3e\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27process.nextTick1\x27\x3c\/span\x3e);\n});\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27setTimeout\x27\x3c\/span\x3e);\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27process.nextTick2\x27\x3c\/span\x3e);\n    });\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise\x27\x3c\/span\x3e);\n    resolve();\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise then\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27main2\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行结果\x3c\/span\x3e\nmain1\npromise\nmain2\nprocess.nextTick1\npromise then\nsetTimeout\nprocess.nextTick2\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在前文中已经介绍过 JavaScript 的主线程在遇到异步调用时，这些异步调用会立刻返回某个值，从而让主线程不会在此处阻塞。而真正的异步操作会由浏览器执行，主线程则会在清空当前调用栈后，按照先入先出的顺序读取任务队列里面的任务。而 JavaScript 中的任务又分为 MacroTask 与 MicroTask 两种，在 ES2015 中 MacroTask 即指 Task，而 MicroTask 则是指代 Job。典型的 MacroTask 包含了 setTimeout, setInterval, setImmediate, requestAnimationFrame, I\/O, UI rendering 等，MicroTask 包含了 process.nextTick, Promises, Object.observe, MutationObserver 等。 二者的关系可以图示如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000011044252\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000011044252\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e参考 \x3ca href=\x22https:\/\/html.spec.whatwg.org\/multipage\/webappapis.html#task-queue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewhatwg 规范\x3c\/a\x3e 中的描述：一个事件循环(Event Loop)会有一个或多个任务队列(Task Queue，又称 Task Source)，这里的 Task Queue 就是 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。每个 Task Queue 都保证自己按照回调入队的顺序依次执行，所以浏览器可以从内部到JS\/DOM，保证动作按序发生。而在 Task 的执行之间则会清空已有的 MicroTask 队列，在 MacroTask 或者 MicroTask 中产生的 MicroTask 同样会被压入到 MicroTask 队列中并执行。参考如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n  console.log(\x26quot;Start of queue\x26quot;);\n  bar();\n  setTimeout(function() {\n    console.log(\x26quot;Middle of queue\x26quot;);\n  }, 0);\n  Promise.resolve().then(function() {\n    console.log(\x26quot;Promise resolved\x26quot;);\n    Promise.resolve().then(function() {\n      console.log(\x26quot;Promise resolved again\x26quot;);\n    });\n  });\n  console.log(\x26quot;End of queue\x26quot;);\n}\n\nfunction bar() {\n  setTimeout(function() {\n    console.log(\x26quot;Start of next queue\x26quot;);\n  }, 0);\n  setTimeout(function() {\n    console.log(\x26quot;End of next queue\x26quot;);\n  }, 0);\n}\n\nfoo();\n\n\/\/ 输出\nStart of queue\nEnd of queue\nPromise resolved\nPromise resolved again\nStart of next queue\nEnd of next queue\nMiddle of queue\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Start of queue\x22\x3c\/span\x3e);\n  bar();\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Middle of queue\x22\x3c\/span\x3e);\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Promise resolved\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Promise resolved again\x22\x3c\/span\x3e);\n    });\n  });\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22End of queue\x22\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Start of next queue\x22\x3c\/span\x3e);\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22End of next queue\x22\x3c\/span\x3e);\n  }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\n\nfoo();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x3c\/span\x3e\nStart \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e queue\nEnd \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e queue\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e resolved\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e resolved again\nStart \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e next queue\nEnd \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e next queue\nMiddle \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e queue\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中首个 TaskQueue 即为 foo()，foo() 又调用了 bar() 构建了新的 TaskQueue，bar() 调用之后 foo() 又产生了 MicroTask 并被压入了唯一的 MicroTask 队列。我们最后再总计下 JavaScript MacroTask 与 MicroTask 的执行顺序，当执行栈(call stack)为空的时候，开始依次执行：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e把最早的任务(task A)放入任务队列\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果 task A 为null (那任务队列就是空)，直接跳到第6步\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将 currently running task 设置为 task A\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行 task A (也就是执行回调函数)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将 currently running task 设置为 null 并移出 task A\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e执行 microtask 队列\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ea: 在 microtask 中选出最早的任务 task X\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eb: 如果 task X 为null (那 microtask 队列就是空)，直接跳到 g\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ec: 将 currently running task 设置为 task X\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ed: 执行 task X\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ee: 将 currently running task 设置为 null 并移出 task X\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ef: 在 microtask 中选出最早的任务 , 跳到 b\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eg: 结束 microtask 队列\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e跳到第一步\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e4. 浅析 Vue.js 中 nextTick 的实现\x3c\/h1\x3e\n\x3cp\x3e在 Vue.js 中，其会异步执行 DOM 更新；当观察到数据变化时，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 \x3ccode\x3ePromise.then\x3c\/code\x3e 和 \x3ccode\x3eMutationObserver\x3c\/code\x3e，如果执行环境不支持，会采用 \x3ccode\x3esetTimeout(fn, 0)\x3c\/code\x3e 代替。\x3c\/p\x3e\n\x3cp\x3e《因为本人失误，原来此处内容拷贝了 \x3ca href=\x22https:\/\/www.zhihu.com\/question\/55364497\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.zhihu.com\/questio...\x3c\/a\x3e 这个回答，造成了侵权，深表歉意，已经删除，后续我会在 github 链接上重写本段》\x3c\/p\x3e\n\x3cp\x3e而当我们希望在数据更新之后执行某些 DOM 操作，就需要使用 \x3ccode\x3enextTick\x3c\/code\x3e 函数来添加回调：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ HTML\n\x3cdiv id=\x26quot;example\x26quot;\x3e\x22{{\x22message\x22}}\x22\x3c\/div\x3e\n\n\/\/ JS\nvar vm = new Vue({\n  el: \x27#example\x27,\n  data: {\n    message: \x27123\x27\n  }\n})\nvm.message = \x27new message\x27 \/\/ 更改数据\nvm.$el.textContent === \x27new message\x27 \/\/ false\nVue.nextTick(function () {\n  vm.$el.textContent === \x27new message\x27 \/\/ true\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ HTML\x3c\/span\x3e\n\x26lt;div id=\x3cspan class=\x22hljs-string\x22\x3e\x22example\x22\x3c\/span\x3e\x26gt;\x22{{\x22message\x22}}\x22\x26lt;\/div\x26gt;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#example\x27\x3c\/span\x3e,\n  data: {\n    message: \x3cspan class=\x22hljs-string\x22\x3e\x27123\x27\x3c\/span\x3e\n  }\n})\nvm.message = \x3cspan class=\x22hljs-string\x22\x3e\x27new message\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更改数据\x3c\/span\x3e\nvm.$el.textContent === \x3cspan class=\x22hljs-string\x22\x3e\x27new message\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\nVue.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  vm.$el.textContent === \x3cspan class=\x22hljs-string\x22\x3e\x27new message\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.component(\x27example\x27, {\n  template: \x27\x3cspan\x3e\x22{{\x22 message \x22}}\x22\x3c\/span\x3e\x27,\n  data: function () {\n    return {\n      message: \x27没有更新\x27\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = \x27更新完成\x27\n      console.log(this.$el.textContent) \/\/ =\x3e \x27没有更新\x27\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) \/\/ =\x3e \x27更新完成\x27\n      })\n    }\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3eVue.component(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;span\x26gt;\x22{{\x22 message \x22}}\x22\x26lt;\/span\x26gt;\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27没有更新\x27\x3c\/span\x3e\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eupdateMessage\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.message = \x3cspan class=\x22hljs-string\x22\x3e\x27更新完成\x27\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el.textContent) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27没有更新\x27\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el.textContent) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27更新完成\x27\x3c\/span\x3e\n      })\n    }\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esrc\/core\/util\/env\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/**\n * 使用 MicroTask 来异步执行批次任务\n *\/\nexport const nextTick = (function() {\n  \/\/ 需要执行的回调列表\n  const callbacks = [];\n\n  \/\/ 是否处于挂起状态\n  let pending = false;\n\n  \/\/ 时间函数句柄\n  let timerFunc;\n\n  \/\/ 执行并且清空所有的回调列表\n  function nextTickHandler() {\n    pending = false;\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (let i = 0; i \x3c copies.length; i\x2b\x2b) {\n      copies[i]();\n    }\n  }\n\n  \/\/ nextTick 的回调会被加入到 MicroTask 队列中，这里我们主要通过原生的 Promise 与 MutationObserver 实现\n  \/* istanbul ignore if *\/\n  if (typeof Promise !== \x27undefined\x27 \x26amp;\x26amp; isNative(Promise)) {\n    let p = Promise.resolve();\n    let logError = err =\x3e {\n      console.error(err);\n    };\n    timerFunc = () =\x3e {\n      p.then(nextTickHandler).catch(logError);\n\n      \/\/ 在部分 iOS 系统下的 UIWebViews 中，Promise.then 可能并不会被清空，因此我们需要添加额外操作以触发\n      if (isIOS) setTimeout(noop);\n    };\n  } else if (\n    typeof MutationObserver !== \x27undefined\x27 \x26amp;\x26amp;\n    (isNative(MutationObserver) ||\n      \/\/ PhantomJS and iOS 7.x\n      MutationObserver.toString() === \x27[object MutationObserverConstructor]\x27)\n  ) {\n    \/\/ 当 Promise 不可用时候使用 MutationObserver\n    \/\/ e.g. PhantomJS IE11, iOS7, Android 4.4\n    let counter = 1;\n    let observer = new MutationObserver(nextTickHandler);\n    let textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = () =\x3e {\n      counter = (counter \x2b 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    \/\/ 如果都不存在，则回退使用 setTimeout\n    \/* istanbul ignore next *\/\n    timerFunc = () =\x3e {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick(cb?: Function, ctx?: Object) {\n    let _resolve;\n    callbacks.push(() =\x3e {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, \x27nextTick\x27);\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n\n    \/\/ 如果没有传入回调，则表示以异步方式调用\n    if (!cb \x26amp;\x26amp; typeof Promise !== \x27undefined\x27) {\n      return new Promise((resolve, reject) =\x3e {\n        _resolve = resolve;\n      });\n    }\n  };\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 使用 MicroTask 来异步执行批次任务\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nextTick = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要执行的回调列表\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e callbacks = [];\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否处于挂起状态\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pending = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 时间函数句柄\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e timerFunc;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行并且清空所有的回调列表\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enextTickHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    pending = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e copies = callbacks.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    callbacks.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; copies.length; i\x2b\x2b) {\n      copies[i]();\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nextTick 的回调会被加入到 MicroTask 队列中，这里我们主要通过原生的 Promise 与 MutationObserver 实现\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; isNative(\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve();\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e logError = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err);\n    };\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      p.then(nextTickHandler).catch(logError);\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在部分 iOS 系统下的 UIWebViews 中，Promise.then 可能并不会被清空，因此我们需要添加额外操作以触发\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isIOS) setTimeout(noop);\n    };\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n    \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e MutationObserver !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp;\n    (isNative(MutationObserver) ||\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ PhantomJS and iOS 7.x\x3c\/span\x3e\n      MutationObserver.toString() === \x3cspan class=\x22hljs-string\x22\x3e\x27[object MutationObserverConstructor]\x27\x3c\/span\x3e)\n  ) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当 Promise 不可用时候使用 MutationObserver\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ e.g. PhantomJS IE11, iOS7, Android 4.4\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e observer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(nextTickHandler);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e textNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter));\n    observer.observe(textNode, {\n      \x3cspan class=\x22hljs-attr\x22\x3echaracterData\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    });\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      counter = (counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n      textNode.data = \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(counter);\n    };\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果都不存在，则回退使用 setTimeout\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore next *\/\x3c\/span\x3e\n    timerFunc = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      setTimeout(nextTickHandler, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    };\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3equeueNextTick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecb?: Function, ctx?: Object\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e _resolve;\n    callbacks.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb) {\n        \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n          cb.call(ctx);\n        } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n          handleError(e, ctx, \x3cspan class=\x22hljs-string\x22\x3e\x27nextTick\x27\x3c\/span\x3e);\n        }\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!pending) {\n      pending = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      timerFunc();\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有传入回调，则表示以异步方式调用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!cb \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        _resolve = resolve;\n      });\n    }\n  };\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e5. 延伸阅读\x3c\/h1\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/parg.co\/b2s\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e深入浅出 Node.js 全栈架构 - Node.js 事件循环机制详解与实践\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript Event Loop 机制详解与 Vue.js 中实践应用</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011044242">https://segmentfault.com/a/1190000011044242</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/o9kn7w1w6dm/" target="_blank">https://alili.tech/archive/o9kn7w1w6dm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>