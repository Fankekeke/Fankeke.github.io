<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从使用角度渐进式剖析Promise源码"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从使用角度渐进式剖析Promise源码 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ocn3waj3cqe/",
				"appid": "1613049289050283", 
				"title": "从使用角度渐进式剖析Promise源码 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9b854awzdxv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rnkapw09x6m/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&text=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&text=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&title=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&is_video=false&description=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&title=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&title=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&title=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2focn3waj3cqe%2f&title=%e4%bb%8e%e4%bd%bf%e7%94%a8%e8%a7%92%e5%ba%a6%e6%b8%90%e8%bf%9b%e5%bc%8f%e5%89%96%e6%9e%90Promise%e6%ba%90%e7%a0%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从使用角度渐进式剖析Promise源码</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e开篇\x3c\/h2\x3e\n\x3cp\x3e最近在 github 上看到了一个 extremely lightweight Promise polyfill 实现，打开源码发现只有240行，果然极其轻量级，于是带着惊叹和好奇的心理去了解了下其具体实现。\x3cbr\x3e源码的 github 地址：\x3ca href=\x22https:\/\/github.com\/taylorhakes\/promise-polyfill\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epromise-polyfill\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3ePromise 对于前端来说，是个老生常谈的话题，Promise 的出现解决了 js 回调地域的问题。目前市面上有很多 Promise 库，但其最终实现都要遵从 Promise\/A\x2b 规范,这里对规范不做解读，有兴趣的可以查看链接内容。\x3cbr\x3e\x3ca href=\x22https:\/\/promisesaplus.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\/A\x2b规范链接\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000002452115\x22\x3ePromise\/A\x2b规范中文链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本篇文章将从 Promise 的使用角度来剖析源码具体实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eAPI 列表\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise  \/\/ 构造函数\nPromise.prototype.then\nPromise.prototype.catch\nPromise.prototype.finally\n\n\/\/ 静态方法\nPromise.resolve\nPromise.reject\nPromise.race\nPromise.all\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ePromise  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.then\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.catch\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.finally\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 静态方法\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.resolve\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.reject\x3c\/span\x3e\nPromise\x3cspan class=\x22hljs-selector-class\x22\x3e.race\x3c\/span\x3e\nPromise.all\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e源码解析\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e构造函数\x3c\/h3\x3e\n\x3cp\x3e使用\x3cbr\x3ePromise 使用第一步，构造实例，传入 Function 形参，形参接收两个 Function 类型参数resolve, reject\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const asyncTask = () =\x3e {};\nconst pro = new Promise((resolve, reject) =\x3e {\n  asyncTask((err, data) =\x3e {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst asyncTask = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {};\nconst pro = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve, reject)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  asyncTask(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err, data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        reject(err);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        resolve(data);\n      }\n    });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e源码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError(\x27Promises must be constructed via new\x27);\n  if (typeof fn !== \x27function\x27) throw new TypeError(\x27not a function\x27);\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n  doResolve(fn, this);\n}\n\nfunction doResolve(fn, self) {\n  \/\/ done变量保护 resolve 和 reject 只执行一次\n  \/\/ 这个done在 Promise.race()函数中有用\n  var done = false;\n  try {\n    \/\/ 立即执行 Promise 传入的 fn(resolve,reject)\n    fn(\n      function(value) {\n        \/\/ resolve 回调\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        \/\/ reject 回调\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Promises must be constructed via new\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e fn !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27not a function\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._state = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._handled = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._value = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._deferreds = [];\n  doResolve(fn, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoResolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn, self\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ done变量保护 resolve 和 reject 只执行一次\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个done在 Promise.race()函数中有用\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e done = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 立即执行 Promise 传入的 fn(resolve,reject)\x3c\/span\x3e\n    fn(\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve 回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (done) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        done = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        resolve(self, value);\n      },\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereason\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reject 回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (done) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        done = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        reject(self, reason);\n      }\n    );\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (ex) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (done) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    done = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    reject(self, ex);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePromise必须通过构造函数实例化来使用，传入 Promise 构造函数的形参 fn 在doResolve方法内是 \x3cstrong\x3e立即调用执行\x3c\/strong\x3e 的，并没有异步(指放入事件循环队列)处理。doResolve内部针对 fn 函数的回调参数做了封装处理，done变量保证了 resolve reject 方法只执行一次，这在后面说到的Promise.race()函数实现有很大用处。\x3c\/p\x3e\n\x3ch4\x3ePromise 实例的内部变量介绍\x3c\/h4\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22left\x22\x3e名称\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e默认值\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e_state\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eNumber\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e0\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3ePromise内部状态码\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e_handled\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eBoolean\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3efalse\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eonFulfilled,onRejected是否被处理过\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e_value\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eAny\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eundefined\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3ePromise 内部值，resolve 或者 reject返回的值\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e_deferreds\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eArray\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e[]\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e存放 Handle 实例对象的数组，缓存 then 方法传入的回调\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e_state枚举值类型\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_state === 0  \/\/ pending\n_state === 1  \/\/ fulfilled,执行了resolve函数，并且_value instanceof Promise === true\n_state === 2  \/\/ rejected,执行了reject函数\n_state === 3  \/\/ fulfilled,执行了resolve函数，并且_value instanceof Promise === false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ini\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attr\x22\x3e_state\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e  \/\/ pending\n\x3cspan class=\x22hljs-attr\x22\x3e_state\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e  \/\/ fulfilled,执行了resolve函数，并且_value instanceof Promise === \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e_state\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e  \/\/ rejected,执行了reject函数\n\x3cspan class=\x22hljs-attr\x22\x3e_state\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e  \/\/ fulfilled,执行了resolve函数，并且_value instanceof Promise === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e：这里_state区分了1 和 3 两种状态，下面会解释原因\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Handle 构造函数\n * @param onFulfilled resolve 回调函数\n * @param onRejected reject 回调函数\n * @param promise 下一个 promise 实例对象\n * @constructor\n *\/\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === \x27function\x27 ? onFulfilled : null;\n  this.onRejected = typeof onRejected === \x27function\x27 ? onRejected : null;\n  this.promise = promise;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Handle 构造函数\n * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e onFulfilled resolve 回调函数\n * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e onRejected reject 回调函数\n * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e promise 下一个 promise 实例对象\n * \x3cspan class=\x22hljs-doctag\x22\x3e@constructor\x3c\/span\x3e\n *\/\x3c\/span\x3e\nfunction Handler(onFulfilled, onRejected, promise) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFulfilled = typeof onFulfilled === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ? onFulfilled : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onRejected = typeof onRejected === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ? onRejected : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promise = promise;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e_deferreds数组的意义：当在 Promise 内部调用了异步处理任务时，pro.then(onFulfilled,onRejected)传入的两个函数不会立即执行，所以此时会把当前的回调和下一个 pro 对象关联缓存起来，待到 resolve 或者 reject触发调用时，会去 forEach 这个_deferreds数组中的每个 Handle 实例去处理对应的 onFulfilled,onRejected 方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ePromise 内部 resolve reject finale 方法\x3c\/h3\x3e\n\x3cp\x3e上面说到，doResolve 内部做了 fn 的立即执行，并保证 resolve 和 reject 方法只执行一次，接下来说说resolve 和 reject 内部具体做了什么\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resolve(self, newValue) {\n  try {\n    \/\/ resolve 的值不能为本身 this 对象\n    \/\/ Promise Resolution Procedure: https:\/\/github.com\/promises-aplus\/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError(\x27A promise cannot be resolved with itself.\x27);\n    \/\/ 针对 resolve 值为 Promise 对象的情况处理\n    if (\n      newValue \x26amp;\x26amp;\n      (typeof newValue === \x27object\x27 || typeof newValue === \x27function\x27)\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === \x27function\x27) {\n        \/\/ 兼容类 Promise 对象的处理方式，对其 then 方法继续执行 doResolve\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    \/\/  resolve 正常值的流程，_state = 1\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  \/\/  Promise reject 情况，但是 then 方法未提供 reject 回调函数参数 或者 未实现 catch 函数\n  if (self._state === 2 \x26amp;\x26amp; self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i \x3c len; i\x2b\x2b) {\n    \/\/ 这里调用之前 then 方法传入的onFulfilled, onRejected函数\n    \/\/ self._deferreds[i] =\x3e Handler 实例对象\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e\x3c\/span\x3e(self, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve 的值不能为本身 this 对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Promise Resolution Procedure: https:\/\/github.com\/promises-aplus\/promises-spec#the-promise-resolution-procedure\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === self)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27A promise cannot be resolved with itself.\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 针对 resolve 值为 Promise 对象的情况处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e \x26amp;\x26amp;\n      (typeof \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || typeof \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)\n    ) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e then = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e.then;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e instanceof Promise) {\n        self._state = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n        self._value = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e;\n        finale(self);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof then === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 兼容类 Promise 对象的处理方式，对其 then 方法继续执行 doResolve\x3c\/span\x3e\n        doResolve(bind(then, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e), self);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  resolve 正常值的流程，_state = 1\x3c\/span\x3e\n    self._state = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    self._value = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e;\n    finale(self);\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    reject(self, e);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereject\x3c\/span\x3e\x3c\/span\x3e(self, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e) {\n  self._state = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n  self._value = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e;\n  finale(self);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efinale\x3c\/span\x3e\x3c\/span\x3e(self) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  Promise reject 情况，但是 then 方法未提供 reject 回调函数参数 或者 未实现 catch 函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (self._state === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x26amp;\x26amp; self._deferreds.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    Promise._immediateFn(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e() {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = self._deferreds.length; i \x26lt; len; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里调用之前 then 方法传入的onFulfilled, onRejected函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ self._deferreds[i] =\x26gt; Handler 实例对象\x3c\/span\x3e\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eresolve,reject 是由用户在异步任务里面触发的回调函数\x3cbr\x3e调用 resolve reject 方法的注意点\x3cbr\x3e1、\x3cstrong\x3enewValue不能为当前的 this 对象\x3c\/strong\x3e，即下面的这样写法是错误的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const pro = new Promise((resolve)=\x3e{setTimeout(function () {\n  resolve(pro);\n},1000)});\npro.then(data =\x3e console.log(data)).catch(err =\x3e {console.log(err)});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  resolve(pro);\n},\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)});\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为resolve做了 try catch 的操作，直接会进入 reject 流程。\x3c\/p\x3e\n\x3cp\x3e2、\x3cstrong\x3enewValue可以为另一个Promise 对象类型实例\x3c\/strong\x3e， resolve 的值返回的是另一个 Promise 对象实例的内部的_value,而不是其本身 Promise 对象。即可以这样写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const pro1 = new Promise((resolve)=\x3e{setTimeout(function () {\n  resolve(100);\n},2000)});\nconst pro = new Promise((resolve)=\x3e{setTimeout(function () {\n  resolve(pro1);\n},1000)});\npro.then(data =\x3e console.log(\x27resolve\x27 \x2b data)).catch(err =\x3e {console.log(\x27reject\x27 \x2b err)});\n\/\/ 输出结果：resolve 100\n\/\/ data 并不是pro1对象\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  resolve(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\n},\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)});\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  resolve(pro1);\n},\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)});\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27resolve\x27\x3c\/span\x3e \x2b data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27reject\x27\x3c\/span\x3e \x2b err)});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出结果：resolve 100\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ data 并不是pro1对象\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e具体原因就在 resolve 方法体内部做了newValue instanceof Promise的判断，并将当前的_state=3,self._value = newValue,然后进入 finale 方法体，在 handle 方法做了核心处理，这个下面介绍 handle 方法会说到；\x3c\/p\x3e\n\x3cp\x3e这里有一个注意点，resolve 的 value 可能是其他框架的 Promise(比如：global.Promise，nodejs 内部的 Promise 实现) 构造实例，所以在typeof then === \x27function\x27条件下做了doResolve(bind(then, newValue), self);的重新调用，继续执行当前类型的 Promise then 方法，即又重新回到了doResolve流程。\x3c\/p\x3e\n\x3cp\x3e如果这里的实现方式稍微调整下，即不管newValue是自身的 Promise 实例还是其他框架实现的 Promise实例，都执行doResolve(bind(then, newValue), self)也能行得通,只不过会多执行 then 方式一次，从代码性能上说，上面的实现方式会更好。参照代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resolve(self, newValue) {\n  try {\n    \/\/ Promise Resolution Procedure: https:\/\/github.com\/promises-aplus\/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError(\x27A promise cannot be resolved with itself.\x27);\n    if (\n      newValue \x26amp;\x26amp;\n      (typeof newValue === \x27object\x27 || typeof newValue === \x27function\x27)\n    ) {\n      \/\/ 这里简单粗暴处理，无论是 Promise 还是 global.Promise\n      \/\/ 都直接调用doResolve\n      var then = newValue.then;\n      if (typeof then === \x27function\x27) {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    \/\/  resolve 正常值的流程，_state = 1\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e\x3c\/span\x3e(self, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Promise Resolution Procedure: https:\/\/github.com\/promises-aplus\/promises-spec#the-promise-resolution-procedure\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === self)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27A promise cannot be resolved with itself.\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e \x26amp;\x26amp;\n      (typeof \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || typeof \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)\n    ) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里简单粗暴处理，无论是 Promise 还是 global.Promise\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 都直接调用doResolve\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e then = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e.then;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof then === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n        doResolve(bind(then, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e), self);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  resolve 正常值的流程，_state = 1\x3c\/span\x3e\n    self._state = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    self._value = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eValue\x3c\/span\x3e;\n    finale(self);\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    reject(self, e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有 resolve 和 reject 的值最终都会去到finale函数中去处理,只不过在这里的_state状态会有所不同；当Promise 出现reject的情况时，而没有提供 onRejected 函数时，内部会打印一个错误出来，提示要捕获错误。代码实现即\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const pro = new Promise((resolve,reject)=\x3e{setTimeout(function () {\n  reject(100);\n},1000)});\npro.then(data =\x3e console.log(data));  \/\/ 会报错\npro.then(data =\x3e console.log(data)).catch();  \/\/ 会报错\npro.then(data =\x3e console.log(data)).catch(()=\x3e{});  \/\/ 不会报错\npro.then(data =\x3e console.log(data),()=\x3e{})  \/\/ 不会报错\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  reject(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\n},\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)});\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 会报错\x3c\/span\x3e\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 会报错\x3c\/span\x3e\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{});  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不会报错\x3c\/span\x3e\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data),\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{})  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不会报错\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ethen、catch、finally 方法\x3c\/h3\x3e\n\x3cp\x3e第二步，调用 then 方法来处理回调,支持无限链式调用，then 方法第一个参数成功回调，第二个参数失败或者异常回调\x3c\/p\x3e\n\x3cp\x3e源码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function noop() {}\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype[\x27catch\x27] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype[\x27finally\x27] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enoop\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\nPromise.prototype.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(onFulfilled, onRejected)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prom = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor(noop);\n  handle(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Handler(onFulfilled, onRejected, prom));\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e prom;\n};\n\nPromise.prototype[\x3cspan class=\x22hljs-string\x22\x3e\x27catch\x27\x3c\/span\x3e] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(onRejected)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, onRejected);\n};\n\nPromise.prototype[\x3cspan class=\x22hljs-string\x22\x3e\x27finally\x27\x3c\/span\x3e] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(callback)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e constructor = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then(\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(value)\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e constructor.resolve(callback()).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value;\n      });\n    },\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(reason)\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e constructor.resolve(callback()).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e constructor.reject(reason);\n      });\n    }\n  );\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePromise.prototype.then方法内部构造了一个新的Promsie 实例并返回，这样从 api 角度解决了 Promise 链式调用的问题，而且值得注意的是，\x3cstrong\x3e每个 then 方法返回的都是一个新的 Promise 对象，并不是当前的 this链接调用方式\x3c\/strong\x3e。最终的处理都会调用 handle 方法。\x3c\/p\x3e\n\x3cp\x3ecatch方法在 then 方法上做了一个简单的封装，所以从这里也可以看出，then 方法的形参并不是必传的，catch 只接收onRejected。\x3c\/p\x3e\n\x3cp\x3efinally方法不管是调用了 then 还是 catch，最终都会执行到finally的 callback\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e核心逻辑：handle方法内部实现\x3c\/h3\x3e\n\x3cp\x3e上面说了这么多，最终的 resolve reject 回调处理都会进入到 handle 方法中，来处理onFulfilled 和 onRejected，先看源码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise._immediateFn =\n  (typeof setImmediate === \x27function\x27 \x26amp;\x26amp;\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n  \nfunction handle(self, deferred) {\n  \/\/ 如果当前的self._value instanceof Promise\n  \/\/ 将self._value =\x3e self，接下来处理新 Promise\n  while (self._state === 3) {\n    self = self._value;\n  }\n  \/\/ self._state=== 0 说明还没有执行 resolve || reject 方法\n  \/\/ 此处将 handle 挂起\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  \/\/ 通过事件循环异步来做回调的处理\n  Promise._immediateFn(function() {\n    \/\/ deferred.promise ：第一个 Promise then 方法 返回的新 Promise 对象\n    \/\/ 这里调用下一个 Promise 对象的 then 方法的回调函数\n    \/\/ 如果当前 Promise resolve 了，则调用下一个 Promise 的 resolve方法，反之，则调用下一个 Promise 的 reject 回调\n    \/\/ 如果当前 Promise resolve 了，则调用下一个 Promise 的 resolve方法\n    \/\/ cb回调方法：如果自己有onFulfilled||onRejected方法，则执行自己的方法；如果没有，则调用下一个 Promise 对象的onFulfilled||onRejected\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    \/\/ 自己没有回调函数，进入下一个 Promise 对象的回调\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    \/\/ 自己有回调函数，进入自己的回调函数\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    \/\/ 处理下一个 Promise 的 then 回调方法\n    \/\/ ret 作为上一个Promise then 回调 return的值 =\x3e 返回给下一个Promise then 作为输入值\n    resolve(deferred.promise, ret);\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3ePromise._immediateFn =\n  (typeof setImmediate === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fn)\x3c\/span\x3e \x3c\/span\x3e{\n      setImmediate(fn);\n    }) ||\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fn)\x3c\/span\x3e \x3c\/span\x3e{\n    setTimeoutFunc(fn, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  };\n  \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandle\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(self, deferred)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前的self._value instanceof Promise\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将self._value =\x26gt; self，接下来处理新 Promise\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._state === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._value;\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ self._state=== 0 说明还没有执行 resolve || reject 方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此处将 handle 挂起\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._state === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._deferreds.push(deferred);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._handled = \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过事件循环异步来做回调的处理\x3c\/span\x3e\n  Promise._immediateFn(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ deferred.promise ：第一个 Promise then 方法 返回的新 Promise 对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里调用下一个 Promise 对象的 then 方法的回调函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前 Promise resolve 了，则调用下一个 Promise 的 resolve方法，反之，则调用下一个 Promise 的 reject 回调\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前 Promise resolve 了，则调用下一个 Promise 的 resolve方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cb回调方法：如果自己有onFulfilled||onRejected方法，则执行自己的方法；如果没有，则调用下一个 Promise 对象的onFulfilled||onRejected\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cb = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._state === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? deferred.onFulfilled : deferred.onRejected;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自己没有回调函数，进入下一个 Promise 对象的回调\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb === \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e) {\n      (\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._state === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? resolve : reject)(deferred.promise, \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._value);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自己有回调函数，进入自己的回调函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      ret = cb(\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._value);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n      reject(deferred.promise, e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理下一个 Promise 的 then 回调方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ret 作为上一个Promise then 回调 return的值 =\x26gt; 返回给下一个Promise then 作为输入值\x3c\/span\x3e\n    resolve(deferred.promise, ret);\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eself._state === 3，说明当前 resolve(promise)方法回传的值类型为 Promise 对象,\x3cbr\x3e即 self._value instanceOf Promise === true， \x3cstrong\x3e将 self=self._value,即当前处理变更到了新的 Promise 对象上\x3c\/strong\x3e ，如果当前 promise对象内部状态是fulfilled或者 rejected，则直接处理onFulfilled 或者 onRejected回调；如果仍然是 padding 状态，则继续等待。这就很好的解释了为什么resolve(pro1),pro.then的回调取的值却是 pro1._value.\x3cbr\x3e从使用角度来看\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const pro1 = new Promise(resolve=\x3e{setTimeout(()=\x3e{resolve(100)},1000)})  \/\/ 执行耗时1s 的异步任务\npro.then(()=\x3epro1).then(data =\x3e console.log(data)).catch(err =\x3e {});\n\/\/ 输出结果: 正常打印了100，data并不是当前的pro1对象\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{resolve(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)},\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)})  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行耗时1s 的异步任务\x3c\/span\x3e\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3epro1).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出结果: 正常打印了100，data并不是当前的pro1对象\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epro1内部是耗时1s 的异步任务，此时self._state === 0，即内部是 Padding 状态，则将deferred对象 push 到_deferreds数组里面,然后等待 pro1内部调用resolve(100)时，继续上面resolve方法体执行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const pro1 = new Promise(resolve=\x3eresolve(100)}) \/\/ 执行同步任务\npro.then(()=\x3epro1).then(data =\x3e console.log(data)).catch(err =\x3e {});\n\/\/ 输出结果: 正常打印了100，data并不是当前的pro1对象\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pro1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e=\x26gt;\x3c\/span\x3eresolve(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)}) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行同步任务\x3c\/span\x3e\npro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3epro1).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出结果: 正常打印了100，data并不是当前的pro1对象\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是如果pro1内部是同步任务，立即执行的话，当前的self._state === 1，即调过 push 到_deferreds数组的操作，执行最后的onFulfilled, onRejected回调,\x3cstrong\x3eonFulfilled, onRejected会被放入到事件循环队列里面执行\x3c\/strong\x3e，即执行到了Promise._immediateFn\x3c\/p\x3e\n\x3cp\x3ePromise._immediateFn回调函数放到了事件循环队列里面来执行\x3cbr\x3e这里的deferred对象存放了当前的onFulfilled和onRejected回调函数和下一个 promise 对象。\x3cbr\x3e当前对象的onFulfilled和onRejected如果存在时，则执行自己的回调；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pro.then(data =\x3e data}).then(data =\x3e data).catch(err =\x3e {});\n\/\/ 正确写法: 输出两次  data \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3epro\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e}).then(\x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e =\x26gt; \x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e).catch(\x3cspan class=\x22hljs-title\x22\x3eerr\x3c\/span\x3e =\x26gt; {});\x3c\/span\x3e\n\/\/ 正确写法: 输出两次  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e：then 方法一定要做 return 下一个值的操作，因为当前的 ret 值会被带入到下一个 Promise 对象,即 resolve(deferred.promise, ret)。如果不提供返回值，则第二个 then 的 data 会变成 undefined，即这样的错误写法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pro.then(data =\x3e {\x22}}\x22).then(data =\x3e data).catch(err =\x3e {});\n\/\/ 错误写法: 第二个 then 方法的 data 为 undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3epro\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; {\x22}}\x22).then(\x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e =\x26gt; \x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e).catch(\x3cspan class=\x22hljs-title\x22\x3eerr\x3c\/span\x3e =\x26gt; {});\x3c\/span\x3e\n\/\/ 错误写法: 第二个 \x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e 方法的 \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e 为 undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果onFulfilled和onRejected回调不存在，则执行下一个 promise 的回调并携带当前的_value 值。即可以这样写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pro.then().then().then().then(data =\x3e {}).catch(err =\x3e {});\n\/\/ 正确写法: 第四个 then 方法仍然能取到第一个pro 的内部_value 值\n\/\/ 当然前面的三个 then 写起来毫无用处\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3epro\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; {}).catch(\x3cspan class=\x22hljs-title\x22\x3eerr\x3c\/span\x3e =\x26gt; {});\x3c\/span\x3e\n\/\/ 正确写法: 第四个 \x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e 方法仍然能取到第一个pro 的内部_value 值\n\/\/ 当然前面的三个 \x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e 写起来毫无用处\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以针对下面的情况：当第一个 then 提供了 reject 回调，后面又跟了个 catch 方法。\x3cbr\x3e当 reject 时，会优先执行第一个 Promise 的onRejected回调函数，catch 是在下一个 Promise 对象上的捕获错误方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pro.then(data =\x3e data,err =\x3e err).catch(err =\x3e err);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3epro.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e data,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e err).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e err);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终总结:\x3cstrong\x3eresolve 要么提供带返回值的回调，要么不提供回调函数\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e静态方法：race\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i \x3c len; i\x2b\x2b) {\n      \/\/ 因为doResolve方法内部 done 变量控制了对 resolve reject 方法只执行一次的处理\n      \/\/ 所以这里实现很简单，清晰明了，最快的 Promise 执行了  resolve||reject，后面相对慢的 \/\/ Promise都不执行\n      values[i].then(resolve, reject);\n    }\n  });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.race = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalues\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = values.length; i \x26lt; len; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为doResolve方法内部 done 变量控制了对 resolve reject 方法只执行一次的处理\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所以这里实现很简单，清晰明了，最快的 Promise 执行了  resolve||reject，后面相对慢的 \/\/ Promise都不执行\x3c\/span\x3e\n      values[i].then(resolve, reject);\n    }\n  });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.race([pro1,pro2,pro3]).then()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ePromise\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.race\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-attr\x22\x3e[pro1,pro2,pro3]\x3c\/span\x3e)\x3cspan class=\x22hljs-selector-class\x22\x3e.then\x3c\/span\x3e()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3erace的实现非常巧妙，对当前的 values(必须是 Promise 数组) for 循环执行每个 Promise 的 then 方法，resolve, reject方法对于所有race中 promise 对象都是公用的，从而利用doResolve内部的 done变量，保证了最快执行的 Promise 能做 resolve reject 的回调，从而达到了多个Promise race 竞赛的机制，谁跑的快执行谁。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e静态方法：all\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === \x27undefined\x27)\n      throw new TypeError(\x27Promise.all accepts an array\x27);\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        \/\/ 如果 val 是 Promise 对象的话，则执行 Promise,直到 resolve 了一个非 Promise 对象\n        if (val \x26amp;\x26amp; (typeof val === \x27object\x27 || typeof val === \x27function\x27)) {\n          var then = val.then;\n          if (typeof then === \x27function\x27) {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        \/\/ 用当前resolve||reject 的值重写 args[i]{Promise} 对象\n        args[i] = val;\n        \/\/ 直到所有的 Promise 都执行完毕，则 resolve all 的 Promise 对象，返回args数组结果\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        \/\/ 只要其中一个 Promise 出现异常，则全部的 Promise 执行退出，进入 catch异常处理\n        \/\/ 因为 resolve 和 reject 回调有 done 变量的保证只能执行一次，所以其他的 Promise 都不执行\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i \x3c args.length; i\x2b\x2b) {\n      res(i, args[i]);\n    }\n  });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!arr || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e arr.length === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Promise.all accepts an array\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(arr);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (args.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e resolve([]);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e remaining = args.length;\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eres\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ei, val\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 val 是 Promise 对象的话，则执行 Promise,直到 resolve 了一个非 Promise 对象\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (val \x26amp;\x26amp; (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)) {\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e then = val.then;\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e then === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n            then.call(\n              val,\n              \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e) \x3c\/span\x3e{\n                res(i, val);\n              },\n              reject\n            );\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n          }\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用当前resolve||reject 的值重写 args[i]{Promise} 对象\x3c\/span\x3e\n        args[i] = val;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直到所有的 Promise 都执行完毕，则 resolve all 的 Promise 对象，返回args数组结果\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (--remaining === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n          resolve(args);\n        }\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (ex) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只要其中一个 Promise 出现异常，则全部的 Promise 执行退出，进入 catch异常处理\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为 resolve 和 reject 回调有 done 变量的保证只能执行一次，所以其他的 Promise 都不执行\x3c\/span\x3e\n        reject(ex);\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; args.length; i\x2b\x2b) {\n      res(i, args[i]);\n    }\n  });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.all([pro1,pro2,pro3]).then()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ePromise\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.all\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-attr\x22\x3e[pro1,pro2,pro3]\x3c\/span\x3e)\x3cspan class=\x22hljs-selector-class\x22\x3e.then\x3c\/span\x3e()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eall 等待所有的 Promise 都执行完毕，才会执行 Promise.all().then()回调，只要其中一个出错，则直接进入错误回调，因为对于所有 all 中 promise 对象 reject 回调是公用的，利用doResolve内部的 done变量,保证一次错误终止所有操作。\x3c\/p\x3e\n\x3cp\x3e但是对于 resolve 则不一样， resolve 回调函数通过 res 递归调用自己,从而保证其值_value不为 Promise 类型才结束，并将_value 赋值到 args 数组，最后直到所有的数组Promise都处理完毕由统一的 resolve 方法结束当前的 all 操作，进入 then 处理流程。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3e本篇针对 Promise 的所有 api 做了详细的代码解释和使用场景，篇幅可能过长，看起来比较费力，如果有写的不对的地方欢迎指正。\x3c\/p\x3e\n\x3cp\x3e最后附上我的 github 源码注释版链接  \x3ca href=\x22https:\/\/github.com\/frontMoment\/promise-polyfill-analyze\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epromise源码注释版\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从使用角度渐进式剖析Promise源码</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014368256">https://segmentfault.com/a/1190000014368256</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ocn3waj3cqe/" target="_blank">https://alili.tech/archive/ocn3waj3cqe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>