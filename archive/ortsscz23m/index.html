<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue 使用中的小技巧"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue 使用中的小技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ortsscz23m/",
				"appid": "1613049289050283", 
				"title": "Vue 使用中的小技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-04T02:30:05"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/yfnek81dnst/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tguc2fjhebo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&text=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&text=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&title=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&is_video=false&description=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&title=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&title=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&title=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fortsscz23m%2f&title=Vue%20%e4%bd%bf%e7%94%a8%e4%b8%ad%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue 使用中的小技巧</h1><div class="meta"><div class="postdate"><time datetime="2018-12-04" itemprop="datePublished">2018-12-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在vue的使用过程中会遇到各种场景，当普通使用时觉得没什么，但是或许优化一下可以更高效更优美的进行开发。下面有一些我在日常开发的时候用到的小技巧，在下将不定期更新~\x3c\/p\x3e\n\x3ch2\x3e1. 多图表resize事件去中心化\x3c\/h2\x3e\n\x3ch3\x3e1.1 一般情况\x3c\/h3\x3e\n\x3cp\x3e有时候我们会遇到这样的场景，一个组件中有几个图表，在浏览器resize的时候我们希望图表也进行resize，因此我们会在父容器组件中写：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3emounted() {\n  setTimeout(() =\x26gt; window.onresize = () =\x26gt; {\n    this.$refs.chart1.chartWrapperDom.resize()\n    this.$refs.chart2.chartWrapperDom.resize()\n    \/\/ ... \n  }, 200)\ndestroyed() { window.onresize = null }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样子图表组件如果跟父容器组件不在一个页面，子组件的状态就被放到父组件进行管理，为了维护方便，我们自然希望子组件的事件和状态由自己来维护，这样在添加删除组件的时候就不需要去父组件挨个修改\x3c\/p\x3e\n\x3ch3\x3e1.2 优化\x3c\/h3\x3e\n\x3cp\x3e这里使用了\x3ca href=\x22https:\/\/lodash.com\/\x22 rel=\x22nofollow noreferrer\x22\x3elodash\x3c\/a\x3e的节流throttle函数，也可以自己实现，这篇\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014292298\x22\x3e文章\x3c\/a\x3e也有节流的实现可以参考一下。\x3cbr\x3e以Echarts为例，在每个图表组件中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3ecomputed: {\n  \/**\n   * 图表DOM\n   *\/\n  chartWrapperDom() {\n    const dom = document.getElementById(\x27consume-analy-chart-wrapper\x27)\n    return dom \x26amp;\x26amp; Echarts.init(dom)\n  },\n  \/**\n   * 图表resize节流，这里使用了lodash，也可以自己使用setTimout实现节流\n   *\/\n  chartResize() {\n    return _.throttle(() =\x26gt; this.chartWrapperDom \x26amp;\x26amp; this.chartWrapperDom.resize(), 400)\n  }\n},\nmounted() {\n  window.addEventListener(\x27resize\x27, this.chartResize)\n},\ndestroyed() {\n  window.removeEventListener(\x27resize\x27, this.chartResize)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e1.3 再次优化\x3c\/h3\x3e\n\x3cp\x3e感谢 @JserWang 的提醒，这里因为多个 chart 实例都使用同一套初始化逻辑，可以使用 extends 来考虑复用，因此我想到了 Vue 提供的 \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/mixins.html#%E5%9F%BA%E7%A1%80\x22 rel=\x22nofollow noreferrer\x22\x3eMixins\x3c\/a\x3e，所以我在这里做了点优化，可以让每个同类型的 chart 组件更优雅一点：\x3cbr\x3e新建一个 mixin.js 文件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport Echarts from \x27echarts\x27\nimport _ from \x27lodash\x27\n\nexport default {\n  computed: {\n    \/* 图表DOM *\/\n    $_chartMixin_chartWrapperDom() {\n      const dom = document.getElementById(this.thisDomId)\n      return dom \x26amp;\x26amp; Echarts.init(dom)\n    },\n    \n    \/** 图表resize节流，这里使用了lodash，也可以自己使用setTimout实现节流 *\/\n    $_chartMixin_chartResize() {\n      return _.throttle(() =\x26gt; this.$_chartMixin_chartWrapperDom.resize(), 400)\n    }\n  },\n  \n  methods: {\n    \/* 图表初始化 *\/\n    $_chartMixin_initChart() {\n      this.$_chartMixin_chartWrapperDom.setOption({ \/* options *\/ }\n  },\n  \n  mounted() {\n    this.$_chartMixin_initChart()\n    window.addEventListener(\x27resize\x27, this.$_chartMixin_chartResize)\n  },\n  \n  destroyed() {\n    window.removeEventListener(\x27resize\x27, this.$_chartMixin_chartResize)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在每个 chart 组件中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\x26lt;script type=\x27text\/javascript\x27\x26gt;\nimport ChartMixin from \x27.\/mixin\x27\nexport default {\n  mixins: [ChartMixin],\n  data() {\n    return {\n      thisDomId: \x27consume-analy-chart-wrapper\x27\n    }\n  }\n}\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样就可以在每个图表组件中混入之前在 \x3ccode\x3emixin.js\x3c\/code\x3e 中定义的 resize 事件逻辑，且自动初始化，并在 destroyed 的时候自动销毁事件~\x3c\/p\x3e\n\x3ch2\x3e2. 全局过滤器注册\x3c\/h2\x3e\n\x3ch3\x3e2.1 一般情况\x3c\/h3\x3e\n\x3cp\x3e官方注册过滤器的方式：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eexport default {\n  data () { return {} },\n  filters:{\n    orderBy (){\n      \/\/ doSomething\n    },\n    uppercase () {\n      \/\/ doSomething\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是我们做项目来说，大部分的过滤器是要全局使用的，不会每每用到就在组件里面去写，抽成全局的会更好些。\x3cbr\x3e\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#filters\x22 rel=\x22nofollow noreferrer\x22\x3e官方\x3c\/a\x3e注册全局的方式：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\/\/ 注册\nVue.filter(\x27my-filter\x27, function (value) {\n  \/\/ 返回处理后的值\n})\n\/\/ getter，返回已注册的过滤器\nvar myFilter = Vue.filter(\x27my-filter\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是分散写的话不美观，因此可以抽出成单独文件。\x3c\/p\x3e\n\x3ch3\x3e2.2 优化\x3c\/h3\x3e\n\x3cp\x3e我们可以抽出到独立文件，然后使用Object.keys在main.js入口统一注册\x3c\/p\x3e\n\x3cp\x3e\/src\/common\/filters.js\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3elet dateServer = value =\x26gt; value.replace(\/(\\d{4})(\\d{2})(\\d{2})\/g, \x27$1-$2-$3\x27) \n\nexport { dateServer }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\/src\/main.js\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport * as custom from \x27.\/common\/filters\/custom\x27\nObject.keys(custom).forEach(key =\x26gt; Vue.filter(key, custom[key]))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在其他的.vue 文件中就可愉快地使用这些我们定义好的全局过滤器了\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;section class=\x22content\x22\x26gt;\n    \x26lt;p\x26gt;\x22{{\x22 time | dateServer \x22}}\x22\x26lt;\/p\x26gt; \x26lt;!-- 2016-01-01 --\x26gt;\n  \x26lt;\/section\x26gt;\n\x26lt;\/template\x26gt;\n\x26lt;script\x26gt;\n  export default {\n    data () {\n      return {\n        time: 20160101\n      }\n    }\n  }\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2\x3e3. 全局组件注册\x3c\/h2\x3e\n\x3ch3\x3e3.1 一般情况\x3c\/h3\x3e\n\x3cp\x3e需要使用组件的场景：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n    \x26lt;BaseInput  v-model=\x22searchText\x22  @keydown.enter=\x22search\x22\/\x26gt;\n    \x26lt;BaseButton @click=\x22search\x22\x26gt;\n        \x26lt;BaseIcon name=\x22search\x22\/\x26gt;\n    \x26lt;\/BaseButton\x26gt;\n\x26lt;\/template\x26gt;\n\x26lt;script\x26gt;\n    import BaseButton from \x27.\/baseButton\x27\n    import BaseIcon from \x27.\/baseIcon\x27\n    import BaseInput from \x27.\/baseInput\x27\n    export default {\n      components: { BaseButton, BaseIcon, BaseInput }\n    }\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们写了一堆基础UI组件，然后每次我们需要使用这些组件的时候，都得先import，然后声明components，很繁琐，这里可以使用统一注册的形式\x3c\/p\x3e\n\x3ch3\x3e3.2 优化\x3c\/h3\x3e\n\x3cp\x3e我们需要借助一下神器webpack，使用 \x3ca href=\x22https:\/\/doc.webpack-china.org\/guides\/dependency-management\/#require-context\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3erequire.context()\x3c\/code\x3e\x3c\/a\x3e 方法来创建自己的\x3cstrong\x3e模块\x3c\/strong\x3e上下文，从而实现自动动态require组件。这个方法需要3个参数：要搜索的文件夹目录、是否还应该搜索它的子目录、以及一个匹配文件的正则表达式。\x3cbr\x3e我们在components文件夹添加一个叫componentRegister.js的文件，在这个文件里借助webpack动态将需要的基础组件统统打包进来。\x3c\/p\x3e\n\x3cp\x3e\/src\/components\/componentRegister.js\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport Vue from \x27vue\x27\n\n\/**\n * 首字母大写\n * @param str 字符串\n * @example heheHaha\n * @return {string} HeheHaha\n *\/\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() \x2b str.slice(1)\n}\n\n\/**\n * 对符合\x27xx\/xx.vue\x27组件格式的组件取组件名\n * @param str fileName\n * @example abc\/bcd\/def\/basicTable.vue\n * @return {string} BasicTable\n *\/\nfunction validateFileName(str) {\n  return \/^\\S\x2b\\.vue$\/.test(str) \x26amp;\x26amp;\n    str.replace(\/^\\S\x2b\\\/(\\w\x2b)\\.vue$\/, (rs, $1) =\x26gt; capitalizeFirstLetter($1))\n}\n\nconst requireComponent = require.context(\x27.\/\x27, true, \/\\.vue$\/)\n\n\/\/ 找到组件文件夹下以.vue命名的文件，如果文件名为index，那么取组件中的name作为注册的组件名\nrequireComponent.keys().forEach(filePath =\x26gt; {\n  const componentConfig = requireComponent(filePath)\n  const fileName = validateFileName(filePath)\n  const componentName = fileName.toLowerCase() === \x27index\x27\n    ? capitalizeFirstLetter(componentConfig.default.name)\n    : fileName\n  Vue.component(componentName, componentConfig.default || componentConfig)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里文件夹结构：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22bash\x22\x3ecomponents\n│ componentRegister.js\n├─BasicTable\n│ BasicTable.vue\n├─MultiCondition\n│ index.vue\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里对组件名做了判断，如果是index的话就取组件中的name属性处理后作为注册组件名，所以最后注册的组件为：\x3ccode\x3emulti-condition\x3c\/code\x3e、\x3ccode\x3ebasic-table\x3c\/code\x3e\x3cbr\x3e最后我们在main.js中import \x27components\/componentRegister.js\x27，然后我们就可以随时随地使用这些基础组件，无需手动引入了~\x3c\/p\x3e\n\x3ch2\x3e4. 不同路由的组件复用\x3c\/h2\x3e\n\x3ch3\x3e4.1 场景还原\x3c\/h3\x3e\n\x3cp\x3e当某个场景中vue-router从\/post-page\/a，跳转到\/post-page\/b。然后我们惊人的发现，页面跳转后数据竟然没更新？！原因是vue-router\x22智能地\x22发现这是同一个组件，然后它就决定要复用这个组件，所以你在created函数里写的方法压根就没执行。通常的解决方案是监听$route的变化来初始化数据，如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3edata() {\n  return {\n    loading: false,\n    error: null,\n    post: null\n  }\n},\nwatch: {\n  \x27$route\x27: {        \/\/ 使用watch来监控是否是同一个路由\n    handler: \x27resetData\x27,\n    immediate: true\n  }\n},\nmethods: {\n  resetData() {\n    this.loading = false\n    this.error = null\n    this.post = null\n    this.getPost(this.$route.params.id)\n  },\n  getPost(id){ }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e4.2 优化\x3c\/h3\x3e\n\x3cp\x3e为了实现这样的效果可以给\x3ccode\x3erouter-view\x3c\/code\x3e添加一个不同的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;router-view :key=\x22$route.fullpath\x22\x26gt;\x26lt;\/router-view\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还可以在其后加\x3ccode\x3e\x2b \x2bnew Date()\x3c\/code\x3e时间戳，保证独一无二\x3c\/p\x3e\n\x3cp\x3e感谢网友 @rolitter 的提醒，如果组件被放在\x3ccode\x3e\x26lt;keep-alive\x26gt;\x3c\/code\x3e中的话，可以把获取新数据的方法放在activated钩子，代替原来在created、mounted钩子中获取数据的任务。\x3c\/p\x3e\n\x3ch2\x3e5. 组件事件属性穿透\x3c\/h2\x3e\n\x3ch3\x3e5.1 一般情况\x3c\/h3\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\/\/ 父组件\n\x26lt;BaseInput :value=\x22value\x22\n           label=\x22密码\x22\n           placeholder=\x22请填写密码\x22\n           @input=\x22handleInput\x22\n           @focus=\x22handleFocus\x22\x26gt;\n\x26lt;\/BaseInput\x26gt;\n\n\/\/ 子组件\n\x26lt;template\x26gt;\n  \x26lt;label\x26gt;\n    \x22{{\x22 label \x22}}\x22\n    \x26lt;input :value=\x22 value\x22\n           :placeholder=\x22placeholder\x22\n           @focus=\x22$emit(\x27focus\x27, $event)\x22\n           @input=\x22$emit(\x27input\x27, $event.target.value)\x22\x26gt;\n  \x26lt;\/label\x26gt;\n\x26lt;\/template\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3\x3e5.2 优化\x3c\/h3\x3e\n\x3cp\x3evue的组件实例中的\x3ccode\x3e$props\x3c\/code\x3e、\x3ccode\x3e$attrs\x3c\/code\x3e给我们提供了很大的便利，特别是父子组件传值的时候。\x3cbr\x3e1、 每一个从父组件传到子组件的props,我们都得在子组件的Props中显式的声明才能使用。这样一来，我们的子组件每次都需要申明一大堆props，这里我们知道\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/index.html#v-bind\x22 rel=\x22nofollow noreferrer\x22\x3ev-bind 是可以传对象\x3c\/a\x3e的，可以在 \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/index.html#vm-props\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3evm.$props\x3c\/code\x3e\x3c\/a\x3e 中拿到所有父组件props的值 \x3ccode\x3ev-bind=\x22$props\x22\x3c\/code\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;input  v-bind=\x22$props\x22 \n       @input=\x22$emit(\x27input\x27, $event.target.value)\x22\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、 类似placeholer这种dom原生的property可以使用\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#vm-attrs\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3e$attrs\x3c\/code\x3e\x3c\/a\x3e直接从父传到子，无需声明。方法如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;input :value=\x22value\x22\n       v-bind=\x22$attrs\x22\n       @input=\x22$emit(\x27input\x27, $event.target.value)\x22\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e$attrs\x3c\/code\x3e包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 \x3ccode\x3ev-bind=\x22$attrs\x22\x3c\/code\x3e 传入内部组件。\x3c\/p\x3e\n\x3cp\x3e3、 注意到子组件的\x3ccode\x3e@focus=\x22$emit(\x27focus\x27, $event)\x22\x3c\/code\x3e其实什么都没做，只是把event传回给父组件而已，那其实和上面类似，完全没必要显式地申明：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e\x26lt;input :value=\x22value\x22\n       v-bind=\x22$attrs\x22\n       v-on=\x22listeners\x22\/\x26gt;\n\ncomputed: {\n  listeners() {\n    return {\n      ...this.$listeners,\n      input: event =\x26gt;\n        this.$emit(\x27input\x27, event.target.value)\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#vm-listeners\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3e$listeners\x3c\/code\x3e\x3c\/a\x3e包含了父作用域中的 (不含 .native 修饰器的) \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#v-on\x22 rel=\x22nofollow noreferrer\x22\x3ev-on\x3c\/a\x3e 事件监听器。它可以通过 \x3ccode\x3ev-on=\x22$listeners\x22\x3c\/code\x3e 传入内部组件——在创建更高层次的组件时非常有用。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，由于我们input并不是BaseInput这个组件的根节点，而默认情况下父作用域的不被认作 \x3ccode\x3eprops\x3c\/code\x3e 的特性绑定将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。所以我们需要设置 \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#inheritAttrs\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3einheritAttrs: false\x3c\/code\x3e\x3c\/a\x3e，这些默认行为将会被去掉，上面优化才能成功。\x3c\/p\x3e\n\x3ch2\x3e6. 路由根据开发状态懒加载\x3c\/h2\x3e\n\x3ch3\x3e6.1 一般情况\x3c\/h3\x3e\n\x3cp\x3e一般我们在路由中加载组件的时候：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3eimport Login from \x27@\/views\/login.vue\x27\n\nexport default new Router({\n  routes: [{ path: \x27\/login\x27, name: \x27登陆\x27, component: Login}]\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当你需要懒加载 lazy-loading 的时候，需要一个个把routes的component改为\x3ccode\x3e() =\x26gt; import(\x27@\/views\/login.vue\x27)\x3c\/code\x3e，甚为麻烦。\x3c\/p\x3e\n\x3cp\x3e当你的项目页面越来越多之后，在开发环境之中使用 lazy-loading 会变得不太合适，每次更改代码触发热更新都会变得非常的慢。所以建议只在生成环境之中使用路由懒加载功能。\x3c\/p\x3e\n\x3ch3\x3e6.2 优化\x3c\/h3\x3e\n\x3cp\x3e根据Vue的\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/components.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6\x22 rel=\x22nofollow noreferrer\x22\x3e异步组件\x3c\/a\x3e和Webpack的\x3ca href=\x22https:\/\/doc.webpack-china.org\/guides\/code-splitting\x22 rel=\x22nofollow noreferrer\x22\x3e代码分割功能\x3c\/a\x3e可以轻松实现组件的懒加载，如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3econst Foo = () =\x26gt; import(\x27.\/Foo.vue\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在区分开发环境与生产环境时，可以在路由文件夹下分别新建两个文件：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e_import_production.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3emodule.exports = file =\x26gt; () =\x26gt; import(\x27@\/views\/\x27 \x2b file \x2b \x27.vue\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_import_development.js\x3c\/code\x3e (这种写法\x3ccode\x3evue-loader\x3c\/code\x3e版本至少v13.0.0以上)\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3emodule.exports = file =\x26gt; require(\x27@\/views\/\x27 \x2b file \x2b \x27.vue\x27).default\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而在设置路由的\x3ccode\x3erouter\/index.js\x3c\/code\x3e文件中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3econst _import = require(\x27.\/_import_\x27 \x2b process.env.NODE_ENV)\n\nexport default new Router({\n  routes: [{ path: \x27\/login\x27, name: \x27登陆\x27, component: _import(\x27login\/index\x27) }]\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样组件在开发环境下就是非懒加载，生产环境下就是懒加载的了\x3c\/p\x3e\n\x3ch2\x3e7 vue-loader小技巧\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/vue-loader.vuejs.org\/zh-cn\/\x22 rel=\x22nofollow noreferrer\x22\x3evue-loader\x3c\/a\x3e 是处理 *.vue 文件的 webpack loader。它本身提供了丰富的 API，有些 API 很实用但很少被人熟知。例如接下来要介绍的 \x3ca href=\x22https:\/\/vue-loader.vuejs.org\/zh-cn\/options.html#preservewhitespace\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3epreserveWhitespace\x3c\/code\x3e\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/vue-loader.vuejs.org\/zh-cn\/options.html#transformtorequire\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3etransformToRequire\x3c\/code\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3\x3e7.1 用 \x3ccode\x3epreserveWhitespace\x3c\/code\x3e 减少文件体积\x3c\/h3\x3e\n\x3cp\x3e有些时候我们在写模板时不想让元素和元素之间有空格，可能会写成这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;ul\x26gt;\n  \x26lt;li\x26gt;1111\x26lt;\/li\x26gt;\x26lt;li\x26gt;2222\x26lt;\/li\x26gt;\x26lt;li\x26gt;333\x26lt;\/li\x26gt;\n\x26lt;\/ul\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然还有其他方式，比如设置字体的\x3ccode\x3efont-size: 0\x3c\/code\x3e，然后给需要的内容单独设置字体大小，目的是为了去掉元素间的空格。其实我们完全可以通过配置 vue-loader 实现这一需求。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e{\n  vue: {\n    preserveWhitespace: false\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它的作用是阻止元素间生成空白内容，在 Vue 模板编译后使用 \x3ccode\x3e_v(\x22 \x22)\x3c\/code\x3e 表示。如果项目中模板内容多的话，它们还是会占用一些文件体积的。例如 Element 配置该属性后，未压缩情况下文件体积减少了近 30Kb。\x3c\/p\x3e\n\x3ch3\x3e7.2 使用 \x3ccode\x3etransformToRequire\x3c\/code\x3e 再也不用把图片写成变量了\x3c\/h3\x3e\n\x3cp\x3e以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\n    \x26lt;avatar :default-src=\x22DEFAULT_AVATAR\x22\x26gt;\x26lt;\/avatar\x26gt;\n  \x26lt;\/div\x26gt;\n\x26lt;\/template\x26gt;\n\x26lt;script\x26gt;\n  export default {\n    created () {\n      this.DEFAULT_AVATAR = require(\x27.\/assets\/default-avatar.png\x27)\n    }\n  }\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实通过配置 \x3ccode\x3etransformToRequire\x3c\/code\x3e 后，就可以直接配置，这样vue-loader会把对应的属性自动 require 之后传给组件\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3e{\n  vue: {\n    transformToRequire: {\n      avatar: [\x27default-src\x27]\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e于是我们代码就可以简化不少\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\n    \x26lt;avatar default-src=\x22.\/assets\/default-avatar.png\x22\x26gt;\x26lt;\/avatar\x26gt;\n  \x26lt;\/div\x26gt;\n\x26lt;\/template\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 vue-cli 的 webpack 模板下，默认配置是：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22js\x22\x3etransformToRequire: {\n  video: [\x27src\x27, \x27poster\x27],\n  source: \x27src\x27,\n  img: \x27src\x27,\n  image: \x27xlink:href\x27\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以举一反三进行一下类似的配置\x3c\/p\x3e\n\x3cp\x3evue-loader 还有很多实用的 API 例如最近加入的 \x3ca href=\x22https:\/\/vue-loader.vuejs.org\/zh-cn\/configurations\/custom-blocks.html\x22 rel=\x22nofollow noreferrer\x22\x3e自定义块\x3c\/a\x3e，感兴趣的各位可以去文档里找找看。\x3c\/p\x3e\n\x3ch2\x3e8. render 函数\x3c\/h2\x3e\n\x3cp\x3e在某些场景下你可能需要 \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/render-function.html\x22 rel=\x22nofollow noreferrer\x22\x3erender 渲染函数\x3c\/a\x3e带来的完全编程能力来解决不太容易解决的问题，特别是要动态选择生成标签和组件类型的场景。\x3c\/p\x3e\n\x3ch3\x3e8.1 动态标签\x3c\/h3\x3e\n\x3ch4\x3e1. 一般情况\x3c\/h4\x3e\n\x3cp\x3e比如根据props来生成标签的场景\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\n    \x26lt;div v-if=\x22level === 1\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/div\x26gt;\n    \x26lt;p v-else-if=\x22level === 2\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/p\x26gt;\n    \x26lt;h1 v-else-if=\x22level === 3\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/h1\x26gt;\n    \x26lt;h2 v-else-if=\x22level === 4\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/h2\x26gt;\n    \x26lt;strong v-else-if=\x22level === 5\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/stong\x26gt;\n    \x26lt;textarea v-else-if=\x22level === 6\x22\x26gt; \x26lt;slot\x26gt;\x26lt;\/slot\x26gt; \x26lt;\/textarea\x26gt;\n  \x26lt;\/div\x26gt;\n\x26lt;\/template\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中level是data中的变量，可以看到这里有大量重复代码，如果逻辑复杂点，加上一些绑定和判断就更复杂了，这里可以利用 render 函数来对要生成的标签加以判断。\x3c\/p\x3e\n\x3ch4\x3e2. 优化\x3c\/h4\x3e\n\x3cp\x3e使用 render 方法根据参数来生成对应标签可以避免上面的情况。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\n    \x26lt;child :level=\x22level\x22\x26gt;Hello world!\x26lt;\/child\x26gt;\n  \x26lt;\/div\x26gt;\n\x26lt;\/template\x26gt;\n\n\x26lt;script type=\x27text\/javascript\x27\x26gt;\n  import Vue from \x27vue\x27\n  Vue.component(\x27child\x27, {\n    render(h) {\n      const tag = [\x27div\x27, \x27p\x27, \x27strong\x27, \x27h1\x27, \x27h2\x27, \x27textarea\x27][this.level]\n      return h(tag, this.$slots.default)\n    },\n    props: {\n      level: {  type: Number,  required: true  } \n    }\n  })   \n  export default {\n    name: \x27hehe\x27,\n    data() { return { level: 3 } }\n  }\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e示例可以查看 \x3ca href=\x22https:\/\/codepen.io\/SHERlocked93\/pen\/mLEJPE\x22 rel=\x22nofollow noreferrer\x22\x3eCodePen\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3\x3e8.2 动态组件\x3c\/h3\x3e\n\x3cp\x3e当然render函数还有很多用法，比如要使用动态组件，除了使用 \x3ccode\x3e:is\x3c\/code\x3e 之外也可以使用render函数\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22html\x22\x3e\x26lt;template\x26gt;\n  \x26lt;div\x26gt;\n    \x26lt;button @click=\x27level = 0\x27\x26gt;嘻嘻\x26lt;\/button\x26gt;\n    \x26lt;button @click=\x27level = 1\x27\x26gt;哈哈\x26lt;\/button\x26gt;\n    \x26lt;hr\x26gt;\n    \x26lt;child :level=\x22level\x22\x26gt;\x26lt;\/child\x26gt;\n  \x26lt;\/div\x26gt;\n\x26lt;\/template\x26gt;\n\n\x26lt;script type=\x27text\/javascript\x27\x26gt;\n  import Vue from \x27vue\x27\n  import Xixi from \x27.\/Xixi\x27\n  import Haha from \x27.\/Haha\x27\n  Vue.component(\x27child\x27, {\n    render(h) {\n      const tag = [\x27xixi\x27, \x27haha\x27][this.level]\n      return h(tag, this.$slots.default)\n    },\n    props: { level: { type: Number, required: true } },\n    components: { Xixi, Haha }\n  })\n  export default {\n    name: \x27hehe\x27,\n    data() { return { level: 0 } }\n  }\n\x26lt;\/script\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e示例可以查看 \x3ca href=\x22https:\/\/codepen.io\/SHERlocked93\/pen\/YLWwxM\x22 rel=\x22nofollow noreferrer\x22\x3eCodePen\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e@20180702 添加 @JserWang 提醒的多图标事件去中心化优化方法\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~\x3c\/p\x3e\n\x3cblockquote\x3e参考：\x3cbr\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/xiterjia\/p\/6701324.html\x22 rel=\x22nofollow noreferrer\x22\x3eVue2 全局过滤器（vue-cli）\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000014085613\x22\x3eVue.js最佳实践\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/doc.webpack-china.org\/guides\/dependency-management\/#require-context\x22 rel=\x22nofollow noreferrer\x22\x3ewebpack文档 - require.context\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/wuchangming\/blog\/blob\/master\/docs\/webpack\/require-context-usage.md\x22 rel=\x22nofollow noreferrer\x22\x3e使用webpack的require.context实现路由“去中心化”管理 \x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/panjiachen.github.io\/vue-element-admin-site\/#\/zh-cn\/lazy-loading\x22 rel=\x22nofollow noreferrer\x22\x3evue-element-admin 文档\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/25589193\x22 rel=\x22nofollow noreferrer\x22\x3eVue.js 的实用技巧\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5afd6a88f265da0b9127a879\x22 rel=\x22nofollow noreferrer\x22\x3e优化页面的打开速度，要不要了解一下~\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue 使用中的小技巧</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014527768">https://segmentfault.com/a/1190000014527768</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ortsscz23m/" target="_blank">https://alili.tech/archive/ortsscz23m/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>