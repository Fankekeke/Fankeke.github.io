<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入Webpack-编写Loader"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入Webpack-编写Loader | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pgetwclpn1m/",
				"appid": "1613049289050283", 
				"title": "深入Webpack-编写Loader | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-19T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ool0xz9pwq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1wyqsuqs5tvh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&text=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&text=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&title=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&is_video=false&description=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&title=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&title=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&title=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpgetwclpn1m%2f&title=%e6%b7%b1%e5%85%a5Webpack-%e7%bc%96%e5%86%99Loader"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入Webpack-编写Loader</h1><div class="meta"><div class="postdate"><time datetime="2018-12-19" itemprop="datePublished">2018-12-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eLoader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。\x3c\/p\x3e\n\x3cp\x3e以处理 SCSS 文件为例：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eSCSS 源代码会先交给 sass-loader 把 SCSS 转换成 CSS；\x3c\/li\x3e\n\x3cli\x3e把 sass-loader 输出的 CSS 交给 css-loader 处理，找出 CSS 中依赖的资源、压缩 CSS 等；\x3c\/li\x3e\n\x3cli\x3e把 css-loader 输出的 CSS 交给 style-loader 处理，转换成通过脚本加载的  JavaScript 代码；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可以看出以上的处理过程需要有顺序的链式执行，先 sass-loader 再 css-loader 再 style-loader。\x3cbr\x3e以上处理的 Webpack 相关配置如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        \/\/ 增加对 SCSS 文件的支持\n        test: \/\\.scss\/,\n        \/\/ SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader\n        use: [\n          \x27style-loader\x27,\n          {\n            loader:\x27css-loader\x27,\n            \/\/ 给 css-loader 传入配置项\n            options:{\n              minimize:true, \n            }\n          },\n          \x27sass-loader\x27],\n      },\n    ]\n  },\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3erules\x3c\/span\x3e: [\n      {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增加对 SCSS 文件的支持\x3c\/span\x3e\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.scss\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader\x3c\/span\x3e\n        use: [\n          \x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e,\n          {\n            \x3cspan class=\x22hljs-attr\x22\x3eloader\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27css-loader\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给 css-loader 传入配置项\x3c\/span\x3e\n            options:{\n              \x3cspan class=\x22hljs-attr\x22\x3eminimize\x3c\/span\x3e:\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \n            }\n          },\n          \x3cspan class=\x22hljs-string\x22\x3e\x27sass-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eLoader 的职责\x3c\/h2\x3e\n\x3cp\x3e由上面的例子可以看出：一个 Loader 的职责是单一的，只需要完成一种转换。\x3cbr\x3e如果一个源文件需要经历多步转换才能正常使用，就通过多个 Loader 去转换。\x3cbr\x3e在调用多个 Loader 去转换一个文件时，每个 Loader 会链式的顺序执行，\x3cbr\x3e第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。\x3c\/p\x3e\n\x3cp\x3e所以，在你开发一个 Loader 时，请保持其职责的单一性，你只需关心输入和输出。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eLoader 基础\x3c\/h2\x3e\n\x3cp\x3e由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。\x3cbr\x3e这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。\x3c\/p\x3e\n\x3cp\x3e一个最简单的 Loader 的源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(source) {\n  \/\/ source 为 compiler 传递给 Loader 的一个文件的原内容\n  \/\/ 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换\n  return source;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ source 为 compiler 传递给 Loader 的一个文件的原内容\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e source;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于 Loader 运行在 Node.js 中，你可以调用任何 Node.js 自带的 API，或者安装第三方模块进行调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const sass = require(\x27node-sass\x27);\nmodule.exports = function(source) {\n  return sass(source);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sass = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27node-sass\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e sass(source);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eLoader 进阶\x3c\/h2\x3e\n\x3cp\x3e以上只是个最简单的 Loader，Webpack 还提供一些 API 供 Loader 调用，下面来一一介绍。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e获得 Loader 的 options\x3c\/h3\x3e\n\x3cp\x3e在最上面处理 SCSS 文件的 Webpack 配置中，给 css-loader 传了 options 参数，以控制 css-loader。\x3cbr\x3e如何在自己编写的 Loader 中获取到用户传入的 options 呢？需要这样做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const loaderUtils = require(\x27loader-utils\x27);\nmodule.exports = function(source) {\n  \/\/ 获取到用户给当前 Loader 传入的 options\n  const options = loaderUtils.getOptions(this);\n  return source;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e loaderUtils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27loader-utils\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取到用户给当前 Loader 传入的 options\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = loaderUtils.getOptions(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e source;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e返回其它结果\x3c\/h3\x3e\n\x3cp\x3e上面的 Loader 都只是返回了原内容转换后的内容，但有些场景下还需要返回除了内容之外的东西。\x3c\/p\x3e\n\x3cp\x3e例如以用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码。\x3cbr\x3e为了把 Source Map 也一起随着 ES5 代码返回给 Webpack，可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(source) {\n  \/\/ 通过 this.callback 告诉 Webpack 返回的结果\n  this.callback(null, source, sourceMaps);\n  \/\/ 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，\n  \/\/ 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 \n  return;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 this.callback 告诉 Webpack 返回的结果\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, source, sourceMaps);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中的 \x3ccode\x3ethis.callback\x3c\/code\x3e 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。\x3cbr\x3e\x3ccode\x3ethis.callback\x3c\/code\x3e 的详细使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.callback(\n    \/\/ 当无法转换原内容时，给 Webpack 返回一个 Error\n    err: Error | null,\n    \/\/ 原内容转换后的内容\n    content: string | Buffer,\n    \/\/ 用于把转换后的内容得出原内容的 Source Map，方便调试\n    sourceMap?: SourceMap,\n    \/\/ 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，\n    \/\/ 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能\n    abstractSyntaxTree?: AST\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.callback(\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当无法转换原内容时，给 Webpack 返回一个 Error\x3c\/span\x3e\n    err: \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e | \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原内容转换后的内容\x3c\/span\x3e\n    content: string | Buffer,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于把转换后的内容得出原内容的 Source Map，方便调试\x3c\/span\x3e\n    sourceMap?: SourceMap,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能\x3c\/span\x3e\n    abstractSyntaxTree?: AST\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3eSource Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。\x3cbr\x3e为此 Webpack 为 Loader 提供了 \x3ccode\x3ethis.sourceMap\x3c\/code\x3e API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。\x3cbr\x3e如果你编写的 Loader 会生成 Source Map，请考虑到这点。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e同步与异步\x3c\/h3\x3e\n\x3cp\x3eLoader 有同步和异步之分，上面介绍的 Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。\x3cbr\x3e但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢。\x3c\/p\x3e\n\x3cp\x3e在转换步骤是异步时，你可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(source) {\n    \/\/ 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果\n    var callback = this.async();\n    someAsyncOperation(source, function(err, result, sourceMaps, ast) {\n        \/\/ 通过 callback 返回异步执行后的结果\n        callback(err, result, sourceMaps, ast);\n    });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.async();\n    someAsyncOperation(source, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, result, sourceMaps, ast\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 callback 返回异步执行后的结果\x3c\/span\x3e\n        callback(err, result, sourceMaps, ast);\n    });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e处理二进制数据\x3c\/h3\x3e\n\x3cp\x3e在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。\x3cbr\x3e但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 file-loader，就需要 Webpack 给 Loader 传入二进制格式的数据。\x3cbr\x3e为此，你需要这样编写 Loader：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(source) {\n    \/\/ 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的\n    source instanceof Buffer === true;\n    \/\/ Loader 返回的类型也可以是 Buffer 类型的\n    \/\/ 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果\n    return source;\n};\n\/\/ 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 \nmodule.exports.raw = true;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的\x3c\/span\x3e\n    source \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Buffer === \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Loader 返回的类型也可以是 Buffer 类型的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e source;\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports.raw = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码中最关键的代码是最后一行 \x3ccode\x3emodule.exports.raw = true;\x3c\/code\x3e，没有该行 Loader 只能拿到字符串。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e缓存加速\x3c\/h3\x3e\n\x3cp\x3e在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。\x3cbr\x3e为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，\x3cbr\x3e是不会重新调用对应的 Loader 去执行转换操作的。\x3c\/p\x3e\n\x3cp\x3e如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = function(source) {\n  \/\/ 关闭该 Loader 的缓存功能\n  this.cacheable(false);\n  return source;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 关闭该 Loader 的缓存功能\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cacheable(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e source;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e其它 Loader API\x3c\/h2\x3e\n\x3cp\x3e除了以上提到的在 Loader 中能调用的 Webpack API 外，还存在以下常用 API：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.context\x3c\/code\x3e：当前处理文件的所在目录，假如当前 Loader 处理的文件是 \x3ccode\x3e\/src\/main.js\x3c\/code\x3e，则 \x3ccode\x3ethis.context\x3c\/code\x3e 就等于 \x3ccode\x3e\/src\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.resource\x3c\/code\x3e：当前处理文件的完整请求路径，包括 querystring，例如 \x3ccode\x3e\/src\/main.js?name=1\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.resourcePath\x3c\/code\x3e：当前处理文件的路径，例如 \x3ccode\x3e\/src\/main.js\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.resourceQuery\x3c\/code\x3e：当前处理文件的 querystring。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.target\x3c\/code\x3e：等于 Webpack 配置中的 Target，详情见 \x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/2%E9%85%8D%E7%BD%AE\/2-7%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E9%A1%B9.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2-7其它配置项-Target\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.loadModule\x3c\/code\x3e：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时，\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e就可以通过 \x3ccode\x3ethis.loadModule(request: string, callback: function(err, source, sourceMap, module))\x3c\/code\x3e 去获得 \x3ccode\x3erequest\x3c\/code\x3e 对应文件的处理结果。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.resolve\x3c\/code\x3e：像 \x3ccode\x3erequire\x3c\/code\x3e 语句一样获得指定文件的完整路径，使用方法为 \x3ccode\x3eresolve(context: string, request: string, callback: function(err, result: string))\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.addDependency\x3c\/code\x3e：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 \x3ccode\x3eaddDependency(file: string)\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.addContextDependency\x3c\/code\x3e：和 \x3ccode\x3eaddDependency\x3c\/code\x3e 类似，但 \x3ccode\x3eaddContextDependency\x3c\/code\x3e 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 \x3ccode\x3eaddContextDependency(directory: string)\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.clearDependencies\x3c\/code\x3e：清除当前正在处理文件的所有依赖，使用方法为 \x3ccode\x3eclearDependencies()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ethis.emitFile\x3c\/code\x3e：输出一个文件，使用方法为 \x3ccode\x3eemitFile(name: string, content: Buffer|string, sourceMap: {...})\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其它没有提到的 API 可以去 \x3ca href=\x22https:\/\/webpack.js.org\/api\/loaders\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebpack 官网\x3c\/a\x3e 查看。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e加载本地 Loader\x3c\/h2\x3e\n\x3cp\x3e在开发 Loader 的过程中，为了测试编写的 Loader 是否能正常工作，需要把它配置到 Webpack 中后，才可能会调用该 Loader。\x3cbr\x3e在前面的章节中，使用的 Loader 都是通过 Npm 安装的，要使用 Loader 时会直接使用 Loader 的名称，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    rules: [\n      {\n        test: \/\\.css\/,\n        use: [\x27style-loader\x27],\n      },\n    ]\n  },\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3erules\x3c\/span\x3e: [\n      {\n        \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3euse\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27style-loader\x27\x3c\/span\x3e],\n      },\n    ]\n  },\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果还采取以上的方法去使用本地开发的 Loader 将会很麻烦，因为你需要确保编写的 Loader 的源码是在 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下。\x3cbr\x3e为此你需要先把编写的 Loader 发布到 Npm 仓库后再安装到本地项目使用。\x3c\/p\x3e\n\x3cp\x3e解决以上问题的便捷方法有两种，分别如下：\x3c\/p\x3e\n\x3ch4\x3eNpm link\x3c\/h4\x3e\n\x3cp\x3eNpm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下，让项目可以直接使用本地的 Npm 模块。\x3cbr\x3e由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。\x3c\/p\x3e\n\x3cp\x3e完成 Npm link 的步骤如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 \x3ccode\x3epackage.json\x3c\/code\x3e 已经正确配置好；\x3c\/li\x3e\n\x3cli\x3e在本地 Npm 模块根目录下执行 \x3ccode\x3enpm link\x3c\/code\x3e，把本地模块注册到全局；\x3c\/li\x3e\n\x3cli\x3e在项目根目录下执行 \x3ccode\x3enpm link loader-name\x3c\/code\x3e，把第2步注册到全局的本地 Npm 模块链接到项目的 \x3ccode\x3enode_moduels\x3c\/code\x3e 下，其中的 \x3ccode\x3eloader-name\x3c\/code\x3e 是指在第1步中的 \x3ccode\x3epackage.json\x3c\/code\x3e 文件中配置的模块名称。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e链接好 Loader 到项目后你就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。\x3c\/p\x3e\n\x3ch4\x3eResolveLoader\x3c\/h4\x3e\n\x3cp\x3e在 \x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/2%E9%85%8D%E7%BD%AE\/2-7%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E9%A1%B9.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2-7其它配置项\x3c\/a\x3e 中曾介绍过 ResolveLoader 用于配置 Webpack 如何寻找 Loader。\x3cbr\x3e默认情况下只会去 \x3ccode\x3enode_modules\x3c\/code\x3e 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 \x3ccode\x3eresolveLoader.modules\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e假如本地的 Loader 在项目目录中的 \x3ccode\x3e.\/loaders\/loader-name\x3c\/code\x3e 中，则需要如下配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  resolveLoader:{\n    \/\/ 去哪些目录下寻找 Loader，有先后顺序之分\n    modules: [\x27node_modules\x27,\x27.\/loaders\/\x27],\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3eresolveLoader\x3c\/span\x3e:{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 去哪些目录下寻找 Loader，有先后顺序之分\x3c\/span\x3e\n    modules: [\x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27.\/loaders\/\x27\x3c\/span\x3e],\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e加上以上配置后， Webpack 会先去 \x3ccode\x3enode_modules\x3c\/code\x3e 项目下寻找 Loader，如果找不到，会再去 \x3ccode\x3e.\/loaders\/\x3c\/code\x3e 目录下寻找。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e实战\x3c\/h2\x3e\n\x3cp\x3e上面讲了许多理论，接下来从实际出发，来编写一个解决实际问题的 Loader。\x3c\/p\x3e\n\x3cp\x3e该 Loader 名叫 comment-require-loader，作用是把 JavaScript 代码中的注释语法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ @require \x27..\/style\/index.css\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ @require \x27..\/style\/index.css\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e转换成\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22require(\x27..\/style\/index.css\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27..\/style\/index.css\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该 Loader 的使用场景是去正确加载针对 \x3ca href=\x22http:\/\/fis.baidu.com\/fis3\/docs\/user-dev\/require.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFis3\x3c\/a\x3e 编写的 JavaScript，这些 JavaScript 中存在通过注释的方式加载依赖的 CSS 文件。\x3c\/p\x3e\n\x3cp\x3e该 Loader 的使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  module: {\n    loaders: [\n      {\n        test: \/\\.js$\/,\n        loaders: [\x27comment-require-loader\x27],\n        \/\/ 针对采用了 fis3 CSS 导入语法的 JavaScript 文件通过 comment-require-loader 去转换 \n        include: [path.resolve(__dirname, \x27node_modules\/imui\x27)]\n      }\n    ]\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3emodule\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eloaders\x3c\/span\x3e: [\n      {\n        \x3cspan class=\x22hljs-attr\x22\x3etest\x3c\/span\x3e: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.js$\/\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eloaders\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27comment-require-loader\x27\x3c\/span\x3e],\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 针对采用了 fis3 CSS 导入语法的 JavaScript 文件通过 comment-require-loader 去转换 \x3c\/span\x3e\n        include: [path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27node_modules\/imui\x27\x3c\/span\x3e)]\n      }\n    ]\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该 Loader 的实现非常简单，完整代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function replace(source) {\n    \/\/ 使用正则把 \/\/ @require \x27..\/style\/index.css\x27 转换成 require(\x27..\/style\/index.css\x27);  \n    return source.replace(\/(\\\/\\\/ *@require) \x2b((\x27|\x26quot;).\x2b(\x27|\x26quot;)).*\/, \x27require($2);\x27);\n}\n\nmodule.exports = function (content) {\n    return replace(content);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereplace\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用正则把 \/\/ @require \x27..\/style\/index.css\x27 转换成 require(\x27..\/style\/index.css\x27);  \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e source.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/(\\\/\\\/ *@require) \x2b((\x27|\x22).\x2b(\x27|\x22)).*\/\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27require($2);\x27\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3econtent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e replace(content);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e本实例\x3ca href=\x22https:\/\/github.com\/gwuhaolin\/comment-require-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e提供项目完整代码\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012544051?w=1348\x26amp;h=845\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012544051?w=1348\x26amp;h=845\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《深入浅出Webpack》全书在线阅读链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/webpack.wuhaolin.cn\/5%E5%8E%9F%E7%90%86\/5-3%E7%BC%96%E5%86%99Loader.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阅读原文\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入Webpack-编写Loader</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012718374">https://segmentfault.com/a/1190000012718374</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pgetwclpn1m/" target="_blank">https://alili.tech/archive/pgetwclpn1m/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>