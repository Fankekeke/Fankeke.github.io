<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Async/await学习"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Async/await学习 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/phx7ab073i/",
				"appid": "1613049289050283", 
				"title": "Async/await学习 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/y07bd6t1txm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xqju9u1ged/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&text=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&text=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&title=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&is_video=false&description=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Async%2fawait%e5%ad%a6%e4%b9%a0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&title=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&title=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&title=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fphx7ab073i%2f&title=Async%2fawait%e5%ad%a6%e4%b9%a0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Async/await学习</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eAsync\/await\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e写在前面\x3c\/h2\x3e\n\x3cblockquote\x3e渣渣新人的首篇外文文章翻译！！存在错误可能会很多，如有错误，烦请各位大大指正出来，感谢！\x3c\/blockquote\x3e\n\x3cp\x3e本篇为翻译！\x3cbr\x3e本篇为翻译！\x3cbr\x3e本篇为翻译！\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e原文文章地址\x3c\/strong\x3e：\x3ca href=\x22https:\/\/javascript.info\/async-await\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/javascript.info\/async-await\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eAsync\/await\x3c\/h2\x3e\n\x3cp\x3e有一种特殊的语法可以更舒适地与promise协同工作，它叫做\x3ccode\x3easync\/await\x3c\/code\x3e，它是非常的容易理解和使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eAsync functions\x3c\/h3\x3e\n\x3cp\x3e让我们先从\x3ccode\x3easync\x3c\/code\x3e关键字说起，它被放置在一个函数前面。就像下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    return 1\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数前面的\x3ccode\x3easync\x3c\/code\x3e一词意味着一个简单的事情：这个函数总是返回一个promise，如果代码中有\x3ccode\x3ereturn \x26lt;非promise\x26gt;\x3c\/code\x3e语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\x3c\/p\x3e\n\x3cp\x3e例如，上面的代码返回resolved值为1的promise，我们可以测试一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    return 1\n}\nf().then(alert) \/\/ 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\nf().then(alert) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们也可以显式的返回一个promise，这个将会是同样的结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    return Promise.resolve(1)\n}\nf().then(alert) \/\/ 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n}\nf().then(alert) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，\x3ccode\x3easync\x3c\/code\x3e确保了函数返回一个promise，即使其中包含非promise。够简单了吧？但是不仅仅只是如此，还有另一个关键词\x3ccode\x3eawait\x3c\/code\x3e，只能在\x3ccode\x3easync\x3c\/code\x3e函数里使用，同样，它也很cool。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eAwait\x3c\/h3\x3e\n\x3cp\x3e语法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 只能在async函数内部使用\nlet value = await promise\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只能在async函数内部使用\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promise\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关键词\x3ccode\x3eawait\x3c\/code\x3e可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\x3c\/p\x3e\n\x3cp\x3e以下是一个promise在1s之后resolve的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    let promise = new Promise((resolve, reject) =\x3e {\n        setTimeout(() =\x3e resolve(\x27done!\x27), 1000)\n    })\n    let result = await promise \/\/ 直到promise返回一个resolve值（*）\n    alert(result) \/\/ \x27done!\x27 \n}\nf()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e promise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27done!\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promise \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直到promise返回一个resolve值（*）\x3c\/span\x3e\n    alert(result) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27done!\x27 \x3c\/span\x3e\n}\nf()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数执行到（*）行会‘暂停’，当promise处理完成后重新恢复运行，       resolve的值成了最终的result，所以上面的代码会在1s后输出\x3ccode\x3e\x27done!\x27\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e我们强调一下：\x3ccode\x3eawait\x3c\/code\x3e字面上使得JavaScript等待，直到promise处理完成，\x3cbr\x3e然后将结果继续下去。这并不会花费任何的cpu资源，因为引擎能够同时做其他工作：执行其他脚本，处理事件等等。\x3c\/p\x3e\n\x3cp\x3e这只是一个更优雅的得到promise值的语句，它比promise更加容易阅读和书写。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3e不能在常规函数里使用await\x3c\/strong\x3e\x3cbr\x3e如果我们试图在非async函数里使用await，就会出现一个语法错误：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f() {\n   let promise = Promise.resolve(1)\n   let result = await promise \/\/ syntax error\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e promise = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promise \x3cspan class=\x22hljs-comment\x22\x3e\/\/ syntax error\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们忘记了在函数之前放置async，我们就会得到这样一个错误。如上所述，await只能在async函数中工作。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e让我们来看\x3ca href=\x22https:\/\/javascript.info\/promise-chaining\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epromise链式操作\x3c\/a\x3e一章中提到的\x3ccode\x3eshowAvatar()\x3c\/code\x3e例子，并用\x3ccode\x3easync\/await\x3c\/code\x3e重写它。\x3c\/p\x3e\n\x3cp\x3e1.我们需要将\x3ccode\x3e.then()\x3c\/code\x3e替换为\x3ccode\x3eawait\x3c\/code\x3e\x3cbr\x3e2.此外，我们应该让函数变成\x3ccode\x3easync\x3c\/code\x3e，这样\x3ccode\x3eawait\x3c\/code\x3e才能够工作\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function showAvatar() {\n    \/\/ read our JSON\n    let response = await fetch(\x27\/article\/promise-chaining\/user.json\x27)\n    let user = await response.json()\n    \n    \/\/ read github user\n    let githubResponse = await fetch(`https:\/\/api.github.com\/users\/${user.name}`)\n    let githubUser = await githubResponse.json()\n    \n    \/\/ 展示头像\n    let img = document.createElement(\x27img\x27)\n    img.src = githubUser.avatar_url\n    img.className = \x27promise-avatar-example\x27\n    documenmt.body.append(img)\n    \n    \/\/ 等待3s\n    await new Promise((resolve, reject) =\x3e {\n        setTimeout(resolve, 3000)\n    })\n    \n    img.remove()\n    \n    return githubUser\n}\nshowAvatar()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshowAvatar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ read our JSON\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27\/article\/promise-chaining\/user.json\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e user = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e response.json()\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ read github user\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e githubResponse = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e`https:\/\/api.github.com\/users\/\x3cspan class=\x22hljs-subst\x22\x3e${user.name}\x3c\/span\x3e`\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e githubUser = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e githubResponse.json()\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示头像\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e img = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27img\x27\x3c\/span\x3e)\n    img.src = githubUser.avatar_url\n    img.className = \x3cspan class=\x22hljs-string\x22\x3e\x27promise-avatar-example\x27\x3c\/span\x3e\n    documenmt.body.append(img)\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待3s\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        setTimeout(resolve, \x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e)\n    })\n    \n    img.remove()\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e githubUser\n}\nshowAvatar()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相当的简洁和易读，比以前的要好得多。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3eawait不能工作在顶级作用域\x3c\/strong\x3e\x3cbr\x3e那些刚开始使用await的人们老是忘记这一点，那就是我们不能将await放在代码的顶层，那样是行不通的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 顶层代码处syntax error\nlet response = await fetch(\x27\/article\/promise-chaining\/user.json\x27)\nlet user = await response.json()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顶层代码处syntax error\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27\/article\/promise-chaining\/user.json\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e user = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e response.json()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以我们需要将await代码包裹在一个async函数中，就像上面的例子一样。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3eawait接受thenables\x3c\/strong\x3e（好吧我这个渣渣并不知道thenables该如何翻译，有人能告知吗？）\x3c\/p\x3e\n\x3cp\x3e就像promise.then，await也允许使用thenable对象（那些具有可调用的then方法的对象）。同样，第三方对象可能不是一个promise，但是promise的兼容性表示，如果它支持.then方法，那么它就能用于await。 \x3c\/p\x3e\n\x3cp\x3e例如，这里await接受了new Thenable(1)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Thenable {\n   constructor(num) {\n       this.num = num\n   }\n   then(resolve, reject) {\n       alert(resolve) \/\/ function() {native code}\n       \/\/ 1000ms后将this.num*2作为resolve值\n       setTimeout(()=\x3e {resolve(this.num * 2), 1000})\n   }\n}\nasync function(f) {\n   \/\/ 等待1s，result变为2\n   let result = await new Thenable(1)\n   alert(result)\n}\nf()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThenable\x3c\/span\x3e \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(num) {\n       \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.num = num\n   }\n   then(resolve, reject) {\n       alert(resolve) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ function() {native code}\x3c\/span\x3e\n       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1000ms后将this.num*2作为resolve值\x3c\/span\x3e\n       setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {resolve(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.num * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e})\n   }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ef\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等待1s，result变为2\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Thenable(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n   alert(result)\n}\nf()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果await得到了一个带有then方法的非promise对象，它将会调用提供原生函数resolve、reject作为参数的方法，然后await一直等待，直到他们其中的一个被调用（在上面的例子它发生在（*）行）。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3easync方法\x3c\/strong\x3e\x3cbr\x3e一个class方法同样能够使用async，只需要将async放在它之前就可以\x3cbr\x3e就像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Waiter {\n   async wait () {\n       return await Promise.resolve(1)\n   }\n}\nnew Waiter().wait().then(alert) \/\/ 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWaiter\x3c\/span\x3e \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e wait () {\n       \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n   }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Waiter().wait().then(alert) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的意思是一样的：它确保了返回值是一个promise，支持await\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e错误处理\x3c\/h3\x3e\n\x3cp\x3e如果一个promise正常resolve，那么\x3ccode\x3eawait\x3c\/code\x3e返回这个结果，但是在reject的情况下会抛出一个错误，就好像在那一行有一个throw语句一样。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    await Promise.reject(new Error(\x27whoops!\x27))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27whoops!\x27\x3c\/span\x3e))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和下面一样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    throw new Error(\x27Whoops!\x27)\n}   \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Whoops!\x27\x3c\/span\x3e)\n}   \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在真实的使用场景中，promise在reject抛出错误之前可能需要一段时间，所以\x3ccode\x3eawait\x3c\/code\x3e将会等待，然后才抛出一个错误。\x3cbr\x3e我们可以使用try-catch语句捕获错误，就像在正常抛出中处理异常一样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    try {\n        let response = await fetch(\x27http:\/\/no-such-url\x27)\n    } catch (err) {\n        alet(err) \/\/ TypeError: failed to fetch\n    }\n}\nf()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/no-such-url\x27\x3c\/span\x3e)\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (err) {\n        alet(err) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: failed to fetch\x3c\/span\x3e\n    }\n}\nf()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果发生了一个错误，控制会跳转到catch块。当然我们也能够捕获多行语句：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    try {\n        let response = await fetch(\x27\/no-user-here\x27)\n        let user = await response.json()\n    } catch(err) {\n        \/\/ 在fetch和response.json中都能捕获错误\n        alert(err)\n    }\n}\nf()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27\/no-user-here\x27\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e user = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e response.json()\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在fetch和response.json中都能捕获错误\x3c\/span\x3e\n        alert(err)\n    }\n}\nf()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function f() {\n    let response = await fetch(\x27http:\/\/no-such-url\x27)\n}\n\/\/ f()变成了一个rejected的promise\nf().catch(alert) \/\/ TypeError: failed to fetch\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/no-such-url\x27\x3c\/span\x3e)\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ f()变成了一个rejected的promise\x3c\/span\x3e\nf().catch(alert) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: failed to fetch\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们忘记添加.catch，我们就会得到一个未被处理的promise错误（能够在控制台里看到它），这时我们可以通过使用一个全局的事件处理器去捕获错误，就像在\x3ca href=\x22https:\/\/javascript.info\/promise-chaining\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise链式操作\x3c\/a\x3e一章讲的那样。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3easync\/await和promise.then\/catch\x3c\/strong\x3e\x3cbr\x3e当我们使用async\/await，我们很少需要.then，因为await总是等待着我们，而且我们能够使用常规的try-catch而不是.catch，这通常（并不总是）更方便。\x3cp\x3e但是在代码的顶层，当我们在async函数的外部时，我们在语法上是不能使用await的，所以通常添加.then\/catch去处理最终结果或者错误。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3easync\/await能够与Promise.all友好的协作\x3c\/strong\x3e\x3cbr\x3e当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直到数组全部返回结果\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e results = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果发生了一个错误，它就像普通情况一样：从一个失败状态的promise到Promise.all，然后变成了一个我们能够使用try-cathc去捕获的异常。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e放在一个函数前的async有两个作用：\x3cbr\x3e1.使函数总是返回一个promise\x3cbr\x3e2.允许在这其中使用await\x3c\/p\x3e\n\x3cp\x3epromise前面的await关键字能够使JavaScript等待，直到promise处理结束。然后：\x3cbr\x3e1.如果它是一个错误，异常就产生了，就像在那个地方调用了throw error一样。\x3cbr\x3e2.否则，它会返回一个结果，我们可以将它分配给一个值\x3c\/p\x3e\n\x3cp\x3e他们一起提供了一个很好的框架来编写易于读写的异步代码。\x3c\/p\x3e\n\x3cp\x3e有了async\/await，我们很少需要写promise.then\/catch，但是我们仍然不应该忘记它们是基于promise的，因为有些时候（例如在最外面的范围内）我们不得不使用这些方法。Promise.all也是一个非常棒的东西，它能够同时等待很多任务。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Async/await学习</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013292562">https://segmentfault.com/a/1190000013292562</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/phx7ab073i/" target="_blank">https://alili.tech/archive/phx7ab073i/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>