<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="RxJS: 详解forkJoin, zip, combineLatest之间的区别"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>RxJS: 详解forkJoin, zip, combineLatest之间的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pl6bkvedxq/",
				"appid": "1613049289050283", 
				"title": "RxJS: 详解forkJoin, zip, combineLatest之间的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-22T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/aplso6q597i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hbd3hm21v94/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&text=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&text=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&title=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&is_video=false&description=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&title=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&title=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&title=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpl6bkvedxq%2f&title=RxJS%3a%20%e8%af%a6%e8%a7%a3forkJoin%2c%20zip%2c%20combineLatest%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">RxJS: 详解forkJoin, zip, combineLatest之间的区别</h1><div class="meta"><div class="postdate"><time datetime="2018-12-22" itemprop="datePublished">2018-12-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e前言\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eforkJoin\x3c\/code\x3e, \x3ccode\x3ezip\x3c\/code\x3e, \x3ccode\x3ecombineLatest\x3c\/code\x3e是\x3ccode\x3erxjs\x3c\/code\x3e中的合并操作符，用于对多个流进行合并。很多人第一次接触\x3ccode\x3erxjs\x3c\/code\x3e时往往分不清它们之间的区别，其实这很正常，因为当你准备用来合并的流是那种只会发射一次数据就关闭的流时（比如\x3ccode\x3ehttp\x3c\/code\x3e请求），就结果而言这三个操作符没有任何区别。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ob1 = Rx.Observable.of(1).delay(1000);\nconst ob2 = Rx.Observable.of(2).delay(2000);\nconst ob3 = Rx.Observable.of(3).delay(3000);\n\nRx.Observable.forkJoin(ob1, ob2, ob3).subscribe((data) =\x3e console.log(data));\nRx.Observable.zip(ob1, ob2, ob3).subscribe((data) =\x3e console.log(data));\nRx.Observable.combineLatest(ob1, ob2, ob3).subscribe((data) =\x3e console.log(data));\n\n\/\/ [1, 2, 3]\n\/\/ [1, 2, 3]\n\/\/ [1, 2, 3]\n\/\/ 都是在3秒的时候打印\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3econst ob1 = \x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.of(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e).delay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\nconst ob2 = \x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.of(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e).delay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e);\nconst ob3 = \x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.of(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e).delay(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.forkJoin(ob1, ob2, ob3).subscribe((\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e) =\x26gt; console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e));\n\x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.zip(ob1, ob2, ob3).subscribe((\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e) =\x26gt; console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e));\n\x3cspan class=\x22hljs-literal\x22\x3eRx\x3c\/span\x3e.Observable.combineLatest(ob1, ob2, ob3).subscribe((\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e) =\x26gt; console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 都是在3秒的时候打印\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3erxjs\x3c\/code\x3e中很多操作符功能相近，只有当其操作的流会多次发射数据时才会体现出它们之间的区别，下面我们来详细解释\x3ccode\x3eforkJoin\x3c\/code\x3e, \x3ccode\x3ezip\x3c\/code\x3e, 和\x3ccode\x3ecombineLatest\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e一个基本概念\x3c\/h3\x3e\n\x3cp\x3e首先我们要知道，一个流（或者说\x3ccode\x3eObservable\x3c\/code\x3e序列）的生命周期中，每次发射数据会发出\x3ccode\x3enext\x3c\/code\x3e信号（\x3ccode\x3eNotification\x3c\/code\x3e），结束发射时会发出\x3ccode\x3ecomplete\x3c\/code\x3e信号，发生错误时发出\x3ccode\x3eerror\x3c\/code\x3e信号，三个信号分别对应\x3ccode\x3eobserver\x3c\/code\x3e的三个方法。\x3ccode\x3enext\x3c\/code\x3e信号会由于发射源的不同发射0到多次；而\x3ccode\x3ecomplete\x3c\/code\x3e和\x3ccode\x3eerror\x3c\/code\x3e仅会发射其中一个，且只发射一次，标志着流的结束。\x3cbr\x3e\x3ccode\x3esubscribe\x3c\/code\x3e接收一个\x3ccode\x3eobserver\x3c\/code\x3e对象用来处理上述三种信号，只传入一个函数会被认为是\x3ccode\x3enext\x3c\/code\x3e方法，因此传入\x3ccode\x3esubscribe\x3c\/code\x3e的\x3ccode\x3enext\x3c\/code\x3e方法会执行0到N次，N为序列正常发射信号的次数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3ccode\x3eforkJoin\x3c\/code\x3e\x3c\/h3\x3e\n\x3cp\x3e用\x3ccode\x3eforkJoin\x3c\/code\x3e合并的流，会在每个被合并的流都发出结束信号时发射一次也是唯一一次数据。假设我们有两个流：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ob1 = Rx.Observable.interval(1000).map(d =\x3e `ob1:${d}`).take(3);\nconst ob2 = Rx.Observable.interval(2000).map(d =\x3e `ob2:${d}`).take(2);\n\nRx.Observable.forkJoin(ob1, ob2).subscribe((data) =\x3e console.log(data));\n\/\/ [\x26quot;ob1:2\x26quot;, \x26quot;ob2:1\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob1 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob1:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob2 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob2:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\nRx.Observable.forkJoin(ob1, ob2).subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:2\x22, \x22ob2:1\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eob1\x3c\/code\x3e会在发射完第三个数据时停止发射，\x3ccode\x3eob2\x3c\/code\x3e会在发射完第二个数据时停止，而\x3ccode\x3eforkJoin\x3c\/code\x3e合并后的流会等到\x3ccode\x3eob1\x3c\/code\x3e和\x3ccode\x3eob2\x3c\/code\x3e都结束时，发射一次数据，也就是触发一次\x3ccode\x3esubscribe\x3c\/code\x3e里的回调，接收到的数据为\x3ccode\x3eob1\x3c\/code\x3e和\x3ccode\x3eob2\x3c\/code\x3e发射的最后一次数据的数组。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3ccode\x3ezip\x3c\/code\x3e\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3ezip\x3c\/code\x3e工作原理如下，当每个传入\x3ccode\x3ezip\x3c\/code\x3e的流都发射完毕第一次数据时，\x3ccode\x3ezip\x3c\/code\x3e将这些数据合并为数组并发射出去；当这些流都发射完第二次数据时，\x3ccode\x3ezip\x3c\/code\x3e再次将它们合并为数组并发射。以此类推直到其中某个流发出结束信号，整个被合并后的流结束，不再发射数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ob1 = Rx.Observable.interval(1000).map(d =\x3e `ob1:${d}`).take(3);\nconst ob2 = Rx.Observable.interval(2000).map(d =\x3e `ob2:${d}`).take(2);\n\nRx.Observable.zip(ob1, ob2).subscribe({\n  next: (data) =\x3e console.log(data),\n  complete: () =\x3e console.log(\x27complete\x27)\n});\n\/\/ [\x26quot;ob1:0\x26quot;, \x26quot;ob2:0\x26quot;] ob1等待ob2发射数据，之后合并\n\/\/ [\x26quot;ob1:1\x26quot;, \x26quot;ob2:1\x26quot;] 此时ob2结束，整个合并的流也结束\n\/\/ \x26quot;complete\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob1 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob1:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob2 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob2:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\nRx.Observable.zip(ob1, ob2).subscribe({\n  \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data),\n  \x3cspan class=\x22hljs-attr\x22\x3ecomplete\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e)\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:0\x22, \x22ob2:0\x22] ob1等待ob2发射数据，之后合并\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:1\x22, \x22ob2:1\x22] 此时ob2结束，整个合并的流也结束\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22complete\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ezip\x3c\/code\x3e和\x3ccode\x3eforkJoin\x3c\/code\x3e的区别在于，\x3ccode\x3eforkJoin\x3c\/code\x3e仅会合并各个子流最后发射的一次数据，触发一次回调；\x3ccode\x3ezip\x3c\/code\x3e会等待每个子流都发射完一次数据然后合并发射，之后继续等待，直到其中某个流结束（因为此时不能使合并的数据包含每个子流的数据）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\x3ccode\x3ecombineLatest\x3c\/code\x3e\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3ecombineLatest\x3c\/code\x3e与\x3ccode\x3ezip\x3c\/code\x3e很相似，\x3ccode\x3ecombineLatest\x3c\/code\x3e一开始也会等待每个子流都发射完一次数据，但是在合并时，如果子流1在等待其他流发射数据期间又发射了新数据，则使用子流最新发射的数据进行合并，之后每当有某个流发射新数据，不再等待其他流同步发射数据，而是使用其他流之前的最近一次数据进行合并。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ob1 = Rx.Observable.interval(1000).map(d =\x3e `ob1:${d}`).take(3);\nconst ob2 = Rx.Observable.interval(2000).map(d =\x3e `ob2:${d}`).take(2);\n\nRx.Observable.combineLatest(ob1, ob2).subscribe({\n  next: (data) =\x3e console.log(data),\n  complete: () =\x3e console.log(\x27complete\x27)\n});\n\/\/ [\x26quot;ob1:1\x26quot;, \x26quot;ob2:0\x26quot;] ob1等待ob2发射，当ob2发射时ob1已经发射了第二次数据，使用ob1的第二次数据\n\/\/ [\x26quot;ob1:2\x26quot;, \x26quot;ob2:0\x26quot;] ob1继续发射第三次也是最后一次数据，ob2虽然还未发射，但是可以使用它上一次的数据\n\/\/ [\x26quot;ob1:2\x26quot;, \x26quot;ob2:1\x26quot;] ob2发射第二次也是最后一次数据，使ob1上一次的数据。\n\/\/ \x26quot;complete\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob1 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob1:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ob2 = Rx.Observable.interval(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`ob2:\x3cspan class=\x22hljs-subst\x22\x3e${d}\x3c\/span\x3e`\x3c\/span\x3e).take(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\nRx.Observable.combineLatest(ob1, ob2).subscribe({\n  \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data),\n  \x3cspan class=\x22hljs-attr\x22\x3ecomplete\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e)\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:1\x22, \x22ob2:0\x22] ob1等待ob2发射，当ob2发射时ob1已经发射了第二次数据，使用ob1的第二次数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:2\x22, \x22ob2:0\x22] ob1继续发射第三次也是最后一次数据，ob2虽然还未发射，但是可以使用它上一次的数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ob1:2\x22, \x22ob2:1\x22] ob2发射第二次也是最后一次数据，使ob1上一次的数据。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22complete\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e本期内容结束，下一期会继续带来\x3ccode\x3erxjs\x3c\/code\x3e的其他操作符或者概念详解。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>RxJS: 详解forkJoin, zip, combineLatest之间的区别</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012369871">https://segmentfault.com/a/1190000012369871</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pl6bkvedxq/" target="_blank">https://alili.tech/archive/pl6bkvedxq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>