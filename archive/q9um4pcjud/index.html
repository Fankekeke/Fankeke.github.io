<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="mobx学习总结"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>mobx学习总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/q9um4pcjud/",
				"appid": "1613049289050283", 
				"title": "mobx学习总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-10T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9875xa4ht3i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xguyruf1y4/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&text=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&text=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&title=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&is_video=false&description=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&title=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&title=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&title=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9um4pcjud%2f&title=mobx%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">mobx学习总结</h1><div class="meta"><div class="postdate"><time datetime="2018-12-10" itemprop="datePublished">2018-12-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3eMobx解决的问题\x3c\/h2\x3e\n\x3cp\x3e传统React使用的数据管理库为Redux。Redux要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束。Redux由此引出了dispatch action reducer等概念，对state的概念进行强约束。然而对于一些项目来说，太过强，便失去了灵活性。Mobx便是来填补此空缺的。\x3c\/p\x3e\n\x3cp\x3e这里对Redux和Mobx进行简单的对比：\x3c\/p\x3e\n\x3cp\x3e1. Redux的编程范式是函数式的而Mobx是面向对象的；\x3c\/p\x3e\n\x3cp\x3e2. 因此数据上来说Redux理想的是immutable的，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的；\x3c\/p\x3e\n\x3cp\x3e3. 然而和Redux相比，使用Mobx的组件可以做到精确更新，这一点得益于Mobx的observable；对应的，Redux是用dispath进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mobx更加精细一点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x26nbsp;Mobx核心概念\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013810517\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013810517\x22 alt=\x22图片来自官方文档\x22 title=\x22图片来自官方文档\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eMobx的核心原理是通过action触发state的变化，进而触发state的衍生对象（computed value \x26amp; Reactions）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eState\x3c\/h3\x3e\n\x3cp\x3e在Mobx中，State就对应业务的最原始状态，通过observable方法，可以使这些状态变得可观察。\x3c\/p\x3e\n\x3cp\x3e通常支持被observable的类型有三个，分别是Object, Array, Map；对于原始类型，可以使用Obserable.box。\x3c\/p\x3e\n\x3cp\x3e值得注意的一点是，当某一数据被observable包装后，他返回的其实是被observable包装后的类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun } = Mobx;\nconst obArray = observable([1, 2, 3]);\nconsole.log(\x26quot;ob is Array:\x26quot;, Array.isArray(obArray));\nconsole.log(\x26quot;ob:\x26quot;, obArray);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obArray = observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22ob is Array:\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(obArray));\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22ob:\x22\x3c\/span\x3e, obArray);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e控制台输出为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nob is Array: false\nob: ObservableArray {}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-string\x22\x3eob\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eArray:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3eob:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eObservableArray\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{}\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于该问题，解决方法也很简单，可以通过Mobx原始提供的\x3ccode\x3eobservable.toJS()\x3c\/code\x3e转换成JS再判断，或者直接使用Mobx原生提供的API\x3ccode\x3eisObservableArray\x3c\/code\x3e进行判断。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ecomputed\x3c\/h3\x3e\n\x3cp\x3eMobx中state的设计原则和redux有一点是相同的，那就是尽可能保证state足够小，足够原子。这样设计的原则不言而喻，无论是维护性还是性能。那么对于依赖state的数据而衍生出的数据，可以使用computed。\x3c\/p\x3e\n\x3cp\x3e简而言之，你有一个值，该值的结果依赖于state，并且该值也需要被obserable，那么就使用computed。\x3c\/p\x3e\n\x3cp\x3e通常应该尽可能的使用计算属性，并且由于其函数式的特点，可以最大化优化性能。如果计算属性依赖的state没改变，或者该计算值没有被其他计算值或响应（reaction）使用，computed便不会运行。在这种情况下，computed处于暂停状态，此时若该计算属性不再被observable。那么其便会被Mobx垃圾回收。\x3c\/p\x3e\n\x3cp\x3e简单介绍computed的一个使用场景\x3c\/p\x3e\n\x3cp\x3e假如你观察了一个数组，你想根据数组的长度变化作出反应，在不使用computed时代码是这样的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun, computed } = Mobx;\nvar numbers = observable([1, 2, 3]);\nautorun(() =\x3e console.log(numbers.length));\n\/\/ 输出 \x273\x27\nnumbers.push(4);\n\/\/ 输出 \x274\x27\nnumbers[0] = 0;\n\/\/ 输出 \x274\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun, computed } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numbers = observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(numbers.length));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 \x273\x27\x3c\/span\x3e\nnumbers.push(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 \x274\x27\x3c\/span\x3e\nnumbers[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 \x274\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一行其实只是改了数组中的一个值，但是也触发了autorun的执行。此时如果用computed便会解决该问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun, computed } = Mobx;\nvar numbers = observable([1, 2, 3]);\nvar sum = computed(() =\x3e numbers.length);\nautorun(() =\x3e console.log(sum.get()));\n\/\/ 输出 \x273\x27\nnumbers.push(4);\n\/\/ 输出 \x274\x27\nnumbers[0] = 1;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun, computed } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numbers = observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sum = computed(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e numbers.length);\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sum.get()));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 \x273\x27\x3c\/span\x3e\nnumbers.push(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 \x274\x27\x3c\/span\x3e\nnumbers[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eautorun\x3c\/h3\x3e\n\x3cp\x3e另一个响应state的api便是autorun。和computed类似，每当依赖的值改变时，其都会改变。不同的是，autorun没有了computed的优化（当然，依赖值未改变的情况下也不会重新运行，但不会被自动回收）。因此在使用场景来说，autorun通常用来执行一些有副作用的。例如打印日志，更新UI等等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eaction\x3c\/h3\x3e\n\x3cp\x3e在redux中，唯一可以更改state的途径便是dispatch一个action。这种约束性带来的一个好处是可维护性。整个state只要改变必定是通过action触发的，对此只要找到reducer中对应的action便能找到影响数据改变的原因。强约束性是好的，但是Redux要达到约束性的目的，似乎要写许多样板代码，虽说有许多库都在解决该问题，然而Mobx从根本上来说会更加优雅。\x3c\/p\x3e\n\x3cp\x3e首先Mobx并不强制所有state的改变必须通过action来改变，这主要适用于一些较小的项目。对于较大型的，需要多人合作的项目来说，可以使用Mobx提供的api \x3ccode\x3econfigure\x3c\/code\x3e来强制。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nMobx.configure({enforceActions: true})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMobx\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.configure\x3c\/span\x3e({\x3cspan class=\x22hljs-attribute\x22\x3eenforceActions\x3c\/span\x3e: true})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其原理也很简单\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction\x26nbsp;configure(options){\n\n\x26nbsp; \x26nbsp; if (options.enforceActions !== undefined) {\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; globalState.enforceActions = !!options.enforceActions\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; globalState.allowStateChanges = !options.enforceActions\n\x26nbsp;\x26nbsp;\x26nbsp; }\n\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\nfunction\x26nbsp;configure(options){\n\n\x26nbsp; \x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options\x3cspan class=\x22hljs-selector-class\x22\x3e.enforceActions\x3c\/span\x3e !== undefined) {\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; globalState\x3cspan class=\x22hljs-selector-class\x22\x3e.enforceActions\x3c\/span\x3e = !!options\x3cspan class=\x22hljs-selector-class\x22\x3e.enforceActions\x3c\/span\x3e\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; globalState\x3cspan class=\x22hljs-selector-class\x22\x3e.allowStateChanges\x3c\/span\x3e = !options\x3cspan class=\x22hljs-selector-class\x22\x3e.enforceActions\x3c\/span\x3e\n\x26nbsp;\x26nbsp;\x26nbsp; }\n\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过改变全局的strictMode以及allowStateChanges属性的方式来实现强制使用action。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eMobx异步处理\x3c\/h2\x3e\n\x3cp\x3e和Redux不同的是，Mobx在异步处理上并不复杂，不需要引入额外的类似\x3ccode\x3eredux-thunk\x3c\/code\x3e、\x3ccode\x3eredux-saga\x3c\/code\x3e这样的库。\x3c\/p\x3e\n\x3cp\x3e唯一需要注意的是，在严格模式下，对于异步action里的回调，若该回调也要修改observable的值，那么\x3c\/p\x3e\n\x3cp\x3e该回调也需要绑定action。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nMobx.configure({ enforceActions: true });\nconst { observable, autorun, computed, extendObservable, action } = Mobx;\nclass Store {\n\x26nbsp; @observable a = 123;\n\n\x26nbsp; @action\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = 0;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(this.changeB, 1000);\n\x26nbsp; }\n\x26nbsp; @action.bound\n\x26nbsp; changeB() {\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = 1000;\n\x26nbsp; }\n}\nvar s = new Store();\nautorun(() =\x3e console.log(s.a));\ns.changeA();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\nMobx.configure({ enforceActions: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun, computed, extendObservable, action } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e Store {\n\x26nbsp; \x3cspan class=\x22hljs-meta\x22\x3e@observable\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e;\n\n\x26nbsp; \x3cspan class=\x22hljs-meta\x22\x3e@action\x3c\/span\x3e\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changeB, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n\x26nbsp; }\n\x26nbsp; \x3cspan class=\x22hljs-meta\x22\x3e@action\x3c\/span\x3e.bound\n\x26nbsp; changeB() {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n\x26nbsp; }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Store();\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s.a));\ns.changeA();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里用了action.bound语法糖，目的是为了解决javascript作用域问题。\x3c\/p\x3e\n\x3cp\x3e另外一种更简单的写法是直接包装action\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nMobx.configure({ enforceActions: true });\nconst { observable, autorun, computed, extendObservable, action } = Mobx;\nclass Store {\n\x26nbsp; @observable a = 123;\n\x26nbsp; @action\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = 0;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(action(\x27changeB\x27,()=\x3e{\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; this.a = 1000;\n\x26nbsp;\x26nbsp;\x26nbsp; }), 1000);\n\x26nbsp; }\n}\nvar s = new Store();\nautorun(() =\x3e console.log(s.a));\ns.changeA();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\nconst Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\nMobx.configure({ enforceActions: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e });\nconst { observable, autorun, computed, extendObservable, action } = Mobx;\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e {\x3c\/span\x3e\n\x26nbsp; @observable a = \x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e;\n\x26nbsp; @action\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(action(\x3cspan class=\x22hljs-string\x22\x3e\x27changeB\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp; }), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n\x26nbsp; }\n}\nvar s = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Store();\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s.a));\ns.changeA();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果不想到处写action，可以使用Mobx提供的工具函数runInAction来简化操作。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n...\n\n\x26nbsp;@action\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = 0;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; runInAction(() =\x3e {\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; this.a = 1000;\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; }),\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; 1000\n\x26nbsp;\x26nbsp;\x26nbsp; );\n\x26nbsp; }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\n...\n\n\x26nbsp;@action\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp; setTimeout(\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; runInAction(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; }),\n\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e\n\x26nbsp;\x26nbsp;\x26nbsp; );\n\x26nbsp; }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过该工具函数，可以将所有对observable值的操作放在一个回调里，而不是命名各种各样的action。\x3c\/p\x3e\n\x3cp\x3e最后，Mobx提供的一个工具函数，其原理redux-saga，使用ES6的generator来实现异步操作，可以彻底摆脱action的干扰。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n@asyncAction\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = 0;\n\x26nbsp;\x26nbsp;\x26nbsp; const data = yield Promise.resolve(1)\n\x26nbsp;\x26nbsp;\x26nbsp; this.a = data;\n\x26nbsp; }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e@asyncAction\x3c\/span\x3e\n\x26nbsp; changeA() {\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x26nbsp;\x26nbsp;\x26nbsp; const \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = yield Promise.resolve(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n\x26nbsp; }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eMobx原理分析\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eautorun\x3c\/h3\x3e\n\x3cp\x3eMobx的核心就是通过observable观察某一个变量，当该变量产生变化时，对应的autorun内的回调函数就会发生变化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun } = Mobx;\nconst ob = observable({ a: 1, b: 1 });\nautorun(() =\x3e {\n\x26nbsp; console.log(\x26quot;ob.b:\x26quot;, ob.b);\n});\n\nob.b = 2;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e\nconst Mobx = require(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst { observable, autorun } = Mobx\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst ob = observable({ a: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eb: \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nautorun(() =\x26gt; {\n\x26nbsp; console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22ob.b:\x22\x3c\/span\x3e, ob.\x3cspan class=\x22hljs-keyword\x22\x3eb);\n\x3c\/span\x3e})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\nob.\x3cspan class=\x22hljs-keyword\x22\x3eb \x3c\/span\x3e= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行该代码会发现，log了两遍ob.b的值。其实从这个就能猜到，\x3cstrong\x3eMobx是通过代理变量的getter和setter来实现的变量更新功能\x3c\/strong\x3e。首先先代理变量的getter函数，然后通过预执行一遍autorun中回调，从而触发getter函数，来实现观察值的收集，依次来代理setter。之后只要setter触发便执行收集好的回调就ok了。\x3cbr\x3e具体源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function autorun(view, opts){\n    reaction = new Reaction(name, function () {\n           this.track(reactionRunner);\n    }, opts.onError);\n   function reactionRunner() {\n        view(reaction);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eautorun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(view, opts)\x3c\/span\x3e\x3c\/span\x3e{\n    reaction = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Reaction(name, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.track(reactionRunner);\n    }, opts.onError);\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactionRunner\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        view(reaction);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eautorun的核心就是这一段，这里view就是autorun里的回调函数。具体到track函数，比较关键到代码是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Reaction.prototype.track = function (fn) {\n    var result = trackDerivedFunction(this, fn, undefined);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3eReaction.prototype.track = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(fn)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = trackDerivedFunction(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, fn, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3etrackDerivedFunction函数中会执行autorun里的回调函数，紧接着会触发obserable中代理的函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function generateObservablePropConfig(propName) {\n    return (observablePropertyConfigs[propName] ||\n        (observablePropertyConfigs[propName] = {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return this.$mobx.read(this, propName);\n            },\n            set: function (v) {\n                this.$mobx.write(this, propName, v);\n            }\n        }));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egenerateObservablePropConfig\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(propName)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (observablePropertyConfigs[propName] ||\n        (observablePropertyConfigs[propName] = {\n            configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$mobx.read(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, propName);\n            },\n            \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$mobx.write(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, propName, v);\n            }\n        }));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在get中会将回调与其绑定，之后更改了obserable中的值时，都会触发这里的set，然后随即触发绑定的函数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eMobx的一些坑\x3c\/h3\x3e\n\x3cp\x3e通过autorun的实现原理可以发现，会出现很多我们想象中应该触发，但是没有触发的场景，例如：\x3c\/p\x3e\n\x3cp\x3e1. 无法收集新增的属性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun } = Mobx;\nlet ob = observable({ a: 1, b: 1 });\nautorun(() =\x3e {\n\x26nbsp; if(ob.c){\n\x26nbsp;\x26nbsp;\x26nbsp; console.log(\x26quot;ob.c:\x26quot;, ob.c);\n\x26nbsp; }\n});\nob.c = 1\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ob = observable({ \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e });\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n\x26nbsp; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(ob.c){\n\x26nbsp;\x26nbsp;\x26nbsp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22ob.c:\x22\x3c\/span\x3e, ob.c);\n\x26nbsp; }\n});\nob.c = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于该问题，可以通过\x3ccode\x3eextendObservable(target, props)\x3c\/code\x3e方法来实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun, computed, extendObservable } = Mobx;\nvar numbers = observable({ a: 1, b: 2 });\nextendObservable(numbers, { c: 1 });\nautorun(() =\x3e console.log(numbers.c));\nnumbers.c = 3;\n\n\/\/ 1\n\n\/\/ 3\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Mobx = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { observable, autorun, computed, extendObservable } = Mobx;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numbers = observable({ \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e });\nextendObservable(numbers, { \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e });\nautorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(numbers.c));\nnumbers.c = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eextendObservable\x3c\/code\x3e该API会可以为对象新增加observal属性。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e当然，如果你对变量的entry增删非常关心，应该使用Map数据结构而不是Object。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e2. 回调函数若依赖外部环境，则无法进行收集\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst Mobx = require(\x26quot;mobx\x26quot;);\nconst { observable, autorun } = Mobx;\nlet ob = observable({ a: 1, b: 1 });\nlet x = 0;\nautorun(() =\x3e {\n\x26nbsp; if(x == 1){\n\x26nbsp;\x26nbsp;\x26nbsp; console.log(\x26quot;ob.c:\x26quot;, ob.b);\n\x26nbsp; }\n});\nx = 1;\nob.b = 2;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e\nconst Mobx = require(\x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst { observable, autorun } = Mobx\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nlet ob = observable({ a: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eb: \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nlet x = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nautorun(() =\x26gt; {\n\x26nbsp; if(x == \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e){\n\x26nbsp;\x26nbsp;\x26nbsp; console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22ob.c:\x22\x3c\/span\x3e, ob.\x3cspan class=\x22hljs-keyword\x22\x3eb);\n\x3c\/span\x3e\x26nbsp; }\n})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nx = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nob.\x3cspan class=\x22hljs-keyword\x22\x3eb \x3c\/span\x3e= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很好理解，autorun的回调函数在预执行的时候无法到达ob.b那一行代码，所以收集不到。\x3c\/p\x3e\n\x3cp\x3e参考链接：\x3c\/p\x3e\n\x3cp\x3e1.\x26nbsp;\x3ca href=\x22https:\/\/www.zhihu.com\/question\/52219898\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.zhihu.com\/question\/52219898\x3c\/a\x3e\x3cbr\x3e2.\x26nbsp;\x3ca href=\x22http:\/\/taobaofed.org\/blog\/2016\/08\/18\/react-redux-connect\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/taobaofed.org\/blog\/2016\/08\/18\/react-redux-connect\x3c\/a\x3e\x3cbr\x3e3.\x26nbsp;\x3ca href=\x22https:\/\/Mobx.js.org\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/Mobx.js.org\/index.html\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>mobx学习总结</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013810512">https://segmentfault.com/a/1190000013810512</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/q9um4pcjud/" target="_blank">https://alili.tech/archive/q9um4pcjud/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>