<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="写一个轮播图，学会 React Native"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>写一个轮播图，学会 React Native | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qe19amcr0z9/",
				"appid": "1613049289050283", 
				"title": "写一个轮播图，学会 React Native | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-27T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h70qyy289aj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4e1dgtd2306/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&text=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&text=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&title=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&is_video=false&description=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&title=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&title=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&title=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqe19amcr0z9%2f&title=%e5%86%99%e4%b8%80%e4%b8%aa%e8%bd%ae%e6%92%ad%e5%9b%be%ef%bc%8c%e5%ad%a6%e4%bc%9a%20React%20Native"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">写一个轮播图，学会 React Native</h1><div class="meta"><div class="postdate"><time datetime="2018-12-27" itemprop="datePublished">2018-12-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e我学习 Web 的第一课，就是学习写一个轮播图，在写轮播图时自然地将 html、css、js、DOM、组件设计等各方面简单的知识点给串起来了。学习 React Native 的时候，也自然用起了这个思路，挺好用的。本文通过写一个轮播图，希望帮助到那些对 React Native 有兴趣的同学。\x3c\/p\x3e\n\x3cp\x3e本文会一步一步和带领大家实现一个轮播图组件，帮助大家将一个个单独的知识点给串。学习本文之前，最好对 React Native 有所了解。其中的一些单独的知识点，如果不是很了解，可以在学习过程中点击相关链接学习。这个单独的知识点包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eComponents: View、Touchble*\x3c\/li\x3e\n\x3cli\x3eAPIs: Animated、PanResponder、StyleSheet\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e配合 github 项目学习效果更佳：\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/jiangleo\/learn-react-native\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/jiangleo\/l...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e轮播图的最终效果图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXNIB?w=480\x26amp;h=324\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXNIB?w=480\x26amp;h=324\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e简单轮播图组件\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e接口设计\x3c\/h3\x3e\n\x3cp\x3e一步实现最终效果图实现的效果是很难的，所以不如先把轮播图设计的简单点，然后一步一步地优化。\x3cbr\x3e这个简单的轮播图组件，只拥有如下 3 个功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在展现区域默认显示第 index 个项目的内容；\x3c\/li\x3e\n\x3cli\x3e右滑，在展现区域显示上一个项目的内容；\x3c\/li\x3e\n\x3cli\x3e左滑，在展现区域显示下一个项目的内容。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e轮播图的主要思想是，每次只显示一个个项目面，超出容器个项目面被隐藏，思路图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVXNIN?w=720\x26amp;h=310\x22 src=\x22https:\/\/static.alili.tech\/img\/bVXNIN?w=720\x26amp;h=310\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/29034015\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e图片来源\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e为了达到复用的效果，还需要将组件调用方和组件本身分离。即组件本身只有一个，但是可以被多次调用。\x3c\/p\x3e\n\x3cp\x3e在明确简单轮播图组件的设计要求后，就很自然地设计出其调用方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3estyle\x3c\/code\x3e: 设置外部容器的样式。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eindex\x3c\/code\x3e: 控制组件展示第 \x3ccode\x3eindex\x3c\/code\x3e 项目。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eonChange\x3c\/code\x3e: 当用户点击上一个按钮、点击下一个按钮触发，并通过回调参数通知调用方，\x3ccode\x3eindex\x3c\/code\x3e 应该怎么改变。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3echildren\x3c\/code\x3e: 所有轮播项目。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22state={\n    index: 0,\n}\n\nrender() {\n    return (\n        \x3cSwiper\n            style=\x22{{\x22with: 100\x22}}\x22\n            index={this.state.index}\n            onChange={(index)=\x3e {\n                this.setState({\n                    index: index\n                })\n            \x22}}\x22\n        \x3e\n            \x3cView \/\x3e\n            \x3cView \/\x3e\n            \x3cView \/\x3e\n        \x3c\/Swiper\x3e\n    );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3estate={\n    index: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n}\n\nrender() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x26lt;Swiper\n            style=\x22{{\x22with: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\x22}}\x22\n            index={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.index}\n            onChange={(index)=\x26gt; {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n                    index: index\n                })\n            \x22}}\x22\n        \x26gt;\n            \x26lt;View \/\x26gt;\n            \x26lt;View \/\x26gt;\n            \x26lt;View \/\x26gt;\n        \x26lt;\/Swiper\x26gt;\n    );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e组件实现\x3c\/h3\x3e\n\x3cp\x3e实现轮播的核心原理是，当 \x3ccode\x3eindex\x3c\/code\x3e 变化时，改变 Swiper 所有轮播项目的 \x3ccode\x3etranslateX\x3c\/code\x3e 值。超出 Swiper 容器的轮播项目会被隐藏，所以只会展现当前的第 \x3ccode\x3eindex\x3c\/code\x3e 个项目。其中有一个等式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22轮播项目位移距离 = - 当前展示的项 * 外部容器宽度\ntranslateX =  - index *  layoutWidth\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e轮播项目位移距离 = - 当前展示的项 * 外部容器宽度\n\x3cspan class=\x22hljs-attribute\x22\x3etranslateX\x3c\/span\x3e =  - index *  layoutWidth\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在渲染之前，外部容器宽度 \x3ccode\x3elayoutWidth\x3c\/code\x3e 是不知道的。因此只能在外部容器渲染后，通过 \x3ccode\x3eonLayout\x3c\/code\x3e 函数，来获取外部容器宽度。在获取宽度后，再将正在的轮播项目渲染出来。但是这样做，需要两次渲染才能将轮播图显示出来。在一些对性能要求高的项目中，可以通过暴露一个外部容器初始化宽度 \x3ccode\x3einitialWidth\x3c\/code\x3e 的接口来提前获取，避免两次渲染。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e新接口 \x3ccode\x3einitialWidth\x3c\/code\x3e: 外部容器初始化宽度\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e另外，我写代码的时候，有个小技巧，边写边测，通过小步迭代的方式，进行快速进行开发。因此，左滑、右滑切换的功能，不妨先用上一个、下一个按钮来代替。\x3c\/p\x3e\n\x3cp\x3e其核心代码，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_handleLayout = ({nativeEvent}) =\x3e {\n    this.setState({\n        layoutWidth: nativeEvent.layout.width,\n    })\n}\n\n\nrender() {\n    const {children, style, index} = this.props;\n    const translateX =  - index * this.state.layoutWidth;\n    const items = children.map((item, index) =\x3e React.cloneElement(\n            item,\n            {\n                key: index,\n                style: [\n                    ...item.props.style,\n                    {\n                        width: this.state.layoutWidth,\n                        transform: [{translateX,}],\n                    }\n                ]\n            },\n    ))\n\n    return (\n        \x3cView\n            style={[styles.container,style]}\n            onLayout={this._handleLayout}\n        \x3e\n            {items}\n        \x3c\/View\x3e\n    )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3e_handleLayout = ({nativeEvent}) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        layoutWidth: nativeEvent.layout.width,\n    })\n}\n\n\nrender() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {children, style, index} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e translateX =  - index * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.layoutWidth;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e items = children.map((item, index) =\x26gt; React.cloneElement(\n            item,\n            {\n                key: index,\n                style: [\n                    ...item.props.style,\n                    {\n                        width: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.layoutWidth,\n                        transform: [{translateX,}],\n                    }\n                ]\n            },\n    ))\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x26lt;View\n            style={[styles.container,style]}\n            onLayout={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._handleLayout}\n        \x26gt;\n            {items}\n        \x26lt;\/View\x26gt;\n    )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/jiangleo\/learn-react-native\/blob\/master\/App\/0_SimpleSwiper\/SimpleSwiper.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e添加动画\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\n\x3ccode\x3eAnimated\x3c\/code\x3e 声明式动画\x3c\/h3\x3e\n\x3cp\x3e动画功能会用到 \x3ccode\x3eAnimated\x3c\/code\x3e 这个 API。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eAnimated\x3c\/code\x3e 和 \x3ccode\x3estate\x3c\/code\x3e 一样，都符合符合声明式编程的原理。由于 \x3ccode\x3eAnimated\x3c\/code\x3e 的动画值也可以看做页面的某种状态。在官网的示例代码中，直接将\x3ccode\x3eAnimated\x3c\/code\x3e 的动画值直接挂在了 \x3ccode\x3ethis.state\x3c\/code\x3e 上，也证明了这一点。\x3cbr\x3e下面我们将 \x3ccode\x3eAnimated\x3c\/code\x3e 和 \x3ccode\x3estate\x3c\/code\x3e 进行对比，帮助大家进行理解：\x3c\/p\x3e\n\x3cp\x3e# | Animated | state\x3cbr\x3e声明 | \x3ccode\x3ethis.animKey = animValue}\x3c\/code\x3e | \x3ccode\x3ethis.state={stateKey: stateValue}\x3c\/code\x3e\x3cbr\x3e--| --| --\x3cbr\x3e赋值 | \x3ccode\x3e\x26lt;Animated.View props={this.animKey}\x26gt;\x3c\/code\x3e | \x3ccode\x3e\x26lt;View props={this.state.stateKey}\x26gt;\x3c\/code\x3e\x3cbr\x3e改变状态 | this.animKey.setValue(newAnimValue)  | \x3ccode\x3ethis.setState({stateKey: newStateValue})\x3c\/code\x3e\x3cbr\x3e改变状态_动画曲线形式 |   \x3ccode\x3eAnimated.spring(this.animKey, {toValue: newAnimValue}).toStart()\x3c\/code\x3e  | 无\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e功能描述和接口实现\x3c\/h3\x3e\n\x3cp\x3e在完成轮播图组件的基础切换功能的基础上，要给它添加动画功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e点击上一个按钮，从当前显示项目逐渐右移至上一个项目；\x3c\/li\x3e\n\x3cli\x3e点击下一个按钮，从当前显示项目逐渐左移至下一个项目。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一开始我们使用 \x3ccode\x3eindex\x3c\/code\x3e 这个属性来控制要展现的项目。因为动画会有中间值，比如介于 0 和 1 之间的值，所以我们需要一个新的值来表示项目的位置。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3epositionAnimated：控制项目的位移位置\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e为了组件接口的设计方便，不应该把这个底层状态 \x3ccode\x3epositionAnimated\x3c\/code\x3e 暴露给组件调用方去处理。组件调用方依旧只需要控制 \x3ccode\x3eindex\x3c\/code\x3e 即可动画改变当前展示的项目。而在组件内部，监听 \x3ccode\x3eindex\x3c\/code\x3e 的更新，然后驱动 \x3ccode\x3epositionAnimated\x3c\/code\x3e 的改变项目位置即可。\x3c\/p\x3e\n\x3cp\x3e动画版轮播图的核心原理和最初的简单版类似：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22translateX =  - index *  layoutWidth\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ini\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attr\x22\x3etranslateX\x3c\/span\x3e =  - index *  layoutWidth\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e核心代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22scrollTo = ( toIndex ) =\x3e {\n    Animated.spring(this.state.positionAnimated, {\n        toValue: - toIndex * this.state.layoutWidth,\n        friction: 12,\n        tension: 50,\n    }).start()\n}\n\nrender() {\n    \/\/ ...\n    const items = children.map((item, index) =\x3e (\n        \x3cAnimated.View\n            style=\x22{{\x22\n                width: layoutWidth,\n                transform: [{\n                    translateX: this.state.positionAnimated\n                }],\n            \x22}}\x22\n            key={index}\n        \x3e\n            {item}\n        \x3c\/Animated.View\x3e\n    ));\n    \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3escrollTo = ( toIndex ) =\x26gt; {\n    Animated.spring(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.positionAnimated, {\n        toValue: - toIndex * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.layoutWidth,\n        friction: \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e,\n        tension: \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\n    }).start()\n}\n\nrender() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e items = children.map((item, index) =\x26gt; (\n        \x26lt;Animated.View\n            style=\x22{{\x22\n                width: layoutWidth,\n                transform: [{\n                    translateX: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.positionAnimated\n                }],\n            \x22}}\x22\n            key={index}\n        \x26gt;\n            {item}\n        \x26lt;\/Animated.View\x26gt;\n    ));\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/jiangleo\/learn-react-native\/blob\/master\/App\/1_AnimatedSwiper\/AnimatedSwiper.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e支持手势控制\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e手势事件简介\x3c\/h3\x3e\n\x3cp\x3eReact Native 的手势事件类似于 Web，但 React Native 的手势事件更加强大和灵活。\x3c\/p\x3e\n\x3cp\x3e两者相似点有：\x3c\/p\x3e\n\x3cp\x3e# | React Native | Web\x3cbr\x3e--|--|--\x3cbr\x3e开始触碰 | onPanResponderGrant | touchstart\x3cbr\x3e开始移动 | onResponderMove | touchmove\x3cbr\x3e结束触碰 | onResponderRelease  | touchend\x3cbr\x3e意外取消 |   onResponderTerminate  | touchcancel\x3c\/p\x3e\n\x3cp\x3e两者不同点在于，React Native 可以针对具体元素绑定手势，而在 Web 中只能针对全局 \x3ccode\x3edocument\x3c\/code\x3e 进行手势监听。\x3c\/p\x3e\n\x3cp\x3e在 React Native 手势接口设计上，大家可以先思考一个问题。因为 React Native 允许两个元素同时监听手势事件，如果两个元素都监听了手势，那么 React Native 应该响应那个元素呢？在 React Native 中设计了，成为响应者 \x3ccode\x3eResponder\x3c\/code\x3e 的概念。大概可以描述为：如果没有响应者，任何元素都可以成为响应者；如果有元素是响应者，必须当前响应元素同意不再继续成为响应者后，其他元素才能变成响应者。总而言之，React Native 通过元素间的谈判，保障了手势响应者只有一个。谈判接口主要有：\x3c\/p\x3e\n\x3cp\x3e# | React Native | Web\x3cbr\x3e--|--|--\x3cbr\x3e开始触碰，是否成为响应者 | onStartShouldSetPanResponder =\x26gt; boolean | 无\x3cbr\x3e开始移动，是否成为响应者 | onMoveShouldSetPanResponder =\x26gt; boolean | 无\x3cbr\x3e有其他响应者，是否释放响应权 | onPanResponderTerminationRequest =\x26gt; boolean | 无\x3c\/p\x3e\n\x3cp\x3e以上手势事件非常底层，写起来也很复杂。而一起简单的手势事件，如 click 事件，并不需要这么复杂。为此 React Native 基于以上手势事件，提供了 \x3ccode\x3eTouchableHighlight\x3c\/code\x3e 等组件。该组件封装了一些常用的点击事件和点击相关的配置，如： \x3ccode\x3eonPress\x3c\/code\x3e(click)、\x3ccode\x3eunderlayColor\x3c\/code\x3e 点击态背景色等。\x3c\/p\x3e\n\x3cp\x3e在写简单轮播图时，用的是点击事件来代替滑动事件。点击事件的处理，用到的就是 \x3ccode\x3eTouchableHighlight\x3c\/code\x3e 组件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e实现\x3c\/h3\x3e\n\x3cp\x3e手势轮播图在动画轮播图上进行了升级，它需要支持以下功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e滑动：用户滑动时，轮播图跟着手指移动；\x3c\/li\x3e\n\x3cli\x3e右滑：用户向右滑动超过某个阙值后，触发右滑动作，轮播图位移至上一个项目；\x3c\/li\x3e\n\x3cli\x3e左滑：用户向左滑动超过某个阙值后，触发左滑动作，轮播图位移至下一个项目。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当用户滑动时，需要相应的改变 \x3ccode\x3epositionAnimated\x3c\/code\x3e 的值，使轮播图跟着手指移动。这里有个等式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22最终的位置 = 开始的位置 \x2b 手势移动过的距离\nposition = startPosition \x2b movePosition\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e最终的位置 = 开始的位置 \x2b 手势移动过的距离\n\x3cspan class=\x22hljs-built_in\x22\x3eposition\x3c\/span\x3e = startPosition \x2b movePosition\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e开始的位置，需要在轮播图响应手势时 \x3ccode\x3eonPanResponderGrant\x3c\/code\x3e 记录。手势移动过的距离可以在手势移动时 \x3ccode\x3eonResponderMove\x3c\/code\x3e 获取，与此同时通过 \x3ccode\x3epositionAnimated.setValue(position)\x3c\/code\x3e 改变轮播图的位置，让轮播图跟着手指移动。\x3c\/p\x3e\n\x3cp\x3e左滑、右滑，是在用户抬起手指时 \x3ccode\x3eonResponderRelease\x3c\/code\x3e 开始触发，触发的临界点我们可以简单的设置为外部容器一半的宽度。然后通过 \x3ccode\x3eonChange\x3c\/code\x3e 事件告诉，调用方要改变的位置是什么，由调用方位移轮播图。\x3c\/p\x3e\n\x3cp\x3e实现的核心代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22onPanResponderEnd = () =\x3e {\n    \/\/ 超过 50% 的距离，触发左滑、右滑\n    const index = Math.round(-this.position \/ this.state.layoutWidth)\n    const safeIndex = this.getSafeIndex(index);\n    this.props.onChange(safeIndex)\n};\n\nresponder = PanResponder.create({\n    onPanResponderGrant: (evt, gestureState) =\x3e {\n        \/\/ 用户手指触碰屏幕，停止动画\n        this.state.positionAnimated.stopAnimation();\n        \/\/ 记录手势响应时的位置\n        this.startPosition = this.position;\n    },\n    onPanResponderMove: (evt, { dx }) =\x3e {\n        \/\/ 要变化的位置 = 手势响应时的位置 \x2b 移动的距离\n        const position = this.startPosition \x2b dx\n        this.state.positionAnimated.setValue(position)\n    },\n    onPanResponderRelease: this.onPanResponderEnd,\n    onPanResponderTerminate: this.onPanResponderEnd,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3eonPanResponderEnd = () =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 超过 50% 的距离，触发左滑、右滑\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e index = Math.round(-\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.position \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.layoutWidth)\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e safeIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getSafeIndex(index);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onChange(safeIndex)\n};\n\nresponder = PanResponder.create({\n    onPanResponderGrant: (evt, gestureState) =\x26gt; {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用户手指触碰屏幕，停止动画\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.positionAnimated.stopAnimation();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录手势响应时的位置\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startPosition = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.position;\n    },\n    onPanResponderMove: (evt, { dx }) =\x26gt; {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 要变化的位置 = 手势响应时的位置 \x2b 移动的距离\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e position = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startPosition \x2b dx\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.positionAnimated.setValue(position)\n    },\n    onPanResponderRelease: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onPanResponderEnd,\n    onPanResponderTerminate: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onPanResponderEnd,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/jiangleo\/learn-react-native\/blob\/master\/App\/2_GestureSwiper\/GestureSwiper.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e到此一个 React Native 轮播图的也已经实现了，相信大家也应该对 React Native 有了大概的了解和认知。\x3c\/p\x3e\n\x3cp\x3e在写这个轮播图的过程中，应用了 \x3ccode\x3eView\x3c\/code\x3e、\x3ccode\x3eTouchble*\x3c\/code\x3e 组件和 \x3ccode\x3eAnimated\x3c\/code\x3e、\x3ccode\x3ePanResponder\x3c\/code\x3e、\x3ccode\x3eStyleSheet\x3c\/code\x3e API。\x3c\/p\x3e\n\x3cp\x3e在写轮播图的过程中，还应用了小步迭代的开发方式。即实现的过程中，将这个轮播图分为了三个阶段进行开发：简单轮播图、动画轮播图、手势轮播图。每个阶段，又可以分为三个步骤：准备要应用的知识(google)、实现功能描述、实现。通过小步迭代的方式，可以将一个大问题分解为几个小问题，再把小问题分解为最基本的知识点，再去设法实现。\x3c\/p\x3e\n\x3cp\x3e最后，这还只是一个轮播图的雏形，还有很多优化点可以做，比如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eisLoop： 是否头尾衔接的循环轮播\x3c\/li\x3e\n\x3cli\x3ehorizontal：是否水平轮播\x3c\/li\x3e\n\x3cli\x3erenderPager：接受一个组件，该用于处理手势和动画。比如可以使用 ScrollView 和 ViewPagerAnder，在一些特定场景下处理手势和动画，达到更高的性能。\x3c\/li\x3e\n\x3cli\x3eshowsPagination：实现展现轮播提示的视图，比如小圆点提示当前播到第几个轮播项目了。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e大家可以参考代码中的 SwiperAndroid 进行完成。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>写一个轮播图，学会 React Native</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011830204">https://segmentfault.com/a/1190000011830204</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qe19amcr0z9/" target="_blank">https://alili.tech/archive/qe19amcr0z9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>