<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue源码解析之Template转化为AST"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue源码解析之Template转化为AST | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qhrx51krqa/",
				"appid": "1613049289050283", 
				"title": "Vue源码解析之Template转化为AST | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/5xyr8k7kco3/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hd4tludgiat/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&text=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&text=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&title=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&is_video=false&description=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&title=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&title=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&title=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhrx51krqa%2f&title=Vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%e4%b9%8bTemplate%e8%bd%ac%e5%8c%96%e4%b8%baAST"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue源码解析之Template转化为AST</h1><div class="meta"><div class="postdate"><time datetime="2018-12-29" itemprop="datePublished">2018-12-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e什么是AST\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e在Vue的mount过程中，template会被编译成AST语法树，AST是指抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3cstrong\x3eVirtual Dom\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3eVue的一个厉害之处就是利用Virtual DOM模拟DOM对象树来优化DOM操作的一种技术或思路。\x3cbr\x3eVue源码中虚拟DOM构建经历 template编译成AST语法树 -\x26gt; 再转换为render函数 最终返回一个VNode(VNode就是Vue的虚拟DOM节点) \x3cbr\x3e本文通过对源码中AST转化部分进行简单提取，因为源码中转化过程还需要进行各种兼容判断，非常复杂，所以笔者对主要功能代码进行提取，用了300-400行代码完成对template转化为AST这个功能。下面用具体代码进行分析。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function parse(template) {\n        var currentParent;    \/\/当前父节点\n        var root;            \/\/最终返回出去的AST树根节点\n        var stack = [];\n        parseHTML(template, {\n            start: function start(tag, attrs, unary) {\n               ......\n            },\n            end: function end() {\n              ......\n            },\n            chars: function chars(text) {\n               ......\n            }\n        })\n        return root\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eparse\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(template)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentParent;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/当前父节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/最终返回出去的AST树根节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = [];\n        parseHTML(template, {\n            start: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estart\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(tag, attrs, unary)\x3c\/span\x3e \x3c\/span\x3e{\n               ......\n            },\n            end: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eend\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n              ......\n            },\n            chars: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echars\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(text)\x3c\/span\x3e \x3c\/span\x3e{\n               ......\n            }\n        })\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e root\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第一步就是调用parse这个方法，把template传进来，这里假设template为 \x3ccode\x3e\x26lt;div id=\x22app\x22\x26gt;\x26lt;span\x26gt;\x22{{\x22message\x22}}\x22\x26lt;\/span\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e然后声明3个变量  \x3cbr\x3ecurrentParent -\x26gt; 存放当前父元素，root -\x26gt; 最终返回出去的AST树根节点，stack -\x26gt; 一个栈用来辅助树的建立\x3cbr\x3e接着调用parseHTML函数进行转化，传入template和options（包含3个方法 start,end,chars 等下用到这3个函数再进行解释）接下来先看parseHTML这个方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function parseHTML(html, options) {\n        var stack = [];    \/\/这里和上面的parse函数一样用到stack这个数组 不过这里的stack只是为了简单存放标签名 为了和结束标签进行匹配的作用\n        var isUnaryTag$$1 = isUnaryTag;   \/\/判断是否为自闭合标签\n        var index = 0;\n        var last;\n        while (html) {\n            \/\/　　第一次进入while循环时，由于字符串以\x3c开头，所以进入startTag条件，并进行AST转换，最后将对象弹入stack数组中\n            last = html;\n            var textEnd = html.indexOf(\x27\x3c\x27);\n            if (textEnd === 0) {     \/\/ 此时字符串是不是以\x3c开头\n                \/\/ End tag:\n                var endTagMatch = html.match(endTag);\n                if (endTagMatch) {\n                    var curIndex = index;\n                    advance(endTagMatch[0].length);\n                    parseEndTag(endTagMatch[1], curIndex, index);\n                    continue\n                }\n\n                \/\/ Start tag:    \/\/ 匹配起始标签\n                var startTagMatch = parseStartTag();    \/\/处理后得到match\n                if (startTagMatch) {\n                    handleStartTag(startTagMatch);\n                    continue\n                }\n            }\n\n            \/\/ 初始化为undefined 这样安全且字符数少一点\n            var text = (void 0), rest = (void 0), next = (void 0);\n            if (textEnd \x3e= 0) {      \/\/ 截取\x3c字符索引 =\x3e \x3c\/div\x3e 这里截取到闭合的\x3c\n                rest = html.slice(textEnd);  \/\/截取闭合标签\n                \/\/ 处理文本中的\x3c字符\n                \/\/ 获取中间的字符串 =\x3e \x22{{\x22message\x22}}\x22\n                text = html.substring(0, textEnd); \/\/截取到闭合标签前面部分\n                advance(textEnd);               \/\/切除闭合标签前面部分\n\n            }\n            \/\/ 当字符串没有\x3c时\n            if (textEnd \x3c 0) {\n                text = html;\n                html = \x27\x27;\n            }\n            \/\/ \/\/ 处理文本\n            if (options.chars \x26amp;\x26amp; text) {\n                options.chars(text);\n            }\n        }\n   }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eparseHTML\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(html, options)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = [];    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里和上面的parse函数一样用到stack这个数组 不过这里的stack只是为了简单存放标签名 为了和结束标签进行匹配的作用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isUnaryTag$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e = isUnaryTag;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断是否为自闭合标签\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e last;\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (html) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/　　第一次进入while循环时，由于字符串以\x26lt;开头，所以进入startTag条件，并进行AST转换，最后将对象弹入stack数组中\x3c\/span\x3e\n            last = html;\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e textEnd = html.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\x27\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (textEnd === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此时字符串是不是以\x26lt;开头\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ End tag:\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e endTagMatch = html.match(endTag);\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (endTagMatch) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e curIndex = index;\n                    advance(endTagMatch[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length);\n                    parseEndTag(endTagMatch[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], curIndex, index);\n                    \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n                }\n\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Start tag:    \/\/ 匹配起始标签\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startTagMatch = parseStartTag();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/处理后得到match\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (startTagMatch) {\n                    handleStartTag(startTagMatch);\n                    \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n                }\n            }\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化为undefined 这样安全且字符数少一点\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e text = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e), rest = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e), next = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (textEnd \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 截取\x26lt;字符索引 =\x26gt; \x26lt;\/div\x26gt; 这里截取到闭合的\x26lt;\x3c\/span\x3e\n                rest = html.slice(textEnd);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/截取闭合标签\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理文本中的\x26lt;字符\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取中间的字符串 =\x26gt; \x22{{\x22message\x22}}\x22\x3c\/span\x3e\n                text = html.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, textEnd); \x3cspan class=\x22hljs-comment\x22\x3e\/\/截取到闭合标签前面部分\x3c\/span\x3e\n                advance(textEnd);               \x3cspan class=\x22hljs-comment\x22\x3e\/\/切除闭合标签前面部分\x3c\/span\x3e\n\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当字符串没有\x26lt;时\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (textEnd \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n                text = html;\n                html = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/\/ 处理文本\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.chars \x26amp;\x26amp; text) {\n                options.chars(text);\n            }\n        }\n   }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数进入while循环对html进行获取\x3ccode\x3e\x26lt;\x3c\/code\x3e标签索引 \x3ccode\x3evar textEnd = html.indexOf(\x27\x26lt;\x27);\x3c\/code\x3e如果textEnd === 0 说明当前是标签\x26lt;xxx\x26gt;或者\x26lt;\/xxx\x26gt; 再用正则匹配是否当前是结束标签\x26lt;\/xxx\x26gt;。\x3ccode\x3evar endTagMatch = html.match(endTag);\x3c\/code\x3e  匹配不到那么就是开始标签，调用parseStartTag()函数解析。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function parseStartTag() {      \/\/返回匹配对象\n    var start = html.match(startTagOpen);         \/\/ 正则匹配\n    if (start) {\n        var match = {\n            tagName: start[1],       \/\/ 标签名(div)\n            attrs: [],               \/\/ 属性\n            start: index             \/\/ 游标索引(初始为0)\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) \x26amp;\x26amp; (attr = html.match(attribute))) {  \n            advance(attr[0].length);  \n            match.attrs.push(attr);\n        }\n        if (end) {\n            advance(end[0].length);      \/\/ 标记结束位置\n            match.end = index;      \/\/这里的index 是在 parseHTML就定义 在advance里面相加\n            return match         \/\/ 返回匹配对象 起始位置 结束位置 tagName attrs\n        }\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pony\x22\x3e\x3ccode\x3efunction parseStartTag() {      \x3cspan class=\x22hljs-comment\x22\x3e\/\/返回匹配对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e start = html.\x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e(startTagOpen);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正则匹配\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (start) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e = {\n            tagName: start[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标签名(div)\x3c\/span\x3e\n            attrs: [],               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 属性\x3c\/span\x3e\n            start: index             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 游标索引(初始为0)\x3c\/span\x3e\n        };\n        advance(start[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e, attr;\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e = html.\x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e(startTagClose)) \x26amp;\x26amp; (attr = html.\x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e(attribute))) {  \n            advance(attr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length);  \n            \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e.attrs.push(attr);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n            advance(\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length);      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标记结束位置\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e = index;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里的index 是在 parseHTML就定义 在advance里面相加\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回匹配对象 起始位置 结束位置 tagName attrs\x3c\/span\x3e\n        }\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该函数主要是为了构建一个match对象，对象里面包含tagName(标签名)，attrs(标签的属性)，start(\x3ccode\x3e\x26lt;\x3c\/code\x3e左开始标签在template中的位置)，end(\x3ccode\x3e\x26gt;\x3c\/code\x3e右开始标签在template中的位置) 如template = \x3ccode\x3e\x26lt;div id=\x22app\x22\x26gt;\x26lt;div\x26gt;\x26lt;span\x26gt;\x22{{\x22message\x22}}\x22\x26lt;\/span\x26gt;\x26lt;\/div\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e 程序第一次进入该函数 匹配的是div标签  所以tagName就是div\x3cbr\x3estart：0 end:14 如图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWvOT?w=299\x26amp;h=252\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWvOT?w=299\x26amp;h=252\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接着把match返回出去 作为调用handleStartTag的参数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var startTagMatch = parseStartTag();    \/\/处理后得到match\nif (startTagMatch) {\n    handleStartTag(startTagMatch);\n    continue\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startTagMatch = parseStartTag();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/处理后得到match\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (startTagMatch) {\n    handleStartTag(startTagMatch);\n    \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来看handleStartTag这个函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unary = isUnaryTag$$1(tagName)  \/\/判断是否为闭合标签 \n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i \x3c l; i\x2b\x2b) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || \x27\x27;\n        attrs[i] = {\n            name: args[1],\n            value: value\n        };\n    }\n    if (!unary) {\n        stack.push({tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs});\n        lastTag = tagName;\n    }\n    if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n    }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e function handleStartTag(match) {\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e tagName = match.tagName;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e unary = isUnaryTag$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e(tagName)  \/\/判断是否为闭合标签 \n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e l = match.attrs.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e attrs = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Array(l);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; l; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e = match.attrs[i];\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e] || \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e] || \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e] || \x27\x27;\n        attrs[i] = {\n            name: \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],\n            value: value\n        };\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!unary) {\n        stack.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e({tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs});\n        lastTag = tagName;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n    }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数中分为3部分 第一部分是for循环是对attrs进行转化，我们从上一步的parseStartTag()得到的match对象中的attrs属性如图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWuQv?w=302\x26amp;h=253\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWuQv?w=302\x26amp;h=253\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当时attrs是上面图这样子滴 我们通过这个循环把它转化为只带name 和 value这2个属性的对象 如图:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWuQZ?w=263\x26amp;h=245\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWuQZ?w=263\x26amp;h=245\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接着判断如果不是自闭合标签，把标签名和属性推入栈中（注意 这里的stack这个变量在parseHTML中定义，作用是为了存放标签名 为了和结束标签进行匹配的作用。）接着调用最后一步 options.start 这里的options就是我们在parse函数中 调用parseHTML是传进来第二个参数的那个对象(包含start end chars 3个方法函数) 这里开始看options.start这个函数的作用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22start: function start(tag, attrs, unary) {\n    var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n    };\n    processAttrs(element);\n    if (!root) {\n        root = element;\n    } \n    if(currentParent){\n        currentParent.children.push(element);\n        element.parent = currentParent;\n    }\n    if (!unary) {\n        currentParent = element;\n        stack.push(element);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3estart: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estart\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(tag, attrs, unary)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = {\n        type: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        \x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e: currentParent,\n        children: []\n    };\n    processAttrs(element);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!root) {\n        root = element;\n    } \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(currentParent){\n        currentParent.children.push(element);\n        element.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e = currentParent;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!unary) {\n        currentParent = element;\n        stack.push(element);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数中 生成element对象 再连接元素的parent 和 children节点  最终push到栈中\x3cbr\x3e此时栈中第一个元素生成 如图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWuVO?w=304\x26amp;h=248\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWuVO?w=304\x26amp;h=248\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e完成了while循环的第一次执行，进入第二次循环执行，这个时候html变成\x3ccode\x3e\x26lt;span\x26gt;\x22{{\x22message\x22}}\x22\x26lt;\/span\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e 接着截取到\x26lt;span\x26gt; 处理过程和第一次一致 经过这次循环stack中元素如图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWu1n?w=296\x26amp;h=250\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWu1n?w=296\x26amp;h=250\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWu1r?w=297\x26amp;h=213\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWu1r?w=297\x26amp;h=213\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接着继续执行第三个循环 这个时候是处理文本节点了 \x22{{\x22message\x22}}\x22\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 初始化为undefined 这样安全且字符数少一点\nvar text = (void 0), rest = (void 0), next = (void 0);\nif (textEnd \x3e= 0) {      \/\/ 截取\x3c字符索引 =\x3e \x3c\/div\x3e 这里截取到闭合的\x3c\n    rest = html.slice(textEnd);  \/\/截取闭合标签\n    \/\/ 处理文本中的\x3c字符\n    \/\/ 获取中间的字符串 =\x3e \x22{{\x22message\x22}}\x22\n    text = html.substring(0, textEnd); \/\/截取到闭合标签前面部分\n    advance(textEnd);               \/\/切除闭合标签前面部分\n}\n\/\/ 当字符串没有\x3c时\nif (textEnd \x3c 0) {\n    text = html;\n    html = \x27\x27;\n}\n\/\/ 另外一个函数\nif (options.chars \x26amp;\x26amp; text) {\n    options.chars(text);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化为undefined 这样安全且字符数少一点\x3c\/span\x3e\nvar \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e), rest = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e), next = (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (textEnd \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 截取\x26lt;字符索引 =\x26gt; \x26lt;\/div\x26gt; 这里截取到闭合的\x26lt;\x3c\/span\x3e\n    rest = html.slice(textEnd);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/截取闭合标签\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理文本中的\x26lt;字符\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取中间的字符串 =\x26gt; \x22{{\x22message\x22}}\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e = html.substring(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, textEnd); \x3cspan class=\x22hljs-comment\x22\x3e\/\/截取到闭合标签前面部分\x3c\/span\x3e\n    advance(textEnd);               \x3cspan class=\x22hljs-comment\x22\x3e\/\/切除闭合标签前面部分\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当字符串没有\x26lt;时\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (textEnd \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e = html;\n    html = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 另外一个函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (options.chars \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e) {\n    options.chars(\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的作用就是把文本提取出来 调用options.chars这个函数 接下来看options.chars\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22chars: function chars(text) {\n    if (!currentParent) {   \/\/如果没有父元素 只是文本\n        return\n    }\n\n    var children = currentParent.children;  \/\/取出children\n    \/\/ text =\x3e \x22{{\x22message\x22}}\x22\n    if (text) {\n        var expression;\n        if (text !== \x27 \x27 \x26amp;\x26amp; (expression = parseText(text))) {\n            \/\/ 将解析后的text存进children数组\n            children.push({\n                type: 2,\n                expression: expression,\n                text: text\n            });\n        } else if (text !== \x27 \x27 || !children.length || children[children.length - 1].text !== \x27 \x27) {\n            children.push({\n                type: 3,\n                text: text\n            });\n        }\n    }\n}\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs openscad\x22\x3e\x3ccode\x3echars: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echars\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(text)\x3c\/span\x3e {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!currentParent) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有父元素 只是文本\x3c\/span\x3e\n        return\n    }\n\n    var \x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e = currentParent.\x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/取出children\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ text =\x26gt; \x22{{\x22message\x22}}\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e) {\n        var expression;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e !== \x27 \x27 \x26amp;\x26amp; (expression = parseText(\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e))) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将解析后的text存进children数组\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e.push({\n                type: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n                expression: expression,\n                \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e\n            });\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e !== \x27 \x27 || !\x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e.length || \x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e[\x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e !== \x27 \x27) {\n            \x3cspan class=\x22hljs-built_in\x22\x3echildren\x3c\/span\x3e.push({\n                type: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e\n            });\n        }\n    }\n}\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的主要功能是判断文本是\x22{{\x22xxx\x22}}\x22还是简单的文本xxx,如果是简单的文本 push进父元素的children里面，type设置为3，如果是字符模板\x22{{\x22xxx\x22}}\x22，调用parseText转化。如这里的\x3ccode\x3e\x22{{\x22message\x22}}\x22\x3c\/code\x3e转化为 \x3ccode\x3e_s(message)\x3c\/code\x3e(加上_s是为了AST的下一步转为render函数，本文中暂时不会用到。) 再把转化后的内容push进children。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWu8O?w=297\x26amp;h=245\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWu8O?w=297\x26amp;h=245\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e又走完一个循环了，这个时候html = \x3ccode\x3e\x26lt;\/span\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e 剩下2个结束标签进行匹配了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  var endTagMatch = html.match(endTag);\n    if (endTagMatch) {\n        var curIndex = index;\n        advance(endTagMatch[0].length);\n        parseEndTag(endTagMatch[1], curIndex, index);\n        continue\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3e  var endTagMatch = html.match(endTag);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (endTagMatch) {\n        var curIndex = \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3eadvance\x3c\/span\x3e(endTagMatch[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].length);\n        parseEndTag(endTagMatch[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], curIndex, \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来看parseEndTag这个函数 传进来了标签名 开始索引和结束索引\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n    }\n    \/\/ Find the closest opened tag of the same type\n    if (tagName) { \/\/ 获取最近的匹配标签\n        for (pos = stack.length - 1; pos \x3e= 0; pos--) {\n            \/\/ 提示没有匹配的标签\n            if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n                break\n            }\n        }\n    } else {\n        \/\/ If no tag name is provided, clean shop\n        pos = 0;\n    }\n    \n    if (pos \x3e= 0) {\n        \/\/ Close all the open elements, up the stack\n        for (var i = stack.length - 1; i \x3e= pos; i--) {\n            if (options.end) {\n                options.end(stack[i].tag, start, end);\n            }\n        }\n    \n        \/\/ Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos \x26amp;\x26amp; stack[pos - 1].tag;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs hsp\x22\x3e\x3ccode\x3e  function parseEndTag(tagName, start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n    var \x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e, lowerCasedTagName\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (tagName) {\n        lowerCasedTagName = tagName.toLowerCase()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Find the closest opened tag of the same type\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (tagName) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取最近的匹配标签\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e = stack.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e; pos \x26gt;= 0; pos--) {\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提示没有匹配的标签\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (stack[\x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e].lowerCasedTag === lowerCasedTagName) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n            }\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If no tag name is provided, clean shop\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Close all the open elements, up the stack\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (var i = stack.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e; i \x26gt;= pos; i--) {\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.end) {\n                options.end(stack[i].tag, start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n            }\n        }\n    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Remove the open elements from the stack\x3c\/span\x3e\n        stack.length = \x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        lastTag = \x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e \x26amp;\x26amp; stack[\x3cspan class=\x22hljs-keyword\x22\x3epos\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].tag\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里首先找到栈中对应的开始标签的索引pos，再从该索引开始到栈顶的所以元素调用options.end这个函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 end: function end() {\n    \/\/ pop stack\n    stack.length -= 1;\n    currentParent = stack[stack.length - 1];\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scilab\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eend\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ pop stack\x3c\/span\x3e\n    stack.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e -= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    currentParent = stack[stack.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e把栈顶元素出栈，因为这个元素已经匹配到结束标签了，再把当前父元素更改。终于走完了，把html的内容循环完，最终return root 这个root就是我们所要得到的AST\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWvuX?w=302\x26amp;h=248\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWvuX?w=302\x26amp;h=248\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这只是Vue的冰山一角，文中有什么不对的地方请大家帮忙指正，本人最近也一直在学习Vue的源码，希望能够拿出来与大家一起分享经验，接下来会继续更新后续的源码，如果觉得有帮忙请给个Star哈\x3cbr\x3egithub地址为:\x3ca href=\x22https:\/\/github.com\/zwStar\/vue-ast\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/zwStar\/vue...\x3c\/a\x3e 欢迎各位star或issues\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue源码解析之Template转化为AST</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011531094">https://segmentfault.com/a/1190000011531094</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qhrx51krqa/" target="_blank">https://alili.tech/archive/qhrx51krqa/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>