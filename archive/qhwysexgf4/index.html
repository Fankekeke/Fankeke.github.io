<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 深入系列３：Props 和 State"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 深入系列３：Props 和 State | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qhwysexgf4/",
				"appid": "1613049289050283", 
				"title": "React 深入系列３：Props 和 State | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ry8gh822u39/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/u9cltb727ad/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&text=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&text=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&title=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&is_video=false&description=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&title=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&title=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&title=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqhwysexgf4%2f&title=React%20%e6%b7%b1%e5%85%a5%e7%b3%bb%e5%88%97%ef%bc%93%ef%bc%9aProps%20%e5%92%8c%20State"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 深入系列３：Props 和 State</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e文：徐超，《React进阶之路》作者\x3cp\x3e授权发布，转载请注明作者及出处\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3eReact 深入系列3：Props 和 State\x3c\/h1\x3e\n\x3cblockquote\x3eReact 深入系列，深入讲解了React中的重点概念、特性和模式等，旨在帮助大家加深对React的理解，以及在项目中更加灵活地使用React。\x3c\/blockquote\x3e\n\x3cp\x3eReact 的核心思想是组件化的思想，而React 组件的定义可以通过下面的公式描述：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22UI = Component(props, state)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eUI = Component(props, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组件根据props和state两个参数，计算得到对应界面的UI。可见，props 和 state 是组件的两个重要数据源。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e本篇文章不是对props 和state 基本用法的介绍，而是尝试从更深层次解释props 和 state，并且归纳使用它们时的注意事项。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eProps 和 State 本质\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e一句话概括，props 是组件对外的接口，state 是组件对内的接口。\x3c\/strong\x3e组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。\x3c\/p\x3e\n\x3cp\x3e组件的props 和 state都和组件最终渲染出的UI直接相关。两者的主要区别是：state是可变的，是组件内部维护的一组用于反映组件UI变化的状态集合；而props是组件的只读属性，组件内部不能直接修改props，要想修改props，只能在该组件的上层组件中修改。在组件\x3cstrong\x3e状态上移\x3c\/strong\x3e的场景中，父组件正是通过子组件的props，传递给子组件其所需要的状态。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e如何定义State\x3c\/h2\x3e\n\x3cp\x3e定义一个合适的state，是正确创建组件的第一步。state必须能代表一个组件UI呈现的\x3cstrong\x3e完整状态集\x3c\/strong\x3e，即组件对应UI的任何改变，都可以从state的变化中反映出来；同时，state还必须是代表一个组件UI呈现的\x3cstrong\x3e最小状态集\x3c\/strong\x3e，即state中的所有状态都是用于反映组件UI的变化，没有任何多余的状态，也不需要通过其他状态计算而来的中间状态。\x3c\/p\x3e\n\x3cp\x3e组件中用到的一个变量是不是应该作为组件state，可以通过下面的4条依据进行判断：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e这个变量是否是通过props从父组件中获取？如果是，那么它不是一个状态。\x3c\/li\x3e\n\x3cli\x3e这个变量是否在组件的整个生命周期中都保持不变？如果是，那么它不是一个状态。\x3c\/li\x3e\n\x3cli\x3e这个变量是否可以通过state 或props 中的已有数据计算得到？如果是，那么它不是一个状态。\x3c\/li\x3e\n\x3cli\x3e这个变量是否在组件的render方法中使用？如果\x3cstrong\x3e不是\x3c\/strong\x3e，那么它不是一个状态。这种情况下，这个变量更适合定义为组件的一个\x3cstrong\x3e普通属性\x3c\/strong\x3e（除了props 和 state以外的组件属性 ），例如组件中用到的定时器，就应该直接定义为this.timer，而不是this.state.timer。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e请务必牢记，并不是组件中用到的所有变量都是组件的状态！\x3c\/strong\x3e当存在多个组件共同依赖同一个状态时，一般的做法是\x3cstrong\x3e状态上移\x3c\/strong\x3e，将这个状态放到这几个组件的公共父组件中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e如何正确修改State\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.不能直接修改State。\x3c\/h3\x3e\n\x3cp\x3e直接修改state，组件并不会重新重发render。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 错误\nthis.state.title = \x27React\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ 错误\nthis.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.title = \x27React\x27;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正确的修改方式是使用\x3ccode\x3esetState()\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确\nthis.setState({title: \x27React\x27});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正确\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-string\x22\x3etitle:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e2. State 的更新是异步的。\x3c\/h3\x3e\n\x3cp\x3e调用\x3ccode\x3esetState\x3c\/code\x3e，组件的state并不会立即改变，\x3ccode\x3esetState\x3c\/code\x3e只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且React会出于性能原因，可能会将多次\x3ccode\x3esetState\x3c\/code\x3e的状态修改合并成一次状态修改。所以不能依赖当前的state，计算下个state。当真正执行状态修改时，依赖的this.state并不能保证是最新的state，因为React会把多次state的修改合并成一次，这时，this.state还是等于这几次修改发生前的state。另外需要注意的是，同样不能依赖当前的props计算下个state，因为props的更新也是异步的。\x3c\/p\x3e\n\x3cp\x3e举个例子，对于一个电商类应用，在我们的购物车中，当点击一次购买按钮，购买的数量就会加1，如果我们连续点击了两次按钮，就会连续调用两次\x3ccode\x3ethis.setState({quantity: this.state.quantity \x2b 1})\x3c\/code\x3e，在React合并多次修改为一次的情况下，相当于等价执行了如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.assign(\n  previousState,\n  {quantity: this.state.quantity \x2b 1},\n  {quantity: this.state.quantity \x2b 1}\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eObject.assign(\n  previousState,\n  {quantity: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.quantity \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e},\n  {quantity: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.quantity \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e于是乎，后面的操作覆盖掉了前面的操作，最终购买的数量只增加了1个。\x3c\/p\x3e\n\x3cp\x3e如果你真的有这样的需求，可以使用另一个接收一个函数作为参数的\x3ccode\x3esetState\x3c\/code\x3e，这个函数有两个参数，第一个参数是组件的前一个state（本次组件状态修改成功前的state），第二个参数是组件当前最新的props。如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 正确\nthis.setState((preState, props) =\x3e ({\n  counter: preState.quantity \x2b 1; \n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 正确\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(preState, props)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  counter: preState.quantity \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e3. State 的更新是一个浅合并（Shallow Merge）的过程。\x3c\/h3\x3e\n\x3cp\x3e当调用\x3ccode\x3esetState\x3c\/code\x3e修改组件状态时，只需要传入发生改变的状态变量，而不是组件完整的state，因为组件state的更新是一个浅合并（Shallow Merge）的过程。例如，一个组件的state为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.state = {\n  title : \x27React\x27,\n  content : \x27React is an wonderful JS library!\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n  \x3cspan class=\x22hljs-string\x22\x3etitle :\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3econtent :\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React is an wonderful JS library!\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当只需要修改状态\x3ccode\x3etitle\x3c\/code\x3e时，只需要将修改后的\x3ccode\x3etitle\x3c\/code\x3e传给\x3ccode\x3esetState\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState({title: \x27Reactjs\x27});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setState\x3c\/span\x3e({\x3cspan class=\x22hljs-attribute\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Reactjs\x27\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact会合并新的\x3ccode\x3etitle\x3c\/code\x3e到原来的组件state中，同时保留原有的状态\x3ccode\x3econtent\x3c\/code\x3e，合并后的state为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  title : \x27Reactjs\x27,\n  content : \x27React is an wonderful JS library!\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-attribute\x22\x3etitle \x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Reactjs\x27\x3c\/span\x3e,\n  content : \x3cspan class=\x22hljs-string\x22\x3e\x27React is an wonderful JS library!\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eState与Immutable\x3c\/h2\x3e\n\x3cp\x3eReact官方建议把state当作不可变对象，一方面是如果直接修改this.state，组件并不会重新render；另一方面state中包含的所有状态都应该是不可变对象。当state中的某个状态发生变化，我们应该重新创建一个新状态，而不是直接修改原来的状态。那么，当状态发生变化时，如何创建新的状态呢？根据状态的类型，可以分成三种情况：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e1. 状态的类型是不可变类型（数字，字符串，布尔值，null， undefined）\x3c\/h3\x3e\n\x3cp\x3e这种情况最简单，因为状态是不可变类型，直接给要修改的状态赋一个新值即可。如要修改count（数字类型）、title（字符串类型）、success（布尔类型）三个状态：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState({\n  count: 1,\n  title: \x27Redux\x27,\n  success: true\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setState\x3c\/span\x3e({\n  \x3cspan class=\x22hljs-attribute\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  title: \x3cspan class=\x22hljs-string\x22\x3e\x27Redux\x27\x3c\/span\x3e,\n  success: true\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2. 状态的类型是数组\x3c\/h3\x3e\n\x3cp\x3e如有一个数组类型的状态books，当向books中增加一本书时，使用数组的concat方法或ES6的数组扩展语法（spread syntax）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 方法一：使用preState、concat创建新数组\nthis.setState(preState =\x3e ({\n  books: preState.books.concat([\x27React Guide\x27]);\n}))\n\n\/\/ 方法二：ES6 spread syntax\nthis.setState(preState =\x3e ({\n  books: [...preState.books, \x27React Guide\x27];\n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法一：使用preState、concat创建新数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3ebooks\x3c\/span\x3e: preState.books.concat([\x3cspan class=\x22hljs-string\x22\x3e\x27React Guide\x27\x3c\/span\x3e]);\n}))\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法二：ES6 spread syntax\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3ebooks\x3c\/span\x3e: [...preState.books, \x3cspan class=\x22hljs-string\x22\x3e\x27React Guide\x27\x3c\/span\x3e];\n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当从books中截取部分元素作为新状态时，使用数组的slice方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 使用preState、slice创建新数组\nthis.setState(preState =\x3e ({\n  books: preState.books.slice(1,3);\n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用preState、slice创建新数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3ebooks\x3c\/span\x3e: preState.books.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当从books中过滤部分元素后，作为新状态时，使用数组的filter方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 使用preState、filter创建新数组\nthis.setState(preState =\x3e ({\n  books: preState.books.filter(item =\x3e {\n    return item != \x27React\x27; \n  });\n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用preState、filter创建新数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3ebooks\x3c\/span\x3e: preState.books.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e item != \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e; \n  });\n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意不要使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改，而concat、slice、filter会返回一个新的数组。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e3. 状态的类型是简单对象(Plain Object)\x3c\/h3\x3e\n\x3cp\x3e如state中有一个状态owner，结构如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.state = {\n  owner = {\n    name: \x27老干部\x27,\n    age: 30\n  }  \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3ethis.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {\n  owner = {\n    name: \x27老干部\x27,\n    age: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n  }  \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当修改state时，有如下两种方式：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1） 使用ES6 的Object.assgin方法\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState(preState =\x3e ({\n  owner: Object.assign({}, preState.owner, {name: \x27Jason\x27});\n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3eowner\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, preState.owner, {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Jason\x27\x3c\/span\x3e});\n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e2） 使用对象扩展语法（\x3ca href=\x22https:\/\/github.com\/sebmarkbage\/ecmascript-rest-spread\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eobject spread properties\x3c\/a\x3e）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState(preState =\x3e ({\n  owner: {...preState.owner, name: \x27Jason\x27};\n}))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3epreState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n  \x3cspan class=\x22hljs-attr\x22\x3eowner\x3c\/span\x3e: {...preState.owner, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Jason\x27\x3c\/span\x3e};\n}))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总结一下，创建新的状态的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然，也可以使用一些Immutable的JS库，如\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImmutable.js\x3c\/a\x3e，实现类似的效果。\x3c\/p\x3e\n\x3cp\x3e那么，为什么React推荐组件的状态是不可变对象呢？一方面是因为不可变对象方便管理和调试，了解更多可\x3ca href=\x22http:\/\/redux.js.org\/docs\/faq\/ImmutableData.html#benefits-of-immutability\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e参考这里\x3c\/a\x3e；另一方面是出于性能考虑，当组件状态都是不可变对象时，我们在组件的\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e方法中，仅需要比较状态的引用就可以判断状态是否真的改变，从而避免不必要的\x3ccode\x3erender\x3c\/code\x3e方法的调用。当我们使用React 提供的\x3ccode\x3ePureComponent\x3c\/code\x3e时，更是要保证组件状态是不可变对象，否则在组件的\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e方法中，状态比较就可能出现错误。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e下篇预告：\x3c\/h2\x3e\n\x3cp\x3eReact 深入系列4：组件的生命周期\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e新书推荐《React进阶之路》\x3c\/p\x3e\n\x3cp\x3e作者：徐超\x3c\/p\x3e\n\x3cp\x3e毕业于浙江大学，硕士，资深前端工程师，长期就职于能源物联网公司远景智能。8年软件开发经验，熟悉大前端技术，拥有丰富的Web前端和移动端开发经验，尤其对React技术栈和移动Hybrid开发技术有深入的理解和实践经验。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014177338?w=297\x26amp;h=387\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014177338?w=297\x26amp;h=387\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014229430?w=1500\x26amp;h=854\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014229430?w=1500\x26amp;h=854\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e美团点评广告平台大前端团队招收20192020年前端实习生（偏动效方向）\x3c\/p\x3e\n\x3cp\x3e有意者邮件：yao.zhou@meituan.com\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 深入系列３：Props 和 State</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014411837">https://segmentfault.com/a/1190000014411837</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qhwysexgf4/" target="_blank">https://alili.tech/archive/qhwysexgf4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>