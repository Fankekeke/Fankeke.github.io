<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="数据结构与算法：图和图算法(一)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>数据结构与算法：图和图算法(一) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qvti0i4zbgr/",
				"appid": "1613049289050283", 
				"title": "数据结构与算法：图和图算法(一) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-03T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0p9re17fm7d/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cfp86of75yu/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&text=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&text=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&is_video=false&description=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqvti0i4zbgr%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%9a%e5%9b%be%e5%92%8c%e5%9b%be%e7%ae%97%e6%b3%95%28%e4%b8%80%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">数据结构与算法：图和图算法(一)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-03" itemprop="datePublished">2019-01-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e科学上网 ：\x3cbr\x3e输入我的邀请码 \x3ccode\x3eYHMU3B9\x3c\/code\x3e 来获得三个月的蓝灯专业版！立即下载 \x3ca href=\x22https:\/\/github.com\/getlantern\/forum\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/getlantern...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e摘  要  ： 图 论 问 题(Graph Theory)\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTNFS?w=1300\x26amp;h=818\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTNFS?w=1300\x26amp;h=818\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e节点(Vertex)\x3c\/code\x3e 与 \x3ccode\x3e边（Edge）\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e图的表示： \x3ccode\x3e邻接表\x3c\/code\x3e 和 \x3ccode\x3e邻接矩阵 \x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e这里可以分为 \x3ccode\x3e有向图\x3c\/code\x3e 和\x3ccode\x3e无向图\x3c\/code\x3e\x3cbr\x3e\x3ccode\x3e无向图是一种特殊的有向图\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e有权图\x3c\/code\x3e 和 \x3ccode\x3e无权图\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e图的遍历： \x3ccode\x3eDFS\x3c\/code\x3e \x3ccode\x3eBFS\x3c\/code\x3e     常见可以解决的问题有： \x3ccode\x3e联通分量\x3c\/code\x3e  \x3ccode\x3eFlood Fill\x3c\/code\x3e \x3ccode\x3e寻路\x3c\/code\x3e \x3ccode\x3e走迷宫\x3c\/code\x3e \x3ccode\x3e迷宫生成\x3c\/code\x3e  \x3ccode\x3e无权图的最短路径\x3c\/code\x3e \x3ccode\x3e环的判断\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e最小生成树问题（Minimum Spanning Tree）    \x3ccode\x3ePrim\x3c\/code\x3e \x3ccode\x3eKruskal\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e最短路径问题(Shortest Path)   \x3ccode\x3eDijkstra\x3c\/code\x3e \x3ccode\x3eBellman-Ford\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e拓扑排序(Topological sorting)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里可演示　－\x26gt;  \x3ca href=\x22https:\/\/mrpandey.github.io\/d3graphTheory\/unit.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/mrpandey.github.io\/d3...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e图\x3c\/h1\x3e\n\x3cblockquote\x3e什么是图？\x3c\/blockquote\x3e\n\x3cp\x3e图是一种复杂的非线性结构。\x3c\/p\x3e\n\x3cp\x3e在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；\x3c\/p\x3e\n\x3cp\x3e在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(parent node)及下一层的多个元素(孩子节点)相关；\x3c\/p\x3e\n\x3cp\x3e而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e无向图 和 有向图\x3c\/h2\x3e\n\x3cp\x3e相关基础戳\x3ca href=\x22http:\/\/www.cnblogs.com\/mcgrady\/archive\/2013\/09\/23\/3335847.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e有权图 和 无权图\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTNKF?w=1406\x26amp;h=616\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTNKF?w=1406\x26amp;h=616\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTNKN?w=1276\x26amp;h=643\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTNKN?w=1276\x26amp;h=643\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e顶点的度\x3c\/h2\x3e\n\x3cp\x3e对于\x3cstrong\x3e无向图\x3c\/strong\x3e，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V3的度D(V3)=3\x3c\/p\x3e\n\x3cp\x3e对于\x3cstrong\x3e有向图\x3c\/strong\x3e，顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，顶点V1的入度ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1)\x2bOD(V1)=1\x2b2=3\x3c\/p\x3e\n\x3cp\x3e记住，不管是无向图还是有向图，顶点数n，边数e和顶点的度数有如下关系：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTrBT?w=88\x26amp;h=62\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTrBT?w=88\x26amp;h=62\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e因此，就拿有向图(b)来举例，由公式可以得到图G的边数\x3ccode\x3ee=(D(V1)\x2bD(V2)\x2bD(V3))\/2=(3\x2b2\x2b3)\/2=4\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTrCv?w=202\x26amp;h=180\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTrCv?w=202\x26amp;h=180\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e路径、路径长度和回路\x3c\/h2\x3e\n\x3cp\x3e路径，比如在无向图G中，存在一个顶点序列Vp,Vi1,Vi2,Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…,(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。\x3c\/p\x3e\n\x3cp\x3e一系列顶点构成路径，路径中所有顶点都由边连接。\x3c\/p\x3e\n\x3cp\x3e路径长度，是指一条路径上经过的边的数量。\x3c\/p\x3e\n\x3cp\x3e回路，指一条路径的起点和终点为同一个顶点。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e用图对现实中的系统建模\x3c\/h1\x3e\n\x3cblockquote\x3e可以用图对现实中许多系统建模。\x3c\/blockquote\x3e\n\x3cp\x3e比如对交通流量建模，顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e任何运输系统都可以用图来建模。\x3c\/strong\x3e比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。\x3c\/p\x3e\n\x3cp\x3e包含局域网和广域网（如互联网）在内的计算机网络，同样经常用图来建模。\x3c\/p\x3e\n\x3cp\x3e另一个可以用图来建模的实现系统是消费市场，顶点可以用来表示供应商和消费者。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3e图的创建和遍历\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e图的两种存储结构（表示图）\x3c\/h2\x3e\n\x3cblockquote\x3e乍看起来，图和树或者二叉树很像，我们可能会尝试用树的方式来创建一个图类，用节点来表示每个顶点。但这种情况下，如果用基于对象的方式去处理就会有问题，因为图可能增长到非常大。 用对象来表示图很快会变得效率低下，所以我们要考虑表示顶点或边的其他方案。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e表示顶点\x3c\/h3\x3e\n\x3cp\x3e创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/Vertex 类\n\nfunction Vertex (label wasVisited) {\n  this.label = label;\n  this.wasVisited = wasVisited;\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/Vertex 类\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVertex\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(label wasVisited)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.label = label;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wasVisited = wasVisited;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将所有顶点保存到数组中，在图类里，可以通过它们在数组中位置引用它们。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e表示边\x3c\/h3\x3e\n\x3cp\x3e图的实际信息都保存在边上，因为它们描述了图的结构。我们容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。\x3c\/p\x3e\n\x3cp\x3e我们将表示图的边的方法称为\x3ccode\x3e邻接表\x3c\/code\x3e 或者邻接表数组。\x3c\/p\x3e\n\x3cp\x3e这种方法将边储存为\x3ccode\x3e由顶点的相邻顶点列表构成的数组\x3c\/code\x3e，并以此顶点作为索引。\x3c\/p\x3e\n\x3cp\x3e当我们在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e邻接矩阵\x3c\/strong\x3e\x3cp\x3e原理就是用两个数组，一个数组保存顶点集，一个数组保存边集。下面的算法实现里边我们也是采用这种存储结构。如下图所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTrFU?w=291\x26amp;h=86\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTrFU?w=291\x26amp;h=86\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e邻接表\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e构建图\x3c\/h2\x3e\n\x3cp\x3e确定了如何在代码中表图之后，构建一个表示图的类就容易了，下面是一个Graph类的定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Graph (v) {\n  this.vertices = v;\n  this.edges = 0;\n  this.adj = [];\n  for (var i = 0; i \x3c this.vertices; \x2b\x2bi) {\n    this.adj[i] = [];\n    this.adj[i].push(\x26quot;\x26quot;);\n  }\n  this.addEdge = addEdge;\n  this.toString = toString;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction Graph (v) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices = v;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i] = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i].push(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addEdge = addEdge;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.toString = toString;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个类会记录一个图表示了多少条边，并使用一个长度与图的顶点数相同的数组来记录顶点数量。\x3cbr\x3e通过for循环为数组中的每个元素添加一个子数组来储存所有的相邻顶点，并将所有元素初始化为空字符串。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/addEdge()  函数定义如下\n function addEdge(v,w) {\n  this.adj[v].push(w);\n  this.adj[w].push(v);\n  this.edges\x2b\x2b;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/addEdge()  函数定义如下\x3c\/span\x3e\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddEdge\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(v,w)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v].push(w);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[w].push(v);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges\x2b\x2b;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当调用这个函数并传入顶点A 和 B 时，函数会先查找顶点A ，函数会先查找A的邻接表，将顶点B添加到列表中，然后再查找顶点B的邻接表，将顶点A加入列表。最后，这个函数会将边数加 1.\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eshowGraph()\x3c\/code\x3e 函数会通过打印所有顶点及其相邻顶点列表的方式来显示图：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function showGraph() {\n  for (var i = 0 ; i \x3c this.vertices; \x2b\x2bi ) {\n  putstr(i \x2b \x26quot;-\x3e\x26quot;);\n      for (var j  = 0; j \x3c this.vertices; \x2b\x2bj) {\n        if(this.adj[i][j] != undefined)\n          putstr(this.adj[i][j] \x2b \x27 \x27)\n      }\n      \n      print();\n  \n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshowGraph\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi ) {\n  putstr(i \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22-\x26gt;\x22\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j  = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bj) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i][j] != \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)\n          putstr(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i][j] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e)\n      }\n      \n      print();\n  \n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个完整的 \x3ccode\x3eGraph\x3c\/code\x3e 类\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Graph(v) {\n  this.vertices = v ;\n  this.edges = 0;\n  this.adj = [];\n  for(var i = 0 ; i \x3c this.vertices; \x2b\x2bi ){\n    this.adj[i] = [];\n    this.adj[i].push(\x26quot;\x26quot;);\n    }\n  this.addEdge = addEadge;\n  this.showGraph = showGraph;\n}\n\nfunction addEdge(v,w)  {\n  this.adj[v].push(w);\n  this.adj[w].push(v);\n  this.edges\x2b\x2b;\n}\n\nfunction showGraph () {\n  for (var i = 0; i \x3c this.vertices; \x2b\x2bi) {\n  putstr(i \x2b \x26quot; -\x3e \x26quot;);\n  for (var j = 0; j \x3c this.vertices; \x2b\x2bj) {\n    if(this.adj[i][j] != undefined) {\n      putstr(this.adj[i][j] \x2b \x27 \x27);\n    }\n  }\n  print()\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction Graph(v) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices = v ;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi ){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i] = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i].push(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e);\n    }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addEdge = addEadge;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.showGraph = showGraph;\n}\n\nfunction addEdge(v,w)  {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v].push(w);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[w].push(v);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges\x2b\x2b;\n}\n\nfunction showGraph () {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi) {\n  putstr(i \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 -\x26gt; \x22\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bj) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i][j] != undefined) {\n      putstr(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i][j] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e);\n    }\n  }\n  print()\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e图的两种遍历方法\x3c\/h2\x3e\n\x3cp\x3e确定从一个指定的顶点可以到达其他哪些顶点。这是经常对图执行的操作。我们可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。\x3c\/p\x3e\n\x3cp\x3e而图上这些操作是用算法执行的。在图上可以执行以下两种遍历算法用于搜索：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e深度优先搜索遍历\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTChX?w=600\x26amp;h=290\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTChX?w=600\x26amp;h=290\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是：\x3cp\x3ea) 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。\x3c\/p\x3e\n\x3cp\x3eb)然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。\x3c\/p\x3e\n\x3cp\x3ec) 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e图示如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTuM1?w=312\x26amp;h=275\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTuM1?w=312\x26amp;h=275\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e注：红色数字代表遍历的先后顺序，所以图(e)无向图的深度优先遍历的顶点访问序列为：V0，V1，V2，V5，V4，V6，V3，V7，V8\x3c\/p\x3e\n\x3cp\x3e如果采用邻接矩阵存储，则时间复杂度为O(n2)；当采用邻接表时时间复杂度为O(n\x2be)。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e深度优先搜索的\x3ccode\x3e算法\x3c\/code\x3e比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTvbn?w=600\x26amp;h=450\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTvbn?w=600\x26amp;h=450\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e要让该算法运行，需要为Graph类添加一个数组，用来储存已访问过的顶点，将它所有元素的值全部初始化为false。\x3ccode\x3eGraph类\x3c\/code\x3e的代码片段演示了这个新数组及其初始化过程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.marked = [];\nfor(var i = 0; i \x3c this.vertices; \x2b\x2bi) {\n  this.marked[i] = false;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked = [];\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[i] = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们可以开始编写深度优先搜索函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function dfs(v) {\n  this.marked[v] = true;\n  \/\/用于输出的if语句在这里不是必须的\n  if(this.adj[v] != undefined)\n    print(\x26quot;Visited vertex: \x26quot; \x2b v)\n  for each(var w in this.adj[v]) {\n   if(!this.marked[w]) {\n     this.dfs(w);\n   }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edfs\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[v] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于输出的if语句在这里不是必须的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v] != \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)\n    print(\x3cspan class=\x22hljs-string\x22\x3e\x22Visited vertex: \x22\x3c\/span\x3e \x2b v)\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eeach\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e w \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]) {\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w]) {\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dfs(w);\n   }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码中用到了print()函数，这样我们可以查看当前正在访问的顶点。当然，dfs()不想要print()也能运行。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e注意\x3c\/strong\x3e 深度优先算法属于盲目搜索，无法保证搜索到的路径为最短路径。\x3c\/blockquote\x3e\n\x3ch4\x3e执行深度优先搜索\x3c\/h4\x3e\n\x3cp\x3e下面是depthFirst() 函数 及完整的Graph类定义\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function Graph(v) {\n  this.vertices = v;\n  this.edges = 0;\n  this.adj = [];\n  for(var i=0;i\x3cthis.vertices;i\x2b\x2b) {\n    this.adj[i] = [];\n    this.adj[i].push(\x26quot;\x26quot;);\n  }\n  this.addEdge = addEdge;\n  this.showGragh = showGragh;\n  this.dfs = dfs;\n  this.marked = [];\n  for(var i=0;i\x3cthis.vertices;i\x2b\x2b){\n  this.marked[i] = false; \n  }\n}\n\nfunction addEdge(v,w) {\n  this.adj[v].push(w);\n  this.adj[w].push(v);\n  this.edges\x2b\x2b;\n}\n\nfunction showGragh() {\n  for(var i = 0;i \x3c this.vertices; \x2b\x2bi) {\n  putstr(i \x2b \x26quot;-\x3e\x26quot;);\n    for(var j=0;j\x3cthis.vertices;\x2b\x2bi) {\n      if(this.adj[i][j] != undefined)\n        putstr(this.add[i][j] \x2b \x27 \x27);\n    }\n    print();\n  }\n}\n\nfunction dfs(v) {\n  this.marked[v] = true;\n  if(this.adj[v]!==undefined){\n  print(\x26quot;Visited vertex: \x26quot; \x2b v);\n  }\n  for each(var w in this.adj[v]) {\n    if(!this.marked[w]) {\n      this.dfs(w)\n    }\n  }\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e function Graph(v) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices = v;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices;i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i] = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i].push(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addEdge = addEdge;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.showGragh = showGragh;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dfs = dfs;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices;i\x2b\x2b){\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[i] = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \n  }\n}\n\nfunction addEdge(v,w) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v].push(w);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[w].push(v);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edges\x2b\x2b;\n}\n\nfunction showGragh() {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices; \x2b\x2bi) {\n  putstr(i \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22-\x26gt;\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;j\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vertices;\x2b\x2bi) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[i][j] != undefined)\n        putstr(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.add[i][j] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e);\n    }\n    print();\n  }\n}\n\nfunction dfs(v) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[v] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]!==undefined){\n  print(\x3cspan class=\x22hljs-string\x22\x3e\x22Visited vertex: \x22\x3c\/span\x3e \x2b v);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e each(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e w \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dfs(w)\n    }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 测试dfs() 函数\nload(\x26quot;Graph.js\x26quot;);\ng = new Gragh(5);\ng.addEdge(0,1);\ng.addEdge(0,2);\ng.addEdge(1,3);\ng.addEdge(2,4);\ng.showGragh();\ng.dfs(0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 测试dfs() 函数\x3c\/span\x3e\nload(\x3cspan class=\x22hljs-string\x22\x3e\x22Graph.js\x22\x3c\/span\x3e);\ng = new Gragh(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\ng.showGragh();\ng.dfs(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上程序的输出结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x220 -\x3e 1 2\n1 -\x3e 0 3\n2 -\x3e 0 4\n3 -\x3e 1\n4 -\x3e 2\n\nVisited vertex: 0 \nVisited vertex: 1\nVisited vertex: 2 \nVisited vertex: 3 \nVisited vertex: 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs tap\x22\x3e\x3ccode\x3e0 -\x26gt;\x3cspan class=\x22hljs-number\x22\x3e 1 \x3c\/span\x3e2\n1 -\x26gt;\x3cspan class=\x22hljs-number\x22\x3e 0 \x3c\/span\x3e3\n2 -\x26gt;\x3cspan class=\x22hljs-number\x22\x3e 0 \x3c\/span\x3e4\n3 -\x26gt; 1\n4 -\x26gt; 2\n\nVisited vertex:\x3cspan class=\x22hljs-number\x22\x3e 0 \x3c\/span\x3e\nVisited vertex: 1\nVisited vertex:\x3cspan class=\x22hljs-number\x22\x3e 2 \x3c\/span\x3e\nVisited vertex:\x3cspan class=\x22hljs-number\x22\x3e 3 \x3c\/span\x3e\nVisited vertex: 4\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e完整示例\x3c\/h4\x3e\n\x3cp\x3e戳\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/28486528\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e广度优先搜索遍历\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTCh7?w=600\x26amp;h=292\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTCh7?w=600\x26amp;h=292\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是：\x3c\/p\x3e\n\x3cp\x3ea) 首先访问出发点Vi\x3c\/p\x3e\n\x3cp\x3eb) 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。\x3c\/p\x3e\n\x3cp\x3ec) 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。\x3cbr\x3e图示如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTwBW?w=455\x26amp;h=356\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTwBW?w=455\x26amp;h=356\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e因此，图(f)采用广义优先搜索遍历以V0为出发点的顶点序列为：V0，V1，V3，V4，V2，V6，V8，V5，V7\x3c\/p\x3e\n\x3cp\x3e如果采用邻接矩阵存储，则时间复杂度为O(n2)，若采用邻接表，则时间复杂度为O(n\x2be)。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下：\x3c\/blockquote\x3e\n\x3col\x3e\n\x3cli\x3e查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中;\x3c\/li\x3e\n\x3cli\x3e从图中取下一个顶点v，添加到已访问的顶点列表\x3c\/li\x3e\n\x3cli\x3e将所有与v相邻的未访问顶点添加到队列。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bfs(s) {\n  var queue = [];\n  this.marked[s] = true;\n  queue.push(s); \/\/ 添加到队尾\n  while (queue.length \x3e 0) {\n    var v =queue.shift(); \/\/从队首移除\n    if(this.adj[v]!= undefined) {\n      print(\x26quot;Visisted  vertex: \x26quot; \x2b v);\n    } \n    for each(var w in this.adj[v]) {\n      if(!this.marked[w]) {\n        this.marked[w] = true;\n        queue.push(w);\n      }\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebfs\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(s)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e queue = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[s] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  queue.push(s); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加到队尾\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (queue.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e v =queue.shift(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/从队首移除\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]!= \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n      print(\x3cspan class=\x22hljs-string\x22\x3e\x22Visisted  vertex: \x22\x3c\/span\x3e \x2b v);\n    } \n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eeach\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e w \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        queue.push(w);\n      }\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行广度优先搜索\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22load(\x26quot;Graph.js\x26quot;);\ng = new Graph(5);\ng.addEdge(0,1);\ng.addEdge(0,2);\ng.addEdge(1,3);\ng.addEdge(2,4);\ng.showGragh();\ng.bfs(0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3eload(\x3cspan class=\x22hljs-string\x22\x3e\x22Graph.js\x22\x3c\/span\x3e);\ng = new Graph(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\ng.showGragh();\ng.bfs(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上程序的输出结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x220 -\x3e 1 2\n1 -\x3e 0 3\n2 -\x3e 0 4\n3 -\x3e 1\n4 -\x3e 2\nVisited vertex: 0\nVisited vertex: 1\nVisited vertex: 2\nVisited vertex: 3\nVisited vertex: 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e -\x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e -\x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e -\x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e -\x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e -\x26gt; \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\nVisited vertex: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nVisited vertex: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\nVisited vertex: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\nVisited vertex: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\nVisited vertex: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于广度优先遍历的应用\x3cbr\x3e-\x26gt; d3中的\x3ccode\x3eeach()\x3c\/code\x3eapi   \x3ca href=\x22http:\/\/devdocs.io\/d3~4\/d3-hierarchy#node_each\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode.each(function)\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e查找最短路径\x3c\/h2\x3e\n\x3cblockquote\x3e图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径.\x3cbr\x3e考虑下面的例子：\x3c\/blockquote\x3e\n\x3cp\x3e假期中，你将在两个星期的时间里游历10个旅游城市，去那里最富盛名的景点（1 个），你希望通过最短路径算法，找出开车游历10个城市行驶的最小历程数。\x3cbr\x3e另一个最短路径问题涉及创建一个计算机网络时的开销，其中包括两台电脑之间传递数据的时间，或者两台电脑建立和维护连接的成本。 \x3cbr\x3e最短路径算法可以帮助确定构建此网络的最有效方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e广度优先搜索对应的最短路径\x3c\/h3\x3e\n\x3cp\x3e在执行广度优先搜索时，会自动查找从一个顶点到另一个相邻顶点的最短路径。\x3cbr\x3e例如：要查找从顶点A到顶点D的最短路径，我们首先会查找从A到D是否有任何一条单边路径，接着查找两条边的路径，以此类推。\x3ccode\x3e这正是广度优先搜索的搜索过程，因此我们可以轻松地修改广度优先搜索算法，找出最短路径。\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e确定路径\x3c\/h3\x3e\n\x3cp\x3e要查找最短路径，需要修改广度优先搜索算法来记录从一个顶点到另一个顶点的路径，这需要对Gragh类做一些修改。\x3c\/p\x3e\n\x3cp\x3e首先，需要一个数组来保存从一个顶点到下一个顶点的所有边。我们将这个数组命名为edgeTo。 因为从始至终使用的都是广度优先搜索函数，所以每次都会遇到一个没有标记的顶点，除了对它进行标记外，还会从邻接列表中我们正在搜索的那个顶点添加一条边到这个顶点。\x3cbr\x3e下面是新的\x3ccode\x3ebfs()\x3c\/code\x3e函数 和需要添加到Gragh类的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/将这行添加到Gragh类\nthis.edgeTo = [];\n\n\/\/ bfs函数\n\nfunction bfs(s) {\n  var queque = [];\n  this.marked[s] = true;\n  queue.push(s); \/\/添加到队尾\n  while (queue.length \x3e 0 ) {\n   var v = queque.shift(); \/\/从队首移除\n   if(v == undefined) {\n     print(\x26quot;Visited vertex: \x26quot; \x2b v);\n   }\n   for each(var w in this.adj[v]) {\n     if(!this.marked[w]) {\n       this.edgeTo[w] = v;\n       this.marked[w] = true;\n       queue.push(w);\n     }\n   }\n  }\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/将这行添加到Gragh类\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeTo = [];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ bfs函数\x3c\/span\x3e\n\nfunction bfs(s) {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e queque = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[s] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  queue.push(s); \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加到队尾\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (queue.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) {\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e v = queque.shift(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/从队首移除\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(v == undefined) {\n     print(\x3cspan class=\x22hljs-string\x22\x3e\x22Visited vertex: \x22\x3c\/span\x3e \x2b v);\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e each(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e w \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.adj[v]) {\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w]) {\n       \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeTo[w] = v;\n       \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[w] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n       queue.push(w);\n     }\n   }\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们需要一个函数，用于展示图中连接到不同顶点的路径。函数pathTo() 创建了一个栈，用来储存与指定顶点有共同边的所有顶点。\x3cbr\x3e以下是pathTo()函数的代码，以及一个简单的辅助函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function pathTo(v) {\n  var source = 0;\n  if(!this.hasPathTo(v) {\n    return undefined;\n  }\n  var path = [];\n  for (var i = v; i!= source;i = this.edgeTo[i]) {\n    path.push(i);\n  }\n  path.push(source);\n  return path;\n}\n\nfunction hasPathTo(v) {\n  return this.marked[v];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epathTo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e source = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasPathTo(v) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e path = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = v; i!= source;i = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.edgeTo[i]) {\n    path.push(i);\n  }\n  path.push(source);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehasPathTo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.marked[v];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要确保将以下声明添加到 Graph()构造函数中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.pathTo = pathTo;\nthis.hasPathTo = hasPathTo;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pathTo = pathTo;\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hasPathTo = hasPathTo;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了这个函数，我们要做的就是编写一些客户端代码来显示从源顶点到某个特定顶点的最短路径。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e查找一个顶点的最短路径\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22load(\x26quot;Gragh.js\x26quot;);\ng = new Gragh(5);\ng.bfs(0);\ng.addEdge(0,1);\ng.addEdge(0,2);\ng.addEdge(1,3);\ng.addEdge(2,4);\nvar vartex = 4;\nvar paths = g.pathTo(vertex);\nwhile (paths.length \x3e 0) {\n  id(paths.length \x3e 1) {\n    putstr(paths.pop() \x2b \x27-\x27);\n  }\n  else {\n    putstr(paths.pop());\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3eload(\x3cspan class=\x22hljs-string\x22\x3e\x22Gragh.js\x22\x3c\/span\x3e);\ng = new Gragh(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\ng.bfs(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ng.addEdge(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\nvar vartex = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\nvar paths = g.pathTo(vertex);\nwhile (paths.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  id(paths.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    putstr(paths.pop() \x2b \x27-\x27);\n  }\n  else {\n    putstr(paths.pop());\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上程序输出结果为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x220-2-4\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-4\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是从顶点 0 到顶点4 的最短路径\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e拓扑排序\x3c\/h2\x3e\n\x3cp\x3e在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。\x3cbr\x3e该序列必须满足下面两个条件：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e每个顶点出现且只出现一次\x3c\/li\x3e\n\x3cli\x3e若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3e有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTB6h?w=335\x26amp;h=270\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTB6h?w=335\x26amp;h=270\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。\x3c\/li\x3e\n\x3cli\x3e从图中删除该顶点和所有以它为起点的有向边。\x3c\/li\x3e\n\x3cli\x3e重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTCas?w=544\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTCas?w=544\x26amp;h=350\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e通常，一个有向无环图可以有一个或多个拓扑排序序列。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e拓扑排序的应用\x3c\/h3\x3e\n\x3cblockquote\x3e拓扑排序通常用来“排序”具有依赖关系的任务。它与深度优先搜索BFS类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。\x3cbr\x3e 举一个例子如下图：\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTCum?w=289\x26amp;h=178\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTCum?w=289\x26amp;h=178\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e其拓扑排序可以是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     1,2,3,4,5,7,9,10,11,6,12,8\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e     \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也可以是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     9,10,11,6,1,12,4,2,3,5,7,8\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e     \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边\x26lt;A,B\x26gt;表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/datavis-tech\/graph-data-structure#abc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egraph-data-structure\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader20\x22\x3e其他经典问题\x3c\/h1\x3e\n\x3cul\x3e\n\x3cli\x3e有向图周期检测：\x3c\/li\x3e\n\x3cli\x3e强连通组件图\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e以上不少内容来自《数据结构与算法 javascript》这本书\x3cbr\x3e,感觉讲的很糟糕 ,也有可能是译者的问题。 回头翻一翻其他资料 重新整理下  并且补上相关算法的应用代码\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader21\x22\x3e参考\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Depth-first_search\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDepth-first search\x3c\/a\x3e\x3cbr\x3e[数据结构与算法 javascript描述]\x3cbr\x3e[慕课网 算法与数据结构]\x3cbr\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/mcgrady\/archive\/2013\/09\/23\/3335847.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数据结构和算法系列17 \x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Graph_(abstract_data_type\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGraph (abstract data type)\x3c\/a\x3e)\x3cbr\x3e\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Topological_sorting\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTopological sorting\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.geeksforgeeks.org\/topological-sorting\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTopological Sorting\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/lisonglisonglisong\/article\/details\/45543451\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e拓扑排序（Topological Sorting）\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/25498681\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数据结构与算法 - 图论\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBreadth-first search 广度优先搜索\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>数据结构与算法：图和图算法(一)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010794621">https://segmentfault.com/a/1190000010794621</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qvti0i4zbgr/" target="_blank">https://alili.tech/archive/qvti0i4zbgr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>