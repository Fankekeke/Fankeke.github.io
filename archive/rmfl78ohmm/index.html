<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="AJAX原理与CORS跨域"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>AJAX原理与CORS跨域 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rmfl78ohmm/",
				"appid": "1613049289050283", 
				"title": "AJAX原理与CORS跨域 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2st07fx7663/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0k5q8u3fas6t/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&text=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&text=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&title=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&is_video=false&description=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&title=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&title=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&title=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frmfl78ohmm%2f&title=AJAX%e5%8e%9f%e7%90%86%e4%b8%8eCORS%e8%b7%a8%e5%9f%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">AJAX原理与CORS跨域</h1><div class="meta"><div class="postdate"><time datetime="2018-12-29" itemprop="datePublished">2018-12-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eajax作为前端开发必需的基础能力之一，你可能会使用它，但并不一定懂得其原理，以及更深入的服务器通信相关的知识。在最近两天的整理过程中，看了大量的文章，发现自己的后端能力已经限制自己在网络通信相关的知识领域的探索，还是应该尽快补齐短板。\x3c\/p\x3e\n\x3cp\x3e下面我们来聊一聊\x3ccode\x3eajax\x3c\/code\x3e相关的东西，包括\x3ccode\x3exhr\/xdr\/ajax\/cors\/http\x3c\/code\x3e的一部分内容，其中会抛弃一些被弃用的历史包袱，如IE6\/7等。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eAjax的出现\x3c\/h2\x3e\n\x3cp\x3e2005年，\x3ccode\x3eJesse James Garrett\x3c\/code\x3e提出了Ajax的技术，其全称为\x3ccode\x3eAsynchronous Javascript and XML\x3c\/code\x3e，Ajax的核心是\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象，简称\x3ccode\x3eXHR\x3c\/code\x3e，它用于使浏览器向服务器请求额外的数据而不卸载页面，极大的提高了用户体验。在此之前，其实这种技术已经存在并被一些人实现，但并没有流行也没有被浏览器支持。不过在此之后，IE5第一次引入\x3ccode\x3eXHR\x3c\/code\x3e对象，并支持\x3ccode\x3eajax\x3c\/code\x3e技术，后续被所有浏览器支持。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\n\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象和请求\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eXHR\x3c\/code\x3e是一个API，为客户端提供服务端和客户端之间通信的功能，并且不会刷新页面。它并不仅仅能取回XML类型的数据，而能取回所有类型的数据，除了http协议，还支持file和ftp协议。我们可以通过其构造函数来创建一个新的\x3ccode\x3eXHR\x3c\/code\x3e对象，这个操作需要在其它所有操作之前完成:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eXMLHttpRequest\x3c\/span\x3e();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过控制台我们可以很方便看到\x3ccode\x3eXHR\x3c\/code\x3e的原型链：\x3ccode\x3eObject -\x26gt; EventTarget -\x26gt; XMLHttpRequestEventTarget -\x26gt; XMLHttpRequest\x3c\/code\x3e。它拥有原型链上和本身的方法和属性，现在看下我们常用的方法：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWx8o?w=815\x26amp;h=608\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWx8o?w=815\x26amp;h=608\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们解释下它的几个主要方法，我们在创建了新的xhr对象之后，首先要调用它的\x3ccode\x3eopen()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 第一个参数可以为get\/post等，表示该请求的类型\n\/\/ 第二个参数是请求的url，可以为相对路径或绝对路径\n\/\/ 第三个参数代表是否异步，为true时异步，为false时同步\n\/\/ 第四五个参数为可选的授权使用的参数，因为安全性不推荐明文使用\nxhr.open(\x27get\x27, \x27example.php\x27, true, username, password);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一个参数可以为get\/post等，表示该请求的类型\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二个参数是请求的url，可以为相对路径或绝对路径\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第三个参数代表是否异步，为true时异步，为false时同步\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第四五个参数为可选的授权使用的参数，因为安全性不推荐明文使用\x3c\/span\x3e\nxhr.\x3cspan class=\x22hljs-keyword\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27example.php\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, username, password);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这里受同源策略的影响，当第二个参数url跨域的时候会被浏览器报安全错误。同源策略指的是当前页面和目标url协议、域名和端口均相同。后面也会讲到，除IE之外的浏览器通过XHR对象实现跨域请求，只需将url设置为绝对url即可。\x3c\/p\x3e\n\x3cp\x3e当初始化请求完成后，我们调用\x3ccode\x3esend()\x3c\/code\x3e方法发送请求：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var data = new FormData();\ndata.append(\x27name\x27, \x27Nicholas\x27);\n\/\/ 接受一个请求主体发送的数据，如果不需要，传入null\nxhr.send(data);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = new \x3cspan class=\x22hljs-type\x22\x3eFormData\x3c\/span\x3e();\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.append(\x27\x3cspan class=\x22hljs-title\x22\x3ename\x27\x3c\/span\x3e, \x27\x3cspan class=\x22hljs-type\x22\x3eNicholas\x3c\/span\x3e\x27);\x3c\/span\x3e\n\/\/ 接受一个请求主体发送的数据，如果不需要，传入null\n\x3cspan class=\x22hljs-title\x22\x3exhr\x3c\/span\x3e.send(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当请求的类型为\x3ccode\x3eget\/head\x3c\/code\x3e时，send()的参数会被忽略并置为null，send()传递的参数会影响到我们请求的头部\x3ccode\x3econtent-type\x3c\/code\x3e的默认值，该字段代表返回的资源内容的类型，用于浏览器处理，如果没有设置或在一些场景下，浏览器会进行MIME嗅探来确定怎么处理返回的资源。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eXHR2级\x3c\/code\x3e中定义了\x3ccode\x3eFormData\x3c\/code\x3e数据，用于常见的类表单数据序列化：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 直接传入表单id\nvar data = new FormData(document.getElementById(\x27user-form\x27));\n\n\/\/ 创建类表单数据\nvar data = new FormData();\ndata.append(\x27name\x27, \x27Nicholas\x27);\n\n\/\/ `FormData`可以直接被send()调用，会自动修改xhr的content-type头部\nxhr.send(data);\n\n\/\/ 请求头部的content-type: multipart\/form-data; boundary=----WebKitFormBoundaryjn3q2KKRYrEH55Vz\n\n\/\/ 请求的上传数据 Request Payload:\n------WebKitFormBoundaryjn3q2KKRYrEH55Vz\nContent-Disposition: form-data; name=\x26quot;name\x26quot;\n\nNicholas\n------WebKitFormBoundaryjn3q2KKRYrEH55Vz--\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\/\/ 直接传入表单id\n\x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = new \x3cspan class=\x22hljs-type\x22\x3eFormData\x3c\/span\x3e(\x3cspan class=\x22hljs-title\x22\x3edocument\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3egetElementById\x3c\/span\x3e(\x27\x3cspan class=\x22hljs-title\x22\x3euser\x3c\/span\x3e-\x3cspan class=\x22hljs-title\x22\x3eform\x27\x3c\/span\x3e));\x3c\/span\x3e\n\n\/\/ 创建类表单数据\n\x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = new \x3cspan class=\x22hljs-type\x22\x3eFormData\x3c\/span\x3e();\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.append(\x27\x3cspan class=\x22hljs-title\x22\x3ename\x27\x3c\/span\x3e, \x27\x3cspan class=\x22hljs-type\x22\x3eNicholas\x3c\/span\x3e\x27);\x3c\/span\x3e\n\n\/\/ `\x3cspan class=\x22hljs-type\x22\x3eFormData\x3c\/span\x3e`可以直接被send()调用，会自动修改xhr的content-\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e头部\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3exhr\x3c\/span\x3e.send(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\x3c\/span\x3e\n\n\/\/ 请求头部的content-\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: multipart\/form-\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e; boundary=\x3cspan class=\x22hljs-comment\x22\x3e----WebKitFormBoundaryjn3q2KKRYrEH55Vz\x3c\/span\x3e\x3c\/span\x3e\n\n\/\/ 请求的上传数据 \x3cspan class=\x22hljs-type\x22\x3eRequest\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ePayload\x3c\/span\x3e:\n\x3cspan class=\x22hljs-comment\x22\x3e------WebKitFormBoundaryjn3q2KKRYrEH55Vz\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eContent\x3c\/span\x3e-\x3cspan class=\x22hljs-type\x22\x3eDisposition\x3c\/span\x3e: form-\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e; name=\x22name\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-type\x22\x3eNicholas\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e------WebKitFormBoundaryjn3q2KKRYrEH55Vz--\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eFormData\x3c\/code\x3e常用的方法有\x3ccode\x3eappend\/delete\/entries\/forEach\/get\/getAll\/has\/keys\/set\/values\x3c\/code\x3e，都是常用的跟数组类似的方法，不再解释。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e请求方法\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eGET\x3c\/code\x3e是最常见的请求类型，可以将查询字符串参数添加到URL尾部，对XHR而言，该查询字符串必须经过正确编码，每个键值对必须使用\x3ccode\x3eencodeURIComponent()\x3c\/code\x3e进行编码，键值对之间由\x3ccode\x3e\x26amp;\x3c\/code\x3e分割：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 封装序列化键值对\nfunction addURLParam(url, name, value) {\n    url \x2b= (url.indexOf(\x27?\x27) === -1 ? \x27?\x27 : \x27\x26amp;\x27;\n    url \x2b= encodeURIComponent(name) \x2b \x27=\x27 \x2b encodeURIComponent(value);\n    return url;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 封装序列化键值对\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddURLParam\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl, name, value\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e \x2b= (\x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27?\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27?\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27\x26amp;\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e \x2b= \x3cspan class=\x22hljs-built_in\x22\x3eencodeURIComponent\x3c\/span\x3e(name) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27=\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eencodeURIComponent\x3c\/span\x3e(value);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ePOST\x3c\/code\x3e请求使用频率仅次于\x3ccode\x3eGET\x3c\/code\x3e请求，通常发送较多数据，且格式不限，数据传递给\x3ccode\x3esend()\x3c\/code\x3e作为参数。\x3c\/p\x3e\n\x3cp\x3eHTTP一共规定了九种请求方法，每一个动词代表不同的语义，但是常用的只有上面两种：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 - OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送\x27*\x27的请求来测试服务器的功能性。 \n - HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 \n - GET：向特定的资源发出请求。 \n - POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和\/或已有资源的修改。 \n - PUT：向指定资源位置上传其最新内容。 \n - DELETE：请求服务器删除Request-URI所标识的资源。 \n - TRACE：回显服务器收到的请求，主要用于测试或诊断。 \n - CONNECT：HTTP\/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n - PATCH: 用于对资源进行部分修改\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e -\x3cspan class=\x22ruby\x22\x3e OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e的请求来测试服务器的功能性。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e GET：向特定的资源发出请求。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和\/或已有资源的修改。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e PUT：向指定资源位置上传其最新内容。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e DELETE：请求服务器删除Request-URI所标识的资源。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e TRACE：回显服务器收到的请求，主要用于测试或诊断。 \n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e CONNECT：HTTP\/\x3cspan class=\x22hljs-number\x22\x3e1.1\x3c\/span\x3e协议中预留给能够将连接改为管道方式的代理服务器。\n\x3c\/span\x3e -\x3cspan class=\x22ruby\x22\x3e \x3cspan class=\x22hljs-symbol\x22\x3ePATCH:\x3c\/span\x3e 用于对资源进行部分修改\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eHTTP头部信息\x3c\/h3\x3e\n\x3cp\x3e每个HTTP请求和响应都带有头部信息，xhr对象允许我们操作部分头部信息。我们可以通过\x3ccode\x3exhr.setRequestHeader()\x3c\/code\x3e方法来设置自定义的头部信息或者修改浏览器默认的正常头部信息。常用的请求头部：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 下面的实例是从我本地的一次请求取出的\n\nAccept: 浏览器能够处理的内容类型。\/\/ *\/*\nAccept-Charset: 浏览器能够显示的字符集。\/\/ 未取到\nAccept-Encoding: 浏览器能够处理的压缩编码。\/\/ gzip,deflate\nAccept-Language: 浏览器当前设置的语言。\/\/ zh-CN,zh;q=0.8,en;q=0.6\nConnection: 浏览器与服务器之间连接的类型。\/\/ keep-alive\nCookie: 当前页面设置的任意Cookie。\/\/ JlogDataSource=jomodb\nHost: 发出请求的页面所在域。\/\/ gzhxy-cdn-oss-06.gzhxy.baidu.com:8090\nReferer: 发出请求的页面URI。\/\/ http:\/\/gzhxy-cdn-oss-06.gzhxy.baidu.com:8090\/jomocha\/index.php?r=tools\/offline\/index\nUser-Agent: 浏览器的用户代理字符串。\/\/ Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/61.0.3163.100 Safari\/537.36\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面的实例是从我本地的一次请求取出的\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-attribute\x22\x3eAccept\x3c\/span\x3e: 浏览器能够处理的内容类型。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ *\/*\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eAccept-Charset\x3c\/span\x3e: 浏览器能够显示的字符集。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 未取到\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eAccept-Encoding\x3c\/span\x3e: 浏览器能够处理的压缩编码。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ gzip,deflate\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eAccept-Language\x3c\/span\x3e: 浏览器当前设置的语言。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ zh-CN,zh;q=0.8,en;q=0.6\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eConnection\x3c\/span\x3e: 浏览器与服务器之间连接的类型。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep-alive\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eCookie\x3c\/span\x3e: 当前页面设置的任意Cookie。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ JlogDataSource=jomodb\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eHost\x3c\/span\x3e: 发出请求的页面所在域。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ gzhxy-cdn-oss-06.gzhxy.baidu.com:8090\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eReferer\x3c\/span\x3e: 发出请求的页面URI。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/gzhxy-cdn-oss-06.gzhxy.baidu.com:8090\/jomocha\/index.php?r=tools\/offline\/index\x3c\/span\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3eUser-Agent\x3c\/span\x3e: 浏览器的用户代理字符串。\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/61.0.3163.100 Safari\/537.36\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们一般不修改浏览器正常的头部信息，可能会影响到服务器响应。如果需要可以通过\x3ccode\x3exhr.setRequestHeader()\x3c\/code\x3e进行修改：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 传入头部键值对，键值不区分大小写，如果多次设置，则追加\n\/\/ 此时请求头部的content-type: application\/json, text\/html\nxhr.setRequestHeader(\x27content-type\x27, \x27application\/json\x27);\nxhr.setRequestHeader(\x27content-type\x27, \x27application\/json\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传入头部键值对，键值不区分大小写，如果多次设置，则追加\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此时请求头部的content-type: application\/json, text\/html\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3exhr\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setRequestHeader\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27content-type\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-selector-tag\x22\x3exhr\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setRequestHeader\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27content-type\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e设置头部信息需要在\x3ccode\x3eopen()\x3c\/code\x3e之后，\x3ccode\x3esend()\x3c\/code\x3e之前进行调用。响应的头部信息在后端处理，不在此处讲解。有一部分请求头部信息\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Glossary\/%E7%A6%81%E6%AD%A2%E4%BF%AE%E6%94%B9%E7%9A%84%E6%B6%88%E6%81%AF%E9%A6%96%E9%83%A8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不允许设置\x3c\/a\x3e，如\x3ccode\x3eAccept-Encoding, Cookie\x3c\/code\x3e等。\x3c\/p\x3e\n\x3cp\x3e在请求返回后，我们可以获取到响应头部：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取指定项的响应头\nxhr.getResponseHeader(\x27content-type\x27); \/\/ application\/json;charset=utf-8\n\/\/ 获取所有的响应头部信息\nxhr.getAllResponseHeaders();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取指定项的响应头\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3exhr\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.getResponseHeader\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27content-type\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ application\/json;charset=utf-8\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取所有的响应头部信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3exhr\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.getAllResponseHeaders\x3c\/span\x3e();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里简单说下\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/HTTP\/Headers\/Content-Type\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3econtent-type\x3c\/a\x3e值，指的是请求和响应的HTTP内容类型，影响到服务器和浏览器对数据的处理方式，默认为\x3ccode\x3etext\/html\x3c\/code\x3e，常用的如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 包含资源类型，字符编码， 边界字符串三个参数，可选填\n\ntext\/html;charset=utf-8    \/\/ html标签文本\ntext\/plain    \/\/ 纯文本\ntext\/css    \/\/ css文件\ntext\/javascript    \/\/ js文件\n\/\/ 普通的表单数据，可以通过表单标签的enctype属性指定\napplication\/x-www-form-urlencode\n\/\/ 发送文件的POST包，包过大需要分片时使用`boundary`属性分割数据作边界\nmultipart\/form-data; boundary=something\n\/\/ json数据格式\napplication\/json\n\/\/ xml类型的标记语言\napplication\/xml\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 包含资源类型，字符编码， 边界字符串三个参数，可选填\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\/html;charset=utf\x3cspan class=\x22hljs-number\x22\x3e-8\x3c\/span\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ html标签文本\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\/plain    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 纯文本\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\/css    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ css文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\/javascript    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ js文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通的表单数据，可以通过表单标签的enctype属性指定\x3c\/span\x3e\napplication\/x-www-form-urlencode\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发送文件的POST包，包过大需要分片时使用`boundary`属性分割数据作边界\x3c\/span\x3e\nmultipart\/form-data; \x3cspan class=\x22hljs-keyword\x22\x3eboundary\x3c\/span\x3e=something\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ json数据格式\x3c\/span\x3e\napplication\/json\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ xml类型的标记语言\x3c\/span\x3e\napplication\/xml\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e\n\x3ccode\x3eXHR\x3c\/code\x3e对象的响应\x3c\/h2\x3e\n\x3cp\x3e我们现在对请求的发起很了解了，接着看下如何拿到响应数据。如果我们给\x3ccode\x3eopen()\x3c\/code\x3e传递的第三个参数是\x3ccode\x3etrue\x3c\/code\x3e，则代表为同步请求，那么js会被阻塞直到拿到响应，而如果为\x3ccode\x3efalse\x3c\/code\x3e则是异步请求，我们只需要绑定\x3ccode\x3exhr.onreadystatechange()\x3c\/code\x3e事件监听响应即可。最上面的图已经说明了\x3ccode\x3ereadystate\x3c\/code\x3e的值含义，所以我们可以：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ xhr v1 的写法，检测readystate的值，为4则说明数据准备完毕，需要在open()前定义\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4） {\n        if (xhr.status === 200 || xhr.status === 304) {\n            console.log(xhr.responseText);\n        } else {\n            console.log(xhr.statusText);\n        }\n    }   \n}\n\n\/\/ xhr v2 的写法，onload()事件说明数据准备完毕\nxhr.onload = function () {\n    if (xhr.status === 200 || xhr.status === 304) {\n        console.log(xhr.responseText);\n    } else {\n        console.log(xhr.statusText);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3e\/\/ xhr v1 的写法，检测readystate的值，为\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e则说明数据准备完毕，需要在open()前定义\nxhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (xhr.readyState === \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e） {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (xhr.\x3cspan class=\x22hljs-keyword\x22\x3estatus\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e || xhr.\x3cspan class=\x22hljs-keyword\x22\x3estatus\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n            console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(xhr.responseText);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(xhr.statusText);\n        }\n    }   \n}\n\n\/\/ xhr v2 的写法，onload()事件说明数据准备完毕\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (xhr.\x3cspan class=\x22hljs-keyword\x22\x3estatus\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e || xhr.\x3cspan class=\x22hljs-keyword\x22\x3estatus\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(xhr.responseText);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(xhr.statusText);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3exhr\x3c\/code\x3e对象的响应数据中包含几个属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22response    \/\/ 响应的数据\nresponseURL    \/\/ 发起响应的URL\nresponseType    \/\/ 响应的类型，用于浏览器强行重置响应数据的类型\nresponseText    \/\/ 如果为普通文本，则在这显示\nresponseXML    \/\/ 如果为xml类型文本，在这里显示\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3eresponse    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 响应的数据\x3c\/span\x3e\nresponseURL    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发起响应的URL\x3c\/span\x3e\nresponseType    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 响应的类型，用于浏览器强行重置响应数据的类型\x3c\/span\x3e\nresponseText    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果为普通文本，则在这显示\x3c\/span\x3e\nresponseXML    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果为xml类型文本，在这里显示\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e数据会出现在\x3ccode\x3eresponseText\/responseXML\x3c\/code\x3e中的哪一个，取决于服务器返回的\x3ccode\x3eMIME\x3c\/code\x3e类型，当然我们也有一些方式在浏览器端设置如何处理这些数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ xhr v1 的写法，设置响应资源的处理类型\nxhr.overrideMimeType(\x27text\/xml\x27);\n\n\/\/ xhr v2 的写法， 可用值为 arraybuffer\/blob\/document\/json\/text\nxhr.responseType = \x27document\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e xhr v1 的写法，设置响应资源的处理类型\nxhr.overrideMimeType(\x3cspan class=\x22hljs-string\x22\x3e\x27text\/xml\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e xhr v2 的写法， 可用值为 arraybuffer\x3cspan class=\x22hljs-regexp\x22\x3e\/blob\/\x3c\/span\x3edocument\x3cspan class=\x22hljs-regexp\x22\x3e\/json\/\x3c\/span\x3etext\nxhr.responseType = \x3cspan class=\x22hljs-string\x22\x3e\x27document\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e响应数据相关的属性默认为\x3ccode\x3enull \/ \x27\x27\x3c\/code\x3e，只有当请求完成并被正确解析的时候才会有值，取决于responseType的值，来确定\x3ccode\x3eresponse\/responseText\/responseXML\x3c\/code\x3e谁最终具有值。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e\n\x3ccode\x3eXHR\x3c\/code\x3e的高级功能\x3c\/h2\x3e\n\x3cp\x3e在\x3ccode\x3exhr v2\x3c\/code\x3e里提供了超时和进度事件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e超时\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.timeout = 1000;    \/\/ 1分钟，单位为ms\nxhr.ontimeout = function () {};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3exhr.timeout = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1分钟，单位为ms\x3c\/span\x3e\nxhr.ontimeout = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在请求\x3ccode\x3esend()\x3c\/code\x3e之后开始计时，等待\x3ccode\x3etimeout\x3c\/code\x3e时长后，如果没有收到响应，则触发\x3ccode\x3eontimeout()\x3c\/code\x3e事件，超时会将\x3ccode\x3ereadystate=4\x3c\/code\x3e，直接触发\x3ccode\x3eonreadystatechange()\x3c\/code\x3e事件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e请求进度\x3c\/h3\x3e\n\x3cp\x3e像上图所示，\x3ccode\x3exhr v2\x3c\/code\x3e定义了不同的进度事件：\x3ccode\x3eloadstart\/progress\/error\/abort\/load\/loadend\x3c\/code\x3e，这其中我们已经说过了\x3ccode\x3eonload()\x3c\/code\x3e事件为内容加载完成可用。现在说一下\x3ccode\x3eonprogress()\x3c\/code\x3e进度事件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.onprogress = function (event) {\n    if (event.lengthComputable) {\n        console.log(event.loaded \/ event.total);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode\x3exhr.onprogress = function (\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.lengthComputable) {\n        console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.loaded \/ \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.total);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该事件会接收一个\x3ccode\x3eevent\x3c\/code\x3e对象，其\x3ccode\x3etarget\x3c\/code\x3e属性为该xhr对象，\x3ccode\x3elengthComputable\x3c\/code\x3e属性为\x3ccode\x3etotal size\x3c\/code\x3e是否已知，即是否可用进度信息，\x3ccode\x3eloaded\x3c\/code\x3e属性为已经接收的字节数，\x3ccode\x3etotal\x3c\/code\x3e为总字节数。该事件会在数据接收期间不断触发，但间隔不确定。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e跨域\x3ccode\x3eCORS\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e提到\x3ccode\x3eXHR\x3c\/code\x3e对象，我们就会讲到跨域问题，它是为了预防某些恶意行为的安全策略，但有时候我们需要跨域来实现某些功能。需要注意的是跨域并不仅仅是前端单方面的事情，它需要后端代码进行配合，我们只是通过一些方式跳过了浏览器的阻拦。\x3c\/p\x3e\n\x3cp\x3e对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/HTTP\/Access_control_CORS\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e预检请求\x3c\/a\x3e（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eCORS(Cross-Origin Resource Sharing, 跨域资源共享)\x3c\/code\x3e的思想是浏览器和服务端通过头部信息来进行沟通确认是否给予响应。如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Origin: http:\/\/www.baidu.com    \/\/ 浏览器的头部信息\n\n\/\/ 如果服务端认可这个域名的跨域请求，如下设置就可跨域访问资源\nAccess-Control-Allow-Origin: http:\/\/www.baidu.com\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3eOrigin:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ehttp:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/www.baidu.com    \/\/ 浏览器的头部信息\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果服务端认可这个域名的跨域请求，如下设置就可跨域访问资源\x3c\/span\x3e\nAccess-Control-Allow-\x3cspan class=\x22hljs-string\x22\x3eOrigin:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ehttp:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/www.baidu.com\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上就可以实现最简单的跨域访问，但是此时不能携带任何的\x3ccode\x3ecookie\x3c\/code\x3e，如果我们需要传递\x3ccode\x3ecookie\x3c\/code\x3e进行身份认证，需要设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.withCredentials = true;    \/\/ 浏览器端\nAccess-Control-Allow-Credentials: true;    \/\/ 服务端\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3exhr.withCredentials = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 浏览器端\x3c\/span\x3e\nAccess-Control-Allow-\x3cspan class=\x22hljs-string\x22\x3eCredentials:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 服务端\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们就可以传递认证信息了，但如果允许认证，\x3ccode\x3eAccess-Control-Allow-Origin\x3c\/code\x3e不能设置为\x3ccode\x3e*\x3c\/code\x3e，而一定是具体的域名信息。\x3c\/p\x3e\n\x3cp\x3e现在的浏览器都对CORS有了实现，如IE使用\x3ccode\x3eXDomainRequest\x3c\/code\x3e对象，其它浏览器使用\x3ccode\x3eXMLHttpRequest\x3c\/code\x3e对象。所以在此之前有很多奇技淫巧，如通过\x3ccode\x3ejsonp\/图像 Ping\x3c\/code\x3e方法都不再详述，而且其都需要服务端配合并且有很多局限性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eIE实现： \x3ccode\x3eXDomainRequest\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xdr = new XDomainRequest();\nxdr.open(\x27get\x27, \x27http:\/\/www.site.com\/page\x27);\nxdr.send(null);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xdr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eXDomainRequest\x3c\/span\x3e();\nxdr.open(\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/www.site.com\/page\x27\x3c\/span\x3e);\nxdr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eXDR区别于普通XHR：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e不能传输cookie\x3c\/li\x3e\n\x3cli\x3e只能设置请求头部的content-type\x3c\/li\x3e\n\x3cli\x3e不能访问响应头部信息\x3c\/li\x3e\n\x3cli\x3e只支持get\/post方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通过这些区别可以阻止一部分的\x3ccode\x3eCSRF(Cross-Site Request Forgery，跨站点请求伪造)\x3c\/code\x3e和\x3ccode\x3eXSS(Cross-Site Scripting，跨站点脚本)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eXDR与XHR的使用上非常相似，区别有几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eopen()方法只接受两个参数，请求类型和URL\x3c\/li\x3e\n\x3cli\x3e只允许异步请求\x3c\/li\x3e\n\x3cli\x3e响应完成触发onload()事件，但我们只能访问responseText原始文本，并且无法获取响应的status.\x3c\/li\x3e\n\x3cli\x3e异常事件都会触发error事件，并且无错误信息可用。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e其余浏览器实现： \x3ccode\x3eXMLHttpRequest\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e其余浏览器通过XHR对象直接实现了CORS，你只需要做的就是\x3ccode\x3eopen()\x3c\/code\x3e方法中传入一个绝对URL。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.open(\x27get\x27, \x27http:\/\/www.site.com\/page\x27, true);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3exhr.\x3cspan class=\x22hljs-keyword\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/www.site.com\/page\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相对于普通的XHR对象，\x3ccode\x3eCORS-XHR\x3c\/code\x3e依然有部分限制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e不能使用setRequestHeader()定义头部\x3c\/li\x3e\n\x3cli\x3e不能传递cookie\x3c\/li\x3e\n\x3cli\x3e调用getAllResponseHeaders()，结果为空\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e其余跨域方法\x3c\/h3\x3e\n\x3cp\x3e上面的两种方法已经很成熟了，但是仍然有一部分方法可以跨域，比如\x3ccode\x3e图像Ping\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var img = new Image();\nimg.onload = img.onerror = function () {\n    console.log(\x27done\x27);\n}\nimg.src = \x27http:\/\/www.site.com\/test?name=Nicholas\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e img = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image();\nimg.onload = img.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27done\x27\x3c\/span\x3e);\n}\nimg.src = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/www.site.com\/test?name=Nicholas\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式常用于服务端统计广告的点击次数，其缺陷为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e只能是GET请求\x3c\/li\x3e\n\x3cli\x3e单向通信，无法获取响应文本\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外还有\x3ccode\x3eJSONP\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function handleResponse(response) {\n    console.log(response.ip, response.city);\n}\n\nvar script = document.createElement(\x27script\x27);\nscript.src = \x27http:\/\/freegeoip.net\/json?callback=handleResponse\x27;\ndocument.body.insertBefore(script, document.body.firstChild);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleResponse\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(response.ip, response.city);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e script = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27script\x27\x3c\/span\x3e);\nscript.src = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/freegeoip.net\/json?callback=handleResponse\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.insertBefore(script, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.firstChild);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式通过和服务器配合，跨域请求一个js文件并被服务器处理后传回：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22handleResponse({\x27name\x27: \x27Nicholas\x27});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lisp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ehandleResponse({\x27name\x27: \x27Nicholas\x27})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后直接在浏览器调用了该函数，传回的数据被当做response形参进行处理。但它也有一些缺陷：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e访问的方式是请求js，所以如果域名不安全，则很容易被恶意代码直接执行并攻击\x3c\/li\x3e\n\x3cli\x3e无法检测是否错误，因为js不支持这样的接口事件，只能超时判断\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上面两种方式很容易看出，我们在支持CORS之前，使用的方法只不过是采用\x3ccode\x3eimg\/css\/js\x3c\/code\x3e等不受跨域访问限制的对象，变相拿到了响应数据，但都有缺陷，所以如果没有历史包袱，建议采用XDR或XHR对象来实现跨域访问。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3eXHR的兼容性\x3c\/h2\x3e\n\x3cp\x3e我们可以直接到\x3ccode\x3eCan I use\x3c\/code\x3e这个\x3ca href=\x22http:\/\/caniuse.com\/#search=XMLHttpRequest\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e网站\x3c\/a\x3e上查询兼容性问题：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVWCA7?w=2314\x26amp;h=860\x22 src=\x22https:\/\/static.alili.tech\/img\/bVWCA7?w=2314\x26amp;h=860\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e参考资料\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3eMDN - 禁止修改的消息首部：\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Glossary\/%E7%A6%81%E6%AD%A2%E4%BF%AE%E6%94%B9%E7%9A%84%E6%B6%88%E6%81%AF%E9%A6%96%E9%83%A8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e理解HTTP之Content-Type：\x3ca href=\x22http:\/\/homeway.me\/2015\/07\/19\/understand-http-about-content-type\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/homeway.me\/2015\/07\/19\/...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eMDN - Content-Type：\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/HTTP\/Headers\/Content-Type\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eHTTP请求方法：\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/HTTP\/Methods\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eJavascript高级程序设计 第21章（Ajax与Comet）\x3c\/li\x3e\n\x3cli\x3e你真的会使用XHR吗？ \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004322487\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>AJAX原理与CORS跨域</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011549088">https://segmentfault.com/a/1190000011549088</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rmfl78ohmm/" target="_blank">https://alili.tech/archive/rmfl78ohmm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>