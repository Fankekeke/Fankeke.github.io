<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] 探索 Angular 使用 ViewContainerRef 操作 DOM"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] 探索 Angular 使用 ViewContainerRef 操作 DOM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rv0ca6suys/",
				"appid": "1613049289050283", 
				"title": "[译] 探索 Angular 使用 ViewContainerRef 操作 DOM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2a1b5zufrok/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lrls6q2n4h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&text=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&text=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&title=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&is_video=false&description=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&title=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&title=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&title=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frv0ca6suys%2f&title=%5b%e8%af%91%5d%20%e6%8e%a2%e7%b4%a2%20Angular%20%e4%bd%bf%e7%94%a8%20ViewContainerRef%20%e6%93%8d%e4%bd%9c%20DOM"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] 探索 Angular 使用 ViewContainerRef 操作 DOM</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e原文链接：\x3cstrong\x3e\x3ca href=\x22https:\/\/blog.angularindepth.com\/exploring-angular-dom-abstractions-80b3ebcfc02\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExploring Angular DOM manipulation techniques using ViewContainerRef\x3c\/a\x3e\x3c\/strong\x3e\x3cp\x3e如果想深入学习 Angular 如何使用 Renderer 和 View Containers 技术操作 DOM，可以查阅 YouTube 视频 \x3cstrong\x3e\x3ca href=\x22https:\/\/www.youtube.com\/watch?v=qWmqiYDrnDc\x26amp;list=PLVI0Ut22uwY4UC1v5fUvi2RIU4R4jPkba\x26amp;sns=tw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emy talk at NgVikings\x3c\/a\x3e\x3c\/strong\x3e。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e每次我读到 Angular 如何操作 DOM 相关文章时，总会发现这些文章提到 \x3ccode\x3eElementRef\x3c\/code\x3e、\x3ccode\x3eTemplateRef\x3c\/code\x3e、\x3ccode\x3eViewContainerRef\x3c\/code\x3e 和其他的类。尽管这些类在 Angular 官方文档或相关文章会有涉及，但是很少会去描述整体思路，这些类如何一起作用的相关示例也很少，而本文就主要描述这些内容。\x3c\/p\x3e\n\x3cp\x3e如果你来自于 angular.js 世界，很容易明白如何使用 angular.js 操作 DOM。angular.js 会在 \x3ccode\x3elink\x3c\/code\x3e 函数中注入 DOM \x3ccode\x3eelement\x3c\/code\x3e，你可以在组件模板里查询任何节点（node），添加或删除节点（node），修改样式（styles），等等。然而这种方式有个主要缺陷：\x3cstrong\x3e与浏览器平台紧耦合\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e新版本 Angular 需要在不同平台上运行，如 Browser 平台，Mobile 平台或者 Web Worker 平台，所以，就需要在特定平台的 API 和框架接口之间进行一层抽象（abstraction）。Angular 中的这层抽象就包括这些引用类型：\x3ccode\x3eElementRef\x3c\/code\x3e、\x3ccode\x3eTemplateRef\x3c\/code\x3e、\x3ccode\x3eViewRef\x3c\/code\x3e、\x3ccode\x3eComponentRef\x3c\/code\x3e 和 \x3ccode\x3eViewContainerRef\x3c\/code\x3e。本文将详细讲解每一个引用类型（reference type）和该引用类型如何操作 DOM。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e@ViewChild\x3c\/h2\x3e\n\x3cp\x3e在探索 DOM 抽象类前，先了解下如何在组件\/指令中获取这些抽象类。Angular 提供了一种叫做 DOM Query 的技术，主要来源于 \x3ccode\x3e@ViewChild\x3c\/code\x3e 和 \x3ccode\x3e@ViewChildren\x3c\/code\x3e 装饰器（decorators）。两者基本功能相同，唯一区别是 \x3ccode\x3e@ViewChild\x3c\/code\x3e 返回单个引用，\x3ccode\x3e@ViewChildren\x3c\/code\x3e 返回由 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/api\/core\/QueryList\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eQueryList\x3c\/a\x3e\x3c\/strong\x3e 对象包装好的多个引用。本文示例中主要以 \x3ccode\x3eViewChild\x3c\/code\x3e 为例，并且描述时省略 \x3ccode\x3e@\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e通常这两个装饰器与模板引用变量（\x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/guide\/template-syntax#!#ref-vars\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etemplate reference variable\x3c\/a\x3e\x3c\/strong\x3e）一起使用，模板引用变量仅仅是对模板（template）内 DOM 元素命名式引用（a named reference），类似于 \x3ccode\x3ehtml\x3c\/code\x3e 元素的 \x3ccode\x3eid\x3c\/code\x3e 属性。你可以使用模板引用（template reference）来标记一个 DOM 元素，并在组件\/指令类中使用 \x3ccode\x3eViewChild\x3c\/code\x3e 装饰器查询（query）它，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    template: `\n        \x3cspan #tref\x3eI am span\x3c\/span\x3e\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\x26quot;tref\x26quot;, {read: ElementRef}) tref: ElementRef;\n\n    ngAfterViewInit(): void {\n        \/\/ outputs `I am span`\n        console.log(this.tref.nativeElement.textContent);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;span #tref\x26gt;I am span\x26lt;\/span\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAfterViewInit\x3c\/span\x3e \x3c\/span\x3e{\n    @ViewChild(\x3cspan class=\x22hljs-string\x22\x3e\x22tref\x22\x3c\/span\x3e, {\x3cspan class=\x22hljs-attr\x22\x3eread\x3c\/span\x3e: ElementRef}) tref: ElementRef;\n\n    ngAfterViewInit(): \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ outputs `I am span`\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tref.nativeElement.textContent);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eViewChild\x3c\/code\x3e 装饰器基本语法是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@ViewChild([reference from template], {read: [reference type]});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e@ViewChild([reference \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e template], {\x3cspan class=\x22hljs-attr\x22\x3eread\x3c\/span\x3e: [reference type]});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上例中你可以看到，我把 \x3ccode\x3etref\x3c\/code\x3e 作为模板引用名称，并将 \x3ccode\x3eElementRef\x3c\/code\x3e 与该元素联系起来。第二个参数 \x3ccode\x3eread\x3c\/code\x3e 是可选的，因为 Angular 会根据 DOM 元素的类型推断出该引用类型。例如，如果它（#tref）挂载的是类似 \x3ccode\x3espan\x3c\/code\x3e 的简单 html 元素，Angular 返回 \x3ccode\x3eElementRef\x3c\/code\x3e；如果它挂载的是 \x3ccode\x3etemplate\x3c\/code\x3e 元素，Angular 返回 \x3ccode\x3eTemplateRef\x3c\/code\x3e。一些引用类型如 \x3ccode\x3eViewContainerRef\x3c\/code\x3e 就不可以被 Angular 推断出来，所以必须在 \x3ccode\x3eread\x3c\/code\x3e 参数中显式申明。其他的如 \x3ccode\x3eViewRef\x3c\/code\x3e 不可以挂载在 DOM 元素中，所以必须手动在构造函数中编码构造出来。\x3c\/p\x3e\n\x3cp\x3e现在，让我们看看应该如何获取这些引用，一起去探索吧。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eElementRef\x3c\/h2\x3e\n\x3cp\x3e这是最基本的抽象类，如果你查看它的类结构，就发现它只包含所挂载的元素对象，这对访问原生 DOM 元素很有用，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ outputs `I am span`\nconsole.log(this.tref.nativeElement.textContent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ outputs `I am span`\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tref.nativeElement.textContent);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而，\x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/docs\/ts\/latest\/api\/core\/index\/ElementRef-class.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular 团队不鼓励这种写法\x3c\/a\x3e\x3c\/strong\x3e，不但因为这种方式会暴露安全风险，而且还会让你的程序与渲染层（rendering layers）紧耦合，这样就很难在多平台运行你的程序。我认为这个问题并不是使用 \x3ccode\x3enativeElement\x3c\/code\x3e 而是使用特定的 DOM API 造成的，如 \x3ccode\x3etextContent\x3c\/code\x3e。但是后文你会看到，Angular 实现了操作 DOM 的整体思路模型，这样就不再需要低阶 API，如 \x3ccode\x3etextContent\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3eViewChild\x3c\/code\x3e装饰的 DOM 元素会返回 \x3ccode\x3eElementRef\x3c\/code\x3e，但是由于所有组件挂载于自定义 DOM 元素，所有指令作用于 DOM 元素，所以组件和指令都可以通过 DI（Dependency Injection）获取宿主元素的\x3ccode\x3eElementRef\x3c\/code\x3e 对象。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    ...\nexport class SampleComponent{\n      constructor(private hostElement: ElementRef) {\n          \/\/outputs \x3csample\x3e...\x3c\/sample\x3e\n             console.log(this.hostElement.nativeElement.outerHTML);\n      }\n    ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    ...\nexport \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(private hostElement: ElementRef) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/outputs \x26lt;sample\x26gt;...\x26lt;\/sample\x26gt;\x3c\/span\x3e\n             \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hostElement.nativeElement.outerHTML);\n      }\n    ...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以组件通过 DI（Dependency Injection）可以访问到它的宿主元素，但 \x3ccode\x3eViewChild\x3c\/code\x3e 装饰器经常被用来获取模板视图中的 DOM 元素。然而指令却相反，因为指令没有视图模板，所以主要用来获取指令挂载的宿主元素。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eTemplateRef\x3c\/h2\x3e\n\x3cp\x3e对于大部分开发者来说，模板概念很熟悉，就是跨程序视图内一堆 DOM 元素的组合。在 HTML5 引入  \x3cstrong\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en\/docs\/Web\/HTML\/Element\/template\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etemplate\x3c\/a\x3e\x3c\/strong\x3e 标签前，浏览器通过在 \x3ccode\x3escript\x3c\/code\x3e 标签内设置 \x3ccode\x3etype\x3c\/code\x3e 属性来引入模板，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript id=\x26quot;tpl\x26quot; type=\x26quot;text\/template\x26quot;\x3e\n  \x3cspan\x3eI am span in template\x3c\/span\x3e\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;script id=\x3cspan class=\x22hljs-string\x22\x3e\x22tpl\x22\x3c\/span\x3e type=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/template\x22\x3c\/span\x3e\x26gt;\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eI am span in template\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/script\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式不仅有语义缺陷，还需要手动创建 DOM 模型，然而通过 \x3ccode\x3etemplate\x3c\/code\x3e 标签，浏览器可以解析 \x3ccode\x3ehtml\x3c\/code\x3e 并创建 \x3ccode\x3eDOM\x3c\/code\x3e 树，但不会渲染它，该 DOM 树可以通过 \x3ccode\x3econtent\x3c\/code\x3e 属性访问，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript\x3e\n    let tpl = document.querySelector(\x27#tpl\x27);\n    let container = document.querySelector(\x27.insert-after-me\x27);\n    insertAfter(container, tpl.content);\n\x3c\/script\x3e\n\x3cdiv class=\x26quot;insert-after-me\x26quot;\x3e\x3c\/div\x3e\n\x3cng-template id=\x26quot;tpl\x26quot;\x3e\n    \x3cspan\x3eI am span in template\x3c\/span\x3e\n\x3c\/ng-template\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;script\x26gt;\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e tpl = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27#tpl\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e container = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27.insert-after-me\x27\x3c\/span\x3e);\n    insertAfter(container, tpl.content);\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;div \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22insert-after-me\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;ng-template id=\x3cspan class=\x22hljs-string\x22\x3e\x22tpl\x22\x3c\/span\x3e\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eI am span in template\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/ng-template\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eAngular 采用 \x3ccode\x3etemplate\x3c\/code\x3e 标签这种方式，实现了 \x3ccode\x3eTemplateRef\x3c\/code\x3e 抽象类来和 \x3ccode\x3etemplate\x3c\/code\x3e 标签一起合作，看看它是如何使用的（译者注：ng-template 是 Angular 提供的类似于 template 原生 html 标签）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    template: `\n        \x3cng-template #tpl\x3e\n            \x3cspan\x3eI am span in template\x3c\/span\x3e\n        \x3c\/ng-template\x3e\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\x26quot;tpl\x26quot;) tpl: TemplateRef\x3cany\x3e;\n\n    ngAfterViewInit() {\n        let elementRef = this.tpl.elementRef;\n        \/\/ outputs `template bindings={}`\n        console.log(elementRef.nativeElement.textContent);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;ng-template #tpl\x26gt;\n            \x26lt;span\x26gt;I am span in template\x26lt;\/span\x26gt;\n        \x26lt;\/ng-template\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAfterViewInit\x3c\/span\x3e \x3c\/span\x3e{\n    @ViewChild(\x3cspan class=\x22hljs-string\x22\x3e\x22tpl\x22\x3c\/span\x3e) tpl: TemplateRef\x26lt;any\x26gt;;\n\n    ngAfterViewInit() {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e elementRef = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tpl.elementRef;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ outputs `template bindings={}`\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(elementRef.nativeElement.textContent);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eAngular 框架从 DOM 中移除 \x3ccode\x3etemplate\x3c\/code\x3e 元素，并在其位置插入注释，这是渲染后的样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3csample\x3e\n    \x3c!--template bindings={}--\x3e\n\x3c\/sample\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3esample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--template bindings={}--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3esample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eTemplateRef\x3c\/code\x3e 是一个结构简单的抽象类，它的 \x3ccode\x3eelementRef\x3c\/code\x3e 属性是对其宿主元素的引用，还有一个 \x3ccode\x3ecreateEmbeddedView\x3c\/code\x3e 方法。然而 \x3ccode\x3ecreateEmbeddedView\x3c\/code\x3e 方法很有用，因为它可以创建一个视图（view）并返回该视图的引用对象 \x3ccode\x3eViewRef\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eViewRef\x3c\/h2\x3e\n\x3cp\x3e该抽象表示一个 Angular 视图（View），在 Angular 世界里，视图（View）是一堆元素的组合，一起被创建和销毁，是构建程序 UI 的基石。Angular 鼓励开发者把 UI 作为一堆视图（View）的组合，而不仅仅是 html 标签组成的树。\x3c\/p\x3e\n\x3cp\x3eAngular 支持两种类型视图：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e嵌入视图（Embedded View），由 \x3ccode\x3eTemplate\x3c\/code\x3e 提供\x3c\/li\x3e\n\x3cli\x3e宿主视图（Host View），由 \x3ccode\x3eComponent\x3c\/code\x3e 提供\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e创建嵌入视图\x3c\/h3\x3e\n\x3cp\x3e模板仅仅是视图的蓝图，可以通过之前提到的 \x3ccode\x3ecreateEmbeddedView\x3c\/code\x3e 方法创建视图，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ngAfterViewInit() {\n    let view = this.tpl.createEmbeddedView(null);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3engAfterViewInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e view = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tpl.createEmbeddedView(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e创建宿主视图\x3c\/h3\x3e\n\x3cp\x3e宿主视图是在组件动态实例化时创建的，一个动态组件（dynamic component）可以通过 \x3ccode\x3eComponentFactoryResolver\x3c\/code\x3e 创建：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(private injector: Injector,\n            private r: ComponentFactoryResolver) {\n    let factory = this.r.resolveComponentFactory(ColorComponent);\n    let componentRef = factory.create(injector);\n    let view = componentRef.hostView;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(private injector: Injector,\n            private r: ComponentFactoryResolver) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e factory = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.r.resolveComponentFactory(ColorComponent);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e componentRef = factory.create(injector);\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e view = componentRef.hostView;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 Angular 中，每一个组件绑定着一个注入器（Injector）实例，所以创建 \x3ccode\x3eColorComponent\x3c\/code\x3e 组件时传入当前组件（即 SampleComponent）的注入器。另外，别忘了，动态创建组件时需要在模块（module）或宿主组件的 \x3cstrong\x3e\x3ca href=\x22https:\/\/angular.io\/docs\/ts\/latest\/cookbook\/ngmodule-faq.html#!#q-entry-component-defined\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEntryComponents\x3c\/a\x3e\x3c\/strong\x3e 属性添加被创建的组件。\x3c\/p\x3e\n\x3cp\x3e现在，我们已经看到嵌入视图和宿主视图是如何被创建的，一旦视图被创建，它就可以使用 \x3ccode\x3eViewContainer\x3c\/code\x3e 插入 DOM 树中。下文主要探索这个功能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eViewContainerRef\x3c\/h2\x3e\n\x3cp\x3e视图容器就是挂载一个或多个视图的容器。\x3c\/p\x3e\n\x3cp\x3e首先需要说的是，任何 DOM 元素都可以作为视图容器，然而有趣的是，对于绑定 \x3ccode\x3eViewContainer\x3c\/code\x3e 的 DOM 元素，Angular 不会把视图插入该元素的内部，而是追加到该元素后面，这类似于 \x3ccode\x3erouter-outlet\x3c\/code\x3e 插入组件的方式。\x3c\/p\x3e\n\x3cp\x3e通常，比较好的方式是把 \x3ccode\x3eViewContainer\x3c\/code\x3e 绑定在 \x3ccode\x3eng-container\x3c\/code\x3e 元素上，因为 \x3ccode\x3eng-container\x3c\/code\x3e 元素会被渲染为注释，从而不会在 DOM 中引入多余的 html 元素。下面示例描述在组建模板中如何创建 \x3ccode\x3eViewContainer\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    template: `\n        \x3cspan\x3eI am first span\x3c\/span\x3e\n        \x3cng-container #vc\x3e\x3c\/ng-container\x3e\n        \x3cspan\x3eI am last span\x3c\/span\x3e\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\x26quot;vc\x26quot;, {read: ViewContainerRef}) vc: ViewContainerRef;\n\n    ngAfterViewInit(): void {\n        \/\/ outputs `template bindings={}`\n        console.log(this.vc.element.nativeElement.textContent);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;span\x26gt;I am first span\x26lt;\/span\x26gt;\n        \x26lt;ng-container #vc\x26gt;\x26lt;\/ng-container\x26gt;\n        \x26lt;span\x26gt;I am last span\x26lt;\/span\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAfterViewInit\x3c\/span\x3e \x3c\/span\x3e{\n    @ViewChild(\x3cspan class=\x22hljs-string\x22\x3e\x22vc\x22\x3c\/span\x3e, {\x3cspan class=\x22hljs-attr\x22\x3eread\x3c\/span\x3e: ViewContainerRef}) vc: ViewContainerRef;\n\n    ngAfterViewInit(): \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ outputs `template bindings={}`\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vc.element.nativeElement.textContent);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如同其他抽象类一样，\x3ccode\x3eViewContainer\x3c\/code\x3e 通过 \x3ccode\x3eelement\x3c\/code\x3e 属性绑定 DOM 元素，比如上例中，绑定的是 会被渲染为注释的 \x3ccode\x3eng-container\x3c\/code\x3e 元素，所以输出也将是 \x3ccode\x3etemplate bindings={}\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e操作视图\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eViewContainer\x3c\/code\x3e 提供了一些操作视图 API：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ViewContainerRef {\n    ...\n    clear() : void\n    insert(viewRef: ViewRef, index?: number) : ViewRef\n    get(index: number) : ViewRef\n    indexOf(viewRef: ViewRef) : number\n    detach(index?: number) : ViewRef\n    move(viewRef: ViewRef, currentIndex: number) : ViewRef\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eViewContainerRef\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n    clear() : \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e\n    insert(viewRef: ViewRef, index?: number) : ViewRef\n    get(index: number) : ViewRef\n    indexOf(viewRef: ViewRef) : number\n    detach(index?: number) : ViewRef\n    move(viewRef: ViewRef, \x3cspan class=\x22hljs-attr\x22\x3ecurrentIndex\x3c\/span\x3e: number) : ViewRef\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上文我们已经知道如何通过模板和组件创建两种类型视图，即嵌入视图和组件视图。一旦有了视图，就可以通过 \x3ccode\x3einsert\x3c\/code\x3e 方法插入 DOM 中。下面示例描述如何通过模板创建嵌入视图，并在 \x3ccode\x3eng-container\x3c\/code\x3e 标记的地方插入该视图（译者注：从上文中知道是追加到\x3ccode\x3eng-container\x3c\/code\x3e后面，而不是插入到该 DOM 元素内部）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    template: `\n        \x3cspan\x3eI am first span\x3c\/span\x3e\n        \x3cng-container #vc\x3e\x3c\/ng-container\x3e\n        \x3cspan\x3eI am last span\x3c\/span\x3e\n        \x3cng-template #tpl\x3e\n            \x3cspan\x3eI am span in template\x3c\/span\x3e\n        \x3c\/ng-template\x3e\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\x26quot;vc\x26quot;, {read: ViewContainerRef}) vc: ViewContainerRef;\n    @ViewChild(\x26quot;tpl\x26quot;) tpl: TemplateRef\x3cany\x3e;\n\n    ngAfterViewInit() {\n        let view = this.tpl.createEmbeddedView(null);\n        this.vc.insert(view);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;span\x26gt;I am first span\x26lt;\/span\x26gt;\n        \x26lt;ng-container #vc\x26gt;\x26lt;\/ng-container\x26gt;\n        \x26lt;span\x26gt;I am last span\x26lt;\/span\x26gt;\n        \x26lt;ng-template #tpl\x26gt;\n            \x26lt;span\x26gt;I am span in template\x26lt;\/span\x26gt;\n        \x26lt;\/ng-template\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eimplements\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAfterViewInit\x3c\/span\x3e \x3c\/span\x3e{\n    @ViewChild(\x3cspan class=\x22hljs-string\x22\x3e\x22vc\x22\x3c\/span\x3e, {\x3cspan class=\x22hljs-attr\x22\x3eread\x3c\/span\x3e: ViewContainerRef}) vc: ViewContainerRef;\n    @ViewChild(\x3cspan class=\x22hljs-string\x22\x3e\x22tpl\x22\x3c\/span\x3e) tpl: TemplateRef\x26lt;any\x26gt;;\n\n    ngAfterViewInit() {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e view = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tpl.createEmbeddedView(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vc.insert(view);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过上面的实现，最后的 \x3ccode\x3ehtml\x3c\/code\x3e 看起来是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3csample\x3e\n    \x3cspan\x3eI am first span\x3c\/span\x3e\n    \x3c!--template bindings={}--\x3e\n    \x3cspan\x3eI am span in template\x3c\/span\x3e\n\n    \x3cspan\x3eI am last span\x3c\/span\x3e\n    \x3c!--template bindings={}--\x3e\n\x3c\/sample\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3esample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eI am first span\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--template bindings=\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e--\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eI am span in template\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eI am last span\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--template bindings=\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e--\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3esample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以通过 \x3ccode\x3edetach\x3c\/code\x3e 方法从视图中移除 DOM，其他的方法可以通过方法名知道其含义，如通过索引获取视图引用对象，移动视图位置，或者从视图容器中移除所有视图。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e创建视图\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eViewContainer\x3c\/code\x3e 也提供了手动创建视图 API ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ViewContainerRef {\n    element: ElementRef\n    length: number\n\n    createComponent(componentFactory...): ComponentRef\x3cC\x3e\n    createEmbeddedView(templateRef...): EmbeddedViewRef\x3cC\x3e\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eViewContainerRef\x3c\/span\x3e \x3c\/span\x3e{\n    element: ElementRef\n    length: number\n\n    createComponent(componentFactory...): ComponentRef\x26lt;C\x26gt;\n    createEmbeddedView(templateRef...): EmbeddedViewRef\x26lt;C\x26gt;\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面两个方法是个很好的封装，可以传入模板引用对象或组件工厂对象来创建视图，并将该视图插入视图容器中特定位置。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3engTemplateOutlet 和 ngComponentOutlet\x3c\/h2\x3e\n\x3cp\x3e尽管知道 Angular 操作 DOM 的内部机制是好事，但是要是有某种快捷方式就更好了啊。没错，Angular 提供了两种快捷指令：\x3ccode\x3engTemplateOutlet\x3c\/code\x3e 和 \x3ccode\x3engComponentOutlet\x3c\/code\x3e。写作本文时这两个指令都是实验性的，\x3ccode\x3engComponentOutlet\x3c\/code\x3e 也将在版本 4 中可用（译者注：现在版本 5.* 也是实验性的，也都可用）。如果你读完了上文，就很容易知道这两个指令是做什么的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3engTemplateOutlet\x3c\/h3\x3e\n\x3cp\x3e该指令会把 DOM 元素标记为 \x3ccode\x3eViewContainer\x3c\/code\x3e，并插入由模板创建的嵌入视图，从而不需要在组件类中显式创建该嵌入视图。这样，上面实例中，针对创建嵌入视图并插入 \x3ccode\x3e#vc\x3c\/code\x3e DOM 元素的代码就可以重写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n    selector: \x27sample\x27,\n    template: `\n        \x3cspan\x3eI am first span\x3c\/span\x3e\n        \x3cng-container [ngTemplateOutlet]=\x26quot;tpl\x26quot;\x3e\x3c\/ng-container\x3e\n        \x3cspan\x3eI am last span\x3c\/span\x3e\n        \x3cng-template #tpl\x3e\n            \x3cspan\x3eI am span in template\x3c\/span\x3e\n        \x3c\/ng-template\x3e\n    `\n})\nexport class SampleComponent {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@Component({\n    \x3cspan class=\x22hljs-attr\x22\x3eselector\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27sample\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;span\x26gt;I am first span\x26lt;\/span\x26gt;\n        \x26lt;ng-container [ngTemplateOutlet]=\x22tpl\x22\x26gt;\x26lt;\/ng-container\x26gt;\n        \x26lt;span\x26gt;I am last span\x26lt;\/span\x26gt;\n        \x26lt;ng-template #tpl\x26gt;\n            \x26lt;span\x26gt;I am span in template\x26lt;\/span\x26gt;\n        \x26lt;\/ng-template\x26gt;\n    `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3c\/span\x3e{}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面示例看到我们不需要在组件类中写任何实例化视图的代码。非常方便，对不对。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3engComponentOutlet\x3c\/h3\x3e\n\x3cp\x3e这个指令与 \x3ccode\x3engTemplateOutlet\x3c\/code\x3e 很相似，区别是 \x3ccode\x3engComponentOutlet\x3c\/code\x3e 创建的是由组件实例化生成的宿主视图，不是嵌入视图。你可以这么使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cng-container *ngComponentOutlet=\x26quot;ColorComponent\x26quot;\x3e\x3c\/ng-container\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;ng-container *ngComponentOutlet=\x3cspan class=\x22hljs-string\x22\x3e\x22ColorComponent\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eng-container\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e看似有很多新知识需要消化啊，但实际上 Angular 通过视图操作 DOM 的思路模型是很清晰和连贯的。你可以使用 \x3ccode\x3eViewChild\x3c\/code\x3e 查询模板引用变量来获得 Angular DOM 抽象类。DOM 元素的最简单封装是 \x3ccode\x3eElementRef\x3c\/code\x3e；而对于模板，你可以使用 \x3ccode\x3eTemplateRef\x3c\/code\x3e 来创建嵌入视图；而对于组件，可以使用 \x3ccode\x3eComponentRef\x3c\/code\x3e 来创建宿主视图，同时又可以使用 \x3ccode\x3eComponentFactoryResolver\x3c\/code\x3e 创建 \x3ccode\x3eComponentRef\x3c\/code\x3e。这两个创建的视图（即嵌入视图和宿主视图）又会被 \x3ccode\x3eViewContainerRef\x3c\/code\x3e 管理。最后，Angular 又提供了两个快捷指令自动化这个过程：\x3ccode\x3engTemplateOutlet\x3c\/code\x3e 指令使用模板创建嵌入视图；\x3ccode\x3engComponentOutlet\x3c\/code\x3e 使用动态组件创建宿主视图。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] 探索 Angular 使用 ViewContainerRef 操作 DOM</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013860896">https://segmentfault.com/a/1190000013860896</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rv0ca6suys/" target="_blank">https://alili.tech/archive/rv0ca6suys/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>