<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React v16.3.0: New lifecycles and context API"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React v16.3.0: New lifecycles and context API | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rvkg7l0omyo/",
				"appid": "1613049289050283", 
				"title": "React v16.3.0: New lifecycles and context API | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-08T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/yiu5d76tj9g/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/uy3d6j1nija/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&text=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&text=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&title=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&is_video=false&description=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&title=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&title=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&title=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frvkg7l0omyo%2f&title=React%20v16.3.0%3a%20New%20lifecycles%20and%20context%20API"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React v16.3.0: New lifecycles and context API</h1><div class="meta"><div class="postdate"><time datetime="2018-12-08" itemprop="datePublished">2018-12-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e几天前，我们写了一篇关于即将到来的对我们的传统生命周期方法的变更的文章，包括逐步迁移策略。在React 16.3.0中，我们添加了一些新的生命周期方法来帮助迁移。我们还引入了新的API，用于长时间请求的特性:一个官方的上下文API、一个ref转发API和一个更语意化的ref API。\x3c\/p\x3e\n\x3cp\x3e请继续阅读，了解更多关于这个版本的信息。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e官方认证的 Context API\x3c\/h2\x3e\n\x3cp\x3e多年来，React为Context提供了一个实验性的API。虽然它是一个强大的工具，但是由于API中固有的问题，它的使用是不受欢迎的，因此我们打算用一个更好的API来替代这实验性的API。\x3c\/p\x3e\n\x3cp\x3eReact 16.3引入了一个新的Context API，它更高效，同时支持静态类型检查和深度更新。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e注意\x3c\/strong\x3e\x3cbr\x3e旧的ContextAPI 将继续保留到React 16.x，所以您将有时间迁移。\x3c\/blockquote\x3e\n\x3cp\x3e下面是一个示例，说明如何使用新的上下文API注入“主题”:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22## by 司徒正美\nconst ThemeContext = React.createContext(\x27light\x27);\n\nclass ThemeProvider extends React.Component {\n  state = {theme: \x27light\x27};\n\n  render() {\n    return (\n      \x3cThemeContext.Provider value={this.state.theme}\x3e\n        {this.props.children}\n      \x3c\/ThemeContext.Provider\x3e\n    );\n  }\n}\n\nclass ThemedButton extends React.Component {\n  render() {\n    return (\n      \x3cThemeContext.Consumer\x3e\n        {theme =\x3e \x3cButton theme={theme} \/\x3e}\n      \x3c\/ThemeContext.Consumer\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e## by 司徒正美\nconst \x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e = \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.createContext(\x3cspan class=\x22hljs-symbol\x22\x3e\x27ligh\x3c\/span\x3et\x27);\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemeProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {theme: \x3cspan class=\x22hljs-symbol\x22\x3e\x27ligh\x3c\/span\x3et\x27};\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eProvider\x3c\/span\x3e value={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.theme}\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children}\n      \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eProvider\x3c\/span\x3e\x26gt;\n    );\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemedButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eConsumer\x3c\/span\x3e\x26gt;\n        {theme =\x26gt; \x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e theme={theme} \/\x26gt;}\n      \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eThemeContext\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eConsumer\x3c\/span\x3e\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ecreateRef API\x3c\/h2\x3e\n\x3cp\x3e以前，React提供了两种管理refs的方法:字符串ref API和回调ref API。尽管字符串ref API比较方便，但是它有几个缺点，所以我们的官方推荐是使用回调ref。\x3c\/p\x3e\n\x3cp\x3eReact 16.3为管理refs提供了一个新的方案，它为字符串ref提供了方便，并且没有任何缺点:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22## by 司徒正美\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.inputRef = React.createRef();\n  }\n\n  render() {\n    return \x3cinput type=\x26quot;text\x26quot; ref={this.inputRef} \/\x3e;\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e## by 司徒正美\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputRef = \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.createRef();\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;input \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e ref={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputRef} \/\x26gt;;\n  }\n\n  componentDidMount() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputRef.current.focus();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e注意\x3c\/strong\x3e\x3cp\x3e除了新的createRef API外，回调refs将继续得到支持。\x3c\/p\x3e\n\x3cp\x3e您不需要在组件中替换回调refs。它们稍微灵活一些，因此它们将继续作为一个高级特性。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eforwardRef API\x3c\/h2\x3e\n\x3cp\x3e高阶组件(或HOCs)是在组件之间重用代码的常用方法。基于上面的主题上下文示例，我们可能会创建一个临时对象，将当前的“主题”作为一个属性注入:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22## by 司徒正美\n\nfunction withTheme(Component) {\n  return function ThemedComponent(props) {\n    return (\n      \x3cThemeContext.Consumer\x3e\n        {theme =\x3e \x3cComponent {...props} theme={theme} \/\x3e}\n      \x3c\/ThemeContext.Consumer\x3e\n    );\n  };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e## by 司徒正美\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewithTheme\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Component)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemedComponent\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(props)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;ThemeContext.Consumer\x26gt;\n        {theme =\x26gt; \x26lt;Component {...props} theme={theme} \/\x26gt;}\n      \x26lt;\/ThemeContext.Consumer\x26gt;\n    );\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以使用上述特殊的方式将组件连接到主题上下文，而不必直接使用主题上下文。例如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22## by 司徒正美\n\nclass FancyButton extends React.Component {\n  buttonRef = React.createRef();\n\n  focus() {\n    this.buttonRef.current.focus();\n  }\n\n  render() {\n    const {label, theme, ...rest} = this.props;\n    return (\n      \x3cbutton\n        {...rest}\n        className={`${theme}-button`}\n        ref={this.buttonRef}\x3e\n\n        {label}\n      \x3c\/button\x3e\n    );\n  }\n}\n\nconst FancyThemedButton = withTheme(FancyButton);\n\n\/\/ We can render FancyThemedButton as if it were a FancyButton\n\/\/ It will automatically receive the current \x26quot;theme\x26quot;,\n\/\/ And the HOC will pass through our other props.\n\x3cFancyThemedButton\n  label=\x26quot;Click me!\x26quot;\n  onClick={handleClick}\n\/\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e## by 司徒正美\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFancyButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  buttonRef = \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.createRef();\n\n  focus() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buttonRef.current.focus();\n  }\n\n  render() {\n    const {label, theme, ...rest} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;button\n        {...rest}\n        className={`${theme}-button`}\n        ref={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.buttonRef}\x26gt;\n\n        {label}\n      \x26lt;\/button\x26gt;\n    );\n  }\n}\n\nconst \x3cspan class=\x22hljs-type\x22\x3eFancyThemedButton\x3c\/span\x3e = withTheme(\x3cspan class=\x22hljs-type\x22\x3eFancyButton\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ We can render FancyThemedButton as if it were a FancyButton\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ It will automatically receive the current \x22theme\x22,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ And the HOC will pass through our other props.\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-type\x22\x3eFancyThemedButton\x3c\/span\x3e\n  label=\x3cspan class=\x22hljs-string\x22\x3e\x22Click me!\x22\x3c\/span\x3e\n  onClick={handleClick}\n\/\x26gt;;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eHOCs通常会将props传递给它们包装的组件。不幸的是，refs没有冲透进去。这意味着如果我们使用FancyThemedButton，我们就不能将ref添加到FancyButton中，因此我们无法调用focus()。\x3c\/p\x3e\n\x3cp\x3e新的代理API通过提供一种方法来拦截一个ref，并将其转发为一个普通的props，从而解决了这个问题:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22## by 司徒正美\n\nfunction withTheme(Component) {\n  \/\/ Note the second param \x26quot;ref\x26quot; provided by React.forwardRef.\n  \/\/ We can attach this to Component directly.\n  function ThemedComponent(props, ref) {\n    return (\n      \x3cThemeContext.Consumer\x3e\n        {theme =\x3e (\n          \x3cComponent {...props} ref={ref} theme={theme} \/\x3e\n        )}\n      \x3c\/ThemeContext.Consumer\x3e\n    );\n  }\n\n  \/\/ These next lines are not necessary,\n  \/\/ But they do give the component a better display name in DevTools,\n  \/\/ e.g. \x26quot;ForwardRef(withTheme(MyComponent))\x26quot;\n  const name = Component.displayName || Component.name;\n  ThemedComponent.displayName = `withTheme(${name})`;\n\n  \/\/ Tell React to pass the \x26quot;ref\x26quot; to ThemedComponent.\n  return React.forwardRef(ThemedComponent);\n}\n\nconst fancyButtonRef = React.createRef();\n\n\/\/ fancyButtonRef will now point to FancyButton\n\x3cFancyThemedButton\n  label=\x26quot;Click me!\x26quot;\n  onClick={handleClick}\n  ref={fancyButtonRef}\n\/\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e## by 司徒正美\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewithTheme\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Component)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Note the second param \x22ref\x22 provided by React.forwardRef.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We can attach this to Component directly.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eThemedComponent\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(props, ref)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;ThemeContext.Consumer\x26gt;\n        {theme =\x26gt; (\n          \x26lt;Component {...props} ref={ref} theme={theme} \/\x26gt;\n        )}\n      \x26lt;\/ThemeContext.Consumer\x26gt;\n    );\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ These next lines are not necessary,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ But they do give the component a better display name in DevTools,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ e.g. \x22ForwardRef(withTheme(MyComponent))\x22\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e name = Component.displayName || Component.name;\n  ThemedComponent.displayName = `withTheme(${name})`;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Tell React to pass the \x22ref\x22 to ThemedComponent.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e React.forwardRef(ThemedComponent);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fancyButtonRef = React.createRef();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ fancyButtonRef will now point to FancyButton\x3c\/span\x3e\n\x26lt;FancyThemedButton\n  label=\x3cspan class=\x22hljs-string\x22\x3e\x22Click me!\x22\x3c\/span\x3e\n  onClick={handleClick}\n  ref={fancyButtonRef}\n\/\x26gt;;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e组件生命周期钩子的变化\x3c\/h2\x3e\n\x3cp\x3eReact的类组件API已经存在多年，几乎没有变化。但是，当我们为更高级的特性(例如错误边界和即将到来的异步渲染模式)添加支持时，我们以它本来没有打算的方式来扩展这个模型。\x3c\/p\x3e\n\x3cp\x3e例如，在当前的API中，用一些非寻常的手段来阻止初始渲染是很容易的。在某种程度上，这是因为有太多的钩子来完成这项既定的任务，而且还不清楚哪一个是最好的。我们已经注意到错误处理的中断行为通常不会被考虑，并且可能导致内存泄漏(这也会影响即将到来的异步渲染模式)。当前的类组件API也使其他的工作变得复杂，比如我们的代码优化器（Prepack）的工作。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecomponentWillMount\x3c\/code\x3e, \x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e, \x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e这些钩子很容易引发问题，并且也严重扰乱React的生命周期。基于这些原因，我们将废弃这些方法，以支持更好的替代方案。\x3c\/p\x3e\n\x3cp\x3e我们认识到这一变化将影响许多现有的组件。因此，迁移路径将尽可能平缓，并提供迁移方案。(在Facebook，我们拥有5万多个React组件。我们也依赖于一个渐进的发布周期!\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e注意\x3c\/strong\x3e\x3cp\x3e弃用警告将在React16以后的版本中启用， 一直保留到17发布时。\x3c\/p\x3e\n\x3cp\x3e即使在React17中，仍然可以使用它们，但是它们将添加“UNSAFE_”前缀，以表明它们可能导致问题。我们还准备了一个自动化的脚本，以便现有代码中重命名它们。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e除了废弃不安全的生命周期钩子外，我们还增加了一些新的生命周期钩子:\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetDerivedStateFromProps\x3c\/code\x3e 用来componentWillReceiveProps。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetSnapshotBeforeUpdate\x3c\/code\x3e，用在更新前从DOM中安全地读取属性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eStrictMode 组件\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;StrictMode \/\x26gt;\x3c\/code\x3e是一种专门用于暴露潜在问题的工具。与\x3ccode\x3e\x26lt;Fragment \/\x26gt;\x3c\/code\x3e一样，\x3ccode\x3e\x26lt;StrictMode\/\x26gt;\x3c\/code\x3e将 不会渲染到视图中。它能为其子组件激活额外的检查和警告。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3e注意\x3c\/strong\x3e\x3cp\x3e\x3ccode\x3e\x26lt;StrictMode \/\x26gt;\x3c\/code\x3e检查只在开发模式下运行;它们不会影响生产构建。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e虽然严格的模式不可能捕获所有的问题(例如某些类型的窜改)，但它可以帮助很多人。如果您在严格的模式下看到警告，这些事情很可能会导致异步渲染的错误。\x3c\/p\x3e\n\x3cp\x3e在16.3版本中，StrictMode帮助:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e识别具有不安全生命周期钩子的组件。\x3c\/li\x3e\n\x3cli\x3e关于遗留字符串ref API用法的警告。\x3c\/li\x3e\n\x3cli\x3e检测意想不到的副作用\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React v16.3.0: New lifecycles and context API</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014083970">https://segmentfault.com/a/1190000014083970</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rvkg7l0omyo/" target="_blank">https://alili.tech/archive/rvkg7l0omyo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>