<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从零开始实现一个React（二）：实现组件功能"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从零开始实现一个React（二）：实现组件功能 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/s4mspj06ktg/",
				"appid": "1613049289050283", 
				"title": "从零开始实现一个React（二）：实现组件功能 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-08T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3pagy4a7e35/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t4gz9s2pm29/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&is_video=false&description=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs4mspj06ktg%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaReact%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e7%bb%84%e4%bb%b6%e5%8a%9f%e8%83%bd"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从零开始实现一个React（二）：实现组件功能</h1><div class="meta"><div class="postdate"><time datetime="2018-12-08" itemprop="datePublished">2018-12-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e在上一篇文章\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJSX和虚拟DOM\x3c\/a\x3e中，我们实现了基础的JSX渲染功能，但是React的意义在于组件化。在这篇文章中，我们就要实现React的组件功能。\x3c\/p\x3e\n\x3cp\x3eReact定义组件的方式可以分为两种：函数和类，我们姑且将两种不同方式定义的组件称之为\x3cstrong\x3e函数定义组件\x3c\/strong\x3e和\x3cstrong\x3e类定义组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e函数定义组件\x3c\/h1\x3e\n\x3cp\x3e函数定义组件相对简单，只需要用组件名称声明一个函数，并返回一段JSX即可。\x3cbr\x3e例如我们定义一个\x3ccode\x3eWelcome\x3c\/code\x3e组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Welcome( props ) {\n    return \x3ch1\x3eHello, {props.name}\x3c\/h1\x3e;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e props \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e注意组件名称要以大写字母开头\x3c\/blockquote\x3e\n\x3cp\x3e函数组件接受一个props参数，它是给组件传入的数据。\x3c\/p\x3e\n\x3cp\x3e我们可以这样来使用它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = \x3cWelcome name=\x26quot;Sara\x26quot; \/\x3e;\nReactDOM.render(\n    element,\n    document.getElementById( \x27root\x27 )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e element = \x26lt;Welcome name=\x3cspan class=\x22hljs-string\x22\x3e\x22Sara\x22\x3c\/span\x3e \/\x26gt;;\nReactDOM.render(\n    element,\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById( \x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e )\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e让createElemen支持函数定义组件\x3c\/h2\x3e\n\x3cp\x3e回顾一下上一篇文章中我们对\x3ccode\x3eReact.createElement\x3c\/code\x3e的实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElement( tag, attrs, ...children ) {\n    return {\n        tag,\n        attrs,\n        children\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateElement\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e tag, attrs, ...children \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        tag,\n        attrs,\n        children\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种实现只能渲染原生DOM元素，而对于组件，createElement得到的参数略有不同：\x3cbr\x3e如果JSX片段中的某个元素是组件，那么createElement的第一个参数\x3ccode\x3etag\x3c\/code\x3e将会是一个方法，而不是字符串。\x3c\/p\x3e\n\x3cblockquote\x3e区分组件和原生DOM的工作，是\x3ccode\x3ebabel-plugin-transform-react-jsx\x3c\/code\x3e帮我们做的\x3c\/blockquote\x3e\n\x3cp\x3e例如在处理\x3ccode\x3e\x26lt;Welcome name=\x22Sara\x22 \/\x26gt;\x3c\/code\x3e时，\x3ccode\x3ecreateElement\x3c\/code\x3e方法的第一个参数\x3ccode\x3etag\x3c\/code\x3e，实际上就是我们定义\x3ccode\x3eWelcome\x3c\/code\x3e的方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Welcome( props ) {\n    return \x3ch1\x3eHello, {props.name}\x3c\/h1\x3e;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e props \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以我们需要修改一下\x3ccode\x3ecreateElement\x3c\/code\x3e，让它能够渲染组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElement( tag, attrs, ...children ) {\n    \n    \/\/ 如果tag是一个方法，那么它是一个组件\n    if ( typeof tag === \x27function\x27 ) {\n        return tag( attrs || {} );\n    }\n\n    return {\n        tag,\n        attrs,\n        children\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateElement\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e tag, attrs, ...children \x3c\/span\x3e) \x3c\/span\x3e{\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果tag是一个方法，那么它是一个组件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e tag === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e tag( attrs || {} );\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        tag,\n        attrs,\n        children\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e渲染函数定义组件\x3c\/h2\x3e\n\x3cp\x3e在简单的修改了\x3ccode\x3ecreateElement\x3c\/code\x3e方法后，我们就可以用来渲染函数定义组件了。\x3cbr\x3e渲染上文定义的\x3ccode\x3eWelcome\x3c\/code\x3e组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = \x3cWelcome name=\x26quot;Sara\x26quot; \/\x3e;\nReactDOM.render(\n    element,\n    document.getElementById( \x27root\x27 )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e element = \x26lt;Welcome name=\x3cspan class=\x22hljs-string\x22\x3e\x22Sara\x22\x3c\/span\x3e \/\x26gt;;\nReactDOM.render(\n    element,\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById( \x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e )\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在浏览器中可以看到结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6V7k?w=528\x26amp;h=260\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6V7k?w=528\x26amp;h=260\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e试试更复杂的例子，将多个组件组合起来：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function App() {\n    return (\n        \x3cdiv\x3e\n            \x3cWelcome name=\x26quot;Sara\x26quot; \/\x3e\n            \x3cWelcome name=\x26quot;Cahal\x26quot; \/\x3e\n            \x3cWelcome name=\x26quot;Edite\x26quot; \/\x3e\n        \x3c\/div\x3e\n    );\n}\nReactDOM.render(\n    \x3cApp \/\x3e,\n    document.getElementById( \x27root\x27 )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e(\x3c\/span\x3e\n        \x26lt;div\x26gt;\n            \x26lt;Welcome name=\x3cspan class=\x22hljs-string\x22\x3e\x22Sara\x22\x3c\/span\x3e \/\x26gt;\n            \x26lt;Welcome name=\x3cspan class=\x22hljs-string\x22\x3e\x22Cahal\x22\x3c\/span\x3e \/\x26gt;\n            \x26lt;Welcome name=\x3cspan class=\x22hljs-string\x22\x3e\x22Edite\x22\x3c\/span\x3e \/\x26gt;\n        \x26lt;\/div\x26gt;\n    );\n}\nReactDOM.render(\n    \x26lt;App \/\x26gt;,\n    document.getElementById( \x3cspan class=\x22hljs-symbol\x22\x3e\x27root\x3c\/span\x3e\x27 )\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在浏览器中可以看到结果：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6V7s?w=524\x26amp;h=332\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6V7s?w=524\x26amp;h=332\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e类定义组件\x3c\/h1\x3e\n\x3cp\x3e类定义组件相对麻烦一点，我们通过继承\x3ccode\x3eReact.Component\x3c\/code\x3e来定义一个组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Welcome extends React.Component {\n    render() {\n        return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e, {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name}\x26lt;\/h1\x26gt;;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eComponet\x3c\/h2\x3e\n\x3cp\x3e为了实现类定义组件，我们需要定义一个\x3ccode\x3eComponent\x3c\/code\x3e类：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Component {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode class=\x22jsx\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3estate \x26amp; props\x3c\/h3\x3e\n\x3cp\x3e通过继承\x3ccode\x3eReact.Component\x3c\/code\x3e定义的组件有自己的私有状态\x3ccode\x3estate\x3c\/code\x3e，可以通过\x3ccode\x3ethis.state\x3c\/code\x3e获取到。同时也能通过\x3ccode\x3ethis.props\x3c\/code\x3e来获取传入的数据。\x3cbr\x3e所以在构造函数中，我们需要初始化\x3ccode\x3estate\x3c\/code\x3e和\x3ccode\x3eprops\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ React.Component\nclass Component {\n    constructor( props = {} ) {\n        this.isReactComponent = true;\n        this.state = {};\n        this.props = props;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ React.Component\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e( props = {} ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isReactComponent = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {};\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props = props;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里多了一个\x3ccode\x3eisReactComponent\x3c\/code\x3e属性，我们后面会用到。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3esetState\x3c\/h3\x3e\n\x3cp\x3e组件内部的\x3ccode\x3estate\x3c\/code\x3e和渲染结果相关，当\x3ccode\x3estate\x3c\/code\x3e改变时通常会触发渲染，为了让React知道我们改变了\x3ccode\x3estate\x3c\/code\x3e，我们只能通过\x3ccode\x3esetState\x3c\/code\x3e方法去修改它。我们可以通过\x3ccode\x3eObject.assign\x3c\/code\x3e来做一个简单的实现。\x3cbr\x3e在每次更新state后，我们需要使用\x3ccode\x3eReactDOM.render\x3c\/code\x3e重新渲染。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import ReactDOM from \x27..\/react-dom\x27\nclass Component {\n    constructor( props = {} ) {\n        \/\/ ...\n    }\n\n    setState( stateChange ) {\n        \/\/ 将修改合并到state\n        Object.assign( this.state, stateChange );\n        if ( this._container ) {\n            ReactDOM.render( this, this._container );\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/react-dom\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e( props = {} ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    }\n\n    setState( stateChange ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将修改合并到state\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state, stateChange );\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._container ) {\n            ReactDOM.render( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._container );\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可能听说过React的\x3ccode\x3esetState\x3c\/code\x3e是异步的，同时它有很多优化手段，这里我们暂时不去管它，在以后会有一篇文章专门来讲\x3ccode\x3esetState\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e让createElemen支持类定义组件\x3c\/h2\x3e\n\x3cp\x3e在js中，\x3ccode\x3eclass\x3c\/code\x3e只是语法糖，它的本质仍然是一个函数。\x3cbr\x3e所以第一步，我们需要在\x3ccode\x3ecreateElemen\x3c\/code\x3e方法中区分当前的节点是函数定义还是类定义。\x3cbr\x3e类定义组件必须有\x3ccode\x3erender\x3c\/code\x3e方法，而通过\x3ccode\x3eclass\x3c\/code\x3e定义的类，它的方法都附加在\x3ccode\x3eprototype\x3c\/code\x3e上。\x3cbr\x3e所以只需要判断tag的\x3ccode\x3eprototype\x3c\/code\x3e中是否有\x3ccode\x3erender\x3c\/code\x3e方法，就能知道这个组件是函数定义还是类定义。\x3cbr\x3e现在我们可以进一步修改\x3ccode\x3eReact.createElement\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElement( tag, attrs, ...children ) {\n\n    \/\/ 类定义组件\n    if ( tag.prototype \x26amp;\x26amp;  tag.prototype.render ) {\n        return new tag( attrs );\n    \/\/ 函数定义组件\n    } else if ( typeof tag === \x27function\x27 ) {\n        return tag( attrs || {} );\n    }\n\n    return {\n        tag,\n        attrs,\n        children\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateElement\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e tag, attrs, ...children \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类定义组件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( tag.prototype \x26amp;\x26amp;  tag.prototype.render ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e tag( attrs );\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数定义组件\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e tag === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e tag( attrs || {} );\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        tag,\n        attrs,\n        children\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3erender\x3c\/h2\x3e\n\x3cp\x3e函数定义组件返回的是jsx，我们不需要做额外处理。但是类定义组件不同，它并不直接返回jsx。而是通过\x3ccode\x3erender\x3c\/code\x3e方法来得到渲染结果。\x3c\/p\x3e\n\x3cp\x3e所以我们需要修改\x3ccode\x3eReactDOM.render\x3c\/code\x3e方法。\x3cbr\x3e修改之前我们先来回顾一下上一篇文章中我们对\x3ccode\x3eReactDOM.render\x3c\/code\x3e的实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function render( vnode, container ) {\n\n    if ( vnode === undefined ) return;\n    \n    \/\/ 当vnode为字符串时，渲染结果是一段文本\n    if ( typeof vnode === \x27string\x27 ) {\n        const textNode = document.createTextNode( vnode );\n        return container.appendChild( textNode );\n    }\n\n    const dom = document.createElement( vnode.tag );\n\n    if ( vnode.attrs ) {\n        Object.keys( vnode.attrs ).forEach( key =\x3e {\n            if ( key === \x27className\x27 ) key = \x27class\x27;            \/\/ 当属性名为className时，改回class\n            dom.setAttribute( key, vnode.attrs[ key ] )\n        } );\n    }\n\n    vnode.children.forEach( child =\x3e render( child, dom ) );    \/\/ 递归渲染子节点\n\n    return container.appendChild( dom );    \/\/ 将渲染结果挂载到真正的DOM上\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e vnode, container \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vnode === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当vnode为字符串时，渲染结果是一段文本\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e vnode === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e textNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode( vnode );\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e container.appendChild( textNode );\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dom = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement( vnode.tag );\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vnode.attrs ) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys( vnode.attrs ).forEach( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( key === \x3cspan class=\x22hljs-string\x22\x3e\x27className\x27\x3c\/span\x3e ) key = \x3cspan class=\x22hljs-string\x22\x3e\x27class\x27\x3c\/span\x3e;            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当属性名为className时，改回class\x3c\/span\x3e\n            dom.setAttribute( key, vnode.attrs[ key ] )\n        } );\n    }\n\n    vnode.children.forEach( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3echild\x3c\/span\x3e =\x26gt;\x3c\/span\x3e render( child, dom ) );    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 递归渲染子节点\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e container.appendChild( dom );    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将渲染结果挂载到真正的DOM上\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上文定义\x3ccode\x3eComponent\x3c\/code\x3e时，我们添加了一个\x3ccode\x3eisReactComponent\x3c\/code\x3e属性，在这里我们需要用它来判断当前渲染的是否是一个组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function render( vnode, container ) {\n\n    if ( vnode.isReactComponent ) {\n        const component = vnode;\n        component._container = container;   \/\/ 保存父容器信息，用于更新\n        vnode = component.render();            \/\/  render()返回的结果才是需要渲染的vnode\n    }\n    \n    \/\/ 后面的代码不变...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e vnode, container \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vnode.isReactComponent ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e component = vnode;\n        component._container = container;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存父容器信息，用于更新\x3c\/span\x3e\n        vnode = component.render();            \x3cspan class=\x22hljs-comment\x22\x3e\/\/  render()返回的结果才是需要渲染的vnode\x3c\/span\x3e\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后面的代码不变...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们的render方法就可以用来渲染组件了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e生命周期\x3c\/h2\x3e\n\x3cp\x3e上面的实现还差一个关键的部分：生命周期。\x3c\/p\x3e\n\x3cp\x3e在React的组件中，我们可以通过定义生命周期方法在某个时间做一些事情，例如定义\x3ccode\x3ecomponentDidMount\x3c\/code\x3e方法，在组件挂载时会执行它。\x3c\/p\x3e\n\x3cp\x3e但是现在我们的实现非常简单，还没有对比虚拟DOM的变化，很多生命周期的状态没办法区分，所以我们暂时只添加\x3ccode\x3ecomponentWillMount\x3c\/code\x3e和\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e两个方法，它们会在组件挂载之前和更新之前执行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function render( vnode, container ) {\n\n    if ( vnode.isReactComponent ) {\n        const component = vnode;\n\n        if ( component._container ) {\n            if ( component.componentWillUpdate ) {\n                component.componentWillUpdate();    \/\/ 更新\n            }\n        } else if ( component.componentWillMount ) {\n            component.componentWillMount();          \/\/ 挂载\n        }\n\n        component._container = container;   \/\/ 保存父容器信息，用于更新\n\n        vnode = component.render();\n    }\n    \n    \/\/ 后面的代码不变...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e vnode, container \x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( vnode.isReactComponent ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e component = vnode;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( component._container ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( component.componentWillUpdate ) {\n                component.componentWillUpdate();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新\x3c\/span\x3e\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( component.componentWillMount ) {\n            component.componentWillMount();          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挂载\x3c\/span\x3e\n        }\n\n        component._container = container;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存父容器信息，用于更新\x3c\/span\x3e\n\n        vnode = component.render();\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后面的代码不变...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e渲染类定义组件\x3c\/h2\x3e\n\x3cp\x3e现在大部分工作已经完成，我们可以用它来渲染类定义组件了。\x3cbr\x3e我们来试一试将刚才函数定义组件改成类定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Welcome extends React.Component {\n    render() {\n        return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n    }\n}\n\nclass App extends React.Component {\n    render() {\n        return (\n            \x3cdiv\x3e\n                \x3cWelcome name=\x26quot;Sara\x26quot; \/\x3e\n                \x3cWelcome name=\x26quot;Cahal\x26quot; \/\x3e\n                \x3cWelcome name=\x26quot;Edite\x26quot; \/\x3e\n            \x3c\/div\x3e\n        );\n    }\n}\nReactDOM.render(\n    \x3cApp \/\x3e,\n    document.getElementById( \x27root\x27 )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;h1\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e, {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name}\x26lt;\/h1\x26gt;;\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;\n                \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWelcome\x3c\/span\x3e name=\x3cspan class=\x22hljs-string\x22\x3e\x22Sara\x22\x3c\/span\x3e \/\x26gt;\n                \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWelcome\x3c\/span\x3e name=\x3cspan class=\x22hljs-string\x22\x3e\x22Cahal\x22\x3c\/span\x3e \/\x26gt;\n                \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWelcome\x3c\/span\x3e name=\x3cspan class=\x22hljs-string\x22\x3e\x22Edite\x22\x3c\/span\x3e \/\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    }\n}\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\n    \x26lt;\x3cspan class=\x22hljs-type\x22\x3eApp\x3c\/span\x3e \/\x26gt;,\n    document.getElementById( \x3cspan class=\x22hljs-symbol\x22\x3e\x27roo\x3c\/span\x3et\x27 )\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行起来结果和函数定义组件完全一致：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6V7U?w=511\x26amp;h=315\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6V7U?w=511\x26amp;h=315\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e再来尝试一个能体现出类定义组件区别的例子，实现一个计数器\x3ccode\x3eCounter\x3c\/code\x3e，每点击一次就会加1。\x3cbr\x3e并且组件中还增加了两个生命周期函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Counter extends React.Component {\n    constructor( props ) {\n        super( props );\n        this.state = {\n            num: 0\n        }\n    }\n\n    componentWillUpdate() {\n        console.log( \x27update\x27 );\n    }\n\n    componentWillMount() {\n        console.log( \x27mount\x27 );\n    }\n\n    onClick() {\n        this.setState( { num: this.state.num \x2b 1 } );\n    }\n\n    render() {\n        return (\n            \x3cdiv onClick={ () =\x3e this.onClick() }\x3e\n                \x3ch1\x3enumber: {this.state.num}\x3c\/h1\x3e\n                \x3cbutton\x3eadd\x3c\/button\x3e\n            \x3c\/div\x3e\n        );\n    }\n}\n\nReactDOM.render(\n    \x3cCounter \/\x3e,\n    document.getElementById( \x27root\x27 )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e( props ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e( props );\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            \x3cspan class=\x22hljs-attr\x22\x3enum\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        }\n    }\n\n    componentWillUpdate() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-string\x22\x3e\x27update\x27\x3c\/span\x3e );\n    }\n\n    componentWillMount() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-string\x22\x3e\x27mount\x27\x3c\/span\x3e );\n    }\n\n    onClick() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState( { \x3cspan class=\x22hljs-attr\x22\x3enum\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.num \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e } );\n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e () =\x26gt;\x3c\/span\x3e this.onClick() }\x26gt;\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3enumber: {this.state.num}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3eadd\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        );\n    }\n}\n\nReactDOM.render(\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounter\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e,\n    document.getElementById( \x27root\x27 )\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到结果：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6V8j?w=526\x26amp;h=189\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6V8j?w=526\x26amp;h=189\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3emount只在挂载时输出了一次，后面每次更新时会输出update\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader12\x22\x3e后话\x3c\/h1\x3e\n\x3cp\x3e至此我们已经从API层面实现了React的核心功能。但是我们目前的做法是每次更新都重新渲染整个组件甚至是整个应用，这样的做法在页面复杂时将会暴露出性能上的问题，DOM操作非常昂贵，而为了减少DOM操作，React又做了哪些事？这就是我们下一篇文章的内容了。\x3c\/p\x3e\n\x3cp\x3e这篇文章的代码：\x3ca href=\x22https:\/\/github.com\/hujiulong\/simple-react\/tree\/chapter-2\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hujiulong\/...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader13\x22\x3e从零开始实现React系列\x3c\/h1\x3e\n\x3cp\x3eReact是前端最受欢迎的框架之一，解读其源码的文章非常多，但是我想从另一个角度去解读React：从零开始实现一个React，从API层面实现React的大部分功能，在这个过程中去探索为什么有虚拟DOM、diff、为什么setState这样设计等问题。\x3c\/p\x3e\n\x3cp\x3e整个系列大概会有六篇左右，我每周会更新一到两篇，我会第一时间在github上更新，有问题需要探讨也请在github上回复我~\x3c\/p\x3e\n\x3cblockquote\x3e博客地址: \x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hujiulong\/blog\x3c\/a\x3e\x3cbr\x3e关注点star，订阅点watch\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e上一篇文章\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hujiulong\/blog\/issues\/4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从零开始实现React（一）：JSX和虚拟DOM \x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从零开始实现一个React（二）：实现组件功能</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014007460">https://segmentfault.com/a/1190000014007460</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/s4mspj06ktg/" target="_blank">https://alili.tech/archive/s4mspj06ktg/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>