<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue2.0生命周期（组件钩子函数与路由守卫）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue2.0生命周期（组件钩子函数与路由守卫） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/s9351b0nhe/",
				"appid": "1613049289050283", 
				"title": "Vue2.0生命周期（组件钩子函数与路由守卫） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jrz81fk5y5k/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6kn3e7jn7ao/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&text=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&text=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&title=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&is_video=false&description=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&title=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&title=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&title=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs9351b0nhe%2f&title=Vue2.0%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%ef%bc%88%e7%bb%84%e4%bb%b6%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e4%b8%8e%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue2.0生命周期（组件钩子函数与路由守卫）</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e组件相关钩子函数： beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destoryed\x3cbr\x3e还有两个特殊的（使用keep-alive）：\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#activated\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eactivated\x3c\/a\x3e、\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#deactivated\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edeactivated\x3c\/a\x3e（不详述）\x3cbr\x3ev2.5.0\x2b新增： \x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/api\/#errorCaptured\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eerrorCaptured\x3c\/a\x3e (暂时还不知道咋用)\x3c\/p\x3e\n\x3cp\x3e路由守卫：\x3cbr\x3e全局\x26amp;路由独享：beforeEach、beforeResolve（v2.5.0\x2b新增）、afterEach ；beforeEnter（路由独享，类似beforeEach）\x3cbr\x3e组件内：beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e组件生命周期钩子函数\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3ebeforeCreate\x3c\/h3\x3e\n\x3cp\x3e实例初始化之后\x3c\/p\x3e\n\x3cp\x3ethis指向创建的实例\x3cbr\x3e数据观测（data observer）和event\/watcher配置尚未完成\x3cbr\x3e不能访问到methods、data、computed、watch上的方法和数据\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ecreated\x3c\/h3\x3e\n\x3cp\x3e实例创建完成，并已经完成以下配置：数据观测(data observer)，属性和方法的运算， watch\/event 事件回调\x3cbr\x3e此时可以调用methods中定义的方法，修改data的数据，并且可触发响应式变化、computed值重新计算，watch到变更等\x3c\/p\x3e\n\x3cp\x3e还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n  data () {\n    return {\n      a : 1\n    }\n  } ,\n  created (){\n    console.log( this.a )  \/\/ 1\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3enew Vue({\n  \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      a : \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    }\n  } ,\n  created (){\n    console.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a )  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个生命周期阶段比较常用，比如ajax请求获取初始化数据对实例进行初始化预处理等操作；但要注意在结合vue-router使用时，进入created生命周期阶段后是无法对挂载实例进行拦截的，此时实例已经创建完成；故如果需要某些数据获取完成情况才允许进入页面的场景，建议在路由钩子beforeRouteEnter中实现\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ebeforeMount\x3c\/h3\x3e\n\x3cp\x3e在挂载开始之前被调用\x3c\/p\x3e\n\x3cp\x3e注意：从vue生命周期图可以看出\x3cbr\x3e当new Vue({...})的配置中没有el属性时，生命周期暂停，等待vm.$mount(el)调用时才继续\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013956948\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013956948\x22 alt=\x22created-\x26amp;gt;beforeMount\x22 title=\x22created-\x26amp;gt;beforeMount\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ebeforeMount之前，会找到对应的template，并编译成render函数\x3cbr\x3e（这个步骤如果使用.vue文件和运行时版本将会在构建时提前完成）\x3c\/p\x3e\n\x3cp\x3etemplate查找的优先级顺序:\x3cbr\x3e\x3cstrong\x3e template参数  \x26gt; el 外部HTML\x3c\/strong\x3e\x3cbr\x3e如果指定了render函数，则直接采用render函数，即忽略template参数和el外部HTML\x3c\/p\x3e\n\x3cp\x3e写个栗子测试：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;app\x26quot;\x3etemplate outside\x3c\/div\x3e\n...\nimport App from \x27.\/App.vue\x27;  \/\/ App是任一Vue组件对象\n\nnew Vue({\n  el: \x27#app\x27,\n  \/\/ template: \x27\x3cp\x3etemplate inside\x3c\/p\x3e\x27,   \/\/ part inside\n  \/\/ render: h =\x3e h(App)     \/\/  part render\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x26lt;div id=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e outside\x26lt;\/div\x26gt;\n...\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App from \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.vue\x27\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ App是任一Vue组件对象\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ template: \x27\x26lt;p\x26gt;template inside\x26lt;\/p\x26gt;\x27,   \/\/ part inside\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ render: h =\x26gt; h(App)     \/\/  part render\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要Vue完整版本支持，注释part inside和part render依次打开即可观察到三次不同的结果\x3c\/p\x3e\n\x3cp\x3eVue的编译过程暂略\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3emounted\x3c\/h3\x3e\n\x3cp\x3eel被新创建的$el替换 ----  怎么理解？\x3c\/p\x3e\n\x3cp\x3e这个可以理解为挂载前为实例寻找了一个暂时容身之处el，编译完成($el创建完成)后替换这个容身之处完成实例的挂载\x3cbr\x3e如：之前那个栗子中，将part render打开后观察生成的DOM结构，\x3ccode\x3e\x26lt;div id=\x22app\x22\x26gt;template outside\x26lt;\/div\x26gt;\x3c\/code\x3e这个节点即原el已经被替换掉\x3c\/p\x3e\n\x3cp\x3e实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问\x3c\/p\x3e\n\x3cp\x3e虽然经常观察到先进入子组件mounted，但根据Vue官方文档：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22注意\x26nbsp;`mounted`\x26nbsp;不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染\n完毕，可以用\x26nbsp;[vm.$nextTick](https:\/\/cn.vuejs.org\/v2\/api\/#vm-nextTick)\x26nbsp;\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e注意\x26nbsp;\x3cspan class=\x22hljs-code\x22\x3e`mounted`\x3c\/span\x3e\x26nbsp;不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染\n完毕，可以用\x26nbsp;[\x3cspan class=\x22hljs-string\x22\x3evm.$nextTick\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/cn.vuejs.org\/v2\/api\/#vm-nextTick\x3c\/span\x3e)\x26nbsp;\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个阶段改变data上的值，相关的computed属性可以立刻更新；但需要进入到下一次DOM更新，才能看到DOM上数据更新\x3c\/p\x3e\n\x3cp\x3e栗子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n  el: \x27#app\x27,\n  template: \x27\x3cp id=\x26quot;testa\x26quot;\x3e\x22{{\x22a\x22}}\x22\x3c\/p\x3e\x27,\n  router,\n  data ()\n  {\n    return {\n      a : 0\n    }\n  },\n  mounted() {\n    this.a \x2b\x2b;\n    console.log(this.b);   \/\/  2\n    console.log(document.getElementById(\x27testa\x27).innerHTML)  \/\/  0\n  },\n  computed :{\n    b (){\n      return this.a\x2b1;\n    }\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3enew Vue({\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p id=\x22testa\x22\x26gt;\x22{{\x22a\x22}}\x22\x26lt;\/p\x26gt;\x27\x3c\/span\x3e,\n  router,\n  \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e ()\n  {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      a : \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n  },\n  mounted() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b\x2b;\n    console.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.b);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/  2\x3c\/span\x3e\n    console.log(document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27testa\x27\x3c\/span\x3e).innerHTML)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  0\x3c\/span\x3e\n  },\n  computed :{\n    b (){\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    }\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ebeforeRouteEnter的next的勾子比mounted触发还要靠后 - 这个待会说到路由相关钩子时再展开\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ebeforeUpdate\x3c\/h3\x3e\n\x3cp\x3e这里的更新对象是模板，即需要虚拟 DOM 重新渲染和打补丁，beforeUpdate发生在以上两个流程之前，此时新的虚拟DOM已经生成\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e如果发生变更的数据在模板中并没有使用（包括直接和间接，间接：比如某个依赖该数据的计算属性在模板中使用了），则不会触发更新流程！！！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n  el: \x27#app\x27,\n  template: \x27\x3cp id=\x26quot;testa\x26quot;\x3e\x22{{\x22a\x22}}\x22\x3c\/p\x3e\x27,\n  router,\n  data ()\n  {\n    return {\n      a : 0,\n      b :  1\n    }\n  },\n  mounted (){\n    this.b \x2b\x2b;   \/\/   b并没有在模板中使用\n  },\n  beforeUpdate (){\n    debugger;  \/\/  不会进入这个断点\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e({\n  \x3cspan class=\x22hljs-attribute\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p id=\x22testa\x22\x26gt;\x22{{\x22a\x22}}\x22\x26lt;\/p\x26gt;\x27\x3c\/span\x3e,\n  router,\n  data ()\n  {\n    return {\n      \x3cspan class=\x22hljs-attribute\x22\x3ea \x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attribute\x22\x3eb \x3c\/span\x3e:  \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    }\n  },\n  mounted (){\n    \x3cspan class=\x22hljs-selector-tag\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.b\x3c\/span\x3e \x2b\x2b;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/   b并没有在模板中使用\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-selector-tag\x22\x3ebeforeUpdate\x3c\/span\x3e (){\n    \x3cspan class=\x22hljs-selector-tag\x22\x3edebugger\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  不会进入这个断点\x3c\/span\x3e\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在一些参考文章中看到：\x3cbr\x3e\x3ccode\x3e在这个钩子函数中，可以对状态进行进一步更改，不会再次触发重渲染流程\x3c\/code\x3e  --- 这个说法有问题\x3cbr\x3e如果对状态进行变更会导致重新进入beforeUpdate（这里变更的状态同样要在模板中使用，如果变更没有在模板中使用的data，才不会再次触发重渲染流程）\x3cbr\x3e而且若变更操作不是基础类型的简单赋值，还会引起死循环（不断重新进入beforeUpdate）！\x3c\/p\x3e\n\x3cp\x3e看看这个栗子，依次把注释打开测试\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n  el: \x27#app\x27,\n  template: \x27\x3cp id=\x26quot;testa\x26quot;\x3e\x22{{\x22a\x22}}\x22\x3c\/p\x3e\x27,\n  router,\n  data ()\n  {\n    return {\n      a : 0,\n      c:  0\n    }\n  },\n  beforeUpdate() {\n    console.log(document.getElementById(\x27testa\x27).innerHTML)\n    \/\/ this.c = 1;   \/\/  this.c没有在模板中使用，变更不会引起重渲染流程\n    \/\/ this.a = 3;  \/\/  会再次进入一次重渲染流程，第二次进入时发现a仍是3，值没有变更，不会再次重渲染\n    \/\/ this.a \x2b\x2b;   \/\/  会引起死循环，每次进入重渲染流程时，a的值都会变更\n  },\n  updated() {\n    console.log(document.getElementById(\x27testa\x27).innerHTML)\n  }\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e({\n  \x3cspan class=\x22hljs-attribute\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p id=\x22testa\x22\x26gt;\x22{{\x22a\x22}}\x22\x26lt;\/p\x26gt;\x27\x3c\/span\x3e,\n  router,\n  data ()\n  {\n    return {\n      \x3cspan class=\x22hljs-attribute\x22\x3ea \x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attribute\x22\x3ec\x3c\/span\x3e:  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    }\n  },\n  beforeUpdate() {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27testa\x27\x3c\/span\x3e).innerHTML)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.c = 1;   \/\/  this.c没有在模板中使用，变更不会引起重渲染流程\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.a = 3;  \/\/  会再次进入一次重渲染流程，第二次进入时发现a仍是3，值没有变更，不会再次重渲染\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.a \x2b\x2b;   \/\/  会引起死循环，每次进入重渲染流程时，a的值都会变更\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eupdated\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27testa\x27\x3c\/span\x3e).innerHTML)\n  }\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e应该避免在这个钩子函数中操作数据\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eupdated\x3c\/h3\x3e\n\x3cp\x3e由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\x3c\/p\x3e\n\x3cp\x3e当这个钩子被调用时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22注意\x26nbsp;`updated`\x26nbsp;不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，\n可以用\x26nbsp;[vm.$nextTick](https:\/\/cn.vuejs.org\/v2\/api\/#vm-nextTick)\x26nbsp;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e注意\x26nbsp;\x3cspan class=\x22hljs-code\x22\x3e`updated`\x3c\/span\x3e\x26nbsp;不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，\n可以用\x26nbsp;[\x3cspan class=\x22hljs-string\x22\x3evm.$nextTick\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/cn.vuejs.org\/v2\/api\/#vm-nextTick\x3c\/span\x3e)\x26nbsp;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样，\x3cstrong\x3e应该避免在这个钩子函数中操作数据\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3ebeforeDestroy\x3c\/h4\x3e\n\x3cp\x3e实例销毁之前调用。在这一步，实例仍然完全可用，this仍能获取到实例\x3c\/p\x3e\n\x3cp\x3e一般在这一步中进行：销毁定时器、解绑全局事件、销毁插件对象等操作\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3edestroyed\x3c\/h3\x3e\n\x3cp\x3eVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：vue2.0之后主动调用$destroy()不会移除dom节点，作者不推荐直接destroy这种做法，具体参考\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/issues\/5256\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/vuejs\/vue\/...\x3c\/a\x3e，如果实在需要这样用可以在这个生命周期钩子中手动移除dom节点\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e参考\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档中的生命周期说明图\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e路由守卫 —— 路由级别的（全局\x26amp;路由独享）\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3erouter.beforeEach\x3c\/h3\x3e\n\x3cp\x3e全局前置守卫\x3cbr\x3e当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 \x3cem\x3e等待中\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e如何使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22router.beforeEach((to, from, next) =\x3e {\n  console.log(\x27全局前置守卫：beforeEach -- next需要调用\x27)\n  next()\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs moonscript\x22\x3e\x3ccode\x3erouter.beforeEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(to, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27全局前置守卫：beforeEach -- next需要调用\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e()\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一般在这个守卫方法中进行全局拦截，比如必须满足某种条件（用户登录等）才能进入路由的情况\x3c\/p\x3e\n\x3cp\x3e参数to和from都是路由对象\x3ccode\x3eRoute\x3c\/code\x3e\x3cbr\x3enext是个Function，有以下几种用法（from api文档）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3enext(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）\x3c\/li\x3e\n\x3cli\x3enext(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址  ——  也就是说并不是单纯的中断，还会检查URL的变更以保证不会错误的进入到next路由\x3c\/li\x3e\n\x3cli\x3enext(\x27\/\x27)\x26nbsp;或者\x26nbsp;next({ path: \x27\/\x27 }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。可传递的参数与router.push中选项一致\x3c\/li\x3e\n\x3cli\x3enext(error): (v2.4.0\x2b) 如果传入\x26nbsp;\x3ccode\x3enext\x3c\/code\x3e\x26nbsp;的参数是一个\x26nbsp;\x3ccode\x3eError\x3c\/code\x3e\x26nbsp;实例，则导航会被终止且该错误会被传递给\x26nbsp;\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/api\/router-instance.html#%E6%96%B9%E6%B3%95\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3erouter.onError()\x3c\/code\x3e\x3c\/a\x3e\x26nbsp;注册过的回调\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3erouter.beforeResolve (v 2.5.0\x2b)\x3c\/h3\x3e\n\x3cp\x3e全局解析守卫\x3c\/p\x3e\n\x3cp\x3e和beforeEach类似，区别是在\x3cstrong\x3e导航被确认之前\x3c\/strong\x3e，同时在所有\x3cstrong\x3e组件内守卫和异步路由组件被解析之后\x3c\/strong\x3e，解析守卫就被调用\x3cbr\x3e即在 beforeEach 和 组件内beforeRouteEnter 之后\x3c\/p\x3e\n\x3cp\x3e参数和beforeEach一致，也需要调用next对导航确认\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3erouter.afterEach\x3c\/h3\x3e\n\x3cp\x3e全局后置钩子\x3cbr\x3e在所有路由跳转结束的时候调用\x3cbr\x3e这些钩子不会接受 next 函数也不会改变导航本身\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ebeforeEnter\x3c\/h3\x3e\n\x3cp\x3e可直接定义在路由配置上，和beforeEach方法参数、用法相同\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e路由守卫 —— 组件内\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3ebeforeRouteEnter\x3c\/h3\x3e\n\x3cp\x3e在渲染该组件的对应路由被\x3ccode\x3e确认\x3c\/code\x3e前调用，用法和参数与beforeEach类似，\x3cstrong\x3enext需要被主动调用\x3c\/strong\x3e\x3cbr\x3e注意：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e此时组件实例还未被创建，不能访问this\x3c\/li\x3e\n\x3cli\x3e可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22beforeRouteEnter (to, from, next) {\n  \/\/ 这里还无法访问到组件实例，this === undefined\n  next( vm =\x3e {\n    \/\/ 通过 `vm` 访问组件实例\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ruby\x22\x3e\x3ccode\x3ebeforeRouteEnter (to, from, \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 这里还无法访问到组件实例，this === undefined\n  \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e( vm =\x26gt; {\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 通过 \x3cspan class=\x22hljs-string\x22\x3e`vm`\x3c\/span\x3e 访问组件实例\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通过 \x3ccode\x3evm\x3c\/code\x3e访问组件实例进行赋值等操作\x3c\/li\x3e\n\x3cli\x3ebeforeRouteEnter触发在导航确认、组件实例创建之前：beforeCreate之前；而next中函数的调用在mounted之后：为了确保能对组件实例的完整访问\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3ebeforeRouteUpdate (v 2.2\x2b)\x3c\/h3\x3e\n\x3cp\x3e在当前路由改变，并且该组件被复用时调用，可以通过this访问实例， \x3cstrong\x3enext需要被主动调用，不能传回调\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e对于一个带有动态参数的路径 \/foo\/:id，在 \/foo\/1 和 \/foo\/2 之间跳转的时候，组件实例会被复用，该守卫会被调用\x3c\/li\x3e\n\x3cli\x3e当前路由query变更时，该守卫会被调用\x3c\/li\x3e\n\x3cli\x3evue-router推荐的数据获取方法二中，结合beforeRouteEnter使用，在路由参数变更时可以重新获取数据，获取成功再调用next()，参考：\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/advanced\/data-fetching.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/router.vuejs.org\/zh-c...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e之前在手机浏览器中好像发现这个守卫的bug？@TODO 待确认\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3ebeforeRouteLeave\x3c\/h3\x3e\n\x3cp\x3e导航离开该组件的对应路由时调用，可以访问组件实例 \x3ccode\x3ethis\x3c\/code\x3e，\x3cstrong\x3enext需要被主动调用，不能传回调\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e结合并扩展Vue-router官方文档的说明：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e导航行为被触发\x3c\/strong\x3e，此时导航未被确认。\x3c\/li\x3e\n\x3cli\x3e在失活的组件里调用离开守卫 beforeRouteLeave。\x3c\/li\x3e\n\x3cli\x3e调用全局的 beforeEach 守卫。\x3c\/li\x3e\n\x3cli\x3e在重用的组件里调用 beforeRouteUpdate 守卫 (2.2\x2b)。\x3c\/li\x3e\n\x3cli\x3e在路由配置里调用 beforeEnter。\x3c\/li\x3e\n\x3cli\x3e解析异步路由组件（如果有）。\x3c\/li\x3e\n\x3cli\x3e在被激活的组件里调用 beforeRouteEnter。\x3c\/li\x3e\n\x3cli\x3e调用全局的 beforeResolve 守卫 (2.5\x2b)，标示解析阶段完成。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e导航被确认\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e调用全局的 afterEach 钩子。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e非重用组件，开始\x3cstrong\x3e组件实例的生命周期\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ebeforeCreate\x26amp;created\x3c\/li\x3e\n\x3cli\x3ebeforeMount\x26amp;mounted\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e触发 DOM 更新。\x3c\/li\x3e\n\x3cli\x3e用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。\x3c\/li\x3e\n\x3cli\x3e\x3cstrong\x3e导航完成\x3c\/strong\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013956949\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013956949\x22 alt=\x22路由守卫与组件生命周期-首次\x22 title=\x22路由守卫与组件生命周期-首次\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue2.0生命周期（组件钩子函数与路由守卫）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013956945">https://segmentfault.com/a/1190000013956945</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/s9351b0nhe/" target="_blank">https://alili.tech/archive/s9351b0nhe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>