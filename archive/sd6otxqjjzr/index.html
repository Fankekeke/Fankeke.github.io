<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一篇文章教会你Event loop——浏览器和Node"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一篇文章教会你Event loop——浏览器和Node | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/sd6otxqjjzr/",
				"appid": "1613049289050283", 
				"title": "一篇文章教会你Event loop——浏览器和Node | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-09T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/stytndigxun/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2a1b5zufrok/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&text=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&text=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&is_video=false&description=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsd6otxqjjzr%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%95%99%e4%bc%9a%e4%bd%a0Event%20loop%e2%80%94%e2%80%94%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNode"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一篇文章教会你Event loop——浏览器和Node</h1><div class="meta"><div class="postdate"><time datetime="2018-12-09" itemprop="datePublished">2018-12-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e最近对Event loop比较感兴趣，所以了解了一下。但是发现整个Event loop尽管有很多篇文章，但是没有一篇可以看完就对它所有内容都了解的文章。大部分的文章都只阐述了浏览器或者Node二者之一，没有对比的去看的话，认识总是浅一点。所以才有了这篇整理了百家之长的文章。\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. 定义\x3c\/h2\x3e\n\x3cblockquote\x3eEvent loop：为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。（3月29修订）\x3c\/blockquote\x3e\n\x3cp\x3e那什么是事件？\x3c\/p\x3e\n\x3cblockquote\x3e事件：事件就是由于某种外在或内在的信息状态发生的变化，从而导致出现了对应的反应。比如说用户点击了一个按钮，就是一个事件；HTML页面完成加载，也是一个事件。一个事件中会包含多个任务。\x3c\/blockquote\x3e\n\x3cp\x3e我们在之前的文章中提到过，JavaScript引擎又称为JavaScript解释器，是JavaScript解释为机器码的工具，分别运行在浏览器和Node中。而根据上下文的不同，Event loop也有不同的实现：其中Node使用了libuv库来实现Event loop; 而在浏览器中，html规范定义了Event loop，具体的实现则交给不同的厂商去完成。\x3c\/p\x3e\n\x3cp\x3e所以，\x3cstrong\x3e浏览器的Event loop和Node的Event loop是两个概念\x3c\/strong\x3e，下面分别来看一下。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2. 意义\x3c\/h2\x3e\n\x3cp\x3e在实际工作中，了解Event loop的意义能帮助你\x3cstrong\x3e分析一些异步次序的问题\x3c\/strong\x3e（当然，随着es7 async和await的流行，这样的机会越来越少了）。除此以外，它还对你\x3cstrong\x3e了解浏览器和Node的内部机制\x3c\/strong\x3e有积极的作用；对于\x3cstrong\x3e参加面试\x3c\/strong\x3e，被问到一堆异步操作的执行顺序时，也不至于两眼抓瞎。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3. 浏览器上的实现\x3c\/h2\x3e\n\x3cp\x3e在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。它们分别包含以下内容：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cstrong\x3eMacroTask\x3c\/strong\x3e: script(整体代码), setTimeout, setInterval, setImmediate（node独有）, I\/O, UI rendering\x3cbr\x3e\x3cstrong\x3eMicroTask\x3c\/strong\x3e: process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver\x3c\/blockquote\x3e\n\x3cp\x3e需要\x3cstrong\x3e注意\x3c\/strong\x3e的一点是：在同一个上下文中，\x3cstrong\x3e总的执行顺序为同步代码—\x26gt;microTask—\x26gt;macroTask\x3c\/strong\x3e[6]。这一块我们在下文中会讲。\x3c\/p\x3e\n\x3cp\x3e浏览器中，一个事件循环里有很多个来自不同任务源的任务队列（task queues），每一个任务队列里的任务是严格按照\x3cstrong\x3e先进先出\x3c\/strong\x3e的顺序执行的。但是，因为\x3cstrong\x3e浏览器自己调度\x3c\/strong\x3e的关系，\x3cstrong\x3e不同任务队列的任务的执行顺序是不确定\x3c\/strong\x3e的。\x3c\/p\x3e\n\x3cp\x3e具体来说，浏览器会不\x3cstrong\x3e断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空\x3c\/strong\x3e（执行完一个task的具体标志是函数执行栈为空），\x3cstrong\x3e如果不为空则会一次性执行完所有microtask\x3c\/strong\x3e。然后再进入下一个循环去task队列中取下一个task执行，以此类推。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6itK?w=810\x26amp;h=414\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6itK?w=810\x26amp;h=414\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e注意：图中橙色的MacroTask任务队列也应该是在不断被切换着的。\x3c\/p\x3e\n\x3cp\x3e本段大批量引用了《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010622146\x22\x3e什么是浏览器的事件循环（Event Loop）\x3c\/a\x3e》的相关内容，想看更加详细的描述可以自行取用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e4. Node上的实现\x3c\/h2\x3e\n\x3cp\x3enodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3etimers：执行setTimeout() 和 setInterval()中到期的callback。\x3c\/li\x3e\n\x3cli\x3eI\/O callbacks：上一轮循环中有少数的I\/Ocallback会被延迟到这一轮的这一阶段执行\x3c\/li\x3e\n\x3cli\x3eidle, prepare：队列的移动，仅内部使用\x3c\/li\x3e\n\x3cli\x3epoll：最为重要的阶段，执行I\/O callback，在适当的条件下会阻塞在这个阶段\x3c\/li\x3e\n\x3cli\x3echeck：执行setImmediate的callback\x3c\/li\x3e\n\x3cli\x3eclose callbacks：执行close事件的callback，例如socket.on(\x22close\x22,func)\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cp\x3e不同于浏览器的是，在每个阶段完成后，而不是MacroTask任务完成后，microTask队列就会被执行。这就导致了\x3cstrong\x3e同样的代码在不同的上下文环境下会出现不同的结果\x3c\/strong\x3e。我们在下文中会探讨。\x3c\/p\x3e\n\x3cp\x3e另外需要\x3cstrong\x3e注意\x3c\/strong\x3e的是，如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV6iwC?w=655\x26amp;h=503\x22 src=\x22https:\/\/static.alili.tech\/img\/bV6iwC?w=655\x26amp;h=503\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e5. 示例\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e5.1 浏览器与Node执行顺序的区别\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(()=\x3e{\n    console.log(\x27timer1\x27)\n\n    Promise.resolve().then(function() {\n        console.log(\x27promise1\x27)\n    })\n}, 0)\n\nsetTimeout(()=\x3e{\n    console.log(\x27timer2\x27)\n\n    Promise.resolve().then(function() {\n        console.log(\x27promise2\x27)\n    })\n}, 0)\n\n\n\n浏览器输出：\ntime1\npromise1\ntime2\npromise2\n\nNode输出：\ntime1\ntime2\npromise1\npromise2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timer1\x27\x3c\/span\x3e)\n\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise1\x27\x3c\/span\x3e)\n    })\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timer2\x27\x3c\/span\x3e)\n\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise2\x27\x3c\/span\x3e)\n    })\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\n\n\n浏览器输出：\ntime1\npromise1\ntime2\npromise2\n\nNode输出：\ntime1\ntime2\npromise1\npromise2\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，Node的逻辑如下：\x3c\/p\x3e\n\x3cp\x3e最初timer1和timer2就在timers阶段中。开始时首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；\x3cbr\x3e至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。\x3c\/p\x3e\n\x3cp\x3e而浏览器则因为两个setTimeout作为两个MacroTask, 所以先输出timer1, promise1，再输出timer2，promise2。\x3c\/p\x3e\n\x3cp\x3e更加详细的信息可以查阅《\x3ca href=\x22http:\/\/lynnelv.github.io\/js-event-loop-nodejs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e深入理解js事件循环机制（Node.js篇）\x3c\/a\x3e》\x3c\/p\x3e\n\x3cp\x3e为了证明我们的理论，把代码改成下面的样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setImmediate(() =\x3e {\n  console.log(\x27timer1\x27)\n\n  Promise.resolve().then(function () {\n    console.log(\x27promise1\x27)\n  })\n})\n\nsetTimeout(() =\x3e {\n  console.log(\x27timer2\x27)\n\n  Promise.resolve().then(function () {\n    console.log(\x27promise2\x27)\n  })\n}, 0)\n\nNode输出：\ntimer1               timer2\npromise1    或者     promise2\ntimer2               timer1\npromise2             promise1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timer1\x27\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise1\x27\x3c\/span\x3e)\n  })\n})\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27timer2\x27\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27promise2\x27\x3c\/span\x3e)\n  })\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\nNode输出：\ntimer1               timer2\npromise1    或者     promise2\ntimer2               timer1\npromise2             promise1\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e按理说\x3ccode\x3esetTimeout(fn,0)\x3c\/code\x3e应该比\x3ccode\x3esetImmediate(fn)\x3c\/code\x3e快，应该只有第二种结果，为什么会出现两种结果呢？\x3cbr\x3e这是因为Node 做不到0毫秒，最少也需要1毫秒。实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。\x3c\/p\x3e\n\x3cp\x3e另外，如果已经过了Timer阶段，那么setImmediate会比setTimeout更快，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\n\nfs.readFile(\x27test.js\x27, () =\x3e {\n  setTimeout(() =\x3e console.log(1));\n  setImmediate(() =\x3e console.log(2));\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\nfs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27test.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\n  setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e));\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码会先进入 I\/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。\x3c\/p\x3e\n\x3cp\x3e具体可以看《\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2018\/02\/node-event-loop.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode 定时器详解\x3c\/a\x3e》。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e5.2 不同异步任务执行的快慢\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(() =\x3e console.log(1));\nsetImmediate(() =\x3e console.log(2));\n\nPromise.resolve().then(() =\x3e console.log(3));\nprocess.nextTick(() =\x3e console.log(4));\n\n\n输出结果：4 3 1 2或者4 3 2 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3esetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\nsetImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e));\n\nPromise.resolve().\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e));\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e));\n\n\n输出结果：\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e或者\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为我们上文说过microTask会优于macroTask运行，所以先输出下面两个，而在Node中process.nextTick比Promise更加优先[3]，所以4在3前。而根据我们之前所说的Node没有绝对意义上的0ms，所以1,2的顺序不固定。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e5.3 MicroTask队列与MacroTask队列\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   setTimeout(function () {\n       console.log(1);\n   },0);\n   console.log(2);\n   process.nextTick(() =\x3e {\n       console.log(3);\n   });\n   new Promise(function (resolve, rejected) {\n       console.log(4);\n       resolve()\n   }).then(res=\x3e{\n       console.log(5);\n   })\n   setImmediate(function () {\n       console.log(6)\n   })\n   console.log(\x27end\x27);\n\nNode输出：\n2 4 end 3 5 1 6\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e   setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n   },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n   process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n   });\n   \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve, rejected\x3c\/span\x3e) \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n       resolve()\n   }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n   })\n   setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e)\n   })\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e);\n\nNode输出：\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e end \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子来源于《\x3ca href=\x22https:\/\/juejin.im\/post\/5a623a11f265da3e2d33846b#heading-1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript中的执行机制\x3c\/a\x3e》。Promise的代码是同步代码，then和catch才是异步的，所以4要同步输出，然后Promise的then位于microTask中，优于其他位于macroTask队列中的任务，所以5会优于1,6输出，而Timer优于Check阶段,所以1,6。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e6. 总结\x3c\/h2\x3e\n\x3cp\x3e综上，关于最关键的顺序，我们要\x3cstrong\x3e依据以下几条规则\x3c\/strong\x3e:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e同一个上下文下，MicroTask会比MacroTask先运行\x3c\/li\x3e\n\x3cli\x3e然后浏览器按照一个MacroTask任务，所有MicroTask的顺序运行，Node按照六个阶段的顺序运行，并在每个阶段后面都会运行MicroTask队列\x3c\/li\x3e\n\x3cli\x3e同个MicroTask队列下\x3ccode\x3eprocess.tick()\x3c\/code\x3e会优于\x3ccode\x3ePromise\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eEvent loop还是比较深奥的，深入进去会有很多有意思的东西，有任何问题还望不吝指出。\x3c\/p\x3e\n\x3ch4\x3e参考文档：\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010622146\x22\x3e什么是浏览器的事件循环（Event Loop）\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/cnodejs.org\/topic\/5a9108d78d6e16e56bb80882\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不要混淆nodejs和浏览器中的event loop\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2018\/02\/node-event-loop.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode 定时器详解\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000013660033\x22\x3e浏览器和Node不同的事件循环（Event Loop）\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22http:\/\/lynnelv.github.io\/js-event-loop-nodejs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e深入理解js事件循环机制（Node.js篇）\x3c\/a\x3e》\x3c\/li\x3e\n\x3cli\x3e《\x3ca href=\x22https:\/\/juejin.im\/post\/5a623a11f265da3e2d33846b#heading-1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript中的执行机制\x3c\/a\x3e》\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一篇文章教会你Event loop——浏览器和Node</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013861128">https://segmentfault.com/a/1190000013861128</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/sd6otxqjjzr/" target="_blank">https://alili.tech/archive/sd6otxqjjzr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>