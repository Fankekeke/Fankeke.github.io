<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【React系列】如何构建React应用程序"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【React系列】如何构建React应用程序 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/sw4ts5hb99/",
				"appid": "1613049289050283", 
				"title": "【React系列】如何构建React应用程序 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/y18wkfg5crg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ezt32nw2eyh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&text=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&text=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&title=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&is_video=false&description=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&title=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&title=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&title=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsw4ts5hb99%2f&title=%e3%80%90React%e7%b3%bb%e5%88%97%e3%80%91%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%baReact%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【React系列】如何构建React应用程序</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e前面几篇内容简单整理了一些React的基础知识点，以方便大家能够简单的了解React的一些相关概念。在本节中，我们来试着以一个简单的例子来分析，如何构建一个React应用程序，该如何去思考。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e首先，我们来选择比较常见的一个示例程序：TodoList来作为本次的分析案例。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVU6Se?w=360\x26amp;h=112\x22 src=\x22https:\/\/static.alili.tech\/img\/bVU6Se?w=360\x26amp;h=112\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面是一个简单的TodoList的的样子，此处并没有进行样式修饰，大家可以后面自己完善。我们将按照以下几个步骤进行分析设计：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e步骤1：将 UI 拆解到组件层次结构中\x3c\/h2\x3e\n\x3cp\x3e当我们拿到一个UI设计时，需要我们将之进行拆解，使之成为由每个组件（和子组件）的结构构成的一个整体，并且可以根据功能给各个部分进行命名。\x3c\/p\x3e\n\x3cp\x3e但是你该如何拆分组件呢？其实只需要像拆分一个新方法或新对象一样的方式即可。一个常用的技巧是\x3cstrong\x3e单一职责原则\x3c\/strong\x3e，即一个组件理想情况下只处理一件事。如果一个组件持续膨胀，就应该将其拆分为多个更小的组件中。\x3c\/p\x3e\n\x3cp\x3eReact最大的卖点是轻量组件化。我们分析一下以上截图中的页面，如果要分组件的话，我们大约可以分成一个总组件和两个子组件。一个输入内容的组件，一个显示内容列表（带删除功能）的组件，外面再用一个总组件将两个子组件包括起来。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVU6WI?w=577\x26amp;h=117\x22 src=\x22https:\/\/static.alili.tech\/img\/bVU6WI?w=577\x26amp;h=117\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这样，我们的应用程序的结构就清晰了：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3etodoList --- 整个应用程序用例\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3etypeNew  ---  接收用户的输入\x3c\/li\x3e\n\x3cli\x3elistTodo ---  显示所有的list item\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e步骤2： 用 React 构建一个静态版本\x3c\/h2\x3e\n\x3cp\x3e通过上面的结构划分，我们代码的整体结构大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\nimport \x27.\/index.css\x27;\n\n\n\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\n\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\nclass TodoList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      todoList: []\n    }\n  }\n  render() {\n      return (\n          \x3cdiv\x3e\n              \x3cTypeNew  \/\x3e\n              \x3cListTodo \/\x3e\n          \x3c\/div\x3e\n      );\n  }\n};\n\n\/\/ TypeNew 组件用于新增数据，\nclass TypeNew extends Component {\n  render() {\n      return (\n          \x3cform\x3e\n              \x3cinput type=\x26quot;text\x26quot; placeholder=\x26quot;typing a newthing todo\x26quot; autoComplete=\x26quot;off\x26quot; \/\x3e\n          \x3c\/form\x3e\n      );\n  }\n};\n\n\/\/ ListTodo 组件用于展示列表，并可以删除某一项内容，\nclass ListTodo extends Component {\n  render() {\n      return (\n          \x3cul id=\x26quot;todo-list\x26quot;\x3e\n              {\/* 其中显示数据列表 *\/}\n          \x3c\/ul\x3e\n      );\n  }\n};\n\n\/\/ 将 TodoList 组件渲染到页面\nReactDOM.render(\x3cTodoList \/\x3e, document.getElementById(\x27root\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27react\x3c\/span\x3e-dom\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x27.\/index.css\x27;\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      todoList: []\n    }\n  }\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;div\x26gt;\n              \x26lt;\x3cspan class=\x22hljs-type\x22\x3eTypeNew\x3c\/span\x3e  \/\x26gt;\n              \x26lt;\x3cspan class=\x22hljs-type\x22\x3eListTodo\x3c\/span\x3e \/\x26gt;\n          \x26lt;\/div\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeNew 组件用于新增数据，\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTypeNew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;form\x26gt;\n              \x26lt;input \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e placeholder=\x3cspan class=\x22hljs-string\x22\x3e\x22typing a newthing todo\x22\x3c\/span\x3e autoComplete=\x3cspan class=\x22hljs-string\x22\x3e\x22off\x22\x3c\/span\x3e \/\x26gt;\n          \x26lt;\/form\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ListTodo 组件用于展示列表，并可以删除某一项内容，\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eListTodo\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;ul id=\x3cspan class=\x22hljs-string\x22\x3e\x22todo-list\x22\x3c\/span\x3e\x26gt;\n              {\x3cspan class=\x22hljs-comment\x22\x3e\/* 其中显示数据列表 *\/\x3c\/span\x3e}\n          \x26lt;\/ul\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 TodoList 组件渲染到页面\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eTodoList\x3c\/span\x3e \/\x26gt;, document.getElementById(\x3cspan class=\x22hljs-symbol\x22\x3e\x27roo\x3c\/span\x3et\x27));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e目前为止你已经有了组件层次结构，现在是时候实现你的 app 了。最简单的方法是构建一个采用数据模型并渲染 UI 但没有交互性的版本。最好解耦这些处理，因为构建静态版本需要 大量的代码 和 少量的思考，而添加交互需要 大量思考 和 少量的代码。我们将看到原因。\x3c\/p\x3e\n\x3cp\x3e要构建你 app 的一个静态版本，用于渲染数据模型， 您将需要构建复用其他组件并使用 props 传递数据的组件。props 是将数据从 父级组件 传递到 子级 的一种方式。如果你熟悉 state 的概念，在构建静态版本时 \x3cem\x3e不要使用 \x3c\/em\x3estate ** 。state 只用于交互，也就是说，数据可以随时被改变。由于这是一个静态版本 app，所以你并不需要使用 state 。\x3c\/p\x3e\n\x3cp\x3e您可以 自上而下 或 自下而上 构建。也就是说，您可以从构建层次结构中顶端的组件开始（即从 FilterableProductTable 开始），也可以从构建层次结构中底层的组件开始（即 ProductRow ）。在更简单的例子中，通常 自上而下 更容易，而在较大的项目中，自下而上，更有利于编写测试。\x3c\/p\x3e\n\x3cp\x3e在这一步结束时，你已经有了一个可重用的组件库，用于渲染你的数据模型。组件将只有 render() 方法，因为这是你应用程序的静态版本。层次结构顶部的组件（ FilterableProductTable ）应该接收你的数据模型作为 prop 。如果您对基础数据模型进行更改，并再次调用 ReactDOM.render()，UI 将同步更新。这有利于观测UI的更新以及相关的数据变化，因为这中间没有做什么复杂的事情。React 的 单向数据流（也称为 单向绑定 ）使所有模块化和高性能。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e♥ 小插曲 区分: Props(属性) vs State(状态)\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e步骤3： 确定 UI state(状态) 的最小（但完整）表示\x3c\/h2\x3e\n\x3cp\x3e为了你的 UI 可以交互，你需要能够触发更改底层的数据模型。React 通过 state 使其变得容易。\x3c\/p\x3e\n\x3cp\x3e要正确的构建应用程序，你首先需要考虑你的应用程序需要的可变 state(状态) 的最小集合。这里的关键是：不要重复你自己 (DRY，don\x27t repeat yourself)。找出你的应用程序所需 state(状态) 的绝对最小表示，并且可以以此计算出你所需的所有其他数据内容。正如我们在构建一个 TODO 列表，只保留一个 TODO 元素数组即可;不需要为元素数量保留一个单独的 state(状态) 变量。相反，当你要渲染 TODO 计数时，只需要获取 TODO 数组的长度即可。\x3c\/p\x3e\n\x3cp\x3e在我们的例子中，主要出现的数据有两个，一个是todo列表，一个是用户输入的新的todo项目，todo列表会根据用户的添加和删除发生变化，可以认为是属于state的，对于用户输入的todo项目，我们发现它只是一个中间的临时值，并不需要设置相应的变量进行存储，所以我们的最终的State是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3etodo列表\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e步骤4：确定 state(状态) 的位置\x3c\/h2\x3e\n\x3cp\x3e既然是展示数据，首先要考虑数据存储在哪里，来自于哪里。现在这里放一句话——React提倡所有的数据都是由父组件来管理，通过props的形式传递给子组件来处理——先记住，接下来再解释这句话。\x3c\/p\x3e\n\x3cp\x3e上面提到，做一个todolist页面需要一个父组件，两个子组件。父组件当然就是todolist的『总指挥』，两个子组件分别用来add和show、delete。用通俗的方式讲来，父组件就是领导，两个子组件就是协助领导开展工作的，一切的资源和调动资源的权利，都在领导层级，子组件配合领导工作，需要资源或者调动资源，只能申请领导的批准。\x3c\/p\x3e\n\x3cp\x3e这么说来就明白了吧。数据完全由父组件来管理和控制，子组件用来显示、操作数据，得经过父组件的批准，即——父组件通过props的形式将数据传递给子组件，子组件拿到父组件传递过来的数据，再进行展示。\x3c\/p\x3e\n\x3cp\x3e另外，根据React开发的规范，组件内部的数据由state控制，外部对内部传递数据时使用 props 。这么看来，针对父组件来说，要存储todolist的数据，那就是内部信息（本身就是自己可控的资源，而不是『领导』控制的资源），用state来存储即可。而父组件要将todolist数据传递给子组件，对子组件来说，那就是传递进来的外部信息（是『领导』的资源，交付给你来处理），需要使用props。\x3c\/p\x3e\n\x3cp\x3e此时我们的代码可以修改为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\n\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\nclass TodoList extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        todoList: []\n      }\n    }\n\n    render() {\n        return (\n            \x3cdiv\x3e\n                \x3cTypeNew  \/\x3e\n                \x3cListTodo \/\x3e\n            \x3c\/div\x3e\n        );\n    };\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(props) {\n      \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n        todoList: []\n      }\n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;\n                \x26lt;\x3cspan class=\x22hljs-type\x22\x3eTypeNew\x3c\/span\x3e  \/\x26gt;\n                \x26lt;\x3cspan class=\x22hljs-type\x22\x3eListTodo\x3c\/span\x3e \/\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    };\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，已经确定了应用所需 state(状态) 的最小集合。接下来，需要确定是哪个组件可变，或者说哪个组件拥有这些 state(状态) 。\x3c\/p\x3e\n\x3cp\x3e记住：React 单向数据流在层级中自上而下进行。这样有可能不能立即判断出状态属于哪个组件。这常常是新手最难理解的一部分，试着按下面的步骤分析操作：\x3c\/p\x3e\n\x3cp\x3e对于你应用中的每一个 state(状态) ：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e确定每个基于这个 state(状态) 渲染的组件。\x3c\/li\x3e\n\x3cli\x3e找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。\x3c\/li\x3e\n\x3cli\x3e公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。\x3c\/li\x3e\n\x3cli\x3e如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e步骤5：添加反向数据流\x3c\/h2\x3e\n\x3cp\x3e目前，构建的应用已经具备了正确渲染 props(属性) 和 state(状态) 沿着层次结构向下传播的功能。现在是时候实现另一种数据流方式：层次结构中深层的 form(表单) 组件需要更新 TodoList中的 state(状态) 。\x3c\/p\x3e\n\x3cp\x3e想想我们希望发生什么。我们期望当用户改变表单输入进行提交的时候，我们更新 state(状态) 来反映用户的输入。由于组件只能更新它们自己的 state(状态) ，TodoList将传递回调到 TypeNew，然后在 state(状态) 被更新的时候触发。我们可以使用表单的onSubmit事件来接收通知。而且通过 TodoList传递的回调调用 setState()，然后应用被更新。同理删除处理在ListTodo中触发按钮的点击onClick事件来调用TodoList传递的回掉函数来更新删除后的state。\x3c\/p\x3e\n\x3cp\x3e最终我们的代码结果如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\nimport \x27.\/index.css\x27;\n\n\n\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\n\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\nclass TodoList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      todoList: []\n    }\n    this.handleAddNewItem = this.handleAddNewItem.bind(this);\n    this.handleDelItem = this.handleDelItem.bind(this);\n  }\n\n  handleAddNewItem(todo) {\n    var todoList = this.state.todoList;\n    if(todo === \x26quot;\x26quot;) {\n      return;\n    }\n    todoList.push(todo);\n    this.setState({\n      todoList: todoList\n    })\n  }\n\n  handleDelItem(index) {\n    var todoList = this.state.todoList;\n    todoList.splice(index, 1);\n    this.setState({\n      todoList: todoList\n    })\n  }\n\n  render() {\n      return (\n          \x3cdiv\x3e\n              \x3cTypeNew typeNewItem={this.handleAddNewItem} \/\x3e\n              \x3cListTodo todoList={this.state.todoList} onDelItem={this.handleDelItem} \/\x3e\n          \x3c\/div\x3e\n      );\n  }\n};\n\n\/\/ TypeNew 组件用于新增数据，\nclass TypeNew extends Component {\n  constructor(props){\n    super(props);\n    this.onHandleAddNewItem = this.onHandleAddNewItem.bind(this);\n  }\n  onHandleAddNewItem(e) {\n    e.preventDefault();\n    var inputDom = this.textInput;\n    var newthing = inputDom.value.trim();\n    this.props.typeNewItem(newthing);\n    inputDom.value = \x27\x27;\n  }\n  render() {\n      return (\n          \x3cform onSubmit={this.onHandleAddNewItem}\x3e\n              \x3cinput type=\x26quot;text\x26quot; ref={(input) =\x3e { this.textInput = input; \x22}}\x22 placeholder=\x26quot;typing a newthing todo\x26quot; autoComplete=\x26quot;off\x26quot; \/\x3e\n          \x3c\/form\x3e\n      );\n  }\n};\n\n\/\/ ListTodo 组件用于展示列表，并可以删除某一项内容，\nclass ListTodo extends Component {\n  constructor(props){\n    super(props);\n    this.onHandleDelItem = this.onHandleDelItem.bind(this);\n  }\n\n  onHandleDelItem(e){\n    this.props.onDelItem(e.target.getAttribute(\x26quot;data-key\x26quot;));\n  }\n\n  render() {\n      return (\n          \x3cul id=\x26quot;todo-list\x26quot;\x3e\n              {\n                \/\/ this.props.todo 获取父组件传递过来的数据\n                \/\/ {\/* 遍历数据 *\/}\n                this.props.todoList.map(function (item, i) {\n                    return (\n                        \x3cli\x3e\n                            \x3clabel\x3e{item}\x3c\/label\x3e\n                            \x3cbutton onClick={this.onHandleDelItem} data-key={i}\x3edelete\x3c\/button\x3e\n                        \x3c\/li\x3e                     \n                      );\n                }.bind(this))\n              }\n          \x3c\/ul\x3e\n      );\n  }\n};\n\n\/\/ 将 TodoList 组件渲染到页面\nReactDOM.render(\x3cTodoList \/\x3e, document.getElementById(\x27root\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } from \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM from \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/index.css\x27\x3c\/span\x3e;\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TodoList 组件是一个整体的组件，最终的React渲染也将只渲染这一个组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该组件用于将『新增』和『列表』两个组件集成起来\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoList\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      todoList: []\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleAddNewItem = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleAddNewItem.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleDelItem = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleDelItem.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n\n  handleAddNewItem(todo) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e todoList = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.todoList;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(todo === \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    todoList.push(todo);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      todoList: todoList\n    })\n  }\n\n  handleDelItem(index) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e todoList = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.todoList;\n    todoList.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      todoList: todoList\n    })\n  }\n\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;div\x26gt;\n              \x26lt;TypeNew typeNewItem={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleAddNewItem} \/\x26gt;\n              \x26lt;ListTodo todoList={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.todoList} onDelItem={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleDelItem} \/\x26gt;\n          \x26lt;\/div\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeNew 组件用于新增数据，\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTypeNew\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props){\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleAddNewItem = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleAddNewItem.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n  onHandleAddNewItem(e) {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inputDom = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.textInput;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newthing = inputDom.value.trim();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.typeNewItem(newthing);\n    inputDom.value = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n  }\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;form onSubmit={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleAddNewItem}\x26gt;\n              \x26lt;input type=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e ref={(input) =\x26gt; { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.textInput = input; \x22}}\x22 placeholder=\x3cspan class=\x22hljs-string\x22\x3e\x22typing a newthing todo\x22\x3c\/span\x3e autoComplete=\x3cspan class=\x22hljs-string\x22\x3e\x22off\x22\x3c\/span\x3e \/\x26gt;\n          \x26lt;\/form\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ListTodo 组件用于展示列表，并可以删除某一项内容，\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eListTodo\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props){\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleDelItem = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleDelItem.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n\n  onHandleDelItem(e){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onDelItem(e.target.getAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x22data-key\x22\x3c\/span\x3e));\n  }\n\n  render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n          \x26lt;ul id=\x3cspan class=\x22hljs-string\x22\x3e\x22todo-list\x22\x3c\/span\x3e\x26gt;\n              {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.props.todo 获取父组件传递过来的数据\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ {\/* 遍历数据 *\/}\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.todoList.map(function (item, i) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n                        \x26lt;li\x26gt;\n                            \x26lt;label\x26gt;{item}\x26lt;\/label\x26gt;\n                            \x26lt;button onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHandleDelItem} \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e-key={i}\x26gt;delete\x26lt;\/button\x26gt;\n                        \x26lt;\/li\x26gt;                     \n                      );\n                }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e))\n              }\n          \x26lt;\/ul\x26gt;\n      );\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 TodoList 组件渲染到页面\x3c\/span\x3e\nReactDOM.render(\x26lt;TodoList \/\x26gt;, document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面就是我们一步步进行分析拆分来设计我们的应用程序的过程。由于例子比较简单，所以相对来说思路更加清晰，当我们面对大型的应用程序时，往往分析方式会有所变化，但是根本的原理是不变的。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e参考资料\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.css88.com\/react\/docs\/thinking-in-react.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 的编程思想\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/wangfupeng1988\/p\/5302738.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用React并做一个简单的to-do-list\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【React系列】如何构建React应用程序</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011190715">https://segmentfault.com/a/1190000011190715</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/sw4ts5hb99/" target="_blank">https://alili.tech/archive/sw4ts5hb99/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>