<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="关于首屏时间采集自动化的解决方案"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>关于首屏时间采集自动化的解决方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/swcnaf8875m/",
				"appid": "1613049289050283", 
				"title": "关于首屏时间采集自动化的解决方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-16T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/lcd328w875h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/8hyd8c2wfzm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&text=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&text=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&title=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&is_video=false&description=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&title=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&title=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&title=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fswcnaf8875m%2f&title=%e5%85%b3%e4%ba%8e%e9%a6%96%e5%b1%8f%e6%97%b6%e9%97%b4%e9%87%87%e9%9b%86%e8%87%aa%e5%8a%a8%e5%8c%96%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">关于首屏时间采集自动化的解决方案</h1><div class="meta"><div class="postdate"><time datetime="2018-12-16" itemprop="datePublished">2018-12-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e关于首屏\x3c\/h2\x3e\n\x3cp\x3e首屏时间是指从转向该页面到屏幕中该页面所有内容都可见时的时间。已经有太多的关于首屏时间的计算，在本文中并不重复阐述这些已经被提出或者实现的方案，而旨在探索与讨论更多的首屏自动化采集方案，扩大思考范围，你我思想之间互相碰撞往往可以激起更多的稀奇古怪的解决方案，这也正是我写这篇文章的目的。\x3c\/p\x3e\n\x3cp\x3e通过浏览器调试工具，我们可以清晰的看出页面资源加载时序图：\x3c\/p\x3e\n\x3cp\x3e先是html页面加载，token进行词法、语法解析后开始加载静态资源并执行相关脚本，开始构建DOM树、render树和CSSOM数，最后加载图片，用户看到完整的网页。\x3c\/p\x3e\n\x3cp\x3e虽然浏览器有着各自的优化的解决方案，但是大多数情况下图片往往是最后加载完毕，这不仅仅是由于图片的大小相对较大，而且图片的加载与否与DOM结构有着很大的关系。DOM是否构建完毕，render树中是否渲染以及其他的图片加载策略有关系可能都会影响图片加载时序。因此在首屏时间的计算中，我们是以最终首屏图片的加载时间为节点计算的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e首屏计算\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e原则1 首屏计算模块不应该耦合业务线\x3c\/h3\x3e\n\x3cp\x3e一般而言，首屏计算作为一个抽离出的js脚本单独引用，这个模块尽量不暴露API给开发者使用，所有的采集端任务都由该模块完成。这句话可能听起来像一句废话，但还是有很多情况可能需要业务人员来进行首屏渲染时间的判断的，下面将针对这个情形举一个实际的场景：\x3c\/p\x3e\n\x3cp\x3e随着MVVM模式的兴起，前端异步渲染逐渐流行起来，前端编码逐渐由面向jQuery编程转向为面向Vue编程。可是使用Vue编写的业务代码在本地打包后仅仅是一个bundle，此时的HTML文件中只是一个 \x3cstrong\x3e\x26lt;div id=\x22app\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/strong\x3e 的占位符而已，那么首屏时间计算模块该如何准确的计算首屏时间呢？\x3cstrong\x3e因此首屏时间计算模块必须知道首屏的DOM结构渲染完毕的时间节点，在这个节点时刻进行计算首屏范围内的图片加载时间。\x3c\/strong\x3e 可是如何获取首屏DOM结构渲染完毕的时间节点呢？这就需要业务开发人员制定。在更新vue实例的data属性后，通知首屏计算模块此时DOM接口已渲染完毕，开始计算首屏时间。\x3c\/p\x3e\n\x3cp\x3eMVVM开发模式下，首屏时间的计算已经耦合了业务代码，虽然可以在保证首屏时间的准确性，但却给开发者带来了一些可观判断逻辑，而这些判断往往会困扰新入职的同志们，因此我们的目标之一就是解决需要手动打点进行首屏时间计算的现状。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e原则2 性能与准确性的权衡\x3c\/h3\x3e\n\x3cp\x3e业界有个通过canvas截屏并通过轮询对比不同时间点截屏图片之间某几个随机像素点，从而判断首屏是否加载完毕。这种方式虽然科学，但是估计没有几个公司会采用这种方案。通过canvas截屏这个操作对硬件的要求可能就比较高，而且需要进行额外的像素运算，因此性能肯定很差。其实这种场景在工程领域经常出现，工程不同于科学那般严谨，我们只需要找到给定条件的最优解即可，做工程也就是在做trade off。因此这种对比方案我们也必须摒弃。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e实现\x3c\/h2\x3e\n\x3cp\x3e再次强调，由开发者打点首屏DOM渲染完毕进行首屏时间计算的方式是相对准确的方式，因此我们后续讨论的自动化计算首屏时间的准确性都是基于此标准进行对比说明，因为自动化计算肯定是没有人工干预准确的，这一点毫无疑问。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e轮训采集大法\x3c\/h3\x3e\n\x3cp\x3e仍然是轮训，不同的是在每次轮询中执行一些操作：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e获取首屏的所有图片（包括IMG标签与css相关属性）\x3c\/li\x3e\n\x3cli\x3e绑定首屏图片的onload和onerror事件，每次轮询不会重复绑定已绑定的图片\x3c\/li\x3e\n\x3cli\x3e相同图片不需重复绑定事件侦听，否则会与 2 中的每次轮询混淆\x3c\/li\x3e\n\x3cli\x3e图片的事件处理函数执行打点信息并统计图片加载状态，同时比对时间戳得到最迟加载的时间\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e具体的实现中，需要特别注意首屏出现的相同图片的情况。笔者起初在获取首屏图片中简单计算图片的url数组，存储重复图片的个数，并且与该图片的加载状态绑定在一起。如首屏中出现了3张相同的图片，那么在该图片onload或onerror中对已加载图片的数量做 \x3cstrong\x3e加3\x3c\/strong\x3e 处理，否则导致最终的 \x3cstrong\x3e已加载图片总数 与 首屏图片总数 不相等的情况发生\x3c\/strong\x3e。这种实现导致逻辑非常的差，且实现复杂。后通过存储图片所在的DOM对象数组实现更为简单的图片状态判断，更加已读。\x3c\/p\x3e\n\x3cp\x3e伪代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ totalCounter为轮询的总时间\n\/\/ DemandCounter是规定的轮询总时间，为3000ms\n\/\/ imgsLoadedCount则为首屏已加载的图片数量\n\/\/ lastImageLoadedStamp为最后加载的图片时间戳\nfunction checkFirstScreenDomReady(){\n    if(totalCounter \x3e= DemandCounter){\n        \/\/ ...\n        var stamps = Object.keys(pools),\n        len = stamps.length,\n        i = 0,\n        it; \n        finalImgCount = pools[stamps[len - 1]].imgLen; \n        pollEnd = true;\n\n        for(;i\x3clen;i\x2b\x2b){\n            it = pools[stamps[i]];\n            if(it.imgLen == finalImgCount \x26amp;\x26amp; it.imgsLoadedCount \x3e= finalImgCount){\n                self.onRecord = true;\n                _perfQueue._firstScreenLoadEnd = lastImageLoadedStamp;\n                firstScreen.firstScreenLoadEnd = lastImageLoadedStamp;\n                firstScreen.duaring = lastImageLoadedStamp - performance.timing.navigationStart;\n                \n                reportData(firstScreen);\n                return;\n            }\n        }\n        return;\n    }\n    \n    var imgEls = getImage();\n\n    imgEls.forEach(function(el) {\n        if(!imgLoadedHash.get(el)){\n            var img = new Image();\n            imgLoadedHash.put(el,{\n                loaded: true,\n            });\n            img.onload = OnLoad;\n            img.onerror = OnError;\n            img.src = el.__src;\n        }\n    });\n    pools[totalCounter\x2b\x27\x27] = {\n        imgLen: imgEls.length,\n        stamp: Date.now(),\n        imgsLoadedCount: imgsLoadedCount\n    };\n    totalCounter \x2b= timeout;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ totalCounter为轮询的总时间\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ DemandCounter是规定的轮询总时间，为3000ms\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ imgsLoadedCount则为首屏已加载的图片数量\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ lastImageLoadedStamp为最后加载的图片时间戳\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckFirstScreenDomReady\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(totalCounter \x26gt;= DemandCounter){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stamps = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(pools),\n        len = stamps.length,\n        i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        it; \n        finalImgCount = pools[stamps[len - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]].imgLen; \n        pollEnd = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(;i\x26lt;len;i\x2b\x2b){\n            it = pools[stamps[i]];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(it.imgLen == finalImgCount \x26amp;\x26amp; it.imgsLoadedCount \x26gt;= finalImgCount){\n                self.onRecord = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n                _perfQueue._firstScreenLoadEnd = lastImageLoadedStamp;\n                firstScreen.firstScreenLoadEnd = lastImageLoadedStamp;\n                firstScreen.duaring = lastImageLoadedStamp - performance.timing.navigationStart;\n                \n                reportData(firstScreen);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e imgEls = getImage();\n\n    imgEls.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!imgLoadedHash.get(el)){\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e img = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image();\n            imgLoadedHash.put(el,{\n                \x3cspan class=\x22hljs-attr\x22\x3eloaded\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            });\n            img.onload = OnLoad;\n            img.onerror = OnError;\n            img.src = el.__src;\n        }\n    });\n    pools[totalCounter\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e] = {\n        \x3cspan class=\x22hljs-attr\x22\x3eimgLen\x3c\/span\x3e: imgEls.length,\n        \x3cspan class=\x22hljs-attr\x22\x3estamp\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now(),\n        \x3cspan class=\x22hljs-attr\x22\x3eimgsLoadedCount\x3c\/span\x3e: imgsLoadedCount\n    };\n    totalCounter \x2b= timeout;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3ewatch dog采集\x3c\/h2\x3e\n\x3cp\x3e利用Mutation Observer API进行侦听 内容框的DOM事件，判断首屏DOM结构是否完备；如果构建完毕则侦听首屏范围内的图片加载事件，计算首屏时间。\x3c\/p\x3e\n\x3cp\x3ewatch dog需要知晓合适首屏DOM构建完毕。这需要首屏计算模块主动插入一个打点标签 \x3cstrong\x3e\x26lt;div class=\x22j_collector_container\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/strong\x3e，将业务代码放置在标签内部（这个步骤最好放在发布阶段，由脚手架操作）。通过mutation 侦听 .j_collector_container 容器的DOM子孙节点变化。如在observe事件处理函数中，计算 .j_collector_container 高度，如果大于屏幕高度则意味着首屏的DOM结构已渲染完毕，开始计算首屏时间。\x3c\/p\x3e\n\x3cp\x3e在计算 .j_collector_container 高度时，最好采用限流策略，防止短时间内计算多次容器的布局信息，这也是无可奈何之举。\x3c\/p\x3e\n\x3cp\x3e此处的伪代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 记录首屏DOM元素的位置信息\nvar firstScreenDomReady = false;\nvar callback = function(records){\n    if(firstScreenDomReady)\n        return;\n\n    \/\/ 此处需做throttle 处理\n    for(var i=0,len=records.length;i\x3clen;i\x2b\x2b){\n        \/\/ 判断首屏DOM渲染完毕的策略：\n        \/\/ 判断collectWrapper元素高度是否大于首屏\n        var cr = collectWrapper.getBoundingClientRect(),\n        screenHeight = win.innerHeight;\n\n        if(cr.top \x2b cr.height \x3e= screenHeight){\n            firstScreenDomReady = true;\n            recordFirstScreenLoad();\n            return;\n        }\n    }\n};\n    \nvar mo = new MutationObserver(callback);\n\nvar option = {\n    \x27childList\x27: true,\n    \x27subtree\x27: true\n};\n\nvar collectWrapper = document.querySelector(\x27.j_collector_wrapper\x27);\nif(collectWrapper.getBoundingClientRect().height \x3c win.innerHeight){\n    mo.observe(collectWrapper, option);\n}else{\n    setTimeout(function(){\n        recordFirstScreenLoad();\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 记录首屏DOM元素的位置信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e firstScreenDomReady = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erecords\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(firstScreenDomReady)\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此处需做throttle 处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,len=records.length;i\x26lt;len;i\x2b\x2b){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断首屏DOM渲染完毕的策略：\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断collectWrapper元素高度是否大于首屏\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cr = collectWrapper.getBoundingClientRect(),\n        screenHeight = win.innerHeight;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(cr.top \x2b cr.height \x26gt;= screenHeight){\n            firstScreenDomReady = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            recordFirstScreenLoad();\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n    }\n};\n    \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mo = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MutationObserver(callback);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e option = {\n    \x3cspan class=\x22hljs-string\x22\x3e\x27childList\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27subtree\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e collectWrapper = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27.j_collector_wrapper\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(collectWrapper.getBoundingClientRect().height \x26lt; win.innerHeight){\n    mo.observe(collectWrapper, option);\n}\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        recordFirstScreenLoad();\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e不管采用哪种方式，计算出来的首屏时间都不是准确的。而且在每种实现中都需要通过JS引擎与渲染引擎的bridge进行通信执行耗时的操作，如getBoundingClientRect和访问offsetTop属性导致relayout。不过这也是没有办法的办法，在浏览器不提供相关首屏API的前提下我们只有这么做。\x3c\/p\x3e\n\x3cp\x3e另外，对比这三种实现（开发者手动打点、轮训、watch dog采集），针对一个复杂的电商首屏做了性能测试，该页面首屏部分有7个非常复杂的子组件，得到如下结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013016766?w=558\x26amp;h=994\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013016766?w=558\x26amp;h=994\x22 alt=\x22电商首页\x22 title=\x22电商首页\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013016767?w=1588\x26amp;h=714\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013016767?w=1588\x26amp;h=714\x22 alt=\x22采集结果\x22 title=\x22采集结果\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013016768?w=1008\x26amp;h=636\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013016768?w=1008\x26amp;h=636\x22 alt=\x22采集结果柱状图\x22 title=\x22采集结果柱状图\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e结果也符合我们的预期。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>关于首屏时间采集自动化的解决方案</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013016763">https://segmentfault.com/a/1190000013016763</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/swcnaf8875m/" target="_blank">https://alili.tech/archive/swcnaf8875m/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>