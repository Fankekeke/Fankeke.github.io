<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="排序算法的Javascript实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>排序算法的Javascript实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/sxmaj9ep4e/",
				"appid": "1613049289050283", 
				"title": "排序算法的Javascript实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-11T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ur3w5vdls9e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7h2bdpw56a5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&text=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&text=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&is_video=false&description=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsxmaj9ep4e%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84Javascript%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">排序算法的Javascript实现</h1><div class="meta"><div class="postdate"><time datetime="2018-12-11" itemprop="datePublished">2018-12-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e1.冒泡排序：\x3c\/p\x3e\n\x3cp\x3e比较相邻的两个数，如果前一个数大于后一个数，就将这两个数换位置。每一次遍历都会将本次遍历最大的数冒泡到最后。为了将n个数排好序，需要n-1次遍历。\x3cbr\x3e如果某次遍历中，没有调整任何两个相邻的数的位置关系，说明此时数组已排好序，可以结束程序。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Array.prototype.bubbleSort = function () {\n  let i, j;\n  for (i = 1; i \x3c this.length; i\x2b\x2b) {  \/\/表示本次是第i次遍历\n    let changed = false;\n    for (j = 0; j \x3c this.length - i; j\x2b\x2b) {   \/\/访问序列为arr[0:length-i]\n      if(this[j] \x3e this[j \x2b 1]){  \/\/发现前一个数大于后一个时，互换位置\n        [this[j],this[j\x2b1]] = [this[j\x2b1],this[j]];\n        changed = true;\n      }\n    }\n    if(!changed) {      \/\/如果本轮遍历没有发现位置调整，结束排序函数\n      break;\n    }\n  }\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.bubbleSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eArray.prototype.bubbleSort = function () {\n  let i, j;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length; i\x2b\x2b) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/表示本次是第i次遍历\x3c\/span\x3e\n    let changed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length - i; j\x2b\x2b) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/访问序列为arr[0:length-i]\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j] \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]){  \x3cspan class=\x22hljs-comment\x22\x3e\/\/发现前一个数大于后一个时，互换位置\x3c\/span\x3e\n        [\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j],\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]] = [\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j]];\n        changed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!changed) {      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果本轮遍历没有发现位置调整，结束排序函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\n  }\n};\n\nlet arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.bubbleSort();\nconsole.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2.选择排序\x3c\/p\x3e\n\x3cp\x3e第i轮遍历arr[0:n-i]选出最大的数，与arr[n-i]互换。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Array.prototype.selectSort = function () {\n  let i, j;\n  for (i = 1; i \x3c this.length; i\x2b\x2b) {     \/\/表示本次是第i次遍历\n    let maxIndex = 0;\n    for (j = 0; j \x3c= this.length - i; j\x2b\x2b) {  \/\/访问子序列为arr[0:this.length-i]\n      if (this[j] \x3e this[maxIndex]) {   \/\/当前值大于当前最大值时，记录索引\n        maxIndex = j;\n      }\n    }\n    \/\/将子数组最大值索引的值，与子数组末尾的值互换\n    [this[this.length - i], this[maxIndex]] = [this[maxIndex], this[this.length - i]]\n  }\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.selectSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eArray.prototype.selectSort = function () {\n  let i, j;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length; i\x2b\x2b) {     \x3cspan class=\x22hljs-comment\x22\x3e\/\/表示本次是第i次遍历\x3c\/span\x3e\n    let maxIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt;= \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length - i; j\x2b\x2b) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/访问子序列为arr[0:this.length-i]\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j] \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[maxIndex]) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/当前值大于当前最大值时，记录索引\x3c\/span\x3e\n        maxIndex = j;\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/将子数组最大值索引的值，与子数组末尾的值互换\x3c\/span\x3e\n    [\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length - i], \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[maxIndex]] = [\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[maxIndex], \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length - i]]\n  }\n};\n\nlet arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.selectSort();\nconsole.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.插入排序\x3cbr\x3e数组的前面部分已经排好序，要把当前数字插入到前面已排好序的数组的相应位置。可能有人会有疑问为什么默认数组前面部分已排好序？是怎么排好序的？是因为当排序开始时，从第2个数字开始进行向前插入，此时当前数字索引为1，当前数字前面仅有一个数字，因此可以认为前面部分已经排好序，将这个数字插入到相应位置之后数组仍然是有序的。每次都将当前数字插入到对应的位置，因此每次插入之后前面的数组仍是排好序的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Array.prototype.insertSort = function () {\n  let i, j;\n  for (i = 1; i \x3c this.length; i\x2b\x2b) {   \/\/i表示当前要向前插入的数字的索引，从1(即第2个数)开始前插\n    let val = this[i];   \/\/记录当前要前插的数的大小\n    \/*\n    * 用指针j来遍历第i个数字前面的，已经排好序的子数组。当j没有指到头，并且j的数字大于要插入的数字时，说明\n    * j还要向前遍历，直到发现一个比要插入数字小的位置pos，然后将这个数字插到pos\x2b1处。如果j已经指到头了，\n    * 到了-1了还没有找到比当前数字小的位置，就把当前数字放在索引0处。\n    * *\/\n    for (j = i - 1; j \x3e= 0 \x26amp;\x26amp; this[j] \x3e val; j--) {  \n      this[j \x2b 1] = this[j];\n    }\n    this[j \x2b 1] = val;\n  }\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.insertSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eArray.prototype.insertSort = function () {\n  let i, j;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length; i\x2b\x2b) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/i表示当前要向前插入的数字的索引，从1(即第2个数)开始前插\x3c\/span\x3e\n    let \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[i];   \x3cspan class=\x22hljs-comment\x22\x3e\/\/记录当前要前插的数的大小\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*\n    * 用指针j来遍历第i个数字前面的，已经排好序的子数组。当j没有指到头，并且j的数字大于要插入的数字时，说明\n    * j还要向前遍历，直到发现一个比要插入数字小的位置pos，然后将这个数字插到pos\x2b1处。如果j已经指到头了，\n    * 到了-1了还没有找到比当前数字小的位置，就把当前数字放在索引0处。\n    * *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j] \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e; j--) {  \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e;\n  }\n};\n\nlet arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.insertSort();\nconsole.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.shell排序\x3cbr\x3e加了step的插入排序。分别以索引数为0,1,......step-1的元素为起点，将其看做不同的组，0、0\x2bstep,0\x2b2\x3cem\x3estep，......，0\x2bn\x3c\/em\x3estep为一组，1,1\x2bstep,1\x2b2\x3cem\x3estep，.....,1\x2bn\x3c\/em\x3estep为一组依次分组，按照组为单位进行插入排序。各组都已经插入排序一轮过后，将step除以2向下取整，再进行分组并将各组分别进行插入排序，直到step为0。\x3cbr\x3estep的取值与性能直接相关，需要思考后取值。\x3cbr\x3e并且这里的分组仅仅是逻辑上分组，并没有开辟新的地址空间将其进行物理上的分组。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {floor} = Math;\n\n\/\/这个和插入排序相同，只不过加了step\nArray.prototype.shellInsertSort = function (startIndex, step) {\n  let i, j;\n  for (i = startIndex \x2b step; i \x3c this.length; i \x2b= step) {\n    let val = this[i];\n    for (j = i - step; j \x3e= 0 \x26amp;\x26amp; this[j] \x3e val; j -= step) {\n      this[j \x2b step] = this[j];\n    }\n    this[j \x2b step] = val;\n  }\n};\n\nArray.prototype.shellSort = function () {\n  let i, step;\n  for (step = floor(this.length \/ 2); step \x3e 0; step = floor(step \/ 2)) {\n    for (i = 0; i \x3c step; i\x2b\x2b) {\n      this.shellInsertSort(i, step);\n    }\n  }\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.shellSort(true);\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3econst {\x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e} = Math;\n\n\/\/这个和插入排序相同，只不过加了\x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e\nArray.prototype.shellInsertSort = function (startIndex, \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e i, j;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = startIndex \x2b \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e; i \x26lt; this.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i \x2b= \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e val = this[i];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = i - \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e; j \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; this[j] \x26gt; val; j -= \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e) {\n      this[j \x2b \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e] = this[j];\n    }\n    this[j \x2b \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e] = val;\n  }\n};\n\nArray.prototype.shellSort = function () {\n  \x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e i, \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e(this.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e; i\x2b\x2b) {\n      this.shellInsertSort(i, \x3cspan class=\x22hljs-keyword\x22\x3estep\x3c\/span\x3e);\n    }\n  }\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.shellSort(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e5.合并排序\x3c\/p\x3e\n\x3cp\x3e举个例子： 有 43 12 32 29 66 78 31这个数组要用合并排序。\x3cbr\x3e先将相邻两数分为一组进行合并 43|12 32|29 66|78 31\x3cbr\x3e结果为12 43 29 32 66 78 31\x3c\/p\x3e\n\x3cp\x3e再将组的大小乘以二  (12 43|29 32)  (66 78|31)\x3cbr\x3e本次合并后结果为 12 29 32 43 31 66 78\x3c\/p\x3e\n\x3cp\x3e再将组的大小乘以二  12 43 29 32 | 66 78 31\x3cbr\x3e合并结果：12 29 31 32 43 66 78\x3c\/p\x3e\n\x3cp\x3e合并的过程中要开辟新的数组arr，建立两个指针i,j分别指向arr1与arr2，此时arr1与arr2都是排好序的，然后每次都将arr1[i]与arr2[j]较小的数加到arr中并将指针后移。最后哪个数组有剩余的数在追加到arr后面。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {min} = Math;\n\nfunction merge(arr1, arr2,) {\n  let arr = [];\n  let i = 0, j = 0;\n  while (i \x3c arr1.length \x26amp;\x26amp; j \x3c arr2.length) {\n    arr1[i] \x3c arr2[j] ? arr.push(arr1[i\x2b\x2b]) : arr.push(arr2[j\x2b\x2b]);\n  }\n  return i \x3c arr1.length ? arr.concat(arr1.slice(i)) : arr.concat(arr2.slice(j))\n}\n\nArray.prototype.mergeSort = function () {\n  let groupSize, i, secondPartSize, firstPart, secondPart, totalSize;\n  \/\/最初合并时，每组的大小仅为1，然后将组的大小乘以2。\n  for (groupSize = 1; groupSize \x3c this.length; groupSize *= 2) {\n    for (i = 0; i \x3c this.length; i \x2b= 2 * groupSize) {\n      \/\/前半段大小一定是groupSize，后半段则不一定\n      secondPartSize = min(groupSize, this.length - i - groupSize);\n      totalSize = secondPartSize \x2b groupSize;\n      \/\/截取前后部分数组，将其排序\n      firstPart = this.slice(i, i \x2b groupSize);\n      secondPart = this.slice(i \x2b groupSize, i \x2b groupSize \x2b secondPartSize);\n      this.splice(i, totalSize, ...merge(firstPart, secondPart));\n    }\n  }\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.mergeSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {min} = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emerge\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr1, arr2,\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i \x26lt; arr1.length \x26amp;\x26amp; j \x26lt; arr2.length) {\n    arr1[i] \x26lt; arr2[j] ? arr.push(arr1[i\x2b\x2b]) : arr.push(arr2[j\x2b\x2b]);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i \x26lt; arr1.length ? arr.concat(arr1.slice(i)) : arr.concat(arr2.slice(j))\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.mergeSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e groupSize, i, secondPartSize, firstPart, secondPart, totalSize;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/最初合并时，每组的大小仅为1，然后将组的大小乘以2。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (groupSize = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; groupSize \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length; groupSize *= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length; i \x2b= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * groupSize) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/前半段大小一定是groupSize，后半段则不一定\x3c\/span\x3e\n      secondPartSize = min(groupSize, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length - i - groupSize);\n      totalSize = secondPartSize \x2b groupSize;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/截取前后部分数组，将其排序\x3c\/span\x3e\n      firstPart = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.slice(i, i \x2b groupSize);\n      secondPart = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.slice(i \x2b groupSize, i \x2b groupSize \x2b secondPartSize);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.splice(i, totalSize, ...merge(firstPart, secondPart));\n    }\n  }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.mergeSort();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e6.自然合并排序\x3c\/p\x3e\n\x3cp\x3e合并排序的分组是死板的没有利用到数组中原本就是顺序的子序列。\x3c\/p\x3e\n\x3cp\x3e如果数组为 43 56 79 12 33 90 66\x3cbr\x3e将其分组为 43 56 79 | 12 33 90 | 66\x3cbr\x3e再将相邻的，原本就是从小到大的顺序的数组进行合并，效果会更好。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function merge(arr1, arr2) {\n  let arr = [], i = 0, j = 0;\n  while (i \x3c arr1.length \x26amp;\x26amp; j \x3c arr2.length) {\n    arr.push(arr1[i] \x3c arr2[j] ? arr1[i\x2b\x2b] : arr2[j\x2b\x2b])\n  }\n  return arr.concat(i \x3c arr1.length ? arr1.slice(i) : arr2.slice(j));\n}\n\nfunction getSortedArrList(arr) {\n  \/\/记录下已经原本就是从小到大顺序的子数组\n  let sortedArrList = [];\n  let childArr = [arr[0]];\n  for (let i = 1; i \x3c arr.length; i\x2b\x2b) {\n    \/\/当前值小于上一个值时，将childArr加入sortedArrList中，创建新的childArr，并加入当前值。\n    if (arr[i] \x3c arr[i - 1]) {\n      sortedArrList.push(childArr);\n      childArr = [arr[i]];\n    }\n    \/\/否则，将当前值加入到childArr中\n    else {\n      childArr.push(arr[i]);\n    }\n  }\n  sortedArrList.push(childArr);\n  return sortedArrList;\n}\n\nArray.prototype.naturalMergeSort = function() {\n  let sortedArrList = getSortedArrList(this);  \/\/获取原本从小到大顺序的子数组\n\n  while (sortedArrList.length \x3e 1) {    \/\/当还有两个及以上的数组没合并完成时\n    let newSortedArrList = [];\n    for (let i = 0; i \x3c sortedArrList.length; i \x2b= 2) {\n      if (i !== sortedArrList.length - 1) {\n        newSortedArrList.push(merge(sortedArrList[i], sortedArrList[i \x2b 1]));\n      }\n      else {\n        newSortedArrList.push(sortedArrList[i]);\n      }\n    }\n    sortedArrList = newSortedArrList;\n  }\n  this.splice(0,this.length,...sortedArrList[0]);\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.naturalMergeSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emerge\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr1, arr2\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [], i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i \x26lt; arr1.length \x26amp;\x26amp; j \x26lt; arr2.length) {\n    arr.push(arr1[i] \x26lt; arr2[j] ? arr1[i\x2b\x2b] : arr2[j\x2b\x2b])\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr.concat(i \x26lt; arr1.length ? arr1.slice(i) : arr2.slice(j));\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetSortedArrList\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/记录下已经原本就是从小到大顺序的子数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e sortedArrList = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childArr = [arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; arr.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/当前值小于上一个值时，将childArr加入sortedArrList中，创建新的childArr，并加入当前值。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i] \x26lt; arr[i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n      sortedArrList.push(childArr);\n      childArr = [arr[i]];\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则，将当前值加入到childArr中\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      childArr.push(arr[i]);\n    }\n  }\n  sortedArrList.push(childArr);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e sortedArrList;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.naturalMergeSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e sortedArrList = getSortedArrList(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取原本从小到大顺序的子数组\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (sortedArrList.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {    \x3cspan class=\x22hljs-comment\x22\x3e\/\/当还有两个及以上的数组没合并完成时\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newSortedArrList = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; sortedArrList.length; i \x2b= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (i !== sortedArrList.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        newSortedArrList.push(merge(sortedArrList[i], sortedArrList[i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]));\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        newSortedArrList.push(sortedArrList[i]);\n      }\n    }\n    sortedArrList = newSortedArrList;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.splice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length,...sortedArrList[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.naturalMergeSort();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e7.基数排序(LSD least significant digit first)\x3cbr\x3eLSD中没有数值之间的比较。建立一个[10][]的二维数组arr。\x3cbr\x3e挑选出要排序数组中最大的数字，计算该数字的位数记为digitNum。将数组中的所有数字填充到digitNum位，位数不够的高位补0。\x3cbr\x3e然后遍历digitNum次，从低位开始。第i次遍历按照将数组中元素的第i位的数值，将元素num放到二维数组相应位置处，如果num第i位数值为n，则执行arr[n].push(num)的操作。每次遍历之后，将arr[0:9]各数组的元素依次取出，并且重新初始化二维数组。直到遍历到最高位为止，再取出的就是已经排好序的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {max} = Math;\n\nfunction initBarrel() {\n  let barrel = [];\n  for (let i = 0; i \x3c 10; i\x2b\x2b) {\n    barrel[i] = [];\n  }\n  return barrel;\n}\n\nfunction radixSort(arr) {\n  let barrel = initBarrel();\n  let figureNum = max(...arr).toString().length;  \/\/计算最大的数字的位数\n  arr = arr.map(num =\x3e num.toString().padStart(figureNum, \x270\x27));  \/\/将数字填充到figureNum位\n  for (let i = 0; i \x3c figureNum; i\x2b\x2b) {\n    let index = figureNum - i - 1;  \/\/本次根据第index位来选择放入哪个桶\n    arr.forEach(numStr =\x3e {         \/\/将填充过的数组放入桶中\n      let num = Number(numStr[index]);\n      barrel[num].push(numStr);\n    });\n    arr = barrel.reduce((prevArr, curArr) =\x3e prevArr.concat(curArr), []);\/\/汇总barrel中的数\n    barrel = initBarrel();    \/\/初始化barrel\n  }\n  return arr.map(num =\x3e Number(num));   \/\/最终转为数字形式\n}\n\nArray.prototype.radixSort = function () {\n  let arr = radixSort(this);\n  this.splice(0, this.length, ...arr);\n};\n\nlet arr = [1234342, 52165, 75, 1, 356, 575, 765433212, 57994, 3535];\narr.radixSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {max} = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitBarrel\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e barrel = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n    barrel[i] = [];\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e barrel;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eradixSort\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e barrel = initBarrel();\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e figureNum = max(...arr).toString().length;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/计算最大的数字的位数\x3c\/span\x3e\n  arr = arr.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e =\x26gt;\x3c\/span\x3e num.toString().padStart(figureNum, \x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e));  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将数字填充到figureNum位\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; figureNum; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e index = figureNum - i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/本次根据第index位来选择放入哪个桶\x3c\/span\x3e\n    arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enumStr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {         \x3cspan class=\x22hljs-comment\x22\x3e\/\/将填充过的数组放入桶中\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e num = \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(numStr[index]);\n      barrel[num].push(numStr);\n    });\n    arr = barrel.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprevArr, curArr\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e prevArr.concat(curArr), []);\x3cspan class=\x22hljs-comment\x22\x3e\/\/汇总barrel中的数\x3c\/span\x3e\n    barrel = initBarrel();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化barrel\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(num));   \x3cspan class=\x22hljs-comment\x22\x3e\/\/最终转为数字形式\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.radixSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = radixSort(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.splice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length, ...arr);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1234342\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e52165\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e75\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e356\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e575\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e765433212\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57994\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3535\x3c\/span\x3e];\narr.radixSort();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e8.基数排序(MSD most significant digit first)\x3cbr\x3e从高位开始，依然没有数值之间的比较。\x3cbr\x3e将最初的元素序列按照各元素最高位的数值进行分组，将分组后，组中只有一个元素或者多个相等元素的组拼接到result数组中，而有多个不同元素的组再递归地向下分，取的位次依次减少。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {max} = Math;\n\nfunction initBarrel() {\n  let barrel = [];\n  for (let i = 0; i \x3c 10; i\x2b\x2b) {\n    barrel[i] = [];\n  }\n  return barrel;\n}\n\n\/\/判断当前桶中是否只有唯一值 有的桶中可能只有一种值，但是有多个重复项\nfunction unique(barrel) {\n  return new Set(barrel).size \x3c= 1;\n}\n\nArray.prototype.radixSort = function () {\n  let result = [];\n  let figureNum = max(...this).toString().length;\n  this.splice(0, this.length, ...this.map(num =\x3e num.toString().padStart(figureNum, \x270\x27)));\n  radixGroup(this, 0, figureNum, result);\n  this.splice(0, this.length, ...result.map(numStr =\x3e Number(numStr)));\n};\n\nfunction radixGroup(group, index, figureNum, result) {    \/\/输入的group是一组numStr，index是当前分桶依据第几位数\n  if (index \x3c figureNum) {\n    let barrel = initBarrel();\n    group.forEach(numStr =\x3e {\n      let idx = Number(numStr[index]);\n      barrel[idx].push(numStr);\n    });\n\n    barrel.forEach(subBarrel =\x3e {\n      if(unique(subBarrel)) {\n        subBarrel.forEach(num =\x3e {\n          result.push(num);\n        })\n      }\n      else {\n        radixGroup(subBarrel,index\x2b1,figureNum,result);\n      }\n    })\n  }\n}\nlet arr = [1234342, 52165, 75, 1, 356, 575, 765433212, 57994, 3535];\narr.radixSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {max} = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitBarrel\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e barrel = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n    barrel[i] = [];\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e barrel;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/判断当前桶中是否只有唯一值 有的桶中可能只有一种值，但是有多个重复项\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ebarrel\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(barrel).size \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.radixSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e figureNum = max(...this).toString().length;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.splice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length, ...this.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e =\x26gt;\x3c\/span\x3e num.toString().padStart(figureNum, \x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e)));\n  radixGroup(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, figureNum, result);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.splice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length, ...result.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enumStr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(numStr)));\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eradixGroup\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egroup, index, figureNum, result\x3c\/span\x3e) \x3c\/span\x3e{    \x3cspan class=\x22hljs-comment\x22\x3e\/\/输入的group是一组numStr，index是当前分桶依据第几位数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (index \x26lt; figureNum) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e barrel = initBarrel();\n    group.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enumStr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e idx = \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(numStr[index]);\n      barrel[idx].push(numStr);\n    });\n\n    barrel.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3esubBarrel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(unique(subBarrel)) {\n        subBarrel.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n          result.push(num);\n        })\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        radixGroup(subBarrel,index\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,figureNum,result);\n      }\n    })\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1234342\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e52165\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e75\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e356\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e575\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e765433212\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57994\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3535\x3c\/span\x3e];\narr.radixSort();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e9.快速排序\x3c\/p\x3e\n\x3cp\x3e将数组头部的元素pivotNum作为一个基准，通过两个指针指向数组的头部和尾部，经过一次partition以后将pivotNum放在一个位置pivot，pivot前面的数小于pivotNum，后面的数大于pivotNum。\x3cbr\x3e为了防止最坏情况的发生，可以在数组中随机选出一个数来与数组头部元素换位置，来降低具体实例与最坏情况的关联性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {floor, random} = Math;\n\nfunction randomIndex(start, end) {\n  return floor(random() * (end - start \x2b 1)) \x2b start;\n}\n\nfunction partition(arr, start, end) {\n  let index = randomIndex(start, end);\n  [arr[start], arr[index]] = [arr[index], arr[start]];\n\n  let value = arr[start];\n\n  while (start \x3c end) {\n    while (start \x3c end \x26amp;\x26amp; arr[end] \x3e value) end--;\n    arr[start] = arr[end];\n    while (start \x3c end \x26amp;\x26amp; arr[start] \x3c value) start\x2b\x2b;\n    arr[end] = arr[start];\n  }\n\n  arr[start] = value;\n  return start;\n}\n\nfunction quickSort(arr, start, end) {\n  if (start \x3c end) {\n    let pivot = partition(arr, start, end);\n    quickSort(arr, start, pivot - 1);\n    quickSort(arr, pivot \x2b 1, end);\n  }\n}\n\nArray.prototype.quickSort = function (asc = true) {\n  quickSort(this, 0, this.length - 1, asc)\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.quickSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3econst {\x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e, random} = Math;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e randomIndex(start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e(random() * (\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e - start \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)) \x2b start;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e partition(arr, start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n  let \x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e = randomIndex(start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e);\n  [arr[start], arr[\x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e]] = [arr[\x3cspan class=\x22hljs-built_in\x22\x3eindex\x3c\/span\x3e], arr[start]];\n\n  let \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = arr[start];\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (start \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (start \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e \x26amp;\x26amp; arr[\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e] \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e--;\n    arr[start] = arr[\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (start \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e \x26amp;\x26amp; arr[start] \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) start\x2b\x2b;\n    arr[\x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e] = arr[start];\n  }\n\n  arr[start] = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e start;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e quickSort(arr, start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (start \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e) {\n    let pivot = partition(arr, start, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e);\n    quickSort(arr, start, pivot - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    quickSort(arr, pivot \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eend\x3c\/span\x3e);\n  }\n}\n\nArray.prototype.quickSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e (asc = true) {\n  quickSort(this, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, this.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, asc)\n};\n\nlet arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.quickSort();\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e10.堆排序\x3cbr\x3e将数组看做完全二叉树，因此节点i的左右子节点的索引分别为2i\x2b1与2i\x2b2。通过从根节点开始令小的值下沉，或者从最后的叶节点开始令大的值上浮的方法，将一个数组构造成一个大根堆。再将大根堆的头元素与尾元素换位置，这样就将当前最大值置换到了尾部。然后下次构建大根堆的时候，将刚置换过的尾部元素刨除在外不做为节点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const {floor, max} = Math;\n\nfunction getBiggestNodeIndex(...nodes) {\n  return nodes.indexOf(max(...nodes));\n}\n\n\/\/将arr从0开始，长度为length的子数组构建为堆\nfunction constructHeap(arr, length) {\n  let adjusted = true;  \/\/adjusted来标识本次堆是否作出了调整，若未调整说明堆已构建完毕\n  while (adjusted) {\n    adjusted = false;\n    for (let i = 0; i \x3c floor(length \/ 2); i\x2b\x2b) {\n      \/\/当只有左节点时\n      if (2 * i \x2b 2 === length) {\n        \/\/当父节点比左节点小的时候\n        if (arr[i] \x3c arr[2 * i \x2b 1]) {\n          \/\/互换\n          [arr[i], arr[2 * i \x2b 1]] = [arr[2 * i \x2b 1], arr[i]];\n          adjusted = true;\n        }\n      }\n      \/\/当同时有左节点和右节点时\n      else {\n        \/\/判断三个中最大的节点\n        let biggestNodeIndex = getBiggestNodeIndex(arr[i], arr[2 * i \x2b 1], arr[2 * i \x2b 2]);\n        \/\/若父节点不是最大的，则和最大的交换\n        \/\/如果biggestNodeIndex为0，说明自己最大，为1，说明左节点大，为2，说明右节点大\n        switch (biggestNodeIndex) {\n          case 0:\n            break;\n          case 1:\n            [arr[i], arr[2 * i \x2b 1]] = [arr[2 * i \x2b 1], arr[i]];\n            adjusted = true;\n            break;\n          case 2:\n            [arr[i], arr[2 * i \x2b 2]] = [arr[2 * i \x2b 2], arr[i]];\n            adjusted = true;\n            break;\n        }\n      }\n    }\n  }\n}\n\nfunction heepSort(arr) {\n  \/\/只将arr从0开始，长度为length的子数组构建成大根堆\n  let length = arr.length;\n  while (length \x3e 1) {\n    constructHeap(arr, length);\n    [arr[0], arr[length-- - 1]] = [arr[length - 1], arr[0]];\n  }\n}\n\nArray.prototype.heepSort = function () {\n  heepSort(this);\n};\n\nlet arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];\narr.heepSort();\nconsole.log(arr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {floor, max} = Math;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetBiggestNodeIndex\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...nodes\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nodes.indexOf(max(...nodes));\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将arr从0开始，长度为length的子数组构建为堆\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econstructHeap\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arr, length)\x3c\/span\x3e \x3c\/span\x3e{\n  let adjusted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/adjusted来标识本次堆是否作出了调整，若未调整说明堆已构建完毕\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (adjusted) {\n    adjusted = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; floor(length \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); i\x2b\x2b) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/当只有左节点时\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e === length) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/当父节点比左节点小的时候\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i] \x26lt; arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/互换\x3c\/span\x3e\n          [arr[i], arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]] = [arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], arr[i]];\n          adjusted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        }\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/当同时有左节点和右节点时\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断三个中最大的节点\x3c\/span\x3e\n        let biggestNodeIndex = getBiggestNodeIndex(arr[i], arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/若父节点不是最大的，则和最大的交换\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果biggestNodeIndex为0，说明自己最大，为1，说明左节点大，为2，说明右节点大\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (biggestNodeIndex) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e:\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:\n            [arr[i], arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]] = [arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], arr[i]];\n            adjusted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e:\n            [arr[i], arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]] = [arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * i \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e], arr[i]];\n            adjusted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        }\n      }\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eheepSort\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arr)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/只将arr从0开始，长度为length的子数组构建成大根堆\x3c\/span\x3e\n  let length = arr.length;\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    constructHeap(arr, length);\n    [arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], arr[length-- - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]] = [arr[length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]];\n  }\n}\n\nArray.prototype.heepSort = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  heepSort(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n};\n\nlet arr = [\x3cspan class=\x22hljs-number\x22\x3e43\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e57\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e];\narr.heepSort();\nconsole.log(arr);\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>排序算法的Javascript实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013613746">https://segmentfault.com/a/1190000013613746</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/sxmaj9ep4e/" target="_blank">https://alili.tech/archive/sxmaj9ep4e/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>