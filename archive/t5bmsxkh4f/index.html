<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="如何继承Date对象？由一道题彻底弄懂JS继承。"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>如何继承Date对象？由一道题彻底弄懂JS继承。 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/t5bmsxkh4f/",
				"appid": "1613049289050283", 
				"title": "如何继承Date对象？由一道题彻底弄懂JS继承。 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-17T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ilebde498ws/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zolyt3tgoo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&text=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&text=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&title=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&is_video=false&description=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&title=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&title=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&title=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ft5bmsxkh4f%2f&title=%e5%a6%82%e4%bd%95%e7%bb%a7%e6%89%bfDate%e5%af%b9%e8%b1%a1%ef%bc%9f%e7%94%b1%e4%b8%80%e9%81%93%e9%a2%98%e5%bd%bb%e5%ba%95%e5%bc%84%e6%87%82JS%e7%bb%a7%e6%89%bf%e3%80%82"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">如何继承Date对象？由一道题彻底弄懂JS继承。</h1><div class="meta"><div class="postdate"><time datetime="2018-12-17" itemprop="datePublished">2018-12-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e见解有限，如有描述不当之处，请帮忙及时指出，如有错误，会及时修正。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e20180201更新：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e修改用词描述，如组合寄生式改成寄生组合式，修改多处笔误（感谢@Yao Ding的反馈）\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------长文\x2b多图预警，需要花费一定时间----------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e故事是从一次实际需求中开始的。。。\x3c\/p\x3e\n\x3cp\x3e某天，某人向我寻求了一次帮助，要协助写一个日期工具类，要求：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e此类继承自\x3ccode\x3eDate\x3c\/code\x3e，拥有Date的所有属性和对象\x3c\/li\x3e\n\x3cli\x3e此类可以自由拓展方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e形象点描述，就是要求可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 假设最终的类是 MyDate，有一个getTest拓展方法\nlet date = new MyDate();\n\n\/\/ 调用Date的方法，输出GMT绝对毫秒数\nconsole.log(date.getTime());\n\/\/ 调用拓展的方法，随便输出什么，譬如helloworld!\nconsole.log(date.getTest());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 假设最终的类是 MyDate，有一个getTest拓展方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyDate();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用Date的方法，输出GMT绝对毫秒数\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(date.getTime());\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用拓展的方法，随便输出什么，譬如helloworld!\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(date.getTest());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e于是，随手用JS中经典的\x3cstrong\x3e寄生组合式\x3c\/strong\x3e写了一个继承，然后，刚准备完美收工，一运行，却出现了以下的情景：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e但是的心情是这样的： \x3cstrong\x3e?囧\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e以前也没有遇到过类似的问题，然后自己尝试着用其它方法，多次尝试，均无果（不算暴力混合法的情况），其实回过头来看，是因为思路新奇，凭空想不到，并不是原理上有多难。。。\x3c\/p\x3e\n\x3cp\x3e于是，借助强大的搜素引擎，搜集资料，最后，再自己总结了一番，才有了本文。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------正文开始前----------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e正文开始前，各位看官可以先暂停往下读，尝试下，在不借助任何网络资料的情况下，是否能实现上面的需求？（就以\x3ccode\x3e10分钟\x3c\/code\x3e为限吧）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e大纲\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e先说说如何快速快速寻求解答\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3estackoverflow上早就有答案了！\x3c\/li\x3e\n\x3cli\x3e倘若用的是中文搜索。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e分析问题的关键\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e经典的继承法有何问题\x3c\/li\x3e\n\x3cli\x3e为什么无法被继承？\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e该如何实现继承？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e暴力混合法\x3c\/li\x3e\n\x3cli\x3eES5黑魔法\x3c\/li\x3e\n\x3cli\x3eES6大法\x3c\/li\x3e\n\x3cli\x3eES6写法，然后babel打包\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e几种继承的细微区别\x3c\/li\x3e\n\x3cli\x3eES6继承与ES5继承的区别\x3c\/li\x3e\n\x3cli\x3e构造函数与实例对象\x3c\/li\x3e\n\x3cli\x3e[[Class]]与Internal slot\x3c\/li\x3e\n\x3cli\x3e如何快速判断是否继承？\x3c\/li\x3e\n\x3cli\x3e写在最后的话\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e先说说如何快速快速寻求解答\x3c\/h2\x3e\n\x3cp\x3e遇到不会的问题，肯定第一目标就是如何快速寻求解决方案，答案是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e先去stackoverflow上看看有没有类似的题。。。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e于是，借助搜索引擎搜索了下，第一条就符合条件，点开进去看描述\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3estackoverflow上早就有答案了！\x3c\/h3\x3e\n\x3cp\x3e先说说结果，再浏览一番后，确实找到了解决方案，然后回过头来一看，惊到了，因为这个问题的提问时间是\x3ccode\x3e6 years, 7 months ago\x3c\/code\x3e。\x3cbr\x3e也就是说，\x3ccode\x3e2011\x3c\/code\x3e年的时候就已经有人提出了。。。\x3c\/p\x3e\n\x3cp\x3e感觉自己落后了一个时代\x3cstrong\x3e\x26gt;_\x26lt;\x3c\/strong\x3e。。。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search2.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search2.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而且还发现了一个细节，那就是\x3ccode\x3eviewed:10,606 times\x3c\/code\x3e，也就是说至今一共也才一万多次阅读而已，考虑到前端行业的从业人数，这个比例惊人的低。\x3cbr\x3e以点见面，看来，遇到这个问题的人并不是很多。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e倘若用的是中文搜索。\x3c\/h3\x3e\n\x3cp\x3e用中文搜索并不丢人（我遇到问题时的本能反应也是去百度）。结果是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search3.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search3.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e嗯，看来英文关键字搜索效果不错，第一条就是符合要求的。然后又试了试中文搜索。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search4.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search4.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search5.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search5.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e效果不如人意，搜索前几页，唯一有一条看起来比较相近的（\x3ccode\x3esegmentfault\x3c\/code\x3e上的那条），点进去看\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search6.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search6.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search7.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_search7.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e怎么说呢。。。这个问题关注度不高，浏览器数较少，而且上面的问题描述和预期的有点区别，仍然是有人回答的。\x3cbr\x3e不过，虽然说问题在一定程度上得到了解决，但是回答者绕过了无法继承这个问题，有点未竟全功的意思。。。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e分析问题的关键\x3c\/h2\x3e\n\x3cp\x3e借助stackoverflow上的回答\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e经典的继承法有何问题\x3c\/h3\x3e\n\x3cp\x3e先看看本文最开始时提到的经典继承法实现，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 经典的js寄生组合式继承\n *\/\nfunction MyDate() {\n    Date.apply(this, arguments);\n    this.abc = 1;\n}\n\nfunction inherits(subClass, superClass) {\n    function Inner() {}\n    \n    Inner.prototype = superClass.prototype;\n    subClass.prototype = new Inner();\n    subClass.prototype.constructor = subClass;\n}\n\ninherits(MyDate, Date);\n\nMyDate.prototype.getTest = function() {\n    return this.getTime();\n};\n\n\nlet date = new MyDate();\n\nconsole.log(date.getTest());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 经典的js寄生组合式继承\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyDate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubClass, superClass\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eInner\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n    \n    Inner.prototype = superClass.prototype;\n    subClass.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Inner();\n    subClass.prototype.constructor = subClass;\n}\n\ninherits(MyDate, \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e);\n\nMyDate.prototype.getTest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getTime();\n};\n\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyDate();\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(date.getTest());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就是这段代码⬆，这也是JavaScript高程（红宝书）中推荐的一种，一直用，从未失手，结果现在马失前蹄。。。\x3c\/p\x3e\n\x3cp\x3e我们再回顾下它的报错：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e再打印它的原型看看：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_proto.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_proto.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e怎么看都没问题，因为按照原型链回溯规则，\x3ccode\x3eDate\x3c\/code\x3e的所有原型方法都可以通过\x3ccode\x3eMyDate\x3c\/code\x3e对象的原型链往上回溯到。\x3cbr\x3e再仔细看看，发现它的关键并不是找不到方法，而是\x3ccode\x3ethis is not a Date object.\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e嗯哼，也就是说，关键是：\x3cstrong\x3e由于调用的对象不是Date的实例，所以不允许调用，就算是自己通过原型继承的也不行\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e为什么无法被继承？\x3c\/h3\x3e\n\x3cp\x3e首先，看看\x3ccode\x3eMDN\x3c\/code\x3e上的解释，上面有提到，JavaScript的日期对象只能通过\x3ccode\x3eJavaScript Date\x3c\/code\x3e作为构造函数来实例化。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_explain.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_explain.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e然后再看看stackoverflow上的回答：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_explain2.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_explain2.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e有提到，\x3ccode\x3ev8\x3c\/code\x3e引擎底层代码中有限制，如果调用对象的\x3ccode\x3e[[Class]]\x3c\/code\x3e不是\x3ccode\x3eDate\x3c\/code\x3e，则抛出错误。\x3c\/p\x3e\n\x3cp\x3e总的来说，结合这两点，可以得出一个结论：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e要调用Date上方法的实例对象必须通过Date构造出来，否则不允许调用Date的方法\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e该如何实现继承？\x3c\/h2\x3e\n\x3cp\x3e虽然原因找到了，但是问题仍然要解决啊，真的就没办法了么？当然不是，事实上还是有不少实现的方法的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e暴力混合法\x3c\/h3\x3e\n\x3cp\x3e首先，说说说下暴力的混合法，它是下面这样子的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_mix.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_mix.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e说到底就是：内部生成一个\x3ccode\x3eDate\x3c\/code\x3e对象，然后此类暴露的方法中，把原有\x3ccode\x3eDate\x3c\/code\x3e中所有的方法都代理一遍，而且严格来说，这根本算不上继承（都没有原型链回溯）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eES5黑魔法\x3c\/h3\x3e\n\x3cp\x3e然后，再看看ES5中如何实现？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 需要考虑polyfill情况\nObject.setPrototypeOf = Object.setPrototypeOf ||\nfunction(obj, proto) {\n    obj.__proto__ = proto;\n\n    return obj;\n};\n\n\/**\n * 用了点技巧的继承，实际上返回的是Date对象\n *\/\nfunction MyDate() {\n    \/\/ bind属于Function.prototype，接收的参数是：object, param1, params2...\n    var dateInst = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))();\n\n    \/\/ 更改原型指向，否则无法调用MyDate原型上的方法\n    \/\/ ES6方案中，这里就是[[prototype]]这个隐式原型对象，在没有标准以前就是__proto__\n    Object.setPrototypeOf(dateInst, MyDate.prototype);\n\n    dateInst.abc = 1;\n\n    return dateInst;\n}\n\n\/\/ 原型重新指回Date，否则根本无法算是继承\nObject.setPrototypeOf(MyDate.prototype, Date.prototype);\n\nMyDate.prototype.getTest = function getTest() {\n    return this.getTime();\n};\n\nlet date = new MyDate();\n\n\/\/ 正常输出，譬如1515638988725\nconsole.log(date.getTest());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要考虑polyfill情况\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf ||\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj, proto\x3c\/span\x3e) \x3c\/span\x3e{\n    obj.__proto__ = proto;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj;\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 用了点技巧的继承，实际上返回的是Date对象\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyDate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind属于Function.prototype，接收的参数是：object, param1, params2...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dateInst = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.bind.apply(\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e, [\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e].concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e))))();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更改原型指向，否则无法调用MyDate原型上的方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES6方案中，这里就是[[prototype]]这个隐式原型对象，在没有标准以前就是__proto__\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(dateInst, MyDate.prototype);\n\n    dateInst.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dateInst;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原型重新指回Date，否则根本无法算是继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(MyDate.prototype, \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.prototype);\n\nMyDate.prototype.getTest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetTest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getTime();\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyDate();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正常输出，譬如1515638988725\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(date.getTest());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一眼看上去不知所措？没关系，先看下图来理解：（原型链关系一目了然）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_date_es5_prototype.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_date_es5_prototype.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到，用的是非常巧妙的一种做法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e正常继承的情况如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3enew MyDate()\x3c\/code\x3e返回实例对象\x3ccode\x3edate\x3c\/code\x3e是由\x3ccode\x3eMyDate\x3c\/code\x3e构造的\x3c\/li\x3e\n\x3cli\x3e原型链回溯是: \x3ccode\x3edate(MyDate对象)-\x26gt;date.__proto__-\x26gt;MyDate.prototype-\x26gt;MyDate.prototype.__proto__-\x26gt;Date.prototype\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e这种做法的继承的情况如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3enew MyDate()\x3c\/code\x3e返回实例对象\x3ccode\x3edate\x3c\/code\x3e是由\x3ccode\x3eDate\x3c\/code\x3e构造的\x3c\/li\x3e\n\x3cli\x3e原型链回溯是: \x3ccode\x3edate(Date对象)-\x26gt;date.__proto__-\x26gt;MyDate.prototype-\x26gt;MyDate.prototype.__proto__-\x26gt;Date.prototype\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e可以看出，关键点在于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e构造函数里返回了一个真正的\x3ccode\x3eDate\x3c\/code\x3e对象（由\x3ccode\x3eDate\x3c\/code\x3e构造，所以有这些内部类中的关键\x3ccode\x3e[[Class]]\x3c\/code\x3e标志），所以它有调用\x3ccode\x3eDate\x3c\/code\x3e原型上方法的权利\x3c\/li\x3e\n\x3cli\x3e构造函数里的Date对象的\x3ccode\x3e[[ptototype]]\x3c\/code\x3e（对外，浏览器中可通过\x3ccode\x3e__proto__\x3c\/code\x3e访问）指向\x3ccode\x3eMyDate.prototype\x3c\/code\x3e，然后\x3ccode\x3eMyDate.prototype\x3c\/code\x3e再指向\x3ccode\x3eDate.prototype\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e所以最终的实例对象仍然能进行正常的原型链回溯，回溯到原本Date的所有原型方法\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e这样通过一个巧妙的欺骗技巧，就实现了完美的Date继承。不过补充一点，\x3ccode\x3eMDN\x3c\/code\x3e上有提到\x3cstrong\x3e尽量不要修改对象的\x3ccode\x3e[[Prototype]]\x3c\/code\x3e\x3c\/strong\x3e，因为这样可能会干涉到浏览器本身的优化。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_protowarn.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_protowarn.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eES6大法\x3c\/h3\x3e\n\x3cp\x3e当然，除了上述的ES5实现，ES6中也可以直接继承（自带支持继承\x3ccode\x3eDate\x3c\/code\x3e），而且更为简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyDate extends Date {\n    constructor() {\n        super();\n        this.abc = 1;\n    }\n    getTest() {\n        return this.getTime();\n    }\n}\n\nlet date = new MyDate();\n\n\/\/ 正常输出，譬如1515638988725\nconsole.log(date.getTest());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyDate\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDate\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    }\n    getTest() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getTime();\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e date = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyDate();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正常输出，譬如1515638988725\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(date.getTest());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对比下ES5中的实现，这个真的是简单的不行，直接使用ES6的Class语法就行了。\x3c\/p\x3e\n\x3cp\x3e而且，也可以正常输出。\x3c\/p\x3e\n\x3cp\x3e注意：\x3cstrong\x3e这里的正常输出环境是直接用ES6运行，不经过babel打包，打包后实质上是转化成ES5的，所以效果完全不一样\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eES6写法，然后Babel打包\x3c\/h3\x3e\n\x3cp\x3e虽然说上述ES6大法是可以直接继承Date的，但是，考虑到实质上大部分的生产环境是：\x3ccode\x3eES6 \x2b Babel\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e直接这样用ES6 \x2b Babel是会出问题的\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e不信的话，可以自行尝试下，Babel打包成ES5后代码大致是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_babel.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_babel.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e然后当信心满满的开始用时，会发现：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e对，又出现了这个问题，也许这时候是这样的\x3cstrong\x3e⊙?⊙\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e因为转译后的ES5源码中，\x3cstrong\x3e仍然是通过\x3ccode\x3eMyDate\x3c\/code\x3e来构造\x3c\/strong\x3e，\x3cbr\x3e而\x3ccode\x3eMyDate\x3c\/code\x3e的构造中又无法修改属于\x3ccode\x3eDate\x3c\/code\x3e内部的\x3ccode\x3e[[Class]]\x3c\/code\x3e之类的私有标志，\x3cbr\x3e因此构造出的对象仍然不允许调用\x3ccode\x3eDate\x3c\/code\x3e方法（调用时，被引擎底层代码识别为\x3ccode\x3e[[Class]]\x3c\/code\x3e标志不符合，不允许调用，抛出错误）\x3c\/p\x3e\n\x3cp\x3e由此可见，ES6继承的内部实现和Babel打包编译出来的实现是有区别的。\x3cbr\x3e（虽说Babel的polyfill一般会按照定义的规范去实现的，但也不要过度迷信）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e几种继承的细微区别\x3c\/h2\x3e\n\x3cp\x3e虽然上述提到的三种方法都可以达到继承\x3ccode\x3eDate\x3c\/code\x3e的目的-混合法严格说不能算继承，只不过是另类实现。\x3c\/p\x3e\n\x3cp\x3e于是，将所有能打印的主要信息都打印出来，分析几种继承的区别，大致场景是这样的：\x3c\/p\x3e\n\x3cp\x3e可以参考：（ 请进入调试模式）\x3ca href=\x22https:\/\/dailc.github.io\/fe-interview\/demo\/extends_date.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/dailc.github.io\/fe-interview\/demo\/extends_date.html\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e从上往下，\x3ccode\x3e1, 2, 3, 4\x3c\/code\x3e四种继承实现分别是：（排出了混合法）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eES6的Class大法\x3c\/li\x3e\n\x3cli\x3e经典寄生组合式继承法\x3c\/li\x3e\n\x3cli\x3e本文中的取巧做法，Date构造实例，然后更改\x3ccode\x3e__proto__\x3c\/code\x3e的那种\x3c\/li\x3e\n\x3cli\x3eES6的Class大法，Babel打包后的实现（无法正常调用的）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22~~~~以下是MyDate们的prototype~~~~~~~~~\nDate {constructor: ƒ, getTest: ƒ}\nDate {constructor: ƒ, getTest: ƒ}\nDate {getTest: ƒ, constructor: ƒ}\nDate {constructor: ƒ, getTest: ƒ}\n\n~~~~以下是new出的对象~~~~~~~~~\nSat Jan 13 2018 21:58:55 GMT\x2b0800 (CST)\nMyDate2 {abc: 1}\nSat Jan 13 2018 21:58:55 GMT\x2b0800 (CST)\nMyDate {abc: 1}\n\n~~~~以下是new出的对象的Object.prototype.toString.call~~~~~~~~~\n[object Date]\n[object Object]\n[object Date]\n[object Object]\n\n~~~~以下是MyDate们的__proto__~~~~~~~~~\nƒ Date() { [native code] }\nƒ () { [native code] }\nƒ () { [native code] }\nƒ Date() { [native code] }\n\n~~~~以下是new出的对象的__proto__~~~~~~~~~\nDate {constructor: ƒ, getTest: ƒ}\nDate {constructor: ƒ, getTest: ƒ}\nDate {getTest: ƒ, constructor: ƒ}\nDate {constructor: ƒ, getTest: ƒ}\n\n~~~~以下是对象的__proto__与MyDate们的prototype比较~~~~~~~~~\ntrue\ntrue\ntrue\ntrue\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e~~~~以下是MyDate们的prototype~~~~~~~~~\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\n~~~~以下是\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e出的对象~~~~~~~~~\nSat Jan \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2018\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e58\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e55\x3c\/span\x3e GMT\x2b\x3cspan class=\x22hljs-number\x22\x3e0800\x3c\/span\x3e (CST)\nMyDate2 {\x3cspan class=\x22hljs-attr\x22\x3eabc\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}\nSat Jan \x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2018\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e58\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e55\x3c\/span\x3e GMT\x2b\x3cspan class=\x22hljs-number\x22\x3e0800\x3c\/span\x3e (CST)\nMyDate {\x3cspan class=\x22hljs-attr\x22\x3eabc\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}\n\n~~~~以下是\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e出的对象的\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call~~~~~~~~~\n[object \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e]\n\n~~~~以下是MyDate们的__proto__~~~~~~~~~\nƒ \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() { [native code] }\nƒ () { [native code] }\nƒ () { [native code] }\nƒ \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() { [native code] }\n\n~~~~以下是\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e出的对象的__proto__~~~~~~~~~\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ}\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: ƒ, \x3cspan class=\x22hljs-attr\x22\x3egetTest\x3c\/span\x3e: ƒ}\n\n~~~~以下是对象的__proto__与MyDate们的prototype比较~~~~~~~~~\n\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看出，主要差别有几点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eMyDate们的__proto__指向不一样\x3c\/li\x3e\n\x3cli\x3eObject.prototype.toString.call的输出不一样\x3c\/li\x3e\n\x3cli\x3e对象本质不一样，可以正常调用的\x3ccode\x3e1, 3\x3c\/code\x3e都是\x3ccode\x3eDate\x3c\/code\x3e构造出的，而其它的则是\x3ccode\x3eMyDate\x3c\/code\x3e构造出的\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e我们上文中得出的一个结论是：\x3cstrong\x3e由于调用的对象不是由Date构造出的实例，所以不允许调用，就算是自己的原型链上有Date.prototype也不行\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e但是这里有两个变量：\x3cstrong\x3e分别是底层构造实例的方法不一样，以及对象的\x3ccode\x3eObject.prototype.toString.call\x3c\/code\x3e的输出不一样\x3c\/strong\x3e。\x3cbr\x3e（另一个\x3ccode\x3eMyDate.__proto__\x3c\/code\x3e可以排除，因为原型链回溯肯定与它无关）\x3c\/p\x3e\n\x3cp\x3e万一它的判断是根据\x3ccode\x3eObject.prototype.toString.call\x3c\/code\x3e来的呢？那这样结论不就有误差了？\x3c\/p\x3e\n\x3cp\x3e于是，根据ES6中的，\x3ccode\x3eSymbol.toStringTag\x3c\/code\x3e，使用黑魔法，动态的修改下它，排除下干扰：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 分别可以给date2，date3设置\nObject.defineProperty(date2, Symbol.toStringTag, {\n    get: function() {\n        return \x26quot;Date\x26quot;;\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 分别可以给date2，date3设置\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(date2, \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag, {\n    \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Date\x22\x3c\/span\x3e;\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在打印下看看，变成这样了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[object Date]\n[object Date]\n[object Date]\n[object Object]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e[object \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e]\n[object \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，第二个的\x3ccode\x3eMyDate2\x3c\/code\x3e构造出的实例，虽然打印出来是\x3ccode\x3e[object Date]\x3c\/code\x3e，但是调用Date方法仍然是有错误\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/date_extend_error1.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e此时我们可以更加准确一点的确认：\x3cstrong\x3e由于调用的对象不是由Date构造出的实例，所以不允许调用\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e而且我们可以看到，就算通过黑魔法修改\x3ccode\x3eObject.prototype.toString.call\x3c\/code\x3e，内部的\x3ccode\x3e[[Class]]\x3c\/code\x3e标识位也是无法修改的。\x3cbr\x3e（这块知识点大概是Object.prototype.toString.call可以输出内部的[[Class]]，但无法改变它，由于不是重点，这里不赘述）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3eES6继承与ES5继承的区别\x3c\/h2\x3e\n\x3cp\x3e从上文中的分析可以看到一点：ES6的Class写法继承是没问题的。但是换成ES5写法就不行了。\x3c\/p\x3e\n\x3cp\x3e所以ES6的继承大法和ES5肯定是有区别的，那么究竟是哪里不同呢？（主要是结合的本文继承Date来说）\x3c\/p\x3e\n\x3cp\x3e区别：（以\x3ccode\x3eSubClass\x3c\/code\x3e，\x3ccode\x3eSuperClass\x3c\/code\x3e，\x3ccode\x3einstance\x3c\/code\x3e为例）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eES5中继承的实质是：（那种经典寄生组合式继承法）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e先由子类（\x3ccode\x3eSubClass\x3c\/code\x3e）构造出实例对象this\x3c\/li\x3e\n\x3cli\x3e然后在子类的构造函数中，将父类（\x3ccode\x3eSuperClass\x3c\/code\x3e）的属性添加到\x3ccode\x3ethis\x3c\/code\x3e上，\x3ccode\x3eSuperClass.apply(this, arguments)\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e子类原型（\x3ccode\x3eSubClass.prototype\x3c\/code\x3e）指向父类原型（\x3ccode\x3eSuperClass.prototype\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3e所以\x3ccode\x3einstance\x3c\/code\x3e是子类（\x3ccode\x3eSubClass\x3c\/code\x3e）构造出的（所以没有父类的\x3ccode\x3e[[Class]]\x3c\/code\x3e关键标志）\x3c\/li\x3e\n\x3cli\x3e所以，\x3ccode\x3einstance\x3c\/code\x3e有\x3ccode\x3eSubClass\x3c\/code\x3e和\x3ccode\x3eSuperClass\x3c\/code\x3e的所有实例属性，以及可以通过原型链回溯，获取\x3ccode\x3eSubClass\x3c\/code\x3e和\x3ccode\x3eSuperClass\x3c\/code\x3e原型上的方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eES6中继承的实质是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e先由父类（\x3ccode\x3eSuperClass\x3c\/code\x3e）构造出实例对象this，这也是为什么必须先调用父类的\x3ccode\x3esuper()\x3c\/code\x3e方法（子类没有自己的this对象，需先由父类构造）\x3c\/li\x3e\n\x3cli\x3e然后在子类的构造函数中，修改this（进行加工），譬如让它指向子类原型（\x3ccode\x3eSubClass.prototype\x3c\/code\x3e），这一步很关键，否则无法找到子类原型（\x3cem\x3e注，子类构造中加工这一步的实际做法是推测出的，从最终效果来推测\x3c\/em\x3e）\x3c\/li\x3e\n\x3cli\x3e然后同样，子类原型（\x3ccode\x3eSubClass.prototype\x3c\/code\x3e）指向父类原型（\x3ccode\x3eSuperClass.prototype\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3e所以\x3ccode\x3einstance\x3c\/code\x3e是父类（\x3ccode\x3eSuperClass\x3c\/code\x3e）构造出的（所以有着父类的\x3ccode\x3e[[Class]]\x3c\/code\x3e关键标志）\x3c\/li\x3e\n\x3cli\x3e所以，\x3ccode\x3einstance\x3c\/code\x3e有\x3ccode\x3eSubClass\x3c\/code\x3e和\x3ccode\x3eSuperClass\x3c\/code\x3e的所有实例属性，以及可以通过原型链回溯，获取\x3ccode\x3eSubClass\x3c\/code\x3e和\x3ccode\x3eSuperClass\x3c\/code\x3e原型上的方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e以上⬆就列举了些重要信息，其它的如静态方法的继承没有赘述。（静态方法继承实质上只需要更改下\x3ccode\x3eSubClass.__proto__\x3c\/code\x3e到\x3ccode\x3eSuperClass\x3c\/code\x3e即可）\x3c\/p\x3e\n\x3cp\x3e可以看着这张图快速理解：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_es5_and_es6.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_es5_and_es6.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e有没有发现呢：\x3cstrong\x3eES6中的步骤和本文中取巧继承Date的方法一模一样，不同的是ES6是语言底层的做法，有它的底层优化之处，而本文中的直接修改__proto__容易影响性能\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eES6中在super中构建this的好处？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e因为ES6中允许我们继承内置的类，如Date，Array，Error等。如果this先被创建出来，在传给Array等系统内置类的构造函数，这些内置类的构造函数是不认这个this的。\x3cbr\x3e所以需要现在super中构建出来，这样才能有着super中关键的\x3ccode\x3e[[Class]]\x3c\/code\x3e标志，才能被允许调用。（否则就算继承了，也无法调用这些内置类的方法）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e构造函数与实例对象\x3c\/h2\x3e\n\x3cp\x3e看到这里，不知道是否对上文中频繁提到的\x3cstrong\x3e构造函数\x3c\/strong\x3e，\x3cstrong\x3e实例对象\x3c\/strong\x3e有所混淆与困惑呢？这里稍微描述下：\x3c\/p\x3e\n\x3cp\x3e要弄懂这一点，需要先知道\x3ccode\x3enew\x3c\/code\x3e一个对象到底发生了什么？先形象点说：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3enew MyClass()中，都做了些什么工作\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function MyClass() {\n    this.abc = 1;\n}\n\nMyClass.prototype.print = function() {\n    console.log(\x27this.abc:\x27 \x2b this.abc);\n};\n\nlet instance = new MyClass();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyClass\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\nMyClass.prototype.print = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27this.abc:\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.abc);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e instance = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyClass();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e譬如，上述就是一个标准的实例对象生成，都发生了什么呢？\x3c\/p\x3e\n\x3cp\x3e步骤简述如下：（\x3cstrong\x3e参考MDN\x3c\/strong\x3e，还有部分关于底层的描述略去-如[[Class]]标识位等）\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e构造函数内部，创建一个新的对象，它继承自\x3ccode\x3eMyClass.prototype\x3c\/code\x3e，\x3ccode\x3elet instance = Object.create(MyClass.prototype);\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e使用指定的参数调用构造函数\x3ccode\x3eMyClass\x3c\/code\x3e，并将 this绑定到新创建的对象，\x3ccode\x3eMyClass.call(instance);\x3c\/code\x3e，执行后拥有所有实例属性\x3c\/li\x3e\n\x3cli\x3e如果构造函数返回了一个“对象”，那么这个对象会取代整个\x3ccode\x3enew\x3c\/code\x3e出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。）\x3c\/p\x3e\n\x3cp\x3e结合上述的描述，大概可以还原成以下代码：（简单还原，不考虑各种其它逻辑）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let instance = Object.create(MyClass.prototype);\nlet innerConstructReturn = MyClass.call(instance);\nlet innerConstructReturnIsObj = typeof innerConstructReturn === \x27object\x27 || typeof innerConstructReturn === \x27function\x27;\n\nreturn innerConstructReturnIsObj ? innerConstructReturn : instance;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e instance = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(MyClass.prototype);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e innerConstructReturn = MyClass.call(instance);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e innerConstructReturnIsObj = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e innerConstructReturn === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e innerConstructReturn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e innerConstructReturnIsObj ? innerConstructReturn : instance;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e注意⚠️：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e普通的函数构建，可以简单的认为就是上述步骤\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e实际上对于一些内置类（如Date等），并没有这么简单，还有一些自己的隐藏逻辑，譬如\x3ccode\x3e[[Class]]\x3c\/code\x3e标识位等一些重要私有属性。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e譬如可以在MDN上看到，以常规函数调用Date（即不加 new 操作符）将会返回一个字符串，而不是一个日期对象，如果这样模拟的话会无效\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e觉得看起来比较繁琐？可以看下图梳理：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_new_obj.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/dailc.github.io\/staticResource\/blog\/basicKnowledge\/extenddate\/extend_new_obj.png\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那现在再回头看看。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e什么是构造函数？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e如上述中的\x3ccode\x3eMyClass\x3c\/code\x3e就是一个构造函数，在内部它构造出了\x3ccode\x3einstance\x3c\/code\x3e对象\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e什么是实例对象？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3einstance\x3c\/code\x3e就是一个实例对象，它是通过\x3ccode\x3enew\x3c\/code\x3e出来的？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e实例与构造的关系\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e有时候浅显点，可以认为构造函数是xxx就是xxx的实例。即：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let instance = new MyClass();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e instance = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyClass();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时我们就可以认为\x3ccode\x3einstance\x3c\/code\x3e是\x3ccode\x3eMyClass\x3c\/code\x3e的实例，因为它的构造函数就是它\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e实例就一定是由对应的构造函数构造出的么？\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e不一定\x3c\/strong\x3e，我们那ES5黑魔法来做示例\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function MyDate() {\n    \/\/ bind属于Function.prototype，接收的参数是：object, param1, params2...\n    var dateInst = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))();\n\n    \/\/ 更改原型指向，否则无法调用MyDate原型上的方法\n    \/\/ ES6方案中，这里就是[[prototype]]这个隐式原型对象，在没有标准以前就是__proto__\n    Object.setPrototypeOf(dateInst, MyDate.prototype);\n\n    dateInst.abc = 1;\n\n    return dateInst;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyDate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind属于Function.prototype，接收的参数是：object, param1, params2...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dateInst = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.bind.apply(\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e, [\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e].concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e))))();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更改原型指向，否则无法调用MyDate原型上的方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES6方案中，这里就是[[prototype]]这个隐式原型对象，在没有标准以前就是__proto__\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(dateInst, MyDate.prototype);\n\n    dateInst.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dateInst;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以看到\x3ccode\x3einstance\x3c\/code\x3e的最终指向的原型是\x3ccode\x3eMyDate.prototype\x3c\/code\x3e，而\x3ccode\x3eMyDate.prototype\x3c\/code\x3e的构造函数是\x3ccode\x3eMyDate\x3c\/code\x3e，\x3cbr\x3e因此可以认为\x3ccode\x3einstance\x3c\/code\x3e是\x3ccode\x3eMyDate\x3c\/code\x3e的实例。\x3c\/p\x3e\n\x3cp\x3e但是，\x3cstrong\x3e实际上，\x3ccode\x3einstance\x3c\/code\x3e却是由\x3ccode\x3eDate\x3c\/code\x3e构造的\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们可以继续用\x3ccode\x3eES6\x3c\/code\x3e中的\x3ccode\x3enew.target\x3c\/code\x3e来验证。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3cspan style=\x22font-weight:normal;\x22\x3e⚠\x3c\/span\x3e️\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e关于\x3ccode\x3enew.target\x3c\/code\x3e，\x3ccode\x3eMDN\x3c\/code\x3e中的定义是：\x3cstrong\x3enew.target返回一个指向构造方法或函数的引用\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e嗯哼，也就是说，返回的是构造函数。\x3c\/p\x3e\n\x3cp\x3e我们可以在相应的构造中测试打印：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyDate extends Date {\n    constructor() {\n        super();\n        this.abc = 1;\n        console.log(\x27~~~new.target.name:MyDate~~~~\x27);\n        console.log(new.target.name);\n    }\n}\n\n\/\/ new操作时的打印结果是：\n\/\/ ~~~new.target.name:MyDate~~~~\n\/\/ MyDate\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyDate\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDate\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.abc = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27~~~new.target.name:MyDate~~~~\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e.target.name);\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ new操作时的打印结果是：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ~~~new.target.name:MyDate~~~~\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ MyDate\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后，可以在上面的示例中看到，就算是ES6的Class继承，\x3ccode\x3eMyDate\x3c\/code\x3e构造中打印\x3ccode\x3enew.target\x3c\/code\x3e也显示\x3ccode\x3eMyDate\x3c\/code\x3e，\x3cbr\x3e但实际上它是由\x3ccode\x3eDate\x3c\/code\x3e来构造（有着\x3ccode\x3eDate\x3c\/code\x3e关键的\x3ccode\x3e[[Class]]\x3c\/code\x3e标志，因为如果不是Date构造（如没有标志）是无法调用Date的方法的）。\x3c\/p\x3e\n\x3cp\x3e所以，实际上\x3cstrong\x3e用\x3ccode\x3enew.target\x3c\/code\x3e是无法判断实例对象到底是由哪一个构造构造的（这里指的是判断底层真正的\x3ccode\x3e[[Class]]\x3c\/code\x3e标志来源的构造）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在MDN上的定义也可以看到，\x3ccode\x3enew.target\x3c\/code\x3e返回的是直接构造函数（new作用的那个），所以请不要将直接构造函数与\x3cstrong\x3e实际上的构造\x3c\/strong\x3e搞混\x3c\/p\x3e\n\x3cp\x3e再回到结论：\x3cstrong\x3e实例对象不一定就是由它的原型上的构造函数构造的，有可能构造函数内部有着寄生等逻辑，偷偷的用另一个函数来构造了下\x3c\/strong\x3e,\x3cbr\x3e当然，简单情况下，我们直接说实例对象由对应构造函数构造也没错（不过，在涉及到这种Date之类的分析时，我们还是得明白）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e[[Class]]与Internal slot\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e这一部分为补充内容。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e前文中一直提到一个概念：\x3cstrong\x3eDate内部的\x3ccode\x3e[[Class]]\x3c\/code\x3e标识\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e其实，严格来说，不能这样泛而称之（前文中只是用这个概念是为了降低复杂度，便于理解），它可以分为以下两部分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e在ES5中，每种内置对象都定义了 [[Class]] 内部属性的值，[[Class]] 内部属性的值用于内部区分对象的种类\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eObject.prototype.toString\x3c\/code\x3e访问的就是这个[[Class]]\x3c\/li\x3e\n\x3cli\x3e规范中除了通过\x3ccode\x3eObject.prototype.toString\x3c\/code\x3e，没有提供任何手段使程序访问此值。\x3c\/li\x3e\n\x3cli\x3e而且Object.prototype.toString输出无法被修改\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e而在ES6中，之前的 [[Class]] 不再使用，取而代之的是一系列的\x3ccode\x3einternal slot\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eInternal slot 对应于与对象相关联并由各种ECMAScript规范算法使用的内部状态，它们没有对象属性，也不能被继承\x3c\/li\x3e\n\x3cli\x3e根据具体的 Internal slot 规范，这种状态可以由任何ECMAScript语言类型或特定ECMAScript规范类型值的值组成\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3eObject.prototype.toString\x3c\/code\x3e，仍然可以输出Internal slot值\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e简单点理解（简化理解）\x3c\/strong\x3e，Object.prototype.toString的流程是：如果是基本数据类型（除去Object以外的几大类型），则返回原本的slot，\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22如果是Object类型（包括内置对象以及自己写的对象），则调用`Symbol.toStringTag`\n\n- `Symbol.toStringTag`方法的默认实现就是返回对象的Internal slot，这个方法**可以被重写**\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e如果是Object类型（包括内置对象以及自己写的对象），则调用`Symbol.toStringTag`\n\n- `Symbol.toStringTag`方法的默认实现就是返回对象的Internal slot，这个方法**可以被重写**\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这两点是有所差异的，需要区分（不过简单点可以统一理解为内置对象内部都有一个特殊标识，用来区分对应类型-不符合类型就不给调用）。\x3c\/p\x3e\n\x3cp\x3eJS内置对象是这些：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;Arguments\x26quot;, \x26quot;Array\x26quot;, \x26quot;Boolean\x26quot;, \x26quot;Date\x26quot;, \x26quot;Error\x26quot;, \x26quot;Function\x26quot;, \x26quot;JSON\x26quot;, \x26quot;Math\x26quot;, \x26quot;Number\x26quot;, \x26quot;Object\x26quot;, \x26quot;RegExp\x26quot;, \x26quot;String\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22Arguments\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Array\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Boolean\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Date\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Function\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22JSON\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Math\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Number\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Object\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22RegExp\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22String\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES6新增的一些，这里未提到：（如Promise对象可以输出\x3ccode\x3e[object Promise]\x3c\/code\x3e）\x3c\/p\x3e\n\x3cp\x3e而前文中提到的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.defineProperty(date, Symbol.toStringTag, {\n    get: function() {\n        return \x26quot;Date\x26quot;;\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(date, \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag, {\n    \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Date\x22\x3c\/span\x3e;\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它的作用是重写Symbol.toStringTag，截取date（虽然是内置对象，但是仍然属于Object）的\x3ccode\x3eObject.prototype.toString\x3c\/code\x3e的输出，让这个对象输出自己修改后的\x3ccode\x3e[object Date]\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e但是，仅仅是做到输出的时候变成了Date，实际上内部的\x3ccode\x3einternal slot\x3c\/code\x3e值并没有被改变\x3c\/strong\x3e，因此仍然不被认为是Date\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e如何快速判断是否继承？\x3c\/h2\x3e\n\x3cp\x3e其实，在判断继承时，没有那么多的技巧，就只有关键的一点：\x3cstrong\x3e\x3ccode\x3e[[prototype]]\x3c\/code\x3e（\x3ccode\x3e__ptoto__\x3c\/code\x3e）的指向关系\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e譬如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(instance instanceof SubClass);\nconsole.log(instance instanceof SuperClass);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e SubClass);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e SuperClass);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实质上就是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eSubClass.prototype\x3c\/code\x3e是否出现在\x3ccode\x3einstance\x3c\/code\x3e的原型链上\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eSuperClass.prototype\x3c\/code\x3e是否出现在\x3ccode\x3einstance\x3c\/code\x3e的原型链上\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e然后，对照本文中列举的一些图，一目了然就可以看清关系。有时候，完全没有必要弄的太复杂。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3e写在最后的话\x3c\/h2\x3e\n\x3cp\x3e由于继承的介绍在网上已经多不胜数，因此本文没有再重复描述，而是由一道Date继承题引发，展开。（关键就是原型链）\x3c\/p\x3e\n\x3cp\x3e不知道看到这里，各位看官是否都已经弄懂了JS中的继承呢？\x3c\/p\x3e\n\x3cp\x3e另外，遇到问题时，多想一想，有时候你会发现，其实你知道的并不是那么多，然后再想一想，又会发现其实并没有这么复杂。。。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader21\x22\x3e附录\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3e博客\x3c\/h3\x3e\n\x3cp\x3e初次发布\x3ccode\x3e2018.01.15\x3c\/code\x3e于我个人博客上面\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.dailichun.com\/2018\/01\/15\/howtoextenddate.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.dailichun.com\/2018\/01\/15\/howtoextenddate.html\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3e参考资料\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Classes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Classes\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/stackoverflow.com\/questions\/6075231\/how-to-extend-the-javascript-date-object\/30882416\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/stackoverflow.com\/questions\/6075231\/how-to-extend-the-javascript-date-object\/30882416\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/exploringjs.com\/es6\/ch_classes.html#sec_essentials-classes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/exploringjs.com\/es6\/ch_classes.html#sec_essentials-classes\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/github_36978270\/article\/details\/71896444\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.csdn.net\/github_36978270\/article\/details\/71896444\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/pcaxb\/article\/details\/53784309\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.csdn.net\/pcaxb\/article\/details\/53784309\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/kittyjie\/article\/details\/50494915\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.csdn.net\/kittyjie\/article\/details\/50494915\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>如何继承Date对象？由一道题彻底弄懂JS继承。</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012841509">https://segmentfault.com/a/1190000012841509</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/t5bmsxkh4f/" target="_blank">https://alili.tech/archive/t5bmsxkh4f/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>