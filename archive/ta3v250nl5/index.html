<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一篇文章彻底说清JS的深拷贝/浅拷贝"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一篇文章彻底说清JS的深拷贝/浅拷贝 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ta3v250nl5/",
				"appid": "1613049289050283", 
				"title": "一篇文章彻底说清JS的深拷贝/浅拷贝 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-17T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/arcwclv1d8m/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0e1n25wybzra/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&text=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&text=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&is_video=false&description=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fta3v250nl5%2f&title=%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e5%bd%bb%e5%ba%95%e8%af%b4%e6%b8%85JS%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d%2f%e6%b5%85%e6%8b%b7%e8%b4%9d"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一篇文章彻底说清JS的深拷贝/浅拷贝</h1><div class="meta"><div class="postdate"><time datetime="2018-12-17" itemprop="datePublished">2018-12-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e一篇文章彻底说清JS的深拷贝and浅拷贝\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e这篇文章的受众\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e第一类,业务需要,急需知道如何深拷贝JS对象的开发者。\x3c\/li\x3e\n\x3cli\x3e第二类,希望扎实JS基础,将来好去面试官前秀操作的好学者。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e写给第一类读者\x3c\/h2\x3e\n\x3cblockquote\x3e你只需要一行黑科技代码就可以实现深拷贝\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var copyObj = {\n    name: \x27ziwei\x27,\n    arr : [1,2,3]\n}\n\nvar targetObj = JSON.parse(JSON.stringify(copyObj))\n\n此时 copyObj.arr !== targetObj.arr  已经实现了深拷贝 \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e copyObj = {\n    name: \x3cspan class=\x22hljs-string\x22\x3e\x27ziwei\x27\x3c\/span\x3e,\n    arr : [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n}\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e targetObj = JSON.parse(JSON.stringify(copyObj))\n\n此时 copyObj\x3cspan class=\x22hljs-selector-class\x22\x3e.arr\x3c\/span\x3e !== targetObj\x3cspan class=\x22hljs-selector-class\x22\x3e.arr\x3c\/span\x3e  已经实现了深拷贝 \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cstrong\x3e\x3cem\x3e别着急走,利用window.JSON的方法做深拷贝存在2个缺点:\x3c\/em\x3e\x3c\/strong\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e如果你的对象里有函数,函数无法被拷贝下来\x3c\/li\x3e\n\x3cli\x3e无法拷贝copyObj对象原型链上的属性和方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当然,你明确知道他们的缺点后,如果他的缺点对你的业务需求没有影响,就可以放心使用了,一行原生代码就能搞定。\x3c\/p\x3e\n\x3cp\x3e目前我在开发业务场景中,大多还真可以忽略上面2个缺点。往往需要深拷贝的对象里没有函数,也不需要拷贝它原型链的属性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e写给第二类读者\x3c\/h2\x3e\n\x3cp\x3e下面我会尽可能全面的讲解清楚JS里对象的拷贝,要讲清楚拷贝,你需要一点点前置知识\x3c\/p\x3e\n\x3cp\x3e你需要的前置知识:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e理解JS里的引用类型和值类型的区别,知道Obj存储的只是引用\x3c\/li\x3e\n\x3cli\x3e对原型链有基本了解\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e关于对象拷贝的全部:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e1.深拷贝、浅拷贝是什么\x3c\/li\x3e\n\x3cli\x3e2.深拷贝、浅拷贝在业务里的最常见的应用场景\x3c\/li\x3e\n\x3cli\x3e3.深拷贝和浅拷贝的实现方式\x3c\/li\x3e\n\x3cli\x3e4.总结与建议\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.深拷贝、浅拷贝是什么\x3c\/h3\x3e\n\x3cblockquote\x3e我们讨论JS对象深拷贝、浅拷贝的前提\x3c\/blockquote\x3e\n\x3cp\x3e只有对象里嵌套对象的情况下,才会根据需求讨论,我们要深拷贝还是浅拷贝。\x3c\/p\x3e\n\x3cp\x3e比如下面这种对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj1 = {\n    name: \x27ziwei\x27,\n    arr : [1,2,3]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e obj1 = {\n    name: \x3cspan class=\x22hljs-string\x22\x3e\x27ziwei\x27\x3c\/span\x3e,\n    arr : [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为,如果是类似这样{name: \x27ziwei\x27},没有嵌套对象的对象的话,就没必要区分深浅拷贝了。只有在有嵌套的对象时,深拷贝和浅拷贝才有区别\x3c\/p\x3e\n\x3cblockquote\x3e浅拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲)\x3c\/blockquote\x3e\n\x3cp\x3e调用shallowCopy()后,obj2拷贝obj1所有的属性。但是obj2.arr和obj1.arr是不同的引用,指向同一个内存空间\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var obj2 = shallowCopy( obj1 , {})\n \n console.log( obj1 !== obj2 )                   \/\/ true    无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)\n \n console.log( obj2.arr === obj1.arr )            \/\/ true   他们2个对象里arr的引用,指向【相同的】内存空间\n    \n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = shallowCopy( obj1 , {})\n \n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( obj1 !== obj2 )                   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true    无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)\x3c\/span\x3e\n \n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( obj2.arr === obj1.arr )            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true   他们2个对象里arr的引用,指向【相同的】内存空间\x3c\/span\x3e\n    \n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e所以, 2个obj经过拷贝后,虽然他们属性相同,也的确是不同的对象,但他们内部的obj都是指向同一个内存空间,这种我们叫浅拷贝\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e深拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲)\x3c\/blockquote\x3e\n\x3cp\x3e调用deepCopy()后,obj2拷贝obj1所有的属性,而且obj2.arr和obj1.arr是指向不同的内存空间,\x3c\/p\x3e\n\x3cp\x3e2个obj2除了拷贝了一样的属性,没有任何其他关联。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var obj2 = deepCopy( obj1 , {})\n \n console.log( obj1 !== obj2 )                   \/\/ true    无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)\n \n console.log( obj2.arr === obj1.arr )            \/\/ false   他们2个对象里arr的引用,指向【不同的】内存空间\n    \n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = deepCopy( obj1 , {})\n \n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( obj1 !== obj2 )                   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true    无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)\x3c\/span\x3e\n \n \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( obj2.arr === obj1.arr )            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false   他们2个对象里arr的引用,指向【不同的】内存空间\x3c\/span\x3e\n    \n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e所以, 2个obj经过拷贝后,除了拷贝下来相同的属性之外,没有任何其他关联的2个对象,这种我们叫深拷贝\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e2.深拷贝在业务里的最常见的应用场景\x3c\/h3\x3e\n\x3cp\x3e举个栗子,业务需求是 : 一个表格展示商品各种信息,点击【同意】时,是可以弹出对话框调整商品数量的。\x3c\/p\x3e\n\x3cp\x3e这种业务需求下,我们就会用到对象的深拷贝。因为【商品表格】的属性和【调整商品表格】的属性几乎一样,我们需要拷贝。\x3c\/p\x3e\n\x3cp\x3e下面的伪代码和图片就是展示使用浅拷贝存在的问题\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV1Zpx?w=1364\x26amp;h=486\x22 src=\x22https:\/\/static.alili.tech\/img\/bV1Zpx?w=1364\x26amp;h=486\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这样得到的adjustTableArr和tableArr里,内部对象都是相同的,所以就出现了图中红线标注的情况,\x3c\/p\x3e\n\x3cp\x3e当我们修改【调整商品表格】里的商品数量时,【商品表格】也跟着改变了,这并不是我们想要的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/\/ 表格对象的数据结构\nvar tableArr = [\n        {goods_name : \x27长袖腰背夹\x27 , code : \x27M216C239E0864\x27 , num : \x272\x27},\n        {goods_name : \x27长袖腰背夹\x27 , code : \x27M216C240B0170\x27 , num : \x273\x27},\n        {goods_name : \x27短塑裤\x27 , code : \x27M216D241C04106\x27 , num : \x273\x27},\n    ]\n    \nvar adjustTableArr = []                  \/\/ 调整表格用的数组\n\nfor (var key in tableArr) {               \/\/ 浅拷贝\n    adjustTableArr[key] = tableArr[key]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 表格对象的数据结构\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e tableArr = [\n        {goods_name : \x3cspan class=\x22hljs-string\x22\x3e\x27长袖腰背夹\x27\x3c\/span\x3e , \x3cspan class=\x22hljs-selector-tag\x22\x3ecode\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27M216C239E0864\x27\x3c\/span\x3e , num : \x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e},\n        {goods_name : \x3cspan class=\x22hljs-string\x22\x3e\x27长袖腰背夹\x27\x3c\/span\x3e , \x3cspan class=\x22hljs-selector-tag\x22\x3ecode\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27M216C240B0170\x27\x3c\/span\x3e , num : \x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e},\n        {goods_name : \x3cspan class=\x22hljs-string\x22\x3e\x27短塑裤\x27\x3c\/span\x3e , \x3cspan class=\x22hljs-selector-tag\x22\x3ecode\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27M216D241C04106\x27\x3c\/span\x3e , num : \x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e},\n    ]\n    \n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e adjustTableArr = []                  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调整表格用的数组\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e tableArr) {               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 浅拷贝\x3c\/span\x3e\n    adjustTableArr[key] = tableArr[key]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而实际上,我们希望这2个表格里的数据完全独立,互不干扰,只有在确认调整之后才刷新商品数量。\x3c\/p\x3e\n\x3cp\x3e这种情况下我们就可以使用前面说的深拷贝的一行黑科技\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var adjustTableArr = JSON.parse(JSON.stringify(tableArr))\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e adjustTableArr = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(tableArr))\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还记得它的缺陷吗? 对象里的函数无法被拷贝,原型链里的属性无法被拷贝。这里就对业务没有影响,可以很方便的深拷贝。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e3.深拷贝和浅拷贝的实现方式\x3c\/h3\x3e\n\x3cp\x3e其实JQ里已经有$.extend()函数,实现就是深拷贝和浅拷贝的功能。有兴趣的小伙伴也可以看看源码。\x3c\/p\x3e\n\x3cblockquote\x3e浅拷贝\x3c\/blockquote\x3e\n\x3cp\x3e浅拷贝比较简单,就是用for in 循环赋值\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function shallowCopy(source, target = {}) {\n        var key;\n        for (key in source) {\n            if (source.hasOwnProperty(key)) {        \/\/ 意思就是__proto__上面的属性,我不拷贝\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e    function shallowCopy(source, target = {}) {\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e source) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (source.hasOwnProperty(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e)) {        \/\/ 意思就是__proto__上面的属性,我不拷贝\n                target[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] = source[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e];\n            }\n        }\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e target;\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e深拷贝的实现\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e深拷贝,就是遍历那个被拷贝的对象\x3c\/li\x3e\n\x3cli\x3e判断对象里每一项的数据类型\x3c\/li\x3e\n\x3cli\x3e如果不是对象类型,就直接赋值,如果是对象类型,就再次调用deepCopy,递归的去赋值。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function deepCopy(source, target = {}) {\n        var key;\n        for (key in source) {\n            if (source.hasOwnProperty(key)) {                         \/\/ 意思就是__proto__上面的属性,我不拷贝\n                if (typeof(source[key]) === \x26quot;object\x26quot;) {               \/\/ 如果这一项是object类型,就递归调用deepCopy\n                    target[key] = Array.isArray(source[key]) ? [] : {};\n                    deepCopy(source[key], target[key]);\n                } else {                                            \/\/ 如果不是object类型,就直接赋值拷贝\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e    function deepCopy(source, target = {}) {\n        var \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e in source) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (source.hasOwnProperty(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e)) {                         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 意思就是__proto__上面的属性,我不拷贝\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof(source[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e]) === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果这一项是object类型,就递归调用deepCopy\x3c\/span\x3e\n                    target[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3eArray\x3c\/span\x3e.isArray(source[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e]) ? [] : {};\n                    deepCopy(source[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e], target[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e]);\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {                                            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不是object类型,就直接赋值拷贝\x3c\/span\x3e\n                    target[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] = source[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e];\n                }\n            }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target;\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上的无论深、浅拷贝,都用了source.hasOwnProperty(key),意思是判断这一项是否是其自有属性,是的话才拷贝,不是就不拷贝。\x3c\/p\x3e\n\x3cp\x3e也就是说__proto__上面的属性,我不拷贝。这个其实你可以根据业务需求,来决定加上和这个条件\x3c\/p\x3e\n\x3cp\x3e(JQ的$.extend()是会连__proto__上的属性也拷贝下来的,但是是直接拷贝到对象上,而不是放到之前的__proto__上)\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e4.总结与建议\x3c\/h3\x3e\n\x3cp\x3e虽然大家可能经常用框架提供的api来实现深拷贝。\x3c\/p\x3e\n\x3cp\x3e这篇文章分享的目的,更多还是希望用一篇文章整理清楚深浅拷贝的含义、递归实现思路,以及小伙伴们如果使用了JSON.parse()这种黑科技,一定要清楚这样写的优缺点。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一篇文章彻底说清JS的深拷贝/浅拷贝</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012828382">https://segmentfault.com/a/1190000012828382</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ta3v250nl5/" target="_blank">https://alili.tech/archive/ta3v250nl5/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>