<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="很全很全的前端本地存储讲解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>很全很全的前端本地存储讲解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/tkfdpcdrxq/",
				"appid": "1613049289050283", 
				"title": "很全很全的前端本地存储讲解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-20T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/opusli6kbsp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/h81zal7bfpa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&text=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&text=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&is_video=false&description=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftkfdpcdrxq%2f&title=%e5%be%88%e5%85%a8%e5%be%88%e5%85%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e8%ae%b2%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">很全很全的前端本地存储讲解</h1><div class="meta"><div class="postdate"><time datetime="2018-12-20" itemprop="datePublished">2018-12-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e最近一直在搞基础的东西，弄了一个持续更新的github笔记，可以去看看，诚意之作（本来就是写给自己看的……）链接地址：\x3ca href=\x22https:\/\/qiqihaobenben.github.io\/Front-End-Basics\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFront-End-Basics\x3c\/a\x3e  \x3c\/p\x3e\n\x3cp\x3e此篇文章的地址：\x3ca href=\x22https:\/\/qiqihaobenben.github.io\/Front-End-Basics\/JavaScript\/utility\/cache\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e三种本地存储方式\x3c\/a\x3e  \x3c\/p\x3e\n\x3cp\x3e基础笔记的github地址：\x3ca href=\x22https:\/\/github.com\/qiqihaobenben\/Front-End-Basics\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/qiqihaobenben\/Front-End-Basics\x3c\/a\x3e ,可以watch,也可以star。\x3c\/p\x3e\n\x3cblockquote\x3e发完之后，就有同学表示，你这也不全呀，还有评论说：吹牛不交税……，应该是被人举报了，现在看不到那条评论了，但是我邮箱里面有哦……本人水平有限只用过那三种，不过人家说的也是事实，我就有两个想法，第一是把标题改为“不太全的前端本地存储讲解”，第二种是把那不全的尽力补一下，嗯，做对的事情，我选择了第二种，补充的东西在最后。\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3ch4\x3e正文开始……\x3c\/h4\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e三种本地存储方式\x3c\/h2\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ecookie\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3e前言\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e网络早期最大的问题之一是如何管理状态。简而言之，服务器无法知道两个请求是否来自同一个浏览器。当时最简单的方法是在请求时，在页面中插入一些参数，并在下一个请求中传回参数。这需要使用包含参数的隐藏的表单，或者作为URL参数的一部分传递。这两个解决方案都手动操作，容易出错。cookie出现来解决这个问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3cstrong\x3e作用\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3ecookie是纯文本，没有可执行代码。存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie来向访问者电脑上存储数据，或者某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\x3cstrong\x3e如何工作\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。  \x3c\/p\x3e\n\x3cp\x3e存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那种设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\x3cstrong\x3e特征\x3c\/strong\x3e\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e不同的浏览器存放的cookie位置不一样，也是不能通用的。\x3c\/li\x3e\n\x3cli\x3ecookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。\x3c\/li\x3e\n\x3cli\x3e我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域以及当前域下的所有子域\x3c\/li\x3e\n\x3cli\x3e一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样,一般为20个。\x3c\/li\x3e\n\x3cli\x3e每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。\x3c\/li\x3e\n\x3cli\x3ecookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3ecookie值既可以设置，也可以读取。\x3c\/strong\x3e\x3c\/h3\x3e\n\x3ch4\x3e设置\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e客户端设置\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.cookie = \x27名字=值\x27;\ndocument.cookie = \x27username=cfangxu;domain=baike.baidu.com\x27    并且设置了生效域\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie = \x3cspan class=\x22hljs-string\x22\x3e\x27名字=值\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie = \x3cspan class=\x22hljs-string\x22\x3e\x27username=cfangxu;domain=baike.baidu.com\x27\x3c\/span\x3e    并且设置了生效域\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e 客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e服务器端设置\x3c\/strong\x3e  \x3cbr\x3e不管你是请求一个资源文件（如 html\/js\/css\/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Set-Cookie 消息头是一个字符串，其格式如下（中括号中的部分是可选的）：\nSet-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3eSet-Cookie 消息头是一个字符串，其格式如下（中括号中的部分是可选的）：\nSet-Cookie: value[\x3cspan class=\x22hljs-string\x22\x3e; expires=date\x3c\/span\x3e][\x3cspan class=\x22hljs-symbol\x22\x3e; domain=domain\x3c\/span\x3e][\x3cspan class=\x22hljs-string\x22\x3e; path=path\x3c\/span\x3e][\x3cspan class=\x22hljs-symbol\x22\x3e; secure\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e 一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。  \x3cbr\x3e服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly  \x3cbr\x3e通过 Set-Cookie 指定的这些可选项只会在浏览器端使用，而不会被发送至服务器端。\x3c\/p\x3e\n\x3ch4\x3e读取\x3c\/h4\x3e\n\x3cp\x3e我们通过document.cookie来获取当前网站下的cookie的时候，得到的字符串形式的值，它包含了当前网站下所有的cookie（为避免跨域脚本(xss)攻击，这个方法只能获取非 HttpOnly 类型的cookie）。它会把所有的cookie通过一个分号\x2b空格的形式串联起来，例如\x3ccode\x3eusername=chenfangxu; job=coding\x3c\/code\x3e\x3c\/p\x3e\n\x3ch4\x3e修改 cookie\x3c\/h4\x3e\n\x3cp\x3e要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path\/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。\x3c\/p\x3e\n\x3ch4\x3e删除\x3c\/h4\x3e\n\x3cp\x3e把要删除的cookie的过期时间设置成已过去的时间,path\/domain\/这几个选项一定要旧cookie 保持一样。\x3c\/p\x3e\n\x3ch4\x3e注意\x3c\/h4\x3e\n\x3cp\x3e如果只设置一个值，那么算cookie中的value; 设置的两个cookie,key值如果设置的相同，下面的也会把上面的覆盖。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\x3cstrong\x3ecookie的属性（可选项）\x3c\/strong\x3e\x3c\/h3\x3e\n\x3ch4\x3e过期时间\x3c\/h4\x3e\n\x3cp\x3e如果我们想长时间存放一个cookie。需要在设置这个cookie的时候同时给他设置一个过期的时间。如果不设置，cookie默认是临时存储的，当浏览器关闭进程的时候自动销毁\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22注意：document.cookie = \x27名称=值;expires=\x27 \x2b GMT(格林威治时间)格式的日期型字符串; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e注意：\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie = \x3cspan class=\x22hljs-string\x22\x3e\x27名称=值;expires=\x27\x3c\/span\x3e \x2b GMT(格林威治时间)格式的日期型字符串; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一般设置天数：new Date().setDate( oDate.getDate() \x2b 5 );    比当前时间多5天  \x3c\/p\x3e\n\x3cp\x3e一个设置cookie时效性的例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function setCookie(c_name, value, expiredays){\n    var exdate=new Date();\n    exdate.setDate(exdate.getDate() \x2b expiredays);\n    document.cookie=c_name\x2b \x26quot;=\x26quot; \x2b escape(value) \x2b ((expiredays==null) ? \x26quot;\x26quot; : \x26quot;;expires=\x26quot;\x2bexdate.toGMTString())\n}\n使用方法：setCookie(\x27username\x27,\x27cfangxu\x27,30)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetCookie\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ec_name, value, expiredays\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e exdate=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e();\n    exdate.setDate(exdate.getDate() \x2b expiredays);\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie=c_name\x2b \x3cspan class=\x22hljs-string\x22\x3e\x22=\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eescape\x3c\/span\x3e(value) \x2b ((expiredays==\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) ? \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22;expires=\x22\x3c\/span\x3e\x2bexdate.toGMTString())\n}\n使用方法：setCookie(\x3cspan class=\x22hljs-string\x22\x3e\x27username\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27cfangxu\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3eexpires 是 http\/1.0协议中的选项，在新的http\/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻\x2b max-age）。  \x3cbr\x3e另外，max-age 的默认值是 -1(即有效期为 session )；max-age有三种可能值：负数、0、正数。  \x3cbr\x3e负数：有效期session；  \x3cbr\x3e0：删除cookie；  \x3cbr\x3e正数：有效期为创建时刻\x2b max-age\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecookie的域概念（domain选项）\x3c\/h3\x3e\n\x3cp\x3edomain指定了 cookie 将要被发送至哪个或哪些域中。默认情况下，domain 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。  \x3c\/p\x3e\n\x3cp\x3e浏览器会把 domain 的值与请求的域名做一个尾部比较（即从字符串的尾部开始比较），并将匹配的 cookie 发送至服务器。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e客户端设置\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3edocument.cookie = \x22username=cfangxu;path=\/;domain=qq.com\x22\x3c\/code\x3e  \x3cbr\x3e如上：“www.qq.com\x22 与 \x22sports.qq.com\x22 公用一个关联的域名\x22qq.com\x22，我们如果想让 \x22sports.qq.com\x22 下的cookie被 \x22www.qq.com\x22 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 \x22\/\x22。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e服务端设置\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eSet-Cookie: username=cfangxu;path=\/;domain=qq.com\x3c\/code\x3e  \x3cbr\x3e\x3cem\x3e注：一定的是同域之间的访问，不能把domain的值设置成非主域的域名。\x3c\/em\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3ecookie的路径概念（path选项）\x3c\/h3\x3e\n\x3cp\x3ecookie 一般都是由于用户访问页面而被创建的，可是并不是只有在创建 cookie 的页面才可以访问这个 cookie。  \x3cbr\x3e因为安全方面的考虑,默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问。\x3cbr\x3e即path属性可以为服务器特定文档指定cookie，这个属性设置的url且带有这个前缀的url路径都是有效的。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e客户端设置\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e\x26nbsp;最常用的例子就是让 cookie 在根目录下,这样不管是哪个子页面创建的 cookie，所有的页面都可以访问到了。  \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edocument.cookie = \x22username=cfangxu; path=\/\x22\x3c\/code\x3e\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e服务端设置\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eSet-Cookie:name=cfangxu; path=\/blog\x3c\/code\x3e  \x3c\/p\x3e\n\x3cp\x3e如上设置：path 选项值会与 \/blog，\/blogrool 等等相匹配；任何以 \/blog 开头的选项都是合法的。需要注意的是，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3edomain和path总结：\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3edomain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。  \x3cbr\x3e所以domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。domain的默认值为设置该cookie的网页所在的域名，path默认值为设置该cookie的网页所在的目录。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3ecookie的安全性（secure选项）\x3c\/h3\x3e\n\x3cp\x3e通常 cookie 信息都是使用HTTP连接传递数据，这种传递方式很容易被查看，所以 cookie 存储的信息容易被窃取。假如 cookie 中所传递的内容比较重要，那么就要求使用加密的数据传输。  \x3c\/p\x3e\n\x3cp\x3esecure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。  \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edocument.cookie = \x22username=cfangxu; secure\x22\x3c\/code\x3e  \x3c\/p\x3e\n\x3cp\x3e把cookie设置为secure，只保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息。机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：如果想在客户端即网页中通过 js 去设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ehttpOnly\x3c\/h3\x3e\n\x3cp\x3e这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e\x3cstrong\x3ecookie的编码\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3ecookie其实是个字符串，但这个字符串中等号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；当然也可以用encodeURIComponent\/decodeURIComponent或者encodeURI\/decodeURI，\x3ca href=\x22http:\/\/www.cnblogs.com\/season-huang\/p\/3439277.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e查看关于编码的介绍\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e\x3cstrong\x3e第三方cookie\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e通常cookie的域和浏览器地址的域匹配，这被称为第一方cookie。那么第三方cookie就是cookie的域和地址栏中的域不匹配，这种cookie通常被用在第三方广告网站。为了跟踪用户的浏览记录，并且根据收集的用户的浏览习惯，给用户推送相关的广告。  \x3cbr\x3e关于第三方cookie和cookie的安全问题可以查看\x3ca href=\x22https:\/\/mp.weixin.qq.com\/s\/oOGIuJCplPVW3BuIx9tNQg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/mp.weixin.qq.com\/s\/oOGIuJCplPVW3BuIx9tNQg\x3c\/a\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3ecookie推荐资源\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004556040\x22\x3e聊一聊 cookie\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/bubkoo.com\/2014\/04\/21\/http-cookies-explained\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTTP cookies 详解\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3elocalStorage（本地存储）\x3c\/h2\x3e\n\x3cp\x3eHTML5新方法，不过\x3cstrong\x3eIE8及以上\x3c\/strong\x3e浏览器都兼容。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e特点\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。\x3c\/li\x3e\n\x3cli\x3e存储的信息在同一域中是共享的。\x3c\/li\x3e\n\x3cli\x3e当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。\x3c\/li\x3e\n\x3cli\x3e大小：据说是5M（跟浏览器厂商有关系）\x3c\/li\x3e\n\x3cli\x3e在非IE下的浏览中可以本地打开。IE浏览器要在服务器中打开。\x3c\/li\x3e\n\x3cli\x3elocalStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\x3c\/li\x3e\n\x3cli\x3elocalStorage受同源策略的限制\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e设置\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3elocalStorage.setItem(\x27username\x27,\x27cfangxu\x27);\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e获取\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3elocalStorage.getItem(\x27username\x27)\x3c\/code\x3e  \x3cbr\x3e也可以获取键名  \x3cbr\x3e\x3ccode\x3elocalStorage.key(0) #获取第一个键名 \x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e删除\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3elocalStorage.removeItem(\x27username\x27)\x3c\/code\x3e  \x3cbr\x3e也可以一次性清除所有存储  \x3cbr\x3e\x3ccode\x3elocalStorage.clear()\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3estorage事件\x3c\/h3\x3e\n\x3cp\x3e当storage发生改变的时候触发。  \x3cbr\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e 当前页面对storage的操作会触发其他页面的storage事件  \x3cbr\x3e事件的回调函数中有一个参数event,是一个StorageEvent对象，提供了一些实用的属性,如下表：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3eProperty\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eType\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3eDescription\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ekey\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eThe named key that was added, removed, or moddified\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eoldValue\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eAny\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eThe previous value(now overwritten), or null if a new item was added\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3enewValue\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eAny\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eThe new value, or null if an item was added\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eurl\/uri\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eString\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eThe page that called the method that triggered this change\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3esessionStorage\x3c\/h2\x3e\n\x3cp\x3e其实跟localStorage差不多，也是本地存储，会话本地存储\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e特点：\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3e用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁，或者在新窗口打开同源的另一个页面，sessionStorage也是没有的。\x3c\/li\x3e\x3c\/ul\x3e\n\x3chr\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader22\x22\x3ecookie、localStorage、sessionStorage区别\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e相同：在本地（浏览器端）存储数据\x3c\/li\x3e\n\x3cli\x3e不同：  \x3cp\x3elocalStorage、sessionStorage  \x3c\/p\x3e\n\x3cp\x3elocalStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取\/修改到同一份localStorage数据。  \x3c\/p\x3e\n\x3cp\x3esessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。    \x3c\/p\x3e\n\x3cp\x3elocalStorage是永久存储，除非手动删除。  \x3c\/p\x3e\n\x3cp\x3esessionStorage当会话结束（当前页面关闭的时候，自动销毁） \x3c\/p\x3e\n\x3cp\x3ecookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cbr\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3e扩展其他的前端存储方式（不常用）\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3eweb SQL database\x3c\/h3\x3e\n\x3cp\x3e先说个会被取代的，为什么会被取代，主要有以下几个原因：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eW3C舍弃 \x3ccode\x3eWeb SQL database\x3c\/code\x3e草案,而且是在2010年年底，规范不支持了，浏览器厂商已经支持的就支持了，没有支持的也不打算支持了，比如IE和Firefox。\x3c\/li\x3e\n\x3cli\x3e为什么要舍弃？因为 \x3ccode\x3eWeb SQL database\x3c\/code\x3e 本质上是一个关系型数据库，后端可能熟悉，但是前端就有很多不熟悉了，虽然SQL的简单操作不难，但是也得需要学习。\x3c\/li\x3e\n\x3cli\x3eSQL熟悉后，真实操作中还得把你要存储的东西，比如对象，转成SQL语句，也挺麻烦的。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3eindexedDB\x3c\/h3\x3e\n\x3cblockquote\x3e来自MDN的解释： indexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件\/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。\x3c\/blockquote\x3e\n\x3cp\x3e所以，\x3ccode\x3eIndexedDB\x3c\/code\x3e API是强大的，但对于简单的情况可能看起来太复杂了，所以要看你的业务场景来选择到底是用还是不用。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eindexedDB\x3c\/code\x3e 是一个基于JavaScript的面向对象的数据库。 \x3ccode\x3eIndexedDB\x3c\/code\x3e允许你存储和检索用键索引的对象;\x3c\/p\x3e\n\x3cp\x3eIndexedDB 鼓励使用的基本模式如下所示：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e打开数据库并且开始一个事务。\x3c\/li\x3e\n\x3cli\x3e创建一个 object store。\x3c\/li\x3e\n\x3cli\x3e构建一个请求来执行一些数据库操作，像增加或提取数据等。\x3c\/li\x3e\n\x3cli\x3e通过监听正确类型的 DOM 事件以等待操作完成。\x3c\/li\x3e\n\x3cli\x3e在操作结果上进行一些操作（可以在 request 对象中找到）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e1、首先打开indexedDB数据库\x3c\/h4\x3e\n\x3cp\x3e语法：  \x3cbr\x3e\x3ccode\x3ewindow.indexedDB.open(dbName, version)\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var db;\n\/\/ 打开数据库,open还有第二个参数版本号\nvar request = window.indexedDB.open(\x27myTestDatabase\x27);\n\/\/ 数据库打开成功后\nrequest.onsuccess = function (event) {\n    \/\/ 存储数据结果,后面所有的数据库操作都离不开它。\n    db = request.result;\n}\nrequest.onerror = function (event) {\n    alert(\x26quot;Why didn\x27t you allow my web app to use IndexedDB?!\x26quot;);\n}\n\n\/\/ 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高）\nrequest.onupgradeneeded = function (event) {\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e db;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开数据库,open还有第二个参数版本号\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e request = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.indexedDB.open(\x3cspan class=\x22hljs-string\x22\x3e\x27myTestDatabase\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据库打开成功后\x3c\/span\x3e\nrequest.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 存储数据结果,后面所有的数据库操作都离不开它。\x3c\/span\x3e\n    db = request.result;\n}\nrequest.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22Why didn\x27t you allow my web app to use IndexedDB?!\x22\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高）\x3c\/span\x3e\nrequest.onupgradeneeded = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eonupgradeneeded事件：\x3c\/strong\x3e 更新数据库的 schema，也就是创建或者删除对象存储空间，这个事件将会作为一个允许你处理对象存储空间的 \x3ccode\x3eversionchange\x3c\/code\x3e 事务的一部分被调用。在数据库第一次被打开时或者当指定的版本号高于当前被持久化的数据库的版本号时，这个 \x3ccode\x3eversionchange\x3c\/code\x3e 事务将被创建。\x3ccode\x3eonupgradeneeded\x3c\/code\x3e 是我们唯一可以修改数据库结构的地方。在这里面，我们可以创建和删除对象存储空间以及构建和删除索引。\x3c\/p\x3e\n\x3ch4\x3e2、构建数据库\x3c\/h4\x3e\n\x3cp\x3eIndexedDB 使用对象存储空间而不是表，并且一个单独的数据库可以包含任意数量的对象存储空间。每当一个值被存储进一个对象存储空间时，它会被和一个键相关联。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高）\n  request.onupgradeneeded = function (event) {\n\n      \/\/之前咱们不是在success中得到了db了么，为什么还要在这获取，\n      \/\/因为在当前事件函数执行后才会去执行success事件\n      var db = event.target.result;\n\n      \/\/ 创建一个对象存储空间，keyPath是id，keyGenerator是自增的\n      var objectStore = db.createObjectStore(\x27testItem\x27,{keyPath: \x27id\x27,autoIncrement: true});\n      \/\/ 创建一个索引来通过id搜索，id是自增的，不会有重复，所以可以用唯一索引\n      objectStore.createIndex(\x27id\x27,\x27id\x27,{unique: true})\n\n      objectStore.createIndex(\x27name\x27,\x27name\x27);\n      objectStore.createIndex(\x27age\x27,\x27age\x27);\n\n      \/\/添加一条信息道数据库中\n      objectStore.add({name: \x27cfangxu\x27, age: \x2727\x27});\n\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高）\x3c\/span\x3e\n  request.onupgradeneeded = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(event)\x3c\/span\x3e \x3c\/span\x3e{\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/之前咱们不是在success中得到了db了么，为什么还要在这获取，\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/因为在当前事件函数执行后才会去执行success事件\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e db = event.target.result;\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个对象存储空间，keyPath是id，keyGenerator是自增的\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objectStore = db.createObjectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e,{keyPath: \x3cspan class=\x22hljs-string\x22\x3e\x27id\x27\x3c\/span\x3e,autoIncrement: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e});\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个索引来通过id搜索，id是自增的，不会有重复，所以可以用唯一索引\x3c\/span\x3e\n      objectStore.createIndex(\x3cspan class=\x22hljs-string\x22\x3e\x27id\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27id\x27\x3c\/span\x3e,{unique: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e})\n\n      objectStore.createIndex(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e);\n      objectStore.createIndex(\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e);\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加一条信息道数据库中\x3c\/span\x3e\n      objectStore.add({name: \x3cspan class=\x22hljs-string\x22\x3e\x27cfangxu\x27\x3c\/span\x3e, age: \x3cspan class=\x22hljs-string\x22\x3e\x2727\x27\x3c\/span\x3e});\n\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e 执行完后，在调试工具栏Application的indexedDB中也看不到，你得右键刷新一下。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e创建索引的语法：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22objectStore.createIndex(indexName, keyPath, objectParameters)\n\nindexName:创建的索引名称，可以使用空名称作为索引。\nkeyPath:索引使用的关键路径，可以使用空的keyPath, 或者keyPath传为数组keyPath也是可以的。\nobjectParameters:可选参数。常用参数之一是unique，表示该字段值是否唯一，不能重复。例如，本demo中id是不能重复的，于是有设置：\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs avrasm\x22\x3e\x3ccode\x3eobjectStore.createIndex(indexName, keyPath, objectParameters)\n\n\x3cspan class=\x22hljs-symbol\x22\x3eindexName:\x3c\/span\x3e创建的索引名称，可以使用空名称作为索引。\n\x3cspan class=\x22hljs-symbol\x22\x3ekeyPath:\x3c\/span\x3e索引使用的关键路径，可以使用空的keyPath, 或者keyPath传为数组keyPath也是可以的。\n\x3cspan class=\x22hljs-symbol\x22\x3eobjectParameters:\x3c\/span\x3e可选参数。常用参数之一是unique，表示该字段值是否唯一，不能重复。例如，本demo中id是不能重复的，于是有设置：\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e3、添加数据\x3c\/h4\x3e\n\x3cp\x3e上面的代码建好了字段，并且添加了一条数据，但是我们如果想在onupgradeneeded事件外面操作，接下来的步骤了。  \x3cbr\x3e由于数据库的操作都是基于事务（transaction）来进行，于是，无论是添加编辑还是删除数据库，我们都要先建立一个事务（transaction），然后才能继续下面的操作。  \x3cbr\x3e语法： \x3ccode\x3evar transaction = db.transaction(dbName, \x22readwrite\x22);\x3c\/code\x3e  \x3cbr\x3e第一个参数是事务希望跨越的对象存储空间的列表，可以是数组或者字符串。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。如果你没有为第二个参数指定任何内容，你得到的是只读事务。因为这里我们是想要写入所以我们需要传入 \x22readwrite\x22 标识。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var timer = setInterval(function () {\n    if(db) {\n        clearInterval(timer);\n        \/\/ 新建一个事务\n        var transaction = db.transaction([\x27testItem\x27], \x27readwrite\x27);\n        \/\/ 打开一个存储对象\n        var objectStore = transaction.objectStore(\x27testItem\x27);\n        \/\/ 添加数据到对象中\n        objectStore.add({ name: \x27xiaoming\x27, age: \x2712\x27 });\n        objectStore.add({ name: \x27xiaolong\x27, age: \x2720\x27 });\n    }\n},100)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timer = setInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(db) {\n        clearInterval(timer);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建一个事务\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27readwrite\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开一个存储对象\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加数据到对象中\x3c\/span\x3e\n        objectStore.add({ name: \x3cspan class=\x22hljs-string\x22\x3e\x27xiaoming\x27\x3c\/span\x3e, age: \x3cspan class=\x22hljs-string\x22\x3e\x2712\x27\x3c\/span\x3e });\n        objectStore.add({ name: \x3cspan class=\x22hljs-string\x22\x3e\x27xiaolong\x27\x3c\/span\x3e, age: \x3cspan class=\x22hljs-string\x22\x3e\x2720\x27\x3c\/span\x3e });\n    }\n},\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e为什么要用一个间隔定时器？\x3c\/strong\x3e 因为这是一个demo，正常的是要有操作才能进行数据库的写入，在我们的demo中，js执行到transaction会比indexedDB的onsuccess事件回调快，导致会拿到db为undefined，所以写了个间隔定时器等它一会。\x3c\/p\x3e\n\x3ch4\x3e4、获取数据\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var transaction = db.transaction([\x27testItem\x27], \x27readwrite\x27);\n\nvar objectStore = transaction.objectStore(\x27testItem\x27);\n\nvar getRquest = objectStore.get(1);\ngetRquest.onsuccess = function (event) {\n    console.log(getRquest.result);\n}\n\/\/输出：{name: \x26quot;cfangxu\x26quot;, age: \x26quot;27\x26quot;, id: 1}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27readwrite\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getRquest = objectStore.get(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ngetRquest.onsuccess = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(getRquest.result);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/输出：{name: \x22cfangxu\x22, age: \x2227\x22, id: 1}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e5、修改数据\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var transaction = db.transaction([\x27testItem\x27], \x27readwrite\x27);\n\nvar objectStore = transaction.objectStore(\x27testItem\x27);\n\nvar getRquest = objectStore.put({ name: \x27chenfangxu\x27, age: \x2727\x27, id:1 });\n\/\/ 修改了id为1的那条数据\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27readwrite\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e getRquest = objectStore.put({ \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27chenfangxu\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2727\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3eid:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e1 });\n\/\/ 修改了id\x3c\/span\x3e为\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e的那条数据\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e6、删除数据\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var transaction = db.transaction([\x27testItem\x27], \x27readwrite\x27);\n\nvar objectStore = transaction.objectStore(\x27testItem\x27);\n\nvar getRquest = objectStore.delete(1);\n\/\/ 删除了id为1的那条数据\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs go\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e transaction = db.transaction([\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-string\x22\x3e\x27readwrite\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e objectStore = transaction.objectStore(\x3cspan class=\x22hljs-string\x22\x3e\x27testItem\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getRquest = objectStore.\x3cspan class=\x22hljs-built_in\x22\x3edelete\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除了id为1的那条数据\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e上面的例子执行完后，一定一定要右键刷新indexedDB,它自己是不会变的。\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e关于数据库的名词解释和indexedDB的游标介绍参阅：\x3ca href=\x22http:\/\/www.zhangxinxu.com\/wordpress\/2017\/07\/html5-indexeddb-js-example\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 indexedDB前端本地存储数据库实例教程\x3c\/a\x3e 张大神的文中没有指出新手要踩的坑，我踩完也说明了。\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>很全很全的前端本地存储讲解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012578794">https://segmentfault.com/a/1190000012578794</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/tkfdpcdrxq/" target="_blank">https://alili.tech/archive/tkfdpcdrxq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>