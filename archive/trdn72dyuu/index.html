<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="理解React组件的生命周期"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>理解React组件的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/trdn72dyuu/",
				"appid": "1613049289050283", 
				"title": "理解React组件的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ik2skfkdbg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7wn227097dq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&text=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&text=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&title=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&is_video=false&description=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&title=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&title=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&title=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftrdn72dyuu%2f&title=%e7%90%86%e8%a7%a3React%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">理解React组件的生命周期</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact提供了很多钩子函数使我们可以在合适的时间、合适的节点更新组件的状态，这些钩子是生命周期函数，想要使用React，我们必须掌握在钩子中可以做什么，不可以做什么。\x3c\/p\x3e\n\x3cblockquote\x3e？？首先大家想一下在哪里发送请求比较合适\x3ccode\x3ecomponentWillMount\x3c\/code\x3e、\x3ccode\x3ecomponentDidMount\x3c\/code\x3e、\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e、\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e?\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4ca1?w=1169\x26amp;h=742\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4ca1?w=1169\x26amp;h=742\x22 alt=\x22reactlifecycle.png\x22 title=\x22reactlifecycle.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e组件3个阶段\x3c\/h2\x3e\n\x3cp\x3e组件的生命主要包括3个阶段： 挂载、更新、卸载，React 16开始还添加了错误处理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e挂载\x3c\/h3\x3e\n\x3cp\x3e组件被实例化并挂载在到dom树这一过程称为挂载\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4cbb?w=289\x26amp;h=470\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4cbb?w=289\x26amp;h=470\x22 alt=\x22mounting.png\x22 title=\x22mounting.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3econstructor()\x3c\/li\x3e\n\x3cli\x3ecomponentWillMount()\x3c\/li\x3e\n\x3cli\x3erender()\x3c\/li\x3e\n\x3cli\x3ecomponentDidMount()\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e更新\x3c\/h3\x3e\n\x3cp\x3e当组件的属性或者状态改变时会重新渲染\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4cbh?w=519\x26amp;h=757\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4cbh?w=519\x26amp;h=757\x22 alt=\x22updating.png\x22 title=\x22updating.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ecomponentWillReceiveProps()\x3c\/li\x3e\n\x3cli\x3eshouldComponentUpdate()\x3c\/li\x3e\n\x3cli\x3ecomponentWillUpdate()\x3c\/li\x3e\n\x3cli\x3erender()\x3c\/li\x3e\n\x3cli\x3ecomponentDidUpdate()\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当执行this.forceUpdate时，shouldComponentUpdate将不会被触发\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4cbG?w=373\x26amp;h=371\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4cbG?w=373\x26amp;h=371\x22 alt=\x22forceUpdate.png\x22 title=\x22forceUpdate.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e卸载\x3c\/h3\x3e\n\x3cp\x3e当一个组件被移出Dom树时，组件就会被卸载\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3ecomponentWillUnmount()\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eError Handling\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4cbJ?w=643\x26amp;h=402\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4cbJ?w=643\x26amp;h=402\x22 alt=\x22error-handleing.png\x22 title=\x22error-handleing.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3ecomponentDidCatch()\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3econstructor\x3c\/h2\x3e\n\x3cp\x3e当组件被实例化时，构造函数就被会最先执行。需要注意的是constructor的第一行必须是\x3ccode\x3esuper(props)\x3c\/code\x3e语句。\x3c\/p\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e设置组件的初始状态\x3c\/li\x3e\n\x3cli\x3ebind function\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e简单解释下bind function,当类的方法作为事件处理函数时，有可能会丢失this指向，有两种常见的解决方案：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ This binding is necessary to make `this` work in the callback\nthis.handleClick = this.handleClick.bind(this); \/\/ 上面提到的bind function\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This binding is necessary to make `this` work in the callback\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上面提到的bind function\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22使用箭头函数声明处理函数，个人比较推荐这种方案，代码简洁干净\nhandleClick = () =\x3e {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e使用箭头函数声明处理函数，个人比较推荐这种方案，代码简洁干净\nhandleClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e向后台发送请求进而更新组件状态\x3c\/li\x3e\n\x3cli\x3e使用this.setState初始化\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e下图是强行在constructor中调用this.setState所发出的警告，在constructor中调用this.setState是没有任何作用的\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4cbO?w=2536\x26amp;h=136\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4cbO?w=2536\x26amp;h=136\x22 alt=\x22setStateError.png\x22 title=\x22setStateError.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3ecomponentWillMount\x3c\/h2\x3e\n\x3cp\x3e它也只会在挂载过程中被调用一次，它的作用和constructor没有太大差异。有很多人在componentWillMount中请求后台数据，认为这样可以更早的得到数据，componentWillMout是在render函数执行前执行的，虽然请求是在第一次render之前发送的，但是返回并不能保证在render之前完成。React中不推荐在componentWillMount中发送异步请求?。\x3c\/p\x3e\n\x3cp\x3e还有一点需要了解： 在componentWillMount中执行this.setState是不会触发二次渲染的。仔细思考一下，componentWillMount好像没啥卵用了。正所谓存在即合理，在服务端渲染的场景中componentDidMount是不会被执行的，因此可以在componnetWillMount中发生AJAX请求。\x3c\/p\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用this.setState更新组件状态\x3c\/li\x3e\n\x3cli\x3e发送AJAX请求(服务端渲染场景中)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e发送AJAX请求(浏览器渲染场景中)\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3ecomponentDidMount\x3c\/h2\x3e\n\x3cp\x3e此函数只会被调用一次既组件挂载完成时，在render函数调用之后。组件挂载完成表示它的子组件也全部被挂载完成。\x3ccode\x3e父组件render -\x26gt;子组件render-\x26gt;子子组件render ... ...子子组件DidMount -\x26gt; 子组件DidMount -\x26gt; 父组件DidMount\x3c\/code\x3e。React就是个递归的世界。componentDidMount函数中可以发生异步请求。\x3c\/p\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e发送AJAX请求\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\x3cli\x3ethis.setState更新状态，因为会触发二次渲染\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3ecomponentWillReceiveProps\x3c\/h2\x3e\n\x3cp\x3e当父组件re-render时该钩子函数就会执行，即使所传入的属性没有改变。这个钩子最大的用途：组件的部分状态是依赖于属性时做状态同步使用，在其中使用this.setState是不会触发\x3ccode\x3e额外\x3c\/code\x3e的渲染的，this.setState的状态更新和props触发的render合并一次进行。要合理使用componentWillReceiveProps需记住做好条件判断：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentWillReceiveProps(nextProps) {\n  if(nextProps.myProp !== this.props.myProps) {\n    \/\/ nextProps.myProp has a different value than our current prop\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecomponentWillReceiveProps(nextProps) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(nextProps.myProp !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.myProps) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nextProps.myProp has a different value than our current prop\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请不要尝试在componentWillReceiveProps中发送异步请求(React Fiber后该钩子函数可能会被触发多次)?\x3c\/p\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e根据Props的更新同步组件状态\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e发生异步请求\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eshouldComponentUpdate\x3c\/h2\x3e\n\x3cp\x3eshouldComponentUpdate主要是用来优化React应用性能的，水平没达到一定高度就不要去动它了。组件的状态或者属性改变时都会触发该函数，但只有在返回true时，组件才会被重新渲染。\x3c\/p\x3e\n\x3cp\x3eDO or DON’T\x3cbr\x3e什么也不要做就对了?\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3ecomponentWillUpdate\x3c\/h2\x3e\n\x3cp\x3e当我们没有覆写componentShouldUpdate时，componentWillUpdate会在其之后立即执行。当shouldComponent被覆写过时，componentWillUpdate主要用来取代componentWillReceiveProps，用来同步Props至组件的部分状态。\x3c\/p\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e同步Props到组件状态\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e发生异步请求\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3ecomponentDidUpdate\x3c\/h2\x3e\n\x3cp\x3e它和componentDidMount的功能类似，componentDidMount发生于组件的首次render之后，而componentDidUpdate则是发生于组件状态及属性变化所导致的re-render之后。主要是用来请求后台数据。和componentWillReceiveProps类似，做相应处理时，需要做属性是否变更的判断，如下面代码所示。有趣的一点： componentWillReceiveProps接收的参数是nextProps, componentDidUpdate接收的是preProps。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22componentDidUpdate(prevProps) {\n  if(prevProps.myProps !== this.props.myProp) {\n    \/\/ this.props.myProp has a different value\n    \/\/ ...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ecomponentDidUpdate(prevProps) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(prevProps.myProps !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.myProp) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.props.myProp has a different value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eDO\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e异步请求\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eDON’T\x3c\/p\x3e\n\x3col\x3e\x3cli\x3ethis.setState更新状态，会触发二次渲染\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3ecomponentWillUnmount\x3c\/h2\x3e\n\x3cp\x3e当组件被卸载时被调用，在这里主要做一些清理操作，清理定时器、关闭socket、清除监听器等等\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3ecomponentDidCatch\x3c\/h2\x3e\n\x3cp\x3eReact的错误机制：子组件中产生的错误若并未被捕获或处理会抛给父组件，若上层也一直没有处理，错误将会被抛至最顶层导致浏览器白屏。\x3cbr\x3eReact16开始添加了一个新的特性\x3ccode\x3e错误处理\x3c\/code\x3e。componentDidCatch十分特别，它只可以处理子组件中产生的、未处理的错误，能够捕获的错误类型有子组件render函数中产生的错误及生命周期函数中产生的非异步错误。用法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/父组件或祖宗组件中实现\ncomponentDidCatch(errorString, errorInfo) {\n  this.setState({\n    error: errorString\n  });\n  ErrorLoggingTool.log(errorInfo);\n}\nrender() {\n  if(this.state.error) return \x3cShowErrorMessage error={this.state.error} \/\x3e\n  return (\n    \/\/ render normal component output\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/父组件或祖宗组件中实现\x3c\/span\x3e\ncomponentDidCatch(errorString, errorInfo) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n    \x3cspan class=\x22hljs-attr\x22\x3eerror\x3c\/span\x3e: errorString\n  });\n  ErrorLoggingTool.log(errorInfo);\n}\nrender() {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.error) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eShowErrorMessage\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eerror\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.error}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  return (\n    \/\/ render normal component output\n  );\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e在哪请求数据\x3c\/h2\x3e\n\x3cp\x3e？？首先大家想一下在哪里发送请求比较合适\x3ccode\x3ecomponentWillMount\x3c\/code\x3e、\x3ccode\x3ecomponentDidMount\x3c\/code\x3e、\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e、\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e?\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3ecomponentDidMount\x3c\/code\x3e和\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e中。?\x3c\/p\x3e\n\x3cp\x3e本文是阅读了\x3ca href=\x22https:\/\/medium.com\/@baphemot\/understanding-reactjs-component-life-cycle-823a640b3e8d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnderstanding React — Component life-cycle\x3c\/a\x3e和官方文档后做的总结，也可以说是我抄来得?，欢迎大家批评指正。\x3ca href=\x22https:\/\/github.com\/xiyuanyuan\/react16-lifecycle\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecode\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/l\/1500000013813893\x22\x3eReact系列课程之 入门\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/medium.com\/@baphemot\/understanding-reactjs-component-life-cycle-823a640b3e8d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnderstanding React — Component life-cycle\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/reactjs.org\/docs\/react-component.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact.Component\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/react.tips\/how-to-use-react-component-lifecycle-methods\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecomponent-lifecycle-methods\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e【开发环境推荐】\x3ca href=\x22https:\/\/studio.coding.net\/intro\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCloud Studio\x3c\/a\x3e 是基于浏览器的集成式开发环境，支持绝大部分编程语言，包括 HTML5、PHP、Python、Java、Ruby、C\/C\x2b\x2b、.NET 小程序等等，无需下载安装程序，一键切换开发环境。 Cloud Studio提供了完整的 Linux 环境，并且支持自定义域名指向，动态计算资源调整，可以完成各种应用的开发编译与部署。\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>理解React组件的生命周期</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013354181">https://segmentfault.com/a/1190000013354181</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/trdn72dyuu/" target="_blank">https://alili.tech/archive/trdn72dyuu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>