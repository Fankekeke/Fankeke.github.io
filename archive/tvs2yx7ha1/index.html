<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="flutter实战5：异步async、await和Future的使用技巧"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>flutter实战5：异步async、await和Future的使用技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/tvs2yx7ha1/",
				"appid": "1613049289050283", 
				"title": "flutter实战5：异步async、await和Future的使用技巧 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/291lwr58l13/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zkvkv2tdprq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&text=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&text=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&title=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&is_video=false&description=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&title=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&title=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&title=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftvs2yx7ha1%2f&title=flutter%e5%ae%9e%e6%88%985%ef%bc%9a%e5%bc%82%e6%ad%a5async%e3%80%81await%e5%92%8cFuture%e7%9a%84%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">flutter实战5：异步async、await和Future的使用技巧</h1><div class="meta"><div class="postdate"><time datetime="2018-12-05" itemprop="datePublished">2018-12-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e由于前面的\x3cstrong\x3eHTTP\x3c\/strong\x3e请求用到了异步操作，不少小伙伴都被这个问题折了下腰，今天总结分享下实战成果。Dart是一个单线程的语言，遇到有延迟的运算（比如IO操作、延时执行）时，线程中按顺序执行的运算就会阻塞，用户就会感觉到卡顿，于是通常用异步处理来解决这个问题。当遇到有需要延迟的运算（\x3cstrong\x3easync\x3c\/strong\x3e）时，将其放入到延迟运算的队列（\x3cstrong\x3eawait\x3c\/strong\x3e）中去，把不需要延迟运算的部分先执行掉，最后再来处理延迟运算的部分。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3easync和await\x3c\/h2\x3e\n\x3cp\x3e首先看一个案例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/HTTP的get请求返回值为Future\x3cString\x3e类型，即其返回值未来是一个String类型的值\n  getData() async {    \/\/async关键字声明该函数内部有代码需要延迟执行\n    return await http.get(Uri.encodeFull(url), headers: {\x26quot;Accept\x26quot;: \x26quot;application\/json\x26quot;}); \/\/await关键字声明运算为延迟执行，然后return运算结果\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/HTTP的get请求返回值为Future\x26lt;String\x26gt;类型，即其返回值未来是一个String类型的值\x3c\/span\x3e\n  getData() \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e {    \x3cspan class=\x22hljs-comment\x22\x3e\/\/async关键字声明该函数内部有代码需要延迟执行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e http.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eUri\x3c\/span\x3e.encodeFull(url), headers: {\x3cspan class=\x22hljs-string\x22\x3e\x22Accept\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22application\/json\x22\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/await关键字声明运算为延迟执行，然后return运算结果\x3c\/span\x3e\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们调用这个函数，想获取其结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  String data = getData();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = getData();\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在书写时，在IDE中这个代码是没有问题的，但是当我们运行这段代码时，就报错了：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014396426\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014396426\x22 alt=\x22Future类型不匹配的错误\x22 title=\x22Future类型不匹配的错误\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为什么呢？因为\x3ccode\x3edata\x3c\/code\x3e是\x3cstrong\x3eString\x3c\/strong\x3e类型，而函数\x3ccode\x3egetData()\x3c\/code\x3e是一个异步操作函数，其返回值是一个\x3ccode\x3eawait\x3c\/code\x3e延迟执行的结果。在Dart中，有\x3ccode\x3eawait\x3c\/code\x3e标记的运算，其结果值都是一个\x3ccode\x3eFuture\x3c\/code\x3e对象，\x3ccode\x3eFuture\x3c\/code\x3e不是\x3cstrong\x3eString\x3c\/strong\x3e类型，所以就报错了。\x3c\/p\x3e\n\x3cp\x3e那如果这样的话，我们就没法获取到延迟执行的结果了？当然可以，Dart规定有\x3ccode\x3easync\x3c\/code\x3e标记的函数，只能由\x3ccode\x3eawait\x3c\/code\x3e来调用，比如这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String data = await getData();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = await getData();\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是要使用\x3ccode\x3eawait\x3c\/code\x3e，必须在有\x3ccode\x3easync\x3c\/code\x3e标记的函数中运行，否则这个\x3ccode\x3eawait\x3c\/code\x3e会报错：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014396427\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014396427\x22 alt=\x22await用法不正确\x22 title=\x22await用法不正确\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e于是，我们要为这个给\x3ccode\x3edata\x3c\/code\x3e赋值的语句加一个\x3ccode\x3easync\x3c\/code\x3e函数的包装：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String data;\nsetData() async {\n  data = await getData();    \/\/getData()延迟执行后赋值给data\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3esetData\x3c\/span\x3e() async {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = await getData();    \/\/getData()延迟执行后赋值给\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e上面这种方法一般用于调用封装好的异步接口，比如\x3ccode\x3egetData()\x3c\/code\x3e被封装到了其他dart文件，通过使用\x3ccode\x3easync\x3c\/code\x3e函数对其调取使用\x3c\/blockquote\x3e\n\x3cp\x3e再或者，我们去掉\x3ccode\x3easync\x3c\/code\x3e函数的包装，在\x3ccode\x3egetData()\x3c\/code\x3e中直接完成\x3ccode\x3edata\x3c\/code\x3e变量的赋值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String data;\ngetData() async {\n  data = await http.get(Uri.encodeFull(url), headers: {\x26quot;Accept\x26quot;: \x26quot;application\/json\x26quot;});     \/\/延迟执行后赋值给data\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eString\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3egetData\x3c\/span\x3e() async {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = await http.get(\x3cspan class=\x22hljs-type\x22\x3eUri\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eencodeFull\x3c\/span\x3e(\x3cspan class=\x22hljs-title\x22\x3eurl\x3c\/span\x3e), headers: {\x22\x3cspan class=\x22hljs-type\x22\x3eAccept\x3c\/span\x3e\x22: \x22\x3cspan class=\x22hljs-title\x22\x3eapplication\x3c\/span\x3e\/\x3cspan class=\x22hljs-title\x22\x3ejson\x3c\/span\x3e\x22});     \/\/延迟执行后赋值给\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，\x3ccode\x3edata\x3c\/code\x3e就获取到HTTP请求的数据了。就这样就完了？是滴，只要记住两点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eawait\x3c\/code\x3e关键字必须在\x3ccode\x3easync\x3c\/code\x3e函数内部使用\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3easync\x3c\/code\x3e函数必须使用\x3ccode\x3eawait\x3c\/code\x3e关键字\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3ePS：\x3ccode\x3eawait\x3c\/code\x3e关键字真的很形象，等一等的意思，就是说，既然你运行的时候都要等一等，那我调用的时候也等一等吧\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eFuture简单科普\x3c\/h2\x3e\n\x3cp\x3e前面个讲到过，直接\x3ccode\x3ereturn await ...\x3c\/code\x3e的时候，实际上返回的是一个延迟计算的\x3ccode\x3eFuture\x3c\/code\x3e对象，这个\x3ccode\x3eFuture\x3c\/code\x3e对象是Dart内置的，有自己的队列策略，我们就来聊聊这个\x3ca href=\x22https:\/\/docs.flutter.io\/flutter\/dart-async\/Future-class.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFuture\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e先啰嗦一些关于Dart在线程方面的知识。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eDart\x3c\/strong\x3e是基于单线程模型的语言。在\x3cstrong\x3eDart\x3c\/strong\x3e也有自己的进程（或者叫线程）机制，名叫\x3cstrong\x3eisolate\x3c\/strong\x3e。APP的启动入口\x3ccode\x3emain\x3c\/code\x3e函数就是一个\x3cstrong\x3eisolate\x3c\/strong\x3e。玩家也可以通过引入\x3ccode\x3eimport \x27dart:isolate\x27\x3c\/code\x3e创建自己的\x3cstrong\x3eisolate\x3c\/strong\x3e，对多核CPU的特性来说，多个\x3cstrong\x3eisolate\x3c\/strong\x3e可以显著提高运算效率，当然也要适当控制\x3cstrong\x3eisolate\x3c\/strong\x3e的数量，不应滥用，否则走火入魔自废武功。有一个很重要的点，Dart中\x3cstrong\x3eisolate\x3c\/strong\x3e之间无法直接共享内存，不同的\x3cstrong\x3eisolate\x3c\/strong\x3e之间只能通过\x3cstrong\x3eisolate\x3c\/strong\x3e API进行通信，当然本篇的重点在于\x3ccode\x3eFuture\x3c\/code\x3e，不展开讲\x3cstrong\x3eisolate\x3c\/strong\x3e，心急的小伙伴可以参考\x3ca href=\x22https:\/\/webdev.dartlang.org\/articles\/performance\/event-loop#event-queue-new-future\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方阅读理解\x3c\/a\x3e或者参考大神\x3ca href=\x22https:\/\/segmentfault.com\/u\/tain335\x22\x3etain335\x3c\/a\x3e的\x3ca href=\x22https:\/\/juejin.im\/post\/5a9a21f8518825558b3d5d35#heading-3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e人肉翻译\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eDart\x3c\/strong\x3e线程中有一个消息循环机制（\x3cstrong\x3eevent loop\x3c\/strong\x3e）和两个队列（\x3cstrong\x3eevent queue\x3c\/strong\x3e和\x3cstrong\x3emicrotask queue\x3c\/strong\x3e）。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3eevent queue\x3c\/strong\x3e包含所有外来的事件：I\/O，mouse events，drawing events，timers，isolate之间的message等。任意\x3cstrong\x3eisolate\x3c\/strong\x3e中新增的\x3cstrong\x3eevent\x3c\/strong\x3e（I\/O，mouse events，drawing events，timers，isolate的message）都会放入\x3cstrong\x3eevent queue\x3c\/strong\x3e中排队等待执行，好比机场的公共排队大厅。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3emicrotask queue\x3c\/strong\x3e只在当前\x3cstrong\x3eisolate\x3c\/strong\x3e的任务队列中排队，优先级高于\x3cstrong\x3eevent queue\x3c\/strong\x3e，好比机场里的某个VIP候机室，总是VIP用户先登机了，才开放公共排队入口。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果在\x3cstrong\x3eevent\x3c\/strong\x3e中插入\x3cstrong\x3emicrotask\x3c\/strong\x3e，当前\x3cstrong\x3eevent\x3c\/strong\x3e执行完毕即可插队执行\x3cstrong\x3emicrotask\x3c\/strong\x3e。如果没有\x3cstrong\x3emicrotask\x3c\/strong\x3e，就没办法插队了，也就是说，\x3cstrong\x3emicrotask queue\x3c\/strong\x3e的存在为Dart提供了给任务队列插队的解决方案。\x3c\/p\x3e\n\x3cp\x3e当\x3ccode\x3emain\x3c\/code\x3e方法执行完毕退出后，\x3cstrong\x3eevent loop\x3c\/strong\x3e就会以FIFO(先进先出)的顺序执行\x3cstrong\x3emicrotask\x3c\/strong\x3e，当所有\x3cstrong\x3emicrotask\x3c\/strong\x3e执行完后它会从\x3cstrong\x3eevent queue\x3c\/strong\x3e中取事件并执行。如此反复，直到两个队列都为空，如下流程图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000014396428\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000014396428\x22 alt=\x22event queue和microtask queue\x22 title=\x22event queue和microtask queue\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e注意：当事件循环正在处理\x3cstrong\x3emicrotask\x3c\/strong\x3e的时候，\x3cstrong\x3eevent queue\x3c\/strong\x3e会被堵塞。这时候app就无法进行UI绘制，响应鼠标事件和I\/O等事件。胡乱插队也是有代价的~\x3c\/blockquote\x3e\n\x3cp\x3e虽然你可以预测任务执行的顺序，但你无法准确的预测到事件循环何时会处理你期望的任务。例如当你创建一个延时1s的任务，但在排在你之前的任务结束前事件循环是不会处理这个延时任务的，也就是或任务执行可能是大于1s的。\x3c\/p\x3e\n\x3cp\x3eOK，了解以上信息之后，再来回到\x3cstrong\x3eFuture\x3c\/strong\x3e，小伙伴可能已经被绕晕了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eFuture\x3c\/strong\x3e就是\x3cstrong\x3eevent\x3c\/strong\x3e，很多\x3cstrong\x3eFlutter\x3c\/strong\x3e内置的组件比如前几篇用到的Http（http请求控件）的\x3ccode\x3eget\x3c\/code\x3e函数、RefreshIndicator（下拉手势刷新控件）的\x3ccode\x3eonRefresh\x3c\/code\x3e函数都是\x3cstrong\x3eevent\x3c\/strong\x3e。每一个被\x3ccode\x3eawait\x3c\/code\x3e标记的句柄也是一个\x3cstrong\x3eevent\x3c\/strong\x3e，每创建一个\x3cstrong\x3eFuture\x3c\/strong\x3e就会把这个\x3cstrong\x3eFuture\x3c\/strong\x3e扔进\x3cstrong\x3eevent queue\x3c\/strong\x3e中排队等候安检~\x3c\/p\x3e\n\x3cp\x3e什么？那\x3cstrong\x3emicrotask\x3c\/strong\x3e呢？当然不会忘了这个，\x3ca href=\x22https:\/\/docs.flutter.io\/flutter\/dart-async\/scheduleMicrotask.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3escheduleMicrotask\x3c\/a\x3e，用法和\x3cstrong\x3eFuture\x3c\/strong\x3e基本一样。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e为什么要用Future？\x3c\/h2\x3e\n\x3cp\x3e前面讲到，用\x3ccode\x3easync\x3c\/code\x3e和\x3ccode\x3eawait\x3c\/code\x3e组合，即可向\x3cstrong\x3eevent queue\x3c\/strong\x3e中插入\x3cstrong\x3eevent\x3c\/strong\x3e实现异步操作，好像\x3cstrong\x3eFuture\x3c\/strong\x3e的存在有些多余的感觉，刚开始我本人也有这样的疑惑，且往下看。\x3c\/p\x3e\n\x3cp\x3e当定义\x3cstrong\x3eFlutter\x3c\/strong\x3e函数时，还可以指定其运行结果返回值的类型，以提高代码的可读性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/定义了返回结果值为String类型\nFuture\x3cString\x3e getDatas(String category) async {\n    var request = await _httpClient.getUrl(Uri.parse(url));  \n    var response = await request.close();\n    return await response.transform(utf8.decoder).join();\n}\n\nrun() async{\n    int data = await getDatas(\x27keji\x27);    \/\/因为类型不匹配，IDE会报错\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义了返回结果值为String类型\x3c\/span\x3e\nFuture\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x26gt; getDatas(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e category) \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e request = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e _httpClient.getUrl(\x3cspan class=\x22hljs-built_in\x22\x3eUri\x3c\/span\x3e.parse(url));  \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e response = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e request.close();\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e response.transform(utf8.decoder).join();\n}\n\nrun() \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3eint\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getDatas(\x3cspan class=\x22hljs-string\x22\x3e\x27keji\x27\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/因为类型不匹配，IDE会报错\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eFuture\x3c\/strong\x3e最主要的功能就是提供了链式调用。熟悉ES6语法的小伙伴乐开了花，链式调用解决两大问题：明确代码执行的依赖关系和实现异常捕获。WTF?还不明白？且看下面这些案例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/案例1\nfunA() async{\n  ...set an important variable...\n}\n\nfunB() async{\n  await funA();\n  ...use the important variable...\n}\n\nmain() async {\n  funB();   \n}\n\/\/如果要想先执行funA再执行funB，必须在funB中await funA();\n\/\/funB的代码与funA耦合，将来如果funA废掉或者改动，funB中还需要经过修改以适配变更。\n\n\/\/案例2\nfunA() async{\n  try{\n     ...set an important variable...\n  }catch(e){\n    do sth...\n  }finally{\n    do sth. else...\n  }\n}\n\nfunB() async{\n  try{\n     ...use the important variable...\n  }catch(e){\n    do sth...\n  }finally{\n    do sth. else...\n  }\n}\n\nmain() async {\n  await funA();\n  await funB();\n}\n\/\/没有明确体现出设置变量和使用变量之间的依赖关系，其他开发者难以理解你的代码逻辑，代码维护困难\n\/\/并且如果为了防止funA()或者funB()因发生异常导致程序崩溃\n\/\/要到funA()或者funB()中分别加入`try`、`catch`、`finally`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/案例1\x3c\/span\x3e\nfunA() async{\n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e an important \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n}\n\nfunB() async{\n  await funA();\n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3euse the important \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n}\n\nmain() async {\n  funB();   \n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果要想先执行funA再执行funB，必须在funB中await funA();\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/funB的代码与funA耦合，将来如果funA废掉或者改动，funB中还需要经过修改以适配变更。\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/案例2\x3c\/span\x3e\nfunA() async{\n  try{\n     \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e an important \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }catch(e){\n    \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e sth\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }finally{\n    \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e sth. \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }\n}\n\nfunB() async{\n  try{\n     \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3euse the important \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }catch(e){\n    \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e sth\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }finally{\n    \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e sth. \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e\n  }\n}\n\nmain() async {\n  await funA();\n  await funB();\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/没有明确体现出设置变量和使用变量之间的依赖关系，其他开发者难以理解你的代码逻辑，代码维护困难\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/并且如果为了防止funA()或者funB()因发生异常导致程序崩溃\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/要到funA()或者funB()中分别加入`try`、`catch`、`finally`\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了解决上面的问题，\x3cstrong\x3eFuture\x3c\/strong\x3e提供了一套非常简洁的解决方案：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/案例3\n funA(){\n  ...set an important variable...    \/\/设置变量\n}\n\nfunB(){\n  ...use the important variable...   \/\/使用变量\n}\nmain(){\n  new Future.then(funA()).then(funB());   \/\/ 明确表现出了后者依赖前者设置的变量值\n \n  new Future.then(funA()).then((_) {new Future(funB())});    \/\/还可以这样用\n\n  \/\/链式调用，捕获异常\n  new Future.then(funA(),onError: (e) { handleError(e); }).then(funB(),onError: (e) { handleError(e); })  \n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/案例3\x3c\/span\x3e\n funA(){\n  ...set an important \x3cspan class=\x22hljs-keyword\x22\x3evariable\x3c\/span\x3e...    \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置变量\x3c\/span\x3e\n}\n\nfunB(){\n  ...use the important \x3cspan class=\x22hljs-keyword\x22\x3evariable\x3c\/span\x3e...   \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用变量\x3c\/span\x3e\n}\nmain(){\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Future.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(funA()).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(funB());   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 明确表现出了后者依赖前者设置的变量值\x3c\/span\x3e\n \n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Future.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(funA()).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e((\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3e) {\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Future(funB())});    \x3cspan class=\x22hljs-comment\x22\x3e\/\/还可以这样用\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/链式调用，捕获异常\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Future.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(funA(),onError: (e) { handleError(e); }).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(funB(),onError: (e) { handleError(e); })  \n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e案例3的玩法是\x3ccode\x3easync\x3c\/code\x3e和\x3ccode\x3eawait\x3c\/code\x3e无法企及的，因此掌握\x3cstrong\x3eFuture\x3c\/strong\x3e还是很有必要滴。当然了，\x3cstrong\x3eFuture\x3c\/strong\x3e的玩法不仅仅局限于案例3，还有很多有趣的玩法，包括和\x3cstrong\x3emicrotask\x3c\/strong\x3e对象\x3ca href=\x22https:\/\/docs.flutter.io\/flutter\/dart-async\/scheduleMicrotask.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3escheduleMicrotask\x3c\/a\x3e配合使用，我这里就不一一介绍了，大家参考大神\x3ca href=\x22https:\/\/segmentfault.com\/u\/tain335\x22\x3etain335\x3c\/a\x3e的\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008800122#articleHeader6\x22 target=\x22_blank\x22\x3e人肉翻译\x3c\/a\x3e或者\x3ca href=\x22https:\/\/docs.flutter.io\/flutter\/dart-async\/Future-class.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官网阅读理解\x3c\/a\x3e吧。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3eDart的\x3cstrong\x3eisolate\x3c\/strong\x3e中加入了\x3cstrong\x3eevent queue\x3c\/strong\x3e和\x3cstrong\x3emicrotask queue\x3c\/strong\x3e后，有了一点协程的感觉，或许这就是\x3cstrong\x3eFlutter\x3c\/strong\x3e为啥在性能上敢和原生开发叫板的原因之一吧。本篇的内容比较抽象，如果还是有不明白的小伙伴，欢迎留言提问，我尽量回答，哈哈哈，就酱，欢迎加入到\x3ca href=\x22https:\/\/www.jianshu.com\/c\/ebc9d2e84214\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFlutter圈子\x3c\/a\x3e或\x3cstrong\x3eflutter 中文社区（官方QQ群：338252156）\x3c\/strong\x3e，群里有前后端及全栈各路大神镇场子，加入进来没事就写写APP挣点外快（这个真的有），顺便翻译翻译官方英文原稿拉一票粉丝，一举多得何乐而不为呢。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>flutter实战5：异步async、await和Future的使用技巧</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014396421">https://segmentfault.com/a/1190000014396421</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/tvs2yx7ha1/" target="_blank">https://alili.tech/archive/tvs2yx7ha1/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>