<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="探索babel和babel插件是怎么工作的"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>探索babel和babel插件是怎么工作的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/x38gjo4mw/",
				"appid": "1613049289050283", 
				"title": "探索babel和babel插件是怎么工作的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-13T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pm89v9qs35/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wen1a17w7n/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&text=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&text=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&title=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&is_video=false&description=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&title=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&title=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&title=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx38gjo4mw%2f&title=%e6%8e%a2%e7%b4%a2babel%e5%92%8cbabel%e6%8f%92%e4%bb%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">探索babel和babel插件是怎么工作的</h1><div class="meta"><div class="postdate"><time datetime="2018-12-13" itemprop="datePublished">2018-12-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e你有可能会听到过这个词 \x3cstrong\x3ewebpack工程师\x3c\/strong\x3e ,这个看似像是一个专业很强的职位其实很多时候是一些前端对现在前端工作方式对一些吐槽，对于一个之前没有接触过\x3ccode\x3ewebpack\x3c\/code\x3e，\x3ccode\x3enodejs\x3c\/code\x3e,\x3ccode\x3ebabel\x3c\/code\x3e 之类的工具的人来说,看到大量的配置文件后很多人都会看懵\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3N7A?w=380\x26amp;h=181\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3N7A?w=380\x26amp;h=181\x22 alt=\x22config.js\x22 title=\x22config.js\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e很多人就干脆不管这些东西，直接上手写业务代码，把这些构建工具就相当于\x3ccode\x3e黑科技\x3c\/code\x3e，我们把所有的文件都经过这些工具最终生成一个或者几个打包后的文件，其中关于优化和代码转换问题其实一大部分都是在这些配置里面的。如果我们不去了解其中的一部分原理，后面遇到很多问题（\x3ccode\x3e如打包后文件体积过大\x3c\/code\x3e）时候都是束手无策，而且万一哪天构建工具出现问题时候可能连工作都开展不下去了。\x3c\/p\x3e\n\x3cp\x3e既然我们日常都要用到，最好的方式就是去研究一下这些工具的原理的作用，让这些工具成为我们手中的\x3cstrong\x3e利器\x3c\/strong\x3e,而不是工作上的\x3cstrong\x3e绊脚石\x3c\/strong\x3e，而且这些工具的设计者都是顶级的工程师，当你敲开壁垒探究内部秘密时候，我相信你会感受到其中的编程之美。\x3c\/p\x3e\n\x3cp\x3e这里我们去探索一下\x3ccode\x3ebabel\x3c\/code\x3e的原理\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3ebabel 是什么？\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eBabel · The compiler for writing next generation JavaScript\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e6to5\x3c\/h4\x3e\n\x3cp\x3e你在\x3ccode\x3enpm\x3c\/code\x3e上可以看到这样一个包名字是\x3ca href=\x22https:\/\/www.npmjs.com\/package\/6to5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e6to5\x3c\/a\x3e, 光看名字可能会让人感觉到很诧异,名字看起来可能有点奇怪，其实\x3ccode\x3ebabel\x3c\/code\x3e 在开始的时候名字就是这个。简单粗暴\x3ccode\x3ees6 -\x26gt; es5\x3c\/code\x3e,一下子就看懂了\x3ccode\x3ebabel\x3c\/code\x3e 是用来干啥的，但是很明显这不是一个好名字,这个名字会让人感觉到\x3ccode\x3ees6\x3c\/code\x3e普及之后这个库就没用了,为了保持活力这个库可能要不停的修改名字。下面是\x3ccode\x3ebabel\x3c\/code\x3e作者一次分享中假设如果按这个命名法则可能出现的名称\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3N7E?w=800\x26amp;h=600\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3N7E?w=800\x26amp;h=600\x22 alt=\x22babel-history\x22 title=\x22babel-history\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e很明显发生这种情况是很不合理的，团队内部经过大量讨论后，最终选择了\x3ccode\x3ebabel\x3c\/code\x3e,这与电影\x3cstrong\x3e银河系漫游指南\x3c\/strong\x3e中的\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/List_of_races_and_species_in_The_Hitchhiker%27s_Guide_to_the_Galaxy#Babel_fish\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBabel fish\x3c\/a\x3e相应，也有关系到圣经中的一个故事\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Tower_of_Babel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTower of Babel\x3c\/a\x3e。\x3ccode\x3e（ps.优秀的人总是也很有情怀。）\x3c\/code\x3e\x3c\/p\x3e\n\x3ch4\x3ebabel is the new jQuery\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eredux\x3c\/code\x3e 的作者曾说过这样一句话，可以换一种理解为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22babel : AST :: jQuery : DOM\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3ebabel :\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eAST :\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3ejQuery :\x3c\/span\x3e DOM\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ebabel\x3c\/code\x3e 对于 \x3ccode\x3eAST\x3c\/code\x3e 就相当于 \x3ccode\x3ejQuery\x3c\/code\x3e 对于 \x3ccode\x3eDOM\x3c\/code\x3e, 就是说\x3ccode\x3ebabel\x3c\/code\x3e给予了我们便捷查询和修改 \x3ccode\x3eAST\x3c\/code\x3e 的能力。\x3ccode\x3e(AST -\x26gt; Abstract Syntax Tree) 抽象语法树 后面会讲到。\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e为什么要用babel转换代码\x3c\/h3\x3e\n\x3cp\x3e我们之前做一些兼容都会都会接触一些 \x3ccode\x3ePolyfill\x3c\/code\x3e 的概念，比如如果某个版本的浏览器不支持 \x3ccode\x3eArray.prototype.find\x3c\/code\x3e 方法,但是我们的代码中有用到\x3ccode\x3eArray\x3c\/code\x3e 的\x3ccode\x3efind\x3c\/code\x3e 函数，为了支持这些代码，我们会人为的加一些兼容代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \x27find\x27, {\n      \/\/ 实现代码\n      ...\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.find) {\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x27find\x27\x3c\/span\x3e, {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实现代码\x3c\/span\x3e\n      ...\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于这种情况做兼容也很好实现，引入一个 \x3ccode\x3ePolyfill\x3c\/code\x3e 文件就可以了，但是有一些情况我们使用到了一些新语法，或者一些其他写法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 箭头函数\nvar a = () =\x3e {}\n\/\/ jsx\nvar Component = () =\x3e \x3cdiv \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 箭头函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ jsx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Component = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x26lt;div \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种情况靠 \x3ccode\x3ePolyfill\x3c\/code\x3e, 因为一些浏览器根本就不识别这些代码,这时候就需要把这些代码转换成浏览器识别的代码。\x3ccode\x3ebabel\x3c\/code\x3e就是做这个事情的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ebabel做了哪些事情\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3N7J?w=1024\x26amp;h=768\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3N7J?w=1024\x26amp;h=768\x22 alt=\x22babel-works\x22 title=\x22babel-works\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为了转换我们的代码，\x3ccode\x3ebabel\x3c\/code\x3e做了三件事\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eParser\x3c\/code\x3e 解析我们的代码转换为\x3ccode\x3eAST\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eTransformer\x3c\/code\x3e 利用我们配置好的\x3ccode\x3eplugins\/presets\x3c\/code\x3e把\x3ccode\x3eParser\x3c\/code\x3e生成的\x3ccode\x3eAST\x3c\/code\x3e转变为新的\x3ccode\x3eAST\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eGenerator\x3c\/code\x3e 把转换后的\x3ccode\x3eAST\x3c\/code\x3e生成新的代码\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e从图上看 \x3ccode\x3eTransformer\x3c\/code\x3e 占了很大一块比重，这个转换过程就是\x3ccode\x3ebabel\x3c\/code\x3e中最复杂的部分,我们平时配置的\x3ccode\x3eplugins\/presets\x3c\/code\x3e就是在这个模块起作用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e从简单的说起\x3c\/h3\x3e\n\x3cp\x3e可以看到要想搞懂\x3ccode\x3ebabel\x3c\/code\x3e, 就是去了解上面三个步骤都是在干什么，我们先把比较容易看懂的地方开始了解一下。\x3c\/p\x3e\n\x3ch4\x3eParser 解析\x3c\/h4\x3e\n\x3cp\x3e解析步骤接收代码并输出 \x3ccode\x3eAST\x3c\/code\x3e,这其中又包含两个阶段\x3cstrong\x3e词法分析\x3c\/strong\x3e和\x3cstrong\x3e语法分析\x3c\/strong\x3e。词法分析阶段把字符串形式的代码转换为 \x3ccode\x3e令牌（tokens）\x3c\/code\x3e 流。语法分析阶段会把一个令牌流转换成 \x3ccode\x3eAST\x3c\/code\x3e 的形式,方便后续操作。\x3c\/p\x3e\n\x3ch4\x3eGenerator 生成\x3c\/h4\x3e\n\x3cp\x3e代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ebabel的核心内容\x3c\/h3\x3e\n\x3cp\x3e看起来\x3ccode\x3ebabel\x3c\/code\x3e的主要工作都集中在把解析生成的\x3ccode\x3eAST\x3c\/code\x3e经过\x3ccode\x3eplugins\/presets\x3c\/code\x3e然后去生成\x3ccode\x3e新的AST\x3c\/code\x3e这上面了。\x3c\/p\x3e\n\x3ch4\x3eAST抽象语法树\x3c\/h4\x3e\n\x3cp\x3e我们一直在提到\x3ccode\x3eAST\x3c\/code\x3e它究竟是什么呢，既然它的名字叫做\x3ccode\x3e抽象语法树\x3c\/code\x3e,我们可以想象一下如果把我们的程序用树状表示会是什么样呢。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = 1 \x2b 1\nvar b = 2 \x2b 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们想象一下要表示上述代码应该是什么样子，首先必须有东西可以表示这些具体的\x3ccode\x3e声明\x3c\/code\x3e,\x3ccode\x3e变量\x3c\/code\x3e,\x3ccode\x3e常量\x3c\/code\x3e的具体信息，比如\x3ccode\x3e（这棵树上肯定有二个变量，变量名是a和b,肯定有两个运算语句，操作符是 \x2b ）\x3c\/code\x3e,有了这些信息还不够，我们必须建立起它们之间的关系，比如\x3ccode\x3e一个声明语句，声明类型是 var, 左侧是变量, 右侧是表达式\x3c\/code\x3e。有了这些信息我们就可以还原这个程序，这也是把代码解析成\x3ccode\x3eAST\x3c\/code\x3e时候所做的事情，对应上面我们说的\x3ccode\x3e词法分析\x3c\/code\x3e 和 \x3ccode\x3e语法分析\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eAST\x3c\/code\x3e中我们用\x3ccode\x3enode\x3c\/code\x3e（节点）来表示各个代码片段，比如我们上面程序整体就是一个节点\x3ccode\x3eProgram\x3c\/code\x3e节点\x3cem\x3e(所有的 AST 根节点都是 Program 节点)\x3c\/em\x3e，因为它下面有两条语句所以它的 \x3ccode\x3ebody\x3c\/code\x3e属性上就两个声明节点\x3ccode\x3eVariableDeclaration\x3c\/code\x3e。所以上面程序的\x3ccode\x3eAST\x3c\/code\x3e就类似这样\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3N77?w=1400\x26amp;h=710\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3N77?w=1400\x26amp;h=710\x22 alt=\x22ast\x22 title=\x22ast\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到在节点上用各个的属性去表示各种信息以及程序之间的关系,那这些节点每一个叫什么名字,都用哪些属性名呢？我们可以在\x3ca href=\x22https:\/\/github.com\/babel\/babylon\/blob\/master\/ast\/spec.md#variabledeclaration\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e说明文档\x3c\/a\x3e上找到这些说明。\x3c\/p\x3e\n\x3ch5\x3e关于接口\x3c\/h5\x3e\n\x3cp\x3e看这个文档时候我们可以看到说明大多是类似这种\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface Node {\n  type: string;\n  loc: SourceLocation | null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3einterface\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eNode\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3etype\x3c\/span\x3e: string;\n  \x3cspan class=\x22hljs-attribute\x22\x3eloc\x3c\/span\x3e: SourceLocation | null;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里提到\x3ccode\x3einterface\x3c\/code\x3e这个我们在其他语言中是比较常见的，比如\x3ccode\x3eNode\x3c\/code\x3e规定了\x3ccode\x3etype\x3c\/code\x3e和\x3ccode\x3eloc\x3c\/code\x3e属性，如果其他节点继承自\x3ccode\x3eNode\x3c\/code\x3e,那么它也会实现\x3ccode\x3etype\x3c\/code\x3e和\x3ccode\x3eloc\x3c\/code\x3e属性就是说继承自\x3ccode\x3eNode\x3c\/code\x3e的节点也会有这些属性,基本所有节点都继承自\x3ccode\x3eNode\x3c\/code\x3e,所以我们基本可以看到\x3ccode\x3eloc\x3c\/code\x3e这个属性\x3ccode\x3eloc\x3c\/code\x3e表示个一些位置信息。\x3c\/p\x3e\n\x3ch5\x3e节点单位\x3c\/h5\x3e\n\x3cp\x3e我们程序很多地方都会被拆分成一个个的节点，节点里面也会套着其他的节点，我们在文档中可以看到\x3ccode\x3eAST\x3c\/code\x3e结构的各个 \x3ccode\x3eNode\x3c\/code\x3e 节点都很细微,比如我们声明函数,函数就是一个节点\x3ccode\x3eFunctionDeclaration\x3c\/code\x3e,函数名和形参那么参数都是一个变量节点\x3ccode\x3eIdentifier\x3c\/code\x3e。生成的节点往往都很复杂，我们可以借助\x3ca href=\x22https:\/\/astexplorer.net\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eastexplorer\x3c\/a\x3e来帮助我们分析\x3ccode\x3eAST\x3c\/code\x3e结构。\x3c\/p\x3e\n\x3ch5\x3e图像展示\x3c\/h5\x3e\n\x3cp\x3e有了上面这些概念我们已经可以大概了解\x3ccode\x3eAST\x3c\/code\x3e的概念，以及各个模块代表的含义，假设我们有这样一个程序,我们用图形简易的分析下它的结构\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function square (n) {\n    return n * n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esquare\x3c\/span\x3e (n) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3en\x3c\/span\x3e * n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3N8h?w=1024\x26amp;h=768\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3N8h?w=1024\x26amp;h=768\x22 alt=\x22ast-example\x22 title=\x22ast-example\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e节点遍历\x3c\/h4\x3e\n\x3cp\x3e经过一番努力我们终于了解了\x3ccode\x3eAST\x3c\/code\x3e以及其中内容的含义，但是这一部分基本不需要我们做什么，\x3ccode\x3ebabel\x3c\/code\x3e会借助\x3ca href=\x22http:\/\/babeljs.io\/docs\/core-packages\/babylon\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBabylon\x3c\/a\x3e帮我们生成我们需要的\x3ccode\x3eAST\x3c\/code\x3e结构。我们更多要去做的是去修改和改变\x3ccode\x3eBabylon\x3c\/code\x3e生成的这个抽象语法树。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ebabel\x3c\/code\x3e拿到抽象语法树后会使用\x3ccode\x3ebabel-traverse\x3c\/code\x3e进行递归的树状遍历，对于每一个节点都会向下遍历到尽头，然后向上遍历退出分支去寻找下一个分支。这样确保我们能找到任何一个节点，也就是能访问到我们代码的任何一个部分。可是我们要怎么去完成修改操作呢，\x3ccode\x3ebabel\x3c\/code\x3e给我们提供了下面这两个概念。\x3c\/p\x3e\n\x3ch5\x3evisitor\x3c\/h5\x3e\n\x3cp\x3e我们已经知道\x3ccode\x3ebabel\x3c\/code\x3e会遍历节点组成的抽象语法树，每一个节点都会有自己对应的\x3ccode\x3etype\x3c\/code\x3e,比如变量节点\x3ccode\x3eIdentifier\x3c\/code\x3e等。我们需要给\x3ccode\x3ebabel\x3c\/code\x3e提供一个\x3ccode\x3evisitor\x3c\/code\x3e对象，在这个对象上面我们以这些节点的\x3ccode\x3etype\x3c\/code\x3e做为\x3ccode\x3ekey\x3c\/code\x3e,已一个函数作为值，类似如下，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const visitor = {\n    Identifier: {\n        enter() {\n              console.log(\x27traverse enter a Identifier node!\x27)\n        },\n        exit() {\n              console.log(\x27traverse exit a Identifier node!\x27)\n        }\n      }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visitor = {\n    \x3cspan class=\x22hljs-attr\x22\x3eIdentifier\x3c\/span\x3e: {\n        enter() {\n              \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27traverse enter a Identifier node!\x27\x3c\/span\x3e)\n        },\n        exit() {\n              \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27traverse exit a Identifier node!\x27\x3c\/span\x3e)\n        }\n      }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样在遍历进入到对应到节点时候,\x3ccode\x3ebabel\x3c\/code\x3e就会去执行对应的\x3ccode\x3eenter\x3c\/code\x3e函数，向上遍历退出对应节点时候，\x3ccode\x3ebabel\x3c\/code\x3e就会去执行对应的\x3ccode\x3eexit\x3c\/code\x3e函数，接着上面的代码我们可以做一个测试\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const babel = require(\x27babel-core\x27)\n\nconst code = `var a = b \x2b c \x2b d`\n\n\/\/ 如果plugins是个函数则返回的对象要有visitor属性，如果是个对象则直接定义visitor属性\nconst MyVisitor = {\n  visitor\n}\n\nbabel.transform(code, {\n  plugins: [MyVisitor]\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e babel = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27babel-core\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code = \x3cspan class=\x22hljs-string\x22\x3e`var a = b \x2b c \x2b d`\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果plugins是个函数则返回的对象要有visitor属性，如果是个对象则直接定义visitor属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MyVisitor = {\n  visitor\n}\n\nbabel.transform(code, {\n  \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e: [MyVisitor]\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们执行对应代码可以看到上面\x3ccode\x3eenter\x3c\/code\x3e和\x3ccode\x3eexit\x3c\/code\x3e函数分别执行了四次\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22traverse enter a Identifier node! \ntraverse exit a Identifier node!  \n... x4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode class=\x22shell\x22\x3etraverse enter a Identifier node! \ntraverse \x3cspan class=\x22hljs-keyword\x22\x3eexit\x3c\/span\x3e a Identifier node!  \n... x4\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面简单的代码上也可以看到\x3ccode\x3ea,b,c,d\x3c\/code\x3e四个变量,它们应该属于同一级别的节点树上，所以遍历时候会分别进入对应节点然后退出再去下一个节点。\x3c\/p\x3e\n\x3ch5\x3ePaths\x3c\/h5\x3e\n\x3cp\x3e我们通过\x3ccode\x3evisitor\x3c\/code\x3e可以在遍历到对应节点执行对应的函数，可是要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置\x3ccode\x3e（即和其他节点间的关系）\x3c\/code\x3e, \x3ccode\x3evisitor\x3c\/code\x3e在遍历到对应节点执行对应函数时候会给我们传入\x3ccode\x3epath\x3c\/code\x3e参数，辅助我们完成上面这些操作。注意 \x3ccode\x3ePath\x3c\/code\x3e 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了\x3ccode\x3eIdentifier\x3c\/code\x3e节点，它传入的 \x3ccode\x3epath\x3c\/code\x3e参数看起来是这样的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  \x26quot;parent\x26quot;: {\n    \x26quot;type\x26quot;: \x26quot;VariableDeclarator\x26quot;,\n    \x26quot;id\x26quot;: {...},\n    ....\n  },\n  \x26quot;node\x26quot;: {\n    \x26quot;type\x26quot;: \x26quot;Identifier\x26quot;,\n    \x26quot;name\x26quot;: \x26quot;...\x26quot;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e{\n  \x3cspan class=\x22hljs-string\x22\x3e\x22parent\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22type\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22VariableDeclarator\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n    ....\n  },\n  \x3cspan class=\x22hljs-string\x22\x3e\x22node\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22type\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Identifier\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22...\x22\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面我们可以看到 \x3ccode\x3epath\x3c\/code\x3e 表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法。我们修改一下上面的 \x3ccode\x3evisitor\x3c\/code\x3e 函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const visitor = {\n    Identifier: {\n    enter(path) {\n      console.log(\x27traverse enter a Identifier node the name is \x27 \x2b path.node.name)\n    },\n    exit(path) {\n      console.log(\x27traverse exit a Identifier node the name is \x27 \x2b path.node.name)\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode\x3econst visitor = {\n    Identifier: {\n    enter(path) {\n      console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27traverse enter a Identifier node the name is \x27\x3c\/span\x3e \x2b path.node.name)\n    },\n    \x3cspan class=\x22hljs-keyword\x22\x3eexit\x3c\/span\x3e(path) {\n      console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27traverse exit a Identifier node the name is \x27\x3c\/span\x3e \x2b path.node.name)\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在执行一下上面的代码就可以看到\x3ccode\x3ename\x3c\/code\x3e打印出来的依次是\x3ccode\x3ea\x3c\/code\x3e,\x3ccode\x3eb\x3c\/code\x3e,\x3ccode\x3ec\x3c\/code\x3e,\x3ccode\x3ed\x3c\/code\x3e。这样我们就有可以修改操作我们需要改变的节点了。另外\x3ccode\x3epath\x3c\/code\x3e对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。\x3c\/p\x3e\n\x3ch4\x3e一些有用的工具\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3ebabel\x3c\/code\x3e为了方便我们开发，在每一个环节都有很多人性化的定义也提供了很多实用性的工具,比如之前我们在定义\x3ccode\x3evisitor\x3c\/code\x3e时候分别定义了\x3ccode\x3eenter\x3c\/code\x3e,\x3ccode\x3eexit\x3c\/code\x3e函数，可很多时候我们其实只用到了一次在\x3ccode\x3eenter\x3c\/code\x3e的时候做一些处理就行了。所以我们如果我们直接定义节点的\x3ccode\x3ekey\x3c\/code\x3e为函数，就相当于定义了\x3ccode\x3eenter\x3c\/code\x3e函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const visitor = {\n    Identifier(){\n        \/\/ dosmting\n    }\n}\n\n\/\/ 等同于 ↓ ↓ ↓ ↓ ↓ ↓\n\nconst visitor = {\n    Identifier: {\n        enter() {\n            \/\/ dosmting\n        }\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visitor = {\n    Identifier(){\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dosmting\x3c\/span\x3e\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等同于 ↓ ↓ ↓ ↓ ↓ ↓\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visitor = {\n    \x3cspan class=\x22hljs-attr\x22\x3eIdentifier\x3c\/span\x3e: {\n        enter() {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dosmting\x3c\/span\x3e\n        }\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面我们还提到了plugins是函数的情况，其实我们写的差距一般都是一个函数，这个入口函数上\x3ccode\x3ebabel\x3c\/code\x3e也会穿入一个\x3ccode\x3ebabel-types\x3c\/code\x3e,这是一个用于\x3ccode\x3eAST\x3c\/code\x3e 节点的 \x3ccode\x3eLodash\x3c\/code\x3e 式工具库(类似\x3ccode\x3elodash\x3c\/code\x3e对于\x3ccode\x3ejs\x3c\/code\x3e的帮助), 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e实际运用\x3c\/h3\x3e\n\x3cp\x3e假如我们有如下代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const a = 3 * 103.5 * 0.8\nlog(a)\nconst b = a \x2b 105 - 12\nlog(b)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e103.5\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e0.8\x3c\/span\x3e\nlog(a)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a \x2b \x3cspan class=\x22hljs-number\x22\x3e105\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\nlog(b)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们发现这里把\x3ccode\x3econsole.log\x3c\/code\x3e简写成了\x3ccode\x3elog\x3c\/code\x3e，为了让这些代码可以执行，我们现在用\x3ccode\x3ebabel\x3c\/code\x3e装置去转换一下这些代码。\x3c\/p\x3e\n\x3ch4\x3e改变log函数调用本身\x3c\/h4\x3e\n\x3cp\x3e既然是\x3ccode\x3econsole.log\x3c\/code\x3e没有写全，我们就改变这个\x3ccode\x3elog\x3c\/code\x3e函数调用的地方，把每一个\x3ccode\x3elog\x3c\/code\x3e替换成\x3ccode\x3econsole.log\x3c\/code\x3e，我们看一下\x3ccode\x3elog(*)\x3c\/code\x3e属于函数执行语句，相对应的节点就是\x3ccode\x3eCallExpression\x3c\/code\x3e，我们看下它的结构\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface CallExpression \x3c: Expression {\n  type: \x26quot;CallExpression\x26quot;;\n  callee: Expression | Super | Import;\n  arguments: [ Expression | SpreadElement ];\n  optional: boolean | null;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3einterface\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eCallExpression\x3c\/span\x3e \x26lt;: \x3cspan class=\x22hljs-selector-tag\x22\x3eExpression\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22CallExpression\x22\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-attribute\x22\x3ecallee\x3c\/span\x3e: Expression | Super | Import;\n  \x3cspan class=\x22hljs-attribute\x22\x3earguments\x3c\/span\x3e: [ Expression | SpreadElement ];\n  \x3cspan class=\x22hljs-attribute\x22\x3eoptional\x3c\/span\x3e: boolean | null;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecallee\x3c\/code\x3e是我们函数执行的名称，\x3ccode\x3earguments\x3c\/code\x3e就是我们穿入的参数，参数我们不需要改变，只需要把函数名称改变就好了，之前的\x3ccode\x3ecallee\x3c\/code\x3e是一个变量，我们现在要把它变成一个表达式\x3ccode\x3e(取对象属性值的表达式)\x3c\/code\x3e,我们看一下手册可以看到是一个\x3ccode\x3eMemberExpression\x3c\/code\x3e类型的值，这里也可以借助之前提到的网站\x3ca href=\x22https:\/\/astexplorer.net\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eastexplorer\x3c\/a\x3e来帮助我们分析。有了这些信息我们就可以去实现我们的目的了，我们这里手动引入一下\x3ccode\x3ebabel-types\x3c\/code\x3e辅助我们创建新的节点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const babel = require(\x27babel-core\x27)\nconst t = require(\x27babel-types\x27)\n\nconst code = `\n    const a = 3 * 103.5 * 0.8\n    log(a)\n    const b = a \x2b 105 - 12\n    log(b)\n`\n\nconst visitor = {\n    CallExpression(path) {\n        \/\/ 这里判断一下如果不是log的函数执行语句则不处理\n        if (path.node.callee.name !== \x27log\x27) return\n        \/\/ t.CallExpression 和 t.MemberExpression分别代表生成对于type的节点，path.replaceWith表示要去替换节点,这里我们只改变CallExpression第一个参数的值，第二个参数则用它自己原来的内容，即本来有的参数\n        path.replaceWith(t.CallExpression(\n            t.MemberExpression(t.identifier(\x27console\x27), t.identifier(\x27log\x27)),\n            path.node.arguments\n        ))\n    }\n}\n\nconst result = babel.transform(code, {\n    plugins: [{\n        visitor: visitor\n    }]\n})\n\nconsole.log(result.code)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e babel = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27babel-core\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e t = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27babel-types\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code = \x3cspan class=\x22hljs-string\x22\x3e`\n    const a = 3 * 103.5 * 0.8\n    log(a)\n    const b = a \x2b 105 - 12\n    log(b)\n`\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visitor = {\n    CallExpression(path) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里判断一下如果不是log的函数执行语句则不处理\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (path.node.callee.name !== \x3cspan class=\x22hljs-string\x22\x3e\x27log\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ t.CallExpression 和 t.MemberExpression分别代表生成对于type的节点，path.replaceWith表示要去替换节点,这里我们只改变CallExpression第一个参数的值，第二个参数则用它自己原来的内容，即本来有的参数\x3c\/span\x3e\n        path.replaceWith(t.CallExpression(\n            t.MemberExpression(t.identifier(\x3cspan class=\x22hljs-string\x22\x3e\x27console\x27\x3c\/span\x3e), t.identifier(\x3cspan class=\x22hljs-string\x22\x3e\x27log\x27\x3c\/span\x3e)),\n            path.node.arguments\n        ))\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = babel.transform(code, {\n    \x3cspan class=\x22hljs-attr\x22\x3eplugins\x3c\/span\x3e: [{\n        \x3cspan class=\x22hljs-attr\x22\x3evisitor\x3c\/span\x3e: visitor\n    }]\n})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result.code)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行后我们可以看到结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const a = 3 * 103.5 * 0.8;\nconsole.log(a);\nconst b = a \x2b 105 - 12;\nconsole.log(b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e103.5\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e0.8\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a \x2b \x3cspan class=\x22hljs-number\x22\x3e105\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e直接在模块中声明log\x3c\/h4\x3e\n\x3cp\x3e我们已经知道每一个模块都是一个对于的\x3ccode\x3eAST\x3c\/code\x3e，而\x3ccode\x3eAST\x3c\/code\x3e根节点是 \x3ccode\x3eProgram\x3c\/code\x3e 节点,下面的语句都是\x3ccode\x3ebody\x3c\/code\x3e上面的子节点，我们只要在\x3ccode\x3ebody\x3c\/code\x3e头声明一下\x3ccode\x3elog\x3c\/code\x3e变量，把它定义为\x3ccode\x3econsole.log\x3c\/code\x3e，后面这样使用就也正常了。\x3c\/p\x3e\n\x3cp\x3e这里简单的修改下visitor\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const visitor = {\n    Program(path) {\n        path.node.body.unshift(\n      t.VariableDeclaration(\n        \x27var\x27,\n        [t.VariableDeclarator(\n          t.Identifier(\x27log\x27),\n          t.MemberExpression(t.identifier(\x27console\x27), t.identifier(\x27log\x27))\n        )]\n      )\n    )\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visitor = {\n    Program(path) {\n        path.node.body.unshift(\n      t.VariableDeclaration(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27var\x27\x3c\/span\x3e,\n        [t.VariableDeclarator(\n          t.Identifier(\x3cspan class=\x22hljs-string\x22\x3e\x27log\x27\x3c\/span\x3e),\n          t.MemberExpression(t.identifier(\x3cspan class=\x22hljs-string\x22\x3e\x27console\x27\x3c\/span\x3e), t.identifier(\x3cspan class=\x22hljs-string\x22\x3e\x27log\x27\x3c\/span\x3e))\n        )]\n      )\n    )\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行后生成的代码为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var log = console.log;\n\nconst a = 3 * 103.5 * 0.8;\nlog(a);\nconst b = a \x2b 105 - 12;\nlog(b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e = console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = 3 * 103.5 * 0.8;\n\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(a);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a \x2b 105 - 12;\n\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e到这里我们已经简单的分析代码，修改一些抽象语法树上的内容来达到我们的目的，但是还是有很多中情况还没考虑进去，而\x3ccode\x3ebabel\x3c\/code\x3e现阶段不仅仅代表着去转换\x3ccode\x3ees6\x3c\/code\x3e代码之类的功能，实际上我们自己可以写出很多有意思的插件，欢迎来了解\x3ccode\x3ebabel\x3c\/code\x3e,按照自己的想法写一些插件或者去贡献一些代码，相信在这个过程中你收获的绝对比你想象中的要更多！\x3c\/p\x3e\n\x3cblockquote\x3e本文首发与\x3ca href=\x22https:\/\/www.hazyzh.com\/b\/180211145458\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e个人博客\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>探索babel和babel插件是怎么工作的</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013261724">https://segmentfault.com/a/1190000013261724</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/x38gjo4mw/" target="_blank">https://alili.tech/archive/x38gjo4mw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>