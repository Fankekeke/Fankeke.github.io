<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="彻底搞懂 JS 中 this 机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>彻底搞懂 JS 中 this 机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/x3axvqjiopm/",
				"appid": "1613049289050283", 
				"title": "彻底搞懂 JS 中 this 机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-06T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/rwax833q1h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wl0erqryl3e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&text=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&text=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&title=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&is_video=false&description=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&title=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&title=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&title=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx3axvqjiopm%2f&title=%e5%bd%bb%e5%ba%95%e6%90%9e%e6%87%82%20JS%20%e4%b8%ad%20this%20%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">彻底搞懂 JS 中 this 机制</h1><div class="meta"><div class="postdate"><time datetime="2018-12-06" itemprop="datePublished">2018-12-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e彻底搞懂 JS 中 this 机制\x3c\/h1\x3e\n\x3cblockquote\x3e摘要：本文属于原创，欢迎转载，转载请保留出处：\x3ca href=\x22https:\/\/github.com\/jasonGeng88\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/jasonGeng88\/blog\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3ethis 是什么\x3c\/li\x3e\n\x3cli\x3ethis 的四种绑定规则\x3c\/li\x3e\n\x3cli\x3e绑定规则的优先级\x3c\/li\x3e\n\x3cli\x3e绑定例外\x3c\/li\x3e\n\x3cli\x3e扩展：箭头函数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3ethis 是什么\x3c\/h2\x3e\n\x3cp\x3e理解this之前， 先纠正一个观点，\x3cstrong\x3ethis 既不指向函数自身，也不指函数的词法作用域\x3c\/strong\x3e。如果仅通过this的英文解释，太容易产生误导了。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3ethis 的四种绑定规则\x3c\/h2\x3e\n\x3cp\x3ethis的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e默认绑定\x3c\/h3\x3e\n\x3cp\x3e什么叫默认绑定，即没有其他绑定规则存在时的默认规则。这也是函数调用中最常用的规则。\x3c\/p\x3e\n\x3cp\x3e来看这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n}       console.log( this.a );\n\nvar a = 2; \nfoo(); \/\/打印的是什么？\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n}       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; \nfoo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/打印的是什么？\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3efoo()\x3c\/code\x3e 打印的结果是2。\x3c\/p\x3e\n\x3cp\x3e因为foo()是直接调用的（独立函数调用），没有应用其他的绑定规则，这里进行了默认绑定，将全局对象绑定this上，所以this.a 就解析成了全局变量中的a，即2。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e注意：在严格模式下（strict mode），全局对象将无法使用默认绑定，即执行会报undefined的错误\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    \x26quot;use strict\x26quot;;\n   console.log( this.a );\n}\n\nvar a = 2; \nfoo(); \/\/ Uncaught TypeError: Cannot read property \x27a\x27 of undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n\x3cspan class=\x22hljs-meta\x22\x3e    \x22use strict\x22\x3c\/span\x3e;\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; \nfoo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Uncaught TypeError: Cannot read property \x27a\x27 of undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e隐式绑定\x3c\/h3\x3e\n\x3cp\x3e除了直接对函数进行调用外，有些情况是，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nobj.foo(); \/\/ ?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\nobj.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eobj.foo()\x3c\/code\x3e 打印的结果是3。\x3c\/p\x3e\n\x3cp\x3e这里foo函数被当做引用属性，被添加到obj对象上。这里的调用过程是这样的：\x3c\/p\x3e\n\x3cp\x3e获取obj.foo属性 -\x26gt; 根据引用关系找到foo函数，执行调用\x3c\/p\x3e\n\x3cp\x3e所以这里对foo的调用存在上下文对象obj，this进行了隐式绑定，即this绑定到了obj上，所以this.a被解析成了obj.a，即3。\x3c\/p\x3e\n\x3ch4\x3e多层调用链\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj1 = { \n    a: 4,\n    foo: foo \n};\n\nvar obj2 = { \n    a: 3,\n    obj1: obj1\n};\n\nobj2.obj1.foo(); \/\/?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eobj1\x3c\/span\x3e: obj1\n};\n\nobj2.obj1.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eobj2.obj1.foo()\x3c\/code\x3e 打印的结果是4。\x3c\/p\x3e\n\x3cp\x3e同样，我们看下函数的调用过程：\x3c\/p\x3e\n\x3cp\x3e先获取obj2.obj1 -\x26gt; 通过引用获取到obj1对象，再访问 obj1.foo -\x26gt; 最后执行foo函数调用\x3c\/p\x3e\n\x3cp\x3e这里调用链不只一层，存在obj1、obj2两个对象，那么隐式绑定具体会绑哪个对象。这里原则是获取最后一层调用的上下文对象，即obj1，所以结果显然是4（obj1.a）。\x3c\/p\x3e\n\x3ch4\x3e隐式丢失（函数别名）\x3c\/h4\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e注意：这里存在一个陷阱，大家在分析调用过程时，要特别小心\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e先看个代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nvar bar = obj.foo;\nbar(); \/\/?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.foo;\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x26lt;font color=\x22red\x22\x26gt;\x3cstrong\x3e\x3ccode\x3ebar()\x3c\/code\x3e 打印的结果是2。\x3c\/strong\x3e\x26lt;\/font\x26gt;\x3c\/p\x3e\n\x3cp\x3e为什么会这样，obj.foo 赋值给bar，那调用\x3ccode\x3ebar()\x3c\/code\x3e为什么没有触发隐式绑定，使用的是默认绑定呢。\x3c\/p\x3e\n\x3cp\x3e这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。\x3c\/p\x3e\n\x3cp\x3e那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定，全局属性a。\x3c\/p\x3e\n\x3ch4\x3e隐式丢失（回调函数）\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nsetTimeout( obj.foo, 100 ); \/\/ ？\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\nsetTimeout( obj.foo, \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ？\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x26lt;font color=\x22red\x22\x26gt;\x3cstrong\x3e打印的结果是2。\x3c\/strong\x3e\x26lt;\/font\x26gt;\x3c\/p\x3e\n\x3cp\x3e同样的道理，虽然参传是\x3ccode\x3eobj.foo\x3c\/code\x3e，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于\x3ccode\x3esetTimeout\x3c\/code\x3e的调用，还是 setTimeout -\x26gt; 获取参数中foo的引用参数 -\x26gt; 执行 foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e显示绑定\x3c\/h3\x3e\n\x3cp\x3e相对隐式绑定，this值在调用过程中会动态变化，可是我们就想绑定指定的对象，这时就用到了显示绑定。\x3c\/p\x3e\n\x3cp\x3e显示绑定主要是通过改变对象的prototype关联对象，这里不展开讲。具体使用上，可以通过这两个方法call(...)或apply(...)来实现（大多数函数及自己创建的函数默认都提供这两个方法）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3ecall与apply是同样的作用，区别只是其他参数的设置上\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj1 = { \n    a: 3,\n};\n\nvar obj2 = { \n    a: 4,\n};\nfoo.call( obj1 ); \/\/ ?\nfoo.call( obj2 ); \/\/ ?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n};\nfoo.call( obj1 ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\nfoo.call( obj2 ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e打印的结果是3, 4。\x3c\/p\x3e\n\x3cp\x3e这里因为显示的申明了要绑定的对象，所以this就被绑定到了obj上，打印的结果自然就是obj1.a 和obj2.a。\x3c\/p\x3e\n\x3ch4\x3e硬绑定\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj1 = { \n    a: 3,\n};\n\nvar obj2 = { \n    a: 4,\n};\n\nvar bar = function(){\n    foo.call( obj1 );\n}\n\nbar(); \/\/ 3\nsetTimeout( bar, 100 ); \/\/ 3\n\nbar.call( obj2 ); \/\/ 这是多少\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    foo.call( obj1 );\n}\n\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\nsetTimeout( bar, \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\nbar.call( obj2 ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这是多少\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e前面两个（函数别名、回调函数）打印3，因为显示绑定了，没什么问题。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e最后一个打印是3。\x3c\/p\x3e\n\x3cp\x3e这里需要注意下，虽然bar被显示绑定到obj2上，对于bar，function(){...} 中的this确实被绑定到了obj2，而foo因为通过\x3ccode\x3efoo.call( obj1 )\x3c\/code\x3e已经显示绑定了obj1，所以在foo函数内，this指向的是obj1，不会因为bar函数内指向obj2而改变自身。所以打印的是obj1.a（即3）。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3enew 绑定\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3ejs中的new操作符，和其他语言中（如JAVA）的new机制是不一样的。js中，它就是一个普通函数调用，只是被new修饰了而已。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e使用new来调用函数，会自动执行如下操作：\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e从第三点可以看出，this指向的就是对象本身。\x3c\/p\x3e\n\x3cp\x3e看个代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a) { \n    this.a = a;\n}\n\nvar a = 2;\n\nvar bar1 = new foo(3);\nconsole.log(bar1.a); \/\/ ?\n\nvar bar2 = new foo(4);\nconsole.log(bar2.a); \/\/ ?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = a;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar1.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar2.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后一个打印是3, 4。\x3c\/p\x3e\n\x3cp\x3e因为每次调用生成的是全新的对象，该对象又会自动绑定到this上，所以答案显而易见。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e绑定规则优先级\x3c\/h2\x3e\n\x3cp\x3e上面也说过，这里在重复一下。优先级是这样的，以按照下面的顺序来进行判断:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。\n 数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是 指定的对象。\n 数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象。\n 果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。\n var bar = foo()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e 数是否在\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e\x3c\/span\x3e中调用(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e\x3c\/span\x3e绑定)?如果是的话\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e绑定的是新创建的对象。\n 数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e绑定的是 指定的对象。\n 数是否在某个上下文对象中调用(隐式绑定)?如果是的话,\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e绑定的是那个上下文对象。\n 果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e规则例外\x3c\/h2\x3e\n\x3cp\x3e在显示绑定中，对于null和undefined的绑定将不会生效。\x3c\/p\x3e\n\x3cp\x3e代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() { \n    console.log( this.a );\n}\nfoo.call( null ); \/\/ 2\nfoo.call( undefined ); \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\nfoo.call( \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\nfoo.call( \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种情况主要是用在不关心this的具体绑定对象（用来忽略this），而传入null实际上会进行默认绑定，导致函数中可能会使用到全局变量，与预期不符。\x3c\/p\x3e\n\x3cp\x3e所以对于要忽略this的情况，可以传入一个空对象ø，该对象通过\x3ccode\x3eObject.create(null)\x3c\/code\x3e创建。这里不用{}的原因是，ø是真正意义上的空对象，它不创建Object.prototype委托，{}和普通对象一样，有原型链委托关系。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e1. 这里传null的一种具体使用场景是函数柯里化的使用\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e扩展：箭头函数\x3c\/h2\x3e\n\x3cp\x3e最后，介绍一下ES6中的箭头函数。通过“=\x26gt;”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ecase 1 (正常调用)\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3e普通函数\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){     \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nobj.foo(); \/\/3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{     \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\nobj.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e箭头函数\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var foo = () =\x3e {     \n    console.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nobj.foo(); \/\/2\nfoo.call(obj); \/\/2 ，箭头函数中显示绑定不会生效\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {     \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\nobj.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\nfoo.call(obj); \x3cspan class=\x22hljs-comment\x22\x3e\/\/2 ，箭头函数中显示绑定不会生效\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3ecase 2 （函数回调）\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3e普通函数\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){ \n    return function(){\n        console.log( this.a );\n    }    \n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nvar bar = obj.foo();\nbar(); \/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n    }    \n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.foo();\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e箭头函数\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){ \n    return () =\x3e {\n        console.log( this.a );\n    }    \n}\n\n\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nvar bar = obj.foo();\nbar(); \/\/3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n    }    \n}\n\n\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.foo();\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过上面两个列子，我们看到箭头函数的this绑定\x26lt;font color=\x22red\x22\x26gt;\x3cstrong\x3e只取决于外层（函数或全局）的作用域\x3c\/strong\x3e\x26lt;\/font\x26gt;，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e注意：对于ES6之前，箭头函数的替换版本是这样的\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ es6\nfunction foo(){ \n    return () =\x3e {\n        console.log( this.a );\n    }   \n}\n\nvar a = 2;\n\nvar obj = { \n    a: 3,\n    foo: foo \n};\n\nvar bar = obj.foo();\nbar(); \/\/3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n    }   \n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo \n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj.foo();\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过上面两个列子，我们看到箭头函数的this绑定\x26lt;font color=\x22red\x22\x26gt;\x3cstrong\x3e只取决于外层（函数或全局）的作用域\x3c\/strong\x3e\x26lt;\/font\x26gt;，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e注意：对于ES6之前，箭头函数的替换版本是这样的\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ es6\nfunction foo(){ \n    return () =\x3e {\n        console.log( this.a );\n    }   \n}\n\n\/\/ es6之前的替代方法\nfunction foo(){ \n     var self = this;\n    return () =\x3e {\n        console.log( self.a );\n    }   \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a );\n    }   \n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6之前的替代方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \n     \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e self = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( self.a );\n    }   \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e我们在使用js的过程中，对于this的理解往往觉得比较困难，再调试过程中有时也会出现一些不符合预期的现象。很多时候，我们都是通过一些变通的方式（如：使用具体对象替换this）来规避的问题。可问题一直存在那儿，我们没有真正的去理解和解决它。\x3c\/p\x3e\n\x3cp\x3e本文主要参考了《你不知道的JavaScript（上卷）》，对this到底是什么，具体怎么绑定的，有什么例外情况以及ES6中的一个优化方向，来彻底搞清楚我们一直使用的this到底是怎么玩的。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>彻底搞懂 JS 中 this 机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014224541">https://segmentfault.com/a/1190000014224541</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/x3axvqjiopm/" target="_blank">https://alili.tech/archive/x3axvqjiopm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>