<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webRTC实战总结"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webRTC实战总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/x8iogogp5xi/",
				"appid": "1613049289050283", 
				"title": "webRTC实战总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-16T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/b4p55f2vdsr/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qqy5gvd0ygn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&text=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&text=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&title=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&is_video=false&description=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&title=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&title=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&title=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx8iogogp5xi%2f&title=webRTC%e5%ae%9e%e6%88%98%e6%80%bb%e7%bb%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webRTC实战总结</h1><div class="meta"><div class="postdate"><time datetime="2018-12-16" itemprop="datePublished">2018-12-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e前言\x3c\/h3\x3e\n\x3cp\x3e前段时间一直在忙一个基于WebRTC的PC和移动端双向视频的项目。第一次接触webRTC，难免遇到了许多问题，比如：webRTC移动端兼容性检测，如何配置MediaStreamConstraints， 信令(iceCandidate, sessionDescription)传输方式的选择，iceCandidate和sessionDescription设置的先后顺序，STUN和TURN的概念，如何实现截图及录制视频及上传图片和视频功能，如何高效跟踪错误等等。好记性不如烂笔头，特写此文以记之。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e移动端兼容性\x3c\/h3\x3e\n\x3cp\x3e对PC端来说，webRTC早已被各大浏览器支持了，Chrome 28，FF22，Edge...随着不久之前发布的IOS11也宣布支持webRTC及getUserMedia，webRTC在移动端的应用前景也令人憧憬。\x3c\/p\x3e\n\x3cp\x3e具体到实际项目中，经过测试，各大国产安卓手机自带的浏览器基本不支持webRTC，但这些安卓手机的微信内置浏览器均能良好地支持webRTC，虽然Chrome及Firefox的移动端版本也能良好的支持webRTC，但国情决定了微信内置浏览器作为最佳切入点。另一方面。IOS11中微信内置浏览器还不支持webRTC(我坚信不久的将来就会支持)，但在Safari中能够完美支持。因此本项目选择了微信公众号为切入点，通过检测userAgent引导IOS11用户在Safari中打开页面。\x3c\/p\x3e\n\x3cp\x3e检测webRTC的可行性，主要从getUserMedia和webRTC本身来入手：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function detectWebRTC() {\n  const WEBRTC_CONSTANTS = [\x27RTCPeerConnection\x27, \x27webkitRTCPeerConnection\x27, \x27mozRTCPeerConnection\x27, \x27RTCIceGatherer\x27];\n\n  const isWebRTCSupported = WEBRTC_CONSTANTS.find((item) =\x3e {\n    return item in window;\n  });\n\n  const isGetUserMediaSupported = navigator \x26amp;\x26amp; navigator.mediaDevices \x26amp;\x26amp; navigator.mediaDevices.getUserMedia;\n\n  if (!isWebRTCSupported || typeof isGetUserMediaSupported === \x27undefined\x27 ) {\n    return false;\n  }\n\n  return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edetectWebRTC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e WEBRTC_CONSTANTS = [\x3cspan class=\x22hljs-string\x22\x3e\x27RTCPeerConnection\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27webkitRTCPeerConnection\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27mozRTCPeerConnection\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27RTCIceGatherer\x27\x3c\/span\x3e];\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isWebRTCSupported = WEBRTC_CONSTANTS.find(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e item \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e;\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isGetUserMediaSupported = navigator \x26amp;\x26amp; navigator.mediaDevices \x26amp;\x26amp; navigator.mediaDevices.getUserMedia;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isWebRTCSupported || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e isGetUserMediaSupported === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果返回false，再去检测userAgent给予用户不支持的具体提示。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e配置MediaStreamConstraints\x3c\/h3\x3e\n\x3cp\x3e所谓MediaStreamConstraints，就是navigator.mediaDevices.getUserMedia(constraints)传入的constraints，至于它的写法及功能，参考MDN，本文不做赘述。我在这里想要强调的是，对于移动端来说控制好视频图像的大小是很重要的，例如本项目中想要对方的图像占据全屏，这不仅是改变video元素的样式或者属性能做到的，首先要做的是改变MediaStreamConstraints中的视频分辨率(width, height)，使其长宽比例大致与移动端屏幕的类似，然后再将video元素的长和宽设置为容器的长和宽(例如100%)。\x3c\/p\x3e\n\x3cp\x3e另外对于getUserMedia一定要捕获可能出现的错误，如果是老的API，设置onErr回调，如果是新的(navigator.mediaDevices.getUserMedia)，则catch异常。这样做的原因：getUserMedia往往不会完全符合我们的预期，有时即使设置的是ideal的约束，仍然会报错，如果不追踪错误，往往一脸懵逼。这也是后文要提到的高效追踪错误的方法之一。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e搭建信令传输服务\x3c\/h3\x3e\n\x3cp\x3e\x3cbr\x3e要传输的信令包括两个部分：sessionDescription和iceCandidate。为了便于传输可将其处理成字符串，另一端接收时还原并用对应的构造函数构造对应的实例即可。\x3c\/p\x3e\n\x3cp\x3ewebRTC并没有规定信令的传输方式，而是完全由开发者自定义。常见的方式有短轮询、webSocket(socket.io等),短轮询的优点无非是简单，兼容性强，但在并发量较大时，服务器负荷会很重。而webSocket就不存在这个问题，但webSocket搭建起来较为复杂，并不是所有的浏览器都支持websocket。综合来说socket.io是个不错的解决方案，事件机制和自带的房间概念对撮合视频会话都是天然有利的，并且当浏览器不支持websocket时可以切换为轮询，也解决了兼容性的问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e发起视频会话的流程\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV2qly?w=1182\x26amp;h=1088\x22 src=\x22https:\/\/static.alili.tech\/img\/bV2qly?w=1182\x26amp;h=1088\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e可以看到无论是发起方还是接受方，第一步都是getUserMedia获取本地媒体流，然后新建一个\x3ccode\x3eRTCPeerConnection\x3c\/code\x3e实例，并指定好onicecandidate、onaddstream等回调：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 指定TURN及STUN\nconst peerConnectionConfig = {\n  \x27iceServers\x27: [\n    {\n      \x27urls\x27: \x27turn:numb.viagenie.ca\x27,\n      \x27username\x27: \x27muazkh\x27,\n      \x27credential\x27: \x27webrtc@live.com\x27\n    },\n\n    {\n      \x27urls\x27: \x27stun:stun.l.google.com:19302\x27\n    }\n  ],\n  bundlePolicy: \x27max-bundle\x27,\n};\n\nconst pc = new RTCPeerConnection(peerConnectionConfig);\npc.onicecandidate = ...;\npc.onaddstream = ...;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定TURN及STUN\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e peerConnectionConfig = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27iceServers\x27\x3c\/span\x3e: [\n    {\n      \x3cspan class=\x22hljs-string\x22\x3e\x27urls\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27turn:numb.viagenie.ca\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27username\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27muazkh\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27credential\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27webrtc@live.com\x27\x3c\/span\x3e\n    },\n\n    {\n      \x3cspan class=\x22hljs-string\x22\x3e\x27urls\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27stun:stun.l.google.com:19302\x27\x3c\/span\x3e\n    }\n  ],\n  bundlePolicy: \x3cspan class=\x22hljs-string\x22\x3e\x27max-bundle\x27\x3c\/span\x3e,\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pc = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e RTCPeerConnection(peerConnectionConfig);\npc.onicecandidate = ...;\npc.onaddstream = ...;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后addTrack指定要传输的视频流\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22stream.getTracks().forEach((track) =\x3e { pc.addTrack(track, stream); });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3estream.getTracks().forEach((track) \x3c\/span\x3e=\x26gt; { \x3cspan class=\x22hljs-built_in\x22\x3epc\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eaddTrack(track, \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3estream); \x3c\/span\x3e})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发起方通过createOffer生成localDescription并传给pc.setLocalDescription()，pc获取了本地的sdp后开始获取candidate，这里的candidate指的是网络信息(ip、端口、协议)，根据优先级从高到低分为三类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ehost: 设备的ipv4或ipv6地址，即内网地址，一般会有两个，分别对应udp和tcp，ip相同，端口不同;\x3c\/li\x3e\n\x3cli\x3esrflx(server reflexive): STUN返回的外网地址；\x3c\/li\x3e\n\x3cli\x3erelay: 当STUN不适用时(某些NAT会为每个连接分配不同的端口，导致获取的端口和视频连接端口并不一致)，中继服务器的地址；\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e三者之中只需要有一类连接成功即可，所以如果通信双方在同一内网，不配置STUN和TURN也可以直接连接。其实这里隐藏着性能优化的点：如上图所示，webRTC通信双方在交换candidate时，首先由发起方先收集\x3ccode\x3e所有的\x3c\/code\x3ecandidate，然后在icegatheringstatechange事件中检测iceGatheringState是否为\x27complete\x27，再发送给接收方。接收方设置了发送方传来的sdp和candidate后，同样要收集完自己\x3ccode\x3e所有的\x3c\/code\x3ecandidate，再发送给对方。如果这些candidate中有一对可以连接成功，则P2P通信建立，否则连接失败。\x3c\/p\x3e\n\x3cp\x3e问题来了，接受端要等待发起方收集完所有的candidate之后才开始收集自己的candidate，这其实是可以同时进行的；另外其实不一定需要所有的candidate才能建立连接，这也是可以省下时间的；最后如果网络，STUN或者TURN出现问题，在上述传输模式下是非常致命的，会让连接的时间变得很长不可接受。\x3c\/p\x3e\n\x3cp\x3e解决方案就是IETF提出的Trickle ICE。即发起方每获取一个candidate便立即发送给接收方，这样做的好处在于第一类candidate即host，会立即发送给接收方，这样接收方收到后可以立刻开始收集candidate，也就是发起方和接收方同时进行收集candidate的工作。另外，接收方每收到一个candidate会立即去检查它的有效性，如果有效直接接通视频，如果无效也不至于浪费时间。详情可以参见\x3ca href=\x22https:\/\/webrtchacks.com\/trickle-ice\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eICE always tastes better when it trickles\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e至于sessionDescription及iceCandidate的传输，因为JavaScript没有处理sdp格式数据的方法，所以直接将其当做字符串处理，这样做的坏处是难以改变sdp中的信息(如果非要改，通过正则匹配还是能改的)。\x3c\/p\x3e\n\x3cp\x3e在挂断视频时，不仅要关闭peerConnection，也要停止本地及远程的媒体流：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst tracks = localStream.getTracks().concat(remoteStream.getTracks());\ntracks.forEach((track) =\x3e {\n  track.stop();\n});\n\npeerConnection.close();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e\nconst tracks = localStream.getTracks().concat(remoteStream.getTracks())\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\ntracks.forEach((track) =\x26gt; {\n  track.stop()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n})\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\npeerConnection.close()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e截图\x26amp;录制视频\x3c\/h3\x3e\n\x3cp\x3e截图其实并不算什么新鲜的东西，无非是利用canvas的drawImage函数获取video元素在某一帧的图像，得到的是图片的base64格式字符串，但要注意的是这样得到的base64码之前有这样一串文本：\x3c\/p\x3e\n\x3cblockquote\x3edata:image\/png;base64,\x3c\/blockquote\x3e\n\x3cp\x3e这是对数据协议，格式，编码方式的声明，是给浏览器看的。所以在将drawImage得到的字符串上传给服务器时，最好将这串文本去掉，防止后端在转换图片时出现错误。\x3c\/p\x3e\n\x3cp\x3e录制视频使用的是MediaRecorder API 详情参考\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/MediaRecorder\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN MediaRecorder\x3c\/a\x3e，目前仅支持录制webm格式的视频。可以在新建MediaRecorder实例的时候，设置mimeType、videoBitsPerSecond、audioBitsPerSecond：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const options = {\n  mimeType: \x27video\/webm;codecs=vp8\x27,     \/\/ 视频格式及编码格式\n  videoBitsPerSecond: 2500000,           \/\/ 视频比特率，影响文件大小和质量 \n  audioBitsPerSecond: 128000             \/\/ 音频比特率，影响文件大小和质量\n};\n\nconst recorder = new MediaRecorder(options);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = {\n  mimeType: \x3cspan class=\x22hljs-string\x22\x3e\x27video\/webm;codecs=vp8\x27\x3c\/span\x3e,     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 视频格式及编码格式\x3c\/span\x3e\n  videoBitsPerSecond: \x3cspan class=\x22hljs-number\x22\x3e2500000\x3c\/span\x3e,           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 视频比特率，影响文件大小和质量 \x3c\/span\x3e\n  audioBitsPerSecond: \x3cspan class=\x22hljs-number\x22\x3e128000\x3c\/span\x3e             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 音频比特率，影响文件大小和质量\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e recorder = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MediaRecorder(options);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在recorder的ondataavailable事件中拿到数据，将其转换为Blob对象，再通过Formdata异步上传至服务器。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e错误追踪\x3c\/h3\x3e\n\x3cp\x3e整个双向视频涉及到的步骤较多，做好错误追踪是非常重要的。像getUserMedia时，一定要catch可能出现的异常。因为不同的设备，不同的浏览器或者说不同的用户往往不能完全满足我们设置的constraints。还有在实例化RTCPeerConnection时，往往会出现不可预期的错误，常见的有STUN、TURN格式不对，还有createOffer时传递的offerOptions格式不对,正确的应该为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const offerOptions = {\n  \x27offerToReceiveAudio\x27: true,\n  \x27offerToReceiveVideo\x27: true\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eofferOptions\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  \x27offerToReceiveAudio\x27:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  \x27offerToReceiveVideo\x27:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eCAVEAT\x3c\/h3\x3e\n\x3cp\x3e因为webRTC标准还在不断地更新中，所以相关的API经常会有改动。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3enavigator.getUserMeida(已废弃)，现在改为navigator.mediaDevices.getUserMedia;\x3c\/li\x3e\n\x3cli\x3eRTCPeerConnection.addStream被RTCPeerConnection.addTrack取代;\x3c\/li\x3e\n\x3cli\x3eSTUN,TURN配置里的url现被urls取代；\x3c\/li\x3e\n\x3cli\x3e...\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外，对video元素也要特殊处理。设置autoPlay属性，对播放本地视频源的video还要设置muted属性以去除回音。针对IOS播放视频自动全屏的特性，还要设置playsinline属性的值为true。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webRTC实战总结</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000012931944">https://segmentfault.com/a/1190000012931944</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/x8iogogp5xi/" target="_blank">https://alili.tech/archive/x8iogogp5xi/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>