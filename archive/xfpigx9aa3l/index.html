<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译]理解 Node.js 事件驱动机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译]理解 Node.js 事件驱动机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xfpigx9aa3l/",
				"appid": "1613049289050283", 
				"title": "[译]理解 Node.js 事件驱动机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-04T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/820i3ycttir/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/owmu0b66hdp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&text=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&text=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&title=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&is_video=false&description=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&title=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&title=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&title=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxfpigx9aa3l%2f&title=%5b%e8%af%91%5d%e7%90%86%e8%a7%a3%20Node.js%20%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译]理解 Node.js 事件驱动机制</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e学习 Node.js 一定要理解的内容之一，文中主要涉及到了 EventEmitter 的使用和一些异步情况的处理，比较偏基础，值得一读。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/medium.freecodecamp.org\/understanding-node-js-event-driven-architecture-223292fcbc2d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阅读原文\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e大多数 Node.js 对象都依赖了 EventEmitter 模块来监听和响应事件，比如我们常用的 HTTP requests, responses, 以及 streams。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const EventEmitter = require(\x27events\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EventEmitter = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27events\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e事件驱动机制的最简单形式，是在 Node.js 中十分流行的回调函数，例如 fs.readFile。 在回调函数这种形式中，事件每被触发一次，回调就会被触发一次。\x3c\/p\x3e\n\x3cp\x3e我们先来探索下这个最基本的方式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e你准备好了就叫我哈，Node！\x3c\/h2\x3e\n\x3cp\x3e很久很久以前，在 js 里还没有原生支持 Promise，async\/await 还只是一个遥远的梦想，回调函数是处理异步问题的最原始的方式。\x3c\/p\x3e\n\x3cp\x3e回调从本质上讲是传递给其他函数的函数，在 JavaScript 中函数是第一类对象，这也让回调的存在成为可能。\x3c\/p\x3e\n\x3cp\x3e一定要搞清楚的是，回调在代码中的并不表示异步调用。 回调既可以是同步调用的，也可以是异步调用的。\x3c\/p\x3e\n\x3cp\x3e举个例子，这里有一个宿主函数 fileSize，它接受一个回调函数 cb，并且可以通过条件判断来同步或者异步地调用该回调函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fileSize (fileName, cb) {\n  if (typeof fileName !== \x27string\x27) {\n    \/\/ Sync\n    return cb(new TypeError(\x27argument should be string\x27)); \n  }  \n  fs.stat(fileName, (err, stats) =\x3e {\n    if (err) {   \n      \/\/ Async\n      return cb(err); \n     } \n     \/\/ Async\n    cb(null, stats.size);\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efileSize\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efileName, cb\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e fileName !== \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Sync\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cb(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27argument should be string\x27\x3c\/span\x3e)); \n  }  \n  fs.stat(fileName, (err, stats) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {   \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Async\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cb(err); \n     } \n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Async\x3c\/span\x3e\n    cb(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, stats.size);\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这其实也是个反例，这样写经常会引起一些意外的错误，在设计宿主函数的时候，应当尽可能的使用同一种风格，要么始终都是同步的使用回调，要么始终都是异步的。\x3c\/p\x3e\n\x3cp\x3e我们来研究下一个典型的异步 Node 函数的简单示例，它用回调样式编写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const readFileAsArray = function(file, cb) {\n  fs.readFile(file, function(err, data) {\n    if (err) {\n      return cb(err);\n    }\n    const lines = data.toString().trim().split(\x27\\n\x27);\n    cb(null, lines);\n  });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e readFileAsArray = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile, cb\x3c\/span\x3e) \x3c\/span\x3e{\n  fs.readFile(file, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cb(err);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lines = data.toString().trim().split(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e);\n    cb(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, lines);\n  });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ereadFileAsArray 函数接受两个参数：一个文件路径和一个回调函数。它读取文件内容，将其拆分成行数组，并将该数组作为回调函数的参数传入，调用回调函数。\x3c\/p\x3e\n\x3cp\x3e现在设计一个用例，假设我们在同一目录中的文件 numbers.txt 包含如下内容：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x2210\n11\n12\n13\n14\n15\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode class=\x22txt\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e14\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们有一个需求，要求统计该文件中的奇数数量，我们可以使用 readFileAsArray 来简化代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22readFileAsArray(\x27.\/numbers.txt\x27, (err, lines) =\x3e {\n  if (err) throw err;\n  const numbers = lines.map(Number);\n  const oddNumbers = numbers.filter(n =\x3e n%2 === 1);\n  console.log(\x27Odd numbers count:\x27, oddNumbers.length);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3ereadFileAsArray(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/numbers.txt\x27\x3c\/span\x3e, (err, lines) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e numbers = lines.map(\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oddNumbers = numbers.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e =\x26gt;\x3c\/span\x3e n%\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Odd numbers count:\x27\x3c\/span\x3e, oddNumbers.length);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码将文件内容读入字符串数组中，回调函数将其解析为数字，并计算奇数的个数。\x3c\/p\x3e\n\x3cp\x3e这才是最纯粹的 Node 回调风格。回调的第一个参数要遵循错误优先的原则，err 可以为空，我们要将回调作为宿主函数的最后一个参数传递。你应该一直用这种方式这样设计你的函数，因为用户可能会假设。让宿主函数把回调当做其最后一个参数，并让回调函数以一个可能为空的错误对象作为其第一个参数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e回调在现代 JavaScript 中的替代品\x3c\/h2\x3e\n\x3cp\x3e在现代 JavaScript 中，我们有 Promise，Promise 可以用来替代异步 API 的回调。回调函数需要作为宿主函数的一个参数进行传递（多个宿主回调进行嵌套就形成了回调地狱），而且错误和成功都只能在其中进行处理。而 Promise 对象可以让我们分开处理成功和错误，还允许我们链式调用多个异步事件。\x3c\/p\x3e\n\x3cp\x3e如果 readFileAsArray 函数支持 Promise，我们可以这样使用它，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22readFileAsArray(\x27.\/numbers.txt\x27)\n  .then(lines =\x3e {\n    const numbers = lines.map(Number);\n    const oddNumbers = numbers.filter(n =\x3e n%2 === 1);\n    console.log(\x27Odd numbers count:\x27, oddNumbers.length);\n  })\n  .catch(console.error);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3ereadFileAsArray(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/numbers.txt\x27\x3c\/span\x3e)\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3elines\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e numbers = lines.map(\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oddNumbers = numbers.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e =\x26gt;\x3c\/span\x3e n%\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Odd numbers count:\x27\x3c\/span\x3e, oddNumbers.length);\n  })\n  .catch(\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在宿主函数的返回值上调用了一个函数来处理我们的需求，这个 .then 函数会把刚刚在回调版本中的那个行数组传递给这里的匿名函数。为了处理错误，我们在结果上添加一个 .catch 调用，当发生错误时，它会捕捉到错误并让我们访问到这个错误。\x3c\/p\x3e\n\x3cp\x3e在现代 JavaScript 中已经支持了 Promise 对象，因此我们可以很容易的将其使用在宿主函数之中。下面是支持 Promise 版本的 readFileAsArray 函数（同时支持旧有的回调函数方式）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const readFileAsArray = function(file, cb = () =\x3e {}) {\n  return new Promise((resolve, reject) =\x3e {\n    fs.readFile(file, function(err, data) {\n      if (err) {\n        reject(err);\n        return cb(err);\n      }      \n      const lines = data.toString().trim().split(\x27\\n\x27);\n      resolve(lines);\n      cb(null, lines);\n    });\n  });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e readFileAsArray = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile, cb = (\x3c\/span\x3e) =\x26gt; \x3c\/span\x3e{}) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    fs.readFile(file, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, data\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        reject(err);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cb(err);\n      }      \n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lines = data.toString().trim().split(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e);\n      resolve(lines);\n      cb(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, lines);\n    });\n  });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们使该函数返回一个 Promise 对象，该对象包裹了 fs.readFile 的异步调用。Promise 对象暴露了两个参数，一个 resolve 函数和一个 reject 函数。\x3c\/p\x3e\n\x3cp\x3e当有异常抛出时，我们可以通过向回调函数传递 error 来处理错误，也同样可以使用 Promise 的 reject 函数。每当我们将数据交给回调函数处理时，我们同样也可以用 Promise 的 resolve 函数。\x3c\/p\x3e\n\x3cp\x3e在这种同时可以使用回调和 Promise 的情况下，我们需要做的唯一一件事情就是为这个回调参数设置默认值，防止在没有传递回调函数参数时，其被执行然后报错的情况。 在这个例子中使用了一个简单的默认空函数：（）=\x26gt; {}。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e通过 async\/await 使用 Promise\x3c\/h2\x3e\n\x3cp\x3e当需要连续调用异步函数时，使用 Promise 会让你的代码更容易编写。不断的使用回调会让事情变得越来越复杂，最终陷入回调地狱。\x3c\/p\x3e\n\x3cp\x3ePromise 的出现改善了一点，Generator 的出现又改善了一点。 处理异步问题的最新解决方式是使用 async 函数，它允许我们将异步代码视为同步代码，使其整体上更加可读。\x3c\/p\x3e\n\x3cp\x3e以下是使用 async\/await 版本的调用 readFileAsArray 的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function countOdd () {\n  try {\n    const lines = await readFileAsArray(\x27.\/numbers\x27);\n    const numbers = lines.map(Number);\n    const oddCount = numbers.filter(n =\x3e n%2 === 1).length;\n    console.log(\x27Odd numbers count:\x27, oddCount);\n  } catch(err) {\n    console.error(err);\n  }\n}\ncountOdd();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecountOdd\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lines = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e readFileAsArray(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/numbers\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e numbers = lines.map(\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oddCount = numbers.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e =\x26gt;\x3c\/span\x3e n%\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e).length;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Odd numbers count:\x27\x3c\/span\x3e, oddCount);\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err);\n  }\n}\ncountOdd();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先，我们创建了一个 async 函数 —— 就是一个普通的函数声明之前，加了个 async 关键字。在 async 函数内部，我们调用了 readFileAsArray 函数，就像把它的返回值赋值给变量 lines 一样，为了真的拿到 readFileAsArray 处理生成的行数组，我们使用关键字 await。之后，我们继续执行代码，就好像 readFileAsArray 的调用是同步的一样。\x3c\/p\x3e\n\x3cp\x3e要让代码运行，我们可以直接调用 async 函数。这让我们的代码变得更加简单和易读。为了处理异常，我们需要将异步调用包装在一个 try\/catch 语句中。\x3c\/p\x3e\n\x3cp\x3e有了 async\/await 这个特性，我们不必使用任何特殊的API（如 .then 和 .catch ）。我们只是把这种函数标记出来，然后使用纯粹的 JavaScript 写代码。\x3c\/p\x3e\n\x3cp\x3e我们可以把 async\/await 这个特性用在支持使用 Promise 处理后续逻辑的函数上。但是，它无法用在只支持回调的异步函数上（例如setTimeout）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eEventEmitter 模块\x3c\/h2\x3e\n\x3cp\x3eEventEmitter 是一个处理 Node 中各个对象之间通信的模块。 EventEmitter 是 Node 异步事件驱动架构的核心。 Node 的许多内置模块都继承自 EventEmitter。\x3c\/p\x3e\n\x3cp\x3e它的概念其实很简单：emitter 对象会发出被定义过的事件，导致之前注册的所有监听该事件的函数被调用。所以，emitter 对象基本上有两个主要特征：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e触发定义过的事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e注册或者取消注册监听函数\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了使用 EventEmitter，我们需要创建一个继承自 EventEmitter 的类。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyEmitter extends EventEmitter {\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyEmitter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e \x3c\/span\x3e{\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们从 EventEmitter 的子类实例化的对象，就是 emitter 对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const myEmitter = new MyEmitter();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e myEmitter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MyEmitter();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这些 emitter 对象的生命周期里，我们可以调用 emit 函数来触发我们想要的触发的任何被命名过的事件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22myEmitter.emit(\x27something-happened\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3emyEmitter.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27something-happened\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eemit 函数的使用表示发生某种情况发生了，让大家去做该做的事情。 这种情况通常是某些状态变化引起的。\x3c\/p\x3e\n\x3cp\x3e我们可以使用 on 方法添加监听器函数，并且每次 emitter 对象触发其关联的事件时，将执行这些监听器函数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e事件 !== 异步\x3c\/h2\x3e\n\x3cp\x3e先看看这个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const EventEmitter = require(\x27events\x27);\n\nclass WithLog extends EventEmitter {\n  execute(taskFunc) {\n    console.log(\x27Before executing\x27);\n    this.emit(\x27begin\x27);\n    taskFunc();\n    this.emit(\x27end\x27);\n    console.log(\x27After executing\x27);\n  }\n}\n\nconst withLog = new WithLog();\n\nwithLog.on(\x27begin\x27, () =\x3e console.log(\x27About to execute\x27));\nwithLog.on(\x27end\x27, () =\x3e console.log(\x27Done with execute\x27));\n\nwithLog.execute(() =\x3e console.log(\x27*** Executing task ***\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EventEmitter = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27events\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWithLog\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e \x3c\/span\x3e{\n  execute(taskFunc) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Before executing\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e);\n    taskFunc();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27After executing\x27\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e withLog = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WithLog();\n\nwithLog.on(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27About to execute\x27\x3c\/span\x3e));\nwithLog.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done with execute\x27\x3c\/span\x3e));\n\nwithLog.execute(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27*** Executing task ***\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWithLog 是一个事件触发器，它有一个方法 —— execute，该方法接受一个参数，即具体要处理的任务函数，并在其前后包裹 log 以输出其执行日志。\x3c\/p\x3e\n\x3cp\x3e为了看到这里会以什么顺序执行，我们在两个命名的事件上都注册了监听器，最后执行一个简单的任务来触发事件。\x3c\/p\x3e\n\x3cp\x3e下面是上面程序的输出结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Before executing\nAbout to execute\n*** Executing task ***\nDone with execute\nAfter executing\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode class=\x22log\x22\x3eBefore executing\nAbout to\x3cspan class=\x22hljs-built_in\x22\x3e execute\n\x3c\/span\x3e*** Executing task ***\nDone with\x3cspan class=\x22hljs-built_in\x22\x3e execute\n\x3c\/span\x3eAfter executing\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我想证实的是以上的输出都是同步发生的，这段代码里没有什么异步的成分。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e第一行输出了 \x22Before executing\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebegin 事件被触发，输出 \x22About to execute\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e真正应该被执行的任务函数被调用，输出 \x22\x3cstrong\x3e\x3cem\x3e Executing task \x3c\/em\x3e\x3c\/strong\x3e\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eend 事件被触发，输出 \x22Done with execute\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最后输出 \x22After executing\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e就像普通的回调一样，不要以为事件意味着同步或异步代码。\x3c\/p\x3e\n\x3cp\x3e跟之前的回调一样，不要一提到事件就认为它是异步的或者同步的，还要具体分析。\x3c\/p\x3e\n\x3cp\x3e如果我们传递 taskFunc 是一个异步函数，会发生什么呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n\nwithLog.execute(() =\x3e {\n  setImmediate(() =\x3e {\n    console.log(\x27*** Executing task ***\x27)\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\nwithLog.execute(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  setImmediate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27*** Executing task ***\x27\x3c\/span\x3e)\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出结果变成了这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Before executing\nAbout to execute\nDone with execute\nAfter executing\n*** Executing task ***\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode class=\x22log\x22\x3eBefore executing\nAbout to\x3cspan class=\x22hljs-built_in\x22\x3e execute\n\x3c\/span\x3eDone with\x3cspan class=\x22hljs-built_in\x22\x3e execute\n\x3c\/span\x3eAfter executing\n*** Executing task ***\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样就有问题了，异步函数的调用导致 \x22Done with execute\x22 和 \x22After executing\x22 的输出并不准确。\x3c\/p\x3e\n\x3cp\x3e要在异步函数完成后发出事件，我们需要将回调（或 Promise）与基于事件的通信相结合。 下面的例子说明了这一点。\x3c\/p\x3e\n\x3cp\x3e使用事件而不是常规回调的一个好处是，我们可以通过定义多个监听器对相同的信号做出多个不同的反应。如果使用回调来完成这件事，我们要在单个回调中写更多的处理逻辑。事件是应用程序允许多个外部插件在应用程序核心之上构建功能的好办法。你可以把它们当成钩子来挂一些由于状态变化而引发执行的程序。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e异步事件\x3c\/h2\x3e\n\x3cp\x3e我们把刚刚那些同步代码的示例改成异步的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst EventEmitter = require(\x27events\x27);\n\nclass WithTime extends EventEmitter {\n  execute(asyncFunc, ...args) {\n    this.emit(\x27begin\x27);\n    console.time(\x27execute\x27);\n    asyncFunc(...args, (err, data) =\x3e {\n      if (err) {\n        return this.emit(\x27error\x27, err);\n      }\n\n      this.emit(\x27data\x27, data);\n      console.timeEnd(\x27execute\x27);\n      this.emit(\x27end\x27);\n    });\n  }\n}\n\nconst withTime = new WithTime();\n\nwithTime.on(\x27begin\x27, () =\x3e console.log(\x27About to execute\x27));\nwithTime.on(\x27end\x27, () =\x3e console.log(\x27Done with execute\x27));\n\nwithTime.execute(fs.readFile, __filename);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EventEmitter = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27events\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWithTime\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e \x3c\/span\x3e{\n  execute(asyncFunc, ...args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n    asyncFunc(...args, (err, data) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, data);\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e);\n    });\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e withTime = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WithTime();\n\nwithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27About to execute\x27\x3c\/span\x3e));\nwithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done with execute\x27\x3c\/span\x3e));\n\nwithTime.execute(fs.readFile, __filename);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用 WithTime 类执行 asyncFunc 函数，并通过调用 console.time 和 console.timeEnd 报告该asyncFunc 所花费的时间。它在执行之前和之后都将以正确的顺序触发相应的事件，并且还会发出 error\/data 事件作为处理异步调用的信号。\x3c\/p\x3e\n\x3cp\x3e我们传递一个异步的 fs.readFile 函数来测试一下 withTime emitter。 我们现在可以直接通过监听 data 事件来处理读取到的文件数据，而不用把这套处理逻辑写到 fs.readFile 的回调函数中。\x3c\/p\x3e\n\x3cp\x3e执行这段代码，我们以预期的顺序执行了一系列事件，并且得到异步函数的执行时间，这些是十分重要的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22About to execute\nexecute: 4.507ms\nDone with execute\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode class=\x22log\x22\x3eAbout to\x3cspan class=\x22hljs-built_in\x22\x3e execute\n\x3c\/span\x3eexecute: 4.507ms\nDone with execute\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，我们是将回调与事件触发器 emitter 相结合实现的这部分功能。 如果 asynFunc 支持Promise，我们可以使用 async\/await 函数来做同样的事情：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class WithTime extends EventEmitter {\n  async execute(asyncFunc, ...args) {\n    this.emit(\x27begin\x27);\n    try {\n      console.time(\x27execute\x27);\n      const data = await asyncFunc(...args);\n      this.emit(\x27data\x27, data);\n      console.timeEnd(\x27execute\x27);\n      this.emit(\x27end\x27);\n    } catch(err) {\n      this.emit(\x27error\x27, err);\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWithTime\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e execute(asyncFunc, ...args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27begin\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e asyncFunc(...args);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, data);\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我认为这段代码比之前的回调风格的代码以及使用 .then\/.catch 风格的代码更具可读性。async\/await 让我们更加接近 JavaScript 语言本身（不必再使用 .then\/.catch 这些 api）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e事件参数和错误\x3c\/h2\x3e\n\x3cp\x3e在之前的例子中，有两个事件被发出时还携带了别的参数。\x3c\/p\x3e\n\x3cp\x3eerror 事件被触发时会携带一个 error 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.emit(\x27error\x27, err);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edata 事件被触发时会携带一个 data 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.emit(\x27data\x27, data);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, data);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以在 emit 函数中不断的添加参数，当然第一个参数一定是事件的名称，除去第一个参数之外的所有参数都可以在该事件注册的监听器中使用。\x3c\/p\x3e\n\x3cp\x3e例如，要处理 data 事件，我们注册的监听器函数将访问传递给 emit 函数的 data 参数，而这个 data 也正是由 asyncFunc 返回的数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22withTime.on(\x27data\x27, (data) =\x3e {\n  \/\/ do something with data\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3ewithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, (data) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something with data\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eerror 事件比较特殊。在我们基于回调的那个示例中，如果不使用监听器处理 error 事件，node 进程将会退出。\x3c\/p\x3e\n\x3cp\x3e举个由于错误使用参数而造成程序崩溃的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class WithTime extends EventEmitter {\n  execute(asyncFunc, ...args) {\n    console.time(\x27execute\x27);\n    asyncFunc(...args, (err, data) =\x3e {\n      if (err) {\n        return this.emit(\x27error\x27, err); \/\/ Not Handled\n      }\n\n      console.timeEnd(\x27execute\x27);\n    });\n  }\n}\n\nconst withTime = new WithTime();\n\nwithTime.execute(fs.readFile, \x27\x27); \/\/ BAD CALL\nwithTime.execute(fs.readFile, __filename);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWithTime\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEventEmitter\x3c\/span\x3e \x3c\/span\x3e{\n  execute(asyncFunc, ...args) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n    asyncFunc(...args, (err, data) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, err); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Not Handled\x3c\/span\x3e\n      }\n\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27execute\x27\x3c\/span\x3e);\n    });\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e withTime = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WithTime();\n\nwithTime.execute(fs.readFile, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ BAD CALL\x3c\/span\x3e\nwithTime.execute(fs.readFile, __filename);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第一次调用 execute 将会触发 error 事件，由于没有处理 error ，Node 程序随之崩溃：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22events.js:163\n      throw er; \/\/ Unhandled \x27error\x27 event\n      ^\nError: ENOENT: no such file or directory, open \x27\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs subunit\x22\x3e\x3ccode class=\x22log\x22\x3eevents.js:163\n      throw er; \/\/ Unhandled \x27error\x27 event\n      ^\n\x3cspan class=\x22hljs-keyword\x22\x3eError: \x3c\/span\x3eENOENT: no such file or directory, open \x27\x27\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二次执行调用将受到此崩溃的影响，并且可能根本不会被执行。\x3c\/p\x3e\n\x3cp\x3e如果我们为这个 error 事件注册一个监听器函数来处理 error，结果将大不相同：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22withTime.on(\x27error\x27, (err) =\x3e {\n  \/\/ do something with err, for example log it somewhere\n  console.log(err)\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3ewithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, (err) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something with err, for example log it somewhere\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们执行上述操作，将会报告第一次执行 execute 时发送的错误，但是这次 node 进程不会崩溃退出，其他程序的调用也都能正常完成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{ Error: ENOENT: no such file or directory, open \x27\x27 errno: -2, code: \x27ENOENT\x27, syscall: \x27open\x27, path: \x27\x27 }\nexecute: 4.276ms\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode class=\x22log\x22\x3e{ \x3cspan class=\x22hljs-string\x22\x3eError:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eENOENT:\x3c\/span\x3e no such file or directory, open \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eerrno:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3ecode:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27ENOENT\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3esyscall:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27open\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3epath:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e }\n\x3cspan class=\x22hljs-string\x22\x3eexecute:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4.276\x3c\/span\x3ems\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，基于 Promise 的函数有些不同，它们暂时只是输出一个警告:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: ENOENT: no such file or directory, open \x27\x27\n\nDeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs http\x22\x3e\x3ccode class=\x22log\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3eUnhandledPromiseRejectionWarning\x3c\/span\x3e: Unhandled promise rejection (rejection id: 1): Error: ENOENT: no such file or directory, open \x27\x27\n\n\x3cspan class=\x22awk\x22\x3eDeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero \x3cspan class=\x22hljs-keyword\x22\x3eexit\x3c\/span\x3e code.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另一种处理异常的方式是在监听全局的 uncaughtException 进程事件。 然而，使用该事件全局捕获错误并不是一个好办法。\x3c\/p\x3e\n\x3cp\x3e关于 uncaughtException，一般都会建议你避免使用它，但是如果必须用它，你应该让进程退出：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.on(\x27uncaughtException\x27, (err) =\x3e {\n  \/\/ something went unhandled.\n  \/\/ Do any cleanup and exit anyway!\n\n  console.error(err); \/\/ don\x27t do just that.\n\n  \/\/ FORCE exit the process too.\n  process.exit(1);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3eprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27uncaughtException\x27\x3c\/span\x3e, (err) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ something went unhandled.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do any cleanup and exit anyway!\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ don\x27t do just that.\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ FORCE exit the process too.\x3c\/span\x3e\n  process.exit(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，假设在同一时间发生多个错误事件，这意味着上面的 uncaughtException 监听器将被多次触发，这可能会引起一些问题。\x3c\/p\x3e\n\x3cp\x3eEventEmitter 模块暴露了 once 方法，这个方法发出的信号只会调用一次监听器。所以，这个方法常与 uncaughtException 一起使用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e监听器的顺序\x3c\/h2\x3e\n\x3cp\x3e如果针对一个事件注册多个监听器函数，当事件被触发时，这些监听器函数将按其注册的顺序被触发。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ first\nwithTime.on(\x27data\x27, (data) =\x3e {\n  console.log(`Length: ${data.length}`);\n});\n\n\/\/ second\nwithTime.on(\x27data\x27, (data) =\x3e {\n  console.log(`Characters: ${data.toString().length}`);\n});\n\nwithTime.execute(fs.readFile, __filename);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ first\x3c\/span\x3e\nwithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, (data) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Length: \x3cspan class=\x22hljs-subst\x22\x3e${data.length}\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ second\x3c\/span\x3e\nwithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, (data) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Characters: \x3cspan class=\x22hljs-subst\x22\x3e${data.toString().length}\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\nwithTime.execute(fs.readFile, __filename);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码会先输出 Length 信息，再输出 Characters 信息，执行的顺序与注册的顺序保持一致。\x3c\/p\x3e\n\x3cp\x3e如果你想定义一个新的监听函数，但是希望它能够第一个被执行，你还可以使用 prependListener 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22withTime.on(\x27data\x27, (data) =\x3e {\n  console.log(`Length: ${data.length}`);\n});\n\nwithTime.prependListener(\x27data\x27, (data) =\x3e {\n  console.log(`Characters: ${data.toString().length}`);\n});\n\nwithTime.execute(fs.readFile, __filename);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3ewithTime.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, (data) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Length: \x3cspan class=\x22hljs-subst\x22\x3e${data.length}\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\nwithTime.prependListener(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, (data) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Characters: \x3cspan class=\x22hljs-subst\x22\x3e${data.toString().length}\x3c\/span\x3e`\x3c\/span\x3e);\n});\n\nwithTime.execute(fs.readFile, __filename);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中，Charaters 信息将首先被输出。\x3c\/p\x3e\n\x3cp\x3e最后，你可以用 removeListener 函数来删除某个监听器函数。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译]理解 Node.js 事件驱动机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010680130">https://segmentfault.com/a/1190000010680130</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xfpigx9aa3l/" target="_blank">https://alili.tech/archive/xfpigx9aa3l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>