<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React16.2的fiber架构"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React16.2的fiber架构 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xhbpeeac4hq/",
				"appid": "1613049289050283", 
				"title": "React16.2的fiber架构 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-15T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ky4yutdvzzc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/j90m1zq86oc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&text=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&text=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&title=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&is_video=false&description=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&title=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&title=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&title=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxhbpeeac4hq%2f&title=React16.2%e7%9a%84fiber%e6%9e%b6%e6%9e%84"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React16.2的fiber架构</h1><div class="meta"><div class="postdate"><time datetime="2018-12-15" itemprop="datePublished">2018-12-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact16真是一天一改，如果现在不看，以后也很难看懂了。\x3c\/p\x3e\n\x3cp\x3e在React16中，虽然也是通过JSX编译得到一个虚拟DOM对象，但对这些虚拟DOM对象的再加工则是经过翻天覆地的变化。我们需要追根溯底，看它是怎么一步步转换过来的。我们先不看什么组件render，先找到ReactDOM.render。在ReactDOM的源码里，有三个类似的东西：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\/\/ https:\/\/github.com\/RubyLouvre\/anu 欢迎加star\n\nReactDOM= {\n hydrate: function (element, container, callback) {\n    \/\/新API，代替render\n    return renderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    \/\/React15的重要API，逐渐退出舞台\n    return renderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    \/\/用于生成子树，废弃\n    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/github.com\/RubyLouvre\/anu 欢迎加star\x3c\/span\x3e\n\nReactDOM= {\n \x3cspan class=\x22hljs-attr\x22\x3ehydrate\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eelement, container, callback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/新API，代替render\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e renderSubtreeIntoContainer(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, element, container, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, callback);\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eelement, container, callback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/React15的重要API，逐渐退出舞台\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e renderSubtreeIntoContainer(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, element, container, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, callback);\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eunstable_renderSubtreeIntoContainer\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentComponent, element, containerNode, callback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于生成子树，废弃\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e renderSubtreeIntoContainer(parentComponent, element, containerNode, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, callback);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们看renderSubtreeIntoContainer，这是一个内部API\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\nfunction renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n\n  var root = container._reactRootContainer;\n  if (!root) {\n    \/\/如果是第一次对这个元素进行渲染，那么它会清空元素的内部\n    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    \/\/ First clear any existing content.\n    if (!shouldHydrate) {\n      var warned = false;\n      var rootSibling = void 0;\n      while (rootSibling = container.lastChild) {\n        container.removeChild(rootSibling);\n      }\n    }\n\n    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n    \/\/创建一个HostRoot对象，是Fiber对象的一种\n    root = container._reactRootContainer = newRoot;\n    \n    \/\/ Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n     \/\/对newRoot对象进行更新\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } else {\n    \/\/对root对象进行更新\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  return DOMRenderer.getPublicRootInstance(root);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderSubtreeIntoContainer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparentComponent, children, container, forceHydrate, callback\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root = container._reactRootContainer;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!root) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是第一次对这个元素进行渲染，那么它会清空元素的内部\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ First clear any existing content.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!shouldHydrate) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e warned = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rootSibling = \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (rootSibling = container.lastChild) {\n        container.removeChild(rootSibling);\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建一个HostRoot对象，是Fiber对象的一种\x3c\/span\x3e\n    root = container._reactRootContainer = newRoot;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Initial mount should not be batched.\x3c\/span\x3e\n    DOMRenderer.unbatchedUpdates(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/对newRoot对象进行更新\x3c\/span\x3e\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/对root对象进行更新\x3c\/span\x3e\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e DOMRenderer.getPublicRootInstance(root);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看一下DOMRenderer.createContainer是怎么创建root对象的。\x3c\/p\x3e\n\x3cp\x3e首先DOMRenderer这个对象是由一个叫reactReconciler的方法生成，需要传入一个对象，将一些东西注进去。最后产生一个对象，里面就有createContainer这个方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ containerInfo就是ReactDOM.render(\x3cdiv\/\x3e, containerInfo)的第二个对象，换言之是一个元素节点\ncreateContainer: function (containerInfo, hydrate) {\n   return createFiberRoot(containerInfo, hydrate);\n},\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ containerInfo就是ReactDOM.render(\x26lt;div\/\x26gt;, containerInfo)的第二个对象，换言之是一个元素节点\x3c\/span\x3e\ncreateContainer: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3econtainerInfo, hydrate\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createFiberRoot(containerInfo, hydrate);\n},\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再看createFiberRoot是怎么将一个真实DOM变成一个Fiber对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  \/\/ Cyclic construction. This cheats the type system right now because\n  \/\/ stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nvar createFiber = function (tag, key, internalContextTag) {\n  return new FiberNode(tag, key, internalContextTag);\n};\n\n\nfunction FiberNode(tag, key, internalContextTag) {\n  \/\/ Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  \/\/ Fiber\n  this[\x27return\x27] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  \/\/ Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFiberRoot\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtainerInfo, hydrate\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Cyclic construction. This cheats the type system right now because\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stateNode is any.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e uninitializedFiber = createHostRootFiber();\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root = {\n    \x3cspan class=\x22hljs-attr\x22\x3ecurrent\x3c\/span\x3e: uninitializedFiber,\n    \x3cspan class=\x22hljs-attr\x22\x3econtainerInfo\x3c\/span\x3e: containerInfo,\n    \x3cspan class=\x22hljs-attr\x22\x3ependingChildren\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eremainingExpirationTime\x3c\/span\x3e: NoWork,\n    \x3cspan class=\x22hljs-attr\x22\x3eisReadyForCommit\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efinishedWork\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ependingContext\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ehydrate\x3c\/span\x3e: hydrate,\n    \x3cspan class=\x22hljs-attr\x22\x3enextScheduledRoot\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n  };\n  uninitializedFiber.stateNode = root;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e root;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateHostRootFiber\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fiber = createFiber(HostRoot, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, NoContext);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fiber;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e createFiber = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etag, key, internalContextTag\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FiberNode(tag, key, internalContextTag);\n};\n\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFiberNode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etag, key, internalContextTag\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instance\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tag = tag;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key = key;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.stateNode = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Fiber\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[\x3cspan class=\x22hljs-string\x22\x3e\x27return\x27\x3c\/span\x3e] = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.child = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sibling = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ref = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pendingProps = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.memoizedProps = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.updateQueue = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.memoizedState = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.internalContextTag = internalContextTag;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Effects\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.effectTag = NoEffect;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nextEffect = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.firstEffect = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lastEffect = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expirationTime = NoWork;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alternate = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有Fiber对象都是FiberNode的实例，它有许多种类型，通过tag来标识。\x3c\/p\x3e\n\x3cp\x3e内部有许多方法来生成Fiber对象\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ecreateFiberFromElement (type为类，无状态函数，元素标签名)\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromFragment （type为React.Fragment）\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromText (在JSX中表现为字符串，数字)\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromHostInstanceForDeletion\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromCall\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromReturn\x3c\/li\x3e\n\x3cli\x3ecreateFiberFromPortal （createPortal就会产生该类型）\x3c\/li\x3e\n\x3cli\x3ecreateFiberRoot （用于ReactDOM.render的根节点）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3ecreateFiberRoot就是创建了一个普通对象，里面有一个current属性引用fiber对象，有一个containerInfo属性引用刚才的DOM节点，然后fiber对象有一个stateNode引用刚才的普通对象。在React15中，stateNode应该是一个组件实例或真实DOM，可能单纯是为了对齐，就创建一个普通对象。 最后返回普通对象。\x3c\/p\x3e\n\x3cp\x3e我们先不看 DOMRenderer.unbatchedUpdates，直接看DOMRenderer.updateContainer。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/children就是ReactDOM的第一个参数，children通常表示一个数组，但是现在它泛指各种虚拟DOM了，第二个对象就是刚才提到的普通对象，我们可以称它为根组件，parentComponent为之前的根组件，现在它为null\n DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/children就是ReactDOM的第一个参数，children通常表示一个数组，但是现在它泛指各种虚拟DOM了，第二个对象就是刚才提到的普通对象，我们可以称它为根组件，parentComponent为之前的根组件，现在它为null\x3c\/span\x3e\n DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eupdateContainer的源码也很简单，就是获得上下文对象，决定它是叫context还是pendingContext，最后丢给scheduleTopLevelUpdate\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\n updateContainer: function (element, container, parentComponent, callback) {\n      var current = container.current;\/\/createFiberRoot中创建的fiber对象\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n      \/\/ 原传名为 children, newRoot, parentComponent, callback\n      \/\/ newRoot.fiber, children, callback\n      scheduleTopLevelUpdate(current, element, callback);\n    },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n updateContainer: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eelement, container, parentComponent, callback\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e current = container.current;\x3cspan class=\x22hljs-comment\x22\x3e\/\/createFiberRoot中创建的fiber对象\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e context = getContextForSubtree(parentComponent);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (container.context === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        container.context = context;\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        container.pendingContext = context;\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原传名为 children, newRoot, parentComponent, callback\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ newRoot.fiber, children, callback\x3c\/span\x3e\n      scheduleTopLevelUpdate(current, element, callback);\n    },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetContextForSubtree的实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject_1;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\/\/isContextConsumer与isContextProvider是两个全新的概念，\n\/\/ 从原上下文中抽取一部分出来\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent \x26amp;\x26amp; fiber.type.contextTypes != null;\n}\n\/\/isContextProvider,产生一个新的上下文\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent \x26amp;\x26amp; fiber.type.childContextTypes != null;\n}\n\nfunction _processChildContext(currentContext) {\n    var Component = this._currentElement.type;\n    var inst = this._instance;\n    var childContext;\n    if (inst.getChildContext) {\n       childContext = inst.getChildContext();\n    }\n    \n    if (childContext) {\n        return _assign({}, currentContext, childContext);\n    }\n    return currentContext;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n \n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node[\x27return\x27];\n    node = parent;\n  }\n  return node.stateNode.context;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetContextForSubtree\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparentComponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!parentComponent) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e emptyObject_1;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fiber = get(parentComponent);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parentContext = findCurrentUnmaskedContext(fiber);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/isContextConsumer与isContextProvider是两个全新的概念，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从原上下文中抽取一部分出来\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisContextConsumer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiber\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fiber.tag === ClassComponent \x26amp;\x26amp; fiber.type.contextTypes != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/isContextProvider,产生一个新的上下文\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisContextProvider\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiber\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fiber.tag === ClassComponent \x26amp;\x26amp; fiber.type.childContextTypes != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_processChildContext\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecurrentContext\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Component = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._currentElement.type;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inst = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._instance;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e childContext;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inst.getChildContext) {\n       childContext = inst.getChildContext();\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childContext) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _assign({}, currentContext, childContext);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e currentContext;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efindCurrentUnmaskedContext\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiber\x3c\/span\x3e) \x3c\/span\x3e{\n \n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e node = fiber;\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (node.tag !== HostRoot) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isContextProvider(node)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parent = node[\x3cspan class=\x22hljs-string\x22\x3e\x27return\x27\x3c\/span\x3e];\n    node = parent;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e node.stateNode.context;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为我们的parentComponent一开始不存在，于是返回一个空对象。注意，这个空对象是重复使用的，不是每次返回一个新的空对象，这是一个很好的优化。\x3c\/p\x3e\n\x3cp\x3escheduleTopLevelUpdate是将用户的传参封装成一个update对象, update对象有partialState对象，它就是相当于React15中 的setState的第一个state传参。但现在partialState中竟然把children放进去了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\nfunction scheduleTopLevelUpdate(current, element, callback) {\n    \/\/ \/\/ newRoot.fiber, children, callback\n\n    callback = callback === undefined ? null : callback;\n    var expirationTime = void 0;\n    \/\/ Check if the top-level element is an async wrapper component. If so,\n    \/\/ treat updates to the root as async. This is a bit weird but lets us\n    \/\/ avoid a separate `renderAsync` API.\n    if (enableAsyncSubtreeAPI \x26amp;\x26amp; element != null \x26amp;\x26amp; element.type != null \x26amp;\x26amp; element.type.prototype != null \x26amp;\x26amp; element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\/\/计算过时时间\n    }\n\n    var update = {\n      expirationTime: expirationTime,\/\/过时时间\n      partialState: { element: element },\/\/!!!!神奇\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\/\/创建一个列队\n    scheduleWork(current, expirationTime);\/\/执行列队\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3escheduleTopLevelUpdate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecurrent, element, callback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/\/ newRoot.fiber, children, callback\x3c\/span\x3e\n\n    callback = callback === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : callback;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e expirationTime = \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Check if the top-level element is an async wrapper component. If so,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ treat updates to the root as async. This is a bit weird but lets us\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoid a separate `renderAsync` API.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (enableAsyncSubtreeAPI \x26amp;\x26amp; element != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; element.type != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; element.type.prototype != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; element.type.prototype.unstable_isAsyncReactComponent === \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n      expirationTime = computeAsyncExpiration();\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      expirationTime = computeExpirationForFiber(current);\x3cspan class=\x22hljs-comment\x22\x3e\/\/计算过时时间\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e update = {\n      \x3cspan class=\x22hljs-attr\x22\x3eexpirationTime\x3c\/span\x3e: expirationTime,\x3cspan class=\x22hljs-comment\x22\x3e\/\/过时时间\x3c\/span\x3e\n      partialState: { \x3cspan class=\x22hljs-attr\x22\x3eelement\x3c\/span\x3e: element },\x3cspan class=\x22hljs-comment\x22\x3e\/\/!!!!神奇\x3c\/span\x3e\n      callback: callback,\n      \x3cspan class=\x22hljs-attr\x22\x3eisReplace\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eisForced\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3enextCallback\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    };\n    insertUpdateIntoFiber(current, update);\x3cspan class=\x22hljs-comment\x22\x3e\/\/创建一个列队\x3c\/span\x3e\n    scheduleWork(current, expirationTime);\x3cspan class=\x22hljs-comment\x22\x3e\/\/执行列队\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e列队是一个链表\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\/\/ https:\/\/github.com\/RubyLouvre\/anu 欢迎加star\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  \/\/ We\x27ll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    \/\/ TODO: We don\x27t know what the base state will be until we begin work.\n    \/\/ It depends on which fiber is the next current. Initialize with an empty\n    \/\/ base state, then set to the memoizedState when rendering. Not super\n    \/\/ happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  \/\/ If there\x27s only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  \/\/ If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  \/\/ If both lists are not empty, the last update is the same for both lists\n  \/\/ because of structural sharing. So, we should only append to one of\n  \/\/ the lists.\n  insertUpdateIntoQueue(queue1, update);\n  \/\/ But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  \/\/ Append the update to the end of the list.\n  if (queue.last === null) {\n    \/\/ Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime \x3e update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/github.com\/RubyLouvre\/anu 欢迎加star\x3c\/span\x3e\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We\x27ll have at least one and at most two distinct update queues.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e alternateFiber = fiber.alternate;\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e queue1 = fiber.updateQueue;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (queue1 === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e We don\x27t know what the base state will be until we begin work.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ It depends on which fiber is the next current. Initialize with an empty\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ base state, then set to the memoizedState when rendering. Not super\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ happy with this approach.\x3c\/span\x3e\n    queue1 = fiber.updateQueue = createUpdateQueue(\x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e queue2 = \x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (alternateFiber !== \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n    queue2 = alternateFiber.updateQueue;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (queue2 === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(\x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e);\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    queue2 = \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If there\x27s only one queue, add the update to that queue and exit.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (queue2 === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n    insertUpdateIntoQueue(queue1, update);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If either queue is empty, we need to add to both queues.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (queue1.last === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e || queue2.last === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If both lists are not empty, the last update is the same for both lists\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ because of structural sharing. So, we should only append to one of\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the lists.\x3c\/span\x3e\n  insertUpdateIntoQueue(queue1, update);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ But we still need to update the `last` pointer of queue2.\x3c\/span\x3e\n  queue2.last = update;\n}\n\nfunction insertUpdateIntoQueue(\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e, update) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Append the update to the end of the list.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.last === \x3cspan class=\x22hljs-built_in\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Queue is empty\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.first = \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.last = update;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.last.next = update;\n    \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.last = update;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.expirationTime === NoWork || \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.expirationTime \x26gt; update.expirationTime) {\n    \x3cspan class=\x22hljs-built_in\x22\x3equeue\x3c\/span\x3e.expirationTime = update.expirationTime;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3escheduleWork是执行虚拟DOM（fiber树）的更新。 scheduleWork，requestWork, performWork是三部曲。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\n\nfunction scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function checkRootNeedsClearing(root, fiber, expirationTime) {\n    if (!isWorking \x26amp;\x26amp; root === nextRoot \x26amp;\x26amp; expirationTime \x3c nextRenderExpirationTime) {\n      \/\/ Restart the root from the top.\n      if (nextUnitOfWork !== null) {\n        \/\/ This is an interruption. (Used for performance tracking.)\n        interruptedBy = fiber;\n      }\n      nextRoot = null;\n      nextUnitOfWork = null;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n\n    var node = fiber;\n    while (node !== null) {\n      \/\/ Walk the parent path to the root and update each node\x27s\n      \/\/ expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime \x3e expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime \x3e expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node[\x27return\x27] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n\n          return;\n        }\n      }\n      node = node[\x27return\x27];\n    }\n  }\n\n\nfunction requestWork(root, expirationTime) {\n    if (nestedUpdateCount \x3e NESTED_UPDATE_LIMIT) {\n      invariant_1(false, \x27Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\x27);\n    }\n\n    \/\/ Add the root to the schedule.\n    \/\/ Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      \/\/ This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      \/\/ This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime \x3c remainingExpirationTime) {\n        \/\/ Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      \/\/ Prevent reentrancy. Remaining work will be scheduled at the end of\n      \/\/ the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      \/\/ Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        \/\/ unless we\x27re inside unbatchedUpdates, in which case we should\n        \/\/ flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n      return;\n    }\n\n    \/\/ TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    \/\/ Keep working on roots until there\x27s no more work, or until the we reach\n    \/\/ the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI \x26amp;\x26amp; deadline !== null) {\n      var didExpire = nextFlushedExpirationTime \x3c recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (nextFlushedRoot !== null \x26amp;\x26amp; nextFlushedExpirationTime !== NoWork \x26amp;\x26amp; (minExpirationTime === NoWork || nextFlushedExpirationTime \x3c= minExpirationTime) \x26amp;\x26amp; !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      \/\/ Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    \/\/ We\x27re done flushing work. Either we ran out of time in this callback,\n    \/\/ or there\x27s no more work left with sufficient priority.\n\n    \/\/ If we\x27re inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    \/\/ If there\x27s work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    \/\/ Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\nfunction performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant_1(false, \x27performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\n\n    isRendering = true;\n\n    \/\/ Check if this is async work or sync\/expired work.\n    \/\/ TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime \x3c= recalculateCurrentTime()) {\n      \/\/ Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        \/\/ This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          \/\/ We\x27ve completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      \/\/ Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        \/\/ This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          \/\/ We\x27ve completed the root. Check the deadline one more time\n          \/\/ before committing.\n          if (!shouldYield()) {\n            \/\/ Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            \/\/ There\x27s no time left. Mark this root as complete. We\x27ll come\n            \/\/ back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n   isRendering = false;\n}\n\/\/用于调整渲染顺序，高优先级的组件先执行\nfunction findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          \/\/ This root no longer has work. Remove it from the scheduler.\n\n          \/\/ TODO: This check is redudant, but Flow is confused by the branch\n          \/\/ below where we set lastScheduledRoot to null, even though we break\n          \/\/ from the loop right after.\n          !(previousScheduledRoot !== null \x26amp;\x26amp; lastScheduledRoot !== null) ? invariant_1(false, \x27Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\n          if (root === root.nextScheduledRoot) {\n            \/\/ This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            \/\/ This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            \/\/ This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime \x3c highestPriorityWork) {\n            \/\/ Update the priority, if it\x27s higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    \/\/ If the next root is the same as the previous root, this is a nested\n    \/\/ update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null \x26amp;\x26amp; previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount\x2b\x2b;\n    } else {\n      \/\/ Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode class=\x22javasript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/by 司徒正美， 加群：370262116 一起研究React与anujs\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3escheduleWork\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fiber, expirationTime)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e scheduleWorkImpl(fiber, expirationTime, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckRootNeedsClearing\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(root, fiber, expirationTime)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isWorking \x26amp;\x26amp; root === nextRoot \x26amp;\x26amp; expirationTime \x26lt; nextRenderExpirationTime) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Restart the root from the top.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextUnitOfWork !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is an interruption. (Used for performance tracking.)\x3c\/span\x3e\n        interruptedBy = fiber;\n      }\n      nextRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      nextUnitOfWork = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3escheduleWorkImpl\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(fiber, expirationTime, isErrorRecovery)\x3c\/span\x3e \x3c\/span\x3e{\n    recordScheduleUpdate();\n\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e node = fiber;\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (node !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Walk the parent path to the root and update each node\x27s\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ expiration time.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.expirationTime === NoWork || node.expirationTime \x26gt; expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.alternate !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.alternate.expirationTime === NoWork || node.alternate.expirationTime \x26gt; expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node[\x3cspan class=\x22hljs-string\x22\x3e\x27return\x27\x3c\/span\x3e] === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.tag === HostRoot) {\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n      }\n      node = node[\x3cspan class=\x22hljs-string\x22\x3e\x27return\x27\x3c\/span\x3e];\n    }\n  }\n\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erequestWork\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(root, expirationTime)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nestedUpdateCount \x26gt; NESTED_UPDATE_LIMIT) {\n      invariant_1(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\x27\x3c\/span\x3e);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Add the root to the schedule.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Check if this root is already part of the schedule.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root.nextScheduledRoot === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This root is not already scheduled. Add it.\x3c\/span\x3e\n      root.remainingExpirationTime = expirationTime;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lastScheduledRoot === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This root is already scheduled, but its priority may have increased.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e remainingExpirationTime = root.remainingExpirationTime;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (remainingExpirationTime === NoWork || expirationTime \x26lt; remainingExpirationTime) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Update the priority.\x3c\/span\x3e\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isRendering) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Prevent reentrancy. Remaining work will be scheduled at the end of\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the currently rendering batch.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isBatchingUpdates) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flush work at the end of the batch.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUnbatchingUpdates) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ unless we\x27re inside unbatchedUpdates, in which case we should\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ flush it now.\x3c\/span\x3e\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e Get rid of Sync and use current time?\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (expirationTime === Sync) {\n      performWork(Sync, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eperformWork\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(minExpirationTime, dl)\x3c\/span\x3e \x3c\/span\x3e{\n    deadline = dl;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Keep working on roots until there\x27s no more work, or until the we reach\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the deadline.\x3c\/span\x3e\n    findHighestPriorityRoot();\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (enableUserTimingAPI \x26amp;\x26amp; deadline !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e didExpire = nextFlushedExpirationTime \x26lt; recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (nextFlushedRoot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; nextFlushedExpirationTime !== NoWork \x26amp;\x26amp; (minExpirationTime === NoWork || nextFlushedExpirationTime \x26lt;= minExpirationTime) \x26amp;\x26amp; !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Find the next highest priority work.\x3c\/span\x3e\n      findHighestPriorityRoot();\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We\x27re done flushing work. Either we ran out of time in this callback,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ or there\x27s no more work left with sufficient priority.\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If we\x27re inside a callback, set this to false since we just completed it.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (deadline !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      callbackExpirationTime = NoWork;\n      callbackID = \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If there\x27s work left over, schedule a new callback.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Clean-up.\x3c\/span\x3e\n    deadline = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    deadlineDidExpire = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    nestedUpdateCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasUnhandledError) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _error4 = unhandledError;\n      unhandledError = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      hasUnhandledError = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e _error4;\n    }\n  }\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eperformWorkOnRoot\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(root, expirationTime)\x3c\/span\x3e \x3c\/span\x3e{\n    !!isRendering ? invariant_1(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.\x27\x3c\/span\x3e) : \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n    isRendering = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Check if this is async work or sync\/expired work.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e Pass current time as argument to renderRoot, commitRoot\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (expirationTime \x26lt;= recalculateCurrentTime()) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flush sync work.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e finishedWork = root.finishedWork;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (finishedWork !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This root is already complete. We can commit it.\x3c\/span\x3e\n        root.finishedWork = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        root.finishedWork = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        finishedWork = renderRoot(root, expirationTime);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (finishedWork !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We\x27ve completed the root. Commit it.\x3c\/span\x3e\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flush async work.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _finishedWork = root.finishedWork;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_finishedWork !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This root is already complete. We can commit it.\x3c\/span\x3e\n        root.finishedWork = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        root.finishedWork = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        _finishedWork = renderRoot(root, expirationTime);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_finishedWork !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ We\x27ve completed the root. Check the deadline one more time\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ before committing.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!shouldYield()) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Still time left. Commit the root.\x3c\/span\x3e\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ There\x27s no time left. Mark this root as complete. We\x27ll come\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ back and commit it later.\x3c\/span\x3e\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n   isRendering = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/用于调整渲染顺序，高优先级的组件先执行\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efindHighestPriorityRoot\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e highestPriorityWork = NoWork;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e highestPriorityRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lastScheduledRoot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e previousScheduledRoot = lastScheduledRoot;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e root = firstScheduledRoot;\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (root !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e remainingExpirationTime = root.remainingExpirationTime;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (remainingExpirationTime === NoWork) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This root no longer has work. Remove it from the scheduler.\x3c\/span\x3e\n\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e This check is redudant, but Flow is confused by the branch\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ below where we set lastScheduledRoot to null, even though we break\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ from the loop right after.\x3c\/span\x3e\n          !(previousScheduledRoot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; lastScheduledRoot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) ? invariant_1(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.\x27\x3c\/span\x3e) : \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root === root.nextScheduledRoot) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is the only root in the list.\x3c\/span\x3e\n            root.nextScheduledRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            firstScheduledRoot = lastScheduledRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root === firstScheduledRoot) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is the first root in the list.\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root === lastScheduledRoot) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is the last root in the list.\x3c\/span\x3e\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (highestPriorityWork === NoWork || remainingExpirationTime \x26lt; highestPriorityWork) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Update the priority, if it\x27s higher\x3c\/span\x3e\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (root === lastScheduledRoot) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If the next root is the same as the previous root, this is a nested\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update. To prevent an infinite loop, increment the nested update count.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e previousFlushedRoot = nextFlushedRoot;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (previousFlushedRoot !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount\x2b\x2b;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Reset whenever we switch roots.\x3c\/span\x3e\n      nestedUpdateCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这只是一部分更新逻辑， 简直没完没了，下次继续,添上流程图，回忆一下本文学到的东西\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV3bdq?w=736\x26amp;h=746\x22 src=\x22https:\/\/static.alili.tech\/img\/bV3bdq?w=736\x26amp;h=746\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React16.2的fiber架构</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013109071">https://segmentfault.com/a/1190000013109071</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xhbpeeac4hq/" target="_blank">https://alili.tech/archive/xhbpeeac4hq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>