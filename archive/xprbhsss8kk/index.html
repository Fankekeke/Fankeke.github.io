<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="流的剖析和实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>流的剖析和实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xprbhsss8kk/",
				"appid": "1613049289050283", 
				"title": "流的剖析和实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-15T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/co8412hx51k/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1sji2bsj533/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&text=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&text=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&title=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&is_video=false&description=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&title=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&title=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&title=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxprbhsss8kk%2f&title=%e6%b5%81%e7%9a%84%e5%89%96%e6%9e%90%e5%92%8c%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">流的剖析和实现</h1><div class="meta"><div class="postdate"><time datetime="2018-12-15" itemprop="datePublished">2018-12-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e流的定义\x3c\/h2\x3e\n\x3cp\x3e流是抽象化的概念,形象生动的描述了数据的流动、变化。 \x3cbr\x3e具体来说,在node中流是处理数据的抽象接口,继承了EventEmitter,通过这个接口我们能够控制流的开关,流动的方向等等。\x3cbr\x3e比较形象直观一点类似我们在linux上使用shell,通过管道,链接处理各个部分,下面是我写的一个命令,筛选出version并导出到文件中。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013100938?w=1492\x26amp;h=158\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013100938?w=1492\x26amp;h=158\x22 alt=\x22stream-linux-jsdt\x22 title=\x22stream-linux-jsdt\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e流的分类\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3eReadable(可读流)\x3c\/li\x3e\n\x3cli\x3eWritable(可写流)\x3c\/li\x3e\n\x3cli\x3eDuplex(可读可写的流)\x3c\/li\x3e\n\x3cli\x3eTransform(在读写过程中可以修改和变化的Duplex流)\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3cp\x3e流按照功能大致划分为以上四类,具体应用的话有很多场景,如下图所示(来源:参考链接2)\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013100939?w=1196\x26amp;h=818\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013100939?w=1196\x26amp;h=818\x22 alt=\x22stream-apply-jsdt\x22 title=\x22stream-apply-jsdt\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e下面我根据流的分类,列举一些demo应用实例\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eReadable\x3c\/h3\x3e\n\x3cp\x3e可读流能接受各种数据源,例如控制台的输入,文件,字符串等等,就如介绍中所说是抽象接口,可以面向各种形式的输入,下面举几个例子。\x3c\/p\x3e\n\x3ch4\x3e文件流\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22require(\x27fs\x27).createReadStream(\x27.\/1.txt\x27,{\n    encoding: \x27utf8\x27\n}).on(\x27data\x27,(data) =\x3e {\n    console.log(data)\n})\n\/\/ 输出  hello jsdt\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e).createReadStream(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,{\n    encoding: \x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e\n}).\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n})\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 输出  hello jsdt\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  为什么要用流来读取,直接用fs.readFile岂不是更方便吗,因为readFile是整体操作,会将文件全部读到内存中在做处理,这样的话文件如果很大,程序就会很卡,甚至报错。\x3c\/p\x3e\n\x3ch4\x3e标准输入流\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.stdin.setEncoding(\x27utf8\x27);\nprocess.stdin.on(\x27data\x27,(data) =\x3e {\n    console.log(\x27输出: \x27\x2b data)\n})\nnode 运行code,然后输入 hello jsdt\n输出: hello jsdt\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3eprocess.stdin.setEncoding(\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e);\nprocess.stdin.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27输出: \x27\x3c\/span\x3e\x2b data)\n})\nnode 运行code,然后输入 hello jsdt\n输出: hello jsdt\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  这个做acm的时候会用到,或者平时自己写一些交互式应用的时候\x3c\/p\x3e\n\x3ch4\x3e普通数据流\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let {Readable} = require(\x27stream\x27)\nlet util = require(\x27util\x27)\nclass Test extends  Readable{\n    constructor(){\n        super()\n        this.dataSource = 5\n    }\n    _read(){\n        if(this.dataSource--\x3e0){\n            this.push(this.dataSource\x2b\x27\x27);\n        }else{\n            this.push(null);\n        }\n    }\n}\nlet counter = new Test();\ncounter.on(\x27data\x27,function(data){\n    console.log(data.toString())\n});\n输出:\n4\n3\n2\n1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e {Readable} = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTest\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e  \x3cspan class=\x22hljs-title\x22\x3eReadable\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dataSource = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n    }\n    _read(){\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dataSource--\x26gt;\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e){\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dataSource\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n        }\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e counter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Test();\ncounter.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data.toString())\n});\n输出:\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 重写_read方法,自定义输入的逻辑,上面示例中是自己逻辑中产生的一个数据源。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eWritable\x3c\/h3\x3e\n\x3ch4\x3e文件流\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let dataSource = \x27hello jsdt\x27,i = 0;\n(function(){\n    let ws = require(\x27fs\x27).createWriteStream(\x27.\/1.txt\x27,{\n        encoding: \x27utf8\x27\n    })\n    let flag = true;\n    while(flag \x26amp;\x26amp; i\x3cdataSource.length){\n        flag = ws.write(dataSource[i\x2b\x2b]\x2b\x27\x27);\n    }\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dataSource = \x3cspan class=\x22hljs-string\x22\x3e\x27hello jsdt\x27\x3c\/span\x3e,i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ws = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e).createWriteStream(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/1.txt\x27\x3c\/span\x3e,{\n        \x3cspan class=\x22hljs-attr\x22\x3eencoding\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e flag = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(flag \x26amp;\x26amp; i\x26lt;dataSource.length){\n        flag = ws.write(dataSource[i\x2b\x2b]\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n    }\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013100940?w=1002\x26amp;h=540\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013100940?w=1002\x26amp;h=540\x22 alt=\x22write-test-jsdt\x22 title=\x22write-test-jsdt\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 闭包自执行,通过流将数据写入到文件中,上面是输出结果。\x3c\/p\x3e\n\x3ch4\x3e自定义输出\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let {Writable} = require(\x27stream\x27)\nlet arr = []\nlet ws = Writable({\n    write(chunk,encoding,cb){\n        arr.push(chunk)\n        cb()\n    }\n})\nfor(let i = 1; i\x3c= 3;i\x2b\x2b){\n  ws.write(\x27\x27\x2bi,\x27utf8\x27,()=\x3e{})\n}\nprocess.nextTick(function () {\n    console.log(arr.toString())\n})\n\/\/  输出 1,2,3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e {Writable} = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e arr = []\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ws = Writable({\n    write(chunk,encoding,cb){\n        arr.push(chunk)\n        cb()\n    }\n})\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i\x26lt;= \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;i\x2b\x2b){\n  ws.write(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\x2bi,\x3cspan class=\x22hljs-string\x22\x3e\x27utf8\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{})\n}\nprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr.toString())\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  输出 1,2,3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  上面重写了流的write方法,可以自定义写逻辑\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eDuplex\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22require(\x27net\x27).createServer(socket =\x3e {\n    socket.on(\x27data\x27,data =\x3e {\n        console.log(\x27client message \x27 \x2b data);\n        socket.write(\x26quot;server message \x26quot; \x2b \x27hello client \x27);\n    })\n}).listen(8080,() =\x3e{})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e).createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3esocket\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    socket.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27client message \x27\x3c\/span\x3e \x2b data);\n        socket.write(\x3cspan class=\x22hljs-string\x22\x3e\x22server message \x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27hello client \x27\x3c\/span\x3e);\n    })\n}).listen(\x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e{})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013100941?w=1706\x26amp;h=236\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013100941?w=1706\x26amp;h=236\x22 alt=\x22duplex-jsdt\x22 title=\x22duplex-jsdt\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cstrong\x3e说明\x3c\/strong\x3e 作为可写流一面socket可以向客户端发送信息,做为可读流一面可以监听data事件,收到客户端发送过信息\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eTransform\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let t = require(\x27stream\x27).Transform({\n    transform(chunk,encoding,cb){\n        this.push(chunk.toString().toUpperCase());\n        cb();\n    }\n});\nprocess.stdin.pipe(t).pipe(process.stdout);\n\/\/ 输入abc\n\/\/ 输出ABC\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3elet t = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e).Transform({\n    transform(chunk,encoding,cb){\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(chunk.toString().toUpperCase());\n        cb();\n    }\n});\n\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdin.pipe(t).pipe(\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdout);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输入abc\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出ABC\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e  上面使用转换流,实现了terminal上小写输入,对应大写输出的功能\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e流中数据分类\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3e二进制模式\x3c\/li\x3e\n\x3cli\x3e对象模式\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在创建流的时候可以指定配置,objectMode默认为false,设为true切换到对象模式。二进制即buffer模式,可读或可写流都会将数据会缓存数据在buffer中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e流的剖析\x3c\/h2\x3e\n\x3cp\x3e通过上面的介绍我们明确了流的定义,并按照功能对流进行了分类,下面我进行下剖析,总的来说流的各种形态间转化传输底层都是二进制,具体到使用形态上有buffer,string等等。\x3cbr\x3e首先详细说下可读流,可读流有两种模式,默认为paused模式。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3eflowing  按照初始化配置,自动读取数据,并通过观察者模式,直接将数据提供给订阅者\x3c\/li\x3e\n\x3cli\x3epaused  显式调用流的read方法读取数据\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3cp\x3e其中如果我们想切换到流动模式可以通过监听data事件的方式、或者调用stream.resume()、stream.pipe() 这些方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e可读流源码分析\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 可读流入口，根据配置返回一个可读流\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\n\/\/ 实现原理是ReadStream.prototype.__proto__ = Readable.prototype,可以继承Readable上的一些方法\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  \/\/ 非new方式调用，直接返回一个实例\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  options = copyObject(getOptions(options, {}));\n  if (options.highWaterMark === undefined)\n  \/\/ highWaterMark默认值为64k，设置了flow模式下缓冲区的大小\n    options.highWaterMark = 64 * 1024;  \n\n  Readable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  \/\/ 文件描述符，根据这个句柄找到文件\n  this.fd = options.fd === undefined ? null : options.fd;\n  \/\/ flags打开文件要做的操作,默认为\x27r\x27\n  this.flags = options.flags === undefined ? \x27r\x27 : options.flags;\n  \/\/ 用于设置文件模式（权限和粘结位），仅限创建文件时。\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  \/\/ 开始读取位置\n  this.start = options.start;\n  \/\/ 结束读取位置（！！！包括结束位置）\n  this.end = options.end;\n  \/**\n   * 如果 autoClose 为 false，则文件描述符不会被关闭，即使有错误。 \n   * 需要程序负责关闭它，并且确保没有文件描述符泄漏。 \n   * 如果 autoClose 被设置为 true（默认），则在 error 或 end 时，文件描述符会被自动关闭\n   *\/\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n   this.pos = this.start;\n   \n  }\n\/\/ 适合传入句柄的情况，例如fd: 0，这样就不是文件，而是控制台输入的数据了\n  if (typeof this.fd !== \x27number\x27)\n    this.open();\n  this.on(\x27end\x27, function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\n\/\/ 打开文件，并触发open事件，只有打开了才能读取,所以在回调中触发open事件,看下步操作\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    self.fd = fd;\n    self.emit(\x27open\x27, fd);\n    \/\/  start the flow of data.\n    self.read();\n  });\n};\nReadable.prototype.read = function(n) {\n    \/\/ 当read(0)时,如果缓存中已有数据,则触发readable事件,相当于刷新下缓存。否则触发end事件\nif (n === 0 \x26amp;\x26amp;\n      state.needReadable \x26amp;\x26amp;\n      (state.length \x3e= state.highWaterMark || state.ended)) {\n    if (state.length === 0 \x26amp;\x26amp; state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n  \/\/  若可读流已经被传入了终止符（null），且缓冲中没有遗留数据，则结束这个可读流\n  if (n === 0 \x26amp;\x26amp; state.ended) {\n      if (state.length === 0)\n        endReadable(this);\n      return null;\n    }\n    \/\/  若目前缓冲中的数据大小为空，或未超过设置的警戒线，则进行一次数据读取。\n      if (state.length === 0 || state.length - n \x3c state.highWaterMark) {\n        doRead = true;\n      }\n        if (state.ended || state.reading) {\n          doRead = false;\n        } else if (doRead) {\n          state.reading = true;\n          state.sync = true;\n          this._read(state.highWaterMark);\n     }\n\n\n}\nReadStream.prototype._read = function(n) {\n  if (typeof this.fd !== \x27number\x27) {\n    \/\/ 防止重复绑定open事件，当文件打开且emit open事件，此时才会进行真正的读操作\n    return this.once(\x27open\x27, function() {\n      this._read(n);\n    });\n  }\n \/\/ 然后读数据的时候会计算实际读的数量\n function howMuchToRead(n, state) {\n    \/\/  如果读的数量超过highWaterMark,则重新计算highWaterMark\n    if (n \x3e state.highWaterMark)\n      state.highWaterMark = computeNewHighWaterMark(n);\n    if (n \x3c= state.length)\n      return n;\n }\n  \/\/ 经过上面一系列的准备工作,下面开始真正的读操作咯\nfs.read(this.fd, pool, pool.used, toRead, this.pos, (er, bytesRead) =\x3e {\n      if (bytesRead \x3e 0) {\n        this.bytesRead \x2b= bytesRead;\n      }\n      this.push(b);\n  });\n};\n\n\/\/ 上面整个过程是paused的流程,其中flow模式又有所不同,如下所示\n\/\/ 如果监听了data事件,则会调用this.resume()，开始流动模式\nReadable.prototype.on = function(ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  if (ev === \x27data\x27) {\n    \/\/  Start flowing on next tick if stream isn\x27t explicitly paused\n    if (this._readableState.flowing !== false)\n      this.resume();\n  }\n  }\n\/\/ flow模式下 流内部自动触发data事件,循环读取数据\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug(\x27flow\x27, state.flowing);\n  while (state.flowing \x26amp;\x26amp; stream.read() !== null);\n}\n\/\/ 然后触发 data事件,循环发射数据\nstream.emit(\x27data\x27, chunk);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可读流入口，根据配置返回一个可读流\x3c\/span\x3e\nfs.createReadStream = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(path, options)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ReadStream(path, options);\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实现原理是ReadStream.prototype.__proto__ = Readable.prototype,可以继承Readable上的一些方法\x3c\/span\x3e\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReadStream\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(path, options)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非new方式调用，直接返回一个实例\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e ReadStream))\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ReadStream(path, options);\n\n  options = copyObject(getOptions(options, {}));\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.highWaterMark === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ highWaterMark默认值为64k，设置了flow模式下缓冲区的大小\x3c\/span\x3e\n    options.highWaterMark = \x3cspan class=\x22hljs-number\x22\x3e64\x3c\/span\x3e * \x3cspan class=\x22hljs-number\x22\x3e1024\x3c\/span\x3e;  \n\n  Readable.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, options);\n\n  handleError((\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path = getPathFromURL(path)));\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件描述符，根据这个句柄找到文件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fd = options.fd === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : options.fd;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ flags打开文件要做的操作,默认为\x27r\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.flags = options.flags === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27r\x27\x3c\/span\x3e : options.flags;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于设置文件模式（权限和粘结位），仅限创建文件时。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mode = options.mode === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3eo666 : options.mode;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始读取位置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start = options.start;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 结束读取位置（！！！包括结束位置）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.end = options.end;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * 如果 autoClose 为 false，则文件描述符不会被关闭，即使有错误。 \n   * 需要程序负责关闭它，并且确保没有文件描述符泄漏。 \n   * 如果 autoClose 被设置为 true（默认），则在 error 或 end 时，文件描述符会被自动关闭\n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.autoClose = options.autoClose === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e : options.autoClose;\n   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pos = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start;\n   \n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 适合传入句柄的情况，例如fd: 0，这样就不是文件，而是控制台输入的数据了\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fd !== \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.open();\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.autoClose) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.destroy();\n    }\n  });\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 打开文件，并触发open事件，只有打开了才能读取,所以在回调中触发open事件,看下步操作\x3c\/span\x3e\nReadStream.prototype.open = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e self = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  fs.open(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.flags, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mode, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(er, fd)\x3c\/span\x3e \x3c\/span\x3e{\n    self.fd = fd;\n    self.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27open\x27\x3c\/span\x3e, fd);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  start the flow of data.\x3c\/span\x3e\n    self.read();\n  });\n};\nReadable.prototype.read = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当read(0)时,如果缓存中已有数据,则触发readable事件,相当于刷新下缓存。否则触发end事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp;\n      state.needReadable \x26amp;\x26amp;\n      (state.length \x26gt;= state.highWaterMark || state.ended)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; state.ended)\n      endReadable(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n      emitReadable(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  若可读流已经被传入了终止符（null），且缓冲中没有遗留数据，则结束这个可读流\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; state.ended) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        endReadable(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  若目前缓冲中的数据大小为空，或未超过设置的警戒线，则进行一次数据读取。\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e || state.length - n \x26lt; state.highWaterMark) {\n        doRead = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.ended || state.reading) {\n          doRead = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (doRead) {\n          state.reading = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n          state.sync = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._read(state.highWaterMark);\n     }\n\n\n}\nReadStream.prototype._read = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fd !== \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 防止重复绑定open事件，当文件打开且emit open事件，此时才会进行真正的读操作\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.once(\x3cspan class=\x22hljs-string\x22\x3e\x27open\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._read(n);\n    });\n  }\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后读数据的时候会计算实际读的数量\x3c\/span\x3e\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehowMuchToRead\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n, state)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  如果读的数量超过highWaterMark,则重新计算highWaterMark\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n \x26gt; state.highWaterMark)\n      state.highWaterMark = computeNewHighWaterMark(n);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n \x26lt;= state.length)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n;\n }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 经过上面一系列的准备工作,下面开始真正的读操作咯\x3c\/span\x3e\nfs.read(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fd, pool, pool.used, toRead, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pos, (er, bytesRead) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (bytesRead \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bytesRead \x2b= bytesRead;\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(b);\n  });\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上面整个过程是paused的流程,其中flow模式又有所不同,如下所示\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果监听了data事件,则会调用this.resume()，开始流动模式\x3c\/span\x3e\nReadable.prototype.on = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(ev, fn)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = Stream.prototype.on.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, ev, fn);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ev === \x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  Start flowing on next tick if stream isn\x27t explicitly paused\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._readableState.flowing !== \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.resume();\n  }\n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ flow模式下 流内部自动触发data事件,循环读取数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eflow\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(stream)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e state = stream._readableState;\n  debug(\x3cspan class=\x22hljs-string\x22\x3e\x27flow\x27\x3c\/span\x3e, state.flowing);\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (state.flowing \x26amp;\x26amp; stream.read() !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后触发 data事件,循环发射数据\x3c\/span\x3e\nstream.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, chunk);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e总结\x3c\/strong\x3e 上面是可读流的源码分析,摘要了关键部分,下面在梳理一下,当通过ReadStream创建一个流的时候,默认会触发readable事件,进入暂停模式,此时内部维护的有一个缓冲区,在readable事件回调逻辑中进行read操作,首先会通过howMuchToRead方法计算实际读取的数量,如果现有数据小于highWaterMark,内部会进行this._read(state.highWaterMark)操作,其回调中会进行push操作,push在调用readableAddChunk将数据放到内部维护的缓存中,反之则从fromList中读取缓存中的数据,然后返回。而如果监听了data事件,代码中所示会调用this.resume()，将流状态设置为flowing模式,然后resume()-\x26gt;resume_()-\x26gt;flow()的调用顺序执行flow方法循环读取数据,触发data事件,完成数据的自动读取,然后发射给调用者,会不停的循环整个过程。上面比较值的注意一点的就是flow模式和paused模式区别,如果是flow模式在addChunk的时候,如下所示\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing \x26amp;\x26amp; state.length === 0 \x26amp;\x26amp; !state.sync) {\n    stream.emit(\x27data\x27, chunk);\n    stream.read(0);\n  } \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction addChunk(stream, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, chunk, addToFront) {\n  if (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.flowing \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; !\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.sync) {\n    stream.emit(\x27data\x27, chunk);\n    stream.read(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  } \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e会自动发射数据,不会走缓存,而paused模式会走一遍内部的缓存机制。\x3cbr\x3e根据上面node源码的分析过程,下面图形化描述下整个流程。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013100942?w=4026\x26amp;h=2644\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013100942?w=4026\x26amp;h=2644\x22 alt=\x22read-stream-jsdt\x22 title=\x22read-stream-jsdt\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e自己实现的一个\x3ca href=\x22https:\/\/github.com\/gcyStar\/High-Performance-JS\/blob\/master\/node\/stream\/readstream.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e可读流\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e可写流源码分析\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 1:首先第一步根据createWriteStream传入参数进行初始化\n\/\/ 2:调用写操作\nWritable.prototype.write = function(chunk, encoding, cb) {\n  if (state.ended)\n   \/\/在end继续写入会emit一个error事件\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n  \/\/在校验数据chunk合法的情况下才会进行后续的写逻辑\n    state.pendingcb\x2b\x2b;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\nreturn ret;\n};\n\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (chunk instanceof Buffer)\n    encoding = \x27buffer\x27;\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length \x2b= len;\/\/实时更新缓冲区长度\n\n  var ret = state.length \x3c state.highWaterMark;\/\/判断缓存区是否超过水位线(highWaterMark,不传默认16k,源码_stream_writeable.js--40行)设置\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n \/\/如果此时处于写状态,将新添加的数据放到缓冲池链表尾部\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount \x2b= 1;\n  } else {\n    \/\/写入数据\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\nreturn ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  if (writev)\n    \/\/一次写入多个数据块\n    stream._writev(chunk, state.onwrite);\n  else\n  \/\/一次写入一个数据块\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwrite(stream, er) {\n    if (!finished \x26amp;\x26amp;\n        !state.corked \x26amp;\x26amp;\n        !state.bufferProcessing \x26amp;\x26amp;\n        state.bufferedRequest) {\n        \/\/清空缓冲池 ,不为空,则循环执行 _write() 写入单个数据块\n      clearBuffer(stream, state);\n    }\n  }\n}\nfunction clearBuffer(stream, state) {\n    \/\/ 单个数据写入\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n        \/\/开启数据写操作\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1:首先第一步根据createWriteStream传入参数进行初始化\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2:调用写操作\x3c\/span\x3e\nWritable.prototype.write = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(chunk, encoding, cb)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.ended)\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/在end继续写入会emit一个error事件\x3c\/span\x3e\n    writeAfterEnd(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, cb);\n  \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (validChunk(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state, chunk, cb)) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/在校验数据chunk合法的情况下才会进行后续的写逻辑\x3c\/span\x3e\n    state.pendingcb\x2b\x2b;\n    ret = writeOrBuffer(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state, chunk, encoding, cb);\n  }\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewriteOrBuffer\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(stream, state, chunk, encoding, cb)\x3c\/span\x3e \x3c\/span\x3e{\n  chunk = decodeChunk(state, chunk, encoding);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (chunk \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Buffer)\n    encoding = \x3cspan class=\x22hljs-string\x22\x3e\x27buffer\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = state.objectMode ? \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e : chunk.length;\n\n  state.length \x2b= len;\x3cspan class=\x22hljs-comment\x22\x3e\/\/实时更新缓冲区长度\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = state.length \x26lt; state.highWaterMark;\x3cspan class=\x22hljs-comment\x22\x3e\/\/判断缓存区是否超过水位线(highWaterMark,不传默认16k,源码_stream_writeable.js--40行)设置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!ret)\n    state.needDrain = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state.writing || state.corked) {\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果此时处于写状态,将新添加的数据放到缓冲池链表尾部\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e last = state.lastBufferedRequest;\n    state.lastBufferedRequest = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e WriteReq(chunk, encoding, cb);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (last) {\n      last.next = state.lastBufferedRequest;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/写入数据\x3c\/span\x3e\n    doWrite(stream, state, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, len, chunk, encoding, cb);\n  }\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoWrite\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(stream, state, writev, len, chunk, encoding, cb)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (writev)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/一次写入多个数据块\x3c\/span\x3e\n    stream._writev(chunk, state.onwrite);\n  \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/一次写入一个数据块\x3c\/span\x3e\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonwrite\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(stream, er)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!finished \x26amp;\x26amp;\n        !state.corked \x26amp;\x26amp;\n        !state.bufferProcessing \x26amp;\x26amp;\n        state.bufferedRequest) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/清空缓冲池 ,不为空,则循环执行 _write() 写入单个数据块\x3c\/span\x3e\n      clearBuffer(stream, state);\n    }\n  }\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eclearBuffer\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(stream, state)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 单个数据写入\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (entry) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e chunk = entry.chunk;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e encoding = entry.encoding;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cb = entry.callback;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = state.objectMode ? \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e : chunk.length;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/开启数据写操作\x3c\/span\x3e\n      doWrite(stream, state, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, len, chunk, encoding, cb);\n      entry = entry.next;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e总结\x3c\/strong\x3e 上面是可写流源码分析,摘要了关键流程,首先根据传入参数进行初始化配置,然后用户调用write方法进行写入,写入前会判断一下是否超过水位线,超过触发drain事件,返回false,注意一点此时仍可以进行写入,返回false只是告诉你,已经满了,后需要不要写入还是靠用户根据这个返回值来控制。如果没超过,在写之前会先判断是否处于写状态,是的话将数据放到缓存中,反之会进行doWrite \x26lt;--\x26gt;clearBuffer这样的循环操作,一直到数据缓存中数据消耗完为止。清理完了之后,后续调用write的返回值ret为false,从而继续写,一直循环前面描述的整个过程,直到数据源写完为止。总的来说,因为可写流内部只有一个状态,复杂度低于可读流,整个过程还是比较清晰的,不在图形化流程。\x3c\/p\x3e\n\x3cp\x3e自己实现的一个\x3ca href=\x22https:\/\/github.com\/gcyStar\/High-Performance-JS\/blob\/master\/node\/stream\/WriteStream.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e可写流\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e说明\x3c\/strong\x3e\x3cbr\x3enode源码分析版本基于v8.9.4\x3cbr\x3e参考资料\x3cbr\x3e\x3ca href=\x22http:\/\/nodejs.cn\/api\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/nodejs.cn\/api\/\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/medium.freecodecamp.org\/node-js-streams-everything-you-need-to-know-c9141306be93\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/medium.freecodecamp.o...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>流的剖析和实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013100931">https://segmentfault.com/a/1190000013100931</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xprbhsss8kk/" target="_blank">https://alili.tech/archive/xprbhsss8kk/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>