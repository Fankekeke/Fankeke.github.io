<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="追溯 React Hot Loader 的实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>追溯 React Hot Loader 的实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xrnp7inbr1n/",
				"appid": "1613049289050283", 
				"title": "追溯 React Hot Loader 的实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-11T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jih1hq1cf37/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hz02a1jaqpp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&text=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&text=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&title=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&is_video=false&description=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&title=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&title=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&title=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxrnp7inbr1n%2f&title=%e8%bf%bd%e6%ba%af%20React%20Hot%20Loader%20%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">追溯 React Hot Loader 的实现</h1><div class="meta"><div class="postdate"><time datetime="2018-12-11" itemprop="datePublished">2018-12-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e文：萝卜（沪江金融前端开发工程师）\x3cp\x3e本文原创，转载请注明作者及出处\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e如果你使用 React ，你可以在各个工程里面看到 \x3ca href=\x22https:\/\/github.com\/gaearon?tab=repositories\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDan Abramov\x3c\/a\x3e 的身影。他于 2015 年加入 facebook，是 React Hot Loader 、React Transform、redux-thunk、redux-devtools 等等的开发者。同样也是 React、Redux、Create-React-App 的联合开发者。从他的签名 \x3cem\x3eBuilding tools for humans.\x3c\/em\x3e 或许表明了他想打造高效的开发环境以及调试过程。\x3c\/p\x3e\n\x3cp\x3e作为 Dan 的小迷妹，如他说 \x3cem\x3eis curious where the magic comes from\x3c\/em\x3e。这篇文章会带你们去了解 React Hot Loader 的由来，它实现的原理，以及在实现中遇到的问题对应的解决方法。也许你认为这篇文章太过于底层，对日常的业务并没有帮助，但希望你和我一样能通过了解一个实现得到乐趣，以及收获一些思路。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e首先，React Hot Loader 的产生\x3c\/h2\x3e\n\x3cp\x3eDan 在自己的文章里面说到。React Hot Loader 起源一个来自 \x3ca href=\x22https:\/\/stackoverflow.com\/questions\/24581873\/what-exactly-is-hot-module-replacement-in-webpack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3estackoverflow 上的一个问题\x3c\/a\x3e ——  \x3cstrong\x3ewhat exactly is hot module replacement in webpack\x3c\/strong\x3e，这个问题解释了 webpack 的 hot module replacement（下面简称 HMR）到底是什么，以及我们可以利用它做什么，Dan 当时想到也 React 可以和 webpack hot module 以一种有趣的方式结合在一起。\x3c\/p\x3e\n\x3cp\x3e于是他在 Twitter 上录制了一个简单的视频（请看下面），事实上视频中的实现依赖于它在 React 源代码里面插入了很多自己的全局变量。他本没指望到这个视频能带来多大的关注，但结果是他收到了很多点赞，并且粉丝狂增，他意识到必须以一个真正的工程去实现。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000013571765?w=300\x26amp;h=148\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000013571765?w=300\x26amp;h=148\x22 alt=\x22上传大小有限制= =\x22 title=\x22上传大小有限制= =\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/cdn-images-1.medium.com\/max\/400\/1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e大图请戳\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初步尝试,  直接使用 HMR\x3c\/h2\x3e\n\x3cp\x3eHMR 是属于 webpack 范畴内的实现，你可以在 \x3ca href=\x22https:\/\/webpack.js.org\/api\/hot-module-replacement\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack 的官方文档\x3c\/a\x3e 看到如何开启它以及它提供的接口。如果你有印象，你会记得使用它需要\x3cbr\x3e 在 webpack config 或者 webpack-dev-server cli 里面指定开启 hot reloading 模式，并且在你的代码里写上 \x3ccode\x3emodule.hot.accept(xxx)\x3c\/code\x3e。但 HMR 到底是什么？我们可以用一句话总结：当一个 import 进来的模块发生了变化，HMR 提供了一个接口让我们使用 callback 回调去做一些事情。\x3c\/p\x3e\n\x3cp\x3e一个使用 HMR 实现自动刷新的 React App 像下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ index.js\n\nvar App = require(\x27.\/App\x27)\nvar React = require(\x27react\x27)\nvar ReactDOM = require(\x27react-dom\x27)\n\n\/\/ 像通常一样 render Root Element\nvar rootEl = document.getElementById(\x27root\x27)\nReactDOM.render(\x3cApp \/\x3e, rootEl)\n\n\/\/ 我们是不是在 dev 环境 ？\nif (module.hot) {\n  \/\/ 当 App.js 更新了\n  module.hot.accept(\x27.\/App\x27, function () {\n    \/\/ require 进来更新的 App.js 重新render\n    var NextApp = require(\x27.\/App\x27)\n    ReactDOM.render(\x3cNextApp \/\x3e, rootEl)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ index.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e App = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/App\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e React = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ReactDOM = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 像通常一样 render Root Element\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rootEl = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27root\x27\x3c\/span\x3e)\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eApp\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, rootEl)\n\n\/\/ 我们是不是在 dev 环境 ？\nif (module.hot) {\n  \/\/ 当 App.js 更新了\n  module.hot.accept(\x27.\/App\x27, function () {\n    \/\/ require 进来更新的 App.js 重新render\n    var NextApp = require(\x27.\/App\x27)\n    ReactDOM.render(\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eNextApp\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, rootEl)\n  })\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e请注意，这个实现没有使用 React Hot Loader 或者 React Transform 或者任何其他的，这仅仅是 webpack 的HMR 的 api\x3c\/strong\x3e。而这里的 callback 回调函数当然是 re-render 我们的 app。\x3c\/p\x3e\n\x3cp\x3e得益于 HMR API 的设计，在嵌套的组件也能实现更新。如果一个模块没有指明如何去更新自己，那么引入这个模块的另一个模块也会被包含在热更新的 bundle 里，这些更新会”冒泡“，直到某个 import 它们的模块 \x22接收\x22 更新。如果有些模块最终没有被\x22接受\x22，那么热更新失败，控制台会打印出警告。为了“接受”更新，你只需要调用 \x3ccode\x3emodule.hot.accept(\x27.\/name\x27, callback) \x3c\/code\x3e 。\x3c\/p\x3e\n\x3cp\x3e因为我们在 index.js 里的接受了 App.js 的更新 ，这使得我们隐性的接受了所有从 App.js 引入的所有模块（component）的更新。打个比方，假如我编辑了 Button.js 组件，而它被 UserProfile.js 以及 Navbar.js import， 而这两个模块都被 App.js import 引入了。因为 index.js import 了 App.js，并且它包含了 \x3ccode\x3emodule.hot.accept(\x27.\/App\x27, callback)\x3c\/code\x3e ，Webpack 会自动产生一个包含以上所有文件的 “updated bundle”， 并且运行我们提供的 callback。\x3c\/p\x3e\n\x3cp\x3e你以为 hot reloading 就到此为止了吗，当然远远不够 ? 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e问题：组件的 state 和 DOM 被销毁。\x3c\/h2\x3e\n\x3cp\x3e当我们的 App.js 更新，实际上是有个新的 App.js 用 script 标签注入到 html， 并且重新执行了一次。此时新生成的 component 和之前的是一个组件的不同版本，它们是不同版本的同一个组件，但是 NextApp !== App。\x3c\/p\x3e\n\x3cp\x3e如果你了解 React ，你会知道当下一个 component 的 type 和之前的不一样，它会 unmount 之前那个。这就是为什么 state 和 DOM 会被销毁。\x3c\/p\x3e\n\x3cp\x3e在解决 state 保留的问题上，有人认为如果工程依赖一个单一的 state 树，那没有必要费大精力去保留组件自身的 state。因为在这种类型的 app 里面我们关注的更多的是全局的这个 state 树，而去保存这个全局的 state 树是很容易做到的，比如你可以把它保存到 localstorage里面，当 store 初始化的时候你去读取它，这样的话连刷新都不会丢失状态。\x3c\/p\x3e\n\x3cp\x3eDan 接受了这个意见，并且在自己的文章里面总结，如果你使用 redux ，并且主要的状态保存在 redux 的 store 上，这时也许你不需要使用 React-Hot-Loader。\x3c\/p\x3e\n\x3cp\x3e但他并没有因为仅仅 \x3cstrong\x3e有些人\x3c\/strong\x3e 可能不需要用到而放弃了 React-Hot-Loader。这才有了下文 ? 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e如何解决 state 和 DOM 销毁问题\x3c\/h2\x3e\n\x3cp\x3e当你从上面了解了为什么 DOM 和 state 会丢失，也许你就会 和 Dan 一样想到了两种方法。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e找到一种方式把 React 的实例和 Dom nodes 以及 state 分离，创建一个新组件的新实例，然后用一种方式把它递归地和现有的 Dom 和 state 结合在一起。\x3c\/li\x3e\n\x3cli\x3e另外一种，代理 component 的 type，这样能让 React 认为 type 没有变。事实上每次 hot update 实现引用的是新的 component type。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第一种方式看上去好一点，但是 React 暂时没有提供可以分离（聚合）state 以及不销毁 DOM、不运行生命周期去替换一个实例。即使深入到使用 React 的私有 API 达到这个目的，采用第一个方案任然面临着一些细微的问题。\x3c\/p\x3e\n\x3cp\x3e比如，React components 经常 在 componentDidmount 时候订阅 Flux stores 或者其他数据源。即使我们做到不销毁 Dom 以及 state， 偷偷地用一个新的实例替换旧的实例，旧的实例仍然会继续保持订阅，而新的实例将不会订阅。\x3c\/p\x3e\n\x3cp\x3e结论是，如果 React 的 state  的订阅是申明式，并且独立于生命周期之外，或者 React 没有那么依赖 class 和 instance， 第一个方法才可行。这些也许会出现在以后的 React 版本里，但是现在并没有。\x3c\/p\x3e\n\x3cp\x3e于是 Dan 采用了第二种，这也是之后的 React Hot Loader 和 React Transform  所使用的到技巧。\x3c\/p\x3e\n\x3cp\x3e为此，Dan 建立了一个独立的工程（react-proxy）去做 proxy，你可以在\x3ca href=\x22https:\/\/github.com\/gaearon\/react-proxy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e 看到它。create-proxy 只是一个底层的工程，它不依赖 wepback 也不依赖 babel。React Hot Loader 和 React Transform 依赖它，它把 React Component 包装到一个个 proxy 里面，这些 “proxy” 只是些 class， 它们表现的就像你自己的class，但是提供你一些钩子让你能对 class 注入新的实现方法，这样相当于让一个已经存在的实例表现的像新的 class，从而不会销毁 state 和 DOM。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e在哪里 proxy ？\x3c\/h2\x3e\n\x3cp\x3eDan 首先所做的是在 wepback 的 loader 里面 proxy。\x3c\/p\x3e\n\x3cblockquote\x3e补充，很多人认为 React Hot Loader 不是一个 “loader”，因为它只是实现 hot reloading 的。这是一个普遍的误解?。\x3c\/blockquote\x3e\n\x3cp\x3e之所以叫 “loader” 是因为 webpack 是这么称呼它，而其他 bundlers（打包器）称呼为 “transform”。打个比方，json-loader 把JSON 文件 “transform” 成  javascript modules，style-loader 把 CSS 文件 “transform” 成 js code 然后把它们以 stylesheets 的形式注入。\x3c\/p\x3e\n\x3cp\x3e而关于 React Hot Loader 你可以在\x3ca href=\x22https:\/\/github.com\/gaearon\/react-hot-loader\/blob\/7b0bc31d0a65eeae2742579e12ab10cf43df1af6\/index.js#L26-L72\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e 看到，在编译的时候它通过 export 找到 component，并且“静默” 的包裹它，然后 export 一个代理的 component 取而代之原来的。\x3c\/p\x3e\n\x3cp\x3e通过 module.exports 去寻找 components 开始听上去是合理的。开发者们经常把每个组件单独储存在一个文件，自然而然组件将会被exported。然而，随着时间变化，React 社区发生了一些变化，采取了一些新的写法或者思想，这导致了一些问题。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e随着高阶组件变得流行，大家开始 export 出来的是一个高阶组件，而不是实际上自己写的组件。 结果导致， React Hot Loader 没有“发现” module.export 里面包裹的组件，所以没有给它们创建 proxy。它们的 DOM 以及 local state 将会被在这些文件每次修改后销毁。这尤其影响像 \x3ca href=\x22https:\/\/github.com\/jsstyles\/react-jss\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact JSS\x3c\/a\x3e 一样利用高阶组件实现样式。\x3c\/li\x3e\n\x3cli\x3eReact 0.14 引进了函数式组件，并且鼓励在一个文件里面最小化拆分组件。即使React Hot Loader 能检测到导出的组件，它也“看”不到那些未被导出的本地的component。所以这些component 将不会包裹在proxy里面，所以会导致在它以及它下面的子树丢失 DOM 以及 state。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这显然是使得从 \x3ccode\x3emodule.exports\x3c\/code\x3e 去找组件是不可靠的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eReact Transform 的出现\x3c\/h2\x3e\n\x3cp\x3e除了上面提到的从 \x3ccode\x3emodule.exports\x3c\/code\x3e 不可靠之外，第一版的 React-Hot-Loader 还存在一些其他的问题。比如 webpack 的依赖问题，Dan 想做的是一个通用的工具，而不仅限于 webpack，而现在的工具只是一个 webpack 的 loader。\x3c\/p\x3e\n\x3cp\x3e虽然目前为止只有 webpack 实现了HMR， 但是一旦有其他的编译工具也实现了 HMR，那现有的 \x3ccode\x3eloader\x3c\/code\x3e 如何集成到新的编译工具里面 ？\x3c\/p\x3e\n\x3cp\x3e基于这些问题 Dan 曾经写过一篇 \x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/the-death-of-react-hot-loader-765fa791d7c4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact-Hot-Loader\x3c\/a\x3e 之死的文章，文章中提到虽然 React-Hot-Loader 得到了巨大的关注，并且有很多工程也采取了他的思想，他仍然认为这不是他所想要的。\x3c\/p\x3e\n\x3cp\x3e此时  \x3ccode\x3eBabel\x3c\/code\x3e 如浪潮一般突然占领了整个 javascript 世界。Dan 意识到可以采用静态分析的方法去找到这些 component，而 babel 正好很适合做这些。不仅如此，Dan 同样想做一个错误处理的方式，因为当 render() 方法报错的时候，此时组件会处于一种无效状态，而此时 hot reload 是没办法工作的，Dan 想一起 fix 掉这个问题。\x3c\/p\x3e\n\x3cp\x3e把 component 包裹在一个 proxy 里或者把 component  render() 包裹在一个 try\/catch 里，听上去都像 “一个函数接受一个component class 并且在它身上做些修改\x22。\x3c\/p\x3e\n\x3cp\x3e那为什么不创造一个 Babel plugin 在你的基准代码里去定位 React Component 并且包裹它们，这样就可以进行随意的 transform。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eReact Transform 的实现\x3c\/h2\x3e\n\x3cp\x3e如果你在 github 去搜 React Transform ，你可以搜到 gearaon ( dan 在github上的名字，也是唯一一个不使用真名的账号哦~) 几个工程。 这是因为在开始设定 Transform 实现的时候不确定哪些想法最终会有实质作用，所以他拆分了 React Transform 为以下 5 个子工程：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eReact Proxy 实现了对 React Component 的底层代理的功能\x3c\/li\x3e\n\x3cli\x3eReact Transform HMR 为每一个传入的 component 创建了一个代理，并且在全局对象里面保持了一个代理的清单，当同一个组件再次经历 transform，它去更新这些 component\x3c\/li\x3e\n\x3cli\x3eReact Transform Catch Error 在 render() 方法外面包了一层t ry\/catch, 当出现错误可以显示一个自己配置的组件。\x3c\/li\x3e\n\x3cli\x3eBabel Plugin for React Transform 会在你的基准代码里找到所有的React component ，在编译的时候提取它们的信息，并且把它们包裹在你选择使用的 Transform 里（比如，React Transform HMR）\x3c\/li\x3e\n\x3cli\x3eReact Transform Boilerplate 是个模板，展示如何将这些技术组合在一起使用\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这种模块化带了好处，同时也带来了弊端，弊端就是使用者在不清楚原理的情况下，不知道这些工程到底如何关联起来使用。并且这里有太多的概念暴露给了使用者， “proxies”， “HMR”， “hot middleware”, “error catcher”,  这使得用户感到很迷惑。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e问题：高阶组件还是存在问题\x3c\/h3\x3e\n\x3cp\x3e\x3cem\x3e当你解决了这些问题，尽量避免引入由解决它们带来的新的问题\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e还记得当年 React-Hot-Loader 在高阶组件上面束手无策吗，它没办法通过 \x3ccode\x3emodule.export\x3c\/code\x3e 导出的，包裹在高阶组件里面的组件。而 React Transform 通过静态检查这些组件的生命去“fix”这个问题，寻找继承自\x3cbr\x3e React.Component 或者使用 React.createClass() 申明的 class。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/\/ React Hot Loader 找不到它\n\/\/ React Transform 找得到它\nclass Counter extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { counter: 0 }\n    this.handleClick = this.handleClick.bind(this)\n  }\n  handleClick() {\n    this.setState({\n      counter: this.state.counter \x2b 1\n    })\n  }\n  render() {\n    return (\n      \x3cdiv className={this.props.sheet.container} onClick={this.handleClick}\x3e\n        {this.state.counter}\n      \x3c\/div\x3e\n    )\n  }\n}\n\nconst styles = {\n  container: { \n    backgroundColor: \x27yellow\x27\n  }\n}\n\n\/\/ React Hot Loader 找到到它\n\/\/ React Transform 找不到它\nexport default useSheet(styles)(Counter)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ React Hot Loader 找不到它\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ React Transform 找得到它\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { counter: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n  handleClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      counter: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    })\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div className={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.sheet.container} onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.counter}\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\nconst styles = {\n  container: { \n    backgroundColor: \x3cspan class=\x22hljs-string\x22\x3e\x27yellow\x27\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ React Hot Loader 找到到它\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ React Transform 找不到它\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e useSheet(styles)(Counter)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e猜猜这里我们遗漏了什么？被导出的 components! 在这个例子中，React Transform 会保留 \x3cem\x3eCounter\x3c\/em\x3e 的 state ， hot reload 会改变\x3cbr\x3e\x3cem\x3erender()\x3c\/em\x3e  和 \x3cem\x3ehandleClick()\x3c\/em\x3e 这些方法，但是任何对 \x3cem\x3estyles\x3c\/em\x3e 的改变不会体现，因为它不知道 \x3cem\x3euseSheet(styles)(Counter)\x3c\/em\x3e 正好 return 一个 React component， 这个组件也需要被 proxy。\x3c\/p\x3e\n\x3cp\x3e很多人\x3ca href=\x22https:\/\/github.com\/gaearon\/babel-plugin-react-transform\/issues\/26\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e发现了这个问题\x3c\/a\x3e，当他们注意到他们在 redux 里面 selectors 以及 action creators 不再会 hot reload。这是因为 React Transform 没有发现 \x3cem\x3econnect()\x3c\/em\x3e 返回一个组件，然后并没有一个简单的方法去识别。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e问题：使用静态方法检查太过于入侵性\x3c\/h3\x3e\n\x3cp\x3e找到通过继承自 \x3cem\x3eReact.Component\x3c\/em\x3e 或者使 \x3cem\x3eReact.createClass()\x3c\/em\x3e 创建的class \x3ca href=\x22https:\/\/github.com\/gaearon\/babel-plugin-react-transform\/blob\/19c714643faad916f3342f34171f8974589835e1\/src\/index.js#L4-L32\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e不是很难\x3c\/a\x3e 。然而，它可能出错，你也不想 \x3ca href=\x22https:\/\/github.com\/gaearon\/babel-plugin-react-transform\/issues\/78\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e带来误判\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e随着React 0.14的发布，这个任务变得更加艰难。任何 functions，如果\x3cbr\x3e return 出来的是一个有效的 ReactElement 那就可能是一个组件。由于你不能肯定，所以你不得不采用探索法。比如说，你可在判断在顶级作用域的 function，如果是以驼峰命名，使用JSX, 并且接受不超过两个以上（props 和 context）参数，那它可能是个React component。这样会误判吗？是，可能会。\x3c\/p\x3e\n\x3cp\x3e更糟糕的是，你必须让所有的 “transform” 去处理 classes 和 functions。如果React 在v16版本里面引进\x3ca href=\x22https:\/\/github.com\/reactjs\/react-future\/blob\/7ce26f52d53e5132238a4bfcbab821ad77e89d0c\/04%20-%20Layout\/prototype\/index.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e另外一种\x3c\/a\x3e 一种方式去声明组件呢，我们将要重写所有的transform吗？\x3c\/p\x3e\n\x3cp\x3e最后得出结论，用静态方法 \x3cem\x3e包裹\x3c\/em\x3e 组件相当复杂。你将要对 functions 和 classes 可能的 export 方式取使用各种方法去处理，包括 default 和 named 的 exports，function声明，箭头函数，class声明，class表达式，createClass() 形式调用，以及等等。每种情况你都需要用一种方法针对相同的变量或者表达式去绑定不同的值。\x3c\/p\x3e\n\x3cp\x3e想办法支持 functional components 是\x3ca href=\x22https:\/\/github.com\/gaearon\/babel-plugin-react-transform\/issues\/57\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e最多的提议\x3c\/a\x3e， 我现在不会考虑在 React Transform 支持它，因为实现的复杂程度会给工程以及它的维护者带来巨大困难，并且可能由于一些边缘情况导致彻底的破坏。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eReact Hot Loader 3\x3c\/h2\x3e\n\x3cp\x3e以上总结是出自 Dan 的一篇在medium上的\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/hot-reloading-in-react-1140438583bf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文章\x3c\/a\x3e，他称呼 React Hot Loader 是一个 Accidental Complexity，其中还提到它对 compile-to-js 语言 （其他通过编译转成JS的语言）的考虑，以及中途遇到的 babel 的问题等。文章中 Dan 表明他会在几个月内停止 React Transform 而使用一个新的工程代替，新的工程会解决大多数残留的问题，末尾给了一些提示在新工程里面需要做到的。在这篇文章的一个月后，React-Hot-Loader 3 release了，让我们大致的过一下 3 的到底做了些什么。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e在调用的时候 proxy\x3c\/h3\x3e\n\x3cp\x3e在源码中找到并且包裹React components是非常难做到的，并且有可能是破坏性的。这真的会破坏你的代码，但标记它们相对来说是比较安全。比如我们可以通过 babel-plugin 检查一个文件，针对顶层 class、function 以及 被 export 出来的模块在文件末尾做个标记:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Counter extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { counter: 0 }\n    this.handleClick = this.handleClick.bind(this)\n  }\n  handleClick() {\n    this.setState({\n      counter: this.state.counter \x2b 1\n    })\n  }\n  render() {\n    return (\n      \x3cdiv className={this.props.sheet.container} onClick={this.handleClick}\x3e\n        {this.state.counter}\n      \x3c\/div\x3e\n    )\n  }\n}\n\nconst styles = {\n  container: { \n    backgroundColor: \x27yellow\x27\n  }\n}\n\nconst __exports_default = useSheet(styles)(Counter)\nexport default __exports_default\n\n\/\/ 我们 generate 的标记代码：\n\/\/ 在 *远端* 标记任何看上去像 React Component 的东西\nregister(\x27Counter.js#Counter\x27, Counter)\nregister(\x27Counter.js#exports#default\x27, __exports_default) \/\/ every export too\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { counter: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n  handleClick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      counter: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.counter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    })\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div className={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.sheet.container} onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.counter}\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\nconst styles = {\n  container: { \n    backgroundColor: \x3cspan class=\x22hljs-symbol\x22\x3e\x27yello\x3c\/span\x3ew\x27\n  }\n}\n\nconst __exports_default = useSheet(styles)(\x3cspan class=\x22hljs-type\x22\x3eCounter\x3c\/span\x3e)\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e __exports_default\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们 generate 的标记代码：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 *远端* 标记任何看上去像 React Component 的东西\x3c\/span\x3e\nregister(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Counter\x3c\/span\x3e.js#\x3cspan class=\x22hljs-type\x22\x3eCounter\x3c\/span\x3e\x27, \x3cspan class=\x22hljs-type\x22\x3eCounter\x3c\/span\x3e)\nregister(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Counter\x3c\/span\x3e.js#exports#\x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e\x27, __exports_default) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ every export too\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eregister() 至少会判断传进来的值是不是一个函数，如果是，创建一个 React Proxy 包裹它。它不会替换你的 class 或者 function，这个proxy将会待在全局的map里面，等待着，直到你使用React.createElement()。\x3c\/p\x3e\n\x3cp\x3e仅仅真正的组件才会经历 React.createElement，这就是我们为什么 monkeyPatch React.createElement()。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import createProxy from \x27react-proxy\x27\n\nlet proxies = {}\nconst UNIQUE_ID_KEY = \x27__uniqueId\x27\n\nexport function register(uniqueId, type) {\n  Object.defineProperty(type, UNIQUE_ID_KEY, {\n    value: uniqueId,\n    enumerable: false,\n    configurable: false\n  })\n  \n  let proxy = proxies[uniqueId]\n  if (proxy) {\n    proxy.update(type)\n  } else {\n    proxy = proxies[id] = createProxy(type)\n  }\n}\n\n\/\/ Resolve 发生在 element 被创建的时候，而不是声明的时候\nconst realCreateElement = React.createElement\nReact.createElement = function createElement(type, ...args)  {\n  if (type[UNIQUE_ID_KEY]) {\n    type = proxies[type[UNIQUE_ID_KEY]].get()\n  }\n  \n  return realCreateElement(type, ...args)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e createProxy \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-proxy\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e proxies = {}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e UNIQUE_ID_KEY = \x3cspan class=\x22hljs-string\x22\x3e\x27__uniqueId\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eregister\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3euniqueId, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, UNIQUE_ID_KEY, {\n    value: uniqueId,\n    enumerable: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    configurable: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  })\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e proxy = proxies[uniqueId]\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (proxy) {\n    proxy.update(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    proxy = proxies[id] = createProxy(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Resolve 发生在 element 被创建的时候，而不是声明的时候\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e realCreateElement = React.createElement\nReact.createElement = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateElement\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, ...args\x3c\/span\x3e)  \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e[UNIQUE_ID_KEY]) {\n    \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = proxies[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e[UNIQUE_ID_KEY]].get()\n  }\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e realCreateElement(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, ...args)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在调用端包裹组件解决了很多问题，比如 functional component 不会误判，包裹的逻辑只要考虑 function 和 class，因为我们把生成的代码移到底部这样不会污染代码。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e给 compile-to-js 语言提供了一种兼容方式\x3c\/h3\x3e\n\x3cp\x3eDan 提供了类似于 React-Hot-Loader 1 的 webpack loader， 即 \x3ccode\x3ereact-hot-loader\/webpack\x3c\/code\x3e。在不使用 babel 做静态分析的情况下，你可以通过它找到 \x3ccode\x3emodule.export\x3c\/code\x3e 出来的 component，并且 register 到全局，然后在调用端实现真正的代理。所以这种方式只能针对\x3ca href=\x22https:\/\/github.com\/gaearon\/react-hot-loader#known-limitations\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e实际 export 出来的组件做保留 state 以及 DOM 的 hot reloading\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e什么情况下会使用这种方式，那就是针对其他 compile-to-js 的语言比如  \x3ca href=\x22https:\/\/github.com\/bhauman\/lein-figwheel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFigwheel\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/elm-lang\/elm-reactor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eElm Reactor\x3c\/a\x3e。在这些语言里面有自己的类的实现等，所以 Babel 没有针对源码办法去做静态检查，所以必须在编译之后去处理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e错误处理\x3c\/h3\x3e\n\x3cp\x3e还记得 React Transform 里面的React Transform Catch Error 吗。React-Hot-Loader 把处理 render 出错的逻辑放到 AppContainer 。因为 React V16 增加了 \x3ca href=\x22https:\/\/reactjs.org\/docs\/error-boundaries.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eerror boundaries \x3c\/a\x3e，相信在未来的版本 React-Hot-Loader 也会做相应调整。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e写在最后\x3c\/h2\x3e\n\x3cp\x3e这就是对 React-Hot-Loader 的实现的一个追溯，如果你真的理解了，那么你在配置 React-Hot-Loader 到你的应用代码里面的每个步骤会有一个重新的认识。我不确定大家是否读懂了，或者存在还存在什么疑问，欢迎来沟通讨论。截止写文现在 React-Hot-Loader 4 已经在进行中，我比较偏向于 4 会和 React 迭代保持更亲密的同步（ 从之前  \x3ca href=\x22https:\/\/reactjs.org\/docs\/error-boundaries.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eerror boundaries \x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/facebook\/react\/issues\/5306\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eofficial instrumentation API\x3c\/a\x3e 来看），到时候拭目以待吧。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000012423305?w=1426\x26amp;h=778\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000012423305?w=1426\x26amp;h=778\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>追溯 React Hot Loader 的实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000013571760">https://segmentfault.com/a/1190000013571760</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xrnp7inbr1n/" target="_blank">https://alili.tech/archive/xrnp7inbr1n/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>