<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一篇包含了react所有基本点的文章"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一篇包含了react所有基本点的文章 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xsyk6re8i2e/",
				"appid": "1613049289050283", 
				"title": "一篇包含了react所有基本点的文章 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:30"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/uiyd6io2akg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/n7q81ql61h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&text=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&text=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&title=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&is_video=false&description=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&title=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&title=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&title=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxsyk6re8i2e%2f&title=%e4%b8%80%e7%af%87%e5%8c%85%e5%90%ab%e4%ba%86react%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%82%b9%e7%9a%84%e6%96%87%e7%ab%a0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一篇包含了react所有基本点的文章</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e去年，我写了一本关于学习React.js的小书，原来是大约100页。 今年我要挑战自己，把它归纳为一篇文章。\x3c\/p\x3e\n\x3cp\x3e本文不会涵盖什么是React，或者为什么要学习它。 相反，这是面向已经熟悉JavaScript并熟悉DOM API基础知识的人，对React.js的基础知识的介绍。\x3c\/p\x3e\n\x3cp\x3e以下所有代码示例均标示为参考。 它们纯粹是为了提供概念而写的例子。 他们大多数可以写得更好一些。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e1：组件是React的一切\x3c\/h1\x3e\n\x3cp\x3eReact是围绕可重用组件的概念设计的。 您定义小组件，并将它们放在一起形成更大的组件。\x3c\/p\x3e\n\x3cp\x3e所有小或小的组件都可重复使用，甚至跨不同的项目。\x3c\/p\x3e\n\x3cp\x3e一个React组件（以其最简单的形式）是一个简单的JavaScript函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 1\n\/\/ https:\/\/jscomplete.com\/repl?j=Sy3QAdKHW\nfunction Button (props) {\n  \/\/ Returns a DOM element here. For example:\n  return \x3cbutton type=\x26quot;submit\x26quot;\x3e{props.label}\x3c\/button\x3e;\n}\n\/\/ To render the Button component to the browser\nReactDOM.render(\x3cButton label=\x26quot;Save\x26quot; \/\x3e, mountNode)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=Sy3QAdKHW\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Returns a DOM element here. For example:\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22submit\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e{props.label}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ To render the Button component to the browser\x3c\/span\x3e\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3elabel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Save\x22\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, mountNode)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用于按钮标签的花括号将在下面介绍。 现在不必要担心他们。 ReactDOM也将在后面解释，但是如果要测试这个例子和接下来的代码示例，\x3ccode\x3erender\x3c\/code\x3e函数就是你需要的。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eReactDOM.render\x3c\/code\x3e的第二个参数是React将要接管和控制的目标DOM元素。 在jsComplete REPL中，您就可以使用\x3ccode\x3emountNode\x3c\/code\x3e变量。\x3c\/p\x3e\n\x3cp\x3e关于示例1的注意事项有以下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e组件名称以大写字母开头。 这是必需的，因为我们将处理HTML元素和React元素的混合。 小写名称保留给HTML元素。 事实上，请继续尝试将React组件命名为“button”。 ReactDOM将忽略该函数并呈现常规的空HTML按钮。\x3c\/li\x3e\n\x3cli\x3e每个组件都接收一个属性列表，就像HTML元素一样。 在React中，这个列表叫做\x3ccode\x3eprops\x3c\/code\x3e。创建功能组件，你可以通过使用任意名称命名\x3ccode\x3eprops\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e在上面的Button组件的返回中，我们写出了奇怪的HTML。 这既不是JavaScript也不是HTML，甚至不是React.js。 但是，它非常受欢迎，成为React应用程序中的默认设置。 它被称为JSX，它是一个JavaScript扩展。 JSX也是妥协！ 继续尝试在上面的函数中的任何其他HTML元素，并查看它们是如何支持的（例如，返回一个文本输入元素）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e2: What the flux is JSX?\x3c\/h1\x3e\n\x3cp\x3e上面的示例1可以用纯粹的React.js来编写，而不需要JSX，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 2 -  React component without JSX\n\/\/ https:\/\/jscomplete.com\/repl?j=HyiEwoYB-\nfunction Button (props) {\n  return React.createElement(\n    \x26quot;button\x26quot;,\n    { type: \x26quot;submit\x26quot; },\n    props.label\n  );\n}\n\/\/ To use Button, you would do something like\nReactDOM.render(\n  React.createElement(Button, { label: \x26quot;Save\x26quot; }),\n  mountNode\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scilab\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 2 -  React component without JSX\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=HyiEwoYB-\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(props)\x3c\/span\x3e {\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e React.createElement(\n    \x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e,\n    { \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22submit\x22\x3c\/span\x3e },\n    props.label\n  );\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ To use Button, you would do something like\x3c\/span\x3e\nReactDOM.render(\n  React.createElement(Button, { label: \x3cspan class=\x22hljs-string\x22\x3e\x22Save\x22\x3c\/span\x3e }),\n  mountNode\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecreateElement\x3c\/code\x3e函数是React顶级API中函数。 您需要学习的这个级别中共有7件事情中的1项。 可见ReactApi多么简短。\x3c\/p\x3e\n\x3cp\x3e很像DOM本身有一个\x3ccode\x3edocument.createElement\x3c\/code\x3e函数来创建一个由标签名称指定的元素，React的\x3ccode\x3ecreateElement\x3c\/code\x3e函数是一个更高级别的函数，可以做类似于\x3ccode\x3edocument.createElement\x3c\/code\x3e的功能。 但它也可以用于创建一个表示React组件的元素。 当我们使用上面的例2中的Button组件时，我们这里就是创建了一个React组件。\x3c\/p\x3e\n\x3cp\x3e与\x3ccode\x3edocument.createElement\x3c\/code\x3e不同，React的\x3ccode\x3ecreateElement\x3c\/code\x3e可以接受第二个参数之后的动态参数，以表示创建的元素的后代。 所以\x3ccode\x3ecreateElement\x3c\/code\x3e实际上创建一个树。\x3c\/p\x3e\n\x3cp\x3e这是一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/ Example 3 -  React’s createElement API\n\/\/ https:\/\/jscomplete.com\/repl?j=r1GNoiFBb\nconst InputForm = React.createElement(\n  \x26quot;form\x26quot;,\n  { target: \x26quot;_blank\x26quot;, action: \x26quot;https:\/\/google.com\/search\x26quot; },\n  React.createElement(\x26quot;div\x26quot;, null, \x26quot;Enter input and click Search\x26quot;),\n  React.createElement(\x26quot;input\x26quot;, { name: \x26quot;q\x26quot;, className: \x26quot;input\x26quot; }),\n  React.createElement(Button, { label: \x26quot;Search\x26quot; })\n);\n\/\/ InputForm uses the Button component, so we need that too:\nfunction Button (props) {\n  return React.createElement(\n    \x26quot;button\x26quot;,\n    { type: \x26quot;submit\x26quot; },\n    props.label\n  );\n}\n\/\/ Then we can use InputForm directly with .render\nReactDOM.render(InputForm, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e\/ Example \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e -  React’s createElement API\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=r1GNoiFBb\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e InputForm = React.createElement(\n  \x3cspan class=\x22hljs-string\x22\x3e\x22form\x22\x3c\/span\x3e,\n  { \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22_blank\x22\x3c\/span\x3e, action: \x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/google.com\/search\x22\x3c\/span\x3e },\n  React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Enter input and click Search\x22\x3c\/span\x3e),\n  React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e, { name: \x3cspan class=\x22hljs-string\x22\x3e\x22q\x22\x3c\/span\x3e, className: \x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e }),\n  React.createElement(Button, { label: \x3cspan class=\x22hljs-string\x22\x3e\x22Search\x22\x3c\/span\x3e })\n);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ InputForm uses the Button component, so we need that too:\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(props)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e React.\x3cspan class=\x22hljs-title\x22\x3ecreateElement\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\n    \x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e,\n    { type: \x3cspan class=\x22hljs-string\x22\x3e\x22submit\x22\x3c\/span\x3e },\n    props.label\n  )\x3c\/span\x3e\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Then we can use InputForm directly with .render\x3c\/span\x3e\nReactDOM.render(InputForm, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于以上例子要注意的几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eInputForm\x3c\/code\x3e不是React组件; 它只是一个React元素。 这就是为什么我们直接在\x3ccode\x3eReactDOM.render\x3c\/code\x3e调用中使用它，而不是使用\x3ccode\x3e\x26lt;InputForm \/\x26gt;\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e我们可以嵌套\x3ccode\x3eReact.createElement\x3c\/code\x3e调用，因为它都是JavaScript。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eReact.createElement\x3c\/code\x3e的第二个参数可以是null，也可以是一个空对象，当元素不需要attributes和props时。\x3c\/li\x3e\n\x3cli\x3e我们可以将HTML元素与React组件混合使用。 您可以将HTML元素视为内置的React组件。\x3c\/li\x3e\n\x3cli\x3eReact的API尝试尽可能接近DOM API，因此我们为输入元素使用className而不是类。 私以为，我们都希望React的API将成为DOM API本身的一部分。 因为，你知道的，这有太多的好处了。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上面的代码是您在引入React库时了解的内容。 浏览器不处理任何JSX业务。 然而，我们人类喜欢看HTML并且使用HTML而不是这些\x3ccode\x3ecreateElement\x3c\/code\x3e调用（想象一下使用\x3ccode\x3edocument.createElement\x3c\/code\x3e构建一个网站，我相信你可以的！）。 这就是为什么存在JSX的原因。 我们可以用非常类似于HTML的语法编写它，而不是用\x3ccode\x3eReact.createElement\x3c\/code\x3e调用上面的表单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 4 - JSX (compare with Example 3)\n\/\/ https:\/\/jscomplete.com\/repl?j=SJWy3otHW\nconst InputForm =\n  \x3cform target=\x26quot;_blank\x26quot; action=\x26quot;https:\/\/google.com\/search\x26quot;\x3e\n    \x3cdiv\x3eEnter input and click Search\x3c\/div\x3e\n    \x3cinput name=\x26quot;q\x26quot; className=\x26quot;input\x26quot; \/\x3e\n    \x3cButton label=\x26quot;Search\x26quot; \/\x3e\n  \x3c\/form\x3e;\n\/\/ InputForm \x26quot;still\x26quot; uses the Button component, so we need that too.\n\/\/ Either JSX or normal form would do\nfunction Button (props) {\n  \/\/ Returns a DOM element here. For example:\n  return \x3cbutton type=\x26quot;submit\x26quot;\x3e{props.label}\x3c\/button\x3e;\n}\n\/\/ Then we can use InputForm directly with .render\nReactDOM.render(InputForm, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 4 - JSX (compare with Example 3)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=SJWy3otHW\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e InputForm =\n  \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3eform\x3c\/span\x3e target=\x3cspan class=\x22hljs-string\x22\x3e\x22_blank\x22\x3c\/span\x3e action=\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/google.com\/search\x22\x3c\/span\x3e\x26gt;\n    \x26lt;div\x26gt;Enter \x3cspan class=\x22hljs-keyword\x22\x3einput\x3c\/span\x3e and click \x3cspan class=\x22hljs-keyword\x22\x3eSearch\x3c\/span\x3e\x26lt;\/div\x26gt;\n    \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3einput\x3c\/span\x3e name=\x3cspan class=\x22hljs-string\x22\x3e\x22q\x22\x3c\/span\x3e className=\x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e \/\x26gt;\n    \x26lt;Button \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Search\x22\x3c\/span\x3e \/\x26gt;\n  \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3eform\x3c\/span\x3e\x26gt;;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ InputForm \x22still\x22 uses the Button component, so we need that too.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Either JSX or normal form would do\x3c\/span\x3e\nfunction Button (props) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Returns a DOM element here. For example:\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;button \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22submit\x22\x3c\/span\x3e\x26gt;{props.\x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e}\x26lt;\/button\x26gt;;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Then we can use InputForm directly with .render\x3c\/span\x3e\nReactDOM.render(InputForm, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于上面的例子注意以下几点\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e它不是HTML。 例如，我们仍然在使用className而不是类。\x3c\/li\x3e\n\x3cli\x3e我们仍然在考虑将以上HTML作为JavaScript。 看看我在末尾添加了分号。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们上面写的（例4）是JSX。 然而，我们在浏览器的执行版本是它的编译版本（示例3）。 为了实现这一点，我们需要使用预处理器将JSX版本转换为\x3ccode\x3eReact.createElement\x3c\/code\x3e版本。\x3c\/p\x3e\n\x3cp\x3e那就是JSX。 这是一个折中，允许我们以类似于HTML的语法编写我们的React组件，这是一个很好的共识。\x3c\/p\x3e\n\x3cblockquote\x3e上面标题中的“Flux”一词被选为韵脚(...)，但它也是Facebook流行的非常受欢迎的应用程序架构的名称。 最着名的实现是Redux。\x3c\/blockquote\x3e\n\x3cp\x3eJSX，顺便说一下，可以自己在其他地方使用。 这不是只有在React中才可以使用的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e3: 您可以在JSX中的任何位置使用JavaScript表达式\x3c\/h1\x3e\n\x3cp\x3e在JSX部分中，您可以在一对花括号内使用任何JavaScript表达式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 5 -  Using JavaScript expressions in JSX\n\/\/ https:\/\/jscomplete.com\/repl?j=SkNN3oYSW\nconst RandomValue = () =\x3e \n  \x3cdiv\x3e\n    { Math.floor(Math.random() * 100) }\n  \x3c\/div\x3e;\n\/\/ To use it:\nReactDOM.render(\x3cRandomValue \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 5 -  Using JavaScript expressions in JSX\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=SkNN3oYSW\x3c\/span\x3e\nconst RandomValue = () =\x26gt; \n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n    { Math.floor(Math.random() * \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e) }\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/div\x26gt;\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ To use it:\x3c\/span\x3e\nReactDOM.render(\x3cspan class=\x22hljs-params\x22\x3e\x26lt;RandomValue \/\x26gt;\x3c\/span\x3e, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e任何JavaScript表达式都可以放在那些花括号内。 这相当于JavaScript模板文字中的\x3ccode\x3e$ {}\x3c\/code\x3e插值语法。\x3c\/p\x3e\n\x3cp\x3e这是JSX中唯一的约束：只有表达式。 所以，你不能使用常规的if语句，但是三元表达式是可以的。\x3c\/p\x3e\n\x3cp\x3eJavaScript变量也是表达式，所以当组件接收到\x3ccode\x3eprops\x3c\/code\x3e列表（RandomValue组件没有，\x3ccode\x3eprops\x3c\/code\x3e是可选的）时，可以在花括号内使用这些\x3ccode\x3eprops\x3c\/code\x3e。 我们在上面的Button组件中这样做了（示例1）。\x3c\/p\x3e\n\x3cp\x3eJavaScript对象也是表达式。 有时候，我们在一个花括号里面使用一个JavaScript对象，这使得它看起来像双花括号，但它实际上只是一个大括号内的一个对象。 一个用例是将CSS样式对象传递给React中的style属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 6 - An object passed to the special React style prop\n\/\/ https:\/\/jscomplete.com\/repl?j=S1Kw2sFHb\nconst ErrorDisplay = ({message}) =\x3e\n  \x3cdiv style={ { color: \x27red\x27, backgroundColor: \x27yellow\x27 } }\x3e\n    {message}\n  \x3c\/div\x3e;\n\/\/ Use it:\nReactDOM.render(\n  \x3cErrorDisplay \n    message=\x26quot;These aren\x27t the droids you\x27re looking for\x26quot; \n  \/\x3e,\n  mountNode\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs axapta\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 6 - An object passed to the special React style prop\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=S1Kw2sFHb\x3c\/span\x3e\nconst ErrorDisplay = ({message}) =\x26gt;\n  \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e style={ { color: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e, backgroundColor: \x3cspan class=\x22hljs-string\x22\x3e\x27yellow\x27\x3c\/span\x3e } }\x26gt;\n    {message}\n  \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it:\x3c\/span\x3e\nReactDOM.render(\n  \x26lt;ErrorDisplay \n    message=\x3cspan class=\x22hljs-string\x22\x3e\x22These aren\x27t the droids you\x27re looking for\x22\x3c\/span\x3e \n  \/\x26gt;,\n  mountNode\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，我如何仅解析\x3ccode\x3eprops\x3c\/code\x3e参数中的message的。 这是JavaScript。 还要注意上面的style属性是一个特殊的属性（再次，它不是HTML，它更接近于DOM API）。 我们使用一个对象作为style属性的值。 该对象定义了样式，就像我们使用JavaScript一样（因为确实就是）。\x3c\/p\x3e\n\x3cp\x3e甚至可以在JSX中使用React元素，因为这也是一个表达式。 记住，一个React元素就是一个函数调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const MaybeError = ({errorMessage}) =\x3e\n  \x3cdiv\x3e\n    {errorMessage \x26amp;\x26amp; \x3cErrorDisplay message={errorMessage} \/\x3e}\n  \x3c\/div\x3e;\n  \n\/\/ The MaybeError component uses the ErrorDisplay component:\nconst ErrorDisplay = ({message}) =\x3e\n  \x3cdiv style={ { color: \x27red\x27, backgroundColor: \x27yellow\x27 } }\x3e\n    {message}\n  \x3c\/div\x3e;\n\/\/ Now we can use the MaybeError component:\nReactDOM.render(\n  \x3cMaybeError\n    errorMessage={Math.random() \x3e 0.5 ? \x27Not good\x27 : \x27\x27}\n  \/\x3e,\n  mountNode\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs axapta\x22\x3e\x3ccode\x3econst MaybeError = ({errorMessage}) =\x26gt;\n  \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\n    {errorMessage \x26amp;\x26amp; \x26lt;ErrorDisplay message={errorMessage} \/\x26gt;}\n  \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;;\n  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The MaybeError component uses the ErrorDisplay component:\x3c\/span\x3e\nconst ErrorDisplay = ({message}) =\x26gt;\n  \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e style={ { color: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e, backgroundColor: \x3cspan class=\x22hljs-string\x22\x3e\x27yellow\x27\x3c\/span\x3e } }\x26gt;\n    {message}\n  \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Now we can use the MaybeError component:\x3c\/span\x3e\nReactDOM.render(\n  \x26lt;MaybeError\n    errorMessage={Math.random() \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27Not good\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e}\n  \/\x26gt;,\n  mountNode\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的\x3ccode\x3eMaybeError\x3c\/code\x3e组件将只显示\x3ccode\x3eErrorDisplay\x3c\/code\x3e组件，如果有一个\x3ccode\x3eerrorMessage\x3c\/code\x3e字符串传递给它和一个空的div。 React将\x3ccode\x3e{true}\x3c\/code\x3e，\x3ccode\x3e{false}\x3c\/code\x3e，\x3ccode\x3e{undefined}\x3c\/code\x3e和\x3ccode\x3e{null}\x3c\/code\x3e视为没有呈现任何内容的有效元素子元素。\x3c\/p\x3e\n\x3cp\x3e您还可以使用JSX内的集合上的所有JavaScript方法（map，reduce，filter，concat等）。 再次声明原因是因为它们返回的是表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 8 - Using an array map inside {}\n\/\/ https:\/\/jscomplete.com\/repl?j=SJ29aiYH-\nconst Doubler = ({value=[1, 2, 3]}) =\x3e\n  \x3cdiv\x3e\n    {value.map(e =\x3e e * 2)}\n  \x3c\/div\x3e;\n\/\/ Use it\nReactDOM.render(\x3cDoubler \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3e\/\/ Example 8 - Using an\x3cspan class=\x22hljs-built_in\x22\x3e array \x3c\/span\x3emap inside {}\n\/\/ https:\/\/jscomplete.com\/repl?j=SJ29aiYH-\x3cspan class=\x22hljs-built_in\x22\x3e\nconst \x3c\/span\x3eDoubler = ({value=[1, 2, 3]}) =\x26gt;\n  \x26lt;div\x26gt;\n    {value.map(e =\x26gt; e * 2)}\n  \x26lt;\/div\x26gt;;\n\/\/ Use it\nReactDOM.render(\x26lt;Doubler \/\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，我是如何给\x3ccode\x3evalue\x3c\/code\x3eprops默认值的，因为它全是Javascript。 还要注意，我在div中输出了一个数组表达式，这在React中是可行的。 它将把每一个双倍的值放在一个文本节点中。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e4: 您可以使用JavaScript类编写React组件\x3c\/h1\x3e\n\x3cp\x3e简单的功能组件非常适合简单的需求，但有时我们需要更多的功能。 React支持通过JavaScript类语法创建组件。 这是使用类语法编写的Button组件（在示例1中）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 9 - Creating components using JavaScript classes\n\/\/ https:\/\/jscomplete.com\/repl?j=ryjk0iKHb\nclass Button extends React.Component {\n  render() {\n    return \x3cbutton\x3e{this.props.label}\x3c\/button\x3e;\n  }\n}\n\/\/ Use it (same syntax)\nReactDOM.render(\x3cButton label=\x26quot;Save\x26quot; \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 9 - Creating components using JavaScript classes\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=ryjk0iKHb\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;button\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.label}\x26lt;\/button\x26gt;;\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it (same syntax)\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e label=\x3cspan class=\x22hljs-string\x22\x3e\x22Save\x22\x3c\/span\x3e \/\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类语法很简单。 定义一个扩展了React.Component基类的类（需要学习的另一个顶级的React API）。 该类定义一个唯一实例函数render（），该render函数返回虚拟DOM对象。 每次我们使用上面的基于Button类的组件（例如，通过执行\x26lt;Button ... \/\x26gt;），React将从这个基于类的组件中实例化一个对象，并在DOM树中使用该对象。\x3c\/p\x3e\n\x3cp\x3e这就是为什么我们在上面的渲染输出中在JSX中使用\x3ccode\x3ethis.props.label\x3c\/code\x3e的原因。 因为每个组件都获得一个称为\x3ccode\x3eprops\x3c\/code\x3e的特殊实例属性，该实例属性在实例化时保存传递给该组件的所有值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 10 -  Customizing a component instance\n\/\/ https:\/\/jscomplete.com\/repl?j=rko7RsKS-\nclass Button extends React.Component {\n  constructor(props) {\n    super(props);\n    this.id = Date.now();\n  }\n  render() {\n    return \x3cbutton id={this.id}\x3e{this.props.label}\x3c\/button\x3e;\n  }\n}\n\/\/ Use it\nReactDOM.render(\x3cButton label=\x26quot;Save\x26quot; \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 10 -  Customizing a component instance\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=rko7RsKS-\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = \x3cspan class=\x22hljs-type\x22\x3eDate\x3c\/span\x3e.now();\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;button id={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id}\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.label}\x26lt;\/button\x26gt;;\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e label=\x3cspan class=\x22hljs-string\x22\x3e\x22Save\x22\x3c\/span\x3e \/\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们还可以定义类属性函数，并在我们想使用的地方使用，包括返回的JSX输出内：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 11 — Using class properties\n\/\/ https:\/\/jscomplete.com\/repl?j=H1YDCoFSb\nclass Button extends React.Component {\n  clickCounter = 0;\nhandleClick = () =\x3e {\n    console.log(`Clicked: ${\x2b\x2bthis.clickCounter}`);\n  };\n  \n  render() {\n    return (\n      \x3cbutton id={this.id} onClick={this.handleClick}\x3e\n        {this.props.label}\n      \x3c\/button\x3e\n    );\n  }\n}\n\/\/ Use it\nReactDOM.render(\x3cButton label=\x26quot;Save\x26quot; \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 11 — Using class properties\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=H1YDCoFSb\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  clickCounter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\nhandleClick = () =\x26gt; {\n    console.log(`\x3cspan class=\x22hljs-type\x22\x3eClicked\x3c\/span\x3e: ${\x2b\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.clickCounter}`);\n  };\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;button id={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id} onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.label}\n      \x26lt;\/button\x26gt;\n    );\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eButton\x3c\/span\x3e label=\x3cspan class=\x22hljs-string\x22\x3e\x22Save\x22\x3c\/span\x3e \/\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于例子11有几点需要注意\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ehandleClick\x3c\/code\x3e函数是使用JavaScript中新建的类字段语法编写的。这种语法仍然属于\x3ccode\x3estage-2,\x3c\/code\x3e，但由于很多原因，它是访问组件安装实例（由于箭头功能）的最佳选择。 但是，您需要使用像Babel这样的编译器来配置它来理解\x3ccode\x3estage-2\x3c\/code\x3e,（或类字段语法）来获取上面的代码。 jsComplete REPL具有预配置。\x3c\/li\x3e\n\x3cli\x3e我们还使用相同的类字段语法定义了\x3ccode\x3eClickCounter\x3c\/code\x3e实例变量。 这允许我们完全跳过使用类构造函数调用。\x3c\/li\x3e\n\x3cli\x3e当我们将\x3ccode\x3ehandleClick\x3c\/code\x3e函数指定为特殊的\x3ccode\x3eonClick\x3c\/code\x3e，React属性的值时，我们没有调用它。 我们把handleClick函数引用传递给出去了。 在这个属性里面调用函数是使用React最常见的错误之一。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Wrong:\nonClick={this.handleClick()}\n\/\/ Right:\nonClick={this.handleClick}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Wrong:\x3c\/span\x3e\nonClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick()}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Right:\x3c\/span\x3e\nonClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e5: React的事件中，两个最重要的区别\x3c\/h1\x3e\n\x3cp\x3e在React元素中处理事件时，与DOM API的方式有两个非常重要的区别：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e所有React元素属性（包括事件）使用camelCase命名，而不是小写。 它是\x3ccode\x3eonClick\x3c\/code\x3e，而不是\x3ccode\x3eonclick\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e我们传递一个实际的JavaScript函数引用作为事件处理程序，而不是一个字符串。 它是\x3ccode\x3eonClick = {handleClick}\x3c\/code\x3e，而不是\x3ccode\x3eonClick =“handleClick”\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e使用自己的对象将DOM事件对象包装起来，以优化事件处理的性能。 但是在事件处理程序中，我们仍然可以访问DOM事件对象上可用的所有方法。 React将包装的事件对象传递给每个句柄调用。 例如，为了防止表单从默认提交操作中，您可以执行以下操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 12 - Working with wrapped events\n\/\/ https:\/\/jscomplete.com\/repl?j=HkIhRoKBb\nclass Form extends React.Component {\n  handleSubmit = (event) =\x3e {\n    event.preventDefault();\n    console.log(\x27Form submitted\x27);\n  };\n  \n  render() {\n    return (\n      \x3cform onSubmit={this.handleSubmit}\x3e\n        \x3cbutton type=\x26quot;submit\x26quot;\x3eSubmit\x3c\/button\x3e\n      \x3c\/form\x3e\n    );\n  }\n}\n\/\/ Use it\nReactDOM.render(\x3cForm \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 12 - Working with wrapped events\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=HkIhRoKBb\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eForm\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  handleSubmit = (event) =\x26gt; {\n    event.preventDefault();\n    console.log(\x3cspan class=\x22hljs-symbol\x22\x3e\x27Form\x3c\/span\x3e submitted\x27);\n  };\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;form onSubmit={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubmit}\x26gt;\n        \x26lt;button \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22submit\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-type\x22\x3eSubmit\x3c\/span\x3e\x26lt;\/button\x26gt;\n      \x26lt;\/form\x26gt;\n    );\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.render(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eForm\x3c\/span\x3e \/\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e6: 每一个React组件都有故事\x3c\/h1\x3e\n\x3cp\x3e以下仅适用于类组件（扩展为React.Component的组件）。 函数组件有一个略有不同的故事。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e首先，我们为React定义一个模板，以从组件创建元素。\x3c\/li\x3e\n\x3cli\x3e然后，我们指示React在某处使用它。 例如，在另一个组件的render调用中，或者使用ReactDOM.render。\x3c\/li\x3e\n\x3cli\x3e然后，React实例化一个元素，并给出一组我们可以使用\x3ccode\x3ethis.props\x3c\/code\x3e访问的\x3ccode\x3eprops\x3c\/code\x3e。 那些\x3ccode\x3eprops\x3c\/code\x3e正是我们在上面的步骤2中传递的。\x3c\/li\x3e\n\x3cli\x3e由于它都是JavaScript，所以构造方法将被调用（如果已经定义的话）。 这是我们要说的第一个：组件生命周期方法。\x3c\/li\x3e\n\x3cli\x3e然后React计算\x3ccode\x3erender\x3c\/code\x3e方法（虚拟DOM节点）的输出。\x3c\/li\x3e\n\x3cli\x3e由于这是React渲染元素的第一次，React将与浏览器进行通信（代表我们使用DOM API）来显示元素。 这个过程通常被称为挂载。\x3c\/li\x3e\n\x3cli\x3e然后，React调用另一个生命周期方法，称为\x3ccode\x3ecomponentDidMount\x3c\/code\x3e。 我们可以使用这种方法做一些事情，例如，在DOM上做一些我们现在知道在浏览器中支持处理的东西。 在此生命周期方法之前，我们处理的DOM全部是虚拟的。\x3c\/li\x3e\n\x3cli\x3e一些组件故事在这里结束。 出于各种原因，其他组件可以从浏览器DOM中解除挂载。 在后一种情况发生之前，React调用另一个生命周期方法\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e任何已挂载元件的状态可能会改变。 该元素的父代可能会重新呈现。 在任一种情况下，安装的元件可能会接收不同的\x3ccode\x3eprops\x3c\/code\x3e。 这里的魔法发生了，我们现在开始需要React了！ 在此之前，我们完全不需要做任何事情\x3c\/li\x3e\n\x3cli\x3e这个组件的故事继续下去，但在之前，我们需要了解我所说的这个状态。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e7: React组件有一个私有状态\x3c\/h1\x3e\n\x3cp\x3e以下也仅适用于类组件。 有没有人提到有些人把只做展现的组件叫做哑巴？\x3c\/p\x3e\n\x3cp\x3e状态类字段是任何React类组件中的特殊字段。 React监视每个组件状态以进行更改。 但是对于React要有效地执行这些操作，我们必须通过另一个需要学习的React API函数来更改state字段，\x3ccode\x3ethis.setState\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Example 13 -  the setState API\n\/\/ https:\/\/jscomplete.com\/repl?j=H1fek2KH-\nclass CounterButton extends React.Component {\n  state = {\n    clickCounter: 0,\n    currentTimestamp: new Date(),\n  };\n  \n  handleClick = () =\x3e {\n    this.setState((prevState) =\x3e {\n     return { clickCounter: prevState.clickCounter \x2b 1 };\n    });\n  };\n  \n  componentDidMount() {\n   setInterval(() =\x3e {\n     this.setState({ currentTimestamp: new Date() })\n    }, 1000);\n  }\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cbutton onClick={this.handleClick}\x3eClick\x3c\/button\x3e\n        \x3cp\x3eClicked: {this.state.clickCounter}\x3c\/p\x3e\n        \x3cp\x3eTime: {this.state.currentTimestamp.toLocaleString()}\x3c\/p\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\n\/\/ Use it\nReactDOM.render(\x3cCounterButton \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Example 13 -  the setState API\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/jscomplete.com\/repl?j=H1fek2KH-\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounterButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    \x3cspan class=\x22hljs-attr\x22\x3eclickCounter\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ecurrentTimestamp\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e(),\n  };\n  \n  handleClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprevState\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n     \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3eclickCounter\x3c\/span\x3e: prevState.clickCounter \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e };\n    });\n  };\n  \n  componentDidMount() {\n   setInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3ecurrentTimestamp\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e() })\n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eClick\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eClicked: {this.state.clickCounter}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eTime: {this.state.currentTimestamp.toLocaleString()}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    );\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use it\x3c\/span\x3e\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounterButton\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, mountNode);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是了解\x3ccode\x3estate\x3c\/code\x3e最重要的例子。 它将完善您对React交互方式的基础知识。 在这个例子之后，还有一些你需要学习的小事情，但是从这一点来看，它主要是你和你的JavaScript技能。\x3c\/p\x3e\n\x3cp\x3e我们来看一下实例13，从类字段开始。 它有两个。 特殊状态字段被初始化为一个对象，该对象包含起始值为0的\x3ccode\x3eclickCounter\x3c\/code\x3e，以及起始值为\x3ccode\x3enew Date()\x3c\/code\x3e的\x3ccode\x3ecurrentTimestamp\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e第二个类字段是一个\x3ccode\x3ehandleClick\x3c\/code\x3e函数，我们传递给render方法中的button元素的\x3ccode\x3eonClick\x3c\/code\x3e事件。 \x3ccode\x3ehandleClick\x3c\/code\x3e方法使用\x3ccode\x3esetState\x3c\/code\x3e修改此组件实例状态。 注意到这一点。\x3c\/p\x3e\n\x3cp\x3e我们在\x3ccode\x3ecomponentDidMount\x3c\/code\x3e生命周期方法内部启动的间隔定时器中修改状态。 它每秒钟打勾并执行调用\x3ccode\x3ethis.setState\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在render方法中，我们使用了正常读取语法对state两个属性的读取。 没有特殊的API。\x3c\/p\x3e\n\x3cp\x3e现在，请注意，我们使用两种不同的方式更新了状态：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e传递返回一个对象的函数。 我们\x3ccode\x3ehandleClick\x3c\/code\x3e函数中实现了这部分内容。\x3c\/li\x3e\n\x3cli\x3e通过传递一个常规对象。 我们在间隔回调中实现了。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这两种方式都是可以接受的，但是当您同时读取和写入状态时，第一个是首选的（我们这样做）。 在间隔回调之内，我们只写给状态，而不是读取它。 当两难时，始终使用第一个函数参数语法。 它更加安全，因为\x3ccode\x3esetState\x3c\/code\x3e实际上是一个异步方法。\x3c\/p\x3e\n\x3cp\x3e我们如何更新状态？ 我们返回一个包含我们要更新的值的对象。 注意在两次调用\x3ccode\x3esetState\x3c\/code\x3e中，我们只是从\x3ccode\x3estate\x3c\/code\x3e字段传递一个属性，而不是两者。 这是完全可以的，因为\x3ccode\x3esetState\x3c\/code\x3e实际上将您传递的内容（函数参数的返回值）与现有状态合并。 因此，在调用\x3ccode\x3esetState\x3c\/code\x3e时不指定属性意味着我们不希望更改该属性（而不是删除它）。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3e8:React是可以响应的\x3c\/h1\x3e\n\x3cp\x3eReact从它对状态变化做出响应的事实（虽然不是反应性的，而是按计划进行）而得名。 有一个笑话，反应应该被命名为Schedule！\x3c\/p\x3e\n\x3cp\x3e然而，当任何组件的状态被更新时，我们用肉眼看到的是React对该更新做出反应，并自动反映浏览器DOM中的更新（如果需要）。\x3c\/p\x3e\n\x3cp\x3e将render函数输入视为两者\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从父元素得到\x3ccode\x3eprops\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e可以随时更新的内部私有状态\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e当渲染功能的输入变化时，其输出可能会改变。\x3c\/p\x3e\n\x3cp\x3eReact保留了渲染历史的记录，当它看到一个渲染与前一个渲染不同时，它将计算它们之间的差异，并将其有效地转换为在DOM中执行的实际DOM操作。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e9: React是你的代理\x3c\/h1\x3e\n\x3cp\x3e您可以将React视为我们聘请的与浏览器通信的代理。 以上面的当前时间戳显示为例。 我们不是手动去浏览器并调用DOM API操作来每秒查找和更新p＃timestamp元素，而是在组件状态上更改了一个属性，而React代表我们与浏览器进行通信。 我相信这是真正受欢迎的真正原因。 我们讨厌浏览器（domApi很繁琐），React自愿为我们做所有对接工作，免费！\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e10: 每个React组件都有一个故事（第2部分）\x3c\/h1\x3e\n\x3cp\x3e现在我们知道一个组件的状态，以及当这个状态改变了一些魔法的时候，让我们来学习关于该过程的最后几个概念。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e组件可能需要在其状态更新时重新呈现，或者当其父级决定更改传递给组件的\x3ccode\x3eprops\x3c\/code\x3e时，该组件可能需要重新呈现\x3c\/li\x3e\n\x3cli\x3e如果后者发生，React会调用另一个生命周期方法\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e如果状态对象或传入\x3ccode\x3eprops\x3c\/code\x3e被更改，则React有一个重要的决定。 组件应该在DOM中更新吗？ 这就是为什么它在这里调用另一个重要的生命周期方法，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。 这个方法是一个实际的问题，所以如果你需要自己定制或优化渲染过程，你必须通过返回true或false来回答这个问题。\x3c\/li\x3e\n\x3cli\x3e如果没有指定\x3ccode\x3ecustomComponentUpdate\x3c\/code\x3e，React默认是一个非常聪明的事情，在大多数情况下实际上足够好。\x3c\/li\x3e\n\x3cli\x3e首先，React在此时调用另一个生命周期方法\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e。 然后React将计算新的渲染输出并将其与最后渲染的输出进行比较。\x3c\/li\x3e\n\x3cli\x3e如果渲染的输出完全一样，React什么都不做。\x3c\/li\x3e\n\x3cli\x3e如果存在差异，则React会将这些差异映射到浏览器内。\x3c\/li\x3e\n\x3cli\x3e无论如何，由于更新过程无论如何（即使输出完全相同），React会调用最终的生命周期方法\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e生命周期方法实际上是舱口。 如果你没有做任何事情，你可以创建没有他们的完整的应用程序。 他们可以用来非常方便地分析应用程序中发生的情况，并进一步优化了React更新的性能。\x3c\/p\x3e\n\x3cp\x3e根据以上学到的东西（或其中的一部分，真的），您就可以开始创建一些有趣的React应用程序。 如果您渴望了解更多信息，\x3ca href=\x22https:\/\/www.pluralsight.com\/courses\/react-js-getting-started\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e请访问我们的Plactsight的React.js课程入门\x3c\/a\x3e：\x3c\/p\x3e\n\x3cp\x3e翻译自All the fundamental React.js concepts, jammed into this single Medium article\x3c\/p\x3e\n\x3cp\x3e关注我的公众号，更多优质文章定时推送\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVVbe2?w=344\x26amp;h=344\x22 src=\x22https:\/\/static.alili.tech\/img\/bVVbe2?w=344\x26amp;h=344\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一篇包含了react所有基本点的文章</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011205580">https://segmentfault.com/a/1190000011205580</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xsyk6re8i2e/" target="_blank">https://alili.tech/archive/xsyk6re8i2e/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>