<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Javascript面向对象与继承"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Javascript面向对象与继承 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/y3r38u85mr/",
				"appid": "1613049289050283", 
				"title": "Javascript面向对象与继承 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-07T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/poy0x6ik3c/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ug8mmfb7zk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&text=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&text=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&title=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&is_video=false&description=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&title=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&title=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&title=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy3r38u85mr%2f&title=Javascript%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%bb%a7%e6%89%bf"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Javascript面向对象与继承</h1><div class="meta"><div class="postdate"><time datetime="2018-12-07" itemprop="datePublished">2018-12-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e众所周知，Javascript是一门面向对象的语言，如果说针对面向对象来发问的话，我会想到两个问题，在js中，类与实例对象是如何创建的，类与实例对象又是如何实现继承的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e面向对象\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e如何声明一个类\x3c\/h3\x3e\n\x3cp\x3eES5中，还没有类的概念，而是通过函数来声明；到了ES6，有了class关键字，则通过class来声明\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      \/\/ 类的声明\n      var Animal = function () {\n          this.name = \x27Animal\x27;\n      };\n\n      \n      \/\/ es6中class的声明\n      class Animal2 {\n          constructor () {\n              this.name = \x27Animal2\x27;\n          }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类的声明\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Animal\x27\x3c\/span\x3e;\n      };\n\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6中class的声明\x3c\/span\x3e\n      \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal2\x3c\/span\x3e \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n              \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Animal2\x27\x3c\/span\x3e;\n          }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e如何创建对象\x3c\/h3\x3e\n\x3cp\x3e1.字面量对象\x3cbr\x3e2.显示的构造函数\x3cbr\x3e3.Object.create\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      \/\/ 第一种方式：字面量\n      var o1 = {name: \x27o1\x27};\n      var o2 = new Object({name: \x27o2\x27});\n      \/\/ 第二种方式：构造函数\n      var M = function (name) { this.name = name; };\n      var o3 = new M(\x27o3\x27);\n      \/\/ 第三种方式：Object.create\n      var p = {name: \x27p\x27};\n      var o4 = Object.create(p);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一种方式：字面量\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o1 = {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27o1\x27\x3c\/span\x3e};\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e({\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27o2\x27\x3c\/span\x3e});\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二种方式：构造函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e M = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name; };\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e M(\x3cspan class=\x22hljs-string\x22\x3e\x27o3\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第三种方式：Object.create\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27p\x27\x3c\/span\x3e};\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o4 = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(p);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e类与继承\x3c\/h2\x3e\n\x3cp\x3e如何实现继承?\x3cbr\x3e\x3cstrong\x3e继承的本质就是原型链\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e借助构造函数实现继承\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      \/**\n       * 借助构造函数实现继承\n       *\/\n      function Parent1 () {\n          this.name = \x27parent1\x27;\n      }\n      Parent1.prototype.say = function () {\n\n      };\n      function Child1 () {\n          Parent1.call(this); \/\/ 或Parent1.apply(this,arguments)\n          this.type = \x27child1\x27;\n      }\n      console.log(new Child1(), new Child1().say());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/**\n       * 借助构造函数实现继承\n       *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27parent1\x27\x3c\/span\x3e;\n      }\n      Parent1.prototype.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n      };\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          Parent1.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或Parent1.apply(this,arguments)\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x27child1\x27\x3c\/span\x3e;\n      }\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child1(), \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child1().say());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重点是这句：Parent1.call(this); 在子类的构造函数里执行父类的构造函数，通过call\/apply改变this指向，从而导致父类构造函数执行时的这些属性都会挂载到子类实例上去。\x3cbr\x3e问题： 只能继承父类构造函数中声明的实例属性，并没有继承父类原型的属性和方法\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e借助原型链实现继承\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      \/**\n       * 借助原型链实现继承\n       *\/\n      function Parent2 () {\n          this.name = \x27parent2\x27;\n          this.play = [1, 2, 3];\n      }\n      function Child2 () {\n          this.type = \x27child2\x27;\n      }\n      Child2.prototype = new Parent2();\n\n      var s1 = new Child2();\n      var s2 = new Child2();\n      console.log(s1.play, s2.play);\n      s1.play.push(4);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/**\n       * 借助原型链实现继承\n       *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent2\x3c\/span\x3e \x3c\/span\x3e() {\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27parent2\x27\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.play = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n      }\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild2\x3c\/span\x3e \x3c\/span\x3e() {\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x27child2\x27\x3c\/span\x3e;\n      }\n      Child2.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eParent2\x3c\/span\x3e();\n\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eChild2\x3c\/span\x3e();\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eChild2\x3c\/span\x3e();\n      console.log(s1.play, s2.play);\n      s1.play.push(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重点就是这句： Child2.prototype = new Parent2();  就是说 new 一个父类的实例，然后赋给子类的原型 也就是说 new Child2().__proto__ === Child2.prototype === new Parent2()当我们在new Child2()中找不到属性\/方法，顺着原型链就能找到new Parent2()，这样就实现了继承。\x3cbr\x3e问题： 原型链中的原型对象是共用的，子类无法通过父类创建私有属性\x3cbr\x3e比如当你new两个子类s1、s2的时候，改s1的属性，s2的属性也跟着改变\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e组合式继承\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      \/**\n       * 组合方式\n       *\/\n      function Parent3 () {\n          this.name = \x27parent3\x27;\n          this.play = [1, 2, 3];\n      }\n      function Child3 () {\n          Parent3.call(this); \/\/ 父类构造函数执行了\n          this.type = \x27child3\x27;\n      }\n      Child3.prototype = new Parent3(); \/\/ 父类构造函数执行了\n      var s3 = new Child3(); \n      var s4 = new Child3();\n      s3.play.push(4);\n      console.log(s3.play, s4.play);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e      \x3cspan class=\x22hljs-comment\x22\x3e\/**\n       * 组合方式\n       *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent3\x3c\/span\x3e \x3c\/span\x3e() {\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27parent3\x27\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.play = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n      }\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild3\x3c\/span\x3e \x3c\/span\x3e() {\n          Parent3.call(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 父类构造函数执行了\x3c\/span\x3e\n          \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x27child3\x27\x3c\/span\x3e;\n      }\n      Child3.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eParent3\x3c\/span\x3e(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 父类构造函数执行了\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eChild3\x3c\/span\x3e(); \n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eChild3\x3c\/span\x3e();\n      s3.play.push(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n      console.log(s3.play, s4.play);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组合式就是原型链\x2b构造函数继承，解决了前两种方法的问题，但也有不足：子类实例化时，父类构造函数执行了两次，所以有了下面的组合继承的优化1\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e组合继承的优化1\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n       * 组合继承的优化1\n       * @type {String}\n       *\/\n      function Parent4 () {\n          this.name = \x27parent4\x27;\n          this.play = [1, 2, 3];\n      }\n      function Child4 () {\n          Parent4.call(this);\n          this.type = \x27child4\x27;\n      }\n      Child4.prototype = Parent4.prototype;\n      var s5 = new Child4();\n      var s6 = new Child4();\n      console.log(s5, s6);\n\n      console.log(s5 instanceof Child4, s5 instanceof Parent4);\n      console.log(s5.constructor);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n       * 组合继承的优化1\n       * @type {String}\n       *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent4\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27parent4\x27\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.play = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n      }\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild4\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          Parent4.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x27child4\x27\x3c\/span\x3e;\n      }\n      Child4.prototype = Parent4.prototype;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s5 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child4();\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s6 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child4();\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s5, s6);\n\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s5 \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Child4, s5 \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Parent4);\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s5.constructor);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实就是把原型链继承的那句 Child4.prototype = new Parent4(); 改为 Child4.prototype = Parent4.prototype;  这样虽然父类构造函数只执行了一次了，但又有了新的问题： 无法判断s5是Child4的实例还是Parent4的实例  因为Child4.prototype.constructor指向了Parent4的实例；如果直接加一句 Child4.prototype.constructor = Child4  也不行，这样Parent4.prototype.constructor也指向Child4，就无法区分父类实例了。\x3c\/p\x3e\n\x3cblockquote\x3e若要判断a是A的实例  用constructor     \x3cbr\x3e a.__proto__.constructor === A\x3cbr\x3e用instanceof则不准确， instanceof 判断 实例对象的__proto__ 是不是和 构造函数的prototype 是同一个引用。若A 继承 B， B 继承 C  在该原型链上的对象 用instanceof判断都返回ture\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e组合继承的优化2(推荐)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n       * 组合继承的优化2\n       *\/\n      function Parent5 () {\n          this.name = \x27parent5\x27;\n          this.play = [1, 2, 3];\n      }\n      function Child5 () {\n          Parent5.call(this);\n          this.type = \x27child5\x27;\n      }\n      \/\/注意此处,用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝\n      \/\/这个方法作为一个桥梁，达到父类和子类的一个隔离\n      Child5.prototype = Object.create(Parent5.prototype);\n      \/\/修改构造函数指向\n      Child5.prototype.constructor = Child5\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n       * 组合继承的优化2\n       *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent5\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27parent5\x27\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.play = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e];\n      }\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild5\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          Parent5.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x27child5\x27\x3c\/span\x3e;\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/注意此处,用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/这个方法作为一个桥梁，达到父类和子类的一个隔离\x3c\/span\x3e\n      Child5.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Parent5.prototype);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/修改构造函数指向\x3c\/span\x3e\n      Child5.prototype.constructor = Child5\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造函数属性继承和建立子类和父类原型的链接\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eES6实现继承\x3c\/h3\x3e\n\x3cp\x3e引入了class、extends、super关键字，在子类构造函数里调用super()方法来调用父类的构造函数。\x3cbr\x3e在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Child6 extends Parent6 {\n      constructor(x, y, color) {\n        super(x, y); \/\/ 调用父类的constructor(x, y)\n        this.color = color;\n      }\n      toString() {\n        return this.color \x2b \x27 \x27 \x2b super.toString(); \/\/ super代表父类原型，调用父类的toString()\n      }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild6\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent6\x3c\/span\x3e \x3c\/span\x3e{\n      constructor(x, y, color) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(x, y); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用父类的constructor(x, y)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = color;\n      }\n      toString() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color \x2b \x27 \x27 \x2b \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.toString(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ super代表父类原型，调用父类的toString()\x3c\/span\x3e\n      }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eclass实现原理\x3c\/h4\x3e\n\x3cp\x3eClass充当了ES5中构造函数在继承实现过程中的作用\x3cbr\x3e有prototype属性，有__proto__属性，这个属性在ES6中的指向有一些主动的修改。\x3cbr\x3e同时存在两条继承链：一条实现属性继承，一条实现方法继承。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class A extends B {}\nA.__proto__ === B;  \/\/继承属性\nA.prototype.__proto__ === B.prototype;  \/\/继承方法\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e.__proto__ === \x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e.prototype.__proto__ === \x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e.prototype;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承方法\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES6的子类的__proto__是父类，子类的原型的__proto__是父类的原型。\x3cbr\x3e但是在ES5中 A.__proto__是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的__proto__指向父类可以实现属性的继承。\x3c\/p\x3e\n\x3cblockquote\x3e只有函数有prototype属性，只有对象有__proto__属性 ；但函数也有__proto__属性，因为函数也是一个对象，函数的__proto__等于 Function.prototype。\x3c\/blockquote\x3e\n\x3ch4\x3eextends实现原理\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/原型连接\nMan.prototype = Object.create(Person.prototype); \n\/\/ B继承A的静态属性\nObject.setPrototypeOf(Man, Person);\n\/\/绑定this\nPerson.call(this);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\/\/原型连接\n\x3cspan class=\x22hljs-type\x22\x3eMan\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-type\x22\x3ePerson\x3c\/span\x3e.prototype); \n\/\/ \x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e继承\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e的静态属性\n\x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(\x3cspan class=\x22hljs-type\x22\x3eMan\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3ePerson\x3c\/span\x3e);\n\/\/绑定this\n\x3cspan class=\x22hljs-type\x22\x3ePerson\x3c\/span\x3e.call(this);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e前两句实现了原型链上的继承，最后一句实现构造函数上的继承。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Javascript面向对象与继承</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014206021">https://segmentfault.com/a/1190000014206021</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/y3r38u85mr/" target="_blank">https://alili.tech/archive/y3r38u85mr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>