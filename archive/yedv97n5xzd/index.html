<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="解析 Promise 原理，实现一个Promise"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>解析 Promise 原理，实现一个Promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/yedv97n5xzd/",
				"appid": "1613049289050283", 
				"title": "解析 Promise 原理，实现一个Promise | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-31T02:30:29"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/uxg2f7jwqjs/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ivc46de26s/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&text=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&text=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&title=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&is_video=false&description=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&title=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&title=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&title=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyedv97n5xzd%2f&title=%e8%a7%a3%e6%9e%90%20Promise%20%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaPromise"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">解析 Promise 原理，实现一个Promise</h1><div class="meta"><div class="postdate"><time datetime="2018-12-31" itemprop="datePublished">2018-12-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e解析 Promise 原理，实现一个Promise\x3c\/h1\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e概述\x3c\/h3\x3e\n\x3cp\x3e这篇文章旨在解析 Promise的异步实现原理，并且以 ES6中的 Promise 为蓝本实现一个简单的 Promise。\x3c\/p\x3e\n\x3cp\x3e通过自己动手实现一个 Promise 对象，可以熟悉很多可能不知道的 Promise 细节，同时也能对异步的理解更提升一步。\x3c\/p\x3e\n\x3cp\x3e本文假设读者对 Promise 规范有一定理解，并且熟悉 ES6 中的 Promise 基本操作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ePromise 核心\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3ePromise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要）\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ePromise 规范中规定了，promise 的状态只有3种：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3epending\x3c\/li\x3e\n\x3cli\x3efulfilled\x3c\/li\x3e\n\x3cli\x3erejected\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e顾名思义，对上面3个状态的解释就不再赘述，Promise 的状态一旦改变则\x3cstrong\x3e不会再改变\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3ePromise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e具体的规范可以参见：\x3ca href=\x22https:\/\/promisesaplus.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/promisesaplus.com\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eES6 Promise细节\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3ePromise 构造器中必须传入函数，否则会抛出错误。(没有执行器还怎么做异步操作。。。)\x3c\/li\x3e\n\x3cli\x3ePromise.prototype上的 catch(onrejected) 方法是 then(null,onrejected) 的别名,并且会处理链之前的任何的reject。\x3c\/li\x3e\n\x3cli\x3ePromise.prototype 上的 then和 catch 方法总会返回一个\x3cstrong\x3e全新的 Promise 对象\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e如果传入构造器的函数中抛出了错误,该 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。\x3c\/li\x3e\n\x3cli\x3ethen 中的回调如果抛出错误，返回的 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。\x3c\/li\x3e\n\x3cli\x3ethen 中的回调返回值会影响 then 返回的 promise 对象。(下文会具体分析)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这部分内容参考: \x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/promise\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/es6.ruanyifeng.com\/#do...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e动手实现\x3c\/h3\x3e\n\x3cp\x3e做了上面的铺垫，实现一个 Promise 的思路就清晰很多了，本文使用 ES6 来进行实现，暂且把这个类取名为 GPromise吧(不覆盖原生的，便于和原生进行对比测试)。下文中 GPromise 代指将要实现的类，Promise 代指 ES6中的 Promise 类。\x3c\/p\x3e\n\x3ch4\x3e内部属性\x3c\/h4\x3e\n\x3cp\x3e在浏览器中打印出一个 Promise 实例会发现其中会包括两用\x22[[ ]]\x22包裹起来的属性，这是系统内部属性，只有JS 引擎能够访问。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[[PromiseStatus]]\n[[PromiseValue]]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lua\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e[[PromiseStatus]]\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e[[PromiseValue]]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上两个属性分别是 Promise 对象的状态和最终值。\x3c\/p\x3e\n\x3cp\x3e我们自己不能实现内部属性，JS中私有属性特性(#修饰符现在还是提案)暂时也没有支持，所以暂且用\x22_\x22前缀规定私有属性，这样就模拟了Promise 中的两个内部属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class GPromise {\n        constructor(executor) {\n            this._promiseStatus = GPromise.PENDING;\n            this._promiseValue;\n            this.execute(executor);\n        }\n        \n        execute(executor){\n            \/\/...\n        }\n        \n        then(onfulfilled, onrejected){\n            \/\/...\n        }\n    }\n\n    GPromise.PENDING = \x27pedding\x27;\n    GPromise.FULFILLED = \x27resolved\x27;\n    GPromise.REJECTED = \x27rejected\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGPromise\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(executor) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._promiseStatus = GPromise.PENDING;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._promiseValue;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.execute(executor);\n        }\n        \n        execute(executor){\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n        }\n        \n        then(onfulfilled, onrejected){\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n        }\n    }\n\n    GPromise.PENDING = \x3cspan class=\x22hljs-string\x22\x3e\x27pedding\x27\x3c\/span\x3e;\n    GPromise.FULFILLED = \x3cspan class=\x22hljs-string\x22\x3e\x27resolved\x27\x3c\/span\x3e;\n    GPromise.REJECTED = \x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e执行器\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3e传入构造器的executor为函数，并且在构造时就会执行。\x3c\/li\x3e\n\x3cli\x3e我们给 executor 中传入 resolve 和 reject 参数，这两个参数都是函数，用于改变改变 _promiseStatus和 _promiseValue 的值。\x3c\/li\x3e\n\x3cli\x3e并且内部做了捕获异常的操作，一旦传入的executor 函数执行抛出错误，GPromise 实例会变成 rejected状态，即 _promiseStatus赋值为\x27rejected\x27，并且 _promiseValue赋值为Error对象。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  execute(executor) {\n            if (typeof executor != \x27function\x27) {\n                throw new Error(` GPromise resolver ${executor} is not a function`);\n            }\n            \/\/捕获错误\n            try {\n                executor(data =\x3e {\n                    this.promiseStatus = GPromise.FULFILLED;\n                    this.promiseValue = data;\n                }, data =\x3e {\n                    this.promiseStatus = GPromise.REJECTED;\n                    this.promiseValue = data; \n                });\n            } catch (e) {\n                this.promiseStatus = GPromise.REJECTED;\n                this.promiseValue = e;\n            }\n        }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e  execute(executor) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof executor != \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e new Error(` GPromise resolver ${executor} \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e not a function`);\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/捕获错误\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n                executor(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseStatus = GPromise.FULFILLED;\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseValue = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n                }, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseStatus = GPromise.REJECTED;\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseValue = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e; \n                });\n            } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseStatus = GPromise.REJECTED;\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.promiseValue = e;\n            }\n        }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注：Promise 对象在executor 发生错误或者reject 时，如果没有then\x3cbr\x3e或者 catch 来处理，会把错误抛出到外部，也就是会报错。GPromise 实现的是没有向外部抛出错误，只能由then方法处理。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3ethen方法\x3c\/h4\x3e\n\x3ch5\x3e异步实现\x3c\/h5\x3e\n\x3cp\x3ethen 方法内部逻辑稍微复杂点，并且有一点\x3cstrong\x3e一定一定一定\x3c\/strong\x3e要注意到: then 方法中的回调是\x3cstrong\x3e异步执行\x3c\/strong\x3e的，思考下下段代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(1);\nnew Promise((resolve,reject)=\x3e{\n    console.log(2);\n    resolve();\n})\n.then(()=\x3econsole.log(3));\nconsole.log(4);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(resolve,reject)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n    resolve();\n})\n.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e));\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e执行结果是什么呢？答案其实是:\x3cstrong\x3e1 2 4 3\x3c\/strong\x3e。传入Promise 中的执行函数是立即执行完的啊，为什么不是立即执行 then 中的回调呢？因为then 中的回调是异步执行，表示该回调是插入事件队列末尾，在当前的同步任务结束之后，下次事件循环开始时执行队列中的任务。\x3c\/p\x3e\n\x3cp\x3ethen 方法中的难点就是处理异步,其中一个方案是通过 setInterval来监听GPromise 对象的状态改变，一旦改变则执行相应then 中相应的回调函数(onfulfilled和onrejected),这样回调函数就能够插入事件队列末尾，异步执行，实验证明可行，这种方案是最直观也最容易理解的。\x3c\/p\x3e\n\x3ch5\x3ethen 返回值\x3c\/h5\x3e\n\x3cp\x3ethen 方法的返回值是一个新的 GPromise 对象，并且这个对象的状态和 then 中的回调返回值相关，回调指代传入的 onfulfilled 和 rejected。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果 then 中的回调抛出了错误，返回的 GPromise 的 _promiseStatus 赋值为\x27rejected\x27， _promiseValue赋值为抛出的错误对象。\x3c\/li\x3e\n\x3cli\x3e如果回调返回了一个非 GPromise 对象， then返回的 GPromise 的 _promiseStatus 赋值为\x27resolved\x27， _promiseValue赋值为回调的返回值。\x3c\/li\x3e\n\x3cli\x3e如果回调返回了一个 GPromise 对象，then返回的GPromise对象 的_promiseStatus和 _promiseValue 和其保持同步。也就是 then 返回的GPromise记录了回调返回的状态和值，\x3cstrong\x3e不是\x3c\/strong\x3e直接返回回调的返回值。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch5\x3e代码\x3c\/h5\x3e\n\x3cp\x3ethen 方法中的重点逻辑如上，其他参见代码即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  then(onfulfilled, onrejected) {\n            let _ref = null,\n                timer = null,\n                result = new GPromise(() =\x3e {});\n\n            \/\/因为 promise 的 executor 是异步操作,需要监听 promise 对象状态变化，并且不能阻塞线程\n            timer = setInterval(() =\x3e {\n                if ((typeof onfulfilled == \x27function\x27 \x26amp;\x26amp; this._promiseStatus == GPromise.FULFILLED) ||\n                    (typeof onrejected == \x27function\x27 \x26amp;\x26amp; this._promiseStatus == GPromise.REJECTED)) {\n                    \/\/状态发生变化，取消监听\n                    clearInterval(timer);\n                    \/\/捕获传入 then 中的回调的错误，交给 then 返回的 promise 处理\n                    try {\n                        if (this._promiseStatus == GPromise.FULFILLED) {\n                            _ref = onfulfilled(this._promiseValue);\n                        } else {\n                            _ref = onrejected(this._promiseValue);\n                        }\n\n                        \/\/根据回调的返回值来决定 then 返回的 GPromise 实例的状态\n                        if (_ref instanceof GPromise) {\n                            \/\/如果回调函数中返回的是 GPromise 实例，那么需要监听其状态变化，返回新实例的状态是根据其变化相应的\n                            timer = setInterval(()=\x3e{\n                                if (_ref._promiseStatus == GPromise.FULFILLED ||\n                                    _ref._promiseStatus == GPromise.REJECTED) {\n                                    clearInterval(timer);\n                                    result._promiseValue = _ref._promiseValue;\n                                    result._promiseStatus = _ref._promiseStatus;\n                                }\n                            },0);\n                            \n                        } else {\n                            \/\/如果返回的是非 GPromise 实例\n                            result._promiseValue = _ref;\n                            result._promiseStatus = GPromise.FULFILLED;\n                        }\n                    } catch (e) {\n                        \/\/回调中抛出错误的情况\n                        result._promiseStatus = GPromise.REJECTED;\n                        result._promiseValue = e;\n                    }\n                }\n            }, 0);\n            \/\/promise 之所以能够链式操作，因为返回了GPromise对象\n            return result;\n        }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(onfulfilled, onrejected) {\n            let \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e = null,\n                timer = null,\n                result = new GPromise(() =\x26gt; {});\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/因为 promise 的 executor 是异步操作,需要监听 promise 对象状态变化，并且不能阻塞线程\x3c\/span\x3e\n            timer = setInterval(() =\x26gt; {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((\x3cspan class=\x22hljs-built_in\x22\x3etypeof\x3c\/span\x3e onfulfilled == \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; this.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e == GPromise.FULFILLED) ||\n                    (\x3cspan class=\x22hljs-built_in\x22\x3etypeof\x3c\/span\x3e onrejected == \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; this.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e == GPromise.REJECTED)) {\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/状态发生变化，取消监听\x3c\/span\x3e\n                    clearInterval(timer);\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/捕获传入 then 中的回调的错误，交给 then 返回的 promise 处理\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n                        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (this.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e == GPromise.FULFILLED) {\n                            \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e = onfulfilled(this.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e);\n                        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                            \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e = onrejected(this.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e);\n                        }\n\n                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据回调的返回值来决定 then 返回的 GPromise 实例的状态\x3c\/span\x3e\n                        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e instanceof GPromise) {\n                            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果回调函数中返回的是 GPromise 实例，那么需要监听其状态变化，返回新实例的状态是根据其变化相应的\x3c\/span\x3e\n                            timer = setInterval(()=\x26gt;{\n                                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e == GPromise.FULFILLED ||\n                                    \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e == GPromise.REJECTED) {\n                                    clearInterval(timer);\n                                    result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e = \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e;\n                                    result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e = \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e;\n                                }\n                            },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n                            \n                        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果返回的是非 GPromise 实例\x3c\/span\x3e\n                            result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e = \x3cspan class=\x22hljs-variable\x22\x3e_ref\x3c\/span\x3e;\n                            result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e = GPromise.FULFILLED;\n                        }\n                    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n                        \x3cspan class=\x22hljs-comment\x22\x3e\/\/回调中抛出错误的情况\x3c\/span\x3e\n                        result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseStatus\x3c\/span\x3e = GPromise.REJECTED;\n                        result.\x3cspan class=\x22hljs-variable\x22\x3e_promiseValue\x3c\/span\x3e = e;\n                    }\n                }\n            }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/promise 之所以能够链式操作，因为返回了GPromise对象\x3c\/span\x3e\n            return result;\n        }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e测试用例\x3c\/h3\x3e\n\x3cp\x3e是骡子是马，拉出来溜溜。。\x3c\/p\x3e\n\x3cp\x3e测试环境是macOS Sierra 10.12.6，Chrome 60.0.3112.113。\x3c\/p\x3e\n\x3cp\x3e经过以下测试， 证明了GPromise 的基本的异步流程管理和原生 Promise 没有差别。以下测试用例参考了 MDN 中的[Promise\x3cbr\x3eAPI](\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Promise)\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developer.mozilla.org...\x3c\/a\x3e 中的 Advanced Example。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var promiseCount = 0;\n\n    function test(isPromise) {\n        let thisPromiseCount = \x2b\x2bpromiseCount,\n            executor = (resolve, reject) =\x3e {\n                console.log(thisPromiseCount \x2b \x27) Promise started (Async code started)\x27);\n                window.setTimeout(\n                    function () {\n                        resolve(thisPromiseCount);\n                    }, Math.random() * 2000 \x2b 1000);\n            };\n\n        console.log(thisPromiseCount \x2b \x27) Started (Sync code started)\x27);\n\n        let p1 = isPromise ? new Promise(executor) : new GPromise(executor);\n\n        p1.then(\n            function (val) {\n                console.log(val \x2b \x27) Promise fulfilled (Async code terminated)\x27);\n            },\n            function (reason) {\n                console.log(\x27Handle rejected promise (\x27 \x2b reason \x2b \x27) here.\x27);\n            });\n\n        console.log(thisPromiseCount \x2b \x27) Promise made (Sync code terminated)\x27);\n    }\n\n    test();\n    test(true);\n    test();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e promiseCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eisPromise\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e thisPromiseCount = \x2b\x2bpromiseCount,\n            executor = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thisPromiseCount \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27) Promise started (Async code started)\x27\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.setTimeout(\n                    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                        resolve(thisPromiseCount);\n                    }, \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n            };\n\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thisPromiseCount \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27) Started (Sync code started)\x27\x3c\/span\x3e);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p1 = isPromise ? \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(executor) : \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e GPromise(executor);\n\n        p1.then(\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(val \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27) Promise fulfilled (Async code terminated)\x27\x3c\/span\x3e);\n            },\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereason\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Handle rejected promise (\x27\x3c\/span\x3e \x2b reason \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27) here.\x27\x3c\/span\x3e);\n            });\n\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thisPromiseCount \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27) Promise made (Sync code terminated)\x27\x3c\/span\x3e);\n    }\n\n    test();\n    test(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n    test();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么再来测试下链式操作（没有链式操作的 Promise 我要你有何用？），测试结果和 Promise 表现一致。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n    function async1() {\n        return new GPromise(\n            (resolve, reject) =\x3e {\n                console.log(\x27async1 start\x27);\n                setTimeout(() =\x3e {\n                    resolve(\x27async1 finished\x27)\n                }, 1000);\n            }\n        );\n    }\n\n    function async2() {\n        return new GPromise(\n            (resolve, reject) =\x3e {\n                console.log(\x27async2 start\x27);\n                setTimeout(() =\x3e {\n                    resolve(\x27async2 finished\x27)\n                }, 1000);\n            }\n        );\n    }\n\n    function async3() {\n        return new GPromise(\n            (resolve, reject) =\x3e {\n                console.log(\x27async3 start\x27);\n                setTimeout(() =\x3e {\n                    resolve(\x27async3 finished\x27);\n                }, 1000);\n            }\n        );\n    }\n\n    async1()\n        .then(\n            data =\x3e {\n                console.log(data);\n                return async2();\n            })\n        .then(\n            data =\x3e {\n                console.log(data);\n                return async3();\n            }\n        )\n        .then(\n            data =\x3e {\n                console.log(data);\n            }\n        );\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easync1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e GPromise(\n            \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27async1 start\x27\x3c\/span\x3e);\n                setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27async1 finished\x27\x3c\/span\x3e)\n                }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n            }\n        );\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easync2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e GPromise(\n            \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27async2 start\x27\x3c\/span\x3e);\n                setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27async2 finished\x27\x3c\/span\x3e)\n                }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n            }\n        );\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easync3\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e GPromise(\n            \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27async3 start\x27\x3c\/span\x3e);\n                setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27async3 finished\x27\x3c\/span\x3e);\n                }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n            }\n        );\n    }\n\n    async1()\n        .then(\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e async2();\n            })\n        .then(\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e async3();\n            }\n        )\n        .then(\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n            }\n        );\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e到此为止，一个高仿的 Promise 已经实现完成了，它很简单，因为只有一个 then 方法，异步的状态管理由内部完成。\x3c\/p\x3e\n\x3cp\x3e这里并没有实现 catch方法，因为上文也提到了，catch方法就相当于 then(null,onrejected) 。而且 Promise 类上的 race,all，resolve，reject也没有实现，本文旨在理清 Promise 核心原理，篇幅受限（其实就是我懒），其他辅助类的方法等之后有时间再实现。\x3c\/p\x3e\n\x3cp\x3e本文提供的只是一个思路，希望能帮助到你，欢迎大家批评指教。\x3c\/p\x3e\n\x3cp\x3e代码地址:\x3ca href=\x22https:\/\/github.com\/geekinpink\/GPromise\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>解析 Promise 原理，实现一个Promise</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000011241512">https://segmentfault.com/a/1190000011241512</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/yedv97n5xzd/" target="_blank">https://alili.tech/archive/yedv97n5xzd/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>