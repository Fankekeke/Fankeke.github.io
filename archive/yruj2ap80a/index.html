<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/yruj2ap80a/",
				"appid": "1613049289050283", 
				"title": "【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-04T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9dxk2unbmx9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ucsknqcak6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&text=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&text=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&title=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&is_video=false&description=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&title=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&title=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&title=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyruj2ap80a%2f&title=%e3%80%90%e6%95%99%e5%ad%a6%e5%90%91%e3%80%91150%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%95%99%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bd%8e%e9%85%8d%e7%89%88%e7%9a%84MVVM%e5%ba%93%ef%bc%881%ef%bc%89-%20%e5%8e%9f%e7%90%86%e7%af%87"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇</h1><div class="meta"><div class="postdate"><time datetime="2019-01-04" itemprop="datePublished">2019-01-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e适读人群\x3c\/h2\x3e\n\x3cp\x3e本文适合对MVVM有一定了解（如有主流框架ng，vue等使用经验配合本文服用则效果更佳），虽然会用这类框架，但是对框架底层核心实现又不太清楚，或者能说出个所以然，但是让他自己动手写又没有头绪的码友。如果还没听说过MVVM，不妨先收藏着。。。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTflX?w=180\x26amp;h=200\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTflX?w=180\x26amp;h=200\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e名词定义\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e先给低配版的库起一个响亮的名字,以便于开展教学，入乡随俗我们就叫ta -- \x3cstrong\x3eSegmentFault.js\x3c\/strong\x3e 吧 （以下简称\x3cstrong\x3esf.js\x3c\/strong\x3e）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTflT?w=180\x26amp;h=180\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTflT?w=180\x26amp;h=180\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e设置在DOM Element上的自定义属性前缀统一以 \x3cstrong\x3esf-\x3c\/strong\x3e 开头 （如 \x26lt;input type=\x22text\x22 sf-value=\x22xxx\x22\x26gt;）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e为什么是低配版？\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 没有sf-repeat\n2. 不支持select，checkbox，radio等控件的双向绑定\n3. 没有sf-if\n4. 很多都没有\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-bullet\x22\x3e1. \x3c\/span\x3e没有sf-repeat\n\x3cspan class=\x22hljs-bullet\x22\x3e2. \x3c\/span\x3e不支持select，checkbox，radio等控件的双向绑定\n\x3cspan class=\x22hljs-bullet\x22\x3e3. \x3c\/span\x3e没有sf-if\n\x3cspan class=\x22hljs-bullet\x22\x3e4. \x3c\/span\x3e很多都没有\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTfmK?w=178\x26amp;h=188\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTfmK?w=178\x26amp;h=188\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由于是教学向，力图用最简短易读的代码来实现MVVM最主要最基本的功能，故砍掉了部分实现。\x3c\/p\x3e\n\x3cp\x3e先看演示图，图中就是使用sf.js写得DEMO\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTdYX?w=1412\x26amp;h=505\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTdYX?w=1412\x26amp;h=505\x22 alt=\x22演示01\x22 title=\x22演示01\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e100多行的低配版不能要求太多，如果看不上低配版的库，请关闭本教程。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTfmp?w=180\x26amp;h=200\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTfmp?w=180\x26amp;h=200\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e老生常谈\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e什么是双向绑定\x3c\/h3\x3e\n\x3cp\x3e首先明白一个概念，什么是\x3cstrong\x3e双向绑定\x3c\/strong\x3e？在说双向绑定之前，我们先说说\x3cstrong\x3e单向显示\x3c\/strong\x3e。\x3cbr\x3e\x3cstrong\x3e单向显示\x3c\/strong\x3e  说白了就是view动态地显示变量。比如在ng或其它一些主流框架里类似这种写法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/scope.message= \x26quot;segmentfault\x26quot;; \n    \x3ch3 ng-bind=\x26quot;message\x26quot;\x3e\x3c\/h3\x3e \n    \x3c!-- 运行时生成 --\x3e\n    \x3ch3\x3esegmentfault\x3c\/h3\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e    \/\/scope.message= \x22segmentfault\x22; \n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-bind\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 运行时生成 --\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3esegmentfault\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么说是单向呢，因为都是 viewModel上某个变量(message) -\x26gt; view (h3)的一个过程，viewModel上的变量被view所呈现。\x3c\/p\x3e\n\x3cp\x3e再来看看 \x3cstrong\x3e逆向修改\x3c\/strong\x3e\x3cbr\x3e前面说了单向是viewMode-\x26gt;view的过程，那逆向就是 viewModel \x26lt;- view的过程，换句话说就是viewModel被view修改的过程。例如angular中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput type=\x26quot;text\x26quot; ng-model=\x26quot;message\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fsharp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;input \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e ng-model=\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一旦用户在input控件中输入值，便会实时地改变viewModel中message这个变量的值。这是一个view -\x26gt; viewModel 的过程。\x3c\/p\x3e\n\x3cp\x3e所谓的\x3cstrong\x3e双向绑定\x3c\/strong\x3e就是一个 \x3cstrong\x3eviewMode -\x26gt;（显示） view -\x26gt;（修改）viewModel\x3c\/strong\x3e 的过程。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e双向绑定 = 单向显示 \x2b 逆向修改\x3cbr\x3e注意： 单向显示可能发生在所有的类型DOM节点上，而逆向修改只可能发生在INPUT,SELECT,TEXTAREA等交互型控件上。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如果整明白什么是双向绑定了，我们就来谈谈设计思路，没有整明白的同学请再阅读一遍.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e单向显示的设计思路（viewModel -\x26gt; view）\x3c\/h3\x3e\n\x3cp\x3e先看看API的设计\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!-- view --\x3e\n\x3cdiv\x3e\n    \x3ch3 sf-text=\x26quot;vm.message\x26quot;\x3e\x3c\/h3\x3e\n\x3c\/div\x3e\n\n\x3cscript\x3e\n    \/\/ --- viewModel ---\n    function ViewModel(){\n        this.message = \x26quot;segmentfault\x26quot;;\n    }\n    var vm = new ViewModel();\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- view --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esf-text\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22vm.message\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22actionscript\x22\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ --- viewModel ---\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eViewModel\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.message = \x3cspan class=\x22hljs-string\x22\x3e\x22segmentfault\x22\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ViewModel();\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e要实现这个功能，我们的sf库应该需要哪几步操作呢？(先自己想想，独立思考下)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221. 注册ViewModel，我们的库需要知道哪些object是viewModel\n2. 扫描整个DOM Tree找到有哪些DOM节点上被配置了sf-xxxx这个attribute\n3. 纪录这些被单向绑定的DOM节点和viewModel之间的映射关系\n4. 使用DOM API， element.innerText = vm.prop, element.value = vm.prop, element.xxxx = vm.prop 来显示数据\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. 注册ViewModel，我们的库需要知道哪些object是viewModel\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. 扫描整个DOM Tree找到有哪些DOM节点上被配置了sf-xxxx这个attribute\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. 纪录这些被单向绑定的DOM节点和viewModel之间的映射关系\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e. 使用DOM API， element\x3cspan class=\x22hljs-selector-class\x22\x3e.innerText\x3c\/span\x3e = vm\x3cspan class=\x22hljs-selector-class\x22\x3e.prop\x3c\/span\x3e, element\x3cspan class=\x22hljs-selector-class\x22\x3e.value\x3c\/span\x3e = vm\x3cspan class=\x22hljs-selector-class\x22\x3e.prop\x3c\/span\x3e, element\x3cspan class=\x22hljs-selector-class\x22\x3e.xxxx\x3c\/span\x3e = vm\x3cspan class=\x22hljs-selector-class\x22\x3e.prop\x3c\/span\x3e 来显示数据\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e思考题1\x3c\/h4\x3e\n\x3cp\x3eQ：如果我们要单向绑定不是innerText,value 而是作为样式的class，style呢？\x3cbr\x3eA：没错，使用sf-class=\x22vm.myClass\x22 sf-style=\x22vm.myStyle\x22就好了，其它原生属性也以此类推\x3cbr\x3e\x3cstrong\x3e\x22sf-\x22 \x2b native attribute is good!\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e逆向修改的设计思路（viewModel \x26lt;- view）\x3c\/h3\x3e\n\x3cp\x3e主流的一些mvvm框架上一般这么设计API，还是拿angular举例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput type=\x26quot;text\x26quot; ng-model=\x26quot;message\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fsharp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;input \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e ng-model=\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e这里我个人并不认同这种xx-model的命名方式来作为双向绑定的一种标识，比如angular的ng-model，或Vue的v-model，撇开前缀不说，这个model很让人困惑，我们知道input控件是本身就有value这个native的属性的，这个属性就是代表着input输入和输出的值，如果要给一个input进行双向绑定我们应该很自然而然地使用一个 *-value就可以了,完全没有必要弄出一个新的attribute叫做*-model的,从而增加学习成本。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e所以，我们就设计一个叫做sf-value的attribute来做API\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput type=\x26quot;text\x26quot; sf-value=\x26quot;vm.message\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esf\x3c\/span\x3e-value=\x3cspan class=\x22hljs-string\x22\x3e\x22vm.message\x22\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e拍脑袋想想，view要改变数据只可能发生在可以和用户交互的一些html控件上，比如input家族（text, radio, checkbox), select, textarea上。 像h1~hn家族，这辈子是没有机会的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTfnw?w=190\x26amp;h=228\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTfnw?w=190\x26amp;h=228\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e要实现view改写viewModel，我们的库应该需要哪几步操作呢？(也先自己想想，千万不要丢掉独立思考能力)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.扫描整个DOM Tree，找到哪些INPUT，SELECT，TEXTAREA节点上被配置了sf-value这个attribute\n2.纪录这些被双向绑定的DOM节点和viewModel之间的映射关系\n3.sf.js库自动给这个写DOM加上onchange或者oninput的事件监听\n4.一旦监听到change\/input事件，立即获取这个DOM的value值，把这个element.value赋给与之绑定的viewModel的变量上。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3e1.扫描整个DOM Tree，找到哪些INPUT，\x3cspan class=\x22hljs-keyword\x22\x3eSELECT\x3c\/span\x3e，TEXTAREA节点上被配置了sf-\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e这个\x3cspan class=\x22hljs-keyword\x22\x3eattribute\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e纪录这些被双向绑定的DOM节点和viewModel之间的映射关系\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3esf.js库自动给这个写DOM加上onchange或者oninput的事件监听\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e一旦监听到\x3cspan class=\x22hljs-keyword\x22\x3echange\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3einput\x3c\/span\x3e事件，立即获取这个DOM的\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e值，把这个element.value赋给与之绑定的viewModel的变量上。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e思考题2\x3c\/h4\x3e\n\x3cp\x3eQ：那么问题来了，vm.message被input修改了，谁去通知其它同样绑定了vm.message的view呢？\x3cbr\x3eA：请看下一段\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e同步机制\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTfnL?w=240\x26amp;h=164\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTfnL?w=240\x26amp;h=164\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e脏检查大法\x3c\/strong\x3e 这三个字想必大家已经如雷贯耳，我2年多前出去面试的时候被问及最多的就是angular的脏检查，什么是脏检查？angular脏检查的时机是什么？\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e脏检查的原理就是，拷贝一份copy_viewModel在内存中，一旦有用户点击，输入操作，或ajax请求，setInterval，setTimeout等\x3cstrong\x3e这些可能导致viewModel发生改变的行为\x3c\/strong\x3e，框架都会把copy_viewModel和最新的viewModel进行深度比较，一旦发现有属性（如vm.message）发生变化，则重新渲染与message绑定的DOM节点。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这也是为什么，一旦你没有使用ng自带的$http，$interval,$timeout,ng-click这些angular自己封装的API去操作viewModel，angular都不会自动去同步view，因为已经超出他的管辖范围了，你必须手动调用apply函数去强制执行一次脏检查，以同步view。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3esetter大法\x3c\/strong\x3e \x3cbr\x3e听说VUE是使用的这种同步机制，其核心原理就是使用Object.defineProperty(obj, prop, descriptor)（不了解\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/defineProperty\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edefineProperty\x3c\/a\x3e的请戳）这个API，在setter中加点料，一旦有任何地方执行 vm.message = \x22new value\x22语句，则setter都会被调用，由setter去触发重新渲染view的逻辑。\x3c\/p\x3e\n\x3cp\x3e相较这两种同步机制，似乎setter更加轻便，性能更好。所以本文使用了setter的方式来实现同步机制（关键是实现setter机制使用的代码较少）。\x3c\/p\x3e\n\x3ch4\x3e设计思路\x3c\/h4\x3e\n\x3cp\x3e给setter加点料\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTePA?w=2618\x26amp;h=958\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTePA?w=2618\x26amp;h=958\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/jsbin.com\/gosigoh\/edit?js,console\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3c\/a\x3e\x3ca href=\x22http:\/\/jsbin.com\/gosigoh\/edit?js,console\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/jsbin.com\/gosigoh\/edit...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e总体设计图\x3c\/h2\x3e\n\x3cp\x3e所以归纳来说一个MVVM库主要由3块组成\x3cbr\x3e\x3cstrong\x3eMVVM库 = 单向显示 \x2b 逆向修改 \x2b 同步机制\x3c\/strong\x3e\x3cbr\x3e下图为SegmentFault.js的实现机制\x3cbr\x3e其中Renderer负责单向显示和逆向修改，Watcher负责监视viewModel为同步机制的核心模块，\x3cbr\x3eScanner负责sf.js初始化时扫描DOM Tree生成view和viewModel的映射关系。\x3cbr\x3eSegmentFault模块则负责维护view-viewModel Map，以及各个模块间的调度\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVTeUK?w=2306\x26amp;h=1478\x22 src=\x22https:\/\/static.alili.tech\/img\/bVTeUK?w=2306\x26amp;h=1478\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e思考题3\x3c\/h4\x3e\n\x3cp\x3eQ：了解了MVVM的实现机制，你能否自己动手也试着用百来行代码实现一个MVVM库呢？\x3c\/p\x3e\n\x3cp\x3e好了！本教程第一部分设计篇就写到这里，具体coding请移步（\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010752076\x22\x3e下一篇 【教学向】150行代码教你实现一个低配版的MVVM库（2）- 代码篇\x3c\/a\x3e）\x3cbr\x3e我会用Typescript给出一版实现。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e写在最后\x3c\/h3\x3e\n\x3ch4\x3e这篇文章的目的\x3c\/h4\x3e\n\x3cp\x3e2年前写了我受够了angular的笨重，学习曲线陡峭等缺点，自己一怒之下写下一个轻量的MVVM库，给她起名叫【\x3ca href=\x22https:\/\/github.com\/momoko8443\/ukulelejs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUkulele.js\x3c\/a\x3e】（跟我一起念『尤克里里.杰爱死』，当然本文不是这个库的安利文，请安心服用），一开始写这个库出于好玩，后来也加入了越来越多的功能，诸如web component的支持，我渐渐发现，其实要写一个MVVM库也并不是很难，难的是你有没有决心敲下第一行代码。后来我把她和【精通angularjs】一起写在里简历里，然后就去找工作了。面试的时候被问及最多的问题就是：\x22说说MVVM的实现机制\x22。\x3c\/p\x3e\n\x3cp\x3e我今天写下此文，1是希望有机会看到这篇文章的码友能真正掌握MVVM的核心机制，2是鼓励下大家能静下心来，自己动手写写库，写写框架，有些你现在觉得蛮高大上的东西，你仔细一分析，动动脑，真的没有那么高大上，普通的码农也能自己实现\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e相关阅读\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010744960\x22\x3e【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010752076\x22 target=\x22_blank\x22\x3e【教学向】150行代码教你实现一个低配版的MVVM库（2）- 代码篇\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010877602\x22\x3e【教学向】再加150行代码教你实现一个低配版的web component库（1） —设计篇\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010895646\x22 target=\x22_blank\x22\x3e【教学向】再加150行代码教你实现一个低配版的web component库（2） —原理篇\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010744960">https://segmentfault.com/a/1190000010744960</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/yruj2ap80a/" target="_blank">https://alili.tech/archive/yruj2ap80a/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>