<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue：路由实现原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue：路由实现原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/zzbocnd06g/",
				"appid": "1613049289050283", 
				"title": "vue：路由实现原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-12-01T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pdxvpo24yea/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ndpabcigz4/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&text=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&text=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&title=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&is_video=false&description=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&title=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&title=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&title=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzzbocnd06g%2f&title=vue%ef%bc%9a%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue：路由实现原理</h1><div class="meta"><div class="postdate"><time datetime="2018-12-01" itemprop="datePublished">2018-12-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e随着前端应用的业务功能起来越复杂，用户对于使用体验的要求越来越高，单面（\x3ccode\x3eSPA\x3c\/code\x3e）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用的前端路由系统，通过改变\x3ccode\x3eURL\x3c\/code\x3e，在不重新请求页面的情况下，更新页面视图。\x3c\/p\x3e\n\x3cp\x3e更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有\x3ccode\x3e2\x3c\/code\x3e种方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e利用\x3ccode\x3eURL\x3c\/code\x3e中的\x3ccode\x3ehash\x3c\/code\x3e(\x3ccode\x3e\x22#\x22\x3c\/code\x3e);\x3c\/li\x3e\n\x3cli\x3e利用\x3ccode\x3eHistory interface\x3c\/code\x3e在\x3ccode\x3eHTML5\x3c\/code\x3e中新增的方法;\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3evue-router\x3c\/code\x3e是\x3ccode\x3eVue.js\x3c\/code\x3e框架的路由插件，它是通过\x3ccode\x3emode\x3c\/code\x3e这一参数控制路由的实现模式的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const router=new VueRouter({\n    mode:\x27history\x27,\n    routes:[...]\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3econst router=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e VueRouter({\n    \x3cspan class=\x22hljs-keyword\x22\x3emode\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e,\n    route\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e[...]\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建\x3ccode\x3eVueRouter\x3c\/code\x3e的实例对象时，\x3ccode\x3emode\x3c\/code\x3e以构造参数的形式传入。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22src\/index.js\n\nexport default class VueRouter{\n    mode: string; \/\/ 传入的字符串参数，指示history类别\n  history: HashHistory | HTML5History | AbstractHistory; \/\/ 实际起作用的对象属性，必须是以上三个类的枚举\n  fallback: boolean; \/\/ 如浏览器不支持，\x27history\x27模式需回滚为\x27hash\x27模式\n  \n  constructor (options: RouterOptions = {}) {\n    \n    let mode = options.mode || \x27hash\x27 \/\/ 默认为\x27hash\x27模式\n    this.fallback = mode === \x27history\x27 \x26amp;\x26amp; !supportsPushState \/\/ 通过supportsPushState判断浏览器是否支持\x27history\x27模式\n    if (this.fallback) {\n      mode = \x27hash\x27\n    }\n    if (!inBrowser) {\n      mode = \x27abstract\x27 \/\/ 不在浏览器环境下运行需强制为\x27abstract\x27模式\n    }\n    this.mode = mode\n\n    \/\/ 根据mode确定history实际的类并实例化\n    switch (mode) {\n      case \x27history\x27:\n        this.history = new HTML5History(this, options.base)\n        break\n      case \x27hash\x27:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case \x27abstract\x27:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== \x27production\x27) {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n\n  init (app: any \/* Vue component instance *\/) {\n    \n    const history = this.history\n\n    \/\/ 根据history的类别执行相应的初始化操作和监听\n    if (history instanceof HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } else if (history instanceof HashHistory) {\n      const setupHashListener = () =\x3e {\n        history.setupListeners()\n      }\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n\n    history.listen(route =\x3e {\n      this.apps.forEach((app) =\x3e {\n        app._route = route\n      })\n    })\n  }\n\n  \/\/ VueRouter类暴露的以下方法实际是调用具体history对象的方法\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.push(location, onComplete, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.replace(location, onComplete, onAbort)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3esrc\/index.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e VueRouter{\n    mode: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传入的字符串参数，指示history类别\x3c\/span\x3e\n  history: HashHistory | HTML5History | AbstractHistory; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实际起作用的对象属性，必须是以上三个类的枚举\x3c\/span\x3e\n  fallback: \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如浏览器不支持，\x27history\x27模式需回滚为\x27hash\x27模式\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions: RouterOptions = {}\x3c\/span\x3e) {\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e mode = options.mode || \x3cspan class=\x22hljs-string\x22\x3e\x27hash\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认为\x27hash\x27模式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fallback = mode === \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e \x26amp;\x26amp; !supportsPushState \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过supportsPushState判断浏览器是否支持\x27history\x27模式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fallback) {\n      mode = \x3cspan class=\x22hljs-string\x22\x3e\x27hash\x27\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!inBrowser) {\n      mode = \x3cspan class=\x22hljs-string\x22\x3e\x27abstract\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不在浏览器环境下运行需强制为\x27abstract\x27模式\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mode = mode\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据mode确定history实际的类并实例化\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (mode) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HTML5History(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, options.base)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hash\x27\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HashHistory(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, options.base, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fallback)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27abstract\x27\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e AbstractHistory(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, options.base)\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n          assert(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`invalid mode: \x3cspan class=\x22hljs-subst\x22\x3e${mode}\x3c\/span\x3e`\x3c\/span\x3e)\n        }\n    }\n  }\n\n  init (app: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* Vue component instance *\/\x3c\/span\x3e) {\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e history = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据history的类别执行相应的初始化操作和监听\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (history \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (history \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HashHistory) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setupHashListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        history.setupListeners()\n      }\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n\n    history.listen(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.apps.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eapp\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        app._route = route\n      })\n    })\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ VueRouter类暴露的以下方法实际是调用具体history对象的方法\x3c\/span\x3e\n  push (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history.push(location, onComplete, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history.replace(location, onComplete, onAbort)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e作为参数传入的字符串属性\x3ccode\x3emode\x3c\/code\x3e只是一个标记，用来指示实际起作用的对象属性\x3ccode\x3ehistory\x3c\/code\x3e的实现类，两者对应关系：\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    modehistory:\n        \x27history\x27:HTML5History;\n        \x27hash\x27:HashHistory;\n        \x27abstract\x27:AbstractHistory;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-symbol\x22\x3emodehistory:\x3c\/span\x3e\n        \x3cspan class=\x22hljs-string\x22\x3e\x27history\x27\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e:HTML5History\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-string\x22\x3e\x27hash\x27\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e:HashHistory\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-string\x22\x3e\x27abstract\x27\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e:AbstractHistory\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e在初始化对应的\x3ccode\x3ehistory\x3c\/code\x3e之前，会对\x3ccode\x3emode\x3c\/code\x3e做一些校验：若浏览器不支持\x3ccode\x3eHTML5History\x3c\/code\x3e方式(通过\x3ccode\x3esupportsPushState\x3c\/code\x3e变量判断)，则\x3ccode\x3emode\x3c\/code\x3e设为\x3ccode\x3ehash\x3c\/code\x3e;若不是在浏览器环境下运行，则\x3ccode\x3emode\x3c\/code\x3e设为\x3ccode\x3eabstract\x3c\/code\x3e;\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eVueRouter\x3c\/code\x3e类中的\x3ccode\x3eonReady()\x3c\/code\x3e,\x3ccode\x3epush()\x3c\/code\x3e等方法只是一个代理，实际是调用的具体\x3ccode\x3ehistory\x3c\/code\x3e对象的对应方法，在\x3ccode\x3einit()\x3c\/code\x3e方法中初始化时，也是根据\x3ccode\x3ehistory\x3c\/code\x3e对象具体的类别执行不同操作\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e\x3ccode\x3eHashHistory\x3c\/code\x3e\x3c\/h1\x3e\n\x3cp\x3e\x3ccode\x3ehash\x3c\/code\x3e(\x3ccode\x3e\x22#\x22\x3c\/code\x3e)符号的本来作用是加在\x3ccode\x3eURL\x3c\/code\x3e指示网页中的位置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22http:\/\/www.example.com\/index.html#print\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs avrasm\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-symbol\x22\x3ehttp:\x3c\/span\x3e\/\/www.example.com\/index.html\x3cspan class=\x22hljs-meta\x22\x3e#print\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e#\x3c\/code\x3e本身以及它后面的字符称之为\x3ccode\x3ehash\x3c\/code\x3e可通过\x3ccode\x3ewindow.location.hash\x3c\/code\x3e属性读取.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ehash\x3c\/code\x3e虽然出现在\x3ccode\x3eurl\x3c\/code\x3e中，但不会被包括在\x3ccode\x3ehttp\x3c\/code\x3e请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变\x3ccode\x3ehash\x3c\/code\x3e不会重新加载页面。\x3c\/li\x3e\n\x3cli\x3e可以为\x3ccode\x3ehash\x3c\/code\x3e的改变添加监听事件：\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.addEventListener(\x26quot;hashchange\x26quot;,funcRef,false)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22hashchange\x22\x3c\/span\x3e,funcRef,\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e每一次改变\x3ccode\x3ehash\x3c\/code\x3e(\x3ccode\x3ewindow.location.hash\x3c\/code\x3e)，都会在浏览器访问历史中增加一个记录。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e利用\x3ccode\x3ehash\x3c\/code\x3e的以上特点，就可以来实现前端路由\x22更新视图但不重新请求页面\x22的功能了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3ccode\x3eHashHistory.push()\x3c\/code\x3e\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route =\x3e {\n    pushHash(route.fullPath)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3epush (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(location, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    pushHash(route.fullPath)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epushHash\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.location.hash = path\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3etransitionTo()\x3c\/code\x3e方法是父类中定义的是用来处理路由变化中的基础逻辑的，\x3ccode\x3epush()\x3c\/code\x3e方法最主要的是对\x3ccode\x3ewindow\x3c\/code\x3e的\x3ccode\x3ehash\x3c\/code\x3e进行了直接赋值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.location.hash=route.fullPath\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ewindow\x3cspan class=\x22hljs-selector-class\x22\x3e.location\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.hash\x3c\/span\x3e=route.fullPath\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ehash\x3c\/code\x3e的改变会自动添加到浏览器的访问历史记录中。\x3cbr\x3e那么视图的更新是怎么实现的呢，我们来看看父类\x3ccode\x3eHistory\x3c\/code\x3e中的\x3ccode\x3etransitionTo()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const route = this.router.match(location, this.current)\n  this.confirmTransition(route, () =\x3e {\n    this.updateRoute(route)\n    ...\n  })\n}\n\nupdateRoute (route: Route) {\n  \n  this.cb \x26amp;\x26amp; this.cb(route)\n  \n}\n\nlisten (cb: Function) {\n  this.cb = cb\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3etransitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const route = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.router.match(location, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.current)\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.confirmTransition(route, () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.updateRoute(route)\n    ...\n  })\n}\n\nupdateRoute (route: Route) {\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb(route)\n  \n}\n\nlisten (cb: Function) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，当路由变化时，调用了\x3ccode\x3eHitory\x3c\/code\x3e中的\x3ccode\x3ethis.cb\x3c\/code\x3e方法，而\x3ccode\x3ethis.cb\x3c\/code\x3e方法是通过\x3ccode\x3eHistory.listen(cb)\x3c\/code\x3e进行设置的，回到\x3ccode\x3eVueRouter\x3c\/code\x3e类定义中，找到了在\x3ccode\x3einit()\x3c\/code\x3e中对其进行了设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22init (app: any \/* Vue component instance *\/) {\n    \n  this.apps.push(app)\n\n  history.listen(route =\x3e {\n    this.apps.forEach((app) =\x3e {\n      app._route = route\n    })\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3einit (app: any \/* Vue component\x3cspan class=\x22hljs-built_in\x22\x3e instance \x3c\/span\x3e*\/) {\n    \n  this.apps.push(app)\n\n  history.listen(route =\x26gt; {\n    this.apps.forEach((app) =\x26gt; {\n      app._route = route\n    })\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eapp\x3c\/code\x3e为\x3ccode\x3eVue\x3c\/code\x3e组件实例，但是\x3ccode\x3eVue\x3c\/code\x3e作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性\x3ccode\x3e_route\x3c\/code\x3e,如果组件中要有这个属性，应该是在插件加载的地方，即\x3ccode\x3eVueRouter\x3c\/code\x3e的\x3ccode\x3einstall()\x3c\/code\x3e方法中混入\x3ccode\x3eVue\x3c\/code\x3e对象的，\x3ccode\x3einstall.js\x3c\/code\x3e的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function install (Vue) {\n  \n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._router = this.$options.router\n        this._router.init(this)\n        Vue.util.defineReactive(this, \x27_route\x27, this._router.history.current)\n      }\n      registerInstance(this, this)\n    },\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport function install (Vue) {\n  \n  Vue.mixin({\n    beforeCreate () {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.router)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._router = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.router\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._router.init(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n        Vue.util.defineReactive(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27_route\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._router.history.current)\n      }\n      registerInstance(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    },\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过\x3ccode\x3eVue.mixin()\x3c\/code\x3e方法，全局注册一个混合，影响注册之后所有创建的每个\x3ccode\x3eVue\x3c\/code\x3e实例，该混合在\x3ccode\x3ebeforeCreate\x3c\/code\x3e钩子中通过\x3ccode\x3eVue.util.defineReactive()\x3c\/code\x3e定义了响应式的\x3ccode\x3e_route\x3c\/code\x3e属性。所谓响应式属性，即当\x3ccode\x3e_route\x3c\/code\x3e值改变时，会自动调用\x3ccode\x3eVue\x3c\/code\x3e实例的\x3ccode\x3erender()\x3c\/code\x3e方法，更新视图。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$router.push()--\x3eHashHistory.push()--\x3eHistory.transitionTo()--\x3eHistory.updateRoute()--\x3e{app._route=route}--\x3evm.render()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e$router.push\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e--\x26gt;\x3c\/span\x3eHashHistory.push\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e--\x26gt;\x3c\/span\x3eHistory.transitionTo\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e--\x26gt;\x3c\/span\x3eHistory.updateRoute\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e--\x26gt;\x3c\/span\x3e{app._route=route}\x3cspan class=\x22hljs-function\x22\x3e--\x26gt;\x3c\/span\x3evm.render()\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\x3ccode\x3eHashHistory.replace()\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ereplace()\x3c\/code\x3e方法与\x3ccode\x3epush()\x3c\/code\x3e方法不同之处在于，它并不是将新路由添加到浏览器访问历史栈顶，而是替换掉当前的路由：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route =\x3e {\n    replaceHash(route.fullPath)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n  \nfunction replaceHash (path) {\n  const i = window.location.href.indexOf(\x27#\x27)\n  window.location.replace(\n    window.location.href.slice(0, i \x3e= 0 ? i : 0) \x2b \x27#\x27 \x2b path\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3ereplace (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(location, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    replaceHash(route.fullPath)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n  \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereplaceHash\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e i = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.location.href.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.location.replace(\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.location.href.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, i \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ? i : \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e \x2b path\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，它与\x3ccode\x3epush()\x3c\/code\x3e的实现结构基本相似，不同点它不是直接对\x3ccode\x3ewindow.location.hash\x3c\/code\x3e进行赋值，而是调用\x3ccode\x3ewindow.location.replace\x3c\/code\x3e方法将路由进行替换。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e监听地址栏\x3c\/h2\x3e\n\x3cp\x3e上面的\x3ccode\x3eVueRouter.push()\x3c\/code\x3e和\x3ccode\x3eVueRouter.replace()\x3c\/code\x3e是可以在\x3ccode\x3evue\x3c\/code\x3e组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在\x3ccode\x3eHashHistory\x3c\/code\x3e中这一功能通过\x3ccode\x3esetupListeners\x3c\/code\x3e监听\x3cstrong\x3e\x3ccode\x3ehashchange\x3c\/code\x3e\x3c\/strong\x3e实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setupListeners () {\n  window.addEventListener(\x27hashchange\x27, () =\x3e {\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route =\x3e {\n      replaceHash(route.fullPath)\n    })\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3esetupListeners () {\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27hashchange\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!ensureSlash()) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(getHash(), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      replaceHash(route.fullPath)\n    })\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该方法设置监听了浏览器事件\x3ccode\x3ehashchange\x3c\/code\x3e,调用的函数为\x3ccode\x3ereplaceHash\x3c\/code\x3e,即在浏览器地址栏中直接输入路由相当于代码调用了\x3ccode\x3ereplace()\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3e\x3ccode\x3eHTML5History\x3c\/code\x3e\x3c\/h1\x3e\n\x3cp\x3e\x3ccode\x3eHistory interface\x3c\/code\x3e是浏览器历史记录栈提供的接口，通过\x3ccode\x3eback()\x3c\/code\x3e,\x3ccode\x3eforward()\x3c\/code\x3e,\x3ccode\x3ego()\x3c\/code\x3e等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\x3cbr\x3e从\x3ccode\x3eHTML5\x3c\/code\x3e开始，\x3ccode\x3eHistory interface\x3c\/code\x3e提供了2个新的方法：\x3ccode\x3epushState()\x3c\/code\x3e,\x3ccode\x3ereplaceState()\x3c\/code\x3e使得我们可以对浏览器历史记录栈进行修改：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.history.pushState(stateObject,title,url)\nwindow.history,replaceState(stateObject,title,url)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3ewindow.history.pushState(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eObject,title,url)\nwindow.history,replaceState(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eObject,title,url)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3estateObject\x3c\/code\x3e:当浏览器跳转到新的状态时，将触发\x3ccode\x3epopState\x3c\/code\x3e事件，该事件将携带这个\x3ccode\x3estateObject\x3c\/code\x3e参数的副本\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3etitle\x3c\/code\x3e:所添加记录的标题\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eurl\x3c\/code\x3e:所添加记录的\x3ccode\x3eurl\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这\x3ccode\x3e2\x3c\/code\x3e个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前\x3ccode\x3eurl\x3c\/code\x3e改变了，但浏览器不会立即发送请求该\x3ccode\x3eurl\x3c\/code\x3e，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const { current: fromRoute } = this\n  this.transitionTo(location, route =\x3e {\n    pushState(cleanPath(this.base \x2b route.fullPath))\n    handleScroll(this.router, route, fromRoute, false)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\nreplace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const { current: fromRoute } = this\n  this.transitionTo(location, route =\x3e {\n    replaceState(cleanPath(this.base \x2b route.fullPath))\n    handleScroll(this.router, route, fromRoute, false)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\n\/\/ src\/util\/push-state.js\nexport function pushState (url?: string, replace?: boolean) {\n  saveScrollPosition()\n  \/\/ try...catch the pushState call to get around Safari\n  \/\/ DOM Exception 18 where it limits to 100 pushState calls\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, \x27\x27, url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, \x27\x27, url)\n    }\n  } catch (e) {\n    window.location[replace ? \x27replace\x27 : \x27assign\x27](url)\n  }\n}\n\nexport function replaceState (url?: string) {\n  pushState(url, true)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3epush (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { current: fromRoute } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(location, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    pushState(cleanPath(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.base \x2b route.fullPath))\n    handleScroll(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.router, route, fromRoute, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\nreplace (location: RawLocation, onComplete?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e, onAbort?: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { current: fromRoute } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(location, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    replaceState(cleanPath(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.base \x2b route.fullPath))\n    handleScroll(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.router, route, fromRoute, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\n    onComplete \x26amp;\x26amp; onComplete(route)\n  }, onAbort)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/util\/push-state.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epushState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eurl?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, replace?: \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  saveScrollPosition()\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ try...catch the pushState call to get around Safari\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ DOM Exception 18 where it limits to 100 pushState calls\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e history = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.history\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (replace) {\n      history.replaceState({ key: _key }, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, url)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      _key = genKey()\n      history.pushState({ key: _key }, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, url)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.location[replace ? \x3cspan class=\x22hljs-string\x22\x3e\x27replace\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27assign\x27\x3c\/span\x3e](url)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereplaceState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eurl?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  pushState(url, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码结构以及更新视图的逻辑与\x3ccode\x3ehash\x3c\/code\x3e模式基本类似，只不过将对\x3ccode\x3ewindow.location.hash()\x3c\/code\x3e直接进行赋值\x3ccode\x3ewindow.location.replace()\x3c\/code\x3e改为了调用\x3ccode\x3ehistory.pushState()\x3c\/code\x3e和\x3ccode\x3ehistory.replaceState()\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eHTML5History\x3c\/code\x3e中添加对修改浏览器地址栏\x3ccode\x3eURL\x3c\/code\x3e的监听\x3cstrong\x3e\x3ccode\x3epopstate\x3c\/code\x3e\x3c\/strong\x3e是直接在构造函数中执行的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor (router: Router, base: ?string) {\n  \n  window.addEventListener(\x27popstate\x27, e =\x3e {\n    const current = this.current\n    this.transitionTo(getLocation(this.base), route =\x3e {\n      if (expectScroll) {\n        handleScroll(router, route, current, true)\n      }\n    })\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3erouter: Router, base: ?\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x3c\/span\x3e) {\n  \n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27popstate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e current = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.current\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.transitionTo(getLocation(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.base), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eroute\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (expectScroll) {\n        handleScroll(router, route, current, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n      }\n    })\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eHTML5History\x3c\/code\x3e用到了\x3ccode\x3eHTML5\x3c\/code\x3e的新特性，需要浏版本的支持，通过\x3ccode\x3esupportsPushState\x3c\/code\x3e来检查：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22src\/util\/push-state.js\n\nexport const supportsPushState = inBrowser \x26amp;\x26amp; (function () {\n  const ua = window.navigator.userAgent\n\n  if (\n    (ua.indexOf(\x27Android 2.\x27) !== -1 || ua.indexOf(\x27Android 4.0\x27) !== -1) \x26amp;\x26amp;\n    ua.indexOf(\x27Mobile Safari\x27) !== -1 \x26amp;\x26amp;\n    ua.indexOf(\x27Chrome\x27) === -1 \x26amp;\x26amp;\n    ua.indexOf(\x27Windows Phone\x27) === -1\n  ) {\n    return false\n  }\n\n  return window.history \x26amp;\x26amp; \x27pushState\x27 in window.history\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3esrc\/util\/push-state.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e supportsPushState = inBrowser \x26amp;\x26amp; (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ua = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.navigator.userAgent\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n    (ua.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27Android 2.\x27\x3c\/span\x3e) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e || ua.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27Android 4.0\x27\x3c\/span\x3e) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) \x26amp;\x26amp;\n    ua.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27Mobile Safari\x27\x3c\/span\x3e) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e \x26amp;\x26amp;\n    ua.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27Chrome\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e \x26amp;\x26amp;\n    ua.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27Windows Phone\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e\n  ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.history \x26amp;\x26amp; \x3cspan class=\x22hljs-string\x22\x3e\x27pushState\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.history\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上就是\x3ccode\x3ehash\x3c\/code\x3e模式与\x3ccode\x3ehistory\x3c\/code\x3e模式源码导读，这\x3ccode\x3e2\x3c\/code\x3e种模式都是通过浏览器接口实现的，除此之外，\x3ccode\x3evue-router\x3c\/code\x3e还为非浏览器环境准备了一个\x3ccode\x3eabstract\x3c\/code\x3e模式，其原理为用一个数组\x3ccode\x3estack\x3c\/code\x3e模拟出浏览器历史记录栈的功能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e两种模式比较\x3c\/h2\x3e\n\x3cp\x3e一般的需求场景中，\x3ccode\x3ehash\x3c\/code\x3e模式与\x3ccode\x3ehistory\x3c\/code\x3e模式是差不多的，根据\x3ccode\x3eMDN\x3c\/code\x3e的介绍，调用\x3ccode\x3ehistory.pushState()\x3c\/code\x3e相比于直接修改\x3ccode\x3ehash\x3c\/code\x3e主要有以下优势：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3epushState\x3c\/code\x3e设置的新\x3ccode\x3eurl\x3c\/code\x3e可以是与当前\x3ccode\x3eurl\x3c\/code\x3e同源的任意\x3ccode\x3eurl\x3c\/code\x3e,而\x3ccode\x3ehash\x3c\/code\x3e只可修改\x3ccode\x3e#\x3c\/code\x3e后面的部分，故只可设置与当前同文档的\x3ccode\x3eurl\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epushState\x3c\/code\x3e设置的新\x3ccode\x3eurl\x3c\/code\x3e可以与当前\x3ccode\x3eurl\x3c\/code\x3e一模一样，这样也会把记录添加到栈中，而\x3ccode\x3ehash\x3c\/code\x3e设置的新值必须与原来不一样才会触发记录添加到栈中\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epushState\x3c\/code\x3e通过\x3ccode\x3estateObject\x3c\/code\x3e可以添加任意类型的数据记录中，而\x3ccode\x3ehash\x3c\/code\x3e只可添加短字符串\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3epushState\x3c\/code\x3e可额外设置\x3ccode\x3etitle\x3c\/code\x3e属性供后续使用\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e\n\x3ccode\x3ehistory\x3c\/code\x3e模式的问题\x3c\/h2\x3e\n\x3cp\x3e对于单页应用来说，理想的使用场景是仅在进入应用时加载\x3ccode\x3eindex.html\x3c\/code\x3e，后续在的网络操作通过\x3ccode\x3eajax\x3c\/code\x3e完成，不会根据\x3ccode\x3eurl\x3c\/code\x3e重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载等特殊情况。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ehash\x3c\/code\x3e模式仅改变\x3ccode\x3ehash\x3c\/code\x3e部分的内容，而\x3ccode\x3ehash\x3c\/code\x3e部分是不会包含在\x3ccode\x3ehttp\x3c\/code\x3e请求中的(\x3ccode\x3ehash\x3c\/code\x3e带\x3ccode\x3e#\x3c\/code\x3e)：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22http:\/\/oursite.com\/#\/user\/id \/\/如请求，只会发送http:\/\/oursite.com\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ehttp:\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eoursite.com\x3cspan class=\x22hljs-regexp\x22\x3e\/#\/u\x3c\/span\x3eser\x3cspan class=\x22hljs-regexp\x22\x3e\/id \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/如请求，只会发送http:\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/oursite.com\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以\x3ccode\x3ehash\x3c\/code\x3e模式下遇到根据\x3ccode\x3eurl\x3c\/code\x3e请求页面不会有问题\x3c\/p\x3e\n\x3cp\x3e而\x3ccode\x3ehistory\x3c\/code\x3e模式则将\x3ccode\x3eurl\x3c\/code\x3e修改的就和正常请求后端的\x3ccode\x3eurl\x3c\/code\x3e一样(\x3ccode\x3ehistory\x3c\/code\x3e不带\x3ccode\x3e#\x3c\/code\x3e)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22http:\/\/oursite.com\/user\/id\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ehttp:\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3eoursite.com\x3cspan class=\x22hljs-regexp\x22\x3e\/user\/i\x3c\/span\x3ed\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果这种向后端发送请求的话，后端没有配置对应\x3ccode\x3e\/user\/id\x3c\/code\x3e的\x3ccode\x3eget\x3c\/code\x3e路由处理,会返回\x3ccode\x3e404\x3c\/code\x3e错误。\x3c\/p\x3e\n\x3cp\x3e官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 \x3ccode\x3eURL\x3c\/code\x3e 匹配不到任何静态资源，则应该返回同一个 \x3ccode\x3eindex.html\x3c\/code\x3e 页面，这个页面就是你 \x3ccode\x3eapp\x3c\/code\x3e 依赖的页面。同时这么做以后，服务器就不再返回 \x3ccode\x3e404\x3c\/code\x3e 错误页面，因为对于所有路径都会返回 \x3ccode\x3eindex.html\x3c\/code\x3e 文件。为了避免这种情况，在 \x3ccode\x3eVue\x3c\/code\x3e 应用里面覆盖所有的路由情况，然后在给出一个 \x3ccode\x3e404\x3c\/code\x3e 页面。或者，如果是用 \x3ccode\x3eNode.js\x3c\/code\x3e 作后台，可以使用服务端的路由来匹配 \x3ccode\x3eURL\x3c\/code\x3e，当没有匹配到路由的时候返回 \x3ccode\x3e404\x3c\/code\x3e，从而实现 \x3ccode\x3efallback\x3c\/code\x3e。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue：路由实现原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000014822765">https://segmentfault.com/a/1190000014822765</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/zzbocnd06g/" target="_blank">https://alili.tech/archive/zzbocnd06g/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/hvvo3rmt3dj/">JS打包工具rollup——完全入门指南<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/semhn25oasq/">Spring Boot [基于Spring Boot 与 Vue的后台脚手架] SanJi Boot Security<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/t1iml4tjj7r/">WebGL入门demo<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/8gbs1y0r0ns/">[面试专题]一线互联网大厂面试总结<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/4os59l0zeel/">react&#43;react-router4&#43;redux最新版构建分享<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/dznv6a9ewcj/">react虚拟dom机制与diff算法<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/myiqarfowok/">一套Vue的单页模板：N3-admin<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/2eeweuxgjbk/">使用 json-server 搭建 api mock 服务 (一)<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/h7cszygcoqq/">使用Ionic3框架开始第一个混合开发APP<aside class="dates">2019-01-04</aside></a></li><li><a href="/archive/g8by6kv9q8t/">如何只用 CSS 完成漂亮的加载<aside class="dates">2019-01-04</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>